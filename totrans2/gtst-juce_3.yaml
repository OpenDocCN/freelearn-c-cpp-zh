- en: Chapter 3. Essential Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。基本数据结构
- en: 'JUCE includes a range of important data structures, many of which could be
    seen as replacements for some of the standard library classes. This chapter introduces
    the essential classes for JUCE development. In this chapter we will cover the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 包含了一系列重要的数据结构，其中许多可以被视为标准库类的一些替代品。本章介绍了 JUCE 开发所必需的类。在本章中，我们将涵盖以下主题：
- en: Understanding the numerical types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数值类型
- en: Specifying and manipulating strings of text using the `String` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `String` 类指定和操作文本字符串
- en: Measuring and displaying time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量和显示时间
- en: Specifying file paths in a cross-platform manner using the `File` class (including
    access to the user's home space, the `Desktop` and `Documents` locations)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `File` 类以跨平台方式指定文件路径（包括对用户主目录、桌面和文档位置的访问）
- en: 'Using dynamically allocated arrays: the `Array` class'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分配的数组：`Array` 类
- en: Employing smart pointer classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能指针类
- en: By the end of this chapter, you will be able to create and manipulate data in
    a range of JUCE's essential classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建和操作 JUCE 的基本类中的数据。
- en: Understanding the numerical types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数值类型
- en: 'The word size of some the basic data types (`char`, `int`, `long`, and so on)
    varies across platforms, compilers, and CPU architectures. A good example is the
    type `long`. In Xcode on Mac OS X, `long` is 32 bits wide when compiling 32-bit
    code and 64 bits wide when compiling 64-bit code. In Microsoft Visual Studio on
    Windows, `long` is always 32 bits wide. (The same applies to the unsigned versions
    too.) JUCE defines a handful of primitive types to assist the writing of platform-independent
    code. Many of these have familiar names and may be the same names used in other
    libraries and frameworks in use by your code. These types are defined in the `juce`
    namespace; therefore, can be disambiguated using the `juce::` prefix if necessary.
    These primitive types are: `int8` (8-bit signed integer), `uint8` (8-bit unsigned
    integer), `int16` (16-bit signed integer), `uint16` (16-bit unsigned integer),
    `int32` (32-bit signed integer), `uint32` (32-bit unsigned integer), `int64` (64-bit
    signed integer), `uint64` (64-bit unsigned integer), `pointer_sized_int` (a signed
    integer that is the same word size as a pointer on the platform), `pointer_sized_uint`
    (an unsigned integer that is the same word size as a pointer on the platform),
    and `juce_wchar` (a 32-bit Unicode character type).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本数据类型（如 `char`、`int`、`long` 等）的字长在不同的平台、编译器和 CPU 架构中是不同的。一个很好的例子是 `long`
    类型。在 Mac OS X 的 Xcode 中，当编译 32 位代码时，`long` 是 32 位宽，而当编译 64 位代码时，`long` 是 64 位宽。在
    Windows 的 Microsoft Visual Studio 中，`long` 总是 32 位宽。（同样适用于无符号版本。）JUCE 定义了一些原始类型来帮助编写平台无关的代码。许多这些类型都有熟悉的名字，并且可能与你的代码中使用的其他库和框架中使用的名字相同。这些类型在
    `juce` 命名空间中定义；因此，如果需要，可以使用 `juce::` 前缀来消除歧义。这些原始类型包括：`int8`（8 位有符号整数）、`uint8`（8
    位无符号整数）、`int16`（16 位有符号整数）、`uint16`（16 位无符号整数）、`int32`（32 位有符号整数）、`uint32`（32
    位无符号整数）、`int64`（64 位有符号整数）、`uint64`（64 位无符号整数）、`pointer_sized_int`（与平台上的指针具有相同字长的有符号整数）、`pointer_sized_uint`（与平台上的指针具有相同字长的无符号整数），以及
    `juce_wchar`（32 位 Unicode 字符类型）。
- en: In many cases the built-in types are sufficient. For example, JUCE internally
    makes use of the `int` data type for a number of purposes, but the preceding types
    are available where the word size is critical. In addition to this, JUCE does
    not define special data types for `char`, `float`, or `double`. Both floating-point
    types are assumed to be compliant with IEEE 754, and the `float` data type is
    assumed to be 32 bits wide and the `double` data type 64 bits wide.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，内置类型是足够的。例如，JUCE 在内部使用 `int` 数据类型用于许多目的，但前面的类型在字长至关重要时可用。此外，JUCE 没有为
    `char`、`float` 或 `double` 定义特殊的数据类型。两种浮点类型都假定符合 IEEE 754 标准，并且假定 `float` 数据类型是
    32 位宽，`double` 数据类型是 64 位宽。
- en: 'One final utility in this regard addresses the issue that writing 64-bit literals
    in code differs across compilers. The `literal64bit()` macro can be used to write
    such literals if needed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方面，一个最终的实用工具解决了代码中编写 64 位字面量在不同编译器中存在差异的问题。如果需要，可以使用 `literal64bit()` 宏来编写这样的字面量：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JUCE also declares some basic template types for defining certain geometry;
    the `Component` class uses these in particular. Some useful examples are `Point<ValueType>`,
    `Line<ValueType>`, and `Rectangle<ValueType>`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 还声明了一些基本的模板类型，用于定义某些几何形状；`Component` 类特别使用这些类型。一些有用的例子是 `Point<ValueType>`、`Line<ValueType>`
    和 `Rectangle<ValueType>`。
- en: Specifying and manipulating text strings
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定和操作文本字符串
- en: In JUCE, text is generally manipulated using the `String` class. In many ways,
    this class may be seen as an alternative to the C++ Standard Library `std::string`
    class. We have already used the `String` class for the basic operations in earlier
    chapters. For example, in [Chapter 2](ch02.html "Chapter 2. Building User Interfaces"),
    *Building User Interfaces*, strings were used to set the text appearing on a `TextButton`
    object and used to store a dynamically changing string to display in response
    to mouse activity. Even though these examples were quite simple, they harnessed
    the power of the `String` class to make setting and manipulating the strings straightforward
    for the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUCE中，文本通常使用`String`类进行操作。在许多方面，这个类可以被视为C++标准库`std::string`类的替代品。我们已经在早期章节中使用了`String`类进行基本操作。例如，在[第2章](ch02.html
    "第2章。构建用户界面")中，*构建用户界面*，字符串被用来设置`TextButton`对象上显示的文本，并用来存储在鼠标活动响应中显示的动态变化的字符串。尽管这些例子相当简单，但它们利用了`String`类的力量，使得对用户来说设置和操作字符串变得简单直接。
- en: The first way this is achieved is through storing strings using **reference
    counted** objects. That is to say, when a string is created, behind the scenes
    JUCE allocates some memory for the string, stores the string, and returns a `String`
    object that refers to this allocated memory in the background. Straight copies
    of this string (that is, without any modifications) are simply new `String` objects
    that refer to this same shared memory. This helps keep code efficient by allowing
    `String` objects to be passed by value between functions, without the potential
    overhead of copying large chunks of memory in the process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的第一种方式是通过使用**引用计数**的对象来存储字符串。也就是说，当创建一个字符串时，在幕后JUCE为该字符串分配了一些内存，存储了该字符串，并返回一个指向该分配内存的`String`对象。这个字符串的直拷贝（即没有任何修改）仅仅是新的`String`对象，它们指向相同的共享内存。这有助于保持代码效率，允许在函数之间通过值传递`String`对象，而无需在过程中复制大量内存的开销。
- en: To illustrate some of these features, we will use a console, rather than a Graphical
    User Interface (GUI), application in the first instance. Create a new Introjucer
    project named `Chapter03_01`; changing the **Project Type** to **Console Application,**
    and only selecting **Create a Main.cpp file** in the **Files to Auto-Generate**
    menu. Save the project and open it into your Integrated Development Environment
    (IDE).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一些这些特性，我们首先将使用控制台，而不是图形用户界面（GUI）应用程序。创建一个新的名为`Chapter03_01`的Introjucer项目；将**项目类型**更改为**控制台应用程序**，并在**自动生成文件**菜单中仅选择**创建Main.cpp文件**。保存项目并将其打开到你的集成开发环境（IDE）中。
- en: Posting log messages to the console
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志消息发布到控制台
- en: 'To post messages to the console window, it is best to use JUCE''s `Logger`
    class. Logging can be set to log a text file, but the default behavior is to send
    the logging messages to the console. A simple "Hello world!" project using a JUCE
    `String` object and the `Logger` class is shown as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息发布到控制台窗口，最好使用JUCE的`Logger`类。日志可以设置为记录到文本文件，但默认行为是将日志消息发送到控制台。以下是一个简单的“Hello
    world!”项目，它使用JUCE `String`对象和`Logger`类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first line of code in the `main()` function stores a pointer to the current
    logger such that we can reuse it a number of times in later examples. The second
    line creates a JUCE `String` object from the literal C string `"Hello world!"`,
    and the third line sends this string to the logger using its `writeToLog()` function.
    Build and run this application, and the console window should look something like
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数中的第一行代码存储了对当前日志记录器的指针，这样我们就可以在后面的例子中多次重用它。第二行从字面量C字符串`"Hello world!"`创建一个JUCE
    `String`对象，第三行使用其`writeToLog()`函数将此字符串发送到日志记录器。构建并运行此应用程序，控制台窗口应该看起来像以下这样：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JUCE reports the first line automatically; this may be different if you have
    a later version of JUCE from the GIT repository. This is followed by any logging
    messages from your application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE会自动报告第一行；如果你使用的是来自GIT仓库的JUCE的较新版本，这可能会不同。随后是来自你应用程序的任何日志消息。
- en: String manipulation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'While this example is more complex than an equivalent using standard C strings,
    the power of JUCE''s `String` class is delivered through the storage and manipulation
    of strings. For example, to concatenate strings, the `+` operator is overloaded
    for this purpose:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子比使用标准C字符串的等效例子更复杂，但JUCE的`String`类的强大功能是通过字符串的存储和处理来实现的。例如，为了连接字符串，`+`操作符被重载用于此目的：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, separate strings are constructed from literals for `"Hello"`, the space
    in between, and `"world!"`, then the final `message` string is constructed by
    concatenating all three. The stream operator `<<` may also be used for this purpose
    for a similar result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从字面量构造了`"Hello"`、中间的空格和`"world!"`等单独的字符串，然后通过连接这三个字符串来构造最终的`message`字符串。流操作符`<<`也可以用于此目的，以获得类似的结果：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The stream operator concatenates the right-hand side of the expression onto
    the left-hand side of the expression, in-place. In fact, using this simple case,
    the `<<` operator is equivalent to the `+=` operator when applied to strings.
    To illustrate this, replace all the instances of `<<` with `+=` in the code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 流操作符将表达式的右侧连接到左侧，就地完成。实际上，使用这个简单的例子，当应用于字符串时，`<<`操作符等同于`+=`操作符。为了说明这一点，将代码中所有`<<`实例替换为`+=`。
- en: 'The main difference is that the `<<` operator may be more conveniently chained
    into longer expressions without additional parentheses (due to the difference
    between the precedence in C++ of the `<<` and `+=` operators). Therefore, the
    concatenation can be done all on one line, as with the `+` operator, if needed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于`<<`操作符可以更方便地链入更长的表达式，而不需要额外的括号（这是由于C++中`<<`和`+=`操作符优先级的差异）。因此，如果需要，可以像使用`+`操作符一样，在一行内完成连接：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To achieve the same results with `+=` would require cumbersome parentheses
    for each part of the expression: `(((message += "Hello") += " ") += "world!")`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`+=`达到相同的结果，需要在表达式的每一部分都使用繁琐的括号：`(((message += "Hello") += " ") += "world!")`。
- en: 'The way the internal reference counting of strings works in JUCE means that
    you rarely need to be concerned about unintended side effects. For example, the
    following listing works as you might expect from reading the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE中字符串内部引用计数的实现方式意味着你很少需要担心意外的副作用。例如，以下列表的工作方式可能正如你从阅读代码中预期的那样：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This produces the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Breaking this down into steps, we can see what happens:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分解为步骤，我们可以看到发生了什么：
- en: '`String string1 ("Hello");`: The `string1` variable is initialized with a literal
    string.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String string1 ("Hello");`: `string1`变量使用字面量字符串初始化。'
- en: '`String string2 = string1;`: The `string2` variable is initialized with `string1`;
    they now refer to exactly the same data behind the scenes.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String string2 = string1;`: `string2`变量使用`string1`初始化；它们现在在幕后指向完全相同的数据。'
- en: '`string1 << " world!";`: The `string1` variable has another literal string
    appended. At this point `string1` refers to a completely new block of memory containing
    the concatenated string.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string1 << " world!";`: `string1`变量附加了另一个字面量字符串。此时`string1`指向一个包含连接字符串的新内存块。'
- en: '`log->writeToLog ("string1: " + string1);`: This logs `string1`, showing the
    concatenated string `Hello world!`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log->writeToLog ("string1: " + string1);`: 这条日志记录了`string1`，显示了连接后的字符串`Hello
    world!`。'
- en: '`log->writeToLog ("string2: " + string2);`: This logs `string2`; this shows
    that `string1` still refers to the initial string `Hello`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log->writeToLog ("string2: " + string2);`: 这条日志记录了`string2`；这表明`string1`仍然指向初始字符串`Hello`。'
- en: 'One really useful feature of the `String` class is its numerical conversion
    capabilities. Generally, you can pass a numerical type to a `String` constructor,
    and the resulting `String` object will represent that numerical value. For example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类的一个非常有用的功能是其数值转换能力。通常，你可以将数值类型传递给`String`构造函数，生成的`String`对象将表示该数值。例如：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other useful features are conversions to uppercase and lowercase. Strings may
    also be compared using the `==` operator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的功能包括转换为大写和小写。字符串也可以使用`==`操作符进行比较。
- en: Measuring and displaying time
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量和显示时间
- en: 'The JUCE `Time` class provides a cross-platform way to specify, measure, and
    format date and time information in a human-readable fashion. Internally, the
    `Time` class stores a value in milliseconds relative to midnight on 1st January
    1970\. To create a `Time` object that represents the current time, use `Time::getCurrentTime()`
    like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 的 `Time` 类提供了一种跨平台的方法，以人类可读的方式指定、测量和格式化日期和时间信息。内部，`Time` 类以相对于1970年1月1日午夜毫秒为单位存储一个值。要创建表示当前时间的
    `Time` 对象，使用 `Time::getCurrentTime()`，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To bypass the creation of the `Time` object, you can access the millisecond
    counter as a 64-bit value directly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过创建 `Time` 对象，可以直接以64位值的形式访问毫秒计数器：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Time` class also provides access to a 32-bit millisecond counter that
    measures time since system startup:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time` 类还提供了访问自系统启动以来的32位毫秒计数器的功能，用于测量时间：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The important point to note about `Time::getMillisecondCounter()` is that it
    is independent of the system time, and would be unaffected by changes to the system
    time either by the user changing the time, changes due to national daylight saving,
    and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Time::getMillisecondCounter()` 的重要点是，它是独立于系统时间的，并且不会受到用户更改时间、由于国家夏令时变化等原因的系统时间更改的影响。
- en: Displaying and formatting time information
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示和格式化时间信息
- en: 'Displaying time information is straightforward; the following example gets
    the current time from the operating system, formats it as a string, and sends
    it to the console output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显示时间信息很简单；以下示例从操作系统获取当前时间，将其格式化为字符串，并输出到控制台：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This illustrates the four option flags available to the `Time::toString()`
    function. The output on the console will be something like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了 `Time::toString()` 函数可用的四个选项标志。控制台上的输出将类似于以下内容：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For more comprehensive options, the `Time::formatted()` function allows the
    user to specify a format using a special format string (using a system equivalent
    to the standard C `strftime()` function). Alternatively, you can obtain the various
    parts of the date and time information (day, month, hour, minute, time zone, and
    so on), and combine them into a string yourself. For example, the same preceding
    format can be achieved as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更全面的选择，`Time::formatted()` 函数允许用户使用特殊的格式字符串（使用与标准C `strftime()` 函数等效的系统）指定格式。或者，你可以获取日期和时间信息的各个部分（日、月、时、分、时区等），并将它们组合成字符串。例如，可以使用以下方式实现相同的前置格式：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manipulating time data
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作时间数据
- en: '`Time` objects may also be manipulated (with the help from the `RelativeTime`
    class) and compared with other `Time` objects. The following example shows the
    creation of three time values, based on the current time, using a one-hour offset:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time` 对象也可以被操作（借助 `RelativeTime` 类的帮助）并与其他 `Time` 对象进行比较。以下示例展示了基于当前时间创建三个时间值，使用一小时偏移量：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this should be something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果应该类似于这样：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To compare two `Time` objects, the standard comparison operators may be used.
    For example, you could wait for a specific time, like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较两个 `Time` 对象，可以使用标准比较运算符。例如，你可以等待特定的时间，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Two things to note here are that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方是：
- en: The value passed to the `RelativeTime` constructor is in seconds (all the other
    time values need to use one of the static functions as shown earlier for hours,
    minutes, and so on).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 `RelativeTime` 构造函数的值以秒为单位（所有其他时间值都需要使用前面显示的静态函数，例如小时、分钟等）。
- en: The call to `Thread::sleep()` uses values in milliseconds and this sleeps the
    calling thread. The `Thread` class will be examined further in [Chapter 5](ch05.html
    "Chapter 5. Helpful Utilities"), *Helpful Utilities*.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread::sleep()` 函数的调用使用毫秒值，这将使调用线程休眠。`Thread` 类将在 [第5章](ch05.html "第5章。有用的工具")，*有用的工具*
    中进一步探讨。'
- en: Measuring time
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量时间
- en: 'The time values returned from the `Time::getCurrentTime()` function should
    be accurate for most purposes, but as pointed out earlier, the *current time*
    could be changed by the user modifying the system time. An equivalent to the preceding
    example, using `Time::getMillisecondCounter()` that is not susceptible to such
    changes, is shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Time::getCurrentTime()` 函数返回的时间值对于大多数用途应该是准确的，但如前所述，*当前时间* 可以通过用户修改系统时间而改变。以下是一个等效的示例，使用
    `Time::getMillisecondCounter()`，它不受此类变化的影响：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both the `Time::getCurrentTime()` and `Time::getMillisecondCounter()` functions
    have a similar accuracy, which is within a few milliseconds on most platforms.
    However, the `Time` class also provides access to a higher resolution counter
    that returns values as a double precision (64-bit) floating-point value. This
    function is `Time::getMillisecondCounterHiRes()`, and is also relative to the
    system start-up as is the value returned from the `Time::getMillisecondCounter()`
    function. One application of this is to measure the time that certain pieces of
    code have taken to execute, as shown in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time::getCurrentTime()`和`Time::getMillisecondCounter()`函数具有相似的精度，在大多数平台上都在几毫秒之内。然而，`Time`类还提供了一个更高分辨率的计数器，返回双精度（64位）浮点值。这个函数是`Time::getMillisecondCounterHiRes()`，与`Time::getMillisecondCounter()`函数返回的值一样，也是相对于系统启动的。一个应用这个函数的例子是测量某些代码片段执行所需的时间，如下面的示例所示：'
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This records the current time by polling the higher resolution counter, performing
    a large number of floating point additions, and polling the higher resolution
    counter again to determine the duration between these two points in time. The
    output should be something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过轮询更高分辨率的计数器，执行大量浮点数加法，然后再次轮询更高分辨率的计数器来确定这两个时间点之间的持续时间。输出应该类似于以下内容：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, the results here are dependent on the optimization settings in the
    compiler and the runtime system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的结果取决于编译器和运行时系统中的优化设置。
- en: Specifying file paths
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定文件路径
- en: 'JUCE provides a relatively cross-platform way of specifying and manipulating
    file paths using the `File` class. In particular, this provides a means of accessing
    various special directories on the user''s system, such as the `Desktop` directory,
    their user `Documents` directory, application preferences directories, and so
    on. The `File` class also provides functions for accessing information about a
    file (for example, creation date, modification date, file size) and basic mechanisms
    for reading and writing file contents (although other techniques may be more appropriate
    for large or complex files). In the following example, a string is written to
    a text file on disk (using the `File::replaceWithText()` function), then read
    back into a second string (using the `File::loadFileAsString()` function), and
    displayed in the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE通过`File`类提供了一种相对跨平台的方式来指定和操作文件路径。特别是，这提供了一种访问用户系统上各种特殊目录的方法，例如`桌面`目录、他们的用户`文档`目录、应用程序首选项目录等等。`File`类还提供了访问文件信息的功能（例如，创建日期、修改日期、文件大小）以及读写文件内容的基本机制（尽管对于大型或复杂文件，其他技术可能更合适）。在以下示例中，一个字符串被写入磁盘上的文本文件（使用`File::replaceWithText()`函数），然后被读入第二个字符串（使用`File::loadFileAsString()`函数），并在控制台中显示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `File` object in this case is initialized with the path `./chapter03_01_test.txt`.
    It should be noted that this file may not exist at this point, and on first run
    it will not exist until the call to the `File::replaceWithText()` function (and
    on subsequent runs this file will exist, but will be overwritten at that point).
    The `./` character sequence at the front of this path is a common idiom specifying
    that the remainder of the path should be relative to the current directory (or
    current working directory). In this simple case, the current working directory
    is likely to be the directory where the executable file is located. The following
    screenshot shows this location relative to the Introjucer project on the Mac platform:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，`File`对象被初始化为路径`./chapter03_01_test.txt`。需要注意的是，此时该文件可能不存在，并且在第一次运行时，它将在调用`File::replaceWithText()`函数之前不存在（在后续运行中，该文件将存在，但在那个点将被覆盖）。路径前面的`./`字符序列是一个常见的惯用语，指定路径的其余部分应该是相对于当前目录（或当前工作目录）。在这个简单的情况下，当前工作目录很可能是可执行文件所在的目录。以下截图显示了在Mac平台上相对于Introjucer项目的这个位置： '
- en: '![Specifying file paths](img/3316_03_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![指定文件路径](img/3316_03_01.jpg)'
- en: This is not a reliable method; however, it will work if the working directory
    is specifically where you want to save a file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个可靠的方法；然而，如果工作目录正好是你想要保存文件的地方，它将会工作。
- en: Accessing various special directory locations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问各种特殊目录位置
- en: 'It is more precise to use one of the `File` class''s special locations, as
    shown as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`File`类的一个特殊位置会更精确，如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The steps for accessing the file location in this directory are split across
    several lines for clarity in this code. Here, you can see the code to obtain the
    location of the current executable file, then its parent directory, and then create
    a file reference for our text file that is relative to this directory. Much of
    this code may be compacted on a single logical line using a chain of function
    calls:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码清晰，访问此目录中的文件位置的步骤被拆分在多行中。在这里，你可以看到获取当前可执行文件位置、然后是其父目录，然后为相对于此目录的文本文件创建文件引用的代码。大部分这段代码可以通过使用函数调用链在单逻辑行中压缩：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Due to the length of some of the identifiers in this code and the page width
    in this book, this code still occupies four physical lines of code. Nevertheless,
    this illustrates how you can employ this function calls to suit your needs and
    preferences for code layout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此代码中某些标识符的长度和本书的页面宽度，这段代码仍然占据了四行物理代码。尽管如此，这说明了你可以如何使用这些函数调用来满足你的需求和代码布局偏好。
- en: Obtaining various information about files
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取有关文件的各种信息
- en: 'The `File` class can provide useful information about files. One important
    test is whether a file exists; this can be determined using `File::exists()`.
    If a file does exist, then more information may be obtained, such as its creation
    date, modification date, and size. These are illustrated in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类可以提供有关文件的有用信息。一个重要的测试是文件是否存在；这可以通过使用`File::exists()`来确定。如果文件确实存在，则可以获得更多信息，例如其创建日期、修改日期和大小。以下示例中展示了这些信息：'
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assuming you ran all of the preceding examples, the file should exist on your
    system and the information will be reported in the console something like as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你运行了所有前面的示例，文件应该存在于你的系统上，信息将在控制台以类似以下方式报告：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Other special locations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特殊位置
- en: 'In addition to `File::currentExecutableFile`, other special locations known
    to JUCE are:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`File::currentExecutableFile`，JUCE还知道的其他特殊位置包括：
- en: '`File::userHomeDirectory`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userHomeDirectory`'
- en: '`File::userDocumentsDirectory`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userDocumentsDirectory`'
- en: '`File::userDesktopDirectory`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userDesktopDirectory`'
- en: '`File::userApplicationDataDirectory`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userApplicationDataDirectory`'
- en: '`File::commonApplicationDataDirectory`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::commonApplicationDataDirectory`'
- en: '`File::tempDirectory`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::tempDirectory`'
- en: '`File::currentExecutableFile`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::currentExecutableFile`'
- en: '`File::currentApplicationFile`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::currentApplicationFile`'
- en: '`File::invokedExecutableFile`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::invokedExecutableFile`'
- en: '`File::hostApplicationPath`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::hostApplicationPath`'
- en: '`File::globalApplicationsDirectory`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::globalApplicationsDirectory`'
- en: '`File::userMusicDirectory`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userMusicDirectory`'
- en: '`File::userMoviesDirectory`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userMoviesDirectory`'
- en: '`File::userPicturesDirectory`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File::userPicturesDirectory`'
- en: Each of these names is fairly self-explanatory. In some cases, these special
    locations are not applicable on some platforms. For example, there is no such
    thing as the `Desktop` on the iOS platform.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些名称都相当直观。在某些情况下，这些特殊位置在某些平台上不适用。例如，iOS平台上没有所谓的`Desktop`。
- en: Navigating directory structures
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航目录结构
- en: 'Ultimately, a `File` object resolves to an absolute path on the user''s system.
    This can be obtained using the `File::getFullPathName()` function if needed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一个`File`对象在用户的系统上解析为一个绝对路径。如果需要，可以使用`File::getFullPathName()`函数来获取：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition to this, the relative path passed to `File::getChildFile()` can
    contain one or more references to parent directories using the double period notation
    (that is, the "`..`" character sequence). In this next example, we create a simple
    directory structure as shown in the screenshot following this code listing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，传递给`File::getChildFile()`的相对路径可以包含一个或多个使用双点表示法（即，“`..`”字符序列）引用父目录的引用。在下面的示例中，我们创建了一个简单的目录结构，如代码列表后面的截图所示：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Navigating directory structures](img/3316_03_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![导航目录结构](img/3316_03_02.jpg)'
- en: This creates five directories in total, using only two calls to the `File::createDirectory()`function.
    Since this is dependent on the user's permissions to create files in this directory,
    the function returns a `Result` object. This contains a state to indicate if the
    function succeeded or not (which we check with the `Result::wasOk()` function),
    and more information can be gained about any errors if needed. Each call to the
    `File::createDirectory()` function ensures that it creates any intermediate directories
    if required. Therefore, on the first call, it creates the root directory, directory
    `1`, and directory `1/a`. On the second call, the root already exists, so it needs
    only to create directories `2` and `2/a`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这总共创建了五个目录，只使用了两次 `File::createDirectory()` 函数调用。由于这取决于用户在此目录中创建文件的权限，该函数返回一个
    `Result` 对象。该对象包含一个状态来指示函数是否成功（我们通过 `Result::wasOk()` 函数进行检查），如果需要，还可以获取有关任何错误的更多信息。每次调用
    `File::createDirectory()` 函数都确保如果需要，它将创建任何中间目录。因此，在第一次调用时，它创建了根目录、目录 `1` 和目录 `1/a`。在第二次调用时，根目录已经存在，因此它只需要创建目录
    `2` 和 `2/a`。
- en: 'The console output for this should be something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应该是这样的：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, the first line will be different, depending on your system, but the
    remaining five lines should be the same. These paths are displayed relative to
    the root of the directory structure we have created using the `File::getRelativePathFrom()`
    function. Notice that the final line shows that the `rel` object refers to the
    same directory as the `dir2b` object, but we created this `rel` object relative
    to the `dir1a` object by using the function call `dir1a.getChildFile("../../2/b")`.
    That is, we navigate two levels up the directory structure then access the directories
    below.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，第一行将根据您的系统而有所不同，但剩余的五行应该是相同的。这些路径是相对于我们使用 `File::getRelativePathFrom()` 函数创建的目录结构根目录显示的。注意，最后一行显示
    `rel` 对象指向与 `dir2b` 对象相同的目录，但我们通过使用函数调用 `dir1a.getChildFile("../../2/b")` 相对于
    `dir1a` 对象创建了此 `rel` 对象。也就是说，我们在目录结构中向上导航两级，然后访问下面的目录。
- en: The `File` class also includes features to check for a file's existence, to
    move and copy files within the filesystem (including moving the file to the **Trash**
    or **Recycle Bin**), and to create legal filenames on particular platforms (for
    example, avoiding colon and slash characters).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 类还包括检查文件是否存在的功能，在文件系统中移动和复制文件（包括将文件移动到 **垃圾桶** 或 **回收站**），以及在特定平台上创建合法的文件名（例如，避免冒号和斜杠字符）。'
- en: Using dynamically allocated arrays
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分配的数组
- en: 'While most instances of JUCE objects can be stored in regular C++ arrays, JUCE
    offers a handful of arrays that are more powerful, somewhat comparable to the
    C++ Standard Library classes, such as `std::vector`. The JUCE `Array` class offers
    many features; these arrays can be:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数 JUCE 对象的实例可以存储在常规 C++ 数组中，但 JUCE 提供了一些更强大的数组，与 C++ 标准库类（如 `std::vector`）有些相似。JUCE
    的 `Array` 类提供了许多功能；这些数组可以是：
- en: Dynamically sized; items can be added, removed, and inserted at any index
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态大小；可以在任何索引处添加、删除和插入项目
- en: Sorted using custom comparators
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义比较器进行排序
- en: Searched for particular content
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索特定内容
- en: 'The `Array` class is a template class; its main template argument, `ElementType`,
    must meet certain criteria. The `Array` class moves its contents around by copying
    memory during resizing and inserting elements, this could cause problems with
    certain kinds of objects. The class passed as the `ElementType` template argument
    must also have both a copy constructor and an assignment operator. The `Array`
    class, in particular, works well with primitive types and some commonly used JUCE
    classes, for example, the `File` and `Time` classes. In the following example,
    we create an array of integers, add five items to it, and iterate over the array,
    sending the contents to the console:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 类是一个模板类；其主模板参数 `ElementType` 必须满足某些标准。`Array` 类在调整大小和插入元素时通过复制内存来移动其内容，这可能会与某些类型的对象造成问题。作为
    `ElementType` 模板参数传递的类必须同时具有复制构造函数和赋值运算符。特别是，`Array` 类与原始类型和一些常用的 JUCE 类（例如 `File`
    和 `Time` 类）配合得很好。在以下示例中，我们创建了一个整数数组，向其中添加了五个项目，并遍历数组，将内容发送到控制台：'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should produce the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that the JUCE `Array` class supports the C++ indexing subscript operator
    `[]`. This will always return a valid value even if the array index is out of
    bounds (unlike a built-in array). There is a small overhead involved in making
    this check; therefore, you can avoid the bounds checking by using the `Array::getUnchecked()`
    function, but you must be certain that the index is within bounds, otherwise your
    application may crash. The second `for()` loop can be rewritten as follows to
    use this alternative function, because we have already checked that out indices
    will be in-range:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 JUCE 的 `Array` 类支持 C++ 索引下标操作符 `[]`。即使数组索引超出范围，它也会始终返回一个有效值（与内置数组不同）。进行此检查涉及一些开销；因此，您可以通过使用
    `Array::getUnchecked()` 函数来避免边界检查，但您必须确保索引在范围内，否则您的应用程序可能会崩溃。第二个 `for()` 循环可以重写如下以使用此替代函数，因为我们已经检查了索引将在范围内：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finding the files in a directory
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在目录中查找文件
- en: 'The JUCE library uses the `Array` objects for many purposes. For example, the
    `File` class can fill an array of `File` objects with a list of child files and
    directories it contains using the `File::findChildFiles()` function. The following
    example should post a list of files and directories in your user `Documents` directory
    to the console:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 库使用 `Array` 对象来完成许多目的。例如，`File` 类可以使用 `File::findChildFiles()` 函数将包含的子文件和目录列表填充到一个
    `File` 对象数组中。以下示例应将用户 `Documents` 目录中的文件和目录列表输出到控制台：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `File::findChildFiles()` function is passed the array of `File` objects,
    to which it should add the result of the search. It is also told to find both
    files and directories using the value `File::findFilesAndDirectories` (other options
    are the `File::findDirectories` and `File::findFiles` values). Finally, it is
    told not to search recursively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`File::findChildFiles()` 函数被传递了一个 `File` 对象数组，它应该添加搜索结果。它还被指示使用值 `File::findFilesAndDirectories`（其他选项是
    `File::findDirectories` 和 `File::findFiles` 值）来查找文件和目录。最后，它被指示不要递归搜索。
- en: Tokenizing strings
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串标记化
- en: 'Although it is possible to use `Array<String>` to hold an array of JUCE `String`
    objects, there is a dedicated `StringArray` class to offers additional functionality
    when applying array operations to string data. For example, a string can be **tokenized**
    (that is, broken up into smaller strings based on whitespace in the original string)
    using the `String::addTokens()` function, or divided into strings representing
    lines of text (based on newline character sequences found within the original
    string) using the `String::addLines()` function. The following example tokenizes
    a string, then iterates over the resulting `StringArray` object, posting its contents
    to the console:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 `Array<String>` 来存储 JUCE `String` 对象的数组，但有一个专门的 `StringArray` 类，在将数组操作应用于字符串数据时提供了额外的功能。例如，可以使用
    `String::addTokens()` 函数将字符串**标记化**（即将原始字符串中的空白字符分割成更小的字符串），或者使用 `String::addLines()`
    函数将其分割成表示文本行的字符串（基于原始字符串中找到的换行符序列）。以下示例将一个字符串标记化，然后遍历生成的 `StringArray` 对象，将其内容输出到控制台：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Arrays of components
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件数组
- en: 'User interfaces comprising banks of similar controls, such as buttons and sliders,
    can be managed effectively using arrays. However, the JUCE `Component` class and
    its subclasses do not meet the criteria for storage as an object (that is, by
    value) in a JUCE `Array` object. These must be stored as arrays of pointers to
    these objects instead. To illustrate this, we need a new Introjucer project with
    a basic window as used throughout [Chapter 2](ch02.html "Chapter 2. Building User
    Interfaces"), *Building User Interfaces*. Create a new Introjucer project, such
    as this, name it `Chapter03_02`, and open it into your IDE. To the end of the
    `MainWindow` constructor in `Main.cpp`, add the following line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由类似控件（如按钮和滑块）组成的用户界面可以使用数组有效地管理。然而，JUCE 的 `Component` 类及其子类不符合在 JUCE `Array`
    对象中作为对象（即按值）存储的标准。这些必须存储为指向这些对象的指针数组。为了说明这一点，我们需要一个新的 Introjucer 项目，其中包含一个基本的窗口，如
    [第 2 章](ch02.html "第 2 章。构建用户界面") 中使用的，*构建用户界面*。创建一个新的 Introjucer 项目，例如，命名为 `Chapter03_02`，并在您的
    IDE 中打开它。在 `Main.cpp` 中 `MainWindow` 构造函数的末尾添加以下行：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `MainComponent.h` file change the code to:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainComponent.h` 文件中修改代码如下：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that the `Array` object here is an array of pointers to `TextButton`
    objects (that is, `TextButton*)`. In the `MainComponent.cpp` file change the code
    to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的 `Array` 对象是一个指向 `TextButton` 对象的指针数组（即 `TextButton*`）。在 `MainComponent.cpp`
    文件中修改代码如下：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we create 10 buttons and using a `for()` loop, adding these buttons to
    an array, and basing the name of the button on the loop counter. The buttons are
    allocated using the `new` operator (rather than the static allocation used in
    [Chapter 2](ch02.html "Chapter 2. Building User Interfaces"), *Building User Interfaces*),
    and it is these pointers that are stored in the array. (Notice also, that there
    is no need for the `&` operator in the function call to `Component::addAndMakeVisible()`
    because the value is already a pointer.) In the `resized()` function, we use a
    `Rectangle<int>` object to create a rectangle that is inset from the `MainContentComponent`
    object's bounds rectangle by 10 pixels all the way around. The buttons are positioned
    within this smaller rectangle. The height for each button is calculated by dividing
    the height of our rectangle by the number of buttons in the button array. The
    `for()` loop then positions each button, based on its index within the array.
    Build and run the application; its window should present 10 buttons arranged in
    a single column.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major flaw with the preceding code. The buttons allocated with
    the `new` operator are never deleted. The code should run fine, although you will
    get an assertion failure when the application is exited. The message into the
    console will be something like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To solve this, we could delete the buttons in the `MainComponent` destructor
    like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, it is very easy to forget to do this kind of operation when writing
    complex code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Using the OwnedArray class
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JUCE provides a useful alternative to the `Array` class that is dedicated to
    pointer types: the `OwnedArray` class. The `OwnedArray` class always stores pointers,
    therefore should not include the `*` character in the template parameter. Once
    a pointer is added to an `OwnedArray` object, it takes ownership of the pointer
    and will take care of deleting it when necessary (for example, when the `OwnedArray`
    object itself is destroyed). Change the declaration in the `MainComponent.h` file,
    as highlighted in the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should also remove the code from the destructor in the `MainComponent.cpp`
    file, because deleting objects more than once is equally problematic:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Build and run the application, noticing that the application will now exit without
    problems.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique can be extended to using broadcasters and listeners. Create
    a new GUI-based Introjucer project as before, and name it `Chapter03_03`. Change
    the `MainComponent.h` file to:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This time we use an `OwnedArray<Button>` object rather than an `OwnedArray<TextButton>`
    object. This simply avoids the need to typecast our button pointers to different
    types when searching for the pointers in the array, as we do in the following
    code. Also, notice here that we added a `Label` object to our component, made
    our component a button listener, and that we do not need a destructor. Change
    the `MainComponent.cpp` file to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we add the label in the constructor, reduce the width of the bank of buttons
    to occupy only the left half of the component, and position the label at the top
    in the right-half. In the button listener callback, we can obtain the index of
    the button using the `OwnedArray::indexOf()` function to search for the pointer
    (incidentally, the `Array` class also has an `indexOf()` function for searching
    the items). Build and run the application and notice that our label reports which
    button was clicked. Of course, the elegant thing about this code is that we need
    only change the value in the `for()` loop when the buttons are created in our
    constructor to change the number of buttons that are created; everything else
    works automatically.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在构造函数中添加了标签，将按钮组的宽度减小到只占用组件的左侧一半，并将标签定位在右侧的上部。在按钮监听器回调中，我们可以使用`OwnedArray::indexOf()`函数来获取按钮的索引，以搜索指针（顺便说一句，`Array`类也有一个`indexOf()`函数用于搜索项）。构建并运行应用程序，注意我们的标签报告了哪个按钮被点击。当然，这个代码优雅的地方在于，我们只需在构造函数中更改`for()`循环中的值，就可以更改创建的按钮数量；其他所有事情都会自动完成。
- en: Other banks of controls
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他控件组
- en: 'This approach may be applied to other banks of controls. The following example
    creates a bank of sliders and labels, keeping each corresponding component updated
    with the appropriate value. Create a new GUI-based Introjucer project, and name
    it `Chapter03_04`. Change the `MainComponent.h` file to:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以应用于其他控件组。以下示例创建了一个滑块和标签的控件组，并确保每个对应组件都使用适当的值进行更新。创建一个新的基于GUI的Introjucer项目，并将其命名为`Chapter03_04`。将`MainComponent.h`文件更改为：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have arrays of sliders and labels and our component is both a label
    listener and a slider listener. Now, update the `MainComponent.cpp` file to contain
    the include directive, the constructor, and the `resized()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有滑块和标签的数组，我们的组件既是标签监听器也是滑块监听器。现在，更新`MainComponent.cpp`文件以包含包含指令、构造函数和`resized()`函数：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we use a `for()` loop to create the components and add them to the corresponding
    arrays. In the `resized()` function, we create two helper rectangles, one for
    the bank of sliders and one for the bank of labels. These are positioned to occupy
    the left half and right half of the main component respectively.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`for()`循环创建组件并将它们添加到相应的数组中。在`resized()`函数中，我们创建了两个辅助矩形，一个用于滑块组，一个用于标签组。这些矩形分别定位在主组件的左侧和右侧一半。
- en: 'In the listener callback functions, the index of the broadcasting component
    is looked up in its array, and this index is used to set the value of the other
    corresponding component. Add these listener callback functions to the `MainComponent.cpp`
    file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听器回调函数中，广播组件的索引在其数组中查找，并使用此索引设置其他对应组件的值。将这些监听器回调函数添加到`MainComponent.cpp`文件中：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we use the `String` class to perform the numerical conversions. After
    moving some of the sliders, the application window should look similar to the
    following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`String`类来执行数值转换。移动一些滑块后，应用程序窗口应类似于以下截图：
- en: '![Other banks of controls](img/3316_03_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![其他控件组](img/3316_03_03.jpg)'
- en: Hopefully, these examples illustrate the power of combining JUCE array classes
    with other JUCE classes to write elegant, readable, and powerful code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些示例说明了将JUCE数组类与其他JUCE类结合使用的强大之处，以编写优雅、易读且功能强大的代码。
- en: Employing smart pointer classes
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针类
- en: The `OwnedArray` class may be considered a manager of smart pointers, in the
    sense that it manages the lifetime of the object to which it points. JUCE includes
    a range of other smart pointer types to help solve a number of common issues when
    writing code using pointers. In particular, these help avoid mismanagement of
    memory and other resources.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnedArray`类可以被视为智能指针的管理器，从它管理的对象的生命周期来看。JUCE包括一系列其他智能指针类型，以帮助解决在编写使用指针的代码时遇到的一些常见问题。特别是，这些有助于避免内存和其他资源的误管理。'
- en: 'Perhaps the simplest smart pointer is implemented by the `ScopedPointer` class.
    This manages a single pointer and deletes the object to which it points when no
    longer needed. This may happen in two ways:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的智能指针是由`ScopedPointer`类实现的。它管理单个指针，并在不再需要时删除它所指向的对象。这可能以两种方式发生：
- en: When the `ScopedPointer` object itself is destroyed
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ScopedPointer`对象本身被销毁时
- en: When a new pointer is assigned to the `ScopedPointer` object
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新的指针被分配给`ScopedPointer`对象时
- en: 'One use of the `ScopedPointer` class is as an alternative means of storing
    a `Component` objects (or one of its subclasses). In fact, adding subcomponents
    in the Introjucer applications graphical editor adds the components to the code
    as `ScopedPointer` objects in a similar way to the example that follows. Create
    a new Introjucer project named `Chapter03_05`. The following example achieves
    an identical result to the `Chapter02_02` project, but uses `ScopedPointer` objects
    to manage the components rather than statically allocating them. Change the `MainComponent.h`
    file to:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScopedPointer` 类的一个用途是作为存储 `Component` 对象（或其子类之一）的替代方法。实际上，在 Introjucer 应用程序的图形编辑器中添加子组件会将组件以
    `ScopedPointer` 对象的形式添加到代码中，这与下面的示例类似。创建一个新的 Introjucer 项目，命名为 `Chapter03_05`。以下示例实现了与
    `Chapter02_02` 项目相同的结果，但使用 `ScopedPointer` 对象来管理组件，而不是静态分配它们。将 `MainComponent.h`
    文件修改如下：'
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that we use a `ScopedPointer<Button>` object rather than a `ScopedPointer<TextButton>`
    object for the same reasons we used an `OwnedArray<Button>` object in preference
    to an `OwnedArray<TextButton>` object previously. Change the `MainComponent.cpp`
    file as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `ScopedPointer<Button>` 对象而不是 `ScopedPointer<TextButton>` 对象，原因与之前我们更倾向于使用
    `OwnedArray<Button>` 对象而不是 `OwnedArray<TextButton>` 对象的原因相同。将 `MainComponent.cpp`
    文件修改如下：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The main changes here are to use the `->` operator (which the `ScopedPointer`
    class overloads to return the pointer it contains) rather than the `.` operator.
    The components are all explicitly allocated use the `new` operator, but other
    than that, the code is almost identical to the `Chapter02_02` project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要变化是使用 `->` 操作符（`ScopedPointer` 类重载以返回其包含的指针）而不是 `.` 操作符。组件都是显式使用 `new`
    操作符分配的，但除此之外，代码几乎与 `Chapter02_02` 项目相同。
- en: 'Other useful memory management classes in JUCE are:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 中其他有用的内存管理类包括：
- en: '`ReferenceCountedObjectPtr<ReferenceCountedObjectClass>`: This allows you to
    write classes such that instances can be passed around in a similar way to the
    `String` objects. The lifetime is managed by the object maintaining its own counter
    that counts the number of references that exists to the object in the code. This
    is particularly useful in multi-threaded applications and for producing graph
    or tree structures. The `ReferenceCountedObjectClass` template argument needs
    to inherit from the `ReferenceCountedObject` class.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceCountedObjectPtr<ReferenceCountedObjectClass>`：这允许您编写类，使得实例可以像 `String`
    对象一样在代码中传递。生命周期由维护其自己的计数器的对象管理，该计数器统计代码中对对象的引用数量。这在多线程应用程序和生成图或树结构时特别有用。`ReferenceCountedObjectClass`
    模板参数需要继承自 `ReferenceCountedObject` 类。'
- en: '`MemoryBlock`: This manages a block of resizable memory and is the recommended
    method of managing raw memory (rather than using the standard `malloc()` and `free()`
    functions, for example).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MemoryBlock`：这管理一块可调整大小的内存，是管理原始内存的推荐方法（例如，而不是使用标准的 `malloc()` 和 `free()`
    函数）。'
- en: '`HeapBlock<ElementType>`: Similar to the `MemoryBlock` class (in fact a `MemoryBlock`
    object contains a `HeapBlock<char>` object), but this is a smart pointer type
    and supports the `->` operator. As it is a template class, it also points to an
    object or objects of a particular type.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HeapBlock<ElementType>`：类似于 `MemoryBlock` 类（实际上，`MemoryBlock` 对象包含一个 `HeapBlock<char>`
    对象），但这是一个智能指针类型，并支持 `->` 操作符。由于它是一个模板类，它也指向特定类型的对象或对象。'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has outlined some of the core classes in JUCE that provide a foundation
    for building JUCE applications and provide a framework for building applications
    that are idiomatic to the JUCE style. These classes provide further foundations
    for the remainder of this book. Each of these classes contains far more functionality
    than outlined here. Again, it is essential that you review the JUCE class documentation
    for each of the classes introduced in this chapter. Many of these classes are
    used heavily in the JUCE Demo application and the code for the Introjucer application.
    These should also serve as useful for further reading. The next chapter introduces
    classes for handling files, especially media files, such as image and sound files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了 JUCE 中的一些核心类，这些类为构建 JUCE 应用程序提供了基础，并为构建符合 JUCE 风格的应用程序提供了框架。这些类为本书的其余部分提供了进一步的基础。这些类中包含的功能远不止这里概述的。再次强调，您必须查看本章中引入的每个类的
    JUCE 类文档。许多这些类在 JUCE 示例应用程序和 Introjucer 应用程序的代码中被大量使用。这些也应该对进一步阅读很有帮助。下一章将介绍用于处理文件（特别是媒体文件，如图像和声音文件）的类。
