<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Making Things Move and Creating Sounds</h1></div></div></div><p>If the Arduino board can listen and feel with sensors, it can also react by making things move.</p><p>By the movement concept, I mean both of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Object movements</li><li class="listitem" style="list-style-type: disc">Air movements producing sounds</li></ul></div><p>We are going to learn how we can control small motors named <strong>servo</strong>, and how we can deal with high-current control by using transistors.</p><p>Then we'll start talking about the basics of sound generation. This is a requirement before trying to produce any sounds, even the simplest ones. This is the part where we'll describe analog and digital concepts.</p><p>At last, we'll design a very basic random synthesizer controllable using MIDI. We'll also introduce a very nice library called <strong>PCM</strong>
<a id="id983" class="indexterm"/> that provides a simple way to add sample playing features to your 8-bit microcontroller.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Making things vibrate</h1></div></div></div><p>One of the simplest projects we can introduce here is the use of a small <a id="id984" class="indexterm"/>piezoelectric sensor.</p><p>This is the first basic tangible action we design here. Of course, we already designed many of the visual feedback, but this is our first real-world object that moves the firmware.</p><p>This kind of feedback can be very useful in nonvisual contexts. I designed a small project for a person who wanted to send a feedback to visitors in his reactive installation. The visitor had to put on a t-shirt that included some electronics attached, such as a LilyPad and some piezoelectric sensors. The LED feedback wasn't the solution we used before to send feedback to the wearer, and we decided to send a vibration. These piezoelectric sensors were distributed on each side of the t-shirt to produce different feedback in response to different interactions.</p><p>But wouldn't I have made a mistake talking about sensors vibrating?</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec123"/>The piezoelectric sensor</h2></div></div></div><p>A piezoelectric<a id="id985" class="indexterm"/> sensor is a component that uses the piezoelectric effect.</p><p>This effect is defined as the linear electromechanical interaction between the mechanical and electrical state in some specific materials.</p><p>Basically, a mechanical action on this device generates electricity, making it usable for movement and vibration detection. But the nice thing here is that the effect is reciprocal—if you apply a current to it, it will vibrate.</p><p>This is why we are using a piezoelectric sensor here. We are using it as a vibration generator.</p><p>Piezoelectric sensors are also often used as a tone generator. We will dig deeper into the relationship between air vibrations and sound a bit later, but it is important to mention it here too.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec124"/>Wiring a vibration motor</h2></div></div></div><p>Piezoelectric <a id="id986" class="indexterm"/>sensors usually consume around 10 mA to 15 mA, which is very small.</p><p>Of course, you need to check the proper datasheet of the device you are going to use. I have had good results with the one from <strong>Sparkfun</strong>
<a id="id987" class="indexterm"/> (<a class="ulink" href="https://www.sparkfun.com/products/10293">https://www.sparkfun.com/products/10293</a>). The wiring could not be simpler—there are only two legs. The following image shows how the piezoelectric sensor/vibrator is wired to Arduino via a <a id="id988" class="indexterm"/>PWM-capable digital pin:</p><div><img src="img/7584_09_001.jpg" alt="Wiring a vibration motor"/></div><p>Please note that <a id="id989" class="indexterm"/>I have wired the piezoelectric device to a PWM-capable digital pin. I explained PWM in the previous chapter.</p><p>Here is the circuit schematic. This piezoelectric component is displayed as a small buzzer/speaker:</p><div><img src="img/7584_09_002.jpg" alt="Wiring a vibration motor"/></div><p>Of course, <a id="id990" class="indexterm"/>since we are going to use PWM, it means that we are going to simulate an analog output current. Considering the duty-cycle concept, we can feed the piezoelectric device using the <code class="literal">analogWrite()</code> function<a id="id991" class="indexterm"/> and then feed it with different voltages.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec125"/>Firmware generating vibrations</h2></div></div></div><p>Check the firmware. It <a id="id992" class="indexterm"/>is also available in the <code class="literal">Chapter09/vibrations/</code> folder.</p><div><pre class="programlisting">int piezoPin = 9; 
int value = 0;  // stores the current feed value
int incdec = 1; // stores the direction of the variation

void setup() {
}

void loop() {
  
  // test current value and change the direction if required
  if (value == 0 || value == 255) incdec *= -1;
  
  analogWrite(piezoPin, value + incdec);
  delay(30);
}</pre></div><p>We are using the <code class="literal">analogWrite()</code> function<a id="id993" class="indexterm"/> here again. This function takes the digital pin as an argument and value. This value from 0 to 255 is the duty cycle. It basically simulates an analog output.</p><p>We use it the<a id="id994" class="indexterm"/> usual way with the <code class="literal">incdec</code> (stands for increment-decrement) parameter. We store the increment value we want to use at each <code class="literal">loop()</code> execution.</p><p>This increment changes when the value reaches its boundaries, 0 or 255, and is inverted, providing a cheap way to make a cycle from 0 to 255, then to 0, then to 255, and so on.</p><p>This firmware makes the piezoelectric device vibrate cyclically from a low rate to a higher rate.</p><p>Let's control bigger motors now.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Higher current driving and transistors</h1></div></div></div><p>We talked about transistors<a id="id995" class="indexterm"/> in the previous chapter. We used them as digital switches. They can also be used as amplifiers, voltage stabilizers, and many other related applications.</p><p>You can find transistors almost everywhere and they are quite cheap. You can find the complete datasheet at <a class="ulink" href="http://www.fairchildsemi.com/ds/BC/BC547.pdf">http://www.fairchildsemi.com/ds/BC/BC547.pdf</a>. </p><p>The following is a basic diagram explaining how transistors work:</p><div><img src="img/7584_09_003.jpg" alt="Higher current driving and transistors"/><div><p>The transistor used as a digital switch in logical circuits</p></div></div><p>A <a id="id996" class="indexterm"/>transistor has the following legs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id997" class="indexterm"/> collector</li><li class="listitem" style="list-style-type: disc">The base<a id="id998" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">The <a id="id999" class="indexterm"/>emitter</li></ul></div><p>If we saturate the base by applying a 5 V power supply to it, all the current coming from the collector will be transmitted through the emitter.</p><p>When used like this, the NPN transistor<a id="id1000" class="indexterm"/> is a nice way to switch on/off high current that Arduino wouldn't have been able to drive by itself. By the way, this switch is controllable with Arduino because it only requires a very small amount of current to be provided to the base of the transistor.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>Sending 5 V to the transistor base closes the circuit. Putting the transistor base to ground opens the circuit.</p></div></div><p>In any case, where you need to have an external power supply to drive motors, we use this kind of design pattern.</p><p>Let's now learn about small current servos and then move further using transistors.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Controlling a servo</h1></div></div></div><p>A <strong>servomotor</strong>
<a id="id1001" class="indexterm"/> is also defined as a rotary actuator that allows for very fine control of angular positions. </p><p>Many servos are<a id="id1002" class="indexterm"/> widely available and quite cheap. I have had nice results with a 43 R servo, by Spring Model Electronics. You can find the datasheet at <a class="ulink" href="http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf">http://www.sparkfun.com/datasheets/Robotics/servo-360_e.pdf</a>. </p><p>Servos can drive a great amount of current. This means that you wouldn't be able to use more than one or two on your Arduino board without using an external source of power.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec126"/>When do we need servos?</h2></div></div></div><p>Whenever we need a way to control a position related to a rotation angle, we can use servos.</p><p>Servos can<a id="id1003" class="indexterm"/> not only be used to move small parts and make objects rotate, but can also be used to move the object including them. Robots work in this fashion, and there are many Arduino-related robot projects on the Web that are very interesting.</p><p>In the case of robots, the servo device case is fixed to a part of an arm, for instance, and the other part of the arm is fixed to the rotating part of the servo.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec127"/>How to control servos with Arduino</h2></div></div></div><p>There is a nice library <a id="id1004" class="indexterm"/>that should be used at first, named <code class="literal">Servo</code>.</p><p>This library supports <a id="id1005" class="indexterm"/>up to 12 motors on most Arduino boards and 48 on the Arduino Mega.</p><p>By using other Arduino boards over Mega, we can figure out some software limitations. For instance, pins 9 and 10 cannot be used for PWM's <a id="id1006" class="indexterm"/><code class="literal">analogWrite()</code>method (<a class="ulink" href="http://arduino.cc/en/Reference/analogWrite">http://arduino.cc/en/Reference/analogWrite</a>).</p><p>Servos are provided in<a id="id1007" class="indexterm"/> three-pin packages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">5 V</li><li class="listitem" style="list-style-type: disc">Ground</li><li class="listitem" style="list-style-type: disc">Pulse; that is, control pin</li></ul></div><p>Basically, the power supply can be easily provided by an external battery, and the pulse still remains the Arduino board.</p><p>Let's check the basic wiring.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec128"/>Wiring one servo</h2></div></div></div><p>The following diagram is that of a <a id="id1008" class="indexterm"/>servo wired to an Arduino for both power supply and control:</p><div><img src="img/7584_09_004.jpg" alt="Wiring one servo"/></div><p>The corresponding circuit diagram is as follows:</p><div><img src="img/7584_09_005.jpg" alt="Wiring one servo"/><div><p>One servo and Arduino</p></div></div><p>We are basically in <a id="id1009" class="indexterm"/>a very common digital output-based control pattern.</p><p>Let's check the code now.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec129"/>Firmware controlling one servo using the Servo library</h2></div></div></div><p>Here is a <a id="id1010" class="indexterm"/>firmware that<a id="id1011" class="indexterm"/> provides a cyclic movement from 0 degrees to 180 degrees. It is also available in the <code class="literal">Chapter09/OneServo/</code> folder.</p><div><pre class="programlisting">#include &lt;Servo.h&gt; 

Servo myServo;  // instantiate the Servo object
int angle = 0;  // store the current angle

void setup() 
{ 
  // pin 9 to Servo object myServo
  myServo.attach(9);  
} 


void loop() 
{ 
  for(angle = 0; angle &lt; 180; angle += 1)   
  {                                  
    myServo.write(angle);               
    delay(20);                       
  } 
  for(angle = 180; angle &gt;= 1; angle -=1)     
  {                                
    myServo.write(angle);              
    delay(20);                       
  } 
}</pre></div><p>We first include the <code class="literal">Servo</code> library header.</p><p>Then <a id="id1012" class="indexterm"/>we instantiate a <code class="literal">Servo</code> object instance named <code class="literal">myServo</code>.</p><p>In the <code class="literal">setup()</code> block, we<a id="id1013" class="indexterm"/> have to make something special. We attach pin 9 to the<a id="id1014" class="indexterm"/> <code class="literal">myServo</code> object. This explicitly defines the pin as the control pin for the <code class="literal">Servo</code> instance <code class="literal">myServo</code>.</p><p>In the <code class="literal">loop()</code> block, we have two <code class="literal">for()</code> loops, and it looks like the previous example with the piezoelectric device. We define a cycle, progressively incrementing the angle variable from 0 to 180 and then decrementing it from 180 to 0, and each time we pause for 20 ms.</p><p>There is also a function not used here that I want to mention, <code class="literal">Servo.read()</code>.</p><p>This function reads the current angle of the servo (that is, the value passed to the last call to <code class="literal">write()</code>). This can be useful if we are making some dynamic stuff without storing it at each turn.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Multiple servos with external power supply</h1></div></div></div><p>Let's imagine we need <a id="id1015" class="indexterm"/>three servos. As explained before, servos are motors, and motors convert current into movement, driving more current than other kinds of devices such as LEDs or sensors.</p><p>If your Arduino project requires a computer, you can supply power to it with the USB as long as you don't go beyond the 500 mA limit. Beyond this, you'd need to use an external power supply for some or all parts of your circuit.</p><p>Let's see how it goes with three servos.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec130"/>Three servos and an external power supply</h2></div></div></div><p>An external power<a id="id1016" class="indexterm"/> supply can be batteries or a wall adapter power supply.</p><p>We are going to use basic AA batteries here. This is also a way to supply Arduino if you don't need a computer and want Arduino to be autonomous. We will consider this option in the third part of this book about more advanced concepts.</p><p>Let's check the wiring for now:</p><div><img src="img/7584_09_006.jpg" alt="Three servos and an external power supply"/><div><p>Three servos wired to an Arduino, and power supplied by two AA batteries</p></div></div><p>In cases like this, we have to wire the grounds together. Of course, there is only one current source supply for the servos—the two AA batteries.</p><p>Let's check the circuit diagram:</p><div><img src="img/7584_09_007.jpg" alt="Three servos and an external power supply"/><div><p>Three servos, two AA batteries, and an Arduino</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec131"/>Driving three servos with firmware</h2></div></div></div><p>Here is an <a id="id1017" class="indexterm"/>example of<a id="id1018" class="indexterm"/> firmware for driving three servos:</p><div><pre class="programlisting">#include &lt;Servo.h&gt; 

Servo servo01;
Servo servo02;
Servo servo03;

int angle;

void setup() 
{ 
  servo01.attach(9);
  servo02.attach(10);
  servo03.attach(11);
} 

void loop() 
{ 
  for(angle = 0; angle &lt; 180; angle += 1)   
  {                                  
    servo01.write(angle);
    servo02.write(135-angle/2);
    servo03.write(180-angle);

    delay(15);                       
  }
}</pre></div><p>This very minimal firmware is also available in the <code class="literal">Chapter09/Servos/</code> folder.</p><p>We first instantiate our three servos and attach one pin for each in the <code class="literal">setup()</code> block.</p><p>In <code class="literal">loop()</code>, we<a id="id1019" class="indexterm"/> play with angles. As a new approach for <a id="id1020" class="indexterm"/>generative creation, I defined one variable only for the angle. This variable cyclically goes from 0 to 180 in each <code class="literal">loop()</code> turn.</p><p>The servo attached to pin 9 is driven with the angle value itself.</p><p>The servo attached to pin 10 is driven with the value [135-(angle/2)], varying itself from 135 to 45.</p><p>Then, the servo attached to pin 11 is driven with the value [180-angle], which is the opposite movement of the servo attached to pin 9.</p><p>This is also an example to show you how we can easily control one variable only, and program variations around this variable each time; here, we are making angles vary and we are combining the angle variable in different expressions.</p><p>Of course, we could control the servo position by using an external parameter, such as a potentiometer position or distance measured. This will combine concepts taught here with those in <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>, <em>Sensing with Digital Inputs</em>, and <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <em>Sensing the World–Feeling with Analog Inputs</em>.</p><p>Let's learn a bit more about step motors.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Controlling stepper motors</h1></div></div></div><p>
<strong>Stepper motor</strong> <a id="id1021" class="indexterm"/>is the common name for a <strong>step motor</strong>. They are motors that are controllable using small steps.</p><p>The full rotation is divided into a number of equal steps and the motors' positions can be controlled to move and hold at one of these steps easily with a high degree of accuracy, without any feedback mechanism.</p><p>There are a series <a id="id1022" class="indexterm"/>of electromagnetic coils that can be charged positively or negatively in a specific sequence. Controlling the sequence provides control about the movement, forward or backward in small steps.</p><p>Of course, we can do that using Arduino boards.</p><p>We are going to examine the unipolar stepper here.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec132"/>Wiring a unipolar stepper to Arduino</h2></div></div></div><p>Unipolar steppers <a id="id1023" class="indexterm"/>usually consist of a center shaft part and four<a id="id1024" class="indexterm"/> electromagnetic coils. We call them unipolar because power comes in through one pole. We can draw it as follows:</p><div><img src="img/7584_09_010.jpg" alt="Wiring a unipolar stepper to Arduino"/><div><p>A six-pin unipolar step motor </p></div></div><p>Let's check how it can be wired to our Arduino.</p><p>We need to supply power to the stepper from an external source. One of the best practices here is the use of a wall adapter. Pins 5 and 6 have to be fed a source of current.</p><p>Then, we need to control each pin from 1 to 4 with the Arduino. This will be done using the sink current system ULN2004, which is very similar to ULN2003 which we used in the previous chapter with our LED matrix. ULN2004 is suited for voltage from 6 V to 15 V. <a id="id1025" class="indexterm"/>When ULN2003 is 5 V, the stepper datasheet shows that we have to use this system instead of <a id="id1026" class="indexterm"/>ULN2003.</p><div><img src="img/7584_09_008.jpg" alt="Wiring a unipolar stepper to Arduino"/><div><p>A unipolar stepper connected to Arduino through the Darlington transistor array, ULN2004</p></div></div><p>Let's check the corresponding circuit diagram:</p><div><img src="img/7584_09_009.jpg" alt="Wiring a unipolar stepper to Arduino"/><div><p>A circuit diagram showing Arduino, the ULN2004 Darlington transistors array, and the stepper</p></div></div><p>We are using<a id="id1027" class="indexterm"/> an external power supply here again. All the grounds are wired together too.</p><p>Please notice <a id="id1028" class="indexterm"/>that the <strong>COM</strong> pin (pin number 9) has to be wired to the power supply source (+V).</p><p>If you remember correctly from the previous chapter, when we fed an input of the <a id="id1029" class="indexterm"/>ULN200x Darlington Transistor array, the corresponding output sinks the current to the ground.</p><p>In our case here, each pin of Arduino connected to the ULN2004 shift register can commute each pin of the stepper to the ground.</p><p>Let's design firmware for stepper control.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec133"/>Firmware controlling the stepper motor</h2></div></div></div><p>There is a <a id="id1030" class="indexterm"/>very nice library that can save us from providing<a id="id1031" class="indexterm"/> sequences of the HIGH and LOW pins, considering the movements we want to drive.</p><p>In order to control precise movements, we normally have to deal with specific sequences. These sequences are usually described in the datasheet.</p><p>Let's check the one available at <a class="ulink" href="http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf">http://www.sparkfun.com/datasheets/Robotics/StepperMotor.pdf</a>.</p><p>Sparkfun Electronics provides it for a model designed by Robotics.</p><p>We can see a table similar to the following one, named <a id="id1032" class="indexterm"/>
<strong>Drive Sequence Model</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>STEP</p>
</th><th style="text-align: left" valign="bottom">
<p>A</p>
</th><th style="text-align: left" valign="bottom">
<p>B</p>
</th><th style="text-align: left" valign="bottom">
<p>C</p>
</th><th style="text-align: left" valign="bottom">
<p>D</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>LOW</p>
</td><td style="text-align: left" valign="top">
<p>HIGH</p>
</td></tr></tbody></table></div><p>If you want to make a clockwise rotation, you should generate a sequence from 1 to 4, then 1, and so on, cyclically. Counterclockwise rotations require generating sequences from 4 to 1 and so on.</p><p>Instead of writing a lot of sequences like these, with some function, we can directly use the library named <code class="literal">Stepper</code>, which is now included in Arduino Core.</p><p>Here is the code, followed by the discussion. It is also available in the <code class="literal">Chapter09/StepperMotor/</code> folder.</p><div><pre class="programlisting">#include &lt;Stepper.h&gt;
#define STEPS 200

// create an instance of stepper class
Stepper stepper(STEPS, 8, 9, 10, 11);

int counter = 0; // store steps number since last change of direction
int multiplier = 1; // a basic multiplier

void setup() 
{ 
  stepper.setSpeed(30); // set the speed at 30 RPM
} 

void loop()
{

  // move randomly from at least 1 step
  stepper.step(multiplier);

  // counting how many steps already moved
  // then if we reach a whole turn, reset counter and go backward
  if (counter &lt; STEPS)  counter++ ;
  else { 
    counter = 0; 
    multiplier *= -1;
  }
}</pre></div><p>We first include the <code class="literal">Stepper</code> library.</p><p>Then <a id="id1033" class="indexterm"/>we define the number of steps that are <a id="id1034" class="indexterm"/>equivalent to one whole turn. In our datasheet, we can see that the first step is an angle of 1.8 degrees, with a 5 percent error room. We won't consider that error; we will take 1.8 degrees. This means we need 200 steps (200 * 1.8 = 360°) in order to make a whole turn.</p><p>We then instantiate a <code class="literal">Stepper</code> object by pushing five arguments, which are the step numbers for a whole turn, and the four pins of the Arduino wired to the stepper.</p><p>We then declare two helper variables for tracing and, sometimes, changing the rotation direction.</p><p>In the <code class="literal">setup()</code> block, we usually define the speed of the current instance handling the stepper. Here, I have set <code class="literal">30</code> (which stands for 30 rounds per minute). This can also be changed in the <code class="literal">loop()</code> block, considering specific conditions or whatever.</p><p>At last, in the <code class="literal">loop()</code> block, we move the stepper to an amount equal to the multiplier value, which is initially <code class="literal">1</code>. This means that at each run of the <code class="literal">loop()</code> method, the stepper rotates from step 1 (that is, 1.8 degrees) in the clockwise direction.</p><p>I added a logic test, which checks each time if the counter has completed the number of steps required to make a whole turn. If it hasn't, I increment it; otherwise, as soon as it reaches the limit (that is, the motor makes a whole turn since the beginning of the program execution), I reset the counter and invert the multiplier in order to make the stepper continue its walk, but in the other direction.</p><p>This is another pattern that you should keep in mind. These are all small patterns that will give you a lot of cheap and efficient ideas to use in each one of your future projects.</p><p>With <a id="id1035" class="indexterm"/>servos and steppers, we can now make things move.</p><p>In some<a id="id1036" class="indexterm"/> of my projects, I used two steppers, with one string bound to each and both these strings bound to a hanging pencil. We can draw on a wall by controlling the amount of string hanging on each side.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Air movement and sounds</h1></div></div></div><p>Making the air move can <a id="id1037" class="indexterm"/>generate nice audible sounds, and we are going learn a bit more about this in the following sections.</p><p>If you can make things move with Arduino, you will probably be able to make the air move too.</p><p>In fact, we have already done this, but we probably didn't move it enough to produce a sound.</p><p>This part is just a short introduction to some definitions and not a complete course about sound synthesis. These are the basic elements that we will use in the next few sections of the book, and as far as possible there will be references of websites or books provided that you can refer to if you are interested in learning more about those specific parts.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec134"/>What is sound actually?</h2></div></div></div><p>Sound <a id="id1038" class="indexterm"/>can be defined as a mechanical wave. This wave is an oscillation of pressure and can be transmitted through solid, liquid, or gas. By extension, we can define sound as the audible result of these oscillations on our ear.</p><p>Our ear, combined with further brain processes, is an amazing air-pressure sensor. It is able to evaluate the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Amplitude of a sound (related to the amount of air moving)</li><li class="listitem" style="list-style-type: disc">Frequency of a sound (related to the air oscillation amount)</li></ul></div><p>Of course, all these processes are real time, assuming higher or lower frequencies mix at this particular moment.</p><p>I'd really suggest that you read the amazing and efficient introduction to <em>How Digital Audio Works?</em>, by cycling 74, the maker of the Max 6 framework. You can read it online at <a class="ulink" href="http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio">http://www.cycling74.com/docs/max6/dynamic/c74_docs.html#mspdigitalaudio</a>.</p><p>A sound can contain more than one frequency, and it is generally a combination of the frequency content and the global perception of each frequency amplitude that gives the feeling of what we call the timbre of a sound. Psychoacoustics studies the perception of sound.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec135"/>How to describe sound</h2></div></div></div><p>We can describe sound in many ways.</p><p>Usually, there are two representations<a id="id1039" class="indexterm"/> of sound:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Variation of the amplitude over time. This description can be put on a graph and defined as a time-domain representation of sounds.</li><li class="listitem" style="list-style-type: disc">Variation of the amplitude depending on the frequency content. This is called the frequency-domain representation of sounds.</li></ul></div><p>There is a mathematical operation that provides an easy way to pass from one to the other, known as the Fourier transform<a id="id1040" class="indexterm"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/Fast_Fourier_transform">http://en.wikipedia.org/wiki/Fast_Fourier_transform</a>). Many implementations of this operation are available on computers, in the form of the<a id="id1041" class="indexterm"/> <strong>Fast Fourier Transform</strong> (<strong>FFT</strong>), which is an efficient method that provides fast approximate calculations.</p><p>Let's consider a sinusoidal variation of air pressure. This is one of the most simple sound waves.</p><p>Here are the two representations in the two domains:</p><div><img src="img/7584_09_011.jpg" alt="How to describe sound"/><div><p>Two representations of the same elementary sound produced by a sinusoidal variation of air pressure</p></div></div><p>Let's describe the two graphs of the preceding image.</p><p>In the time-domain representation, we can see a cyclical variation with a period. The period is the time equivalent of the spatial wavelength.</p><p>The period is the time needed to complete a complete vibrational cycle. Basically, if you can describe the variation over a period, you are able to totally draw the representation of the sound in time. Here, it is a bit obvious because we are watching a pure sine-based sound.</p><p>If you draw and observe a sound produced by a source, the amplitude variation over time will correspond directly to a variation of air pressure.</p><p>Considering <a id="id1042" class="indexterm"/>the orientation of the axis, we first have what we call a high-pressure front. This is the part of the curve above zero (represented by the time axis). This means that the pressure is high and our tympanum is pushed a bit more inside our ear.</p><p>Then, after a semi-period, the curve crosses zero and goes below, meaning that the air pressure is lower than the normal atmospheric pressure. Our tympanum also feels this variation. It is pulled a little bit.</p><p>In the frequency-domain representation, there is only a vertical line. This pulse-like graph in the previous figure represents the unique frequency contained in this sine-based sound. It is directly related to its period by a mathematical equation, as follows:
</p><div><img src="img/7584_09_inline01.jpg" alt="How to describe sound"/></div><p>
</p><p>Here, <code class="literal">T</code> is the period<a id="id1043" class="indexterm"/> in seconds and <code class="literal">f</code> is the frequency in <a id="id1044" class="indexterm"/>Hertz.</p><p>The higher the frequency, the more the sound is felt as high-pitched. The lesser it is, the more the sound is felt as low-pitched.</p><p>Of course, a high frequency means a short period and faster oscillations over time.</p><p>These are the basic steps in understanding how sound can be represented and felt.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec136"/>Microphones and speakers</h2></div></div></div><p>Microphones<a id="id1045" class="indexterm"/> are devices that are sensitive to the subtle variation of air pressure. Yes, they are sensors. They can translate air-pressure variations into voltage variations.</p><p>Speakers are<a id="id1046" class="indexterm"/> devices that implement a part that can move, pushing and pulling masses of air, making it vibrate and produce sounds. The movement is induced by voltage variations.</p><p>In both these cases, we have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A membrane</li><li class="listitem" style="list-style-type: disc">An electrical transducer system</li></ul></div><p>In the <a id="id1047" class="indexterm"/>microphone case, we change the air pressure and that produces an electrical signal.</p><p>In the<a id="id1048" class="indexterm"/> speaker case, we change the electrical signal and that produces an air pressure variation.</p><p>In each case, we have analog signals.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec137"/>Digital and analog domains</h2></div></div></div><p>Sounds sources<a id="id1049" class="indexterm"/> can be very different. If you knock on a table, you'll hear a sound. This is a basic analog- and physical-based sound. Here, you physically make the table vibrate a bit, pushing and pulling air around it; and because you are near it, your tympanum feels these subtle variations.</p><p>As soon as we talk <a id="id1050" class="indexterm"/>about digital equipment, we have some limitations considering storage and memory. Even if these are large and sufficient now, they aren't infinite.</p><p>And how can we describe something analog in that case? We already spoke about this situation when we described analog and digital input and output pins of Arduino.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec120"/>How to digitalize sound</h3></div></div></div><p>Imagine a system<a id="id1051" class="indexterm"/> that could sample the voltage variation of your microphones periodically. A sampling concept usually used is sample and hold.</p><p>The system is able to read the analog value at regular intervals of time. It takes a value, holds it as a constant until the next value, and so on.</p><p>We are talking about the sampling rate to define the sampling frequency. If the sampling rate is low, we will have a lower approximation of the analog signal than if what we would have had if the sampling rate was high.</p><p>A mathematical theorem provides us a limit that we have to keep in mind—the <a id="id1052" class="indexterm"/>Nyquist frequency.</p><p>In order to keep our sampling system process a safe artifact induced by the system itself, we have to sample at a minimum of two times the higher frequency in our original analog signal.</p><div><img src="img/7584_09_012.jpg" alt="How to digitalize sound"/><div><p>Example illustrating the sampling rate while sampling a sine wave</p></div></div><p>A higher <a id="id1053" class="indexterm"/>sampling rate not only means more precision and fidelity to the original analog wave, but also more points to store in the digital system. The result would be a heavier file, in terms of disks and filesystems.</p><p>Another element to keep in mind while sampling is the bit depth.</p><p>I voluntarily omitted it in the previous figure in order to not overload the drawings.</p><p>Indeed, we sampled a value over time, but how can you represent the value itself, the amplitude I mean? We use a bit-based coding system, as usual, with the digital equipment.</p><p>The <strong>bit depth</strong>
<a id="id1054" class="indexterm"/> is the resolution of the amplitude values from <code class="literal">-1</code> (the minimum possible) to <code class="literal">1</code> (the maximum possible).</p><p>The higher the bit depth, the more the subtle variations we can encode and record into our digital systems. Conversely, if we have a very low bit-depth sampler and we make a progressively decreasing amplitude variation, the sound will decrease considerably in a manner similar to the Doppler effect. For instance, we wouldn't be able to distinguish values from <code class="literal">0.5</code> to <code class="literal">0.6</code>; everything would only be <code class="literal">0.5</code> or <code class="literal">0.7</code> but never <code class="literal">0.6</code>. The sound would lose subtlety.</p><p>Usual <a id="id1055" class="indexterm"/>sampling rates and bit depth depends on the purpose of the final rendering.</p><p>Here are two commonly used quality standards:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CD quality is 44.1 kHz and 16-bit</li><li class="listitem" style="list-style-type: disc">DAT quality is 48 kHz and 16-bit</li></ul></div><p>Some recording and mastering studios use audio interfaces and internal processing at 96 kHz and 24 bits. Some people who love old-school sound engines still use lo-fi systems to produce their own sound and music at 16 kHz and 8 bits.</p><p>The process from analog to digital conversion is handled by the <a id="id1056" class="indexterm"/>
<strong>analog to digital converter</strong> (<strong>ADC</strong>). Its quality is the key to achieving good conversion. This process is similar to the one involved in Arduino when we use an analog input. Its ADC is 10 bits and it can read a value once every 111 microseconds, which is a sampling rate frequency of 9 kHz.</p><p>Buffers are used to smoothly process times and make things smoother in time.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec121"/>How to play digital bits as sounds</h3></div></div></div><p>We can also convert digital encoded sounds into analog sounds. This process is achieved by the <a id="id1057" class="indexterm"/>
<strong>digital to analog converter</strong> (<strong>DAC</strong>).</p><p>If the processor<a id="id1058" class="indexterm"/> sends bits of data from the encoded sound to <a id="id1059" class="indexterm"/>the DAC as a continuous flow of discrete values, the DAC takes all these values and converts them as an analog electrical signal. It interpolates values between each digital value, which often involves some processes (for example, low-pass filtering), in order to remove some artifacts such as harmonics above the Nyquist frequency.</p><p>In the world of digital audio, DAC power and quality is one of the most important aspects of our audio workstation. They have to provide high resolutions, a high sampling rate, a small total harmonic distortion and noise, and a great dynamic range.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec138"/>How Arduino helps produce sounds</h2></div></div></div><p>Let's come back to Arduino.</p><p>Arduino can <a id="id1060" class="indexterm"/>read and write digital signals. It can also read analog signals and <a id="id1061" class="indexterm"/>simulate analog output signals through PWM.</p><p>Wouldn't it be able to produce and even listen to sounds? Of course it would.</p><p>We can even use some dedicated components to make things better. For instance, we can use an ADC with a higher sampling rate in order to store sounds and a high-quality DAC too, if required. Today, we often use electronic hardware equipment to control software. We can, for instance, build a device based on Arduino, full of knobs and buttons and interface it with a software on the computer. This has to be mentioned here.</p><p>We can also use <a id="id1062" class="indexterm"/>Arduino as a sound trigger. Indeed, it is quite easy to turn it<a id="id1063" class="indexterm"/> into a small sequencer, popping out specific MIDI or OSC messages to an external synthesizer, for instance. Let's move further and go deeper into audio concepts specifically with the Arduino board.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Playing basic sound bits</h1></div></div></div><p>Playing a sound <a id="id1064" class="indexterm"/>requires a sound source and a speaker. Of course, it also requires a listener who is able to hear sounds.</p><p>Natively, Arduino is able to produce 8 kHz and 8-bit audio playback sounds on small PC speakers.</p><p>We are going to use the <code class="literal">tone()</code> function<a id="id1065" class="indexterm"/> available natively in the Arduino Core. As written at <a class="ulink" href="http://arduino.cc/en/Reference/Tone">http://arduino.cc/en/Reference/Tone</a>, we have to take care of the pins used when using this function, because it will interfere with PWM output on pins 3 and 11 (except for the Arduino MEGA).</p><p>This technique is also named<a id="id1066" class="indexterm"/> <strong>bit-banging</strong>. It is based on I/O pin toggling at a specific frequency.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec139"/>Wiring the cheapest sound circuit</h2></div></div></div><p>We are going to design the <a id="id1067" class="indexterm"/>cheapest sound generator ever with a small 8-ohm speaker, a resistor, and an Arduino board.</p><div><img src="img/7584_09_013.jpg" alt="Wiring the cheapest sound circuit"/><div><p>A small sound generator</p></div></div><p>The<a id="id1068" class="indexterm"/> connections made here ensure an audible sound. Let's program the chip now.</p><p>The corresponding circuit diagram is as follows:</p><div><img src="img/7584_09_014.jpg" alt="Wiring the cheapest sound circuit"/><div><p>The diagram of the sound generator</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec140"/>Playing random tones</h2></div></div></div><p>As a digital<a id="id1069" class="indexterm"/> artist and specifically as an electronic musician, I like to be free of the notes. I often use frequencies instead of notes; if you are interested, you can read about the microtonal concept at <a class="ulink" href="http://en.wikipedia.org/wiki/Microtonal_music">http://en.wikipedia.org/wiki/Microtonal_music</a>.</p><p>In this example, we don't use notes but frequencies to define and trigger our electronic music.</p><p>The code is also available in the <code class="literal">Chapter09/ ToneGenerator/</code> folder.</p><div><pre class="programlisting">void setup() {
  // initiate the pseudo-random number generator
  randomSeed(analogRead(0));
}

void loop() {
  // generate random pitch &amp; duration
  int pitch = random(30,5000);
  int duration = 1000 / (random(1000) + 1);

  // play a tone to the digital pin PWM number 8
  tone(8, pitch, duration);

  // make a pause
  delay(duration * 1.30);

  // stop the tone playing
  noTone(8);
}</pre></div><p>We initialize the pseudorandom number generator at first by reading the analog input <code class="literal">0</code>.</p><p>In the loop, we generate two numbers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The pitch is a number from 30 to 4,999; this is the frequency of the sound</li><li class="listitem" style="list-style-type: disc">The duration is a number from 1 ms to 1 s; this is the duration of the sound</li></ul></div><p>These two arguments are required by the<a id="id1070" class="indexterm"/> <code class="literal">tone()</code> function.</p><p>Then, we call <code class="literal">tone()</code>. The first argument is the pin where you feed the speaker.</p><p>The <code class="literal">tone()</code> function generates a square wave of the specified frequency on a pin as explained in its reference page at <a class="ulink" href="http://arduino.cc/en/Reference/Tone">http://arduino.cc/en/Reference/Tone</a>.</p><p>If we don't <a id="id1071" class="indexterm"/>provide a duration, the sound continues until the <code class="literal">noTone()</code> function<a id="id1072" class="indexterm"/> is called. The latter takes an argument that was used by the pin as well.</p><p>Now, listen to and enjoy this microtonal pseudorandom melody coming from your 8-bit chip.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Improving the sound engine with Mozzi</h1></div></div></div><p>The bit-banging technique <a id="id1073" class="indexterm"/>is very cheap and it's nice to learn <a id="id1074" class="indexterm"/>how it <a id="id1075" class="indexterm"/>works. However, I can quote some annoying things here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>No pure sound</strong>: Square waves are a sum of all odd harmonics at the fundamental frequency</li><li class="listitem" style="list-style-type: disc"><strong>No amplitude control available</strong>: Each note sounds at the same volume</li></ul></div><p>We are going to use a very nice library called Mozzi, by Tim Barrass. The official website is directly hosted on GitHub at <a class="ulink" href="http://sensorium.github.com/Mozzi/">http://sensorium.github.com/Mozzi/</a>. It includes the<a id="id1076" class="indexterm"/> <code class="literal">TimerOne</code> library, a very fast timer handler.</p><p>Mozzi provides a very nice 16,384 kHz, 8-bit audio output. There is also a nice basic audio toolkit containing oscillators, samples, lines and envelopes, and filtering too.</p><p>Everything<a id="id1077" class="indexterm"/> is available without external hardware and by only using <a id="id1078" class="indexterm"/>two pins of the Arduino.</p><p>We are going to design a small sound engine based on it.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec141"/>Setting up a circuit and Mozzi library</h2></div></div></div><p>Setting up the circuit is easy; it <a id="id1079" class="indexterm"/>is the<a id="id1080" class="indexterm"/> same as the latest one except that pin 9 has to be used.</p><p>Mozzi's <a id="id1081" class="indexterm"/>documentation says:</p><div><blockquote class="blockquote"><p>To hear Mozzi, connect a 3.5 mm audio jack with the centre wire to the PWM output on Digital Pin 9* on Arduino, and the black ground to the Ground on the Arduino. Use this as a line out which you can plug into your computer and listen to with a sound program like Audacity.</p><p>It is really easy to set up the hardware. You can find many 3.5 mm audio jack connector like that all over the Internet. In the following circuit diagram, I put a speaker instead of a jack connector but it works exactly the same with a jack connector, that latter having 2 pins, one ground and one signal related. Ground has to be connected to the Arduino's ground and the other pin to the digital pin 9 of the Arduino.</p><p>Then we have to install the library itself.</p><p>Download it from their website: <a class="ulink" href="http://sensorium.github.com/Mozzi">http://sensorium.github.com/Mozzi</a></p><p>Unzip it and rename the folder as Mozzi.</p><p>Then put it as usual in the place you put your libraries; in my case it is:</p><p>/Users/julien/Documents/Arduino/libraries/</p><p>Restart or just start your Arduino IDE and you'll be able to see the library in the IDE.</p><p>It is provided with a bunch of examples.</p><p>We are going to use the one about the sine wave.</p></blockquote></div><p>This is what the <a id="id1082" class="indexterm"/>Mozzi library looks like:</p><div><img src="img/7584_09_015.jpg" alt="Setting up a circuit and Mozzi library"/><div><p>A Mozzi installation revealing a lot of examples</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec142"/>An example sine wave</h2></div></div></div><p>As with any library, we have to learn how to use the<a id="id1083" class="indexterm"/> sine wave.</p><p>There are a lot of examples, and these are useful to learn how to design our own firmware step-by-step. Obviously, I won't describe all these examples, but only those in which I'll grab elements to make your own sound generator.</p><p>Let's check the sine wave example. It is also available in the <code class="literal">Chapter09/ MozziSoundGenerator/</code> folder.</p><div><pre class="programlisting">#include &lt;MozziGuts.h&gt;
#include &lt;Oscil.h&gt; // oscillator template
#include &lt;tables/sin2048_int8.h&gt; // sine table for oscillator

// use: Oscil &lt;table_size, update_rate&gt; oscilName (wavetable)
Oscil &lt;SIN2048_NUM_CELLS, AUDIO_RATE&gt; aSin(SIN2048_DATA);

// use #define for CONTROL_RATE, not a constant
#define CONTROL_RATE 64 // powers of 2 please


void setup(){
  startMozzi(CONTROL_RATE); // set a control rate of 64 (powers of 2 please)
  aSin.setFreq(440u); // set the frequency with an unsigned int or a float
}


void updateControl(){
  // put changing controls in here
}


int updateAudio(){
  return aSin.next(); // return an int signal centered around 0
}


void loop(){
  audioHook(); // required here
}</pre></div><p>At first, <a id="id1084" class="indexterm"/>some inclusions are done.</p><p>
<code class="literal">MozziGuts.h</code> is the basic header to include in any case.</p><p>
<code class="literal">Oscil.h</code> is the header to use if you need an oscillator.</p><p>We then include a wave table (sine wave).</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec122"/>Oscillators</h3></div></div></div><p>In the sound synthesis world, an <a id="id1085" class="indexterm"/>
<strong>oscillator</strong> is a basic unit that is capable of producing oscillations. It is often used not only for direct sound generation with frequencies varying from 20 Hz to 20 kHz (audible spectrum), but also as a modulator (usually with frequencies lower than 50 Hz). It has been used as the latter in this case. An oscillator is usually called a <a id="id1086" class="indexterm"/> <strong>Low Frequency Oscillator</strong> (<strong>LFO</strong>).</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec123"/>Wavetables</h3></div></div></div><p>A <strong>wavetable</strong> <a id="id1087" class="indexterm"/> is a very nice and efficient way to store whole pieces of sounds, generally cyclical or looped sounds.</p><p>We basically used this as a lookup table. Do you remember using it?</p><p>Instead of calculating our sine value over time in real time, we basically precalculate each value of a whole period, and then add the results into a table; each time we need it, we just have to scan the table from the beginning to the end to retrieve each value.</p><p>Of course, this IS definitely an approximation. But it saves a lot of CPU work.</p><p>A wavetable is defined by its size, the sample rate related, and of course the whole values.</p><p>Let's check what we can find in the <code class="literal">sin2048_int8.h</code> file:</p><div><img src="img/7584_09_016revised.jpg" alt="Wavetables"/></div><p>We can indeed find the number of cells: 2048 (that is, there are 2048 values in the table). Then, the sample rate is defined as 2048.</p><p>Let's go back to the example.</p><p>We then <a id="id1088" class="indexterm"/>define the Oscil object that creates an oscillator. </p><p>After the second <code class="literal">define</code> keyword related to the variable update frequency, we have the usual structure of <code class="literal">setup()</code> and <code class="literal">loop()</code>.</p><p>We also have <code class="literal">updateControl()</code> <a id="id1089" class="indexterm"/>and <code class="literal">updateAudio()</code> and<a id="id1090" class="indexterm"/> those aren't defined in the code. Indeed, they are related to Mozzi and are defined in the library files themselves.</p><p>The <code class="literal">setup()</code> block starts the Mozzi library at the specific control rate defined before. Then, we set up the oscillator defined before at a frequency of 440 Hz. 440 Hz is the frequency of the universal A note. In this context, it can be thought of as the audio equivalent of the Hello World example.</p><p>Nothing more about <code class="literal">updateControl()</code> here.</p><p>We return <code class="literal">aSin.next()</code> in <code class="literal">updateAudio()</code>. It reads and returns the next sample, which is understood as the next element, which is the next bit of sound.</p><p>In <code class="literal">loop()</code>, we call the<a id="id1091" class="indexterm"/> <code class="literal">audioHook()</code> function.</p><p>The global pattern is usual. Even if you use another library related to sound, inside or outside the Arduino world, you'll have to deal with this kind of pattern in four steps (generally, but it may differ):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Definitions in the header with some inclusions</li><li class="listitem" style="list-style-type: disc">Start of the audio engine</li><li class="listitem" style="list-style-type: disc">Permanent loop of a hook</li><li class="listitem" style="list-style-type: disc">Updating functions for rendering things before a commit, then in the hook</li></ul></div><p>If you upload this, you'll hear a nice A440 note, which may make you hum a little.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec143"/>Frequency modulation of a sine wave</h2></div></div></div><p>Let's now <a id="id1092" class="indexterm"/>merge <a id="id1093" class="indexterm"/>some concepts—sine wave generation, modulation, and input reading.</p><p>We are going to use two oscillators, one modulating the frequency of the other.</p><p>With a potentiometer, we can control the frequency of the modulating oscillator.</p><p>Let's first improve the circuit by adding a potentiometer.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec124"/>Adding a pot</h3></div></div></div><p>In the following circuit<a id="id1094" class="indexterm"/> diagram, we<a id="id1095" class="indexterm"/> have added a potentiometer in the sound generator circuit:</p><div><img src="img/7584_09_017.jpg" alt="Adding a pot"/></div><p>The circuit diagram is as follows:</p><div><img src="img/7584_09_018.jpg" alt="Adding a pot"/><div><p>Improving the sound generator</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec125"/>Upgrading the firmware for input handling</h3></div></div></div><p>This code is<a id="id1096" class="indexterm"/> also <a id="id1097" class="indexterm"/>available in the <code class="literal">Chapter09/MozziFMOnePot/</code> folder.</p><div><pre class="programlisting">#include &lt;MozziGuts.h&gt;
#include &lt;Oscil.h&gt;
#include &lt;tables/cos8192_int8.h&gt; // table for Oscils to play
#include &lt;utils.h&gt; // for mtof

#define CONTROL_RATE 64 // powers of 2 please

Oscil&lt;COS8192_NUM_CELLS, AUDIO_RATE&gt; aCos(COS8192_DATA);
Oscil&lt;COS8192_NUM_CELLS, AUDIO_RATE&gt; aVibrato(COS8192_DATA);

const long intensityMax = 500;

int potPin = A0;
int potValue = 0;
void setup(){
  startMozzi(CONTROL_RATE);
  aCos.setFreq(mtof(random(21,80)));
  aVibrato.setFreq((float) map(potValue, 0, 1024, 0, intensityMax));
}

void loop(){
  audioHook();
}

void updateControl(){
  potValue = analogRead(potPin);
}

int updateAudio(){
  long vibrato = map(potValue, 0, 1024, 0, intensityMax) * aVibrato.next();
  return (int)aCos.phMod(vibrato);
}</pre></div><p>In this example, we use two oscillators, both based on a cosine wavetable:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">aCos</code> stands for the sound itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">aVibrato</code> is the modulator</li></ul></div><p>Since <a id="id1098" class="indexterm"/>we have a potentiometer here, we need to scale things a bit.</p><p>
<code class="literal">intensityMax</code> is the <a id="id1099" class="indexterm"/>maximum intensity of the modulation effect. I chose 500 after testing it myself.</p><p>We often use the following technique to scale things: use a constant (or even a "real" variable) and then multiply it by the value you can vary. This can be done in one pass by using the<a id="id1100" class="indexterm"/> <code class="literal">map()</code> function. We already used it in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <em>Sensing the World–Feeling with Analog Inputs</em>, for the same purpose—scaling an analog input value.</p><p>In that case, at the maximum value, your potentiometer (more generally your input) changes the parameter you want to alter to its maximum value.</p><p>Let's continue the review of the code.</p><p>We define the potentiometer pin n and the variable <code class="literal">potPin</code>. We also define <code class="literal">potValue</code> to <code class="literal">0</code>.</p><p>In the <code class="literal">setup()</code> block, we start Mozzi. We define the frequency of the oscillator as <code class="literal">aCos</code>. The frequency itself is the result of the <code class="literal">mtof()</code> function. <code class="literal">mtof</code> stands for <a id="id1101" class="indexterm"/>
<strong>MIDI to Frequency</strong>.</p><p>As we are going to describe it a bit later, MIDI protocol codes many bytes of values, including the pitch of notes it uses to transport from sequencers to instruments. Each MIDI note fits with real note values in the real world, and each note fits with a particular frequency. There are tables that show the frequency of each MIDI note, and Mozzi includes that for us.</p><p>We can <a id="id1102" class="indexterm"/>pass a MIDI note pitch as argument to the <code class="literal">mtof()</code> function, and it will return the right frequency. Here, we use the <code class="literal">random(21,80)</code> function to generate a MIDI note pitch from 21 to 79, which means from A0 to A5.</p><p>Of course, this use <a id="id1103" class="indexterm"/>case is a pretext to begin introducing MIDI. We could have directly used a <code class="literal">random()</code> function<a id="id1104" class="indexterm"/> to generate a frequency.</p><p>We then read the current value of the analog input A0 and use it to calculate a scaled value of the frequency of the modulating oscillator, <code class="literal">aVibrato</code>. This is only to provide more randomness and weirdness. Indeed, if your pot isn't at the same place each time you restart Arduino, you'll have a different modulation frequency.</p><p>The <code class="literal">loop()</code> block then executes the <code class="literal">audioHook()</code> method<a id="id1105" class="indexterm"/> constantly to produce audio.</p><p>And the smart thing here is the<a id="id1106" class="indexterm"/> <code class="literal">updateControl()</code> method. We add the <code class="literal">analogRead()</code> function<a id="id1107" class="indexterm"/> that reads the value of the analog input. Doing this in <code class="literal">updateControl()</code> is better, considering the purpose of this function. Indeed, the Mozzi framework separates the audio rendering time-critical tasks from the control (especially human control) pieces of code.</p><p>You'll come across this situation very often in many frameworks, and it can confuse you the first time. It is all about the task and its scheduling. Without reverse-engineering the Mozzi concepts here, I would like to say only that time-critical events have to be handled more carefully than human actions.</p><p>Indeed, even if it seems as if we can be very fast at turning a knob, it is really slow compared to the sample rate of Mozzi, for instance (16,384 kHz). This means we cannot stop the whole process only to test and check, if we change the value of this potentiometer constantly. Things are separated; keep this in mind and use the framework carefully.</p><p>Here, we read the value in <code class="literal">updateControl()</code> and store it in the <code class="literal">potValue</code> variable.</p><p>Then, in <code class="literal">updateAudio()</code>, we calculate the vibrato value as the value of <code class="literal">potValue</code> scaled from <code class="literal">0</code> to the value of <code class="literal">intensityMax</code>, multiplied by the next value of the oscillator in its wavetable.</p><p>This value is then used in a new method named <code class="literal">phMod</code>. This method applies a phase modulation to the oscillator for which it is called. This modulation is a nice way to produce a frequency modulation effect.</p><p>Now, upload<a id="id1108" class="indexterm"/> the firmware, add the earphone, and<a id="id1109" class="indexterm"/> turn the potentiometer. You should be able to hear the effect and control it with the potentiometer.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Controlling the sound using envelopes and MIDI</h1></div></div></div><p>We are now okay to<a id="id1110" class="indexterm"/> design small bits of a sound engine using <a id="id1111" class="indexterm"/>Mozzi. There are other libraries around,<a id="id1112" class="indexterm"/> and what we learned will be used with those<a id="id1113" class="indexterm"/> two. Indeed, these are patterns.</p><p>Let's check how we can control our Arduino-based sound engine using a standard protocol from a computer or other device. Indeed, it would be interesting to be able to trigger notes to change sound parameters using a computer, for instance.</p><p>Both are protocols used in the music and new media related projects and works.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec144"/>An overview of MIDI</h2></div></div></div><p>
<strong>MIDI</strong>
<a id="id1114" class="indexterm"/> is short for <strong>Musical Instrument Digital Interface</strong>. It is a specification standard that enables digital music instruments, computers, and all required devices to connect and communicate with one another. It was introduced in 1983, and at the time of writing has just celebrated its 30th anniversary. The<a id="id1115" class="indexterm"/> reference website is <a class="ulink" href="http://www.midi.org">http://www.midi.org</a>.</p><p>MIDI can transport the following data over a basic serial link:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Notes (on/off, after touch)</li><li class="listitem" style="list-style-type: disc">Parameter changes (control change, program change)</li><li class="listitem" style="list-style-type: disc">Real-time messages (clock, transport state such as start/stop/continue)</li><li class="listitem" style="list-style-type: disc">System exclusives, allowing manufacturers to create their message</li></ul></div><p>A new protocol appeared and is used very widely today: OSC. It isn't a proper protocol, by the way.</p><p>
<strong>OSC</strong>
<a id="id1116" class="indexterm"/> stands for <strong>Open Sound Control</strong> and is a content format developed by two people at the<a id="id1117" class="indexterm"/> <strong>Center for New Music and Audio Technologies</strong> (<strong>CNMAT</strong>) at University of Berkeley, California. It was originally intended for sharing gestures, parameters, and sequences of notes during musical performances. It is very widely used as a replacement for MIDI today, providing a higher resolution and faster transfer. Its <a id="id1118" class="indexterm"/>main feature is the native network transport possibility. OSC<a id="id1119" class="indexterm"/> can be transported over UDP or TCP in an IP environment, making it easy to be used over Wi-Fi networks and even over the Internet.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec145"/>MIDI and OSC libraries for Arduino</h2></div></div></div><p>I'd suggest two <a id="id1120" class="indexterm"/>libraries here. I <a id="id1121" class="indexterm"/>tested them myself and they are stable and efficient. You can check the one about MIDI at <a class="ulink" href="http://sourceforge.net/projects/arduinomidilib">http://sourceforge.net/projects/arduinomidilib</a>. You can check this one about OSC at <a class="ulink" href="https://github.com/recotana/ArdOSC">https://github.com/recotana/ArdOSC</a>. You shouldn't have too many difficulties installing them now. Let's install at least MIDI, and restart the IDE.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec146"/>Generating envelopes</h2></div></div></div><p>In the audio field, an <a id="id1122" class="indexterm"/>
<strong>envelope</strong> is a shape used to modify something. For instance, imagine an amplitude envelope shaping a waveform.</p><p>You have a waveform first. I <a id="id1123" class="indexterm"/>generated this sine with Operator synthesizer in Ableton Live<a id="id1124" class="indexterm"/> (<a class="ulink" href="https://www.ableton.com">https://www.ableton.com</a>), the famous digital audio workstation. Here is a screenshot:</p><div><img src="img/7584_09_019.jpg" alt="Generating envelopes"/><div><p>A basic sine wave generated by an operator in Ableton Live's Operator FM synth</p></div></div><p>The sine doesn't show very well due to aliasing; here is another screenshot, which is the same wave but more zoomed in:</p><div><img src="img/7584_09_020.jpg" alt="Generating envelopes"/><div><p>A sine wave</p></div></div><p>This sine wave has a<a id="id1125" class="indexterm"/> global constant amplitude. Of course, the air pressure push and pull constantly, but the global maximums and minimums are constant over time.</p><p>Musicians always want to make their sounds evolve over time, subtly or harshly. </p><p>Let's apply an envelope to this same wave that will make it increase the global volume progressively, then decrease it a bit, and then decrease quickly to zero:</p><div><img src="img/7584_09_021.jpg" alt="Generating envelopes"/><div><p>A sine wave altered by an envelope with a long attack</p></div></div><p>Here is the result with another envelope:</p><div><img src="img/7584_09_022.jpg" alt="Generating envelopes"/><div><p>A sine wave altered by an envelope with a very short attack</p></div></div><p>Basically, an <a id="id1126" class="indexterm"/>envelope is a series of points in time. At each moment, we multiply the value of the original signal by the value of the envelope.</p><p>This produces a sound evolution over time.</p><p>We can use envelopes in many cases because they can modulate amplitude, as we just learned. We can also use them to alter the pitch (that is, the frequency) of a sound.</p><p>Usually, envelopes are triggered (that is, applied to the sound) at the same time the sound is triggered, but of course we can use the offset retrigger feature to retrigger the envelope during the same triggered sound and do much more.</p><p>Here is a last example showing a pitch envelope. The envelope makes the frequency of the sound decrease. As you can see, the waves are tighter on the left than on the right. The sound changes from high-pitched to low-pitched.</p><div><img src="img/7584_09_023.jpg" alt="Generating envelopes"/><div><p>An envelope modulating the pitch of a sound</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec147"/>Implementing envelopes and MIDI</h2></div></div></div><p>We are going to <a id="id1127" class="indexterm"/>design a <a id="id1128" class="indexterm"/>very cheap sound synthesizer that will be able to trigger notes when it receives a MIDI note message and alter the sound when it receives a particular MIDI Control Change message.</p><p>The <a id="id1129" class="indexterm"/>MIDI part <a id="id1130" class="indexterm"/>will be handled by the library and the envelope will be explicated and coded.</p><p>You can check the following code. This code is also available in the <code class="literal">Chapter09/MozziMIDI/</code> folder.</p><div><pre class="programlisting">#include &lt;MIDI.h&gt;
#include &lt;MozziGuts.h&gt;
#include &lt;Oscil.h&gt; // oscillator template
#include &lt;Line.h&gt; // for envelope
#include &lt;utils.h&gt; // for mtof
#include &lt;tables/sin2048_int8.h&gt; // sine table for oscillator


// use #define for CONTROL_RATE, not a constant
#define CONTROL_RATE 128 // powers of 2 please

// declare an oscillator using a sine tone wavetable
// use: Oscil &lt;table_size, update_rate&gt; oscilName (wavetable)
Oscil &lt;SIN2048_NUM_CELLS, AUDIO_RATE&gt; aSin(SIN2048_DATA);

// for envelope
Line &lt;unsigned int&gt; aGain;
unsigned int release_control_steps = CONTROL_RATE; // 1 second of control
unsigned int release_audio_steps = 16384; // 1 second of audio
int fade_counter;

float vol= 1. ; // store the master output volume

unsigned int freq; // to convey control info from MIDI handler to updateControl()


void HandleControlChange(byte channel, byte CCnumber, byte value) { 
  switch(CCnumber){
    case 100:
      vol = map(value,0, 127, 0., 1.);
    break;
  }
}

void HandleNoteOn(byte channel, byte pitch, byte velocity) { 
  // scale velocity for high resolution linear fade on Note-off later
  freq = mtof(pitch);
  aGain.set(velocity&lt;&lt;8); // might need a fade-in to avoid clicks

}


void HandleNoteOff(byte channel, byte pitch, byte velocity) { 

  // scale velocity for high resolution linear fade on Note-off later
  aGain.set(0,release_audio_steps);
  fade_counter = release_control_steps;
}

void setup() {
  
  // Initiate MIDI communications, listen to all channels
  MIDI.begin(MIDI_CHANNEL_OMNI);    

  // Connect the HandleControlChange function to the library, so it is called upon reception of a NoteOn.
  MIDI.setHandleControlChange(HandleControlChange); // Put only the name of the function
  
    // Connect the HandleNoteOn function to the library, so it is called upon reception of a NoteOn.
  MIDI.setHandleNoteOn(HandleNoteOn);  // Put only the name of the function


   // Connect the HandleNoteOn function to the library, so it is called upon reception of a NoteOn.
  MIDI.setHandleNoteOff(HandleNoteOff);  // Put only the name of the function

  aSin.setFreq(440u); // default frequency
  startMozzi(CONTROL_RATE); 
}


void updateControl(){
  // Ideally, call MIDI.read the fastest you can for real-time performance.
  // In practice, there is a balance required between real-time 
  // audio generation and a responsive midi control rate.
  MIDI.read();

  if (fade_counter-- &lt;=0) aGain.set(0,0,2); // a line along 0
}


int updateAudio(){
  // aGain is scaled down to usable range
  return (int) ((aGain.next()&gt;&gt;8) * aSin.next() * vol )&gt;&gt;8; // &gt;&gt;8 shifts the multiplied result back to usable output range
}


void loop() {
    audioHook(); // required here
}</pre></div><p>At first, <a id="id1131" class="indexterm"/>we include the MIDI library. Then we include the Mozzi library.</p><p>Of course, the<a id="id1132" class="indexterm"/> right bits of Mozzi to include are a bit different for each project. Studying examples helps to understand what goes where. Here, we not only need Oscil for the basic features of the oscillator, but also need Line. Line is related to interpolation functions in Mozzi. Generating an envelope deals with this. Basically, we choose two values and a time duration, and it starts from the first one and reaches the second one in the time duration you choose.</p><p>We also include the wavetable related to a sine.</p><p>We define a control rate higher than before, at 128. That means the <code class="literal">updateControl()</code> function is called 128 times per second.</p><p>Then we define the oscillator as <code class="literal">aSin</code>.</p><p>After these bits, we define an envelope by declaring an instance of the Line object.</p><p>We define two variables that store the release part of the envelope duration, one for the control part in one second (that is, the number of steps will be the value of <code class="literal">CONTROL_RATE</code>) and one for the audio part in one second too (that is, 16,384 steps). Lastly, a variable named <code class="literal">fade_counter</code> is defined.</p><p>
<code class="literal">HandleControlChange()</code> <a id="id1133" class="indexterm"/>is a function that is called when a MIDI Control Change message is sent to Arduino. The message comes with these bytes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MIDI channel</li><li class="listitem" style="list-style-type: disc">CC number</li><li class="listitem" style="list-style-type: disc">Value</li></ul></div><p>These arguments are passed to the<a id="id1134" class="indexterm"/> <code class="literal">HandleControlChange()</code> function, and you can access them directly in your code.</p><p>This is a very common way to use event handlers. Almost all event listener frameworks are made like this. You have some function and you can use them and put whatever you want inside them. The framework itself handles the functions that have to be called, saving as much CPU time as possible.</p><p>Here, we add a <code class="literal">switch</code> statement with only one case over the <code class="literal">CCNumber</code> variable.</p><p>This <a id="id1135" class="indexterm"/>means if you send a MIDI Control Change 100 <a id="id1136" class="indexterm"/>message, this case being matched, the value of <code class="literal">CC</code> will be processed and the <code class="literal">vol</code> variable will be altered and modified. This Control Change will control the master output volume of the synth.</p><p>In the same way, <code class="literal">HandleNoteOn()</code> and <code class="literal">HandleNoteOff()</code> <a id="id1137" class="indexterm"/>handle MIDI note messages.</p><p>Basically, a MIDI Note On message is sent when you push a key on your MIDI keyboard. As soon as you release that key, a MIDI Note Off message pops out.</p><p>Here, we have two functions handling these messages.</p><p>
<code class="literal">HandleNoteOn()</code> <a id="id1138" class="indexterm"/>parses the message, takes the velocity part, bit shifts it on the left to 8 bits, and passes it to <code class="literal">aGain</code> through the <code class="literal">set()</code> method. When a MIDI Note On message is received, the envelope <code class="literal">aGain</code> is triggered to its maximum value. When a MIDI Note Off message is received, the envelope is triggered to reach 0 in one second via the number of audio steps discussed before. The <code class="literal">fade</code> counter is also reset to its maximum value at the moment the key is released.</p><p>In this way, we have a system responding to the MIDI Note On and MIDI Note Off messages. When we push a key, a sound is produced until we release the key. When we release it, the sound decreases linearly to 0, taking one second.</p><p>The <code class="literal">setup()</code> method includes the setup of the MIDI library:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MIDI.begin()</code> instantiates the communication</li><li class="listitem" style="list-style-type: disc"><code class="literal">MIDI.setHandleControlChange()</code> lets you define the name of the function called when a control change message is coming</li><li class="listitem" style="list-style-type: disc"><code class="literal">MIDI.setHandleNoteOn()</code> lets you define the name of the function called when a Note On message is coming</li><li class="listitem" style="list-style-type: disc"><code class="literal">MIDI.setHandleNoteOff()</code> lets you define the name of the function called when a Note Off message is coming</li></ul></div><p>It also includes the setup of Mozzi.</p><p>The <code class="literal">loop()</code> function is quite familiar now.</p><p>The <code class="literal">updateControl()</code> function<a id="id1139" class="indexterm"/> does not contain the time-critical part of the sound generator. It doesn't mean this function is called rarely; it is called less than <code class="literal">updateAudio()</code>—128 times per second for control and 16,384 per second for audio, as we have seen before.</p><p>This is the <a id="id1140" class="indexterm"/>perfect place to read our MIDI flow, with the <code class="literal">MIDI.read()</code> function.</p><p>This is where <a id="id1141" class="indexterm"/>we can trigger our decreasing envelope to 0 as soon as the <code class="literal">fade</code> counter reaches 0 and not before, making the sound in one second, as we checked before.</p><p>Lastly, the <code class="literal">updateAudio()</code> function<a id="id1142" class="indexterm"/> returns the value of the oscillator multiplied by the envelope value too. This is the purpose of the envelope. Then, <code class="literal">vol</code> multiplies the first result in order to add a key to control the master output volume.</p><p>The <code class="literal">&lt;&lt;8</code> and <code class="literal">&gt;&gt;8</code> expressions here are for setting a high-resolution linear fade on Note Off, and this is a nice trick provided by Tim Barrass himself.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec148"/>Wiring a MIDI connector to Arduino</h2></div></div></div><p>This <a id="id1143" class="indexterm"/>schematic is <a id="id1144" class="indexterm"/>based on the MIDI electrical specification diagram at <a class="ulink" href="http://www.midi.org/techspecs/electrispec.php">http://www.midi.org/techspecs/electrispec.php</a>.</p><div><img src="img/7584_09_024.jpg" alt="Wiring a MIDI connector to Arduino"/><div><p>The MIDI-featured sound generator based on Arduino</p></div></div><p>The<a id="id1145" class="indexterm"/> corresponding<a id="id1146" class="indexterm"/> circuit diagram is as follows:</p><div><img src="img/7584_09_025.jpg" alt="Wiring a MIDI connector to Arduino"/><div><p>The MIDI connector wired to the Arduino-based sound generator</p></div></div><p>As you<a id="id1147" class="indexterm"/> can see, the digital pin 0 (serial input) is involved. This <a id="id1148" class="indexterm"/>means we won't be able to use the serial communication over USB. In fact, we want to use our MIDI interface.</p><p>Let's upload the code and start this small sequencer in Max 6.</p><div><img src="img/7584_09_026.jpg" alt="Wiring a MIDI connector to Arduino"/><div><p>The <em>cheap sequencer for chips</em> fires MIDI notes and MIDI control changes</p></div></div><p>The sequencer is quite self-explanatory. Toggle on the toggle button at the top-left and it starts the sequencer, reading each step in the multislider object. The higher a slider is, the higher the pitch of this note into that step will be.</p><p>You can <a id="id1149" class="indexterm"/>click on the button under the multislider on the left, and it will generate a random sequence of 16 elements.</p><p>Choose the <a id="id1150" class="indexterm"/>correct MIDI output bus from the list menu on the top-right.</p><p>Connect your Arduino circuit and your MIDI interface with a MIDI cable, and listen to the music. Change the multislider content and the sequence played. If you turn the dial, the volume will change.</p><p>Everything here is transmitted by MIDI. The computer is a sequencer and a remote controller and the Arduino is the synthesizer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Playing audio files with the PCM library</h1></div></div></div><p>Another way to play<a id="id1151" class="indexterm"/> sounds is by reading already<a id="id1152" class="indexterm"/> digitalized sounds.</p><p>Audio samples define digital content, often stored as files on filesystems that can be read and converted into audible sound.</p><p>Samples can be very heavy from the memory size point of view.</p><p>We are going to use the PCM library set up by David A. Mellis from MIT. Like other collaborators, he is happy to be a part of this book.</p><p>The reference page is <a class="ulink" href="http://hlt.media.mit.edu/?p=1963">http://hlt.media.mit.edu/?p=1963</a>.</p><p>Download the library and install it.</p><p>Imagine that we have enough space in the Arduino memory spaces. How can we do the installation if we want to convert a sample on our disks as a C-compatible structure?</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec149"/>The PCM library</h2></div></div></div><p>Check this <a id="id1153" class="indexterm"/>code. It is also available in the <code class="literal">Chapter09/PCMreader/</code> folder.</p><div><img src="img/7584_09_027.jpg" alt="The PCM library"/><div><p>Our PCM reader</p></div></div><p>There is an array of <code class="literal">unsigned char</code> datatypes declared as <code class="literal">const</code>, and especially with the <code class="literal">PROGMEM</code> keyword named <code class="literal">sample</code>.</p><p>
<code class="literal">PROGMEM</code> forces this constant to be put in the program space instead of RAM, because the latter is much smaller. Basically, this is the sample. The <code class="literal">startPlayback()</code> function<a id="id1154" class="indexterm"/> is able to play a sample from an array. The <code class="literal">sizeof()</code> method<a id="id1155" class="indexterm"/> calculates the size of the memory of the array.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec150"/>WAV2C – converting your own sample</h2></div></div></div><p>Since we <a id="id1156" class="indexterm"/>have already played with wavetable, and this is what we will be doing hereafter, we can store our sample waveforms in the Arduino code directly.</p><p>Even if dynamic reading of the audio file from an SD card would seem smarter, PCM provides an even easier way to proceed—directly reading an analog conversion of an array while storing a waveform into a sound.</p><p>We first have to transform a sample as C data.</p><p>David Ellis made an open source, small processing-based program that provides a way to do this; it can be found at <a class="ulink" href="https://github.com/damellis/EncodeAudio">https://github.com/damellis/EncodeAudio</a>.</p><p>You can download it from the reference project page directly compiled for your OS.</p><p>Launch it, choose a WAV file (PCM-based encoded sample), and then it will copy something huge in your clipboard.</p><p>Then, you only have to copy-paste this content into the array defined before.</p><p>Be careful to correctly paste it between the curly brackets.</p><p>Here is the content copied from the clipboard after converting a <code class="literal">wav</code> sample that I made myself:</p><div><img src="img/7584_09_028.jpg" alt="WAV2C – converting your own sample"/><div><p>A huge amount of data to paste in a C array</p></div></div><p>In the same folder, I have put  a <code class="literal">.wav</code> file I designed. It is a short rhythm recorded in 16 bits.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec151"/>Wiring the circuit</h2></div></div></div><p>The circuit is<a id="id1157" class="indexterm"/> similar to the one in the <em>Playing basic sound bits</em> section, except that we have to use the digital pin 11 here. And we cannot use PWM on pins 3, 9, and 10 because the timers involved in the library consume them.</p><div><img src="img/7584_09_029.jpg" alt="Wiring the circuit"/><div><p>Wiring our PCM reader</p></div></div><p>The circuit <a id="id1158" class="indexterm"/>diagram is easy too.</p><div><img src="img/7584_09_030.jpg" alt="Wiring the circuit"/><div><p>Don't forget to use pin 11 with the PCM library</p></div></div><p>Now, let's play the music.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec152"/>Other reader libraries</h2></div></div></div><p>There are also other<a id="id1159" class="indexterm"/> libraries providing ways to read and decode the MP3 format or other formats.</p><p>You can find a lot on the Internet; but be careful as some of them require some shields, like the one on the Sparkfun website at <a class="ulink" href="https://www.sparkfun.com/products/10628">https://www.sparkfun.com/products/10628</a>.</p><p>This provides a shield with an SD Card reader, a 3.5 mm stereo headphone jack, a VS1053 shift register, and very versatile decoder chips for MP3, WMA, AAC, and other formats.</p><p>It is a very dedicated solution and we only have to interface the shield with Arduino.</p><p>Arduino only sends and receives bits from the shield, which takes care of the decoding of the encoded files, the conversion to analog signals, and so on.</p><p>I'd really suggest testing it. There are many examples on the Sparkfun website.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Summary</h1></div></div></div><p>We learned how to make things move right here with Arduino. In particular, we learned about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving solid things with motors</li><li class="listitem" style="list-style-type: disc">Moving air with sound generators</li></ul></div><p>Of course, unfortunately, I cannot describe more on how to make things move.</p><p>If you need help with sound, please contact me at <code class="email">&lt;<a class="email" href="mailto:book@cprogrammingforarduino.com">book@cprogrammingforarduino.com</a>&gt;</code>. I will be a happy to help you with sound inputs too, for instance.</p><p>This is the end of the second part of the book. We discovered a lot of concepts together. And now we are going to dig into some more advanced topics.</p><p>We are able to understand firmware design and inputs and outputs, so let's move further.</p><p>We are going to dig deeper into precise examples with I2C/SPI communication to use GPS modules, 7-segment LED systems, and more. We are also going to dig into Max 6, and especially how we can use Arduino to control some OpenGL visuals on the computer. We'll discover network protocols and how to use Arduino even without any network cables, with Wi-Fi. At last, we'll design a small library together and check some nice tips and tricks to improve our C code.</p></div></body></html>