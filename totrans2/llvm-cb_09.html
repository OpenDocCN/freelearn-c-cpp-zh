<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Using LLVM for Various Useful Projects</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Exception handling in LLVM</li><li class="listitem">Using sanitizers</li><li class="listitem">Writing the garbage collector with LLVM</li><li class="listitem">Converting LLVM IR to JavaScript</li><li class="listitem">Using the Clang Static Analyzer</li><li class="listitem">Using bugpoint</li><li class="listitem">Using LLDB</li><li class="listitem">Using LLVM utility passes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec92"/>Introduction</h1></div></div></div><p>Until now, you have learned how to write the frontend of a compiler, write optimizations and create a backend. In this chapter, the last of this book, we will look into some other features that the LLVM infrastructure provides and how we can use them in our projects. We won't be diving very deep into the details of the topics in this chapter. The main point is to let you know about these important tools and techniques, which are hot points in LLVM.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec93"/>Exception handling in LLVM</h1></div></div></div><p>In this recipe, we will<a id="id408" class="indexterm"/> look into the <a id="id409" class="indexterm"/>exception handling infrastructure of LLVM. We will discuss how the exception handling information looks in the IR and the intrinsic functions provided by LLVM for exception handling.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec267"/>Getting ready...</h2></div></div></div><p>You must understand how exception handling works normally and the concepts of <code class="literal">try</code>, <code class="literal">catch</code> and <code class="literal">throw</code> and so on. You must also have Clang and LLVM installed in your path.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec268"/>How to do it…</h2></div></div></div><p>We will take an <a id="id410" class="indexterm"/>example to<a id="id411" class="indexterm"/> describe how exception handling works in LLVM:</p><div><ol class="orderedlist arabic"><li class="listitem">Open a file to write down the source code, and enter the source code to test exception handling:<div><pre class="programlisting">
<strong>$ cat eh.cpp</strong>
<strong>class Ex1 {};</strong>
<strong>void throw_exception(int a, int b) {</strong>
<strong>  Ex1 ex1;</strong>
<strong>  if (a &gt; b) {</strong>
<strong>    throw ex1;</strong>
<strong>  }</strong>
<strong>}</strong>

<strong>int test_try_catch() {</strong>
<strong>  try {</strong>
<strong>    throw_exception(2, 1);</strong>
<strong>  }</strong>
<strong>  catch(...) {</strong>
<strong>    return 1;</strong>
<strong>  }</strong>
<strong>  return 0;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Generate the bitcode file using the following command:<div><pre class="programlisting">
<strong>$ clang -c eh.cpp -emit-llvm -o eh.bc</strong>
</pre></div></li><li class="listitem">To view the IR on the screen, run the following command, which will give you the output as shown:<div><pre class="programlisting">
<strong>$ llvm-dis eh.bc -o -</strong>
<strong>; ModuleID = 'eh.bc'</strong>
<strong>target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong>
<strong>target triple = "x86_64-unknown-linux-gnu"</strong>

<strong>%class.Ex1 = type { i8 }</strong>

<strong>@_ZTVN10__cxxabiv117__class_type_infoE = external global i8*</strong>
<strong>@_ZTS3Ex1 = linkonce_odr constant [5 x i8] c"3Ex1\00"</strong>
<strong>@_ZTI3Ex1 = linkonce_odr constant { i8*, i8* } { i8* bitcast (i8** getelementptr inbounds (i8** @_ZTVN10__cxxabiv117__class_type_infoE, i64 2) to i8*), i8* getelementptr inbounds ([5 x i8]* @_ZTS3Ex1, i32 0, i32 0) }</strong>

<strong>; Function Attrs: uwtable</strong>
<strong>define void @_Z15throw_exceptionii(i32 %a, i32 %b) #0 {</strong>
<strong>  %1 = alloca i32, align 4</strong>
<strong>  %2 = alloca i32, align 4</strong>
<strong>  %ex1 = alloca %class.Ex1, align 1</strong>
<strong>  store i32 %a, i32* %1, align 4</strong>
<strong>  store i32 %b, i32* %2, align 4</strong>
<strong>  %3 = load i32* %1, align 4</strong>
<strong>  %4 = load i32* %2, align 4</strong>
<strong>  %5 = icmp sgt i32 %3, %4</strong>
<strong>  br i1 %5, label %6, label %9</strong>

<strong>; &lt;label&gt;:6                                       ; preds = %0</strong>
<strong>  %7 = call i8* @__cxa_allocate_exception(i64 1) #1</strong>
<strong>  %8 = bitcast i8* %7 to %class.Ex1*</strong>
<strong>  call void @__cxa_throw(i8* %7, i8* bitcast ({ i8*, i8* }* @_ZTI3Ex1 to i8*), i8* null) #2</strong>
<strong>  unreachable</strong>

<strong>; &lt;label&gt;:9                                       ; preds = %0</strong>
<strong>  ret void</strong>
<strong>}</strong>

<strong>declare i8* @__cxa_allocate_exception(i64)</strong>

<strong>declare void @__cxa_throw(i8*, i8*, i8*)</strong>

<strong>; Function Attrs: uwtable</strong>
<strong>define i32 @_Z14test_try_catchv() #0 {</strong>
<strong>  %1 = alloca i32, align 4</strong>
<strong>  %2 = alloca i8*</strong>
<strong>  %3 = alloca i32</strong>
<strong>  %4 = alloca i32</strong>
<strong>  invoke void @_Z15throw_exceptionii(i32 2, i32 1)</strong>
<strong>          to label %5 unwind label %6</strong>

<strong>; &lt;label&gt;:5                                       ; preds = %0</strong>
<strong>  br label %13</strong>

<strong>; &lt;label&gt;:6                                       ; preds = %0</strong>
<strong>  %7 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*)</strong>
<strong>          catch i8* null</strong>
<strong>  %8 = extractvalue { i8*, i32 } %7, 0</strong>
<strong>  store i8* %8, i8** %2</strong>
<strong>  %9 = extractvalue { i8*, i32 } %7, 1</strong>
<strong>  store i32 %9, i32* %3</strong>
<strong>  br label %10</strong>

<strong>; &lt;label&gt;:10                                      ; preds = %6</strong>
<strong>  %11 = load i8** %2</strong>
<strong>  %12 = call i8* @__cxa_begin_catch(i8* %11) #1</strong>
<strong>  store i32 1, i32* %1</strong>
<strong>  store i32 1, i32* %4</strong>
<strong>  call void @__cxa_end_catch()</strong>
<strong>  br label %14</strong>

<strong>; &lt;label&gt;:13                                      ; preds = %5</strong>
<strong>  store i32 0, i32* %1</strong>
<strong>  br label %14</strong>

<strong>; &lt;label&gt;:14                                      ; preds = %13, %10</strong>
<strong>  %15 = load i32* %1</strong>
<strong>  ret i32 %15</strong>
<strong>}</strong>

<strong>declare i32 @__gxx_personality_v0(...)</strong>

<strong>declare i8* @__cxa_begin_catch(i8*)</strong>

<strong>declare void @__cxa_end_catch()</strong>

<strong>attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }</strong>
<strong>attributes #1 = { nounwind }</strong>
<strong>attributes #2 = { noreturn }</strong>

<strong>!llvm.ident = !{!0}</strong>

<strong>!0 = metadata !{metadata !"clang version 3.6.0 (220636)"}</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec269"/>How it works…</h2></div></div></div><p>In LLVM, if an <a id="id412" class="indexterm"/>exception is thrown, the runtime tries its best to find a handler. It <a id="id413" class="indexterm"/>tries to find an exception frame corresponding to the function where the exception was thrown. This exception frame contains a reference to the exception table, which contains the implementation—how to handle the exception when a programming language supports exception handling. When the language does not support exception handling, the information on how to unwind the current activation and restore the state of the prior activation is found in this exception frame.</p><p>Let's look at the preceding example to see how to generate exception handling code with LLVM.</p><p>The <code class="literal">try</code> block is translated to invoke instruction in LLVM:</p><div><pre class="programlisting">invoke void @_Z15throw_exceptionii(i32 2, i32 1)
          to label %5 unwind label %6</pre></div><p>The preceding line tells the compiler how it should handle an exception if the <code class="literal">throw_exception</code> function throws it. If no exception is thrown, then normal execution will take place through the <code class="literal">%5</code> label. But if an exception is thrown, it will branch into the <code class="literal">%6</code> label, which is the landing pad. This corresponds roughly to the <code class="literal">catch</code> portion of a <code class="literal">try</code>/<code class="literal">catch</code> sequence. When execution resumes at a landing pad, it receives an exception structure and a selector value corresponding to the type of exception thrown. The selector is then used to determine which <code class="literal">catch</code> function should actually process the exception. In this case, it looks something like this:</p><div><pre class="programlisting">%7 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*)
     catch i8* null</pre></div><p>The <code class="literal">%7</code> in the<a id="id414" class="indexterm"/> preceding code snippet represents the information describing<a id="id415" class="indexterm"/> the exception. The <code class="literal">{ i8*, i32 }</code> part of the code describes the type of information. The <code class="literal">i8*</code> part of the code represents the exception pointer part, and <code class="literal">i32</code> is the selector value. In this case, we have only one selector value, as the <code class="literal">catch</code> function accepts all types of exception objects thrown. The <code class="literal">@__gxx_personality_v0</code> function is the <code class="literal">personality</code> function. It receives the context of the exception, an exception structure containing the exception object type and value, and a reference to the exception table for the current function. The personality function for the current compile unit is specified in a common exception frame. In our case, the <code class="literal">@__gxx_personality_v0</code> function represents the fact that we are dealing with C++ exceptions.</p><p>So, the <code class="literal">%8 = extractvalue { i8*, i32 } %7, 0</code> will represent the exception object, and <code class="literal">%9 = extractvalue { i8*, i32 } %7, 1</code> represents the selector value.</p><p>The following are some noteworthy IR functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">__cxa_throw</code>: This is a <a id="id416" class="indexterm"/>function used to throw an exception</li><li class="listitem"><code class="literal">__cxa_begin_catch</code>: This<a id="id417" class="indexterm"/> takes an exception structure reference as an argument and returns the value of the exception object</li><li class="listitem"><code class="literal">__cxa_end_catch</code>: This<a id="id418" class="indexterm"/> locates the most recently caught exception and decrements its handler count, removing the exception from the caught state if this counter goes down to zero</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec270"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To understand the <a id="id419" class="indexterm"/>exception format used by LLVM, go to <a class="ulink" href="http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation">http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec94"/>Using sanitizers</h1></div></div></div><p>You might have used tools <a id="id420" class="indexterm"/>such as <a id="id421" class="indexterm"/>
<strong>Valgrind</strong> for memory debugging. LLVM also provides us with tools for memory debugging, such as the address sanitizer, memory sanitizer, and so on. These tools are very fast compared to Valgrind, even though they are not as mature as Valgrind. Most of these tools are in their experimental stage, so if you want, you can contribute to the open source development of these tools.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec271"/>Getting ready</h2></div></div></div><p>To make use of these sanitizers, we need to check out the code for <code class="literal">compiler-rt</code> from the LLVM SVN:</p><div><pre class="programlisting">cd llvm/projects
svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</pre></div><p>Build LLVM as we did in <a class="link" title="Chapter 1. LLVM Design and Use" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <em>LLVM Design and Use</em>. By doing so, we get the runtime libraries required.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec272"/>How to do it…</h2></div></div></div><p>Now, we will test the address sanitizer on a test code.</p><div><ol class="orderedlist arabic"><li class="listitem">Write a test case to check the address sanitizer:<div><pre class="programlisting">
<strong>$ cat asan.c</strong>
<strong>int main() {</strong>
<strong>int a[5];</strong>
<strong>int index = 6;</strong>
<strong>int retval = a[index];</strong>
<strong>return retval;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Compile the test code using the <code class="literal">fsanitize=address</code> <code class="literal">command-line argument</code> for using the address sanitizer:<div><pre class="programlisting">
<strong>$ clang -fsanitize=address asan.c</strong>
</pre></div></li><li class="listitem">Generate the output of running the address sanitizer using the following command:<div><pre class="programlisting">
<strong>$ ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out</strong>
</pre></div><p>Here's the output:</p><div><img src="img/image00268.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec273"/>How it works…</h2></div></div></div><p>The LLVM address <a id="id422" class="indexterm"/>sanitizer works on the principle of code instrumentation. The tool consists of a compiler instrumentation module and a runtime library. The code instrumentation part is done by the pass of LLVM, which runs on passing the <code class="literal">fsanitize=address</code> command-line argument, as is done in the preceding example. The runtime library replaces the <code class="literal">malloc</code> and <code class="literal">free</code> functions in the code with custom-made code. Before we go ahead and discuss the details of how code instrumentation is done, here we must know that the virtual address space is divided into two disjointed classes: the main application memory, which is used by the regular application code; and the shadow memory, which contains the shadow values (or metadata).</p><p>The shadow memory and the main application memory are linked to each other. Poisoning a byte in the main memory means writing a special value into the corresponding shadow memory.</p><p>Let's come back to the<a id="id423" class="indexterm"/> address sanitizer; the memory around the regions allocated by the <code class="literal">malloc</code> function is poisoned. The memory freed by the <code class="literal">free</code> function is placed in quarantine and is also poisoned. Every memory access in the program is transformed by the compiler in the following way.</p><p>At first, it is like this:</p><div><pre class="programlisting">*address = ...;</pre></div><p>After transformation, it becomes the following:</p><div><pre class="programlisting">if (IsPoisoned(address)) {
  ReportError(address, kAccessSize, kIsWrite);
}
*address = ...;</pre></div><p>This means that if it finds any invalid access to this memory, it reports an error.</p><p>In the preceding example, we wrote a piece of code for a buffer overrun, accessing an array that is out of bounds. Here, the instrumentation of code is done on the address just before and after the array. So, when we access the array beyond its upper bound, we try accessing the red zone. Hence, the address sanitizer gives us a stack buffer overflow report.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec274"/>See also…</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">You can check out the <a id="id424" class="indexterm"/>documentation page at <a class="ulink" href="http://clang.llvm.org/docs/AddressSanitizer.html">http://clang.llvm.org/docs/AddressSanitizer.html</a> for more information.</li><li class="listitem">You can also check out the other sanitizers in LLVM using the following links:<p>
<a class="ulink" href="http://clang.llvm.org/docs/MemorySanitizer.html">http://clang.llvm.org/docs/MemorySanitizer.html</a>
</p><p>
<a class="ulink" href="http://clang.llvm.org/docs/ThreadSanitizer.html">http://clang.llvm.org/docs/ThreadSanitizer.html</a>
</p><p>
<a class="ulink" href="https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer">https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer</a>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec95"/>Writing the garbage collector with LLVM</h1></div></div></div><p>Garbage collection <a id="id425" class="indexterm"/>is a technique of memory management<a id="id426" class="indexterm"/> where the collector tries to reclaim the memory occupied by objects that are no longer in use. This frees the programmer from of being required to keep track of the lifetimes of heap objects.</p><p>In this recipe, we will see how to integrate LLVM into a compiler for a language that supports garbage collection. LLVM does not itself provide a garbage collector, but provides a framework for describing the garbage collector's requirements to the compiler.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec275"/>Getting ready</h2></div></div></div><p>LLVM must be built and installed.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec276"/>How to do it…</h2></div></div></div><p>We will see in the following recipe how the LLVM IR code, with garbage collection intrinsic functions, is converted to the corresponding machine assembly code:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the test code:<div><pre class="programlisting">
<strong>$ cat testgc.ll</strong>

<strong>declare i8* @llvm_gc_allocate(i32)</strong>
<strong>declare void @llvm_gc_initialize(i32)</strong>

<strong>declare void @llvm.gcroot(i8**, i8*)</strong>
<strong>declare void @llvm.gcwrite(i8*, i8*, i8**)</strong>

<strong>define i32 @main() gc "shadow-stack" {</strong>
<strong>entry:</strong>
<strong>  %A = alloca i8*</strong>
<strong>  %B = alloca i8**</strong>

<strong>  call void @llvm_gc_initialize(i32 1048576)  ; Start with 1MB heap</strong>

<strong>        ;; void *A;</strong>
<strong>  call void @llvm.gcroot(i8** %A, i8* null)</strong>

<strong>        ;; A = gcalloc(10);</strong>
<strong>  %Aptr = call i8* @llvm_gc_allocate(i32 10)</strong>
<strong>  store i8* %Aptr, i8** %A</strong>

<strong>        ;; void **B;</strong>
<strong>  %tmp.1 = bitcast i8*** %B to i8**</strong>
<strong>  call void @llvm.gcroot(i8** %tmp.1, i8* null)</strong>

<strong>  ;; B = gcalloc(4);</strong>
<strong>  %B.upgrd.1 = call i8* @llvm_gc_allocate(i32 8)</strong>
<strong>  %tmp.2 = bitcast i8* %B.upgrd.1 to i8**</strong>
<strong>  store i8** %tmp.2, i8*** %B</strong>

<strong>  ;; *B = A;</strong>
<strong>  %B.1 = load i8**, i8*** %B</strong>
<strong>  %A.1 = load i8*, i8** %A</strong>
<strong>  call void @llvm.gcwrite(i8* %A.1, i8* %B.upgrd.1, i8** %B.1)</strong>

<strong>  br label %AllocLoop</strong>

<strong>AllocLoop:</strong>
<strong>  %i = phi i32 [ 0, %entry ], [ %indvar.next, %AllocLoop ]</strong>
<strong>        ;; Allocated mem: allocated memory is immediately dead.</strong>
<strong>  call i8* @llvm_gc_allocate(i32 100)</strong>

<strong>  %indvar.next = add i32 %i, 1</strong>
<strong>  %exitcond = icmp eq i32 %indvar.next, 10000000</strong>
<strong>  br i1 %exitcond, label %Exit, label %AllocLoop</strong>

<strong>Exit:</strong>
<strong>  ret i32 0</strong>
<strong>}</strong>

<strong>declare void @__main()</strong>
</pre></div></li><li class="listitem">Use the <code class="literal">llc</code> tool to generate<a id="id427" class="indexterm"/> the assembly code and view the<a id="id428" class="indexterm"/> assembly code using the <code class="literal">cat</code> command:<div><pre class="programlisting">
<strong>$ llc testgc.ll</strong>

<strong>$ cat testgc.s</strong>
<strong>  .text</strong>
<strong>  .file  "testgc.ll"</strong>
<strong>  .globl  main</strong>
<strong>  .align  16, 0x90</strong>
<strong>  .type  main,@function</strong>
<strong>main:                                   # @main</strong>
<strong>.Lfunc_begin0:</strong>
<strong>  .cfi_startproc</strong>
<strong>  .cfi_personality 3, __gcc_personality_v0</strong>
<strong>  .cfi_lsda 3, .Lexception0</strong>
<strong># BB#0:                                 # %entry</strong>
<strong>  pushq  %rbx</strong>
<strong>.Ltmp9:</strong>
<strong>  .cfi_def_cfa_offset 16</strong>
<strong>  subq  $32, %rsp</strong>
<strong>.Ltmp10:</strong>
<strong>  .cfi_def_cfa_offset 48</strong>
<strong>.Ltmp11:</strong>
<strong>  .cfi_offset %rbx, -16</strong>
<strong>  movq  llvm_gc_root_chain(%rip), %rax</strong>
<strong>  movq  $__gc_main, 8(%rsp)</strong>
<strong>  movq  $0, 16(%rsp)</strong>
<strong>  movq  %rax, (%rsp)</strong>
<strong>  leaq  (%rsp), %rax</strong>
<strong>  movq  %rax, llvm_gc_root_chain(%rip)</strong>
<strong>  movq  $0, 24(%rsp)</strong>
<strong>.Ltmp0:</strong>
<strong>  movl  $1048576, %edi          # imm = 0x100000</strong>
<strong>  callq  llvm_gc_initialize</strong>
<strong>.Ltmp1:</strong>
<strong># BB#1:                                 # %entry.cont3</strong>
<strong>.Ltmp2:</strong>
<strong>  movl  $10, %edi</strong>
<strong>  callq  llvm_gc_allocate</strong>
<strong>.Ltmp3:</strong>
<strong># BB#2:                                 # %entry.cont2</strong>
<strong>  movq  %rax, 16(%rsp)</strong>
<strong>.Ltmp4:</strong>
<strong>  movl  $8, %edi</strong>
<strong>  callq  llvm_gc_allocate</strong>
<strong>.Ltmp5:</strong>
<strong># BB#3:                                 # %entry.cont</strong>
<strong>  movq  %rax, 24(%rsp)</strong>
<strong>  movq  16(%rsp), %rcx</strong>
<strong>  movq  %rcx, (%rax)</strong>
<strong>  movl  $10000000, %ebx         # imm = 0x989680</strong>
<strong>  .align  16, 0x90</strong>
<strong>.LBB0_4:                                # %AllocLoop</strong>
<strong>                                        # =&gt;This Inner Loop Header: Depth=1</strong>
<strong>.Ltmp6:</strong>
<strong>  movl  $100, %edi</strong>
<strong>  callq  llvm_gc_allocate</strong>
<strong>.Ltmp7:</strong>
<strong># BB#5:                                 # %AllocLoop.cont</strong>
<strong>                                        #   in Loop: Header=BB0_4 Depth=1</strong>
<strong>  decl  %ebx</strong>
<strong>  jne  .LBB0_4</strong>
<strong># BB#6:                                 # %Exit</strong>
<strong>  movq  (%rsp), %rax</strong>
<strong>  movq  %rax, llvm_gc_root_chain(%rip)</strong>
<strong>  xorl  %eax, %eax</strong>
<strong>  addq  $32, %rsp</strong>
<strong>  popq  %rbx</strong>
<strong>  retq</strong>
<strong>.LBB0_7:                                # %gc_cleanup</strong>
<strong>.Ltmp8:</strong>
<strong>  movq  (%rsp), %rcx</strong>
<strong>  movq  %rcx, llvm_gc_root_chain(%rip)</strong>
<strong>  movq  %rax, %rdi</strong>
<strong>  callq  _Unwind_Resume</strong>
<strong>.Lfunc_end0:</strong>
<strong>  .size  main, .Lfunc_end0-main</strong>
<strong>  .cfi_endproc</strong>
<strong>  .section  .gcc_except_table,"a",@progbits</strong>
<strong>  .align  4</strong>
<strong>GCC_except_table0:</strong>
<strong>.Lexception0:</strong>
<strong>  .byte  255                     # @LPStart Encoding = omit</strong>
<strong>  .byte  3                       # @TType Encoding = udata4</strong>
<strong>  .asciz  "\234"                  # @TType base offset</strong>
<strong>  .byte  3                       # Call site Encoding = udata4</strong>
<strong>  .byte  26                      # Call site table length</strong>
<strong>  .long  .Ltmp0-.Lfunc_begin0    # &gt;&gt; Call Site 1 &lt;&lt;</strong>
<strong>  .long  .Ltmp7-.Ltmp0           #   Call between .Ltmp0 and .Ltmp7</strong>
<strong>  .long  .Ltmp8-.Lfunc_begin0    #     jumps to .Ltmp8</strong>
<strong>  .byte  0                       #   On action: cleanup</strong>
<strong>  .long  .Ltmp7-.Lfunc_begin0    # &gt;&gt; Call Site 2 &lt;&lt;</strong>
<strong>  .long  .Lfunc_end0-.Ltmp7      #   Call between .Ltmp7 and .Lfunc_end0</strong>
<strong>  .long  0                       #     has no landing pad</strong>
<strong>  .byte  0                       #   On action: cleanup</strong>
<strong>  .align  4</strong>

<strong>  .type  llvm_gc_root_chain,@object # @llvm_gc_root_chain</strong>
<strong>  .bss</strong>
<strong>  .weak  llvm_gc_root_chain</strong>
<strong>  .align  8</strong>
<strong>llvm_gc_root_chain:</strong>
<strong>  .quad  0</strong>
<strong>  .size  llvm_gc_root_chain, 8</strong>

<strong>  .type  __gc_main,@object       # @__gc_main</strong>
<strong>  .section  .rodata,"a",@progbits</strong>
<strong>  .align  8</strong>
<strong>__gc_main:</strong>
<strong>  .long  2                       # 0x2</strong>
<strong>  .long  0                       # 0x0</strong>
<strong>  .size  __gc_main, 8</strong>

<strong>  .section  ".note.GNU-stack","",@progbits</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec277"/>How it works…</h2></div></div></div><p>In the preceding code, in the <a id="id429" class="indexterm"/>main function, we are using the built-in<a id="id430" class="indexterm"/> GC collector strategy called <code class="literal">shadow-stack</code>, which maintains a linked list of stack <code class="literal">roots()</code>:</p><div><pre class="programlisting">define i32 @main() gc "shadow-stack"</pre></div><p>It mirrors the machine stack. We can provide any other technique, if we want to, by specifying its name after the function name in this format, <code class="literal">gc "strategy name"</code>. This strategy name can either be the built-in strategy or our own custom strategy for garbage collection.</p><p>To identify the roots, that is, the references to the heap object, LLVM makes use of the intrinsic function <code class="literal">@llvm.gcroot</code> or <code class="literal">the .statepoint</code> relocation sequence. The <code class="literal">llvm.gcroot</code> intrinsic function informs LLVM that a stack variable references an object on the heap and it needs to be tracked by the collector. In the preceding code, the following line is the call to the <code class="literal">llvm.gcroot</code> function to mark the <code class="literal">%tmp.1</code> stack variable:</p><div><pre class="programlisting">call void @llvm.gcroot(i8** %tmp.1, i8* null)</pre></div><p>The <code class="literal">llvm.gcwrite</code> function is a write barrier. This means that whenever a program on which garbage collection is being done, it writes a pointer to a field of a heap object, the collector is informed about that. The <code class="literal">llvm.gcread</code> intrinsic function is also present, which informs the garbage collector when the program reads a pointer to a field of a heap object. The following line of code writes the <code class="literal">%A.1</code> value to the <code class="literal">%B.upgrd</code> heap object:</p><div><pre class="programlisting">call void @llvm.gcwrite(i8* %A.1, i8* %B.upgrd.1, i8** %B.1)</pre></div><div><h3 class="title"><a id="note09"/>Note</h3><p>Note that LLVM does not provide a garbage collector. It should be a part of the runtime library of the language. The preceding explanation deals with the infrastructure that LLVM provides for describing garbage collector requirements to the compiler.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec278"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">See <a class="ulink" href="http://llvm.org/docs/GarbageCollection.html">http://llvm.org/docs/GarbageCollection.html</a> for the documentation<a id="id431" class="indexterm"/> on garbage collection.</li><li class="listitem">Also, check out <a class="ulink" href="http://llvm.org/docs/Statepoints.html">http://llvm.org/docs/Statepoints.html</a> for an alternative method of garbage collection.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec96"/>Converting LLVM IR to JavaScript</h1></div></div></div><p>In this recipe, we will <a id="id432" class="indexterm"/>briefly discuss how we can convert LLVM IR<a id="id433" class="indexterm"/> to JavaScript.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec279"/>Getting ready</h2></div></div></div><p>To convert IR to JavaScript, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We will make use of the<a id="id434" class="indexterm"/> <code class="literal">emscripten</code> LLVM to JavaScript compiler. You need to download the SDK provided at <a class="ulink" href="https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html">https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html</a> . You can also build it from the source code, but just for experimenting, you can use the SDK that comes with the toolchain.</li><li class="listitem">After downloading the SDK, extract it to a location and go to the root folder of the download.</li><li class="listitem">Install the <code class="literal">default-jre</code>, <code class="literal">nodejs</code>, <code class="literal">cmake</code>, <code class="literal">build-essential</code>, and <code class="literal">git</code> dependencies.</li><li class="listitem">Execute the following commands to install the SDK:<div><pre class="programlisting">
<strong>./emsdk update</strong>
<strong>./emsdk install latest</strong>
<strong>./emsdk activate latest</strong>
</pre></div></li><li class="listitem">See the <code class="literal">~/emscripten</code> script to check whether it has the correct values, and if not, update it accordingly.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec280"/>How to do it…</h2></div></div></div><p>Perform the following<a id="id435" class="indexterm"/> steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the test code <a id="id436" class="indexterm"/>for the conversion:<div><pre class="programlisting">
<strong>$ cat test.c</strong>
<strong>#include&lt;stdio.h&gt;</strong>

<strong>int main() {</strong>
<strong>  printf("hi, user!\n");</strong>
<strong>  return 0;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Convert the code to the LLVM IR:<div><pre class="programlisting">
<strong>$ clang –S –emit-llvm test.c</strong>
</pre></div></li><li class="listitem">Now use the <code class="literal">emcc</code> executable located in the <code class="literal">emsdk_portable/emscripten/master</code> directory to take this <code class="literal">.ll</code> file as the input and convert it into JavaScript:<div><pre class="programlisting">
<strong>$ ./emcc test.ll</strong>
</pre></div></li><li class="listitem">The output file generated is the <code class="literal">a.out.js</code> file. We can execute this file using the following command:<div><pre class="programlisting">
<strong>$ nodejs a.out.js</strong>
<strong>hi, user!</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec281"/>See more</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To know more<a id="id437" class="indexterm"/> details, visit <a class="ulink" href="https://github.com/kripken/emscripten">https://github.com/kripken/emscripten</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec97"/>Using the Clang Static Analyzer</h1></div></div></div><p>In this recipe, you will learn<a id="id438" class="indexterm"/> about the static analysis of code, which is carried out by the <strong>Clang Static Analyzer</strong>. It is built on top of Clang and LLVM. The static analysis engine used by the Clang Static Analyzer is a Clang library, and it has the capability to be reused in different contexts by different clients.</p><p>We will take the example of the divide-by-zero defect and show you how the Clang Static Analyzer handles this defect.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec282"/>Getting ready</h2></div></div></div><p>You need to build and install LLVM along with Clang.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec283"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a test file and write the test code in it:<div><pre class="programlisting">
<strong>$ cat sa.c</strong>
<strong>int func() {</strong>
<strong>int a = 0;</strong>
<strong>int b = 1/a;</strong>
<strong>return b;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Run the Clang Static Analyzer by passing the command-line options shown in the following command, and get the output on the screen:<div><pre class="programlisting">
<strong>$ clang -cc1 -analyze -analyzer-checker=core.DivideZero sa.c</strong>
<strong>sa.c:3:10: warning: Division by zero</strong>
<strong>int b = 1/a;</strong>
<strong>        ~^~</strong>
<strong>1 warning generated.</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec284"/>How it works…</h2></div></div></div><p>The static analyzer core <a id="id439" class="indexterm"/>performs the symbolic execution of the program. The input values are represented by symbolic values. The values of the expressions are calculated by the analyzer using the input symbol and the path. The execution of the code is path-sensitive, and hence every possible path is analyzed.</p><p>While executing, the execution traces are represented by an exploded graph. Each node of this <code class="literal">ExplodedGraph</code> is called <code class="literal">ExplodedNode</code>. It consists of a <code class="literal">ProgramState</code> object, which represents the abstract state of the program; and a <code class="literal">ProgramPoint</code> object, which represents the corresponding location in the program.</p><p>For each type of bug, there is an associated checker. Each of these checkers is linked to the core in a way by which they contribute to the <code class="literal">ProgramState</code> construction. Each time the analyzer engine explores a new statement, it notifies each checker registered to listen for that statement, giving it an opportunity to either report a bug or modify the state.</p><p>Each checker registers for some events and callbacks such as <code class="literal">PreCall</code> (prior to the call of the function), <code class="literal">DeadSymbols</code> (when a symbol goes dead), and so on. They are notified in the case of the requested events, and they implement the action to be taken for such events.</p><p>In this recipe, we looked at a divide-by-zero checker, which reports when a divide-by-zero condition occurs. The checker, in this case, registers for the <code class="literal">PreStmt</code> callback, before a statement gets executed. It then checks the operator of the next statement to be executed, and if it finds a <a id="id440" class="indexterm"/>division operator, it looks for a zero value. If it finds such a possible value, it reports a bug.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec285"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For more detailed information about the <a id="id441" class="indexterm"/>static analyzer and checkers, visit <a class="ulink" href="http://clang-analyzer.llvm.org/checker_dev_manual.html">http://clang-analyzer.llvm.org/checker_dev_manual.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec98"/>Using bugpoint</h1></div></div></div><p>In this recipe, you will learn about a <a id="id442" class="indexterm"/>useful tool provided by LLVM infrastructure, known as bugpoint. Bugpoint allows us to narrow down the source of problems in the LLVM's tools and passes. It is helpful in debugging optimizer crashes, miscompilations by optimizers, or bad native code generation. Using this, we can get a small test case for our problem and work on that.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec286"/>Getting ready</h2></div></div></div><p>You need to build and install LLVM.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec287"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the test cases using the bugpoint tool:<div><pre class="programlisting">
<strong>$ cat crash-narrowfunctiontest.ll</strong>
<strong>define i32 @foo() { ret i32 1 }</strong>

<strong>define i32 @test() {</strong>
<strong>  call i32 @test()</strong>
<strong>  ret i32 %1</strong>
<strong>}</strong>
<strong>define i32 @bar() { ret i32 2 }</strong>
</pre></div></li><li class="listitem">Use bugpoint in this test case to view the results :<div><pre class="programlisting">
<strong>$ bugpoint -load  path-to-llvm/build/./lib/BugpointPasses.so crash-narrowfunctiontest.ll -output-prefix crash-narrowfunctiontest.ll.tmp -bugpoint-cras</strong>
<strong>hcalls -silence-passes</strong>
<strong>Read input file      : 'crash-narrowfunctiontest.ll'</strong>
<strong>*** All input ok</strong>
<strong>Running selected passes on program to test for crash: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>

<strong>*** Debugging optimizer crash!</strong>
<strong>Checking to see if these passes crash: -bugpoint-crashcalls: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>

<strong>*** Found crashing pass: -bugpoint-crashcalls</strong>
<strong>Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-passes.bc'</strong>

<strong>*** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-passes.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls</strong>

<strong>*** Attempting to reduce the number of functions in the testcase</strong>
<strong>Checking for crash with only these functions:  foo test bar: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>
<strong>Checking for crash with only these functions:  foo test: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>
<strong>Checking for crash with only these functions:  test: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>
<strong>Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-function.bc'</strong>

<strong>*** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-function.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls</strong>
<strong>Checking for crash with only these blocks: : Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>
<strong>Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-blocks.bc'</strong>

<strong>*** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-blocks.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls</strong>
<strong>Checking for crash with only 1 instruction: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>

<strong>*** Attempting to reduce testcase by deleting instructions: Simplification Level #1</strong>
<strong>Checking instruction:   %1 = call i32 @test()Success!</strong>

<strong>*** Attempting to reduce testcase by deleting instructions: Simplification Level #0</strong>
<strong>Checking instruction:   %1 = call i32 @test()Success!</strong>

<strong>*** Attempting to perform final cleanups: Crashed: Aborted (core dumped)</strong>
<strong>Dumped core</strong>
<strong>Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc'</strong>

<strong>*** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls</strong>
</pre></div></li><li class="listitem">Now, to see the reduced<a id="id443" class="indexterm"/> test case, use the <code class="literal">llvm-dis</code> command to convert the <code class="literal">crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc</code> file to the <code class="literal">.ll</code> form. Then, view the reduced test case:<div><pre class="programlisting">
<strong>$ llvm-dis crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc</strong>
<strong>$ cat $ cat crash-narrowfunctiontest.ll.tmp-reduced-simplified.ll</strong>
<strong>define void @test() {</strong>
<strong>  call void @test()</strong>
<strong>  ret void</strong>
<strong>}</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec288"/>How it works…</h2></div></div></div><p>The bugpoint tool runs all the<a id="id444" class="indexterm"/> passes specified in the command line on the test program. If any of these passes crash, bugpoint starts the crash debugger. The crash debugger tries to reduce the list of passes that cause this crash. Then it tries to removes unnecessary functions. Once able to reduce the test program to a single function, it tries to deletes the edges of the control flow graph to reduce the size of the function. After this, it proceeds to remove the individual LLVM instructions whose absence does not impact the failure. In the end, bugpoint gives the output showing which pass is causing the crash and a simplified reduced test case.</p><p>If the <code class="literal">–output</code> option wasn't specified, then bugpoint runs the program on a <code class="literal">"safe"</code> backend and generated reference output. It then compares the output generated by the selected code generator. If there is a crash, it runs the crash debugger as explained in the previous paragraph. Other than this, if the output generated by the code generator differs from the reference output, it starts the code generator debugger, which reduces the test case through techniques similar to those of the crash debugger.</p><p>Finally, if the output generated by the code generator and the reference output are the same, then bugpoint runs all the LLVM passes and checks the output against the reference output. If there is any mismatch, then it runs the miscompilation debugger. The miscompilation debugger works by splitting the test program into two pieces. It runs the optimizations as specified on one piece, then links the two pieces back together, and finally executes the result. It tries to narrow down to the pass that is causing miscompilation from the list of passes, and then pinpoints the portion of the test program that is being miscompiled. It outputs the reduced case that is causing the miscompilation.</p><p>In the preceding test case, bugpoint checks for the crash in all functions, and ends up knowing that the problem lies in the test function. It also tries to reduce the instructions within the function. The output for every stage is displayed on the terminal, which is self-explanatory. In the end, it produces a simplified reduced test case in the bitcode format, which we can convert to the LLVM IR and get the reduced test case.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec289"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To read more on <a id="id445" class="indexterm"/>bugpoint, go to <a class="ulink" href="http://llvm.org/docs/Bugpoint.html">http://llvm.org/docs/Bugpoint.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec99"/>Using LLDB</h1></div></div></div><p>In this recipe, you will learn how<a id="id446" class="indexterm"/> to use the debugger known as <code class="literal">LLDB</code>, provided by LLVM. LLDB is a next-generation, high-performance debugger. It is essentially built as a set of reusable components that have advantages over the existing libraries in the larger LLVM project. You might find it quite similar to the <code class="literal">gdb</code> debugging tool.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec290"/>Getting ready</h2></div></div></div><p>We will need the following before working with LLDB:</p><div><ol class="orderedlist arabic"><li class="listitem">To use LLDB, we need to check out the LLDB source code in the <code class="literal">llvm/tools</code> folder:<div><pre class="programlisting">
<strong>svn co http://llvm.org/svn/llvm-project/lldb/trunk lldb</strong>
</pre></div></li><li class="listitem">Build and install LLVM, which will also build LLDB simultaneously.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec291"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Write a test case for a simple example using LLDB:<div><pre class="programlisting">
<strong>$ cat lldbexample.c</strong>
<strong>#include&lt;stdio.h&gt;</strong>
<strong>int globalvar = 0;</strong>

<strong>int func2(int a, int b) {</strong>
<strong>globalvar++;</strong>
<strong>return a*b;</strong>
<strong>}</strong>

<strong>int func1(int a, int b) {</strong>
<strong>globalvar++;</strong>
<strong>int d = a + b;</strong>
<strong>int e = a - b;</strong>
<strong>int f = func2(d, e);</strong>
<strong>return f;</strong>
<strong>}</strong>

<strong>int main() {</strong>
<strong>globalvar++;</strong>
<strong>int a = 5;</strong>
<strong>int b = 3;</strong>

<strong>int c = func1(a,b);</strong>
<strong>printf("%d", c);</strong>
<strong>return c;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Compile the code using Clang with the <code class="literal">–g</code> flag to generate the debug information:<div><pre class="programlisting">
<strong>$ clang -g lldbexample.c</strong>
</pre></div></li><li class="listitem">Debug the output file generated in the previous file with LLDB. To load the output file, we need to pass its name to LLDB:<div><pre class="programlisting">
<strong>$ lldb a.out</strong>
<strong>(lldb) target create "a.out"</strong>
<strong>Current executable set to 'a.out' (x86_64).</strong>
</pre></div></li><li class="listitem">Set a breakpoint in the main function:<div><pre class="programlisting">
<strong>(lldb) breakpoint set --name main</strong>
<strong>Breakpoint 1: where = a.out'main + 15 at lldbexample.c:20, address = 0x00000000004005bf</strong>
</pre></div></li><li class="listitem">To look at the list of breakpoints set, use the following command:<div><pre class="programlisting">
<strong>(lldb) breakpoint list</strong>
<strong>Current breakpoints:</strong>
<strong>1: name = 'main', locations = 1</strong>
<strong>  1.1: where = a.out'main + 15 at lldbexample.c:20, address = a.out[0x00000000004005bf], unresolved, hit count = 0</strong>
</pre></div></li><li class="listitem">Add a command to be <a id="id447" class="indexterm"/>executed when a breakpoint is hit. Here, let's add the back trace <code class="literal">bt</code> command when the breakpoint on the main function is hit:<div><pre class="programlisting">
<strong>(lldb) breakpoint command add 1.1</strong>
<strong>Enter your debugger command(s).  Type 'DONE' to end.</strong>
<strong>&gt; bt </strong>
<strong>&gt; DONE</strong>
</pre></div></li><li class="listitem">Run the executable using the following command. This will hit the breakpoint on the <code class="literal">main</code> function and <a id="id448" class="indexterm"/>execute the back trace(<code class="literal">bt</code>) command, as set in the earlier step:<div><pre class="programlisting">
<strong>(lldb) process launch</strong>
<strong>Process 2999 launched: '/home/mayur/book/chap9/a.out' (x86_64)</strong>
<strong>Process 2999 stopped</strong>
<strong>* thread #1: tid = 2999, 0x00000000004005bf a.out'main + 15 at lldbexample.c:20, name = 'a.out', stop reason = breakpoint 1.1</strong>
<strong>    frame #0: 0x00000000004005bf a.out'main + 15 at lldbexample.c:20</strong>
<strong>   17</strong>
<strong>   18</strong>
<strong>   19    int main() {</strong>
<strong>-&gt; 20    globalvar++;</strong>
<strong>   21    int a = 5;</strong>
<strong>   22    int b = 3;</strong>
<strong>   23</strong>
<strong>(lldb)  bt</strong>
<strong>* thread #1: tid = 2999, 0x00000000004005bf a.out'main + 15 at lldbexample.c:20, name = 'a.out', stop reason = breakpoint 1.1</strong>
<strong>  * frame #0: 0x00000000004005bf a.out'main + 15 at lldbexample.c:20</strong>
<strong>    frame #1: 0x00007ffff7a35ec5 libc.so.6'__libc_start_main(main=0x00000000004005b0, argc=1, argv=0x00007fffffffda18, init=&lt;unavailable&gt;, fini=&lt;unavailable&gt;, rtld_fini=&lt;unavailable&gt;, stack_end=0x00007fffffffda08) + 245 at libc-start.c:287</strong>
<strong>    frame #2: 0x0000000000400469 a.out</strong>
</pre></div></li><li class="listitem">To set <code class="literal">watchpoint</code> on the global variable, use the following command:<div><pre class="programlisting">
<strong>(lldb) watch set var globalvar</strong>
<strong>Watchpoint created: Watchpoint 1: addr = 0x00601044 size = 4 state = enabled type = w</strong>
<strong>    declare @ '/home/mayur/book/chap9/lldbexample.c:2'</strong>
<strong>    watchpoint spec = 'globalvar'</strong>
<strong>    new value: 0</strong>
</pre></div></li><li class="listitem">To stop the execution when the value of <code class="literal">globalvar</code> becomes <code class="literal">3</code>, use the <code class="literal">watch</code> command:<div><pre class="programlisting">
<strong>(lldb) watch modify -c '(globalvar==3)'</strong>
<strong>To view list of all watch points:</strong>
<strong>(lldb) watch list</strong>
<strong>Number of supported hardware watchpoints: 4</strong>
<strong>Current watchpoints:</strong>
<strong>Watchpoint 1: addr = 0x00601044 size = 4 state = enabled type = w</strong>
<strong>    declare @ '/home/mayur/book/chap9/lldbexample.c:2'</strong>
<strong>    watchpoint spec = 'globalvar'</strong>
<strong>    new value: 0</strong>
<strong>    condition = '(globalvar==3)'</strong>
</pre></div></li><li class="listitem">To continue execution after<a id="id449" class="indexterm"/> the main function, use the following command. The executable will stop when the value of <code class="literal">globalvar</code> becomes <code class="literal">3</code>, inside the <code class="literal">func2</code> function:<div><pre class="programlisting">
<strong>(lldb) thread step-over</strong>
<strong>(lldb) Process 2999 stopped</strong>
<strong>* thread #1: tid = 2999, 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6, name = 'a.out', stop reason = watchpoint 1</strong>
<strong>    frame #0: 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6</strong>
<strong>   3</strong>
<strong>   4     int func2(int a, int b) {</strong>
<strong>   5     globalvar++;</strong>
<strong>-&gt; 6     return a*b;</strong>
<strong>   7     }</strong>
<strong>   8</strong>
<strong>   9</strong>

<strong>Watchpoint 1 hit:</strong>
<strong>old value: 0</strong>
<strong>new value: 3</strong>
<strong>(lldb) bt</strong>
<strong>* thread #1: tid = 2999, 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6, name = 'a.out', stop reason = watchpoint 1</strong>
<strong>  * frame #0: 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6</strong>
<strong>    frame #1: 0x000000000040059c a.out'func1(a=5, b=3) + 60 at lldbexample.c:14</strong>
<strong>    frame #2: 0x00000000004005e9 a.out'main + 57 at lldbexample.c:24</strong>
<strong>    frame #3: 0x00007ffff7a35ec5 libc.so.6'__libc_start_main(main=0x00000000004005b0, argc=1, argv=0x00007fffffffda18, init=&lt;unavailable&gt;, fini=&lt;unavailable&gt;, rtld_fini=&lt;unavailable&gt;, stack_end=0x00007fffffffda08) + 245 at libc-start.c:287</strong>
<strong>    frame #4: 0x0000000000400469 a.out</strong>
</pre></div></li><li class="listitem">To continue the execution of the executable use the <code class="literal">thread continue</code> command, which will execute till the end as no other breakpoints are met:<div><pre class="programlisting">
<strong>(lldb) thread continue</strong>
<strong>Resuming thread 0x0bb7 in process 2999</strong>
<strong>Process 2999 resuming</strong>
<strong>Process 2999 exited with status = 16 (0x00000010)</strong>
</pre></div></li><li class="listitem">To exit LLDB, use the<a id="id450" class="indexterm"/> following command:<div><pre class="programlisting">
<strong>(lldb)  exit</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec292"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Check out <a class="ulink" href="http://lldb.llvm.org/tutorial.html">http://lldb.llvm.org/tutorial.html</a> for an exhaustive list of <a id="id451" class="indexterm"/>LLDB commands.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec100"/>Using LLVM utility passes</h1></div></div></div><p>In this recipe, you will learn about<a id="id452" class="indexterm"/> LLVM's utility passes. As the name signifies, they are of much utility to users who want to understand certain things about LLVM that are not easy to understand by going through code. We will look into two utility passes that represent the CFG of a program.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec293"/>Getting ready</h2></div></div></div><p>You need to <a id="id453" class="indexterm"/>build and install LLVM, and install the <code class="literal">graphviz</code> tool. You can download <code class="literal">graphviz</code> from <a class="ulink" href="http://www.graphviz.org/Download.php">http://www.graphviz.org/Download.php</a>, or install it from your machine's package manager, if it is in the list of available packages.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec294"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the test code required<a id="id454" class="indexterm"/> for running the utility passes. This test code consists of <code class="literal">if</code> blocks, it will create a new edge in the CFG:<div><pre class="programlisting">
<strong>$ cat utility.ll</strong>
<strong>declare double @foo()</strong>

<strong>declare double @bar()</strong>

<strong>define double @baz(double %x) {</strong>
<strong>entry:</strong>
<strong>  %ifcond = fcmp one double %x, 0.000000e+00</strong>
<strong>  br i1 %ifcond, label %then, label %else</strong>

<strong>then:       ; preds = %entry</strong>
<strong>  %calltmp = call double @foo()</strong>
<strong>  br label %ifcont</strong>

<strong>else:       ; preds = %entry</strong>
<strong>  %calltmp1 = call double @bar()</strong>
<strong>  br label %ifcont</strong>

<strong>ifcont:     ; preds = %else, %then</strong>
<strong>  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]</strong>
<strong>  ret double %iftmp</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Run the <code class="literal">view-cfg-only</code> pass to view the CFG of a function without the function body:<div><pre class="programlisting">
<strong>$ opt –view-cfg-only utility.ll</strong>
</pre></div></li><li class="listitem">Now, view the <code class="literal">dot</code> file formed using the <code class="literal">graphviz</code> tool:<div><img src="img/image00269.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Run the <code class="literal">view-dom</code> pass to <a id="id455" class="indexterm"/>view the <strong>Dominator tree</strong> of a function:<div><pre class="programlisting">
<strong>$ opt –view-dom utility.ll</strong>
</pre></div></li><li class="listitem">View the <code class="literal">dot</code> file formed using the <code class="literal">graphviz</code> tool:<div><img src="img/image00270.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec295"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">A list of the other <a id="id456" class="indexterm"/>utility passes is available at <a class="ulink" href="http://llvm.org/docs/Passes.html#utility-passes">http://llvm.org/docs/Passes.html#utility-passes</a></li></ul></div></div></div></body></html>