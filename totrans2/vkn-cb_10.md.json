["```cpp\nstd::array<float, 16> translation_matrix = { \n  1.0f, 0.0f, 0.0f, 0.0f, \n  0.0f, 1.0f, 0.0f, 0.0f, \n  0.0f, 0.0f, 1.0f, 0.0f, \n     x,    y,    z, 1.0f \n}; \nreturn translation_matrix;\n\n```", "```cpp\nif( normalize ) { \n  std::array<float, 3> normalized = Normalize( x, y, z ); \n  x = normalized[0]; \n  y = normalized[1]; \n  z = normalized[2]; \n} \nconst float c = cos( Deg2Rad( angle ) ); \nconst float _1_c = 1.0f - c; \nconst float s = sin( Deg2Rad( angle ) ); \nstd::array<float, 16> rotation_matrix = { \n  x * x * _1_c + c, \n  y * x * _1_c - z * s, \n  z * x * _1_c + y * s, \n  0.0f, \n  x * y * _1_c + z * s, \n  y * y * _1_c + c, \n  z * y * _1_c - x * s, \n  0.0f, \n  x * z * _1_c - y * s, \n  y * z * _1_c + x * s, \n  z * z * _1_c + c, \n  0.0f, \n  0.0f, \n  0.0f, \n  0.0f, \n  1.0f \n}; \nreturn rotation_matrix;\n\n```", "```cpp\nstd::array<float, 16> scaling_matrix = { \n     x, 0.0f, 0.0f, 0.0f, \n  0.0f,    y, 0.0f, 0.0f, \n  0.0f, 0.0f,    z, 0.0f, \n  0.0f, 0.0f, 0.0f, 1.0f \n}; \nreturn scaling_matrix;\n\n```", "```cpp\nfloat f = 1.0f / tan( Deg2Rad( 0.5f * field_of_view ) );\n\nMatrix4x4 perspective_projection_matrix = {\n f / aspect_ratio,\n 0.0f,\n 0.0f,\n 0.0f,\n\n 0.0f,\n -f,\n 0.0f,\n 0.0f,\n\n 0.0f,\n 0.0f,\n far_plane / (near_plane - far_plane),\n -1.0f,\n\n 0.0f,\n 0.0f,\n (near_plane * far_plane) / (near_plane - far_plane),\n 0.0f\n};\nreturn perspective_projection_matrix;\n\n```", "```cpp\nMatrix4x4 orthographic_projection_matrix = {\n  2.0f / (right_plane - left_plane),\n  0.0f,\n  0.0f,\n  0.0f,\n\n  0.0f,\n  2.0f / (bottom_plane - top_plane),\n  0.0f,\n  0.0f,\n\n  0.0f,\n  0.0f,\n  1.0f / (near_plane - far_plane),\n  0.0f,\n\n  -(right_plane + left_plane) / (right_plane - left_plane),\n  -(bottom_plane + top_plane) / (bottom_plane - top_plane),\n  near_plane / (near_plane - far_plane),\n  1.0f\n };\n return orthographic_projection_matrix;\n\n```", "```cpp\n#include ... \n#define STB_IMAGE_IMPLEMENTATION \n#include \"stb_image.h\"\n\n```", "```cpp\n      std::memcpy( image_data.data(), stbi_data.get(), data_size )\n\n```", "```cpp\nint width = 0; \nint height = 0; \nint num_components = 0; \nstd::unique_ptr<unsigned char, void(*)(void*)> stbi_data( stbi_load( filename, &width, &height, &num_components, num_requested_components ), stbi_image_free );\n\nif( (!stbi_data) || \n    (0 >= width) || \n    (0 >= height) || \n    (0 >= num_components) ) { \n  std::cout << \"Could not read image!\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nstd::vector<unsigned char> image_data; \nint data_size = width * height * (0 < num_requested_components ? num_requested_components : num_components); \nimage_data.resize( data_size ); \nstd::memcpy( image_data.data(), stbi_data.get(), data_size ); \nreturn true;\n\n```", "```cpp\n#include ... \n#define TINYOBJLOADER_IMPLEMENTATION \n#include \"tiny_obj_loader.h\"\n\n```", "```cpp\nstruct Mesh { \n  std::vector<float>  Data; \n  struct Part { \n    uint32_t  VertexOffset; \n    uint32_t  VertexCount; \n  }; \n  std::vector<Part>   Parts; \n};\n\n```", "```cpp\ntinyobj::attrib_t                attribs; \nstd::vector<tinyobj::shape_t>    shapes; \nstd::vector<tinyobj::material_t> materials; \nstd::string                      error; \nbool result = tinyobj::LoadObj( &attribs, &shapes, &materials, &error, filename.c_str() ); \nif( !result ) { \n  std::cout << \"Could not open '\" << filename << \"' file.\"; \n  if( 0 < error.size() ) { \n    std::cout << \" \" << error; \n  } \n  std::cout << std::endl; \n  return false; \n}\n\n```", "```cpp\nMesh mesh = {}; \nuint32_t offset = 0; \nfor( auto & shape : shapes ) { \n  uint32_t part_offset = offset; \n\n  for( auto & index : shape.mesh.indices ) { \n    mesh.Data.emplace_back( attribs.vertices[3 * index.vertex_index + 0] ); \n    mesh.Data.emplace_back( attribs.vertices[3 * index.vertex_index + 1] ); \n    mesh.Data.emplace_back( attribs.vertices[3 * index.vertex_index + 2] ); \n    ++offset; \n\n    if( (load_normals) && \n        (attribs.normals.size() > 0) ) { \n      mesh.Data.emplace_back( attribs.normals[3*index.normal_index+0]); \n      mesh.Data.emplace_back( attribs.normals[3*index.normal_index+1]); \n      mesh.Data.emplace_back( attribs.normals[3*index.normal_index+2]); \n    } \n\n    if( (load_texcoords) && \n        (attribs.texcoords.size() > 0)) { \n      mesh.Data.emplace_back( attribs.texcoords[2 * index.texcoord_index + 0] ); \n      mesh.Data.emplace_back( attribs.texcoords[2 * index.texcoord_index + 1] ); \n    } \n  } \n\n  uint32_t part_vertex_count = offset - part_offset; \n  if( 0 < part_vertex_count ) { \n    mesh.Parts.push_back( { part_offset, part_vertex_count } ); \n  } \n}\n\n```"]