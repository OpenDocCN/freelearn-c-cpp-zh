<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Handling Game States</h1></div></div></div><p>When we first start up a game, we expect to see a splash screen showing any branding for publishers and developers, followed by a loading screen as the game does its initial setup. After this, we are usually faced with a menu screen; here, we can change settings and start the game. Starting the game leads us to another loading screen, possibly followed by a cut scene, and finally, we are in the game. When we are in the game, we can pause our play (allowing us to change any settings), exit the game, restart the level, and so on. If we fail the level, we are shown either an animation or a game over screen depending on how the game is set up. All of these different sections of a game are called <a class="indexterm" id="id274"/>
<em>Game States</em>. It is very important that we make the transition between these states as easy as possible.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two different ways of handling states, starting with a really simple implementation and gradually building our framework implementation</li><li class="listitem" style="list-style-type: disc">Implementing <strong>Finite State Machines</strong> (<strong>FSM</strong>)</li><li class="listitem" style="list-style-type: disc">Adding states to the overall framework</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>A simple way for switching states</h1></div></div></div><p>One of the simplest ways to handle <a class="indexterm" id="id275"/>states is to load everything we want at the game's initialization stage, but only draw and update the objects specific to each state. Let's look at an example of how this could work. First, we can define a set of states we are going to use:</p><div><pre class="programlisting">enum game_states
{
  MENU = 0,
  PLAY = 1,
  GAMEOVER = 2
};</pre></div><p>We can then use the <code class="literal">Game::init</code> function to create the objects:</p><div><pre class="programlisting">// create menu objects
m_pMenuObj1 = new MenuObject();
m_pMenuObj1 = new MenuObject();

// create play objects
m_pPlayer = new Player();
m_pEnemy = new Enemy();

// create game over objects…</pre></div><p>Then, set our initial state:</p><div><pre class="programlisting">m_currentGameState = MENU;</pre></div><p>Next, we can change our <code class="literal">update</code> function<a class="indexterm" id="id276"/> to only use the things we want when in a specific state:</p><div><pre class="programlisting">void Game::update()
{
  switch(m_currentGameState)
  {
    case MENU:
      m_menuObj1-&gt;update();
      m_menuObj2-&gt;update();
      break;

    case PLAY:
      m_pPlayer-&gt;update();
      m_pEnemy-&gt;update();

    case GAMEOVER:
      // do game over stuff…
  }
}</pre></div><p>The <code class="literal">render</code> function<a class="indexterm" id="id277"/> would do something similar. These functions could of course still loop through arrays and use polymorphism as we originally had done, but on a state-by-state basis. Changing states is as simple as changing the value of the <code class="literal">m_currentGameState</code> variable.</p><p>If you can see issues with this method, then it is very encouraging that you are starting to think in an object-oriented way. This way of updating states would be a bit of a nightmare to maintain and the scope for error is quite large. There are too many areas that need to be updated and <a class="indexterm" id="id278"/>changed to make this a viable solution for any game larger than a simple arcade game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Implementing finite state machines</h1></div></div></div><p>What we really need is the ability to define our states outside the <code class="literal">game</code> class, and have the state itself take care of what<a class="indexterm" id="id279"/> it needs to load, render, and update. For this we can create what is known as an FSM. The definition of FSM, as we will use it, is a machine that can exist in a finite number of states,<a class="indexterm" id="id280"/> can exist in only one state at a time (known as the current state), and can change from one state to another (known as a transition).</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>A base class for game states</h2></div></div></div><p>Let's start our implementation by creating a base <a class="indexterm" id="id281"/>class for all of our states; create a header file called <a class="indexterm" id="id282"/>
<code class="literal">GameState.h</code>:</p><div><pre class="programlisting">#include&lt;string&gt;
class GameState
{
public:
  virtual void update() = 0;
  virtual void render() = 0;

  virtual bool onEnter() = 0;
  virtual bool onExit() = 0;

  virtual std::string getStateID() const = 0;
};</pre></div><p>Just like our <code class="literal">GameObject</code> class, this is an abstract base class; we aren't actually putting any functionality into it, we just want all of our derived classes to follow this blueprint. The <code class="literal">update</code> and <code class="literal">render</code> functions are self-explanatory, as they will function just like the functions we created in the <code class="literal">Game</code> class. We can think of the <code class="literal">onEnter</code> and <code class="literal">onExit</code> functions as similar to other <code class="literal">load</code> and <code class="literal">clean</code> functions; we call the <code class="literal">onEnter</code> function as soon as a state is created and <code class="literal">onExit</code> once it is removed. The last function is a getter for the state ID; each state will need to define this function and return its own <code class="literal">staticconst</code> ID. The ID is used to ensure that states don't get repeated. There should be no need to change to the same state, so we check this using the state ID.</p><p>That's it for our <code class="literal">GameState</code> base class; we can now create some test states that derive from this class. We will start<a class="indexterm" id="id283"/> with a state called <code class="literal">MenuState</code>. Go ahead and create <code class="literal">MenuState.h</code> and <code class="literal">MenuState.cpp</code> in our project, open up <code class="literal">MenuState.h</code>, and start coding:</p><div><pre class="programlisting">#include"GameState.h"

class MenuState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_menuID; }

private:

  static const std::string s_menuID;
};</pre></div><p>We can now define these methods in our <code class="literal">MenuState.cpp</code> file<a class="indexterm" id="id284"/>. We will just display some text in the console window for now while we test our implementation; we will give this state an ID of <code class="literal">"MENU"</code>:</p><div><pre class="programlisting">#include "MenuState.h"

const std::string MenuState::s_menuID = "MENU";

void MenuState::update()
{
  // nothing for now
}

void MenuState::render()
{
  // nothing for now
}

bool MenuState::onEnter()
{
  std::cout &lt;&lt; "entering MenuState\n";
  return true;
}

bool MenuState::onExit()
{
  std::cout &lt;&lt; "exiting MenuState\n";
  return true;
}</pre></div><p>We will now create<a class="indexterm" id="id285"/> another state called <code class="literal">PlayState</code>, create <code class="literal">PlayState.h</code> and <code class="literal">PlayState.cpp</code> in our project, and declare our methods in the header file:</p><div><pre class="programlisting">#include "GameState.h"

class PlayState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_playID; }

private:

  static const std::string s_playID;
};</pre></div><p>This header file is the same as <code class="literal">MenuState.h</code> with the only difference being <code class="literal">getStateID</code> returning this class' specific ID (<code class="literal">"PLAY"</code>). Let's define our functions:</p><div><pre class="programlisting">#include "PlayState.h"

const std::string PlayState::s_playID = "PLAY";

void PlayState::update()
{
  // nothing for now
}

void PlayState::render()
{
  // nothing for now
}

bool PlayState::onEnter()
{
  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}

bool PlayState::onExit()
{
  std::cout &lt;&lt; "exiting PlayState\n";
  return true;
}</pre></div><p>We now have two states<a class="indexterm" id="id286"/> ready for testing; we must next create our FSM so that we can handle them.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Implementing FSM</h2></div></div></div><p>Our FSM is going to need to handle our states<a class="indexterm" id="id287"/> in a number of ways, which include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Removing one state and adding another</strong>: We will use this way to completely change states without leaving the option to return</li><li class="listitem" style="list-style-type: disc"><strong>Adding one state without removing the previous state</strong>: This way is useful for pause menus and so on</li><li class="listitem" style="list-style-type: disc"><strong>Removing one state without adding another</strong>: This way will be used to remove pause states or any other state that had been pushed on top of another one</li></ul></div><p>Now that we have come up with the behavior we want our FSM to have, let's start creating the class. Create the <code class="literal">GameStateMachine.h</code> and <code class="literal">GameStateMachine.cpp</code> files in our project. We will start by declaring our functions in the header file:</p><div><pre class="programlisting">#include "GameState.h"

class GameStateMachine
{
public:

  void pushState(GameState* pState);
  void changeState(GameState* pState);
  void popState();
};</pre></div><p>We have declared the three functions we need. The <code class="literal">pushState</code> function will add a state without removing the previous <a class="indexterm" id="id288"/>state, the <code class="literal">changeState</code> function will remove the previous state before adding another, and finally, the <code class="literal">popState</code> function will remove whichever state is currently being used without adding another. We will need a place to store these states; we will use a vector:</p><div><pre class="programlisting">private:

std::vector&lt;GameState*&gt; m_gameStates;</pre></div><p>In the <code class="literal">GameStateMachine.cpp</code> file, we can define these functions and then go through them step-by-step:</p><div><pre class="programlisting">void GameStateMachine::pushState(GameState *pState)
{
  m_gameStates.push_back(pState);
  m_gameStates.back()-&gt;onEnter();
}</pre></div><p>This is a very straightforward function; we simply push the passed-in <code class="literal">pState</code> parameter<a class="indexterm" id="id289"/> into the <code class="literal">m_gameStates</code> array and then call its <code class="literal">onEnter</code> function<a class="indexterm" id="id290"/>:</p><div><pre class="programlisting">void GameStateMachine::popState()
{
  if(!m_gameStates.empty())
  {
    if(m_gameStates.back()-&gt;onExit())
    {
      delete m_gamestates.back();
      m_gameStates.pop_back();
    }
  }
}</pre></div><p>Another simple function is <code class="literal">popState</code>. We first check if there are actually any states available to remove, and if so, we call the <code class="literal">onExit</code> function<a class="indexterm" id="id291"/> of the current state and then remove it:</p><div><pre class="programlisting">void GameStateMachine::changeState(GameState *pState)
{
  if(!m_gameStates.empty())
  {
    if(m_gameStates.back()-&gt;getStateID() == pState-&gt;getStateID())
    {
      return; // do nothing
    }

    if(m_gameStates.back()-&gt;onExit())
    {
      delete m_gamestates.back();
      m_gameStates.pop_back();
    }
  }

  // push back our new state
  m_gameStates.push_back(pState);

  // initialise it
  m_gameStates.back()-&gt;onEnter();
}</pre></div><p>Our third function is a little more complicated. First, we must check if there are already any states in the array, and if there are, <a class="indexterm" id="id292"/>we check whether their state ID is the same as the current one, and if it is, then we do nothing. If the state IDs do not match, then we remove the current state, add our new <code class="literal">pState</code>, and call its <code class="literal">onEnter</code> function. Next, we will add new <code class="literal">GameStateMachine</code> as a member of the <code class="literal">Game</code> class:</p><div><pre class="programlisting">GameStateMachine* m_pGameStateMachine;</pre></div><p>We can then use the <code class="literal">Game::init</code> function<a class="indexterm" id="id293"/> to create our state machine and add our first state:</p><div><pre class="programlisting">m_pGameStateMachine = new GameStateMachine();
m_pGameStateMachine-&gt;changeState(new MenuState());</pre></div><p>The <code class="literal">Game::handleEvents</code> function<a class="indexterm" id="id294"/> will allow us to move between our states for now:</p><div><pre class="programlisting">void Game::handleEvents()
{
  TheInputHandler::Instance()-&gt;update();

  if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_RETURN))
  {
    m_pGameStateMachine-&gt;changeState(new PlayState());
  }
}</pre></div><p>When we press the <em>Enter</em> key<a class="indexterm" id="id295"/>, the<a class="indexterm" id="id296"/> state will change. Test the project and you should get the following output after changing states:</p><div><pre class="programlisting">entering MenuState
exiting MenuState
entering PlayState</pre></div><p>We now have the beginnings of our FSM and can next add <code class="literal">update</code> and <code class="literal">render</code> functions to our <code class="literal">GameStateMachine</code> header file:</p><div><pre class="programlisting">void update();
void render();</pre></div><p>We can define them in our <code class="literal">GameStateMachine.cpp</code> file:</p><div><pre class="programlisting">void GameStateMachine::update()
{
  if(!m_gameStates.empty())
  {
    m_gameStates.back()-&gt;update();
  }
}

void GameStateMachine::render()
{
  if(!m_gameStates.empty())
  {
    m_gameStates.back()-&gt;render();
  }
}</pre></div><p>These functions simply check if there are any states, and if so, they update and render the current state. You will notice that we use <code class="literal">back()</code> to get the current state; this is because we have designed our FSM to always use the state at the back of the array. We use <code class="literal">push_back()</code> when adding new states so that they get pushed to the back of the array and used immediately. Our <code class="literal">Game</code> class will now<a class="indexterm" id="id297"/> use the FSM functions in place of its own <code class="literal">update</code> and <code class="literal">render</code> functions:</p><div><pre class="programlisting">void Game::render()
{
  SDL_RenderClear(m_pRenderer); 

  m_pGameStateMachine-&gt;render();

  SDL_RenderPresent(m_pRenderer); 
}

void Game::update()
{
  m_pGameStateMachine-&gt;update();
}</pre></div><p>Our FSM is now in place.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Implementing menu states</h1></div></div></div><p>We will now move on to creating a<a class="indexterm" id="id298"/> simple menu state with visuals and mouse handling. We will use two new screenshots for our buttons, which are available with the source code downloads:</p><div><img alt="Implementing menu states" src="img/6821OT_05_01.jpg"/></div><p>The following screenshot shows the exit feature:</p><div><img alt="Implementing menu states" src="img/6821OT_05_02.jpg"/></div><p>These are essentially sprite sheets with the three states of our button. Let's create a new class for these buttons, <a class="indexterm" id="id299"/>which we will call <code class="literal">MenuButton</code>. Go ahead and create <code class="literal">MenuButton.h</code> and <code class="literal">MenuButton.cpp</code>. We will start with the header file:</p><div><pre class="programlisting">class MenuButton : public SDLGameObject
{
public:

  MenuButton(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};</pre></div><p>By now this should look very familiar and it should feel straightforward to create new types. We will also define our button states as an enumerated type so that our code becomes more readable; put this in the header file under <code class="literal">private</code>:</p><div><pre class="programlisting">enum button_state
{
  MOUSE_OUT = 0,
  MOUSE_OVER = 1,
  CLICKED = 2
};</pre></div><p>Open up the <code class="literal">MenuButton.cpp</code> file and we can start to flesh out our <code class="literal">MenuButton</code> class:</p><div><pre class="programlisting">MenuButton::MenuButton(const LoaderParams* pParams) : SDLGameObject(pParams)
{
  m_currentFrame = MOUSE_OUT; // start at frame 0
}

void MenuButton::draw()
{
  SDLGameObject::draw(); // use the base class drawing
}

void MenuButton::update()
{
  Vector2D* pMousePos = TheInputHandler::Instance()
  -&gt;getMousePosition();

  if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
  &amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
  &amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
  &amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())
  {
    m_currentFrame = MOUSE_OVER;

    if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT))
    {
      m_currentFrame = CLICKED;
    }
  }
  else
  {
    m_currentFrame = MOUSE_OUT;
  }
}

void MenuButton::clean()
{
  SDLGameObject::clean();
}</pre></div><p>The only thing really new in<a class="indexterm" id="id300"/> this class is the <code class="literal">update</code> function. Next, we will go through each step of this function:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we get the coordinates of the mouse pointer and store them in a pointer to a <code class="literal">Vector2D</code> object:<div><pre class="programlisting">Vector2D* pMousePos = TheInputHandler::Instance()-&gt;getMousePosition();</pre></div></li><li class="listitem" style="list-style-type: disc">Now, check whether the mouse is over the button or not. We do this by first checking whether the mouse position is less than the position of the right-hand side of the button (<em>x position + width</em>). We then check if the mouse position is greater than the position of the left-hand side of the button (<em>x position</em>). The y-position check is essentially the same with <em>y position + height</em> and <em>y position</em> for bottom and top respectively:<div><pre class="programlisting">if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
&amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
&amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
&amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())</pre></div></li><li class="listitem" style="list-style-type: disc">If the previous check is true, we know that the mouse is hovering over our button; we set its frame to <code class="literal">MOUSE_OVER (1)</code>:<div><pre class="programlisting">m_currentFrame = MOUSE_OVER;</pre></div></li><li class="listitem" style="list-style-type: disc">We can then check whether the mouse has been clicked; if it has, then we set the current frame to <code class="literal">CLICKED(2)</code>:<div><pre class="programlisting">if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT))
{
  m_currentFrame = CLICKED;
}</pre></div></li><li class="listitem" style="list-style-type: disc">If the check is not true,<a class="indexterm" id="id301"/> then we know the mouse is outside the button and we set the frame to <code class="literal">MOUSE_OUT (0)</code>:<div><pre class="programlisting">else
{
  m_currentFrame = MOUSE_OUT;
}</pre></div></li></ul></div><p>We can now test out our reusable button class. Open up our previously created <code class="literal">MenuState.hand</code>, which we will implement for real. First, we are going to need a vector of <code class="literal">GameObject*</code> to store our menu items:</p><div><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>Inside the <code class="literal">MenuState.cpp</code> file, we can now start handling our menu items:</p><div><pre class="programlisting">void MenuState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}
void MenuState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}</pre></div><p>The <code class="literal">onExit</code> and <code class="literal">onEnter</code> functions can be defined as follows:</p><div><pre class="programlisting">bool MenuState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/button.png", 
  "playbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/exit.png", 
  "exitbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* button1 = new MenuButton(new LoaderParams(100, 100, 
  400, 100, "playbutton"));
  GameObject* button2 = new MenuButton(new LoaderParams(100, 300, 
  400, 100, "exitbutton"));

  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering MenuState\n";
  return true;
}

bool MenuState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("playbutton");
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("exitbutton");

  std::cout &lt;&lt; "exiting MenuState\n";
  return true;
}</pre></div><p>We use <code class="literal">TextureManager</code> to load our new images and then assign these textures to two buttons. The <code class="literal">TextureManager</code> class<a class="indexterm" id="id302"/> also has a new function called <code class="literal">clearFromTextureMap</code>, which takes the ID of the texture we want to remove; it is defined as follows:</p><div><pre class="programlisting">void TextureManager::clearFromTextureMap(std::string id)
{
  m_textureMap.erase(id);
}</pre></div><p>This function enables us to clear only the textures from the current state, not the entire texture map. This is essential when we push states and then pop them, as we do not want the popped state to clear the original state's textures.</p><p>Everything else is essentially identical to how we handle objects in the <code class="literal">Game</code> class. Run the project and we will have buttons that react to mouse events. The window will look like the following screenshot (go ahead and test it out):</p><div><img alt="Implementing menu states" src="img/6821OT_05_03.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Function pointers and callback functions</h2></div></div></div><p>Our buttons react to rollovers<a class="indexterm" id="id303"/> and clicks but do not actually do anything yet. What we really want to achieve is the ability to create <code class="literal">MenuButton</code> and pass in the function we want it to call once it is clicked; we can achieve this through the use of function pointers. Function pointers do exactly as they say: they point to a function. We can use classic<a class="indexterm" id="id304"/> C style function pointers for the<a class="indexterm" id="id305"/> moment, as we are only going to use functions that do not take any parameters and always have a return type of <code class="literal">void</code> (therefore, we do not need to make them generic at this point). </p><p>The syntax for a function pointer is like this:</p><div><pre class="programlisting">returnType (*functionName)(parameters);</pre></div><p>We declare our function pointer as a private member in <code class="literal">MenuButton.h</code> as follows:</p><div><pre class="programlisting">void (*m_callback)();</pre></div><p>We also add a new member variable to handle clicking better:</p><div><pre class="programlisting">bool m_bReleased;</pre></div><p>Now we can alter the constructor to allow us to pass in our function:</p><div><pre class="programlisting">MenuButton(const LoaderParams* pParams, void (*callback)());</pre></div><p>In our <code class="literal">MenuButton.cpp</code> file, we can now alter the constructor and initialize our pointer with the initialization list:</p><div><pre class="programlisting">MenuButton::MenuButton(const LoaderParams* pParams, void (*callback)() ) : SDLGameObject(pParams), m_callback(callback)</pre></div><p>The <code class="literal">update</code> function can now call this function:</p><div><pre class="programlisting">void MenuButton::update()
{
  Vector2D* pMousePos = TheInputHandler::Instance()
  -&gt;getMousePosition();

  if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
  &amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
  &amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
  &amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())
  {
    if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT) 
    &amp;&amp; m_bReleased)
    {
      m_currentFrame = CLICKED;

      m_callback(); // call our callback function

      m_bReleased = false;
    }
    else if(!TheInputHandler::Instance()
    -&gt;getMouseButtonState(LEFT))
    {
      m_bReleased = true;
      m_currentFrame = MOUSE_OVER;
    }
  }
  else
  {
    m_currentFrame = MOUSE_OUT;
  }
}</pre></div><p>Note that this <code class="literal">update</code> function<a class="indexterm" id="id306"/> now uses the <code class="literal">m_bReleased</code> value to ensure we release the mouse button before doing the<a class="indexterm" id="id307"/> callback again; this is how we want our clicking to behave.</p><p>In our <code class="literal">MenuState.h</code> object, we can declare some functions that we will pass into the constructors of our <code class="literal">MenuButton</code> objects:</p><div><pre class="programlisting">private:
// call back functions for menu items
static void s_menuToPlay();
static void s_exitFromMenu();</pre></div><p>We have declared these functions as static; this is because our callback functionality will only support static functions. It is a little more complicated to handle regular member functions as function pointers, so we will avoid this and stick to static functions. We can define these functions in the <code class="literal">MenuState.cpp</code> file:</p><div><pre class="programlisting">void MenuState::s_menuToPlay()
{
  std::cout &lt;&lt; "Play button clicked\n";
}

void MenuState::s_exitFromMenu()
{
  std::cout &lt;&lt; "Exit button clicked\n";
}</pre></div><p>We can pass these functions into the constructors of our buttons:</p><div><pre class="programlisting">GameObject* button1 = new MenuButton(new LoaderParams(100, 100, 400, 100, "playbutton"), s_menuToPlay);
GameObject* button2 = new MenuButton(new LoaderParams(100, 300, 400, 100, "exitbutton"), s_exitFromMenu);</pre></div><p>Test our project and you will see our functions printing to the console. We are now passing in the function we want our <a class="indexterm" id="id308"/>button to call once it is clicked; this functionality is great for our buttons. Let's test the exit button with some real functionality:</p><div><pre class="programlisting">void MenuState::s_exitFromMenu()
{
  TheGame::Instance()-&gt;quit();
}</pre></div><p>Now clicking on our exit button will exit the game. The next step is to allow the <code class="literal">s_menuToPlay</code> function to move to <code class="literal">PlayState</code>. We first need to add a getter to the <code class="literal">Game.h</code> file to allow us to access the state machine:</p><div><pre class="programlisting">GameStateMachine* getStateMachine(){ return m_pGameStateMachine; }</pre></div><p>We can now use this to change states in <code class="literal">MenuState</code>:</p><div><pre class="programlisting">void MenuState::s_menuToPlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  PlayState());
}</pre></div><p>Go ahead and test; <code class="literal">PlayState</code> does not do anything yet, but our console output should show the movement between states.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Implementing the temporary play state</h2></div></div></div><p>We have created <code class="literal">MenuState</code>; next, we need to create <code class="literal">PlayState</code> so that we can visually see the change in our states. For <code class="literal">PlayState</code> we will create a player object that uses our <code class="literal">helicopter.png</code> image and <a class="indexterm" id="id309"/>follows the mouse around. We will start with the <code class="literal">Player.cpp</code> file and add the code to make the <code class="literal">Player</code> object follow the mouse position:</p><div><pre class="programlisting">void Player::handleInput()
{
  Vector2D* target = TheInputHandler::Instance()
  -&gt;getMousePosition();

  m_velocity = *target - m_position;

  m_velocity /= 50;
}</pre></div><p>First, we get the current mouse location; we can then get a vector that leads from the current position to the mouse position by subtracting the current position from the mouse position. We then divide the<a class="indexterm" id="id310"/> velocity by a scalar to slow us down a little and allow us to see our helicopter catch up to the mouse rather than stick to it. Our <code class="literal">PlayState.h</code> file will now need its own vector of <code class="literal">GameObject*</code>:</p><div><pre class="programlisting">class GameObject;

class PlayState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_playID; }

private:

  static const std::string s_playID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Finally, we must update the <code class="literal">PlayState.cpp</code> implementation file to use our <code class="literal">Player</code> object:</p><div><pre class="programlisting">const std::string PlayState::s_playID = "PLAY";

void PlayState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}

void PlayState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}

bool PlayState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/helicopter.png", 
  "helicopter", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* player = new Player(new LoaderParams(100, 100, 128, 
  55, "helicopter");

  m_gameObjects.push_back(player);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}

bool PlayState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("helicopter");

  std::cout &lt;&lt; "exiting PlayState\n";
  return true;
}</pre></div><p>This file is very similar to the<a class="indexterm" id="id311"/> <code class="literal">MenuState.cpp</code> file, but this time we are using a <code class="literal">Player</code> object rather than the two <code class="literal">MenuButton</code> objects. There is one adjustment to our <code class="literal">SDLGameObject.cpp</code> file that will make <code class="literal">PlayState</code> look even better; we are going to flip the image file depending on the velocity of the object:</p><div><pre class="programlisting">void SDLGameObject::draw()
{
  if(m_velocity.getX() &gt; 0)
  {
    TextureManager::Instance()-&gt;drawFrame(m_textureID, 
    (Uint32)m_position.getX(), (Uint32)m_position.getY(),
    m_width, m_height, m_currentRow, m_currentFrame, 
    TheGame::Instance()-&gt;getRenderer(),SDL_FLIP_HORIZONTAL);
  }
  else
  {
    TextureManager::Instance()-&gt;drawFrame(m_textureID, 
    (Uint32)m_position.getX(), (Uint32)m_position.getY(),
    m_width, m_height, m_currentRow, m_currentFrame, 
    TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>We check whether<a class="indexterm" id="id312"/> the object's velocity is more than <code class="literal">0</code> (moving to the right-hand side) and flip the image accordingly. Run our game and you will now have the ability to move between <code class="literal">MenuState</code> and <code class="literal">PlayState</code> each with their own functionality and objects. The following screenshot shows our project so far:</p><div><img alt="Implementing the temporary play state" src="img/6821OT_05_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Pausing the game</h2></div></div></div><p>Another very important state<a class="indexterm" id="id313"/> for our games is the pause state. Once paused, the game could have all kinds of options. Our <code class="literal">PauseState</code> class will be very similar to the <code class="literal">MenuState</code>, but with different button visuals and callbacks. Here are our two new screenshots (again available in the source code download):</p><div><img alt="Pausing the game" src="img/6821OT_05_05.jpg"/></div><p>The following screenshot shows the resume functionality:</p><div><img alt="Pausing the game" src="img/6821OT_05_06.jpg"/></div><p>Let's start by<a class="indexterm" id="id314"/> creating our <code class="literal">PauseState.h</code> file in the project:</p><div><pre class="programlisting">class GameObject;

class PauseState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_pauseID; }

private:

  static void s_pauseToMain();
  static void s_resumePlay();

  static const std::string s_pauseID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Next, create our <code class="literal">PauseState.cpp</code> file<a class="indexterm" id="id315"/>:</p><div><pre class="programlisting">const std::string PauseState::s_pauseID = "PAUSE";

void PauseState::s_pauseToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}

void PauseState::s_resumePlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;popState();
}

void PauseState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}

void PauseState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}

bool PauseState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/resume.png", 
  "resumebutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/main.png", 
  "mainbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* button1 = new MenuButton(new LoaderParams(200, 100, 
  200, 80, "mainbutton"), s_pauseToMain);
  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, 
  200, 80, "resumebutton"), s_resumePlay);

  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}

bool PauseState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("resumebutton");
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("mainbutton");
  // reset the mouse button states to false
  TheInputHandler::Instance()-&gt;reset();

  std::cout &lt;&lt; "exiting PauseState\n";
  return true;
}</pre></div><p>In our <code class="literal">PlayState.cpp</code> file, we can<a class="indexterm" id="id316"/> now use our new <code class="literal">PauseState</code> class:</p><div><pre class="programlisting">void PlayState::update()
{
  if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_ESCAPE))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    PauseState());
  }

  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}</pre></div><p>This function listens for the <em>Esc</em> key being pressed, and once it has been pressed, it then pushes a new <code class="literal">PauseState</code> class onto the state array in FSM. Remember that <code class="literal">pushState</code> does not remove the old state; it merely stops using it and uses the new state. Once we are done with the pushed state, we remove it from the state array and the game continues to use the previous state. We remove the <a class="indexterm" id="id317"/>pause state using the resume button's callback:</p><div><pre class="programlisting">void PauseState::s_resumePlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;popState();
}</pre></div><p>The main menu button takes us back to the main menu and completely removes any other states:</p><div><pre class="programlisting">void PauseState::s_pauseToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Creating the game over state</h2></div></div></div><p>We are going to create<a class="indexterm" id="id318"/> one final state, <code class="literal">GameOverState</code>. To get to this state, we will use collision detection and a new <code class="literal">Enemy</code> object in the <code class="literal">PlayState</code> class<a class="indexterm" id="id319"/>. We will check whether the <code class="literal">Player</code> object has hit the <code class="literal">Enemy</code> object, and if so, we will change to our <code class="literal">GameOverState</code> class. Our Enemy object will use a new image <code class="literal">helicopter2.png</code>:</p><div><img alt="Creating the game over state" src="img/6821OT_05_07.jpg"/></div><p>We will make our <code class="literal">Enemy</code> object's helicopter move up and down the screen just to keep things interesting. In our <code class="literal">Enemy.cpp</code> file, we will add this functionality:</p><div><pre class="programlisting">Enemy::Enemy(const LoaderParams* pParams) : SDLGameObject(pParams)
{
  m_velocity.setY(2);
  m_velocity.setX(0.001);
}

void Enemy::draw()
{
  SDLGameObject::draw();
}

void Enemy::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % m_numFrames));

  if(m_position.getY() &lt; 0)
  {
    m_velocity.setY(2);
  }
  else if(m_position.getY() &gt; 400)
  {
    m_velocity.setY(-2);
  }

  SDLGameObject::update();
}</pre></div><p>We can now add an <code class="literal">Enemy</code> object to our <code class="literal">PlayState</code> class:</p><div><pre class="programlisting">bool PlayState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/helicopter.png", 
  "helicopter", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()
  -&gt;load("assets/helicopter2.png", "helicopter2", 
  TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }


  GameObject* player = new Player(new LoaderParams(500, 100, 128, 
  55, "helicopter"));
  GameObject* enemy = new Enemy(new LoaderParams(100, 100, 128, 
  55, "helicopter2"));

  m_gameObjects.push_back(player);
  m_gameObjects.push_back(enemy);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}</pre></div><p>Running the game will allow us to see our two helicopters:</p><div><img alt="Creating the game over state" src="img/6821OT_05_08.jpg"/></div><p>Before we cover collision detection, we are going to create our <code class="literal">GameOverState</code> class<a class="indexterm" id="id320"/>. We will be using two <a class="indexterm" id="id321"/>new images for this state, one for new <code class="literal">MenuButton</code> and one for a new type, which we will call <code class="literal">AnimatedGraphic</code>:</p><div><img alt="Creating the game over state" src="img/6821OT_05_09.jpg"/></div><p>The following screenshot shows the game over functionality:</p><div><img alt="Creating the game over state" src="img/6821OT_05_10.jpg"/></div><p>
<code class="literal">AnimatedGraphic</code> is<a class="indexterm" id="id322"/> very similar to other types, so I will not go into too much detail here; however, what is important is the added value in the constructor that controls the speed of the animation, which sets the private member variable <code class="literal">m_animSpeed</code>:</p><div><pre class="programlisting">AnimatedGraphic::AnimatedGraphic(const LoaderParams* pParams, int animSpeed) : SDLGameObject(pParams), m_animSpeed(animSpeed)
{

}</pre></div><p>The <code class="literal">update</code> function will use this value to set the speed of the animation:</p><div><pre class="programlisting">void AnimatedGraphic::update()
{
  m_currentFrame = int(((SDL_GetTicks() / (1000 / m_animSpeed)) % 
  m_numFrames));
}</pre></div><p>Now that we have the <code class="literal">AnimatedGraphic</code> class<a class="indexterm" id="id323"/>, we can implement our <code class="literal">GameOverState</code> class. Create <code class="literal">GameOverState.h</code> and <code class="literal">GameOverState.cpp</code> in our project; the header file we will create should look very familiar, as given in the following code:</p><div><pre class="programlisting">class GameObject;

class GameOverState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const {return s_gameOverID;}

private:

  static void s_gameOverToMain();
  static void s_restartPlay();

  static const std::string s_gameOverID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Our implementation file is also very similar to other files already covered, so again I will only cover the parts that are different. First, we define our static variables and functions:</p><div><pre class="programlisting">const std::string GameOverState::s_gameOverID = "GAMEOVER";

void GameOverState::s_gameOverToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}

void GameOverState::s_restartPlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  PlayState());
}</pre></div><p>The <code class="literal">onEnter</code> function<a class="indexterm" id="id324"/> will create three new<a class="indexterm" id="id325"/> objects along with their textures:</p><div><pre class="programlisting">bool GameOverState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/gameover.png", 
  "gameovertext", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/main.png", 
  "mainbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/restart.png", 
  "restartbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* gameOverText = new AnimatedGraphic(new 
  LoaderParams(200, 100, 190, 30, "gameovertext", 2), 2);
  GameObject* button1 = new MenuButton(new LoaderParams(200, 200, 
  200, 80, "mainbutton"), s_gameOverToMain);
  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, 
  200, 80, "restartbutton"), s_restartPlay);

  m_gameObjects.push_back(gameOverText);
  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>That is pretty much it for our<a class="indexterm" id="id326"/> <code class="literal">GameOverState</code> class<a class="indexterm" id="id327"/>, but we must now create a condition that creates this state. Move to our <code class="literal">PlayState.h</code> file and we will create a new function to allow us to check for collisions:</p><div><pre class="programlisting">bool checkCollision(SDLGameObject* p1, SDLGameObject* p2);</pre></div><p>We will define this function in <code class="literal">PlayState.cpp</code>:</p><div><pre class="programlisting">bool PlayState::checkCollision(SDLGameObject* p1, SDLGameObject* 
p2)
{
  int leftA, leftB;
  int rightA, rightB;
  int topA, topB;
  int bottomA, bottomB;

  leftA = p1-&gt;getPosition().getX();
  rightA = p1-&gt;getPosition().getX() + p1-&gt;getWidth();
  topA = p1-&gt;getPosition().getY();
  bottomA = p1-&gt;getPosition().getY() + p1-&gt;getHeight();

  //Calculate the sides of rect B
  leftB = p2-&gt;getPosition().getX();
  rightB = p2-&gt;getPosition().getX() + p2-&gt;getWidth();
  topB = p2-&gt;getPosition().getY();
  bottomB = p2-&gt;getPosition().getY() + p2-&gt;getHeight();

  //If any of the sides from A are outside of B
  if( bottomA &lt;= topB ){return false;} 
  if( topA &gt;= bottomB ){return false; }
  if( rightA &lt;= leftB ){return false; }
  if( leftA &gt;= rightB ){return false;}

  return true;
}</pre></div><p>This function checks for collisions between two <code class="literal">SDLGameObject</code> types. For the function to work, we need to add three new functions to our <code class="literal">SDLGameObject</code> class:</p><div><pre class="programlisting">Vector2D&amp; getPosition() { return m_position; }
int getWidth() { return m_width; }
int getHeight() { return m_height; }</pre></div><p>The next chapter will deal with how<a class="indexterm" id="id328"/> this function works, but for now, it is enough to know that it does. Our <code class="literal">PlayState</code> class will now utilize this collision detection in its <a class="indexterm" id="id329"/>
<code class="literal">update</code> function:</p><div><pre class="programlisting">void PlayState::update()
{
  if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_ESCAPE))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    PauseState());
  }

  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }

  if(checkCollision(dynamic_cast&lt;SDLGameObject*&gt;
  (m_gameObjects[0]), dynamic_cast&lt;SDLGameObject*&gt;
  (m_gameObjects[1])))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    GameOverState());
  }
}</pre></div><p>We have to use a <code class="literal">dynamic_cast</code> object to cast our<a class="indexterm" id="id330"/> <code class="literal">GameObject*</code> class to an <code class="literal">SDLGameObject*</code> class. If <code class="literal">checkCollision</code> returns <code class="literal">true</code>, then we add the <code class="literal">GameOverState</code> class. The <a class="indexterm" id="id331"/>following screenshot shows the <code class="literal">GameOver</code> state:</p><div><img alt="Creating the game over state" src="img/6821OT_05_11.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Summary</h1></div></div></div><p>This chapter has left us with something a lot more like a game than in previous chapters. We have created states for menus, pause, play, and game over with each state having its own functionality and being handled using FSM. The <code class="literal">Game</code> class now uses FSM to render and update game objects and it does not now handle objects directly, as each individual state handles its own objects. We have also created simple callback functions for our buttons using function pointers and static functions.</p></div></body></html>