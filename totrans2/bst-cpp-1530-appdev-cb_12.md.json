["```cpp\n    #include <boost/graph/adjacency_list.hpp>\n    #include <string>\n\n    typedef std::string vertex_t;\n    typedef boost::adjacency_list<\n        boost::vecS\n        , boost::vecS\n        , boost::bidirectionalS\n        , vertex_t\n    > graph_type;\n    ```", "```cpp\n        graph_type graph;\n    ```", "```cpp\n        static const std::size_t vertex_count = 5;\n        graph.m_vertices.reserve(vertex_count);\n    ```", "```cpp\n    typedef boost::graph_traits<graph_type>\n                ::vertex_descriptor descriptor_t;\n\n        descriptor_t cpp \n            = boost::add_vertex(vertex_t(\"C++\"), graph);\n        descriptor_t stl \n            = boost::add_vertex(vertex_t(\"STL\"), graph);\n        descriptor_t boost \n            = boost::add_vertex(vertex_t(\"Boost\"), graph);\n        descriptor_t guru \n            = boost::add_vertex(vertex_t(\"C++ guru\"), graph);\n        descriptor_t ansic \n            = boost::add_vertex(vertex_t(\"C\"), graph);\n    ```", "```cpp\n        boost::add_edge(cpp, stl, graph);\n        boost::add_edge(stl, boost, graph);\n        boost::add_edge(boost, guru, graph);\n        boost::add_edge(ansic, guru, graph);\n    ```", "```cpp\n    template <class GraphT>\n    void find_and_print(const GraphT& g, boost::string_ref name) {\n    ```", "```cpp\n        typedef typename boost::graph_traits<graph_type>\n                ::vertex_iterator vert_it_t;\n\n        vert_it_t it, end;\n        boost::tie(it, end) = boost::vertices(g);\n    ```", "```cpp\n        typedef boost::graph_traits<graph_type>::vertex_descriptor desc_t;\n        for (; it != end; ++ it) {\n            desc_t desc = *it;\n            if (boost::get(boost::vertex_bundle, g)[desc] \n                     == name.data()) {\n                break;\n            }\n        }\n        assert(it != end);\n        std::cout << name << '\\n';\n    } /* find_and_print */\n    ```", "```cpp\nvertex_descriptor desc = boost::add_vertex(graph);boost::get(boost::vertex_bundle, g_)[desc] = std::move(vertex_data);\n```", "```cpp\n    #include <boost/graph/graphviz.hpp>\n    std::ostream& operator<<(std::ostream& out, const graph_type& g) {\n        detail::vertex_writer<graph_type> vw(g);\n        boost::write_graphviz(out, g, vw);\n        return out;\n    }\n    ```", "```cpp\n    namespace detail {\n\n        template <class GraphT>\n        class vertex_writer {\n            const GraphT& g_;\n\n        public:\n            explicit vertex_writer(const GraphT& g)\n                : g_(g)\n            {}\n\n            template <class VertexDescriptorT>\n            void operator()(std::ostream& out, \n               const VertexDescriptorT& d) const \n            {\n               out << \" [label=\\\"\"\n                   << boost::get(boost::vertex_bundle, g_)[d] \n                   << \"\\\"]\"; \n            }\n        }; // vertex_writer\n\n    } // namespace detail\n    ```", "```cpp\n$ dot -Tpng -o dot.png\n\ndigraph G {\n\n0 [label=\"C++\"];\n\n1 [label=\"STL\"];\n\n2 [label=\"Boost\"];\n\n3 [label=\"C++ guru\"];\n\n4 [label=\"C\"];\n\n0->1 ;\n\n1->2 ;\n\n2->3 ;\n\n4->3 ;\n\n}\n\n```", "```cpp\n    #include <boost/config.hpp>\n    #include <boost/random/random_device.hpp>\n    #include <boost/random/uniform_int_distribution.hpp>\n    ```", "```cpp\n        static const std::string provider =\n    #ifdef BOOST_WINDOWS\n            \"Microsoft Strong Cryptographic Provider\"\n    #else\n            \"/dev/urandom\"\n    #endif\n        ;\n    ```", "```cpp\n        boost::random_device device(provider);\n    ```", "```cpp\n        boost::random::uniform_int_distribution<unsigned short> random(1000);\n    ```", "```cpp\n    #include <boost/math/special_functions.hpp>\n    #include <cassert>\n    ```", "```cpp\n    template <class T>\n    void check_float_inputs(T value) {\n        assert(!boost::math::isinf(value));\n        assert(!boost::math::isnan(value));\n    ```", "```cpp\n        if (boost::math::signbit(value)) {\n            value = boost::math::changesign(value);\n        }\n\n        // ...\n    } // check_float_inputs\n    ```", "```cpp\n#include <stdexcept>\nstruct foo {\n    int val_;\n\n    operator int() const;\n    bool is_not_null() const;\n    void throws() const; // throws(std::logic_error)\n};\n```", "```cpp\n    #define BOOST_TEST_MODULE test_module_name\n    #include <boost/test/unit_test.hpp>\n    ```", "```cpp\n    BOOST_AUTO_TEST_CASE(test_no_1) {\n    ```", "```cpp\n        foo f1 = {1}, f2 = {2};\n        BOOST_CHECK(f1.is_not_null());\n    ```", "```cpp\n        BOOST_CHECK_NE(f1, f2);\n    ```", "```cpp\n        BOOST_CHECK_THROW(f1.throws(), std::logic_error);\n    } // BOOST_AUTO_TEST_CASE(test_no_1)\n    ```", "```cpp\nBOOST_AUTO_TEST_CASE(test_no_2) {\n    foo f1 = {1}, f2 = {2};\n    BOOST_REQUIRE_NE(f1, f2);\n    // ...\n} // BOOST_AUTO_TEST_CASE(test_no_2)\n```", "```cpp\nRunning 2 test cases...\nmain.cpp(15): error in \"test_no_1\": check f1.is_not_null() failed\nmain.cpp(17): error in \"test_no_1\": check f1 != f2 failed [0 == 0]\nmain.cpp(19): error in \"test_no_1\": exception std::logic_error is expected\nmain.cpp(24): fatal error in \"test_no_2\": critical check f1 != f2 failed [0 == 0]\n\n*** 4 failures detected in test suite \"test_module_name\"\n```", "```cpp\n    #define BOOST_TEST_MODULE test_module_name\n    #include <boost/test/unit_test.hpp>\n    ```", "```cpp\n    // developer1.cpp\n    #include <boost/test/unit_test.hpp>\n    #include \"foo.hpp\"\n    BOOST_AUTO_TEST_CASE(test_no_1) {\n        // ...\n    }\n\n    ///////////////////////////////////////////////////////////\n\n    // developer2.cpp\n    #include <boost/test/unit_test.hpp>\n    #include \"foo.hpp\"\n    BOOST_AUTO_TEST_CASE(test_no_2) {\n        // ...\n    }\n    ```", "```cpp\n./testing_advanced –run=test_no_1\n\n```", "```cpp\n./testing_advanced –run=test_no_1,test_no_2\n\n```", "```cpp\n    #include <boost/gil/gil_all.hpp>\n    #include <boost/gil/extension/io/png_dynamic_io.hpp>\n    #include <string>\n    ```", "```cpp\n        typedef boost::mpl::vector<\n                boost::gil::gray8_image_t,\n                boost::gil::gray16_image_t,\n                boost::gil::rgb8_image_t,\n                boost::gil::rgb16_image_t\n        > img_types;\n    ```", "```cpp\n        std::string file_name(argv[1]);\n        boost::gil::any_image<img_types> source;\n        boost::gil::png_read_image(file_name, source);\n    ```", "```cpp\n        boost::gil::apply_operation(\n            view(source),\n            negate()\n        );\n    ```", "```cpp\n        boost::gil::png_write_view(\"negate_\" + file_name, \n          const_view(source));\n    ```", "```cpp\n    struct negate {\n        typedef void result_type; // required\n\n        template <class View>\n        void operator()(const View& source) const {\n            // ...\n        }\n    }; // negate\n    ```", "```cpp\n    typedef typename View::value_type value_type;\n    typedef typename boost::gil::channel_type<value_type>::type \n        channel_t;\n    ```", "```cpp\n    const std::size_t channels \n        = boost::gil::num_channels<View>::value;\n    const channel_t max_val = (std::numeric_limits<channel_t>::max)();\n\n    for (unsigned int y = 0; y < source.height(); ++y) {\n        for (unsigned int x = 0; x < source.width(); ++x) {\n            for (unsigned int c = 0; c < channels; ++c) {\n                source(x, y)[c] = max_val - source(x, y)[c];\n            }\n        }\n    }\n    ```"]