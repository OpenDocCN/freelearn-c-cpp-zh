<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Dialogs, Controls, and Page Setup</h1></div></div></div><p>In this chapter, we look into the implementation of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Custom dialogs</strong>: The <code class="literal">Dialog</code> class is intended to be inherited by subclasses and equipped with controls.</li><li class="listitem" style="list-style-type: disc"><strong>Controls</strong>: The <code class="literal">Control</code> class and its subclasses. There are controls for edit fields, check boxes, radio buttons, list boxes, and combo boxes.</li><li class="listitem" style="list-style-type: disc"><strong>Converters</strong>: Between strings and other values. For instance, when the user inputs text that represents a numerical value, it is possible to add a converter that converts the text to a value, or gives an error message if the text does not hold a valid value.</li><li class="listitem" style="list-style-type: disc"><strong>Page Setup</strong>: Where we extend the <code class="literal">Dialog</code> class. The dialog is used when setting page settings for a document of the <code class="literal">StandardDocument</code> class. It handles information for headers, footers, and margins.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec74"/>Custom dialogs</h1></div></div></div><p>The <code class="literal">Dialog</code> class handles a set of <strong>controls</strong>, which are added to the dialog by the <code class="literal">AddControl</code> method. For a subclass of the <code class="literal">Dialog</code> class, refer to <code class="literal">PageSetupDialog</code> in the last section of this chapter. The Dialog class provides a modal dialog, which means that all other windows in the application become disabled until the dialog is closed.</p><p>The user may navigate between controls with the <em>
<strong>Tab</strong>
</em> key and between radio buttons in the same group with the arrow keys. They can also use mnemonics to access controls.</p><p>
<strong>Dialog.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
</pre><p>The <code class="literal">dialogMap</code> field is used by <code class="literal">DialogProc</code> to look up the dialog receiving the messages:</p><pre class="programlisting">  extern map&lt;HWND,Dialog*&gt; dialogMap; &#13;
  extern Font DialogFont; &#13;
</pre><p>The <code class="literal">Dialog</code> class is a subclass of <code class="literal">Window</code> even though it calls the default <code class="literal">Window</code> constructor, which does not call the Win32 API function <code class="literal">CreateWindowEx</code>. Instead, <code class="literal">DoModal</code> collects information about the dialog and its controls and calls the Win32 API function <code class="literal">DialogBoxIndirectParam</code>:</p><pre class="programlisting">  class Dialog : public Window { &#13;
    public: &#13;
      Dialog(String name, Point topLeft, &#13;
             Window* parentPtr = nullptr, &#13;
             WindowStyle style = OverlappedWindow, &#13;
             WindowStyle extendedStyle = NoStyle, &#13;
             Font font = DialogFont); &#13;
</pre><p>As the name implies, <code class="literal">DoModal</code> disables its parent window for as long as the dialog is visible. That is, until the user closes the dialog:</p><pre class="programlisting">      bool DoModal(); &#13;
</pre><p>The destructor deletes all controls, which implies that a subclass to <code class="literal">Dialog</code> should add dynamically allocated controls to the dialog without deleting them:</p><pre class="programlisting">      ~Dialog(); &#13;
</pre><p>The <code class="literal">AddControl</code> method assigns an identity number to the control and adds it to <code class="literal">idMap</code>.</p><pre class="programlisting">      int AddControl(Control* controlPtr); &#13;
</pre><p>The <code class="literal">OnSize</code> function is called each time the user changes the size of the dialog, it iterates through the controls and adjusts their size so that they keep their size relative to the size of the dialog client area.</p><pre class="programlisting">      void OnSize(Size windowSize); &#13;
</pre><p>When the user presses the <em>
<strong>Return</strong>
</em> key <code class="literal">OnReturn</code> is called, and when they press the <em>
<strong>Esc</strong>
</em> key <code class="literal">OnEscape</code> is called. Their default behavior is to close the dialog and return control to <code class="literal">DoModal</code> with 1 and 0 as the return code; 1 is interpreted as <code class="literal">true</code> and 0 as <code class="literal">false</code>.</p><pre class="programlisting">      void OnReturn(); &#13;
      void OnEscape(); &#13;
</pre><p>The <code class="literal">OnControlInit</code> method is intended to be overridden by subclasses and is called when the dialog is being initialized (when it receives the <code class="literal">WM_INITDIALOG</code> message).</p><pre class="programlisting">      virtual void OnDialogInit() {/* Empty. */} &#13;
</pre><p>The <code class="literal">TryClose</code> method is intended to be overridden by subclasses and its default behavior is to return <code class="literal">true</code>. The <code class="literal">OnClose</code> method is called when the user tries to close the dialog, and its default behavior is to call <code class="literal">TryClose</code> and close the dialog if it returns <code class="literal">true</code>, in which case <code class="literal">OnDestroy</code> is also called:</p><pre class="programlisting">      virtual bool TryClose() const {return true;} &#13;
      virtual void OnClose(); &#13;
      virtual void OnDestroy() {/* Empty. */} &#13;
</pre><p>Each control is assigned an identity number when added to the dialog, which is mapped to a pointer to the control in <code class="literal">idMap</code>:</p><pre class="programlisting">      map&lt;WORD,Control*&gt; IdMap() const {return idMap;} &#13;
      map&lt;WORD,Control*&gt;&amp; IdMap() {return idMap;} &#13;
 &#13;
    private: &#13;
      map&lt;WORD,Control*&gt; idMap; &#13;
</pre><p>The dialog has a header text, top-left position, font, regular style, and extended style, which are stored by the constructor and used by <code class="literal">DoModal</code> in the <code class="literal">DialogBoxIndirectParam</code> call. However, the size of the dialog is not a constructor parameter; instead, the size is based on the control dimensions:</p><pre class="programlisting">      String header; &#13;
      Point topLeft; &#13;
      Font font; &#13;
      WindowStyle style; &#13;
      WindowStyle extendedStyle; &#13;
</pre><p>The <code class="literal">leftMargin</code>, <code class="literal">maxWidth</code>, <code class="literal">topMargin</code>, and <code class="literal">maxHeight</code> fields are used when calculating the size of the dialog. The idea is that its size will be adjusted so that the left and right margins as well as the top and bottom margins for the closest control are equal:</p><pre class="programlisting">      int leftMargin, maxWidth, topMargin, maxHeight; &#13;
</pre><p>The first control is not assigned the identity number of 0, since it will cause confusion when handling messages if the control with identity 0 is a push button. Instead, we initialize <code class="literal">currentId</code> with 1000, and decrease its value with each new control. It is necessary to decrease the value in order for the <em>
<strong>Tab</strong>
</em> key to work correctly in the dialog:</p><pre class="programlisting">      int currentId = 1000; &#13;
</pre><p>When the dialog is initialized (by receiving the <code class="literal">WM_INITDIALOG</code> message), its size is stored in <code class="literal">originalClientSize</code> to be used by <code class="literal">OnSize</code> when calculating the size of the controls:</p><pre class="programlisting">      Size originalClientSize; &#13;
</pre><p>The <code class="literal">DialogProc</code> method is called every time the dialog receives a message. Unlike <code class="literal">WindowProc</code>, it will return <code class="literal">TRUE</code> if the message has been handled and does not need further processing. Moreover, it will not call <code class="literal">DefWindowProc</code> at the end; instead it will return <code class="literal">FALSE</code> if the message has not been handled:</p><pre class="programlisting">      friend INT_PTR CALLBACK &#13;
        DialogProc(HWND windowHandle, UINT message, &#13;
                   WPARAM wordParam, LPARAM longParam); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Dialog.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  map&lt;HWND,Dialog*&gt; dialogMap; &#13;
</pre><p>The default dialog font is set to 12-point Times New Roman.</p><pre class="programlisting">  Font DialogFont(TEXT("Times New Roman"), 12); &#13;
</pre><p>The constructor calls the <code class="literal">Window</code> constructor, which sets the parent window pointer and does nothing else. That is, it does not call the Win32 API function <code class="literal">CreateWindowEx</code>. The <code class="literal">header</code>, <code class="literal">topLeft</code>, <code class="literal">style</code>, <code class="literal">extendedStyle</code>, and <code class="literal">font</code> fields are stored to be used by <code class="literal">DoModal</code>:</p><pre class="programlisting">  Dialog::Dialog(String header, Point topLeft, &#13;
                 Window* parentPtr /*=nullptr*/, &#13;
                 WindowStyle style /* = OverlappedWindow */, &#13;
                 WindowStyle extendedStyle /* = NoStyle */, &#13;
                 Font font /* = DialogFont */) &#13;
   :Window(parentPtr), &#13;
    header(header), &#13;
    topLeft(topLeft), &#13;
    style(style), &#13;
    extendedStyle(extendedStyle), &#13;
&#13;
    font(font) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The <code class="literal">DoModal</code> function makes the dialog enter the modal state. That is, its parent window becomes disabled until the dialog is destroyed. But, it first loads information to <code class="literal">infoList</code>. The <code class="literal">AddValue</code> method is a template method of the <code class="literal">InfoList</code> class and adds values of different types to the list:</p><pre class="programlisting">  bool Dialog::DoModal() { &#13;
    InfoList infoList; &#13;
</pre><p>First, we need to add the value <code class="literal">1</code> in order to set the version of the dialog template we want to work with:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(1); &#13;
</pre><p>The <code class="literal">0xFFFF</code> value indicates that we want to work with the extended dialog template:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(0xFFFF); &#13;
</pre><p>The next word is intended for a help identity; however, we do not use it so we just set it to 0:</p><pre class="programlisting">    infoList.AddValue&lt;DWORD&gt;(0); &#13;
</pre><p>Then comes the extended and regular style. Besides the style sent to the constructor, we set the dialog to have a caption, a system menu, a modal frame, and a font. Due to the <code class="literal">DS_SETFONT</code> flag, we will later add information about the dialog font:</p><pre class="programlisting">    infoList.AddValue&lt;DWORD&gt;(extendedStyle); &#13;
    infoList.AddValue&lt;DWORD&gt;(style | WS_CAPTION | WS_SYSMENU | &#13;
                             DS_MODALFRAME | DS_SETFONT); &#13;
</pre><p>The next value is the number of controls in the dialog, which is given by the size of <code class="literal">idMap</code>:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(idMap.size()); &#13;
</pre><p>The top-left position is given by the <code class="literal">topLeft</code> field:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(topLeft.X()); &#13;
    infoList.AddValue&lt;WORD&gt;(topLeft.Y()); &#13;
</pre><p>The size of the client area of the dialog is set by <code class="literal">maxWidth</code>, <code class="literal">leftMargin</code>, <code class="literal">maxHeight</code>, and <code class="literal">topMargin</code>, which has been calculated in <code class="literal">AddControl</code>. The width of the client area is the maximum width of the control set plus its left margin. In this way, we adjust the dialog to hold the controls with equal left and right margins as well as top and bottom margins to the closest control:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(maxWidth + leftMargin); &#13;
    infoList.AddValue&lt;WORD&gt;(maxHeight + topMargin); &#13;
</pre><p>The next two zeros indicate that we do not want to use a menu and that we use the default dialog <code class="literal">Windows</code> class:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(0); &#13;
    infoList.AddValue&lt;WORD&gt;(0); &#13;
</pre><p>Then, we set the header of the dialog. The <code class="literal">AddString</code> method is an <code class="literal">InfoList</code> template method that adds the string with a terminating 0 to the information list:</p><pre class="programlisting">    infoList.AddString&lt;TCHAR&gt;(header); &#13;
</pre><p>Finally, we set the font of the dialog. We extract the <code class="literal">LOGFONT</code> structure of the <code class="literal">Font</code> class and extract its size (<code class="literal">lfHeight</code>), whether it is bold (<code class="literal">lfWeight</code>) or italics, its character set (which is 0 since we do not use it), and the font name:</p><pre class="programlisting">    LOGFONT logFont = font.LogFont(); &#13;
    infoList.AddValue&lt;WORD&gt;((WORD) logFont.lfHeight); &#13;
    infoList.AddValue&lt;WORD&gt;((WORD) logFont.lfWeight); &#13;
    infoList.AddValue&lt;BYTE&gt;(logFont.lfItalic); &#13;
    infoList.AddValue&lt;BYTE&gt;(logFont.lfCharSet); &#13;
    infoList.AddString&lt;TCHAR&gt;(logFont.lfFaceName); &#13;
</pre><p>When the dialog information has been added to the information list, we call <code class="literal">AddControlInfo</code> for each control in order for the control information to be added to the list:</p><pre class="programlisting">    for (pair&lt;WORD,Control*&gt; entry : idMap) { &#13;
      Control* controlPtr = entry.second; &#13;
      controlPtr-&gt;AddControlInfo(infoList); &#13;
    } &#13;
</pre><p>When the list has been fully loaded, we allocate a global buffer and load it with the list. The <code class="literal">ToBuffer</code> method copies the list into the buffer:</p><pre class="programlisting">    HGLOBAL globalHandle = ::GlobalAlloc(0, infoList.Size()); &#13;
    if (globalHandle != nullptr) { &#13;
      char* buffer = (char*) ::GlobalLock(globalHandle); &#13;
 &#13;
      if (buffer != nullptr) { &#13;
        infoList.ToBuffer(buffer); &#13;
</pre><p>We need the handle to the parent window, if present, and then we create the dialog by calling the Win32 API function <code class="literal">DialogBoxIndirectParam</code>, which will not return until the user closes the dialog. The last parameter is a pointer to the <code class="literal">Dialog</code> object that will be sent with the <code class="literal">WM_INITDIALOG</code> message. The return value stored in <code class="literal">result</code> is the second parameter to an <code class="literal">EndDialog</code> call:</p><pre class="programlisting">        HWND parentHandle = (parentPtr != nullptr) ? &#13;
                            parentPtr-&gt;WindowHandle() : nullptr; &#13;
        INT_PTR result = &#13;
          ::DialogBoxIndirectParam(Application::InstanceHandle(), &#13;
                     (DLGTEMPLATE*) buffer, parentHandle, &#13;
                     DialogProc, (LPARAM) this); &#13;
        ::GlobalUnlock(globalHandle); &#13;
</pre><p>We return <code class="literal">true</code> if the result value does not equal 0:</p><pre class="programlisting">        return (result != 0); &#13;
      } &#13;
    } &#13;
</pre><p>If the global buffer allocation does not succeed, we return <code class="literal">false</code>:</p><pre class="programlisting">    return false;    &#13;
  } &#13;
</pre><p>The destructor iterates through <code class="literal">idMap</code> and deletes each control of the dialog:</p><pre class="programlisting">  Dialog::~Dialog() { &#13;
    for (pair&lt;WORD,Control*&gt; entry : idMap) { &#13;
      Control* controlPtr = entry.second; &#13;
      delete controlPtr; &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">AddControl</code> method adds a control to the dialog. If it is the first control to be added (<code class="literal">idMap</code> is empty), <code class="literal">leftMargin</code> and <code class="literal">topMargin</code> are set to the top-left corner of the control, and <code class="literal">maxWidth</code> and <code class="literal">maxHeight</code> are set to the top-left corner plus the control width or height. However, if it is not, the first control we need to compare is its top-left corner and size, with the current values, in order to find the margins and maximum size of the control set:</p><pre class="programlisting">  int Dialog::AddControl(Control* controlPtr) { &#13;
    Point topLeft = controlPtr-&gt;TopLeft(); &#13;
    Size controlSize = controlPtr-&gt;GetSize(); &#13;
 &#13;
&#13;
&#13;
    if (idMap.empty()) { &#13;
      leftMargin = topLeft.X(); &#13;
      topMargin = topLeft.X(); &#13;
      maxWidth = topLeft.X() + controlSize.Width(); &#13;
      maxHeight = topLeft.Y() + controlSize.Height(); &#13;
    } &#13;
    else { &#13;
      leftMargin = min(leftMargin, topLeft.X()); &#13;
      topMargin = min(topMargin, topLeft.Y()); &#13;
      maxWidth = max(maxWidth, topLeft.X() + controlSize.Width()); &#13;
      maxHeight = max(maxHeight,topLeft.Y()+controlSize.Height()); &#13;
    } &#13;
</pre><p>The identity number of the control is set to <code class="literal">currentId</code>, which is returned and decreased:</p><pre class="programlisting">    idMap[currentId] = controlPtr; &#13;
    return currentId--; &#13;
  } &#13;
</pre><p>The <code class="literal">OnSize</code> method compares the new size of the client area with its original size. The ratio between them is stored in <code class="literal">factorPair</code>:</p><pre class="programlisting">  void Dialog::OnSize(Size newClientSize) { &#13;
    pair&lt;double, double&gt; factorPair &#13;
      (((double) newClientSize.Width() / &#13;
       originalClientSize.Width()), &#13;
       ((double) newClientSize.Height() / &#13;
       originalClientSize.Height())); &#13;
</pre><p>The controls of <code class="literal">idMap</code> are iterated and the original size of each control is multiplied with <code class="literal">factorPair</code>, the ratio between the new and original client area size. In this way, the control will keep their sizes relative to the size of the dialog client area when the user changes the dialog size.</p><pre class="programlisting">    for (pair&lt;WORD,Control*&gt; entry : idMap) { &#13;
      Control* controlPtr = entry.second; &#13;
      Rect originalRect = controlPtr-&gt;OriginalRect(); &#13;
      controlPtr-&gt;SetWindowDeviceRect(factorPair * originalRect); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">OnReturn</code> method is called when the user presses the <em>
<strong>Return</strong>
</em> key, <code class="literal">OnEscape</code> is called when they press the <em>
<strong>Esc</strong>
</em> key, and <code class="literal">OnClose</code> is called when they close the dialog. The default behavior is to call <code class="literal">TryClose</code> and, if it returns <code class="literal">true</code>, call the Win32 API function <code class="literal">EndDialog</code>, which causes the <code class="literal">DialogBoxIndirectParam</code> call in <code class="literal">DoModal</code> to return the integer value given as the second parameter to <code class="literal">EndDialog</code>:</p><pre class="programlisting">  void Dialog::OnReturn() { &#13;
    if (TryClose()) { &#13;
      ::EndDialog(windowHandle, 1); &#13;
    } &#13;
  } &#13;
 &#13;
  void Dialog::OnEscape() { &#13;
    if (TryClose()) { &#13;
      ::EndDialog(windowHandle, 0); &#13;
    } &#13;
  } &#13;
 &#13;
  void Dialog::OnClose() { &#13;
    if (TryClose()) { &#13;
      ::EndDialog(windowHandle, 0); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">DialogProc</code> method is called each time the dialog receives a message. The first parameter is a handle to the dialog, which is mapped to a <code class="literal">Dialog</code> pointer by <code class="literal">dialogMap</code>:</p><pre class="programlisting">  INT_PTR CALLBACK DialogProc(HWND dialogHandle, UINT message, &#13;
                              WPARAM wordParam, LPARAM longParam){ &#13;
    switch (message) { &#13;
</pre><p>The <code class="literal">WM_INITDIALOG</code> case is called when the dialog is created, but before it becomes visible. When the dialog was created by the <code class="literal">DialogBoxIndirectParam</code> method, the last parameter was a pointer to the encapsulating <code class="literal">Dialog</code> object. That pointer is given in the <code class="literal">longParam</code> parameter, it is translated into a pointer to <code class="literal">Dialog</code>, and added to <code class="literal">dialogMap</code>:</p><pre class="programlisting">      case WM_INITDIALOG: { &#13;
          Dialog* dialogPtr = (Dialog*) longParam; &#13;
          dialogMap[dialogHandle] = dialogPtr; &#13;
</pre><p>The Win32 API window handle of the dialog is assigned to <code class="literal">dialogHandle</code>, the original size of the client area is calculated and stored in <code class="literal">originalClientSize</code>, and <code class="literal">OnDialogInit</code> is called:</p><pre class="programlisting">          dialogPtr-&gt;WindowHandle() = dialogHandle; &#13;
          dialogPtr-&gt;originalClientSize = &#13;
            dialogPtr-&gt;GetClientDeviceSize(); &#13;
          dialogPtr-&gt;OnDialogInit(); &#13;
</pre><p>For each control in the dialog, its window handle is set by calling the Win32 API function <code class="literal">GetDlgItem</code>, which takes the dialog window handle and the control identity number, set by <code class="literal">AddControl</code>. Similar to the original client size of the dialog, the original size and position of the controls are also stored. Finally, <code class="literal">OnControlInit</code> is called for each control:</p><pre class="programlisting">          for (pair&lt;WORD,Control*&gt; entry : dialogPtr-&gt;IdMap()) { &#13;
            WORD controlId = entry.first; &#13;
            Control* controlPtr = entry.second; &#13;
            controlPtr-&gt;WindowHandle() = &#13;
              ::GetDlgItem(dialogHandle,controlId); &#13;
            controlPtr-&gt;OriginalRect() = &#13;
              controlPtr-&gt;GetWindowDeviceRect(); &#13;
            controlPtr-&gt;OnControlInit(dialogPtr); &#13;
          } &#13;
        }  &#13;
</pre><p>Since the message is handled, <code class="literal">TRUE</code> is returned:</p><pre class="programlisting">        return TRUE; &#13;
</pre><p>The <code class="literal">WM_SIZE</code> case is sent to the dialog each time its size has been changed. The width and height are stored in the lower and upper word of the <code class="literal">longParam</code> parameter. The <code class="literal">OnSize</code> method is called in order to handle the message:</p><pre class="programlisting">      case WM_SIZE: { &#13;
          Dialog* dialogPtr = dialogMap[dialogHandle]; &#13;
          assert(dialogPtr != nullptr); &#13;
          Size clientSize = &#13;
            {LOWORD(longParam), HIWORD(longParam)}; &#13;
          dialogPtr-&gt;OnSize(clientSize); &#13;
        } &#13;
        return TRUE; &#13;
</pre><p>The <code class="literal">WM_CLOSE</code> case is called when the user tries to close the dialog. The <code class="literal">OnClose</code> method is called to handle the message, which may or may not close the dialog:</p><pre class="programlisting">      case WM_CLOSE: { &#13;
          Dialog* dialogPtr = dialogMap[dialogHandle]; &#13;
          assert(dialogPtr != nullptr); &#13;
          dialogPtr-&gt;OnClose(); &#13;
        } &#13;
        return TRUE; &#13;
</pre><p>The <code class="literal">WM_DESTROY</code> case is called when the dialog is being destroyed. Unlike <code class="literal">WM_CLOSE</code>, there is no way to prevent the dialog from being destroyed. Since <code class="literal">WM_DESTROY</code> is the last message sent to the dialog, the dialog is removed from <code class="literal">dialogMap</code>:</p><pre class="programlisting">      case WM_DESTROY: { &#13;
          Dialog* dialogPtr = dialogMap[dialogHandle]; &#13;
          dialogPtr-&gt;OnDestroy(); &#13;
          dialogMap.erase(dialogHandle); &#13;
        } &#13;
        return TRUE; &#13;
</pre><p>The <code class="literal">WM_COMMAND</code> case is sent to the dialog when the user has performed some action with one of the controls. In cases where the action involves a control, its identity number is stored in the lower word of <code class="literal">wordParam</code>:</p><pre class="programlisting">      case WM_COMMAND: { &#13;
          Dialog* dialogPtr = dialogMap[dialogHandle]; &#13;
          WORD controlId = LOWORD(wordParam); &#13;
</pre><p>If the identity number is <code class="literal">IDOK</code> or <code class="literal">IDCANCEL</code>, the user has pressed the <em>
<strong>Return</strong>
</em> or <em>
<strong>Esc</strong>
</em> key:</p><pre class="programlisting">          switch (controlId) { &#13;
            case IDOK: &#13;
              dialogPtr-&gt;OnReturn(); &#13;
              break; &#13;
 &#13;
            case IDCANCEL: &#13;
              dialogPtr-&gt;OnEscape(); &#13;
              break; &#13;
</pre><p>If the identity number is not <code class="literal">IDOK</code> or <code class="literal">IDCANCEL</code>, we look up the control with <code class="literal">idMap</code> and the notification code in the higher word of <code class="literal">wordParam</code>. The notification code may have the same value as <code class="literal">IDOK</code> or <code class="literal">IDCANCEL</code>, which is why we use this somewhat cumbersome construction to handle the code:</p><pre class="programlisting">            default: { &#13;
                Control* controlPtr = &#13;
                  dialogPtr-&gt;IdMap()[controlId]; &#13;
                WORD notificationCode = HIWORD(wordParam); &#13;
</pre><p>When a control gains or loses input focus, <code class="literal">OnGainFocus</code> or <code class="literal">OnLoseFocus</code> is called; when they change the input text of a text field, <code class="literal">OnChange</code> is called; when they change the selection of a combo box, list box, or multiple list box, <code class="literal">OnSelect</code> is called; and when they click on a push button, checkbox, or radio button, <code class="literal">OnClick</code> is called:</p><pre class="programlisting">                switch (notificationCode) { &#13;
                  case EN_SETFOCUS: &#13;
                    controlPtr-&gt;OnGainFocus(dialogPtr); &#13;
                    break;  &#13;
 &#13;
&#13;
                  case EN_KILLFOCUS: &#13;
                    controlPtr-&gt;OnLoseFocus(dialogPtr); &#13;
                    break;  &#13;
 &#13;
                  case EN_CHANGE: &#13;
                    controlPtr-&gt;OnChange(dialogPtr); &#13;
                    break;  &#13;
 &#13;
                  case CBN_SELCHANGE: &#13;
                    controlPtr-&gt;OnSelect(dialogPtr); &#13;
                    break;  &#13;
 &#13;
                  case BN_CLICKED: &#13;
                    controlPtr-&gt;OnClick(dialogPtr); &#13;
                    break;  &#13;
                } &#13;
              } &#13;
          } &#13;
        } &#13;
</pre><p>When the command message has been handled, there is no need to further process it. Therefore, we return <code class="literal">true</code>:</p><pre class="programlisting">        return TRUE; &#13;
    } &#13;
</pre><p>If the message has not been handled, we returns <code class="literal">false</code> in order for the message to be further processed by the Windows system:</p><pre class="programlisting">    return FALSE; &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec75"/>Controls</h1></div></div></div><p>Here is the Small Windows control hierarchy:</p><p>
</p><div><img src="img/B05475_14_01.jpg" alt="Controls"/></div><p>
</p><p>
<strong>Control.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Dialog; &#13;
</pre><p>The constructor sends the parent window pointer to the <code class="literal">Window</code> constructer and stores the other values until it is added to the dialog information list by <code class="literal">AddControlInfo</code>:</p><pre class="programlisting">  class Control : public Window { &#13;
    public: &#13;
      Control(Dialog* parentPtr, Point topLeft, Size controlSize, &#13;
              String className, String text, int style); &#13;
      void AddControlInfo(InfoList&amp; infoList) const; &#13;
 &#13;
      Point TopLeft() const {return topLeft;} &#13;
      Size GetSize() const {return controlSize;} &#13;
</pre><p>The following methods are intended to be overridden by subclasses and are by default empty:</p><pre class="programlisting">      virtual void OnControlInit(Dialog* dialogPtr) {/* Empty. */} &#13;
      virtual void OnGainFocus(Dialog* dialogPtr) {/* Empty. */} &#13;
      virtual void OnLoseFocus(Dialog* dialogPtr) {/* Empty. */} &#13;
      virtual void OnChange(Dialog* dialogPtr) {/* Empty. */} &#13;
      virtual void OnSelect(Dialog* dialogPtr)  {/* Empty. */} &#13;
      virtual void OnClick(Dialog* dialogPtr) {/* Empty. */} &#13;
</pre><p>The rectangle holding the original size and position is set by <code class="literal">Dialog</code> when it receives the <code class="literal">MW_INITDIALOG</code> message:</p><pre class="programlisting">      Rect OriginalRect() const {return originalRect;} &#13;
      Rect&amp; OriginalRect() {return originalRect;} &#13;
 &#13;
    private: &#13;
      Rect originalRect; &#13;
</pre><p>Each control has an identity number, given by <code class="literal">AddControl</code> in <code class="literal">Dialog</code>. It has a regular style; the extended style is always 0. The style, top-left corner and control size, class name, and control text are added to the information list when <code class="literal">DoModal</code> in <code class="literal">Dialog</code> calls <code class="literal">AddControlInfo</code>:</p><pre class="programlisting">      int controlId, style; &#13;
      Point topLeft; &#13;
      Size controlSize; &#13;
      String className; &#13;
      String text; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Control.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
</pre><p>The constructor calls <code class="literal">AddControl</code> for its parent dialog to add the control to the dialog and to receive the control's identity number:</p><pre class="programlisting">namespace SmallWindows { &#13;
  Control::Control(Dialog* parentPtr, Point topLeft, &#13;
                   Size controlSize, String className, &#13;
                   String text, int style) &#13;
   :Window(parentPtr), &#13;
    topLeft(topLeft), &#13;
    controlSize(controlSize), &#13;
    className(className), &#13;
    text(text), &#13;
    style(style) { &#13;
    controlId = parentPtr-&gt;AddControl(this); &#13;
  } &#13;
</pre><p>The <code class="literal">AddControlInfo</code> method, which is called by <code class="literal">DoModal</code> in <code class="literal">Dialog</code>, adds the information of the control. First, we need to align the information list with the size of a double word (4 bytes):</p><pre class="programlisting">  void Control::AddControlInfo(InfoList&amp; infoList) const { &#13;
    infoList.Align&lt;DWORD&gt;(); &#13;
</pre><p>The help identity and extended style are always 0:</p><pre class="programlisting">    infoList.AddValue&lt;DWORD&gt;(0); &#13;
    infoList.AddValue&lt;DWORD&gt;(0); &#13;
</pre><p>The style is extended with the child and visible flags, indicating that the control is a child window of the dialog and that it becomes visible when the dialog becomes visible:</p><pre class="programlisting">    infoList.AddValue&lt;DWORD&gt;(WS_CHILD | WS_VISIBLE | style); &#13;
</pre><p>The top-left corner and size of the control are given in <strong>dialog </strong>
<strong>units</strong>, which are based on the dialog font and are translated into device units:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(topLeft.X()); &#13;
    infoList.AddValue&lt;WORD&gt;(topLeft.Y()); &#13;
    infoList.AddValue&lt;WORD&gt;(controlSize.Width()); &#13;
    infoList.AddValue&lt;WORD&gt;(controlSize.Height()); &#13;
</pre><p>The control identity number is given in order to identify the control when the user performs some action, such as clicking on a button or selecting a list item:</p><pre class="programlisting">    infoList.AddValue&lt;DWORD&gt;(controlId); &#13;
</pre><p>Each control has a class name, which is button, list, combo, static (label), or edit (text field), and text, which is the text of a text field or the label of a box or button, but is ignored for list and combo boxes:</p><pre class="programlisting">    infoList.AddString&lt;TCHAR&gt;(className); &#13;
    infoList.AddString&lt;TCHAR&gt;(text); &#13;
</pre><p>Finally, it is possible to send extra data with the control. However, we pass on that opportunity and just send 0:</p><pre class="programlisting">    infoList.AddValue&lt;WORD&gt;(0); &#13;
  } &#13;
}; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch14lvl2sec121"/>The button controls</h2></div></div></div><p>There are four kinds of button controls: group box, push button, checkbox, and radio button. The checkbox and radio button can be checked; the <code class="literal">Check</code> and <code class="literal">IsChecked</code> methods are defined in <code class="literal">ButtonControl</code>.</p><p>
<strong>ButtonControl.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
 &#13;
  class ButtonControl : public Control { &#13;
    public: &#13;
      ButtonControl(Dialog* parentPtr, Point topLeft, &#13;
                    Size controlSize, String text, int style); &#13;
 &#13;
    protected: &#13;
      void Check(bool check) const; &#13;
      bool IsChecked() const; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>ButtonControl.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  ButtonControl::ButtonControl(Dialog* parentPtr, Point topLeft, &#13;
                       Size controlSize, String text, int style) &#13;
   :Control(parentPtr, topLeft, controlSize, &#13;
            TEXT("button"), text, style) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>We send the <code class="literal">BM_SETCHECK</code> message to a check, a checkbox, or a radio button and the <code class="literal">BM_GETCHECK</code> message to find out whether it is checked:</p><pre class="programlisting">  void ButtonControl::Check(bool check) const { &#13;
    ::SendMessage(windowHandle, BM_SETCHECK, check ? 1 : 0, 0); &#13;
  } &#13;
 &#13;
  bool ButtonControl::IsChecked() const { &#13;
    return (::SendMessage(windowHandle, BM_GETCHECK, 0, 0) != 0); &#13;
  } &#13;
}; &#13;
</pre><p>A group box is quite simple; it encapsulates a set of other controls and has no functionality besides its graphical appearance.</p><p>
<strong>GroupBox.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class GroupBox : public ButtonControl { &#13;
    public: &#13;
      GroupBox(Dialog* parentPtr, Point topLeft, &#13;
               Size controlSize, String text); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>GroupBox.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  GroupBox::GroupBox(Dialog* parentPtr, Point topLeft, &#13;
                     Size controlSize, String text) &#13;
   :ButtonControl(parentPtr, topLeft, controlSize, &#13;
                  text, BS_GROUPBOX) { &#13;
    // Empty. &#13;
  } &#13;
}; &#13;
</pre><p>The <code class="literal">clickListener</code> constructor parameter is a listener called when the user clicks on the button. The <code class="literal">OnClick</code> method is overridden from <code class="literal">Control</code>.</p><p>
<strong>PushButton.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class PushButton : public ButtonControl { &#13;
    public: &#13;
      PushButton(Dialog* parentPtr, Point topLeft, &#13;
                 Size controlSize, String text, &#13;
                 VoidListener clickListener, &#13;
                 bool default = false); &#13;
      void OnClick(Dialog* dialogPtr); &#13;
 &#13;
    private: &#13;
      VoidListener clickListener; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>PushButton.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  PushButton::PushButton(Dialog* parentPtr, Point topLeft, &#13;
                         Size controlSize, String text, &#13;
                         VoidListener clickListener, &#13;
                         bool default /* = false */) &#13;
   :ButtonControl(parentPtr, topLeft, controlSize, text, &#13;
                  WS_BORDER | WS_GROUP| WS_TABSTOP | &#13;
                  (default ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON)), &#13;
    clickListener(clickListener) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  void PushButton::OnClick(Dialog* dialogPtr) { &#13;
    clickListener(dialogPtr); &#13;
  } &#13;
}; &#13;
</pre><p>A checkbox works independently of other checkboxes. The <code class="literal">checkPtr</code> parameter is a pointer to a <code class="literal">Boolean</code> value set to <code class="literal">true</code> or <code class="literal">false</code>, depending on whether the checkbox is checked.</p><p>
<strong>CheckBox.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class CheckBox : public ButtonControl { &#13;
    public: &#13;
      CheckBox(Dialog* parentPtr, Point topLeft, &#13;
               Size controlSize, String text, bool* checkPtr); &#13;
 &#13;
    private: &#13;
      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnClick(Dialog* dialogPtr); &#13;
      bool* checkPtr; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>CheckBox.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  CheckBox::CheckBox(Dialog* parentPtr, Point topLeft, &#13;
                 Size controlSize, String text, bool* checkPtr) &#13;
&#13;
   :ButtonControl(parentPtr, topLeft, controlSize, text, &#13;
                  BS_AUTOCHECKBOX | WS_GROUP | WS_TABSTOP), &#13;
    checkPtr(checkPtr) { &#13;
  } &#13;
</pre><p>The <code class="literal">OnControlInit</code> method is overridden from <code class="literal">Control</code> and checks the box in accordance with the value that <code class="literal">checkPtr</code> points at. <code class="literal">OnClick</code> is also overridden from <code class="literal">Control</code> and sets the value to <code class="literal">true</code> if the box is checked:</p><pre class="programlisting">  void CheckBox::OnControlInit(Dialog* dialogPtr) { &#13;
    Check(*checkPtr); &#13;
  } &#13;
 &#13;
  void CheckBox::OnClick(Dialog* dialogPtr) { &#13;
    *checkPtr = IsChecked(); &#13;
  } &#13;
}; &#13;
</pre><p>A radio button is intended to work in a group with other radio buttons, with exactly one button checked at the time. When the user checks one button in the group, it gets checked and the previously checked box get unchecked. Each radio button in the group has a zero-based index; <code class="literal">indexPtr</code> points to an integer value, common to all radio buttons in the group, which is set to the index of the button currently checked.</p><p>
<strong>RadioButton.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class RadioButton : public ButtonControl { &#13;
    public: &#13;
      RadioButton(Dialog* parentPtr, Point topLeft, Size size, &#13;
                  String text, int* indexPtr, int index); &#13;
      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnClick(Dialog* dialogPtr); &#13;
 &#13;
    private: &#13;
      int *indexPtr, index; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>RadioButton.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
</pre><p>The constructor sends the group and tab stop styles to the <code class="literal">Control</code> constructor if the index is 0, since the first button is the first button in the group. All buttons in the group will not be accessed by the <em>
<strong>Tab</strong>
</em> key, but only the first button. The <code class="literal">group</code> style indicates that the button starts a group and all additional radio buttons are considered members of the group, until another button with the <code class="literal">group</code> style is added:</p><pre class="programlisting">namespace SmallWindows { &#13;
  RadioButton::RadioButton(Dialog* parentPtr, Point topLeft, &#13;
                           Size size, String text, int* indexPtr, &#13;
                           int index) &#13;
   :ButtonControl(parentPtr, topLeft, size, text, &#13;
                  BS_AUTORADIOBUTTON | &#13;
                  ((index == 0) ? (WS_GROUP | WS_TABSTOP) : 0)), &#13;
    indexPtr(indexPtr), &#13;
    index(index) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The radio button is checked if it has the same index as the value that <code class="literal">indexPtr</code> points at, and the value is set to the index of the button that is checked:</p><pre class="programlisting">  void RadioButton::OnControlInit(Dialog* dialogPtr) { &#13;
    Check((*indexPtr) == index); &#13;
  } &#13;
 &#13;
  void RadioButton::OnClick(Dialog* dialogPtr) { &#13;
    *indexPtr = index; &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec122"/>List controls</h2></div></div></div><p>There are two kinds of list box: single list box and multiple list box. The single list box selects exactly one item at a time, and the multiple list box selects one or several (or none at all) items at the same time. The constructor takes a string list that is loaded to the list box by <code class="literal">LoadList</code>.</p><p>
<strong>ListControl.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class ListControl : public Control { &#13;
    public: &#13;
      ListControl(Dialog* parentPtr, Point topLeft, &#13;
                  Size controlSize, int style, &#13;
                  list&lt;String&gt; textList); &#13;
 &#13;
    protected: &#13;
      void LoadList() const; &#13;
 &#13;
&#13;
    private: &#13;
      list&lt;String&gt; textList; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>ListControl.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  ListControl::ListControl(Dialog* parentPtr, Point topLeft, &#13;
                           Size controlSize, int style, &#13;
                           list&lt;String&gt; textList) &#13;
   :Control(parentPtr, topLeft, controlSize, &#13;
            TEXT("listbox"), TEXT(""), style), &#13;
    textList(textList) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The <code class="literal">LoadList</code> method adds the item text in <code class="literal">textList</code> to the (single or multiple) list box by calling the <code class="literal">LB_ADDSTRING</code> message:</p><pre class="programlisting">  void ListControl::LoadList() const { &#13;
    for (String text : textList) { &#13;
      ::SendMessage(windowHandle, LB_ADDSTRING, &#13;
                    0, (LPARAM) text.c_str()); &#13;
    } &#13;
  } &#13;
}; &#13;
</pre><p>A (single) list box is a box holding a list of visible items, as opposed to a combo box where the items are dropped down. If necessary, the list can be scrolled. Only one item can be selected at a time, as opposed to the multiple list. Similar to the radio box group, the constructor takes the <code class="literal">indexPtr</code> pointer pointing at an integer value holding the zero-based index of the currently selected item. Moreover, the constructor also takes a string list that is loaded into the list box by <code class="literal">LoadList</code> in <code class="literal">ListControl</code>.</p><p>
<strong>ListBox.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class ListBox : public ListControl { &#13;
    public: &#13;
      ListBox(Dialog* parentPtr, Point topLeft, Size controlSize, &#13;
              initializer_list&lt;String&gt; textList, int* indexPtr); &#13;
      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnSelect(Dialog* dialogPtr); &#13;
 &#13;
    private: &#13;
      void SelectList(int index) const; &#13;
      int GetListSelection() const; &#13;
      int* indexPtr; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>ListBox.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  ListBox::ListBox(Dialog* parentPtr, Point topLeft, &#13;
             Size controlSize, initializer_list&lt;String&gt;  textList, &#13;
             int* indexPtr) &#13;
   :ListControl(parentPtr, topLeft, controlSize, WS_VSCROLL | &#13;
                WS_BORDER | LBS_NOTIFY | WS_GROUP | WS_TABSTOP, &#13;
                textList), &#13;
    indexPtr(indexPtr) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  void ListBox::OnControlInit(Dialog* dialogPtr) { &#13;
    LoadList(); &#13;
    SelectList(*indexPtr); &#13;
  } &#13;
 &#13;
  void ListBox::OnSelect(Dialog* dialogPtr) { &#13;
    *indexPtr = GetListSelection(); &#13;
  } &#13;
</pre><p>We send the <code class="literal">LB_SETCURSEL</code> message to select an item and <code class="literal">LB_GETCURSEL</code> to get the index of the currently selected item:</p><pre class="programlisting">  void ListBox::SelectList(int index) const { &#13;
    ::SendMessage(windowHandle, LB_SETCURSEL, index, 0); &#13;
  } &#13;
 &#13;
  int ListBox::GetListSelection() const { &#13;
    return ::SendMessage(windowHandle, LB_GETCURSEL, 0, 0); &#13;
  } &#13;
}; &#13;
</pre><p>A multiple list box is a list box where the user can select more than one value, or no value at all; therefore, the <code class="literal">indexSetPtr</code> parameter is a pointer to a set of indexes rather than a pointer to one index.</p><p>
<strong>MultipleListBox.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class MultipleListBox : public ListControl { &#13;
    public: &#13;
      MultipleListBox(Dialog* parentPtr, Point topLeft, &#13;
              Size controlSize, initializer_list&lt;String&gt; textList, &#13;
              set&lt;int&gt;* indexSetPtr); &#13;
      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnSelect(Dialog* dialogPtr); &#13;
 &#13;
    private: &#13;
      void SelectMultiple(set&lt;int&gt;&amp; indexSet) const; &#13;
      set&lt;int&gt; GetSelectionMultiple() const; &#13;
      set&lt;int&gt;* indexSetPtr; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>MultipleListBox.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  MultipleListBox::MultipleListBox(Dialog* parentPtr, &#13;
              Point topLeft, Size controlSize, &#13;
              initializer_list&lt;String&gt; textList, &#13;
              set&lt;int&gt;* indexSetPtr) &#13;
   :ListControl(parentPtr, topLeft, controlSize, LBS_MULTIPLESEL | &#13;
                WS_VSCROLL | WS_BORDER | LBS_NOTIFY | WS_GROUP | &#13;
                WS_TABSTOP, textList), &#13;
    indexSetPtr(indexSetPtr) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  void MultipleListBox::OnControlInit(Dialog* dialogPtr) { &#13;
    LoadList(); &#13;
    SelectMultiple(*indexSetPtr); &#13;
  } &#13;
 &#13;
  void MultipleListBox::OnSelect(Dialog* dialogPtr) { &#13;
    *indexSetPtr = GetSelectionMultiple(); &#13;
  } &#13;
</pre><p>When the user selects 0 or several values in the multiple list, we iterate through the indexes and send the <code class="literal">LB_SETSEL</code> message for each index with a <code class="literal">Boolean</code> value indicating whether its item will be set:</p><pre class="programlisting">  void MultipleListBox::SelectMultiple(set&lt;int&gt;&amp; indexSet) const { &#13;
    int size = ::SendMessage(windowHandle, LB_GETCOUNT, 0, 0); &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      BOOL selected = (indexSet.count(index) &gt; 0) ? TRUE : FALSE; &#13;
      ::SendMessage(windowHandle, LB_SETSEL, selected, index); &#13;
    } &#13;
  } &#13;
</pre><p>When checking which values are currently selected, we send the <code class="literal">LB_GETSEL</code> message for each index and add the indexes of the selected items to the set, which is then returned:</p><pre class="programlisting">  set&lt;int&gt; MultipleListBox::GetSelectionMultiple() const { &#13;
    int size = ::SendMessage(windowHandle, LB_GETCOUNT, 0, 0); &#13;
 &#13;
    set&lt;int&gt; indexSet; &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (::SendMessage(windowHandle, LB_GETSEL, index, 0) != 0) { &#13;
        indexSet.insert(index); &#13;
      } &#13;
    } &#13;
 &#13;
    return indexSet; &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec123"/>Combo box</h2></div></div></div><p>A combo box is a drop-down list of items, from which the user can select one. The functionality of a combo box is equal to a list box, only their graphical appearance differs. Moreover, the functionality is also equivalent to a radio button group. Similar to <code class="literal">ListBox</code> and <code class="literal">Radiobutton</code>, the constructor takes the <code class="literal">indexPtr</code> parameter, which is a pointer to an integer value, holding the zero-based index of the item currently selected.</p><p>
<strong>ComboBox.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class ComboBox : public Control { &#13;
    public: &#13;
      ComboBox(Dialog* parentPtr, Point topLeft, Size controlSize, &#13;
               initializer_list&lt;String&gt; textList, int* indexPtr); &#13;
      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnSelect(Dialog* dialogPtr); &#13;
 &#13;
&#13;
&#13;
&#13;
    private: &#13;
      void LoadCombo() const; &#13;
      void SelectCombo(int index) const; &#13;
      int GetComboSelection() const; &#13;
      list&lt;String&gt; textList; &#13;
      int* indexPtr; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>ComboBox.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  ComboBox::ComboBox(Dialog* parentPtr, Point topLeft, &#13;
            Size controlSize, initializer_list&lt;String&gt; textList, &#13;
            int* indexPtr) &#13;
   :Control(parentPtr, topLeft, controlSize, TEXT("combobox"), &#13;
            TEXT(""), CBS_DROPDOWN | CBS_HASSTRINGS | LBS_NOTIFY | &#13;
            LBS_COMBOBOX | WS_GROUP | WS_TABSTOP), &#13;
    textList(textList), &#13;
    indexPtr(indexPtr) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  void ComboBox::OnControlInit(Dialog* dialogPtr) { &#13;
    LoadCombo(); &#13;
    SelectCombo(*indexPtr); &#13;
  } &#13;
 &#13;
  void ComboBox::OnSelect(Dialog* dialogPtr) { &#13;
    *indexPtr = GetComboSelection(); &#13;
  } &#13;
</pre><p>The <code class="literal">CB_ADDSTRING</code> message loads the combo box with items, <code class="literal">CB_SETCURSEL</code> sets the selected item, and <code class="literal">CB_GETCURSEL</code> returns the index of the selected item:</p><pre class="programlisting">  void ComboBox::LoadCombo() const { &#13;
    for (String text : textList) { &#13;
      ::SendMessage(windowHandle, CB_ADDSTRING, &#13;
                    0, (LPARAM) text.c_str()); &#13;
    } &#13;
  } &#13;
 &#13;
  void ComboBox::SelectCombo(int index) const { &#13;
    ::SendMessage(windowHandle, CB_SETCURSEL, index, 0); &#13;
  } &#13;
 &#13;
  int ComboBox::GetComboSelection() const { &#13;
    return ::SendMessage(windowHandle, CB_GETCURSEL, 0, 0); &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec124"/>Label</h2></div></div></div><p>A label is a displayed text that often serves as a prompt to a text field; it has no functionality besides its graphical appearance.</p><p>
<strong>Label.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Label : public Control { &#13;
    public: &#13;
      Label(Dialog* parentPtr, Point topLeft, &#13;
            Size controlSize, String text); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Label.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  Label::Label(Dialog* parentPtr, Point topLeft, &#13;
               Size controlSize, String text) &#13;
   :Control(parentPtr, topLeft, controlSize, &#13;
            TEXT("static"), text, 0) { &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec125"/>The TextField class</h2></div></div></div><p>The <code class="literal">TextField</code> class is a template for a text field; it takes the type of the value stored in the text field; an integer base for octal, decimal, or hexadecimal integers (ignored for non-integer types); and a converter of the <code class="literal">Converter</code> class in the next section, which converts between values and text. The constructor's <code class="literal">valuePtr</code> parameter is a pointer to the value to be edited in the text field.</p><p>
<strong>TextField.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  enum EditStyle {LeftEdit = ES_LEFT, CenterEdit = ES_CENTER, &#13;
                  RightEdit = ES_RIGHT, DigitsOnly = ES_NUMBER, &#13;
                  ReadOnly = ES_READONLY, Password = ES_PASSWORD, &#13;
                  Uppercase = ES_UPPERCASE,Lowercase=ES_LOWERCASE, &#13;
                  AutoScroll = ES_AUTOHSCROLL}; &#13;
 &#13;
  enum {oct = 8, dec = 10, hex = 16}; &#13;
 &#13;
  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  class TextField : public Control { &#13;
    public: &#13;
      TextField(Dialog* parentPtr, Point topLeft, &#13;
                Size controlSize, Type* valuePtr, &#13;
                int size = 100, EditStyle style = AutoScroll); &#13;
</pre><p>The <code class="literal">OnControlInit</code> method is called when the text field has been created. It converts the value to the text displayed in the text field. The <code class="literal">OnLoseFocus</code> method is called when the user leaves the text field and converts its text to a value of the template type if the text is valid. If it is not valid, the text field is set to the text converted from the latest valid value:</p><pre class="programlisting">      void OnControlInit(Dialog* dialogPtr); &#13;
      void OnLoseFocus(Dialog* dialogPtr); &#13;
 &#13;
    protected: &#13;
      String GetText() const; &#13;
      void SetText(String text); &#13;
 &#13;
    private: &#13;
      Type* valuePtr; &#13;
  }; &#13;
 &#13;
  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  TextField&lt;Type,Base,TheConverter&gt;::TextField &#13;
    (Dialog* parentPtr, Point topLeft, Size controlSize, &#13;
     Type* valuePtr, int size /* = 100 */, &#13;
     EditStyle style /* = AutoScroll */) &#13;
   :Control(parentPtr, topLeft, controlSize, TEXT("edit"), &#13;
            TEXT(""), style | WS_BORDER | WS_GROUP | WS_TABSTOP), &#13;
    valuePtr(valuePtr) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The Win32 API function <code class="literal">GetWindowText</code> gets the text of the text field and <code class="literal">SetWindowText</code> sets its text. We need to convert from a zero-terminated character pointer string to a <code class="literal">String</code> object by calling the <code class="literal">String</code> constructor, and from a <code class="literal">String</code> object to a zero-terminated character pointer by calling the <code class="literal">c_str</code> method of the <code class="literal">String</code> class:</p><pre class="programlisting">  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  String TextField&lt;Type,Base,TheConverter&gt;::GetText() const { &#13;
    TCHAR buffer[MAX_PATH]; &#13;
    ::GetWindowText(windowHandle, buffer, MAX_PATH); &#13;
    return String(buffer); &#13;
  } &#13;
 &#13;
  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  void TextField&lt;Type,Base,TheConverter&gt;::SetText(String text) { &#13;
    ::SetWindowText(windowHandle, text.c_str()); &#13;
  } &#13;
</pre><p>When the text field has been initialized, the <code class="literal">ValueToText</code> method of the <code class="literal">Converter</code> class is called to convert the value pointed to by <code class="literal">valuePtr</code> to the text displayed in the text field:</p><pre class="programlisting">  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  void TextField&lt;Type,Base,TheConverter&gt;::OnControlInit &#13;
                                          (Dialog* dialogPtr) { &#13;
    SetText(TheConverter::ValueToText(*valuePtr, Base)); &#13;
  } &#13;
</pre><p>When the text field loses input focus, the text is evaluated by the <code class="literal">Check</code> method in order to decide whether it is suitable to be converted to a value. If it is suitable, the <code class="literal">ValueToText</code> method is called to do the actual converting, and then the text is loaded to the text field:</p><pre class="programlisting">  template &lt;class Type = String, int Base = dec, &#13;
            class TheConverter = Converter&lt;Type&gt;&gt; &#13;
  void TextField&lt;Type,Base,TheConverter&gt;::OnLoseFocus &#13;
                                          (Dialog* dialogPtr) { &#13;
    String text = GetText(); &#13;
 &#13;
    if (TheConverter::Check(text, Base)) { &#13;
      *valuePtr = TheConverter::TextToValue(text, Base); &#13;
    } &#13;
 &#13;
    SetText(TheConverter::ValueToText(*valuePtr, Base)); &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec76"/>Converters</h1></div></div></div><p>The <code class="literal">Converter</code> class is a template class intended to be specialized by type. Its task is to convert values between the template type and the <code class="literal">String</code> objects. The <code class="literal">Check</code> variable takes a string and returns <code class="literal">true</code> if it holds a valid value, <code class="literal">TextToValue</code> converts a text to a value, and <code class="literal">ValueToText</code> converts a value to a text.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  template &lt;class Type&gt; &#13;
  class Converter { &#13;
    public: &#13;
      static bool Check(String&amp; text, int base); &#13;
      static Type TextToValue(String&amp; text, int base); &#13;
      static String ValueToText(Type&amp; value, int base); &#13;
  }; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch14lvl2sec126"/>Signed integers</h2></div></div></div><p>Small Windows comes equipped with a set of predefined converters, which are specializations of <code class="literal">Converter</code>. One of these handles signed integer values of the type <code class="literal">int</code>.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;int&gt; { &#13;
    public: &#13;
      static bool Check(String&amp; text, int base); &#13;
      static int TextToValue(String&amp; text, int base); &#13;
      static String ValueToText(int&amp; value, int base); &#13;
  }; &#13;
</pre><p>
<strong>Converter.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>When checking whether the given string holds a valid integer value, we create an <code class="literal">IStringStream</code> object (the generic version of the Standard C++ class <code class="literal">istringstream</code>, with <code class="literal">TCHAR</code> instead of <code class="literal">char</code>) initialized with the trimmed text (initial and terminating white spaces are removed). Then, we read the text into an integer variable with the base parameter and test whether the stream has reached end-of-file (<code class="literal">eof</code>). If it has, all characters of the text have been read, which implies that the text holds a valid integer value and <code class="literal">true</code> is returned:</p><pre class="programlisting">namespace SmallWindows { &#13;
  bool Converter&lt;int&gt;::Check(String&amp; text, int base) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    int value; &#13;
    stringStream &gt;&gt; setbase(base) &gt;&gt; value; &#13;
    return stringStream.eof(); &#13;
  } &#13;
</pre><p>The conversion from a string to an integer is similar to <code class="literal">Check</code>, which we covered earlier, with the difference that we return the integer value assuming that <code class="literal">Check</code> has confirmed that the text holds a valid integer value:</p><pre class="programlisting">  int Converter&lt;int&gt;::TextToValue(String&amp; text, int base) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    int value; &#13;
    stringStream &gt;&gt; setbase(base) &gt;&gt; value; &#13;
    return value; &#13;
  } &#13;
</pre><p>When converting an integer to a string, we use the <code class="literal">OStringStream</code> method (the generic version of <code class="literal">ostringstream</code>), write the value to the stream, and return the stream converted to a string by <code class="literal">str</code>:</p><pre class="programlisting">  String Converter&lt;int&gt;::ValueToText(int&amp; value, int base) { &#13;
    OStringStream outputStream; &#13;
    outputStream &lt;&lt; setbase(base) &lt;&lt; value; &#13;
    return outputStream.str(); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec127"/>Unsigned integers</h2></div></div></div><p>Unsigned integers work in the same way as signed integers, the only difference is that <code class="literal">int</code> has been replaced by <code class="literal">unsigned</code>
<code class="literal">int</code>:</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;unsigned int&gt; { &#13;
    public: &#13;
      static bool Check(String&amp; text, int base); &#13;
      static unsigned int TextToValue(String&amp; text, int base); &#13;
      static String ValueToText(unsigned int&amp; value, int base); &#13;
  }; &#13;
</pre><p>
<strong>Converter.cpp</strong>
</p><pre class="programlisting">  bool Converter&lt;unsigned int&gt;::Check(String&amp; text, int base) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    unsigned int value; &#13;
    stringStream &gt;&gt; setbase(base) &gt;&gt; value; &#13;
    return stringStream.eof() &amp;&amp; (text.find(TEXT("-")) == -1); &#13;
  } &#13;
  unsigned int Converter&lt;unsigned int&gt;::TextToValue(String&amp; text, &#13;
                                                     int base){ &#13;
    IStringStream stringStream(Trim(text)); &#13;
    unsigned int value; &#13;
    stringStream &gt;&gt; setbase(base) &gt;&gt; value; &#13;
    return value; &#13;
  } &#13;
  String Converter&lt;unsigned int&gt;::ValueToText(unsigned int&amp;value, &#13;
                                               int base){ &#13;
    OStringStream outputStream; &#13;
    outputStream &lt;&lt; setbase(base) &lt;&lt; value; &#13;
    return outputStream.str(); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec128"/>Double values</h2></div></div></div><p>Double values ignore the base parameter and do not use the <code class="literal">setbase</code> manipulator; otherwise, the test and conversions work in the same way as in integer cases.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;double&gt; { &#13;
    public: &#13;
      static bool Check(String&amp; text, int /* base */); &#13;
      static double TextToValue(String&amp; text, int /* base */); &#13;
      static String ValueToText(double&amp; value, int /* base */); &#13;
  }; &#13;
</pre><p>
<strong>Converter.cpp</strong>
</p><pre class="programlisting">  bool Converter&lt;double&gt;::Check(String&amp; text, int /* base */) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    double value; &#13;
    stringStream &gt;&gt; value; &#13;
    return stringStream.eof(); &#13;
  } &#13;
&#13;
  double Converter&lt;double&gt;::TextToValue(String&amp; text, &#13;
                                         int /* base */) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    double value; &#13;
    stringStream &gt;&gt; value; &#13;
    return value; &#13;
  } &#13;
  String Converter&lt;double&gt;::ValueToText(double&amp; value, &#13;
                                         int /* base */) { &#13;
    OStringStream outputStream; &#13;
    outputStream &lt;&lt; value; &#13;
    return outputStream.str(); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec129"/>Strings</h2></div></div></div><p>The string case is trivial, since a string can always be converted to another string.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;String&gt; { &#13;
    public: &#13;
      static bool Check(String&amp; text, int /* base */) &#13;
                       {return true;} &#13;
      static String TextToValue(String&amp; text, int /* base */) &#13;
                               {return String(text);} &#13;
      static String ValueToText(String&amp; value, int /* base */) &#13;
                               {return String(value);} &#13;
  }; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec130"/>Rational numbers</h2></div></div></div><p>A <strong>rational </strong>
<strong>number</strong> is a number that can be expressed as a fraction of two integers, where the second integer is non-zero. We do not really use rational numbers in this section or complex numbers in the next section, in our applications. They are included only to demonstrate the converter, and they are implemented in the Appendix at the end of the book.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;Rational&gt; { &#13;
&#13;
    public: &#13;
      static bool Check(String&amp; text, int /* base */); &#13;
      static Rational TextToValue(String&amp; text, int /* base */); &#13;
      static String ValueToText(Rational&amp; value, int /* base */); &#13;
  }; &#13;
</pre><p>When checking whether the text holds a valid rational number, we simply create an object of the <code class="literal">Rational</code> class. If the constructor accepts the text without throwing a <code class="literal">NotaRationalNumber</code> exception, we return <code class="literal">true</code>. If it throws the exception, the text is not acceptable and we return <code class="literal">false</code>.</p><p>
<strong>Converter.cpp</strong>
</p><pre class="programlisting">  bool Converter&lt;Rational&gt;::Check(String&amp; text, int /* base */) { &#13;
    try { &#13;
      Rational value(text); &#13;
      return true; &#13;
    } &#13;
    catch (NotaRationalNumber) { &#13;
      return false; &#13;
    } &#13;
  } &#13;
</pre><p>When converting a string to a rational number, we create and return a <code class="literal">Rational</code> object, assuming that <code class="literal">Check</code> has confirmed that the text holds a valid rational number:</p><pre class="programlisting">  Rational Converter&lt;Rational&gt;::TextToValue(String&amp; text, &#13;
                                             int /* base */) { &#13;
    return Rational(text); &#13;
  } &#13;
</pre><p>When converting a rational number to a string we call the <code class="literal">String</code> conversion operator of the <code class="literal">Rational</code> class.</p><pre class="programlisting">  String Converter&lt;Rational&gt;::ValueToText(Rational&amp; value, &#13;
                                           int /* base */) { &#13;
    return ((String) value); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec131"/>Complex numbers</h2></div></div></div><p>A complex number is the sum <em>z = x + yi</em> of a real number <em>x</em> and a real number <em>y</em> multiplied by the <strong>imaginary </strong>
<strong>unit</strong>
<em>i</em>, which is the solution of the equation <em>x</em>
<sup>2</sup> + 1 = 0. The specialization of <code class="literal">Converter</code> with regard to the <code class="literal">Complex</code> class is similar to the <code class="literal">Rational</code> specialization.</p><p>
<strong>Converter.h</strong>
</p><pre class="programlisting">  template &lt;&gt; &#13;
  class Converter&lt;Complex&gt; { &#13;
    public: &#13;
      static bool Check(String&amp; text, int /* base */); &#13;
      static Complex TextToValue(String&amp; text, int /* base */); &#13;
      static String ValueToText(Complex&amp; value, int /* base */); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Converter.cpp</strong>
</p><pre class="programlisting">  bool Converter&lt;Complex&gt;::Check(String&amp; text, int /* base */) { &#13;
    try { &#13;
      Complex value(text); &#13;
      return true; &#13;
    } &#13;
    catch (NotaComplexNumber) { &#13;
      return false; &#13;
    } &#13;
  } &#13;
 &#13;
  Complex Converter&lt;Complex&gt;::TextToValue(String&amp; text, &#13;
                                           int /* base */) { &#13;
    return Complex(text); &#13;
  } &#13;
 &#13;
  String Converter&lt;Complex&gt;::ValueToText(Complex&amp; value, &#13;
                                          int /* base */) { &#13;
    return ((String) value); &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec77"/>Page setup</h1></div></div></div><p>The final section describes page setup functionality, divided into the <code class="literal">PageSetupInfo</code> class, which handles page setup information, the <code class="literal">PageSetupDialog</code>, which is a subclass of <code class="literal">Dialog</code> displayed for the user to input page setup information, and the <code class="literal">Template</code> function, which translates code input by the user in the <strong>Page Setup</strong> dialog to actual values.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec132"/>Page setup information</h2></div></div></div><p>The <code class="literal">PageSetupInfo</code> class holds information about the page: portrait or landscape orientation, the margins, the text and font of the header and footer, whether the header and footer will be present on the first page, and whether the pages will be enclosed by a frame.</p><p>
<strong>PageSetupInfo.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  enum Orientation {Portrait, Landscape}; &#13;
 &#13;
  class PageSetupInfo { &#13;
    public: &#13;
      PageSetupInfo(); &#13;
      PageSetupInfo(const PageSetupInfo&amp; pageSetupInfo); &#13;
      bool operator==(const PageSetupInfo&amp; pageSetupInfo); &#13;
      bool operator!=(const PageSetupInfo&amp; pageSetupInfo); &#13;
 &#13;
      void ClearPageSetupInfo(); &#13;
      bool WritePageSetupInfoToStream(ostream&amp; outStream) const; &#13;
      bool ReadPageSetupInfoFromStream(istream&amp; inStream); &#13;
 &#13;
      Orientation&amp; GetOrientation() {return orientation;} &#13;
      int&amp; LeftMargin() {return leftMargin;} &#13;
      int&amp; TopMargin() {return topMargin;} &#13;
      int&amp; RightMargin() {return rightMargin;} &#13;
      int&amp; BottomMargin() {return bottomMargin;} &#13;
      String&amp; HeaderText() {return headerText;} &#13;
      String&amp; FooterText() {return footerText;} &#13;
      bool&amp; HeaderFirst() {return headerFirst;} &#13;
      bool&amp; FooterFirst() {return footerFirst;} &#13;
      bool&amp; Frame() {return frame;} &#13;
      Font&amp; HeaderFont() {return headerFont;} &#13;
      Font&amp; FooterFont() {return footerFont;} &#13;
 &#13;
      Orientation GetOrientation() const {return orientation;} &#13;
      int LeftMargin() const {return leftMargin;} &#13;
      int TopMargin() const {return topMargin;} &#13;
      int RightMargin() const {return rightMargin;} &#13;
      int BottomMargin() const {return bottomMargin;} &#13;
      String HeaderText() const {return headerText;} &#13;
      String FooterText() const {return footerText;} &#13;
      bool HeaderFirst() const {return headerFirst;} &#13;
      bool FooterFirst() const {return footerFirst;} &#13;
      bool Frame() const {return frame;} &#13;
      Font HeaderFont() const {return headerFont;} &#13;
      Font FooterFont() const {return footerFont;} &#13;
 &#13;
    private: &#13;
      Orientation orientation; &#13;
      int leftMargin, topMargin, rightMargin, bottomMargin; &#13;
      String headerText, footerText; &#13;
      bool headerFirst, footerFirst, frame; &#13;
      Font headerFont, footerFont; &#13;
 }; &#13;
}; &#13;
</pre><p>
<strong>PageSetupInfo.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
</pre><p>The default constructor initializes the default member values by calling <code class="literal">PageSetupInfo</code>.</p><pre class="programlisting">namespace SmallWindows { &#13;
  PageSetupInfo::PageSetupInfo() { &#13;
    ClearPageSetupInfo(); &#13;
  } &#13;
</pre><p>The default constructor and assignment operator copy the member values.</p><pre class="programlisting">  PageSetupInfo::PageSetupInfo(const PageSetupInfo&amp; pageSetupInfo) &#13;
   :orientation(pageSetupInfo.orientation), &#13;
    leftMargin(pageSetupInfo.leftMargin), &#13;
    topMargin(pageSetupInfo.topMargin), &#13;
    rightMargin(pageSetupInfo.rightMargin), &#13;
    bottomMargin(pageSetupInfo.bottomMargin), &#13;
    headerText(pageSetupInfo.headerText), &#13;
    footerText(pageSetupInfo.footerText), &#13;
    headerFirst(pageSetupInfo.headerFirst), &#13;
    footerFirst(pageSetupInfo.footerFirst), &#13;
    frame(pageSetupInfo.frame), &#13;
    headerFont(pageSetupInfo.headerFont), &#13;
    footerFont(pageSetupInfo.footerFont) { &#13;
     // Empty. &#13;
  } &#13;
</pre><p>The equality operators compare all the fields:</p><pre class="programlisting">  bool PageSetupInfo::operator== &#13;
         (const PageSetupInfo&amp; pageSetupInfo) { &#13;
    return (orientation == pageSetupInfo.orientation) &amp;&amp; &#13;
           (leftMargin == pageSetupInfo.leftMargin) &amp;&amp; &#13;
           (topMargin == pageSetupInfo.topMargin) &amp;&amp; &#13;
           (rightMargin == pageSetupInfo.rightMargin) &amp;&amp; &#13;
           (bottomMargin == pageSetupInfo.bottomMargin) &amp;&amp; &#13;
           (headerText == pageSetupInfo.headerText) &amp;&amp; &#13;
           (footerText == pageSetupInfo.footerText) &amp;&amp; &#13;
           (headerFirst == pageSetupInfo.headerFirst) &amp;&amp; &#13;
           (footerFirst == pageSetupInfo.footerFirst) &amp;&amp; &#13;
           (frame == pageSetupInfo.frame) &amp;&amp; &#13;
           (headerFont == pageSetupInfo.headerFont) &amp;&amp; &#13;
           (footerFont == pageSetupInfo.footerFont); &#13;
  } &#13;
 &#13;
  bool PageSetupInfo::operator!= &#13;
         (const PageSetupInfo&amp; pageSetupInfo) { &#13;
    return !(*this == pageSetupInfo); &#13;
  } &#13;
  void PageSetupInfo::ClearPageSetupInfo() { &#13;
    orientation = Portrait; &#13;
    leftMargin = 25; &#13;
    topMargin = 25; &#13;
    rightMargin = 25; &#13;
    bottomMargin = 25; &#13;
    headerText = TEXT(""); &#13;
    footerText = TEXT(""); &#13;
    headerFirst = true; &#13;
    footerFirst = true; &#13;
    frame = true; &#13;
    headerFont = Font(TEXT("Times New Roman"), 12, false, true); &#13;
    footerFont = Font(TEXT("Times New Roman"), 12, false); &#13;
  } &#13;
</pre><p>Page setup information can be written to, or read from, a stream:</p><pre class="programlisting">  bool PageSetupInfo::WritePageSetupInfoToStream &#13;
                      (ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;orientation, sizeof orientation); &#13;
    outStream.write((char*) &amp;leftMargin, sizeof leftMargin); &#13;
    outStream.write((char*) &amp;topMargin, sizeof topMargin); &#13;
    outStream.write((char*) &amp;rightMargin, sizeof rightMargin); &#13;
    outStream.write((char*) &amp;bottomMargin, sizeof bottomMargin); &#13;
    WriteStringToStream(headerText, outStream); &#13;
    WriteStringToStream(footerText, outStream); &#13;
    outStream.write((char*) &amp;headerFirst, sizeof headerFirst); &#13;
    outStream.write((char*) &amp;footerFirst, sizeof footerFirst); &#13;
    outStream.write((char*) &amp;frame, sizeof frame); &#13;
    headerFont.WriteFontToStream(outStream); &#13;
    footerFont.WriteFontToStream(outStream); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool PageSetupInfo::ReadPageSetupInfoFromStream &#13;
                      (istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;orientation, sizeof orientation); &#13;
    inStream.read((char*) &amp;leftMargin, sizeof leftMargin); &#13;
    inStream.read((char*) &amp;topMargin, sizeof topMargin); &#13;
    inStream.read((char*) &amp;rightMargin, sizeof rightMargin); &#13;
    inStream.read((char*) &amp;bottomMargin, sizeof bottomMargin); &#13;
    ReadStringFromStream(headerText, inStream); &#13;
    ReadStringFromStream(footerText, inStream); &#13;
    inStream.read((char*) &amp;headerFirst, sizeof headerFirst); &#13;
    inStream.read((char*) &amp;footerFirst, sizeof footerFirst); &#13;
    inStream.read((char*) &amp;frame, sizeof frame); &#13;
    headerFont.ReadFontFromStream(inStream); &#13;
    footerFont.ReadFontFromStream(inStream); &#13;
    return ((bool) inStream); &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec133"/>The Page Setup dialog</h2></div></div></div><p>The <code class="literal">PageSetupDialog</code> class is a part of Small Windows and is displayed by the <code class="literal">StandardDocument</code> framework when the user selects the <strong>Page Setup</strong> menu item. The word processor earlier in this book gives an example. The <code class="literal">PageSetupDialog</code> class is a subclass of <code class="literal">Dialog</code> and provides the user with the possibility to input the information in <code class="literal">PageSetupInfo</code>. Note that the header and footer text can be annotated with blocks of code, explained in the next section.</p><p>
</p><div><img src="img/B05475_14_02.jpg" alt="The Page Setup dialog"/></div><p>
</p><p>
<strong>PageSetupDialog.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class PageSetupDialog : public Dialog { &#13;
    public: &#13;
      PageSetupDialog(Window* parentPtr, PageSetupInfo* infoPtr); &#13;
</pre><p>Each push button has its own listener:</p><pre class="programlisting">      DEFINE_VOID_LISTENER(PageSetupDialog, OnHeaderFont); &#13;
      DEFINE_VOID_LISTENER(PageSetupDialog, OnFooterFont);       &#13;
      DEFINE_VOID_LISTENER(PageSetupDialog, OnOk); &#13;
      DEFINE_VOID_LISTENER(PageSetupDialog, OnCancel); &#13;
</pre><p>The page setup information is pointed at by <code class="literal">infoPtr</code>, which is modified when the user changes the state of the controls. There is also <code class="literal">backupInfo</code>, in case the user cancels the dialog:</p><pre class="programlisting">    private: &#13;
      PageSetupInfo *infoPtr, backupInfo; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>PageSetupDialog.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>The constructor sets the pointer <code class="literal">infoPtr</code> to point at the page setup information. The information is also stored in <code class="literal">backupInfo</code>, which will be used if the user cancels the dialog; refer to <code class="literal">OnCancel</code>:</p><pre class="programlisting">namespace SmallWindows { &#13;
  PageSetupDialog::PageSetupDialog(Window* parentPtr, &#13;
                                   PageSetupInfo* infoPtr) &#13;
   :Dialog(TEXT("Page Setup"), Point(0, 0), parentPtr), &#13;
    infoPtr(infoPtr), &#13;
    backupInfo(*infoPtr) { &#13;
</pre><p>Each control gives the <strong>Page Setup</strong> dialog (<code class="literal">this</code>) as its parent dialog, which means that the controls will be deleted by the dialog's destructor. This implies that we do need to keep track of the controls in order to delete them manually. Actually, we will not delete them manually as it would result in dangling pointers:</p><pre class="programlisting">    new GroupBox(this, Point(10, 10), &#13;
                 Size(330, 50), TEXT("Margins")); &#13;
    new Label(this, Point(20, 20), Size(50, 10), &#13;
              TEXT("&amp;Top Margin:")); &#13;
</pre><p>Note that we give a pointer as a reference for the value of the top margin. This value will be modified when the user changes the value:</p><pre class="programlisting">    new TextField&lt;int&gt;(this, Point(70, 20), Size(100, 12), &#13;
                       &amp;infoPtr-&gt;TopMargin()); &#13;
    new Label(this, Point(180, 20), Size(50, 10), &#13;
              TEXT("&amp;Bottom Margin:")); &#13;
    new TextField&lt;int&gt;(this, Point(230, 20), Size(100, 12), &#13;
                       &amp;infoPtr-&gt;BottomMargin()); &#13;
    new Label(this, Point(20, 40), Size(50, 10), &#13;
              TEXT("&amp;Left Margin:")); &#13;
    new TextField&lt;int&gt;(this, Point(70, 40), Size(100, 12), &#13;
                       &amp;infoPtr-&gt;LeftMargin()); &#13;
    new Label(this, Point(180, 40), Size(50, 10), &#13;
              TEXT("&amp;Right Margin:")); &#13;
    new TextField&lt;int&gt;(this, Point(230, 40), Size(100, 12), &#13;
                       &amp;infoPtr-&gt;RightMargin()); &#13;
 &#13;
    new GroupBox(this, Point(10, 70), &#13;
                 Size(330, 50), TEXT("Header")); &#13;
    new Label(this, Point(20, 80), Size(50, 10), &#13;
              TEXT("&amp;Header Text:")); &#13;
    new TextField&lt;&gt;(this, Point(70, 80), Size(260, 12), &#13;
                    &amp;infoPtr-&gt;HeaderText()); &#13;
</pre><p>Similar to the <code class="literal">TextField</code> case, we give a pointer to a reference of the <code class="literal">HeaderFirst</code> value, which is a <code class="literal">Boolean</code> value. It will be modified when the user checks the box:</p><pre class="programlisting">    new CheckBox(this, Point(70, 100), Size(100, 10), &#13;
                 TEXT("H&amp;eader at First Page"), &#13;
                 &amp;infoPtr-&gt;HeaderFirst()); &#13;
</pre><p>The <code class="literal">OnHeaderFont</code> listener is called when the user presses the button:</p><pre class="programlisting">    new PushButton(this, Point(270, 98), Size(60, 15), &#13;
                   TEXT("He&amp;ader Font"), OnHeaderFont); &#13;
 &#13;
    new GroupBox(this, Point(10, 130), &#13;
                 Size(330, 50), TEXT("Footer")); &#13;
    new Label(this, Point(20, 140), Size(50, 10), &#13;
              TEXT("&amp;Footer Text:")); &#13;
    new TextField&lt;&gt;(this, Point(70, 140), Size(260, 12), &#13;
                    &amp;infoPtr-&gt;FooterText()); &#13;
    new CheckBox(this, Point(70, 160), Size(100, 10), &#13;
                 TEXT("F&amp;ooter at First Page"), &#13;
                 &amp;infoPtr-&gt;FooterFirst()); &#13;
    new PushButton(this, Point(270, 158), Size(60, 15), &#13;
                   TEXT("Footer Fo&amp;nt"), OnFooterFont); &#13;
 &#13;
    new Label(this, Point(20, 190), Size(40, 10), &#13;
              TEXT("&amp;Orientation:")); &#13;
    new ComboBox(this, Point(65, 190), Size(70, 30), &#13;
                 {TEXT("Portrait"), TEXT("Landscape")}, &#13;
                 (int*) &amp;infoPtr-&gt;GetOrientation()); &#13;
    new CheckBox(this, Point(20, 205), Size(100, 10), &#13;
                 TEXT("Page &amp;Surrounded by Frame"), &#13;
                 &amp;infoPtr-&gt;Frame()); &#13;
    new PushButton(this, Point(200, 200), &#13;
                   Size(60, 15), TEXT("Ok"), OnOk); &#13;
    new PushButton(this, Point(270, 200), Size(60, 15), &#13;
                   TEXT("Cancel"), OnCancel); &#13;
  } &#13;
</pre><p>The <code class="literal">OnHeaderFont</code> and <code class="literal">OnFooterFont</code> methods display font dialogs:</p><pre class="programlisting">  void PageSetupDialog::OnHeaderFont() { &#13;
    StandardDialog::FontDialog(this, infoPtr-&gt;HeaderFont()); &#13;
  } &#13;
 &#13;
  void PageSetupDialog::OnFooterFont() { &#13;
    StandardDialog::FontDialog(this, infoPtr-&gt;FooterFont()); &#13;
  } &#13;
</pre><p>The <code class="literal">OnOk</code> and <code class="literal">OnCancel</code> methods terminate the dialog. The <code class="literal">OnCancel</code> method also copies the backup information that was stored by the constructor at the beginning, since no new information will be returned when the user cancels the dialog:</p><pre class="programlisting">  void PageSetupDialog::OnOk() { &#13;
    Dialog::OnReturn(); &#13;
  } &#13;
 &#13;
  void PageSetupDialog::OnCancel() { &#13;
    *infoPtr = backupInfo; &#13;
    Dialog::OnEscape(); &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec134"/>The Template function</h2></div></div></div><p>When the user inputs text in the header and footer fields in the <strong>Page Setup</strong> dialog, they can insert code in the text, which needs to be translated into valid values. The code is shown in the following table:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Code</strong></p>
</td><td>
<p><strong>Description</strong></p>
</td><td>
<p><strong>Example</strong></p>
</td></tr><tr><td>
<p>%P</p>
</td><td>
<p>Path with suffix</p>
</td><td>
<p>
<code class="literal">C:\Test\Test.wrd</code>
</p>
</td></tr><tr><td>
<p>%p</p>
</td><td>
<p>Path without suffix</p>
</td><td>
<p>
<code class="literal">C:\Test\Test</code>
</p>
</td></tr><tr><td>
<p>%F</p>
</td><td>
<p>File with suffix</p>
</td><td>
<p>
<code class="literal">Test.wrd</code>
</p>
</td></tr><tr><td>
<p>%f</p>
</td><td>
<p>File without suffix</p>
</td><td>
<p>Test</p>
</td></tr><tr><td>
<p>%N</p>
</td><td>
<p>Total number of pages</p>
</td><td>
<p>7</p>
</td></tr><tr><td>
<p>%n</p>
</td><td>
<p>Current page</p>
</td><td>
<p>5</p>
</td></tr><tr><td>
<p>%c</p>
</td><td>
<p>Current Copy</p>
</td><td>
<p>3</p>
</td></tr><tr><td>
<p>%D</p>
</td><td>
<p>Date with full month</p>
</td><td>
<p>January 1, 2016</p>
</td></tr><tr><td>
<p>%d</p>
</td><td>
<p>Date with abbreviated month</p>
</td><td>
<p>Jan 1, 2016</p>
</td></tr><tr><td>
<p>%T</p>
</td><td>
<p>Time with seconds</p>
</td><td>
<p>07:08:09</p>
</td></tr><tr><td>
<p>%t</p>
</td><td>
<p>Time without seconds</p>
</td><td>
<p>07:08</p>
</td></tr><tr><td>
<p>%%</p>
</td><td>
<p>Percent character</p>
</td><td>
<p>%</p>
</td></tr></tbody></table></div><p>The task of the <code class="literal">Template</code> function is to replace the code with valid values. It takes the <code class="literal">templateText</code> string with template code and returns the text with the code replaced by valid values. It needs the current copy and page number as well as the total number of pages.</p><p>For instance, the <code class="literal">Page %n out of %N</code> text can be translated to <strong>Page 3 out of 5</strong> and <code class="literal">File: %F, date: %d</code> can be translated to <strong>File: Text.txt, date: Dec 31, 2016</strong>.</p><p>
<strong>Template.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  String Template(const Document* documentPtr, String templateText, &#13;
                  int copy = 0, int page = 0, int totalPages = 0); &#13;
}; &#13;
</pre><p>
<strong>Template.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  String Template(const Document* documentPtr, String templateText, &#13;
                  int copy /* = 0 */, int page /* = 0 */, &#13;
                  int totalPages /* = 0 */) { &#13;
</pre><p>We start by replacing the <code class="literal">c</code>, <code class="literal">n</code>, and <code class="literal">N</code> code with the number of copies and the current and total pages. The numerical values are translated into strings by <code class="literal">to_String</code>:</p><pre class="programlisting">    ReplaceAll(templateText, TEXT("%c"), to_String(copy)); &#13;
    ReplaceAll(templateText, TEXT("%n"), to_String(page)); &#13;
    ReplaceAll(templateText, TEXT("%N"), to_String(totalPages)); &#13;
</pre><p>The file of the path is its text after the last backslash (<strong>\</strong>) and the suffix is its text after the last dot (<strong>.</strong>). If there is no backslash, the file is the same as the path; if there is no dot, the path and file without the suffix is the same as the file and path with the suffix:</p><pre class="programlisting">    String pathWithSuffix = documentPtr-&gt;GetName(); &#13;
    ReplaceAll(templateText, TEXT("%P"), pathWithSuffix); &#13;
 &#13;
    int lastPathDot = pathWithSuffix.find_last_of(TEXT('.')); &#13;
    String pathWithoutSuffix = &#13;
      pathWithSuffix.substr(0, lastPathDot); &#13;
    ReplaceAll(templateText, TEXT("%p"), pathWithoutSuffix); &#13;
 &#13;
    int lastBackslash = pathWithSuffix.find_last_of(TEXT('')); &#13;
    String fileWithSuffix = &#13;
      pathWithSuffix.substr(lastBackslash + 1); &#13;
    ReplaceAll(templateText, TEXT("%F"), fileWithSuffix); &#13;
 &#13;
    int lastFileDot = fileWithSuffix.find_last_of(TEXT('.')); &#13;
    String fileWithoutSuffix = &#13;
      fileWithSuffix.substr(0, lastFileDot); &#13;
    ReplaceAll(templateText, TEXT("%f"), fileWithoutSuffix); &#13;
</pre><p>The current date and time are obtained by calling the Standard C functions <code class="literal">time</code> and <code class="literal">localtime_s</code>:</p><pre class="programlisting">    time_t t = ::time(nullptr); &#13;
    struct tm time; &#13;
    ::localtime_s(&amp;time, &amp;t); &#13;
</pre><p>The current time with and without seconds and the current date with whole and abbreviated month names are written to string output streams. The <code class="literal">setw</code> manipulator makes sure that two characters are always written, <code class="literal">setfill</code> fills with zeros if necessary, and <code class="literal">ios::right</code> writes the value in a right-aligned manner:</p><pre class="programlisting">    { OStringStream timeWithoutSeconds; &#13;
      timeWithoutSeconds &lt;&lt; std::setw(2) &lt;&lt; setw(2) &#13;
                         &lt;&lt; setiosflags(ios::right)  &#13;
                         &lt;&lt; setfill(TEXT('0')) &lt;&lt; time.tm_hour &#13;
                         &lt;&lt; TEXT(":") &lt;&lt; setiosflags(ios::right) &#13;
                         &lt;&lt; setw(2) &lt;&lt; setfill(TEXT('0')) &#13;
                         &lt;&lt; time.tm_min; &#13;
 &#13;
      ReplaceAll(templateText, TEXT("%t"), &#13;
                 timeWithoutSeconds.str()); &#13;
 &#13;
      OStringStream timeWithSeconds; &#13;
      timeWithSeconds &lt;&lt; timeWithoutSeconds.str() &lt;&lt; TEXT(":") &#13;
                      &lt;&lt; setiosflags(ios::right) &lt;&lt; setw(2) &#13;
                      &lt;&lt; setfill(TEXT('0')) &lt;&lt; time.tm_sec; &#13;
      ReplaceAll(templateText, TEXT("%T"), timeWithSeconds.str()); &#13;
    } &#13;
 &#13;
    { static const String longMonths[] = &#13;
        {TEXT("January"), TEXT("February"), TEXT("March"), &#13;
         TEXT("April"), TEXT("May"), TEXT("June"), TEXT("July"), &#13;
         TEXT("August"), TEXT("September"), TEXT("October"), &#13;
         TEXT("November"), TEXT("December")}; &#13;
      OStringStream dateFullMonth; &#13;
      dateFullMonth &lt;&lt; longMonths[time.tm_mon] &lt;&lt; TEXT(" ") &#13;
                    &lt;&lt; time.tm_mday &lt;&lt; TEXT(", ") &#13;
                    &lt;&lt; (1900 + time.tm_year); &#13;
      ReplaceAll(templateText, TEXT("%D"), dateFullMonth.str()); &#13;
    } &#13;
 &#13;
    { static const String shortMonths[] = &#13;
        {TEXT("Jan"), TEXT("Feb"), TEXT("Mar"), TEXT("Apr"), &#13;
         TEXT("May"), TEXT("Jun"), TEXT("Jul"), TEXT("Aug"), &#13;
         TEXT("Sep"), TEXT("Oct"), TEXT("Nov"), TEXT("Dec")}; &#13;
      OStringStream dateShortMonth; &#13;
      dateShortMonth &lt;&lt; shortMonths[time.tm_mon] &lt;&lt; TEXT(" ") &#13;
                     &lt;&lt; time.tm_mday &lt;&lt; TEXT(", ") &#13;
                     &lt;&lt; (1900 + time.tm_year); &#13;
      ReplaceAll(templateText, TEXT("%d"), dateShortMonth.str()); &#13;
    } &#13;
</pre><p>Finally, we need to replace each instance of <code class="literal">%%</code> with <code class="literal">%</code>:</p><pre class="programlisting">    ReplaceAll(templateText, TEXT("%%"), TEXT("%")); &#13;
    return templateText; &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we looked into custom dialogs, controls, converters, and the Page Setup dialog. The only remaining part of the book is the implementation of the rational and complex classes.</p></div></body></html>