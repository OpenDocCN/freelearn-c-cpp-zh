<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Rendering Simple 3D Graphics</h1></div></div></div><p>Now that we've covered user input, 2D graphics, and sound, let's take a look at 3D graphics. Most games these days are 3D, probably because 3D graphics are cooler than 2D graphics! That's not to say that 2D graphics are bad or outdated. There are still many games made using 2D graphics, but creating a game in 3D literally adds another dimension to the game, giving the world that much more depth and making it more interesting to explore.</p><p>In this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Direct3D graphics rendering pipeline</li><li class="listitem" style="list-style-type: disc">Shaders</li><li class="listitem" style="list-style-type: disc">Rendering a triangle</li><li class="listitem" style="list-style-type: disc">Rendering a cube with texturing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>The Direct3D graphics rendering pipeline</h1></div></div></div><p>The Direct3D graphics rendering pipeline takes our geometry data and turns it into graphics on the<a id="id341" class="indexterm"/> screen. It is designed to generate graphics for real-time applications such as video games. The pipeline consists of a number of stages that our data goes through to produce the finished image for the current frame. Some of these stages are programmable, giving us a lot more power. Let's take a look at the main pipeline stages, which are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Input assembler</li><li class="listitem" style="list-style-type: disc">Vertex shader</li><li class="listitem" style="list-style-type: disc">Rasterizer</li><li class="listitem" style="list-style-type: disc">Pixel shader</li><li class="listitem" style="list-style-type: disc">Output merger</li></ul></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Input assembler</h2></div></div></div><p>The main purpose of the <strong>input assembler</strong> is to take our raw vertex data (points, lines, or triangles), and <a id="id342" class="indexterm"/>assemble them into<a id="id343" class="indexterm"/> primitives, such as <code class="literal">PrimitiveType.TriangleList</code>, which can be used by the graphics rendering pipeline. This primitive type tells Direct3D that our vertex data is arranged so that every three vertices in the list make a single triangle. All of the primitive types supported by Direct3D are defined in the <code class="literal">PrimitiveType</code> enumeration.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Vertex shader</h2></div></div></div><p>The <strong>vertex shader</strong>
<a id="id344" class="indexterm"/> stage performs<a id="id345" class="indexterm"/> per-vertex operations on vertex data outputted from the input assembler stage. These operations are things such as transformations, per-vertex lighting, morphing, and skinning.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Rasterizer</h2></div></div></div><p>The <strong>rasterizer</strong> stage takes the primitives processed in the previous stages and turns them into<a id="id346" class="indexterm"/> pixels to make a rendered image. It <a id="id347" class="indexterm"/>also performs the clipping of vertices, which means that if part of a triangle is off the screen, it will clip that part of the triangle off, so to speak, since it doesn't need to be drawn.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Pixel shader</h2></div></div></div><p>The <strong>pixel shader</strong>
<a id="id348" class="indexterm"/> stage of the graphics <a id="id349" class="indexterm"/>pipeline performs shading techniques, such as per-pixel lighting or post-processing stuff. The rasterizer invokes the pixel shader stage once for each pixel, which is covered by the current primitive that it is processing.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Output merger</h2></div></div></div><p>The <strong>output merger</strong>
<a id="id350" class="indexterm"/> generates the <a id="id351" class="indexterm"/>final pixel color using a combination of numerous things, including the current state of the graphics pipeline, the data generated by the pixel shader stage, and the contents of render targets, and depth/stencil buffers, which we'll get into a bit later in the chapter.</p><p>This was a pretty quick overview of the Direct3D graphics pipeline. There are other stages in the pipeline besides these, but we will not be using them. For a more in-depth look at <a id="id352" class="indexterm"/>the graphics pipeline, check<a id="id353" class="indexterm"/> out Microsoft's documentation: <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ff476882(v=vs.85).aspx</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Shaders</h1></div></div></div><p>As you can see above, <strong>shaders</strong> are a fairly integral part of 3D graphics programming. So what exactly is a shader? A shader is a small program that we write for one of the programmable stages of the Direct3D graphics pipeline. Two of the stages we previously looked at are<a id="id354" class="indexterm"/> programmable: the vertex shader stage and the pixel shader stage. These are not the only programmable stages in the graphics pipeline though.</p><p>Shaders have <a id="id355" class="indexterm"/>what is known as a <strong>shader signature</strong>. The signature of a shader is just a list of the input and/or output parameters of that shader.</p><p>In this chapter we will create two demos. Each will have its own shader file, named <code class="literal">Effects.fx</code>. This is just a text file containing the code for our shaders. Shaders are written in <strong>HLSL</strong> (<strong>High Level Shader Language</strong>). The downloadable code for this chapter <a id="id356" class="indexterm"/>includes the <code class="literal">Effects.fx</code> files for both demo projects (they are <em>NOT</em> the same).</p><p>For more information on shaders and HLSL, check out the HLSL programming guide on Microsoft's website at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/bb509635(v=vs.85).aspx</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Rendering a triangle</h1></div></div></div><p>In this section we will set up a basic Direct3D application and render a simple triangle on the screen. We<a id="id357" class="indexterm"/> will start by creating a new project called <code class="literal">Triangle</code>. In this project, we will first create a new class named <code class="literal">TriangleGameWindow.cs</code>. We will need to make it inherit from our <code class="literal">GameWindow</code> base class and implement <code class="literal">IDisposable</code>, of course.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>You will need to get the downloadable code for this book to complete this chapter, particularly for the second demo we will create in this chapter.</p></div></div><p>Now that we have a new game window class, the next item of business is to get Direct3D set up and ready to go. We will need to add some <code class="literal">using</code> statements to the top of the file first though. These allow us to use Direct3D in our code. The following are the new statements that we need:</p><div><pre class="programlisting">using SlimDX.D3DCompiler;
using SlimDX.Direct3D11;
using SlimDX.DirectInput;
using SlimDX.DXGI
using SlimDX;</pre></div><p>Next, we<a id="id358" class="indexterm"/> need to create our member variables. They are as follows:</p><div><pre class="programlisting">SlimDX.Direct3D11.Device m_Device;
SlimDX.Direct3D11.DeviceContext m_DeviceContext;
RenderTargetView m_RenderTargetView;
SwapChain m_SwapChain;
Viewport m_Viewport;

InputLayout m_InputLayout;

VertexShader m_VertexShader;
ShaderSignature m_VShaderSignature;
PixelShader m_PixelShader;

SlimDX.Direct3D11.Buffer m_VertexBuffer;</pre></div><p>The <code class="literal">m_Device</code> variable will hold our Direct3D device object. The <code class="literal">m_DeviceContext</code> variable is just a convenience variable that holds the device context for us. This shortens some lines of code since we don't have to access it through <code class="literal">m_Device</code>.</p><p>The <code class="literal">m_RenderTargetView</code> variable will hold our <code class="literal">RenderTargetView</code> object, which is similar to the <code class="literal">RenderTarget</code> object we worked with in <a class="link" href="ch03.html" title="Chapter 3. Rendering 2D Graphics">Chapter 3</a>, <em>Rendering 2D Graphics</em>. This is basically our Direct3D render target.</p><p>The <code class="literal">m_SwapChain</code> variable will hold our <a id="id359" class="indexterm"/>
<strong>swap chain</strong>. The swap chain is just a chain of buffers. Remember that a buffer is just an area in memory for storing data. The simplest swap chain would have two buffers, which hold the graphics that our program is drawing. Each time we draw a new frame, the buffers get swapped, so the buffer containing our new frame becomes visible on the screen. The buffer we draw into is called the <strong>back buffer</strong>
<a id="id360" class="indexterm"/> because it is behind the scenes, so the player cannot see it while we are drawing the next frame. The buffer that is currently displayed on the screen is called the <a id="id361" class="indexterm"/>
<strong>front buffer</strong>. When the buffers get swapped, the back buffer becomes the new front buffer and vice versa.</p><p>At first, this may seem like a waste of memory. Why not just draw into the buffer that is currently displayed onscreen so we can have one buffer rather than two? The reason is that doing so can cause some flickering. This is because the player could see things appear on the screen as they are being drawn. So instead, we draw into an offscreen buffer until the frame is fully drawn. Then, we swap the buffers so that the new frame appears on the screen all at once. This makes for smoother animation. This rendering technique is called <strong>double buffering</strong>
<a id="id362" class="indexterm"/>. You can add more buffers in between the back buffer and the front buffer as well. If you add one additional buffer in between them, you will be doing <strong>triple buffering</strong>, which actually provides speed improvement <a id="id363" class="indexterm"/>over double buffering.</p><p>Back to our<a id="id364" class="indexterm"/> member variables; the next one is <code class="literal">m_Viewport</code>. The view port simply specifies the area of the render target that we want to draw on. It also specifies the minimum and maximum depth values. These are normally set to <code class="literal">0.0f</code> and <code class="literal">1.0f</code> respectively.</p><p>The next member variable is <code class="literal">m_InputLayout</code>. The <code class="literal">InputLayout</code> object tells Direct3D about the vertex format and shader model we are using. Remember that, a shader is basically just a small program that is run by the video card.</p><p>The <code class="literal">m_VertexShader</code> variable will hold our vertex shader. The <code class="literal">m_VShaderSignature</code> variable holds the signature for the vertex shader. A shader signature is just a list of parameters that are inputted to or outputted from the shader. And lastly, <code class="literal">m_PixelShader</code> will hold our pixel shader. We'll get into shaders a bit later in the chapter.</p><p>If you don't fully understand all of these member variables, that's fine. They should become a little clearer once we start using them. We need to initialize Direct3D now, so let's get started.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Initializing Direct3D</h2></div></div></div><p>We are now<a id="id365" class="indexterm"/> ready to initialize Direct3D. For this task, we will create a new method named <code class="literal">InitD3D()</code>. The following is the code for this method:</p><div><pre class="programlisting">public void InitD3D()
{
    // Setup the configuration for the SwapChain.
    var swapChainDesc = new SwapChainDescription()
    {
        BufferCount = 2, // 2 back buffers (Triple Buffering)
        Usage = Usage.RenderTargetOutput,
        OutputHandle = FormObject.Handle,

        IsWindowed = true,
        ModeDescription = new ModeDescription(FormObject.Width,
          FormObject.Height,new Rational(60, 1),Format.R8G8B8A8_UNorm),
        SampleDescription = new SampleDescription(1, 0),
        Flags = SwapChainFlags.AllowModeSwitch,
        SwapEffect = SwapEffect.Discard
    };

    // Create the SwapChain

    SlimDX.Direct3D11.Device.CreateWithSwapChain(
      DriverType.Hardware,
      DeviceCreationFlags.Debug,
      new FeatureLevel[] { FeatureLevel.Level_11_0 },
      swapChainDesc,
      out m_Device,
      
out m_SwapChain);

    // create a view of our render target, which is the backbuffer of the swap chain we just created
    using (var resource =SlimDX.Direct3D11.Resource.FromSwapChain&lt;Texture2D&gt;(m_SwapChain, 0))
    {
        m_RenderTargetView = new RenderTargetView(m_Device,resource);
    }

    // Get the device context and store it in our m_DeviceContext member variable.
    m_DeviceContext = m_Device.ImmediateContext;

    // Setting a viewport is required if you want to actually see anything
    m_Viewport = new Viewport(0.0f,0.0f,m_Form.Width,m_Form.Height,0.0f,1.0f);

    m_DeviceContext.Rasterizer.SetViewports(m_Viewport);
    m_DeviceContext.OutputMerger.SetTargets(m_RenderTargetView);

    // Prevent DXGI handling of Alt+Enter since it does not work properly with Winforms
    using (var factory = m_SwapChain.GetParent&lt;Factory&gt;())
    {
        factory.SetWindowAssociation(m_Form.Handle,
             WindowAssociationFlags.IgnoreAltEnter);
    }
}</pre></div><p>As you can see, the first thing we do in this method is create <code class="literal">SwapChainDescription</code> to configure the swap chain we will create in a moment. We are using the initializer syntax here, which is a<a id="id366" class="indexterm"/> handy way for us to set the values of the struct's properties when it is created. You can use the initializer syntax for structs, arrays, and lists by opening a brace block after the line that creates the new object, and then setting the values of its properties inside the brace block.</p><p>The <code class="literal">BufferCount</code> property specifies how many buffers we want to have in our swap chain, in addition to the front buffer.  You should not use more than four buffers as you will get a performance decrease with too many. In the windowed mode, the desktop is used as the front buffer, but in the fullscreen mode, a dedicated front buffer is required in the swap chain. The <code class="literal">Usage</code> property specifies how we intend to use our swap chain surfaces. The term <strong>surface</strong> refers to a buffer that we will draw on, so the surfaces of our swap chain are just the buffers that are in it. For the <code class="literal">OutputHandle</code> property, we set this to the handle of our game window to tell it what window we will be displaying our graphics in. The <code class="literal">IsWindowed</code> property determines whether we want to start the program in windowed mode. Remember that we haven't implemented fullscreen mode yet.</p><p>Next, we have the <code class="literal">ModeDescription</code> property, which specifies the video mode we want to use. The first two parameters of the <code class="literal">ModeDescription</code> object are the height and width. In other words, they are the screen resolution we want to use. The third parameter is the refresh rate specified as a numerator and a denominator. Here, we have it set to the fraction <em>60/1</em>, which means a refresh rate of 60 times per second. And lastly, we have the format parameter. This tells it the pixel format, and as you can see, we have it set to <code class="literal">Format.R8G8B8A8_UNorm</code>. This means we have eight bits for each of the four color channels (red, green, blue, and alpha). The <code class="literal">UNorm</code> part of this format name indicates that the values of the color channels are unsigned, normalized integers (normalized meaning they are in the range <code class="literal">0.0</code>-<code class="literal">1.0</code>). An <strong>unsigned integer</strong>
<a id="id367" class="indexterm"/> is similar to a normal <code class="literal">integer</code> variable, except that it does not support negative numbers. This allows an unsigned integer to hold much larger values than you can store in a normal integer <a id="id368" class="indexterm"/>variable of the same size. The opposite of an unsigned integer is a <strong>signed integer</strong> variable, which has to use half of its possible values to represent negative numbers.</p><p>The next property we set on the <code class="literal">SwapChainDescription</code> object is the <code class="literal">SampleDescription</code> property. For this, we create a new sample description object and give it two parameters: the first parameter is the number of multisamples per pixel, and the second parameter is the quality level. The valid range for the quality level is <code class="literal">0</code> to one less than the level returned by the <code class="literal">CheckMultisampleQualityLevel()</code> method of the Direct3D device object (remember that the device is stored in our <code class="literal">m_Device</code> member variable). Of course, higher quality levels are more expensive to perform than lower ones. Here, we set the count to <code class="literal">1</code> and quality to <code class="literal">0</code>. This is the default sampler state with no anti-aliasing. Note that there are also a couple of standard values we can use to set our multisampling level, and they are defined in the <code class="literal">Direct3D11.StandardMultisamplQualityLevel</code> enumeration.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>If your PC is not able to use Direct3D 11, you can change the code in this chapter to use Direct3D 10 instead. The code should be nearly identical, since Direct3D 11 is in reality an extension of Direct3D 10, and we are not using any advanced features or new stuff that Direct3D 11 brings to the table. Just make sure you change all objects from the Direct3D 11 namespace to their counterparts in the Direct3D 10 namespace.</p><p>You may notice that there is also Direct3D 11.1. We are not using this because it is the Windows 8 version of Direct3D 11, and you can only use it on Windows 8.</p></div></div><p>So what is <strong>multisampling</strong>
<a id="id369" class="indexterm"/> and <strong>anti-aliasing</strong>? Anti-aliasing is actually <a id="id370" class="indexterm"/>an effect of multisampling, where the jagged edges of objects are smoothed, so they don't look jagged on the screen anymore. This jaggedness is caused by<a id="id371" class="indexterm"/> the fact that the pixels on the screen are not infinitely small, and thus you can sometimes see a stair-step pattern on the edges of objects on the screen. Multisampling involves looking at the colors of adjacent pixels and blending them together in some fashion so as to soften edges on the screen and remove other graphical artifacts that can be caused by aliasing, such as moiré patterns. You can look up for moiré patterns on Wikipedia: <a class="ulink" href="http://en.wikipedia.org/wiki/Moir%C3%A9_pattern">http://en.wikipedia.org/wiki/Moir%C3%A9_pattern</a>.</p><p>The next property we set on the <code class="literal">SwapChainDescription</code> object is the <code class="literal">Flags</code> property. This property lets us set various flags that affect the behavior of our swap chain. In this case, we set it to the <code class="literal">SwapChainFlags.AllowModeSwitch</code> flag, which allows us to switch the screen mode of our swap chain by calling its <code class="literal">ResizeTarget()</code> method.</p><p>And the final property we are setting on our <code class="literal">SwapChainDescription</code> object is the <code class="literal">SwapEffect</code> property. This sets options for how to handle the back buffer's contents after it has been displayed on the screen. We have set this to <code class="literal">SwapEffect.Discard</code>. And with that, we are done setting up our <code class="literal">SwapChainDescription</code> object.</p><p>We are now ready to create our swap chain and the Direct3D device. Both of these are accomplished with the next line of code, which calls a static member of the <code class="literal">SlimDX.Direct3D11.Device</code> class; that method is the <code class="literal">CreateWithSwapChain()</code> method. As you can see, there are six parameters. The first parameter specifies the driver type. In this case, we set it to <code class="literal">DriverType.Hardware</code>, since we want hardware acceleration if it is available. The second parameter is the device creation flag. In this case, we have used <code class="literal">DeviceCreationFlags.Debug</code>, which creates a Direct3D device that supports the debug layer. Of course, you would change this to something else before you release your game, since the debug code slows down the game and hurts performance.</p><p>The third parameter specifies feature levels. In this case, we have only used <code class="literal">FeatureLevel.Level_11_0</code>, which means we want the Direct3D 11 features. As this parameter is an array, you can, of course, provide more than one feature level if your program needs to support more levels.</p><p>The fourth parameter is our <code class="literal">SwapChainDescription</code> object, and the last two parameters begin with the <code class="literal">out</code> keyword. This means they are actually output from the function, or in other words, the variables we pass in are modified by the function to return data. In this case, the fifth <a id="id372" class="indexterm"/>parameter is our <code class="literal">m_Device</code> member variable, and the sixth parameter is our <code class="literal">m_SwapChain</code> variable. So this function creates the Direct3D device and stores it in the variable we passed into the fifth parameter. And it also creates the swap chain, storing it in the variable that we passed into the sixth parameter.</p><p>The next thing we need to do is create our render target. As you can see, the next piece of code is a <code class="literal">using</code> block, which creates a <code class="literal">SlimDX.Direct3D11.Resource</code> object using the <code class="literal">Resource</code> class's static method, <code class="literal">FromSwapChain()</code>. The <code class="literal">&lt;Texture2D&gt;</code> part of this line indicates that the function is <strong>generic</strong>. A generic method<a id="id373" class="indexterm"/> is one that allows you to specify a data type when you call it. In other words, it is a function that is able to act on multiple data types, whereas a normal function can't do that. In this case, we have specified the data type of <code class="literal">Direct3D11.Texture2D</code>. A <code class="literal">Texture2D</code> object represents an image. The <code class="literal">FromSwapChain()</code> method takes two parameters. The first one is the swap chain we want to create the resource from, and the second parameter is the index of one of the buffers in that swap chain.</p><p>Then, inside of this <code class="literal">using</code> statement, we have a single line of code that creates our <code class="literal">RenderTargetView</code> object. This object is essentially our render target. As you can see, we pass in two parameters when we create the <code class="literal">RenderTargetView</code> object. The first parameter is our Direct3D device, and the second parameter is the resource we just created.</p><p>The next line of code stores the Direct3D device context in our <code class="literal">m_DeviceContext</code> member variable. Remember that this variable is just for convenience. Using it allows us to shorten some of our lines of code. The device context is accessed via the Direct3D device object's <code class="literal">ImmediateContext</code> property.</p><p>Next up, we create our viewport. The <code class="literal">ViewPort</code> object specifies the area of the swap chain buffer that we want to draw onto, as well as the minimum and maximum depth values. The first two parameters we pass in when we create the <code class="literal">Viewport</code> object are the x and y position of the rectangular area we want to draw in. The third and fourth parameters are the width and height of that area. As you can see, we have specified that we want to use the entire window to draw on. The last two parameters are the minimum and maximum depth values, which are usually set to <code class="literal">0.0f</code> and <code class="literal">1.0f</code> respectively. These specify how much of the depth range to draw. Setting them to <code class="literal">0.0f</code> and <code class="literal">1.0f</code> tells it to draw the entire depth range of the scene. You could set both to <code class="literal">0.0f</code> to draw all objects to the foreground, or set both to <code class="literal">1.0f</code> to draw everything in the background.</p><p>As you can see, next up is code consisting of two lines. The first one sets the <code class="literal">Viewport</code> we just created on the <a id="id374" class="indexterm"/>
<strong>rasterizer</strong>. Remember that, the rasterizer is one of the stages in the Direct3D graphics processing pipeline. It clips primitives, prepares them for the pixel shader (another stage in the pipeline), and also determines how to call the pixel shaders for them.</p><p>The second line of code here sets our <code class="literal">RenderTargetView</code> on the output merger (remember that the output merger is a stage of the graphics pipeline).</p><p>We've finally reached the last piece of code in our <code class="literal">InitD3D()</code> method. It's another <code class="literal">using</code> block, this time<a id="id375" class="indexterm"/> getting a <code class="literal">Factory</code> object. It then calls the <code class="literal">SetWindowAssociation()</code> method on this object. This method takes two parameters: the first being the handle of our game window and the second being the window association flags we want to use. In this case, we are using the <code class="literal">WindowAssociationFlags.IgnoreAltEnter</code> flag. So why are we doing this? The answer is to prevent <strong>DXGI</strong>
<a id="id376" class="indexterm"/> from handling <em>Alt</em> + <em>Enter</em> since it does not work properly with WinForms. Remember that DXGI is one of the namespaces that we included with a <code class="literal">using</code> statement when we started this project. DXGI is short for DirectX Graphics Infrastructure. We will handle the <em>Alt</em> + <em>Enter</em> keyboard shortcut ourselves later. It will toggle the fullscreen mode for our program.</p><p>With that done, we need to create two more initialization functions: one will initialize our shaders, and the other will initialize our geometry (the triangle we are going to draw).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Initializing the shaders</h2></div></div></div><p>We will create<a id="id377" class="indexterm"/> a new method named <code class="literal">InitShaders()</code> to initialize our shaders for us. In this demo, we will set up both a vertex shader and a pixel shader. The following is the code for this method:</p><div><pre class="programlisting">public void InitShaders()
{
    // Load and compile the vertex shader
    string vsCompileError = "Vertex Shader Compile Error!!!";
    using (var bytecode =ShaderBytecode.CompileFromFile("Effects.fx","Vertex_Shader","vs_4_0",ShaderFlags.Debug,SlimDX.D3DCompiler.EffectFlags.None,null,null,out vsCompileError))

    {
        m_VShaderSignature = ShaderSignature.GetInputSignature(bytecode);
        m_VertexShader = new VertexShader(m_Device, bytecode);
    }

    // Load and compile the pixel shader
    string psCompileError = "Pixel Shader Compile Error!!!";
    using (var bytecode =ShaderBytecode.CompileFromFile("Effects.fx","Pixel_Shader","ps_4_0",ShaderFlags.Debug,SlimDX.D3DCompiler.EffectFlags.None,null,null,out psCompileError))
    {
        m_PixelShader = new PixelShader(m_Device, bytecode);
    }
}</pre></div><p>You can see <a id="id378" class="indexterm"/>that this function contains two blocks of code that are quite similar to each other. The first one initializes our vertex shader. The downloadable code contains a file called <code class="literal">Effects.fx</code>, which is simply a text file containing the code of our basic shaders.</p><p>The first line creates a string variable named <code class="literal">vsCompileError</code>. This will receive any errors that are raised by the next piece of code. As you can see, it is a <code class="literal">using</code> block that calls the <code class="literal">ShaderBytecode.CompileFromFile()</code> method to compile our vertex shader. The returned byte code is the compiled form of our vertex shader. The <code class="literal">CreateFromFile()</code> method takes a handful of parameters, and it also has several overloads. An <code class="literal">overload</code> method is another version of the same function with a different parameter list.</p><p>The first parameter of the <code class="literal">CompileFromFile()</code> method is the file containing the code of the shader we want to compile. The second parameter is the name of the method in the shader file that contains the code for this shader. The third parameter is the shader model. In this case we used <code class="literal">"vs_4_0"</code>, which tells it that we want to use shader model 4. The fourth parameter is the shader flags we use. We used <code class="literal">ShaderFlags.Debug</code> here. Again, you'd probably want to remove this flag when your game is done since the debug code will slow down performance. The next two parameters are a list of shader macros to define during shader compilation and an interface for handling the <code class="literal">include</code> files. These two parameters are set to <code class="literal">null</code> as they are beyond the scope of this chapter. And the final parameter is the <code class="literal">psCompileError</code> variable we created above the <code class="literal">using</code> block. If there are any errors, they will be put in this variable.</p><p>Inside of this <code class="literal">using</code> block we have two lines of code. The first gets the signature for this shader. Remember that the signature of a shader is just a list of the input and/or output parameters of that shader. The second line of code creates a <code class="literal">VertexShader</code> object to hold our vertex shader, and stores it in our <code class="literal">m_VertexShader</code> variable.</p><p>The second block of code in our <code class="literal">InitShaders()</code> method is very similar to the first one. It does the same stuff but for the pixel shader. It compiles our pixel shader and stores it in our <code class="literal">m_PixelShader</code> member variable. You may have noticed that it uses the same shader file as the vertex shader code at the top of this method. You can define multiple shaders in a single file, and we've done that here for simplicity.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Remember that the vertex shader is one of the stages in the Direct3D graphics pipeline, as is the pixel shader.</p></div></div><p>The last<a id="id379" class="indexterm"/> two lines of code in this method tell the graphics processing pipeline to use our vertex shader and pixel shader. So why do we have shaders anyway? The reason is because some stages in the Direct3D graphics pipeline are programmable. Shaders are the programs we write for these stages, so a shader is essentially a small program that tells Direct3D what to do during that stage in the pipeline. There are more shader types besides vertex and pixel shaders too, but they are beyond the scope of this book. Shaders are a powerful tool that allow us to customize the graphics processing pipeline, so we can do things that otherwise we might not be able to do. You can have more than one shader of a given type and switch between them at will too (we will actually do this in the second demo we make in this chapter), so you're not stuck with the first shader you set. At this point, we are ready to initialize our scene.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Initializing the scene</h2></div></div></div><p>In 3D graphics, the term <strong>scene</strong> is used much as it is in the movies. However, in this case, the term scene<a id="id380" class="indexterm"/> refers to the world, or 3D scene, that we are rendering. To initialize our scene, we will create one more initialization method named <code class="literal">InitScene()</code>. The code for this method looks as follows:</p><div><pre class="programlisting">public void InitScene()
{
    // Create the vertices of our triangle.
    Vector3[] vertexData =
    {
        new Vector3(-0.5f,  0.5f,  0.5f),
        new Vector3( 0.5f,  0.5f,  0.5f),
        new Vector3( 0.0f, -0.5f,  0.5f),
    };

    // Create a DataStream object that we will use to put the vertices into the vertex buffer.
    using (DataStream DataStream =new DataStream(Vector3.SizeInBytes * 3, true, true))
    {
        DataStream.Position = 0;
        DataStream.Write(vertexData[0]);
        DataStream.Write(vertexData[1]);
        DataStream.Write(vertexData[2]);
        DataStream.Position = 0;

        // Create a description for the vertex buffer.
        BufferDescription bd = new BufferDescription();
        bd.Usage = ResourceUsage.Default;
        bd.SizeInBytes = Vector3.SizeInBytes * 3;
        bd.BindFlags = BindFlags.VertexBuffer;
        bd.CpuAccessFlags = CpuAccessFlags.None;
        bd.OptionFlags = ResourceOptionFlags.None;

        // Create the vertex buffer.
        m_VertexBuffer = new SlimDX.Direct3D11.Buffer(m_Device,DataStream,bd);
    }

    // Define the vertex format.
    // This tells Direct3D what information we are storing for each vertex, and how it is stored.InputElement[] InputElements = new InputElement[]
    {
        new InputElement("POSITION", 0, Format.R32G32B32_Float,InputElement.AppendAligned, 0,SlimDX.Direct3D11.InputClassification.PerVertexData, 0),};

    // Create the InputLayout using the vertex format we just created.
    m_InputLayout = new InputLayout(m_Device,m_VShaderSignature,InputElements);

    // Setup the InputAssembler stage of the Direct3D 11 graphics pipeline.
    m_DeviceContext.InputAssembler.InputLayout = m_InputLayout;
    m_DeviceContext.InputAssembler.SetVertexBuffers(0,new VertexBufferBinding(m_VertexBuffer,Vector3.SizeInBytes,0));

    // Set the Primitive Topology.
    m_DeviceContext.InputAssembler.PrimitiveTopology =PrimitiveTopology.TriangleList;
}</pre></div><p>The first<a id="id381" class="indexterm"/> thing we do in this method is create an array of the <code class="literal">Vector3</code> objects. These are the vertices that make up our inverted triangle. So, each <code class="literal">Vector3</code> object contains the x, y, and z coordinates for the vertex it represents.</p><p>The next block of code is a <code class="literal">using</code> block that creates a <code class="literal">DataStream</code> object. We pass in the three parameters when we create this object. The first parameter is the total size in bytes of our vertex data. The last two parameters are <code class="literal">canRead</code> and <code class="literal">canWrite</code>. They specify whether or not reading and writing to the buffer should be allowed.</p><p>The next line sets the position of the data stream to the start. The following three lines write our vertices into the data stream one by one. And the last line here sets the data stream's position back to the beginning again.</p><p>Now that our geometry data is ready, we need to create a <code class="literal">VertexBuffer</code> object to put it in. The next block of code creates a <code class="literal">BufferDescription</code> object for this purpose. We set the <code class="literal">ResourceUsage</code> property to <code class="literal">ResourceUsage.Default</code>. Next, we set the <code class="literal">SizeInBytes</code> property to the size of our vertex data, so the vertex buffer will be big enough to hold it all. Then, we set the <code class="literal">BindFlags</code> property to <code class="literal">BindFlags.VertexBuffer</code> since this buffer is going to be used as a vertex buffer. We have set both the <code class="literal">CpuAccessFlags</code> and <code class="literal">OptionFlags</code> properties to <code class="literal">None</code> on the next two lines as they are beyond the scope of this discussion.</p><p>The next line of code creates the <code class="literal">VertexBuffer</code> object. We pass in three parameters when we create it. The first parameter is our Direct3D device. The second parameter is the <code class="literal">DataStream</code> object we wrote our vertex data into, and the last parameter is the <code class="literal">BufferDescription</code> object we just created.</p><p>At this point, the <code class="literal">using</code> block ends. When program execution reaches this point, our <code class="literal">DataStream</code> object gets disposed of since we no longer need it.</p><p>The next bit of code creates an array of the <code class="literal">InputElement</code> objects. This tells Direct3D what data we have stored in each of our vertices, and how it is formatted. As you can see, we have only added one input element here. It is the position of the vertex in 3D space.</p><p>There are a handful of parameters we pass in when creating this <code class="literal">InputElement</code> object. The first parameter is a string indicating what type of element this is. We set this to <code class="literal">"POSITION"</code> since this input element holds the position of our vertex in 3D space. The second parameter is an index that is used when you have multiple elements with the same name. So if we had two elements named <code class="literal">"POSITION"</code>, we would set the index parameter to <code class="literal">1</code> for the second one. The third parameter is the data format used by this input element. In this case, we need to store three numbers since a coordinate in 3D space is composed of three integers. So, we used the format <code class="literal">Format.R32G32B32_Float</code>. This format holds three float values, each of which is 32 bits in size. The next parameter is an offset to the next input element.</p><p>For convenience, we've set this to <code class="literal">InputElement.AppendAligned</code>, which means <a id="id382" class="indexterm"/>this input element will start directly after the previous one. The next parameter is the input slot to use for this input element. The valid values for this property are <code class="literal">0</code>-<code class="literal">15</code>. Then, we have the slot class parameter, which we've set to <code class="literal">InputClassification.PerVertexData</code>. This is because this element is being used on a per-vertex basis since we need to store the position for every vertex. The last parameter is the step rate. We have set this to <code class="literal">0</code> in our code since we are not using this feature, and it is beyond the scope of this chapter.</p><p>With that, we're almost done now. The next line of code creates an <code class="literal">InputLayout</code> object that will hold the information we just set up. We pass in three parameters when we create it. The first parameter is our Direct3D device object. The second parameter is the signature of our vertex shader, and the last parameter is the input elements array we just created.</p><p>The next line of code tells the input assembler to use our new <code class="literal">InputLayout</code> object. Remember from earlier in this chapter that the input assembler is a stage in the Direct3D graphics pipeline.</p><p>Next, we call the <code class="literal">SetVertexBuffers()</code> method on the <code class="literal">InputAssembler</code>. This tells it what vertex buffer we want to use. If you had multiple objects to draw, you can reset the vertex buffers multiple times in the <code class="literal">RenderScene()</code> method. This method takes three parameters. The first parameter is the slot we want to use. Depending on the feature level we are using, the maximum number of slots available to use can vary. The second parameter is a <code class="literal">VertexBufferBinding</code> object. We give it three parameters when we create it. The first parameter is our vertex buffer that we created a moment ago. The second parameter is the total size of our vertex buffer, and the last parameter is an offset to the first vertex in the buffer. We have set this to <code class="literal">0</code> since our first vertex is at the very beginning of the buffer.</p><p>Finally, we have one <a id="id383" class="indexterm"/>more line of code to set the <strong>primitive topology</strong>. This setting basically tells the graphics pipeline how to interpret our vertex data. In this case, we set this to <code class="literal">PrimitiveTopology.TriangleList</code>. This tells Direct3D that our vertex data is a list of triangles, or, in other words, every three vertices in the list form a triangle. There are a number of other options you can use for this setting, and they are all defined in the <code class="literal">PrimitiveTopology</code> enumeration.</p><p>The input assembler also has a <code class="literal">SetIndexBuffer()</code> method for setting <strong>index buffers</strong>. An index <a id="id384" class="indexterm"/>buffer simply holds a list of offsets into a vertex buffer to allow for more efficient rendering. For example, let's say we want to render a square. It has four vertices, but we'd have to create six to render it using a vertex buffer alone (three per triangle, and a square is composed of two triangles). We could accomplish this using only four vertices if we use an index buffer. Our index buffer would have two values in it.</p><p>The first value would be <code class="literal">0</code>, since the first triangle starts with the first vertex. The second value would be the<a id="id385" class="indexterm"/> index of the first vertex of the second triangle in the vertex buffer. This allows triangles to share vertices, as it is very common for two triangles to have vertices that are at the same point in 3D space. Clearly, this wastes memory if we re-define the same vertex more than once to create a separate instance of it for each triangle that has that vertex in it. Index buffers allow us to get around this problem. For simplicity though, we will not use an index buffer in this demo.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Rendering the scene</h2></div></div></div><p>To draw<a id="id386" class="indexterm"/> our scene, we just need to add three lines of code to our <code class="literal">RenderScene()</code> method so that it looks like the following:</p><div><pre class="programlisting">public override void RenderScene()
{
    if ((!this.IsInitialized) || this.IsDisposed)
    {
         return;
    }

    // Clear the screen before we draw the next frame.
    m_DeviceContext.ClearRenderTargetView(m_RenderTargetView,
                                          ClearColor);

    // Draw the triangle that we created in our vertex buffer.
    m_DeviceContext.Draw(3, 0);

    // Present the frame we just rendered to the user.
    m_SwapChain.Present(0, PresentFlags.None);
}</pre></div><p>As you can see, this code is fairly simple. At the top of the method, we have the same <code class="literal">if</code> statement we've been using here in previous demos. Remember that this <code class="literal">if</code> statement prevents this method from doing anything if the program isn't initialized yet or if it has already been disposed of. This prevents the crashing that could otherwise occur when the program first starts up or shuts down.</p><p>The next line of code clears the screen using whatever color is stored in our <code class="literal">ClearColor</code> property that is defined by the <code class="literal">GameWindow</code> base class. Then, we call the <code class="literal">Draw()</code> method of the Direct3D device context to draw our geometry. This method takes two parameters. The first one is the total number of vertices we want to draw. The second parameter is the index to start at in the vertex buffer. We want to draw all of our vertices, so we set this to <code class="literal">0</code> to start with the first vertex.</p><p>And lastly, we call the <code class="literal">Present()</code> method on the swap chain. It takes two parameters. The first parameter is the sync interval, and the second is the present flags. Both of these are beyond the scope of this chapter, so we are using <code class="literal">0</code> for the first parameter, and <code class="literal">PresentFlags.None</code> for the second parameter.</p><p>Before we test the code, we'll do one more little thing. We will edit the <code class="literal">ToggleFullscreen()</code> method of our <code class="literal">TriangleGameWindow</code> class so it looks like the next code<a id="id387" class="indexterm"/> snippet. Remember that this function is an override of a method defined by our <code class="literal">GameWindow</code> base class:</p><div><pre class="programlisting">public override void ToggleFullscreen()
{
    base.ToggleFullscreen();

    m_SwapChain.IsFullScreen = this.IsFullScreen;
}</pre></div><p>The first line toggles the value of our <code class="literal">IsFullScreen</code> property that was defined by the <code class="literal">GameWindow</code> base class. The second line sets the fullscreen state of our swap chain to the new value in the <code class="literal">IsFullScreen</code> property. With this bit of code, we can now toggle fullscreen mode while the program is running. If you press <em>Alt</em> + <em>Enter</em>, the program will toggle its fullscreen mode. Remember that we added code to detect the <em>Alt</em> + <em>Enter</em> key stroke back in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>, when we created the <code class="literal">GameWindow</code> base class.</p><p>Note that the resolution we are rendering at does not change when you do this. When we resize the window, the image we drew simply gets stretched to fit the new size of the window. You can have your swap chain and viewport resized by adding an event handler and subscribing it to the <code class="literal">Resize</code> event of our form (remember that our <code class="literal">RenderForm</code> object is stored in our <code class="literal">FormObject</code> property that is defined by the <code class="literal">GameWindow</code> base class). In this event handler, you would dispose of the <code class="literal">RenderTargetView</code> object using its <code class="literal">Dispose()</code> method and recreate it with the new window size. You would then reset the viewport as well.</p><p>Before you run the program, remember to edit the <code class="literal">Dispose(bool)</code> method, and make sure it disposes of all of our objects. See the downloadable code for this chapter to see the new code for this method. Once that's done, we're ready to run the program. The following is a screenshot of this program in action, showing our inverted triangle:</p><div><img src="img/7389_05_01.jpg" alt="Rendering the scene"/><div><p>Our inverted triangle being rendered in our game window</p></div></div><p>You may be wondering why the triangle is blue. We never set a color for it, so how did that happen? Well, if you look in our <code class="literal">Effects.fx</code> file at the shader code, you will see that the <a id="id388" class="indexterm"/>pixel shader is hardcoded to shade every pixel it draws blue. The pixel shader has only a single line of code that returns the color blue in RGBA format. The color returned by the pixel shader is the color for the current pixel that the graphics pipeline is processing. The <code class="literal">Effects.fx</code> file is included with the downloadable code for this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Rendering a cube</h1></div></div></div><p>In this<a id="id389" class="indexterm"/> section we will render a cube since it is actually 3D, unlike our triangle in the previous demo. We will modify the project from the previous demo to create the cube demo. In the downloadable code for this chapter, you will find the code for the cube demo in a separate project so you can look at the code for both demos. The <code class="literal">Triangle</code> project is set as the startup project by default. When you want to run the <code class="literal">Cube</code> demo, remember that you will have to set the <code class="literal">Cube</code> project as the startup project to run it.</p><p>To get started, we will add an enumeration named <code class="literal">GraphicsMode</code>. We will use it to specify how we will render our cube. This enumeration looks like the following:</p><div><pre class="programlisting">enum GraphicsMode
{
    SolidBlue = 0,
    PerVertexColoring,
    Textured
}</pre></div><p>The first<a id="id390" class="indexterm"/> option will make the program render all the pixels of the cube blue. The second option renders the cube using colors specified with each vertex and blending them across each <strong>face</strong> (or side) of the cube. And the third option will render our cube with a texture on it, which happens to be the red brick tile from our 2D demo in <a class="link" href="ch03.html" title="Chapter 3. Rendering 2D Graphics">Chapter 3</a>, <em>Rendering 2D Graphics</em>. Next, we need to make a new structure to represent a vertex since we need to store more information for each vertex now. We will name it <code class="literal">Vertex</code>. It looks as follows:</p><div><pre class="programlisting">struct Vertex
{
    public Vector4 Position;
    public Color4 Color;
    public Vector2 TexCoord;
}</pre></div><p>The first variable holds the position of the vertex in 3D space. The second one stores a color for this vertex, and the third variable stores the texture coordinates for this vertex. The texture coordinates simply define how the texture is applied to the polygon. For example, to texture a square, you'd give the upper-left vertex <code class="literal">(0,0)</code> for its texture coordinates. The upper-right vertex would be <code class="literal">(1,0)</code>, the lower-left vertex would be <code class="literal">(0,1)</code>, and the lower-right vertex would have <code class="literal">(1,1)</code> for its texture coordinates. In the texture coordinates, <code class="literal">(0,0)</code> is the upper-left corner of the texture image, and <code class="literal">(1,1)</code> represents the bottom-right corner of the texture image. So, the texture coordinates we just saw would make the texture fill the entire face of the square. They are basically attaching the top-left corner of the texture to the top-left corner of the square, the bottom-right corner of the texture to the bottom-right corner of the square, and so on.</p><p>Now, we will need to add a few sets of new member variables. The first one is for our <strong>constant buffers</strong>
<a id="id391" class="indexterm"/>. A constant buffer is just a buffer that we use to communicate certain information to the video card, such as the projection and view matrices. We have four variables for our constant buffers:</p><div><pre class="programlisting">SlimDX.Direct3D11.Buffer m_CbChangesOnResize;
SlimDX.Direct3D11.Buffer m_CbChangesPerFrame;
SlimDX.Direct3D11.Buffer m_CbChangesPerObject;

// We use this to send data into the constant buffers.
DataStream m_DataStream;</pre></div><p>The first three variables will hold our three constant buffers. But why do we have three?  The reason is that it's more efficient this way compared to using only one. The <code class="literal">m_CbChangesOnResize</code> buffer will hold the projection matrix that only needs to change when the window is resized. In this demo, this never changes since we just let it keep rendering at the same resolution and stretch it to fit the window. By having it in a separate <a id="id392" class="indexterm"/>buffer, we never have to change it unless the window changes size, which saves time. The <code class="literal">m_CbChangesPerFrame</code> buffer will hold our view matrix, which can change per frame any time that you press one of the movement keys. And lastly, the <code class="literal">m_CbChangesPerObject</code> buffer will hold information that is object-specific. This buffer would be updated each time before you draw the next object in your scene by filling it with the information for that object.</p><p>Next up, we need to add a few matrix variables:</p><div><pre class="programlisting">Matrix m_ViewMatrix;  // This is our view matrix.
Matrix m_ProjectionMatrix;  // The projection matrix.

Matrix m_CubeWorldMatrix;
Matrix m_CubeRotationMatrix;</pre></div><p>The first two variables will hold our view and projection matrices. We will look at these matrices in more detail in a moment. The other two variables hold two matrices for our cube object. The <strong>world matrix</strong>
<a id="id393" class="indexterm"/> is used to convert the coordinates of a <strong>model</strong> into <strong>world space</strong>
<a id="id394" class="indexterm"/>, which is the coordinate system of our 3D world.</p><p>A model is a 3D geometrical representation of an object. In other words, it holds all of the geometry for the object it represents. Models often have their own coordinate system known as <strong>model space</strong>
<a id="id395" class="indexterm"/>, which is why we need to convert it.</p><p>Lastly, the rotation matrix you see there for our cube controls the pitch, yaw, and roll of our cube. It is known as a <strong>transformation matrix</strong>
<a id="id396" class="indexterm"/>, because it transforms the object we use it on in some way, such as moving it, scaling it, or rotating it. The projection and view matrices are, of course, also transformation matrices. Transformation matrices are a very central concept in 3D graphics.</p><p>Now, we also need to add a few depth stencil and sampler member variables:</p><div><pre class="programlisting">// Depth stencil vars
Texture2D m_DepthStencilTexture = null;
DepthStencilView m_DepthStencilView = null;

// Sampler vars.
ShaderResourceView m_CubeTexture;
SamplerState m_CubeTexSamplerState;</pre></div><p>The first variable holds the depth stencil's texture. The <strong>depth stencil</strong> is basically a texture. Each<a id="id397" class="indexterm"/> pixel in it holds a depth value representing the nearest object that has been drawn on that pixel so far while rendering the current frame. This is how Direct3D knows whether an object is in front of or behind another object. When the pixel shader goes to draw a pixel, it checks the depth value for that pixel in the depth stencil texture. If that pixel's depth value is closer than the depth of the pixel it is trying to draw, that pixel is discarded since it belongs to an object behind another closer one that we already drew on this pixel.</p><p>The second variable holds our <code class="literal">DepthStencilView</code> object, which accesses the depth stencil texture when Direct3D is doing depth testing on a pixel. The next two variables have to do with sampling. The first one will hold our texture that we will put on the cube. The second variable holds the sampler state that we will use with our texture.</p><p>
<strong>Sampling</strong>
<a id="id398" class="indexterm"/> is the act of reading image data from our texture so that we can use it to render pixels in the pixel shader. Basically, the pixel shader gets the pixel color from the texture based on the texture coordinates of the vertices that make up the face it is drawing.</p><p>Lastly, we <a id="id399" class="indexterm"/>have one more small set of member variables to look at:</p><div><pre class="programlisting">Vector3 m_CameraPosition = new Vector3(0, 2, -5);

float m_CubeRotation = 0.005f;

float m_MoveSpeed = 0.01f;

GraphicsMode m_GraphicsMode = GraphicsMode.PerVertexColoring;</pre></div><p>The first variable here keeps track of the position of our camera, of course. The second variable tracks the current rotation amount (on the y axis) for our cube. The <code class="literal">m_MoveSpeed</code> variable specifies how fast the camera moves when you press one of the movement keys. And the last variable specifies how we want to render our cube.</p><p>I wanted to make a demo that we could really experiment with, so I added this feature. So how does it work? If you look at the code in the <code class="literal">InitShaders()</code> method in the downloadable code for this demo, you can see that we have changed the code that loads the pixel shader. Now, it has <code class="literal">if</code> statements above it that check the value of the <code class="literal">m_GraphicsMode</code> member variable. So basically, depending on which graphics mode you set, it will load and use the appropriate pixel shader. If you look in the <code class="literal">Effects.fx</code> file in the downloadable code for this demo, you can see that we have three pixel shaders in there, one for each of our three graphics modes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Initializing the depth stencil</h2></div></div></div><p>Anyway, now<a id="id400" class="indexterm"/> that we've covered the new member variables and the changes to the <code class="literal">InitShaders()</code> method, we need to add a couple of entirely new methods. The first one is the <code class="literal">InitDepthStencil()</code> method that will initialize our depth stencil for us:</p><div><pre class="programlisting">public void InitDepthStencil()
{
    // Create the depth stencil texture description
    Texture2DDescription DepthStencilTextureDesc =new Texture2DDescription();DepthStencilTextureDesc.Width = m_Form.ClientSize.Width;
    DepthStencilTextureDesc.Height = m_Form.ClientSize.Height;
    DepthStencilTextureDesc.MipLevels = 1;
    DepthStencilTextureDesc.ArraySize = 1;
    DepthStencilTextureDesc.Format = Format.D24_UNorm_S8_UInt;
    DepthStencilTextureDesc.SampleDescription =new SampleDescription(1, 0);
    DepthStencilTextureDesc.Usage = ResourceUsage.Default;
    DepthStencilTextureDesc.BindFlags = BindFlags.DepthStencil;
    DepthStencilTextureDesc.CpuAccessFlags = CpuAccessFlags.None;
    DepthStencilTextureDesc.OptionFlags =ResourceOptionFlags.None;

    // Create the Depth Stencil View description
    DepthStencilViewDescription DepthStencilViewDesc =new DepthStencilViewDescription();
    DepthStencilViewDesc.Format = DepthStencilTextureDesc.Format;
    DepthStencilViewDesc.Dimension =DepthStencilViewDimension.Texture2D;
    DepthStencilViewDesc.MipSlice = 0;

    // Create the depth stencil texture.
    m_DepthStencilTexture = new Texture2D(m_Device,DepthStencilTextureDesc);

    // Create the DepthStencilView object.
    m_DepthStencilView = new DepthStencilView(m_Device,m_DepthStencilTexture,DepthStencilViewDesc);

    // Make the DepthStencilView active.
    m_DeviceContext.OutputMerger.SetTargets(m_DepthStencilView,
        m_RenderTargetView);
}</pre></div><p>As you can see, the first thing we do is create a <code class="literal">Texture2DDescription</code> to configure the depth<a id="id401" class="indexterm"/> stencil texture. The <code class="literal">width</code> and <code class="literal">height</code> properties, of course, are setting its size to the same size as our rendering area. The <code class="literal">MipLevels</code> and <code class="literal">ArraySize</code> parameters are beyond the scope of this text, so we will ignore them. The <code class="literal">Format</code> property is, of course, the format our texture is in. The <code class="literal">D24_UNorm_S8_UInt</code> format means 24 bits for depth and 8 bits for the stencil component, but this is getting into the details of how the depth stencil actually works, which is beyond the scope of this text. The <code class="literal">SampleDescription</code> property sets the multisampling parameters for this texture. The <code class="literal">Usage</code> property specifies how this resource will be used during rendering. We set the <code class="literal">BindFlags</code> property to <code class="literal">BindFlags.DepthStencil</code> to tell Direct3D that this will be used for depth stenciling. And lastly, we set the <code class="literal">CpuAccessFlags</code> and <code class="literal">OptionsFlags</code> to <code class="literal">None</code> as we've done before.</p><p>Next, we <a id="id402" class="indexterm"/>create a <code class="literal">DepthStencilViewDescription</code> to configure the depth stencil view object. The <code class="literal">Format</code> property specifies the format, for which we just pass in the value we set for the <code class="literal">Format</code> property of the depth stencil texture description we just filled in. We set the <code class="literal">Dimension</code> property to <code class="literal">DepthStencilViewDimension.Texture2D</code> since we are using a <code class="literal">Texture2D</code> object for the depth stencil texture. And the <code class="literal">MipSlice</code> property is beyond the scope of this text, so we set it to <code class="literal">0</code>.</p><p>The next line of code creates the depth stencil texture object. And after that, the following line creates the <code class="literal">DepthStencilView</code> object. And the last line tells the output merger to use our new depth stencil along with our render target.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>In this demo we only have one object, so we won't really see the depth stencil in action. If we had two cubes, with one partially obscured by the other, then we'd see the depth stencil in action, making the front cube actually get drawn in front as we want.</p></div></div><p>With that done, we need to initialize our constant buffers now, so that we can communicate various bits of information to the graphics card, such as our projection and view matrices.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Initializing the constant buffers</h2></div></div></div><p>Next we<a id="id403" class="indexterm"/> will create the <code class="literal">InitConstantBuffers()</code> method to initialize our constant buffers:</p><div><pre class="programlisting">public void InitConstantBuffers()
{
    // Create a buffer description.
    BufferDescription bd = new BufferDescription();
    bd.Usage = ResourceUsage.Default;
    bd.BindFlags = BindFlags.ConstantBuffer;
    bd.CpuAccessFlags = CpuAccessFlags.None;
    bd.SizeInBytes = 64;

    // Create the changes on resize buffer.
    m_CbChangesOnResize = new SlimDX.Direct3D11.Buffer(m_Device,bd);// Create the changes per frame buffer.
    m_CbChangesPerFrame = new SlimDX.Direct3D11.Buffer(m_Device,bd);
    // Create the changes per object buffer.
    m_CbChangesPerObject = new SlimDX.Direct3D11.Buffer(m_Device,bd);

    // Send the Projection matrix into the changes on resize constant buffer.
    m_DataStream = new DataStream(64, true, true);
    m_DataStream.Position = 0;
    m_DataStream.Write(Matrix.Transpose(m_ProjectionMatrix));
    m_DataStream.Position = 0;
    m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesOnResize,0);

    // Send the View matrix into the changes per frame buffer.
    m_DataStream.Position = 0;
    m_DataStream.Write(Matrix.Transpose(m_ViewMatrix));
    m_DataStream.Position = 0;
    m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerFrame,0);

    // Tell the VertexShader to use our constant buffers.
    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesOnResize, 0);
    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesPerFrame, 1);
    m_DeviceContext.VertexShader.SetConstantBuffer(m_CbChangesPerObject, 2);
}</pre></div><p>In this<a id="id404" class="indexterm"/> method, we start by creating a <code class="literal">BufferDescription</code>. In this case, all three of our constant buffers will be the same size (64 bytes), which means we can get away with using just this one <code class="literal">BufferDescription</code> to create all three buffers. We set its <code class="literal">ResourceUsage</code> property to <code class="literal">default</code> and its <code class="literal">BindFlags</code> property to <code class="literal">BindFlags.ConstantBuffer</code> since we want to use these buffers as constant buffers. We set the <code class="literal">CpuAccessFlags</code> property to <code class="literal">None</code> once again, and the <code class="literal">SizeInBytes</code> property we set to <code class="literal">64</code> since that's the size we need our constant buffers to be. The reason is that in this demo, each of these buffers will simply hold a single 4 x 4 matrix, which takes 64 bytes of memory.</p><p>The next three lines of code create each of our three constant buffers. Then, the next block of code creates a <code class="literal">DataStream</code> object and stores it in our <code class="literal">m_DataStream</code> member variable so we can re-use it. Then we set the position of the data stream to <code class="literal">0</code> so that we start writing at the beginning of it. Next, we write the transpose of the projection matrix into the <a id="id405" class="indexterm"/>data stream and reset its position back to <code class="literal">0</code> again. The last line is slightly complex, but it simply sends the data in the data stream into the <code class="literal">m_CbChangesOnResize</code> constant buffer to make it available to the graphics pipeline. The details of how this line actually works are beyond the scope of this chapter.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>You may have noticed that we didn't create our <code class="literal">DataStream</code> object in a <code class="literal">using</code> block this time. The reason is that we continue to use it throughout the life of the program, so we can't dispose of it here, or else the demo would crash!</p></div></div><p>The next set of code does the same thing, but for the view matrix, sending it into the <code class="literal">m_CbChangesPerFrame</code> constant buffer. And lastly, the final three lines in this method tell the vertex shader to use our three new constant buffers. As you can see, we put each constant buffer in its own slot; hence, the second parameter increments by one in each line. This parameter specifies which slot to set the constant buffer to.</p><p>We are now ready to initialize our scene and create our cube!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Initializing the scene</h2></div></div></div><p>A lot of the<a id="id406" class="indexterm"/> code for this method is the same as before, so we won't show it all here. At the top of this method, we add some new code to initialize the projection and view matrices:</p><div><pre class="programlisting">// Create our projection matrix.
m_ProjectionMatrix = Matrix.PerspectiveFovLH(1.570796f, // 90 degrees in radians(float) m_Form.Width / (float) m_Form.Height,0.5f,1000.0f);

// Create our view matrix.
    m_ViewMatrix = Matrix.LookAtLH(m_CameraPosition,new Vector3(0, 0, 0),new Vector3(0, 1, 0));</pre></div><p>The first line creates the projection matrix. The projection matrix is analogous to choosing a type of lens for the camera. The four parameters we pass into the <code class="literal">Matrix.PerspectiveFovLH()</code> method set the vertical field of view, the aspect ratio, and <a id="id407" class="indexterm"/>the <strong>near clipping plane</strong> and <strong>far clipping plane</strong> distances. The <a id="id408" class="indexterm"/>
<code class="literal">Fov</code> part in the method name is, of course, short for field of view. The <code class="literal">LH</code> part indicates that this is the method to use if you are working in a left-handed coordinate system. We are using a left-handed coordinate system in this demo because video games generally use the left-handed coordinate system. There is, of course, another version of this method that ends in <code class="literal">RH</code> for use in right-handed <a id="id409" class="indexterm"/>coordinate systems. For a more in-depth look at these two types of coordinate systems, take a look at this article on Microsoft's MSDN website <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/bb324490(v=vs.85).aspx</a>.</p><p>Clipping is the removing of objects from the render list that don't need to be drawn in the current frame—generally because they are not visible anyway. This provides performance benefits and is necessary since trying to render everything in your 3D world is not practical unless it happens to be a very small world. Trying to do so may result in very low frame rates.</p><p>The near clipping plane is the minimum distance an object must be from the camera to be rendered. If an object is closer to the camera than this, it will not be rendered. This can prevent objects from being partially rendered if the player gets too close to them. Likewise, the far clipping plane is the maximum distance an object can be from the camera and still be drawn. An object farther away than this will not be drawn. Note that Direct3D takes care of basic clipping for us.</p><p>The next bit of code creates the view matrix using the <code class="literal">Matrix.LookAtLH()</code> method. The three parameters we pass in are all <code class="literal">Vector3</code> objects. The first one is the position of the camera (in other words, the player's viewpoint) in 3D space. The second parameter is the coordinates for the camera to look at. And the last parameter is simply a vector that specifies which way is up in our 3D world. We are using the positive y axis as the vertical axis here, which is what you'll use most of the time.</p><p>Under this code, we have new vertex data, but it is far too big to show here, so check out the downloadable code to see it. It specifies a position, color, and texture coordinates for each vertex, which is a big departure from our previous demo that only had a position for each vertex. This means that the input elements array will be very different this time too. Again, check out the downloadable code to see this.</p><p>Lastly, we need to add this code to the bottom of this method:</p><div><pre class="programlisting">// Load the cube texture.
m_CubeTexture = ShaderResourceView.FromFile(m_Device,Application.StartupPath + "\\Brick.png");
// Create a SamplerDescription
SamplerDescription sd = new SamplerDescription();
sd.Filter = Filter.MinMagMipLinear;
sd.AddressU = TextureAddressMode.Wrap;
sd.AddressV = TextureAddressMode.Wrap;
sd.AddressW = TextureAddressMode.Wrap;
sd.ComparisonFunction = Comparison.Never;
sd.MinimumLod = 0;
sd.MaximumLod = float.MaxValue;

// Create our SamplerState
m_CubeTexSamplerState = SamplerState.FromDescription(m_Device,sd);</pre></div><p>As you can see, the first line loads our cube texture. As mentioned before, this is just the red brick tile from our 2D demo back in <a class="link" href="ch03.html" title="Chapter 3. Rendering 2D Graphics">Chapter 3</a>, <em>Rendering 2D Graphics </em>. Next, we create a sampler <a id="id410" class="indexterm"/>description, which we will use to create a sampler state to use with our cube texture. Most of the properties of the <code class="literal">SamplerDescription</code> are beyond the scope of this text. And finally, the last line creates a <code class="literal">SamplerState</code> for our cube texture. Now that our cube texture is set up, we are ready to update the scene in our <code class="literal">UpdateScene()</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Updating the scene</h2></div></div></div><p>Next, we need to modify our <code class="literal">UpdateScene()</code> method. First, we need to add the following <a id="id411" class="indexterm"/>code after the <code class="literal">if</code> statement at the top of this method:</p><div><pre class="programlisting">// Keep the cube rotating by increasing its rotation amount
m_CubeRotation += 0.00025f;
if (m_CubeRotation &gt; 6.28f) // 2 times PI
    m_CubeRotation = 0.0f;</pre></div><p>Here, we increment the <code class="literal">m_CubeRotation</code> variable to increase the cube's rotation slightly for this frame. Note that this rotation value is in radians, not degrees. The <code class="literal">if</code> statement resets this variable to <code class="literal">0</code> when it gets too large. Over many frames, this causes the cube to rotate.</p><p>Below that, we will add the following <code class="literal">if</code> statement:</p><div><pre class="programlisting">// If the player pressed forward.
if (UserInput.IsKeyPressed(Key.UpArrow) ||UserInput.IsKeyPressed(Key.W))
{
    m_CameraPosition.Z = m_CameraPosition.Z + m_MoveSpeed;
}</pre></div><p>This <code class="literal">if</code> statement checks if the player has pressed the up arrow key or the <em>W</em> key. If so, we increase the camera's position on the z axis. Then, below this we would add another <code class="literal">if</code> statement that does the same for moving backwards if you press the down arrow key or the <em>D</em> key. If you have pressed one of these keys, it will decrease the camera's position on the z axis. Check out the downloadable code for this chapter to see this code.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Remember that <code class="literal">UserInput</code> is a variable defined by our <code class="literal">GameWindow</code> base class, which provides access to its <code class="literal">UserInput</code> object that we created in <a class="link" href="ch02.html" title="Chapter 2. Responding to Player Inputs">Chapter 2</a>, <em>Responding to Player Inputs</em>.</p></div></div><p>You may notice that the camera acts a bit oddly if you move forward until you pass the cube. This is just because the camera is effectively locked on to the cube. If you try to add controls<a id="id412" class="indexterm"/> for moving left/right or up/down, you will notice the camera will act a bit oddly for this same reason when you move it in those directions. The camera auto-rotates so that it is always looking towards the cube, no matter where you move it. The next block of code recreates the view matrix, and then sends that data into the <code class="literal">m_CbChangesPerFrame</code> constant buffer. We need to update the view matrix every time the camera moves. The following is that code:</p><div><pre class="programlisting">// Update the view matrix.
m_ViewMatrix = Matrix.LookAtLH(m_CameraPosition,new Vector3(0, 0, 0),new Vector3(0, 1, 0));

// Send the updated view matrix into its constant buffer.
m_DataStream.Position = 0;
m_DataStream.Write(Matrix.Transpose(m_ViewMatrix));
m_DataStream.Position = 0;

m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerFrame,0);</pre></div><p>Lastly, we update the cube's rotation matrix with the new value in the <code class="literal">m_CubeRotation</code> variable that we updated at the top of this method:</p><div><pre class="programlisting">// Update the cube's rotation matrix.
Vector3 rotationAxis = new Vector3(0.0f, 1.0f, 0.0f);
m_CubeRotationMatrix =Matrix.RotationAxis(rotationAxis, m_CubeRotation);

// Update the cube's world matrix with the new translation and rotation matrices.
m_CubeWorldMatrix = m_CubeRotationMatrix;</pre></div><p>The first parameter of the <code class="literal">Matrix.RotationAxis()</code> method is <code class="literal">Vector3</code> specifying the axis we want the cube to rotate around. The second parameter is our rotation amount in radians, which is in our <code class="literal">m_CubeRotation</code> member variable. And finally we update the cube's world matrix with the new rotation matrix we just created.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Rendering the scene</h2></div></div></div><p>We have<a id="id413" class="indexterm"/> one last thing to change and we should be ready to run the program. We need to change the code in our <code class="literal">RenderScene()</code> method to draw the cube. After the line that clears the screen, we add the following line:</p><div><pre class="programlisting">m_DeviceContext.ClearDepthStencilView(m_DepthStencilView,DepthStencilClearFlags.Depth,1.0f,0);</pre></div><p>This line clears the depth stencil texture, so it is empty before we start rendering this frame. Then below this, we need to add the following block of code:</p><div><pre class="programlisting">m_DeviceContext.PixelShader.SetShaderResource(m_CubeTexture, 0);
m_DeviceContext.PixelShader.SetSampler(m_CubeTexSamplerState, 0);

// Send the cube's world matrix to the changes per object constant buffer.
m_DataStream.Position = 0;
m_DataStream.Write(Matrix.Transpose(m_CubeWorldMatrix));
m_DataStream.Position = 0;

m_Device.ImmediateContext.UpdateSubresource(new DataBox(0, 0, m_DataStream),m_CbChangesPerObject,0);</pre></div><p>The first two lines set our cube texture as a resource on the pixel shader so that it can use it. The second line sets the sampler state to use with it. Then the next block of code uses our <code class="literal">DataStream</code> to send the updated information for our cube into the <code class="literal">m_CbChangesPerObject</code> constant buffer.</p><p>Now we need to change the line that calls the <code class="literal">Draw()</code> method on the <code class="literal">DeviceContext</code>:</p><div><pre class="programlisting">m_DeviceContext.Draw(36, 0);</pre></div><p>As you can see, we've changed it to draw 36 vertices now. This is because our cube has 36 vertices. But a cube only has eight corners, right? Well, each corner vertex is duplicated for each side it is shared by. You can avoid this somewhat by using the <code class="literal">TriangleStrip</code> primitive topology rather than <code class="literal">TriangleList</code> as we've used here and by using index buffers as discussed earlier in this chapter.</p><p>As always, don't forget to edit the <code class="literal">Dispose(bool)</code> method, and make sure it disposes of all of our disposable objects. The following are some examples of the program running in all three of our graphics modes:</p><div><img src="img/7389_05_02.jpg" alt="Rendering the scene"/><div><p>The cube demo in all three graphics modes</p></div></div><p>The first <a id="id414" class="indexterm"/>part of the previous diagram shows the program when you set <code class="literal">m_GraphicsMode</code> to <code class="literal">GraphicsMode.SolidBlue</code>. The second image shows <code class="literal">GraphicsMode.PerVertexColoring</code>, and the last image shows <code class="literal">GraphicsMode.Textured</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter we dived into the world of 3D graphics. It's a very complicated subject, but we drew a blue triangle on the screen in our first demo, where we looked at the basics of setting up a Direct3D application. Then, we started work on our cube demo, where we introduced the concepts of depth stencils and constant buffers. We gave this demo three graphics modes that you can run it in by changing the value of the <code class="literal">m_GraphicsMode</code> member variable in the <code class="literal">CubeGameWindow</code> class. In the next chapter, we'll take a look at a few other topics briefly and discuss where to go from here in learning the art of game programming.</p></div></body></html>