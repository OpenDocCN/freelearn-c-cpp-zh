<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating and Displaying Tile Maps</h1></div></div></div><p>Most 2D games that you have played in the past made use of <a class="indexterm" id="id392"/>
<strong>tile maps</strong>. It is an extremely efficient and fast way to develop complex 2D levels or scenes. Even if a game has more complex graphical content, it is likely that it will still make use of tiles in some way. Throughout this chapter we will be using the <a class="indexterm" id="id393"/>
<strong>tiled map editor</strong>, an open source and cross-platform tool created by Thorbjørn Lindeijer and a large open source community. It is available at <a class="ulink" href="http://www.mapeditor.org/">http://www.mapeditor.org/</a>. We will essentially make this tool our level editor and use it for creating maps and placing our objects within those maps.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What a tile map is</li><li class="listitem" style="list-style-type: disc">What a tile sheet looks like</li><li class="listitem" style="list-style-type: disc">Using the tiled map editor to create our maps</li><li class="listitem" style="list-style-type: disc">Parsing a state from a tiled map</li><li class="listitem" style="list-style-type: disc">Loading and displaying a tile-based map in SDL 2.0</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>What is a tile map?</h1></div></div></div><p>If you have played a lot of 2D games <a class="indexterm" id="id394"/>then you will be very familiar with tile maps. We will start by looking at an example in the form of the following screenshot:</p><div><img alt="What is a tile map?" src="img/6821OT_07_01.jpg"/></div><p>This 20 x 15 tile map <a class="indexterm" id="id395"/>was made using the following screenshot called a <strong>tileset</strong>.</p><div><img alt="What is a tile map?" src="img/6821OT_07_02.jpg"/></div><p>As you can see, one huge advantage to a tile system like this is that you can create large maps from relatively small image files. Tile maps are essentially a multidimensional array of IDs that tell us which part of the tileset we want to draw at each location. It will help to look at the images again with their IDs in place as shown in the following screenshot:</p><div><img alt="What is a tile map?" src="img/6821OT_07_03.jpg"/></div><p>Here is the tileset with its IDs <a class="indexterm" id="id396"/>in place as shown in the preceding screenshot.</p><div><img alt="What is a tile map?" src="img/6821OT_07_04.jpg"/></div><p>To draw the map we loop through the number of columns and the number of rows, grab the correct tile using its ID, and draw it to the screen. Any tile with an ID of zero will not be drawn (a blank tile). This can be seen in the preceding screenshot.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Getting familiar with the Tiled application</h1></div></div></div><p>Tiled is a very user-friendly<a class="indexterm" id="id397"/> application that can greatly speed up our development time. Once you have downloaded and installed the application, open it up and you will be presented with the user interface as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_05.jpg"/></div><p>On the right-hand side we have the <strong>Layers</strong> and <strong>Tilesets</strong> views; the left-hand side will contain our tile map. First we must create a new map, this can be done by navigating to <strong>File</strong> | <strong>New…</strong> or <em>Ctrl </em>+ <em>N</em>. This brings up the new map dialog as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_06.jpg"/></div><p>Here we can define the size<a class="indexterm" id="id398"/> and type of our map. We are only going to use orthogonal tile maps (as opposed to isometric), so go ahead and create an orthogonal tile map that is 20 tiles wide and 15 tiles high, with tile width and height both set to 32 px. We can now see our tile map in the left-hand side of the UI (<em>Ctrl </em>+ <em>G</em> will show the grid). Tiled will also automatically create a layer for us called <strong>Tile Layer 1</strong> (Visible in the <strong>Layers</strong> view on the right-hand side) as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_07.jpg"/></div><p>We are not going to deal <a class="indexterm" id="id399"/>with any terrain so we can turn off that tab by navigating to <strong>View</strong> | <strong>Terrains</strong> and unchecking. Save this map as <code class="literal">map1.tmx</code> in the same location as the rest of our game assets. If you open this file you will see that it is actually just an XML file:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;map version="1.0" orientation="orthogonal" width="20" height="15" tilewidth="32" tileheight="32"&gt;
    &lt;layer name="Tile Layer 1" width="20" height="15"&gt;
        &lt;data encoding="base64" compression="zlib"&gt;
          eJxjYBgFo2AUjIKhAQAEsAAB
        &lt;/data&gt;
    &lt;/layer&gt;
&lt;/map&gt;</pre></div><p>This should all look very familiar. Tiled has a few different compression algorithms that can be used to store the tile IDs of our maps. The preceding file uses the<a class="indexterm" id="id400"/> <strong>zlib compression algorithm</strong> along with <a class="indexterm" id="id401"/>
<strong>base64 encoding</strong> which, as you can see, gives great results:</p><div><pre class="programlisting">&lt;data encoding="base64" compression="zlib"&gt;
  eJxjYBgFo2AUjIKhAQAEsAAB
&lt;/data&gt;</pre></div><p>If we compare the same map with base64 <a class="indexterm" id="id402"/>encoding and no compression, we can see that the extra work needed to decompress and parse the zlib compression is definitely worth it. Here is the uncompressed map:</p><div><pre class="programlisting"> &lt;data encoding="base64"&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
&lt;/data&gt;</pre></div><p>We will cover this in more depth once we start parsing the tile maps, but for now let's look at adding a tileset. Navigate to <strong>Map</strong> | <strong>New Tileset…</strong> and it will bring up a new <strong>Tileset</strong> dialog as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_08.jpg"/></div><p>The tileset we will start<a class="indexterm" id="id403"/> with is <code class="literal">blocks1.png</code> as shown in the following screenshot, available in the source downloads.</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_09.jpg"/></div><p>Copy the image to the game assets location and then we can browse to it in the <strong>New Tileset</strong> dialog. This tileset<a class="indexterm" id="id404"/> has a 2 pixel wide margin around the outside and 2 pixel spacing between each tile; each tile is 32 x 32 pixels. Once these values are set, click on <strong>OK</strong> and the tileset will appear in the <strong>Tilesets</strong> view to the right-hand side. We can now start to build our map using the provided tools as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_10.jpg"/></div><p>The red highlights are our bread-and-butter tools. The stamp tool adds the selected tile from the tileset to the given location, the paint bucket fills an area with a selected tile from the tileset, and the eraser tool, of course, erases. We can select tiles from the tileset one at a time or many at a time, as shown in the following screenshot:</p><div><img alt="Getting familiar with the Tiled application" src="img/6821OT_07_11.jpg"/></div><p>Go ahead and get acquainted with these tools by building a simple map. Once the map is saved we will see that the tileset has been added to the map file:</p><div><pre class="programlisting">&lt;tileset firstgid="1" name="blocks1" tilewidth="32" tileheight="32" spacing="2" margin="2"&gt;
  &lt;image source="assets/blocks1.png" width="614" height="376"/&gt;
&lt;/tileset&gt;</pre></div><p>The <code class="literal">firstgid</code> attribute<a class="indexterm" id="id405"/> is the first tile ID that uses this tileset. If we were to have more than one tileset, it would come with its own <code class="literal">firstgid</code> attribute so that we knew which tile IDs to start associating with that tileset; again, we will cover this in greater detail when we come to parse our maps. Add another tileset, <code class="literal">blocks2.png</code> (also available in the source code downloads), to our map and we shall move into drawing it in our game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Parsing and drawing a tile map</h1></div></div></div><p>Now that we are relatively familiar with creating tile maps in the Tiled application we will move on to parsing them and <a class="indexterm" id="id406"/>drawing them in our game. We are going to create quite a<a class="indexterm" id="id407"/> few new classes starting with a class called <code class="literal">Level</code> that will hold our tilesets and also draw and update our separate layers. Let's go ahead and create <code class="literal">Level.h</code> in our project and add the following code:</p><div><pre class="programlisting">class Level {
  public:

  Level();
  ~Level() {}

  void update();
  void render();
};</pre></div><p>We will also define a <code class="literal">struct</code> at the top of this file called <code class="literal">Tileset</code>:</p><div><pre class="programlisting">struct Tileset
{
  int firstGridID;
  int tileWidth;
  int tileHeight;
  int spacing;
  int margin;
  int width;
  int height;
  int numColumns;
  std::string name;
};</pre></div><p>This <code class="literal">struct</code> holds <a class="indexterm" id="id408"/>any information we need to know about our tilesets. Our <code class="literal">Level</code> <a class="indexterm" id="id409"/>class will now also hold a vector of <code class="literal">Tileset</code> objects:</p><div><pre class="programlisting">private:

  std::vector&lt;Tileset&gt; m_tilesets;</pre></div><p>Next we will create a public getter function that returns a pointer to this <code class="literal">Tileset</code> vector:</p><div><pre class="programlisting">std::vector&lt;Tileset&gt;* getTilesets() 
{ 
    return &amp;m_tilesets;  
}</pre></div><p>We will pass this into our parser when we come to load the map.</p><p>The next class we will create is an abstract base class called <code class="literal">Layer</code>. All of our layer types will derive from this class. Create <code class="literal">Layer.h</code> and add the following code:</p><div><pre class="programlisting">class Layer
{
  public:

  virtual void render() = 0;
  virtual void update() = 0;

  protected:

  virtual ~Layer() {}
};</pre></div><p>Now that we <a class="indexterm" id="id410"/>have the <code class="literal">Layer</code> class we will store a vector of the <code class="literal">Layer*</code> objects in the <code class="literal">Level</code> class. Back in <code class="literal">Level.h</code> add our vector:</p><div><pre class="programlisting">std::vector&lt;Layer*&gt; m_layers;</pre></div><p>And a getter function:</p><div><pre class="programlisting">std::vector&lt;Layer*&gt;* getLayers() 
{ 
    return &amp;m_layers; 
}</pre></div><p>Now we have a basic <a class="indexterm" id="id411"/>
<code class="literal">Level</code> class in place; its purpose is to store, draw, and update our layers. We will define the functions for <code class="literal">Level</code> in a <code class="literal">Level.cpp</code> file:</p><div><pre class="programlisting">void Level::render()
{
  for(int i = 0; i &lt; m _layers.size(); i++)
  {
    m_layers[i]-&gt;render();
  }
}
void Level::update()
{
  for(int i = 0; i &lt; m_layers.size(); i++)
  {
    m_layers[i]-&gt;update();
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Creating the TileLayer class</h2></div></div></div><p>Our first layer type is <a class="indexterm" id="id412"/>going to be a <code class="literal">TileLayer</code>. This type of layer is made up entirely of tiles and does not contain anything else. We have already created a layer like this in the Tiled application. Create <code class="literal">TileLayer.h</code> and we can start to write up this class:</p><div><pre class="programlisting">class TileLayer : public Layer
{
  public:

    TileLayer(int tileSize, const std::vector&lt;Tileset&gt; &amp;tilesets);

    virtual void update();
    virtual void render();

    void setTileIDs(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; data)  
    {  
        m_tileIDs = data;  
    }

    void setTileSize(int tileSize)  
    {  
        m_tileSize = tileSize;  
    }

    Tileset getTilesetByID(int tileID);

  private:

    int m_numColumns;
    int m_numRows;
    int m_tileSize;

    Vector2D m_position;
    Vector2D m_velocity;

    const std::vector&lt;Tileset&gt; &amp;m_tilesets;

    std::vector&lt;std::vector&lt;int&gt;&gt; m_tileIDs;
};</pre></div><p>There is nothing too complicated about this class; it holds data for our tile layer. The <code class="literal">Vector2D</code> variables are used when we start to scroll our maps. We will not define this class' functions properly<a class="indexterm" id="id413"/> right now, but you will need to create empty definitions along with defining the vector constants in a <code class="literal">TileLayer.cpp</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Creating the LevelParser class</h2></div></div></div><p>Now that we have the basic <a class="indexterm" id="id414"/>level and layer classes in place, <a class="indexterm" id="id415"/>we can move onto creating a parser for our <code class="literal">.tmx</code> files and creating levels from them. Create <code class="literal">LevelParser.h</code>:</p><div><pre class="programlisting">Class LevelParser
{
  public:

    Level* parseLevel(const char* levelFile);

  private:

    void parseTilesets(TiXmlElement* pTilesetRoot,std::vector&lt;Tileset&gt;* pTilesets);

    void parseTileLayer(TiXmlElement* pTileElement,std::vector&lt;Layer*&gt; *pLayers, const std::vector&lt;Tileset&gt;*pTilesets);

    int m_tileSize;
    int m_width;
    int m_height;
};</pre></div><p>The <code class="literal">parseLevel</code> function<a class="indexterm" id="id416"/> is what <a class="indexterm" id="id417"/>we will call whenever we want to create a level. To ensure that this function must be used to create a <code class="literal">Level</code> object, we will make the <code class="literal">Level</code> class' constructor <a class="indexterm" id="id418"/>private and make it a friend class of <code class="literal">LevelParser</code>:</p><div><pre class="programlisting">private:

  friend class LevelParser;
  Level();</pre></div><p>Now <code class="literal">LevelParser</code> has access to the private constructor of <code class="literal">Level</code> and can return new instances. We can now define the <code class="literal">parseLevel</code> function and then go through it step-by-step. Create <code class="literal">LevelParser.cpp</code> and define the <a class="indexterm" id="id419"/>
<code class="literal">parseLevel</code> function as follows:</p><div><pre class="programlisting">Level* LevelParser::parseLevel(const char *levelFile)
{
    // create a TinyXML document and load the map XML
    TiXmlDocument levelDocument;
    levelDocument.LoadFile(levelFile);

    // create the level object
    Level* pLevel = new Level();

    // get the root node 
    TiXmlElement* pRoot = levelDocument.RootElement();

    pRoot-&gt;Attribute("tilewidth", &amp;m_tileSize);
    pRoot-&gt;Attribute("width", &amp;m_width);
    pRoot-&gt;Attribute("height", &amp;m_height);

    // parse the tilesets
    for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
    {
      if(e-&gt;Value() == std::string("tileset"))
      {
         parseTilesets(e, pLevel-&gt;getTilesets());
      }
    }

    // parse any object layers
    for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
    {
      if(e-&gt;Value() == std::string("layer"))
      {
        parseTileLayer(e, pLevel-&gt;getLayers(), pLevel-&gt;getTilesets());
      }
    }

    return pLevel;
}</pre></div><p>We covered XML<a class="indexterm" id="id420"/> files and TinyXML in the previous chapter<a class="indexterm" id="id421"/> so I won't go into detail again here. The first part of the function grabs the root node:</p><div><pre class="programlisting">// get the root node 
TiXmlElement* pRoot = levelDocument.RootElement();</pre></div><p>We can see from the map file that this node has several attributes:</p><div><pre class="programlisting">&lt;map version="1.0" orientation="orthogonal" width="60" height="15" tilewidth="32" tileheight="32"&gt;</pre></div><p>We grab these values using the <code class="literal">Attribute</code> function from TinyXML and set the member variables of <code class="literal">LevelParser</code>:</p><div><pre class="programlisting">pRoot-&gt;Attribute("tilewidth", &amp;m_tileSize);
pRoot-&gt;Attribute("width", &amp;m_width);
pRoot-&gt;Attribute("height", &amp;m_height);</pre></div><p>Next we must check for any tileset nodes and parse them, using the <code class="literal">getTilesets</code> function of our<a class="indexterm" id="id422"/> newly created <code class="literal">Level</code> instance to pass in the <code class="literal">Tileset</code> vector:</p><div><pre class="programlisting">// parse the tilesets
for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("tileset"))
  {
    parseTilesets(e, pLevel-&gt;getTilesets());
  }
}</pre></div><p>Finally we can check for<a class="indexterm" id="id423"/> any tile layers and then parse them, again using the getter functions from our <code class="literal">pLevel</code> object, which we then return:</p><div><pre class="programlisting">// parse any object layers
for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("layer"))
  {
    parseTileLayer(e, pLevel-&gt;getLayers(), pLevel-&gt;getTilesets());
  }
}

return pLevel;
}</pre></div><p>You can see that this function is very similar to our <code class="literal">parseState</code> function from the previous chapter. Now we must define the <code class="literal">parseTilesets</code> and <code class="literal">parseTileLayer</code> functions.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Parsing tilesets</h2></div></div></div><p>Parsing tilesets <a class="indexterm" id="id424"/>is actually<a class="indexterm" id="id425"/> quite simple due to our <code class="literal">TextureManager</code> class:</p><div><pre class="programlisting">void LevelParser::parseTilesets(TiXmlElement* pTilesetRoot, std::vector&lt;Tileset&gt;* pTilesets)
{
  // first add the tileset to texture manager
    TheTextureManager::Instance()-&gt;load(pTilesetRoot-&gt;FirstChildElement()-&gt;Attribute("source"), pTilesetRoot-&gt;Attribute("name"), TheGame::Instance()-&gt;getRenderer());

  // create a tileset object
  Tileset tileset;
  pTilesetRoot-&gt;FirstChildElement()-&gt;Attribute("width", &amp;tileset.width);
  pTilesetRoot-&gt;FirstChildElement()-&gt;Attribute("height", &amp;tileset.height);
  pTilesetRoot-&gt;Attribute("firstgid", &amp;tileset.firstGridID);
  pTilesetRoot-&gt;Attribute("tilewidth", &amp;tileset.tileWidth);
  pTilesetRoot-&gt;Attribute("tileheight", &amp;tileset.tileHeight);
  pTilesetRoot-&gt;Attribute("spacing", &amp;tileset.spacing);
  pTilesetRoot-&gt;Attribute("margin", &amp;tileset.margin);
  tileset.name = pTilesetRoot-&gt;Attribute("name");

  tileset.numColumns = tileset.width / (tileset.tileWidth + tileset.spacing);

  pTilesets-&gt;push_back(tileset);
}</pre></div><p>We add the tileset<a class="indexterm" id="id426"/> to the <code class="literal">TextureManager</code> class using its attributes <a class="indexterm" id="id427"/>and then create a <code class="literal">Tileset</code> object and push it into the <code class="literal">pTilesets</code> array. The <code class="literal">pTilesets</code> array is actually a pointer to the array from our <code class="literal">pLevel</code> object which we previously created in the <code class="literal">parseLevel</code> function. Here is our first tileset so that you can look at it alongside the preceding function:</p><div><pre class="programlisting">&lt;tileset firstgid="1" name="blocks1" tilewidth="32" tileheight="32"spacing="2" margin="2"&gt;
  &lt;image source="blocks1.png" width="614" height="376"/&gt;
&lt;/tileset&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Parsing a tile layer</h2></div></div></div><p>Due to the compression and<a class="indexterm" id="id428"/> encoding of our tile IDs, this function is <a class="indexterm" id="id429"/>actually quite complicated. We are going to make use of a few different libraries that will help us to decode and decompress our data, the first of which is a<a class="indexterm" id="id430"/> <strong>Base64</strong> decoder. We will be using a decoder created by René Nyffenegger, available from the source code downloads and also from <a class="ulink" href="https://github.com/ReneNyffenegger/development_misc/tree/master/base64">https://github.com/ReneNyffenegger/development_misc/tree/master/base64</a>. The <code class="literal">base64.h</code> and <code class="literal">base64.cpp</code> files can be added directly to the project.</p><p>The second library we will need is the <code class="literal">zlib</code> library, a compiled version is available at <a class="ulink" href="http://www.zlib.net">http://www.zlib.net</a> and can be easily added to your project like any other library. Once these libraries are<a class="indexterm" id="id431"/> available to the project we can start parsing our tiles:</p><div><pre class="programlisting">void LevelParser::parseTileLayer(TiXmlElement* pTileElement, std::vector&lt;Layer*&gt; *pLayers, const std::vector&lt;Tileset&gt;* pTilesets)
{
  TileLayer* pTileLayer = new TileLayer(m_tileSize, *pTilesets);

    // tile data
  std::vector&lt;std::vector&lt;int&gt;&gt; data;

  std::string decodedIDs;
  TiXmlElement* pDataNode;

  for(TiXmlElement* e = pTileElement-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == std::string("data"))
    {
      pDataNode = e;
    }
  }

  for(TiXmlNode* e = pDataNode-&gt;FirstChild(); e != NULL; e = e-&gt;NextSibling())
  {
    TiXmlText* text = e-&gt;ToText();
    std::string t = text-&gt;Value();
    decodedIDs = base64_decode(t);
  }

    // uncompress zlib compression
  uLongf numGids = m_width * m_height * sizeof(int);
  std::vector&lt;unsigned&gt; gids(numGids);
  uncompress((Bytef*)&amp;gids[0], &amp;numGids,(const Bytef*)decodedIDs.c_str(), decodedIDs.size());

  std::vector&lt;int&gt; layerRow(m_width);

  for(int j = 0; j &lt; m_height; j++)
  {
    data.push_back(layerRow);
  }

  for(int rows = 0; rows &lt; m_height; rows++)
  {
    for(int cols = 0; cols &lt; m_width; cols++)
    {
      data[rows][cols] = gids[rows * m_width + cols];
    }
  }

  pTileLayer-&gt;setTileIDs(data);

  pLayers-&gt;push_back(pTileLayer);
}</pre></div><p>Let's go through this function step-by-step. First we create a new <code class="literal">TileLayer</code> instance:</p><div><pre class="programlisting">TileLayer* pTileLayer = new TileLayer(m_tileSize, *pTilesets);</pre></div><p>Next we declare<a class="indexterm" id="id432"/> some needed variables; a multidimensional array of <code class="literal">int</code> values to hold our final decoded and uncompressed tile data, a <code class="literal">std::string</code> that will be our base64 decoded information and <a class="indexterm" id="id433"/>finally a place to store our XML node once we find it:</p><div><pre class="programlisting">// tiledata
std::vector&lt;std::vector&lt;int&gt;&gt; data;

std::string decodedIDs;
TiXmlElement* pDataNode;</pre></div><p>We can search for the node we need in the same way we have previously done:</p><div><pre class="programlisting">for(TiXmlElement* e = pTileElement-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
    if(e-&gt;Value() == std::string("data"))
    {
      pDataNode = e;
    }
}</pre></div><p>Once we have found the correct node we can then get the text from within it (our encoded/compressed data) and use the base64 decoder to decode it:</p><div><pre class="programlisting">for(TiXmlNode* e = pDataNode-&gt;FirstChild(); e != NULL; e = e-&gt;NextSibling())
{
  TiXmlText* text = e-&gt;ToText();
  std::string t = text-&gt;Value();
  decodedIDs = base64_decode(t);
}</pre></div><p>Our <code class="literal">decodedIDs</code> <a class="indexterm" id="id434"/>variable is now a <code class="literal">base64</code> decoded <code class="literal">string</code>. The next step is to use the <code class="literal">zlib</code> library to decompress our data, this is done using the <code class="literal">uncompress</code> function:</p><div><pre class="programlisting">// uncompress zlib compression
uLongf sizeofids = m_width * m_height * sizeof(int);

std::vector&lt;int&gt; ids(m_width * m_height);

uncompress((Bytef*)&amp;ids[0], &amp;sizeofids,(const Bytef*)decodedIDs.c_str(), decodedIDs.size());</pre></div><p>The<a class="indexterm" id="id435"/> <code class="literal">uncompress</code> function <a class="indexterm" id="id436"/>takes an array of <code class="literal">Bytef*</code> (defined in zlib's <code class="literal">zconf.h</code>) as the destination buffer; we are using an <code class="literal">std::vector</code> of <code class="literal">int</code> values and casting it to a <code class="literal">Bytef*</code> array. The second parameter is the total size of the destination buffer, in our case we are using a <code class="literal">vector</code> of <code class="literal">int</code> values making the total size the number of rows x the number of columns x the size of an <code class="literal">int</code>; or <code class="literal">m_width * m_height * sizeof(int)</code>. We then pass in our decoded string and its size as the final two parameters. Our <code class="literal">ids</code> vector now contains all of our tile IDs and the function moves on to set the size of our data vector for us to fill with our tile IDs:</p><div><pre class="programlisting">std::vector&lt;int&gt; layerRow(m_width);
for(int j = 0; j &lt; m_height; j++)
{
  data.push_back(layerRow);
}</pre></div><p>We can now fill our data array with the correct values:</p><div><pre class="programlisting">for(int rows = 0; rows &lt; m_height; rows++)
{
  for(int cols = 0; cols &lt; m_width; cols++)
  {
    data[rows][cols] = ids[rows * m_width + cols];
  }
}</pre></div><p>And finally we set <a class="indexterm" id="id437"/>this layer's tile data and then push the layer into the layers array of our <code class="literal">Level</code>.</p><p>We must now define the functions in our <code class="literal">Level.cpp</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Drawing the map</h2></div></div></div><p>We are finally at a stage where <a class="indexterm" id="id438"/>we can start drawing our tiles to the screen. Inside the earlier created <code class="literal">TileLayer.cpp</code> file we will now need to define our functions for the layer. Starting with the constructor:</p><div><pre class="programlisting">TileLayer::TileLayer(int tileSize, const std::vector&lt;Tileset&gt; &amp;tilesets) : m_tileSize(tileSize), m_tilesets(tilesets), m_position(0,0), m_velocity(0,0)
{
  m_numColumns = (TheGame::Instance()-&gt;getGameWidth() / m_tileSize);
  m_numRows = (TheGame::Instance()-&gt;getGameHeight() / m_tileSize);
}</pre></div><p>The new <a class="indexterm" id="id439"/>
<code class="literal">Game::getGameWidth</code> and <code class="literal">Game::getGameHeight</code> functions<a class="indexterm" id="id440"/> are just simple getter functions that return variables set in the <code class="literal">Game::init</code> function:</p><div><pre class="programlisting">int getGameWidth() const  
{  
  return m_gameWidth;  
}
int getGameHeight() const  
{  
  return m_gameHeight;  
}</pre></div><p>The <a class="indexterm" id="id441"/>
<code class="literal">TileLayer</code> <code class="literal">update</code> function uses <code class="literal">velocity</code> to set the map's position; we will cover this in more detail when we come to scroll our map:</p><div><pre class="programlisting">void TileLayer::update()
{
  m_position += m_velocity;
}</pre></div><p>The <code class="literal">render</code> function is where all the magic happens:</p><div><pre class="programlisting">void TileLayer::render()
{
  int x, y, x2, y2 = 0;

  x = m_position.getX() / m_tileSize;
  y = m_position.getY() / m_tileSize;

  x2 = int(m_position.getX()) % m_tileSize;
  y2 = int(m_position.getY()) % m_tileSize;

  for(int i = 0; i &lt; m_numRows; i++)
  {
    for(int j = 0; j &lt; m_numColumns; j++)
    {
        int id = m_tileIDs[i][j + x];

          if(id == 0)
          {
            continue;
          }

        Tileset tileset = getTilesetByID(id);

        id--;

        TheTextureManager::Instance()-&gt;drawTile(tileset.name, 2, 2, (j * m_tileSize) - x2, (i * m_tileSize) - y2, m_tileSize, m_tileSize, (id - (tileset.firstGridID - 1)) / tileset.numColumns, (id - (tileset.firstGridID - 1)) % tileset.numColumns, TheGame::Instance()-&gt;getRenderer());
    }
  }
}</pre></div><p>You will notice that there<a class="indexterm" id="id442"/> is a new function in the <code class="literal">TextureManager</code>, <code class="literal">drawTile</code>. This function is specifically for drawing tiles and includes margin and spacing values. Here it is:</p><div><pre class="programlisting">void TextureManager::drawTile(std::string id, int margin, int spacing, int x, int y, int width, int height, int currentRow, int currentFrame, SDL_Renderer *pRenderer)
{
  SDL_Rect srcRect;
  SDL_Rect destRect;
  srcRect.x = margin + (spacing + width) * currentFrame;
  srcRect.y = margin + (spacing + height) * currentRow;
  srcRect.w = destRect.w = width;
  srcRect.h = destRect.h = height;
  destRect.x = x;
  destRect.y = y;

  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &amp;srcRect,&amp;destRect, 0, 0, SDL_FLIP_NONE);
}</pre></div><p>Let's look closer<a class="indexterm" id="id443"/> at the <code class="literal">render</code> function; we will ignore the positioning code for now:</p><div><pre class="programlisting">for(int i = 0; i &lt; m_numRows; i++)
{
  for(int j = 0; j &lt; m_numColumns; j++)
  {
    int id = m_tileIDs[i][j + x];

    if(id == 0)
    {
      continue;
    }

    Tilesettileset = getTilesetByID(id);

    id--;

    TheTextureManager::Instance()-&gt;drawTile(tileset.name,tileset.margin, tileset.spacing, (j * m_tileSize) - x2, (i *m_tileSize) - y2, m_tileSize, m_tileSize, (id -(tileset.firstGridID - 1)) / tileset.numColumns, (id -(tileset.firstGridID - 1)) % tileset.numColumns,TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>We loop through the number of columns and the number of rows:</p><div><pre class="programlisting">for(int i = 0; i &lt; m_numRows; i++)
{
  for(int j = 0; j &lt; m_numColumns; j++)
{</pre></div><p>This is not the number of rows and columns in the full tile ID array, it is actually the number of columns and rows needed to fill the size of our game. We do not want to be drawing anything that we do not have to. We obtained these values earlier in the constructor:</p><div><pre class="programlisting">m_numColumns = (TheGame::Instance()-&gt;getGameWidth() / m_tileSize);
m_numRows = (TheGame::Instance()-&gt;getGameHeight() / m_tileSize);</pre></div><p>Next we get the current tile ID from the array (ignore the  <code class="literal">+ x</code> for now):</p><div><pre class="programlisting">int id = m_tileIDs[i + y][j + x];</pre></div><p>We check if the tile ID is 0. If it is, then we do not want to draw anything:</p><div><pre class="programlisting">if(id == 0)
{
  continue;
}</pre></div><p>Otherwise we grab the correct tileset:</p><div><pre class="programlisting">Tileset tileset = getTilesetByID(id);</pre></div><p>Getting the tileset uses a very simple function, <code class="literal">getTilesetByID</code>, which compares each tileset's <code class="literal">firstgid</code> value and returns the correct tileset:</p><div><pre class="programlisting">Tileset TileLayer::getTilesetByID(int tileID)
{
  for(int i = 0; i &lt; m_tilesets.size(); i++)
  {
    if( i + 1 &lt;= m_tilesets.size() - 1)
    {
      if(tileID &gt;= m_tilesets[i].firstGridID&amp;&amp;tileID &lt; m_tilesets[i + 1].firstGridID)
      {
        return m_tilesets[i];
      }
    }
    else
    {
      return m_tilesets[i];
    }
  }

  std::cout &lt;&lt; "did not find tileset, returning empty tileset\n";
  Tileset t;
  return t;
}</pre></div><p>Next we move on to drawing the tiles:</p><div><pre class="programlisting">id--;

TheTextureManager::Instance()-&gt;drawTile(tileset.name, 
  tileset.margin, tileset.spacing, (j * m_tileSize) - x2, (i * 
  m_tileSize) - y2, m_tileSize, m_tileSize, (id - 
  (tileset.firstGridID - 1)) / tileset.numColumns, (id - 
  (tileset.firstGridID - 1)) % tileset.numColumns, 
    TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>First we decrement the <a class="indexterm" id="id444"/>ID so that we can draw the correct tile from the tilesheet, even if it is at position <code class="literal">0,0</code>. We then use the <code class="literal">drawTile</code> function to copy across the correct tile using the tileset we grabbed earlier, to set the first parameter of the function, which is the <code class="literal">name</code> of the texture. Again, we can use the tileset for the next two parameters, <code class="literal">margin</code> and <code class="literal">spacing</code>:</p><div><pre class="programlisting">tileset.margin, tileset.spacing</pre></div><p>The next two parameters set the position we want to draw our tiles at:</p><div><pre class="programlisting">(j * m_tileSize) - x2, (i * m_tileSize) - y2</pre></div><p>Ignoring the <code class="literal">x2</code> and <code class="literal">y2</code> values for now (they are 0 anyway), we can set the current <code class="literal">x</code> position as the current column multiplied by the width of a tile and the <code class="literal">y</code> value as the current row multiplied by the height of a tile. We then set the width and height of the tile we are copying across:</p><div><pre class="programlisting">m_tileSize, m_tileSize,</pre></div><p>And finally we work out the location of the tile on the tilesheet:</p><div><pre class="programlisting">(id - (tileset.firstGridID - 1)) / tileset.numColumns, 
(id - (tileset.firstGridID - 1)) % tileset.numColumns,</pre></div><p>We subtract the <code class="literal">firstGridID - 1</code> to allow us to treat each tilesheet the same and obtain the correct location. For example, the <code class="literal">firstGridID</code> of a tileset could be 50 and the current tile ID could be 70. We know that this is actually going to be tile 19 (after we decrement the ID) on the tilesheet itself.</p><p>Finally, we must create a level in our <code class="literal">PlayState</code> class:</p><div><pre class="programlisting">bool PlayState::onEnter()
{
  LevelParser levelParser;
  pLevel = levelParser.parseLevel("assets/map1.tmx");

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}</pre></div><p>Next, draw it in the<a class="indexterm" id="id445"/> <code class="literal">render</code> function, and also do the same with the <code class="literal">update</code> function:</p><div><pre class="programlisting">void PlayState::render()
{
  pLevel-&gt;render();
}</pre></div><p>We will also have to comment out any functions that use objects (such as <code class="literal">collisionChecks</code>) as we don't have any yet and this will cause a runtime error. Run our game and you<a class="indexterm" id="id446"/> will see our tile map being drawn to the screen.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Scrolling a tile map</h1></div></div></div><p>What we have created so far is fine for a game that takes place in one area that is the size of our window, but what about if we want to have large maps that are open to exploration. This is <a class="indexterm" id="id447"/>where scrolling comes into play. We have actually implemented this already but have not yet gone through it step-by-step or seen it in action. Let's do this now.</p><p>First of all, we must resize our map in the Tiled application. Navigating to <strong>Map</strong> | <strong>Resize Map…</strong> will allow us to do this. Leave the height of our map at 15 and change the width to 60. Fill up the remaining squares with whatever tiles you like. The map would then look like the following screenshot:</p><div><img alt="Scrolling a tile map" src="img/6821OT_07_12.jpg"/></div><p>Save the map and we can look at the code:</p><div><pre class="programlisting">int x, y, x2, y2 = 0;

x = m_position.getX() / m_tileSize;
y = m_position.getY() / m_tileSize;

x2 = int(m_position.getX()) % m_tileSize;
y2 = int(m_position.getY()) % m_tileSize;</pre></div><p>When scrolling the map we don't actually move it more than a tile width; we use the position value to work out where we should begin drawing our map from within the tile ID array. To get the <code class="literal">x</code> value we can use the position we have moved to divided by the tile width. For example, let's say that we have moved the map to <code class="literal">x position = 100</code> and the tile width is 32; this <a class="indexterm" id="id448"/>would give us a value of 3.125, but since we are using <code class="literal">int</code> values, this will simply be 3. We now know that we are to start drawing from the third tile across on the map. The <code class="literal">y</code> position works in the same way.</p><p>To ensure that our tile drawing does not jump between tiles, but smoothly scrolls, we use a modulo calculation to get the remaining tile amount that we need to move by and use that to position our map:</p><div><pre class="programlisting">x2 = int(m_position.getX()) % m_tileSize;
y2 = int(m_position.getY()) % m_tileSize;</pre></div><p>We then subtract these values in the <code class="literal">draw</code> function:</p><div><pre class="programlisting">(j * m_tileSize) - x2, (i * m_tileSize) - y2</pre></div><p>We can test this by setting a velocity in our layers <code class="literal">update</code> function:</p><div><pre class="programlisting">void TileLayer::update()
{
  m_position += m_velocity;
  m_velocity.setX(1);
}</pre></div><p>And then in <code class="literal">PlayState</code> we can call this function:</p><div><pre class="programlisting">void PlayState::update()
{
  pLevel-&gt;update();
}</pre></div><p>Run the game and you will see the map scrolling. At the moment we have not put any kind of handling in for<a class="indexterm" id="id449"/> looping the map or stopping at the end. We will cover this when we begin to create a game in later chapters.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Parsing object layers</h1></div></div></div><p>The final topic <a class="indexterm" id="id450"/>we will cover in this chapter is loading objects from our Tiled map file. This is extremely useful and takes the guesswork out of placing objects within a level. Open up the Tiled application and we can create our first <strong>Object Layer</strong>
<a class="indexterm" id="id451"/> by clicking <strong>Layer</strong> | <strong>Add Object Layer</strong>. This will create a new layer called <strong>Object Layer 1</strong> as shown in the following screenshot:</p><div><img alt="Parsing object layers" src="img/6821OT_07_13.jpg"/></div><p>We can create objects and assign any values and properties we want on these layers. First we will create a rectangle. Press <em>R</em> and click anywhere on your tile map, you will see a small square appear, as shown in the following screenshot:</p><div><img alt="Parsing object layers" src="img/6821OT_07_14.jpg"/></div><p>Right-click on<a class="indexterm" id="id452"/> this square and click on <strong>Object Properties…</strong>. This will bring up the object properties dialog as shown in the following screenshot:</p><div><img alt="Parsing object layers" src="img/6821OT_07_15.jpg"/></div><p>Here, we can set the values we want our object to have, just like our previous state XML files. Go ahead and fill in the dialog box as shown in the preceding screenshot. The positions and sizes of this<a class="indexterm" id="id453"/> dialog box deal in tiles, not pixels, so <code class="literal">x = 1</code> is actually <code class="literal">x = tile width</code> and so on. Saving this map will add our new object layer to the map file:</p><div><pre class="programlisting">&lt;objectgroup name="Object Layer 1" width="60" height="15"&gt;
  &lt;object name="Helicopter1" type="Player" x="32" y="32" width="32 height="32"&gt;
    &lt;properties&gt;
      &lt;property name="numFrames" value="4"/&gt;
      &lt;property name="textureHeight" value="55"/&gt;
      &lt;property name="textureID" value="helicopter"/&gt;
      &lt;property name="textureWidth" value="128"/&gt;
    &lt;/properties&gt;
  &lt;/object&gt;
&lt;/objectgroup&gt;</pre></div><p>We are also going to use another property list to load in our textures for this map. <strong>Map</strong> | <strong>Map Properties</strong> will bring up the map properties dialog as shown in the following screenshot:</p><div><img alt="Parsing object layers" src="img/6821OT_07_16.jpg"/></div><p>Here we can add <a class="indexterm" id="id454"/>the textures we need for this map's objects. The saved file will now have an additional property list for us to parse through:</p><div><pre class="programlisting">&lt;properties&gt;
  &lt;property name="helicopter" value="helicopter.png"/&gt;
&lt;/properties&gt;</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Developing the ObjectLayer class</h2></div></div></div><p>Back in our project <a class="indexterm" id="id455"/>we will now create a new layer type called <code class="literal">ObjectLayer</code>. Create <code class="literal">ObjectLayer.h</code> and we can add the following code:</p><div><pre class="programlisting">class ObjectLayer : public Layer
{
  public:
  virtual void update();
  virtual void render();

  std::vector&lt;GameObject*&gt;* getGameObjects()  
  {  
    return &amp;m_gameObjects;  
  }

  private:

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>We will also define these functions in <code class="literal">ObjectLayer.cpp</code>:</p><div><pre class="programlisting">void ObjectLayer::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }

}
void ObjectLayer::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}</pre></div><p>Our <code class="literal">ObjectLayer</code> class is very simple. It only needs to draw and update the objects for that layer. Now let's parse <a class="indexterm" id="id456"/>our <code class="literal">ObjectLayer</code>. We will need two new functions in the <code class="literal">LevelParser</code> class:</p><div><pre class="programlisting">void parseTextures(TiXmlElement* pTextureRoot);

void parseObjectLayer(TiXmlElement* pObjectElement,std::vector&lt;Layer*&gt; *pLayers);</pre></div><p>The <a class="indexterm" id="id457"/>
<code class="literal">parseLevel</code> function must now include these functions and pass in the correct XML node:</p><div><pre class="programlisting">// we must parse the textures needed for this level, which have been added to properties
for(TiXmlElement* e = pProperties-&gt;FirstChildElement(); e != NULL;e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("property"))
  {
  parseTextures(e);
  }
}</pre></div><p>We will alter the way we were searching for tile layers to also search for object layers:</p><div><pre class="programlisting">// parse any object layers
for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("objectgroup") || e-&gt;Value() == std::string("layer"))
  {
    if(e-&gt;FirstChildElement()-&gt;Value() == std::string("object"))
    {
      parseObjectLayer(e, pLevel-&gt;getLayers());
    }
    else if(e-&gt;FirstChildElement()-&gt;Value() == std::string("data"))
    {
      parseTileLayer(e, pLevel-&gt;getLayers(), pLevel-&gt;getTilesets());
    }
  }
}</pre></div><p>Now we need to define the new functions; <code class="literal">parseTextures</code> is a very small and simple function:</p><div><pre class="programlisting">void LevelParser::parseTextures(TiXmlElement* pTextureRoot)
{
  TheTextureManager::Instance()-&gt;load(pTextureRoot-&gt;Attribute("value"), pTextureRoot-&gt;Attribute("name"), TheGame::Instance()-&gt;getRenderer());
}</pre></div><p>It gets the texture <a class="indexterm" id="id458"/>values and adds them to the <code class="literal">TextureManager</code>. The<a class="indexterm" id="id459"/> <code class="literal">parseObjects</code> function is a little longer but not particularly complicated:</p><div><pre class="programlisting">void LevelParser::parseObjectLayer(TiXmlElement* pObjectElement, std::vector&lt;Layer*&gt; *pLayers)
{
    // create an object layer
  ObjectLayer* pObjectLayer = new ObjectLayer();

  std::cout &lt;&lt; pObjectElement-&gt;FirstChildElement()-&gt;Value();

  for(TiXmlElement* e = pObjectElement-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
    {
      std::cout &lt;&lt; e-&gt;Value();
      if(e-&gt;Value() == std::string("object"))
      {
        int x, y, width, height, numFrames, callbackID, animSpeed;
        std::string textureID;

        // get the initial node values type, x and y
        e-&gt;Attribute("x", &amp;x);
        e-&gt;Attribute("y", &amp;y);
        GameObject* pGameObject = TheGameObjectFactory::Instance()-&gt;create(e-&gt;Attribute("type"));

        // get the property values
        for(TiXmlElement* properties = e-&gt;FirstChildElement(); properties != NULL; properties = properties-&gt;NextSiblingElement())
        {
          if(properties-&gt;Value() == std::string("properties"))
          {
            for(TiXmlElement* property = properties-&gt;FirstChildElement(); property != NULL; property = property-&gt;NextSiblingElement())
            {
              if(property-&gt;Value() == std::string("property"))
              {
                if(property-&gt;Attribute("name") == std::string("numFrames"))
                  {
                    property-&gt;Attribute("value", &amp;numFrames);
                  }
                else if(property-&gt;Attribute("name") == std::string("textureHeight"))
                {
                  property-&gt;Attribute("value", &amp;height);
                }
                else if(property-&gt;Attribute("name") == std::string("textureID"))
                {
                  textureID = property-&gt;Attribute("value");
                }
                else if(property-&gt;Attribute("name") == std::string("textureWidth"))
                {
                  property-&gt;Attribute("value", &amp;width);
                }
                else if(property-&gt;Attribute("name") == std::string("callbackID"))
                {
                  property-&gt;Attribute("value", &amp;callbackID);
                }
                else if(e-&gt;Attribute("name") == std::string("animSpeed"))
                {
                  property-&gt;Attribute("value", &amp;animSpeed);
                }
              }
            }
          }
        }
        pGameObject-&gt;load(newLoaderParams(x, y, width, height, textureID, numFrames, callbackID, animSpeed));
      pObjectLayer-&gt;getGameObjects()-&gt;push_back(pGameObject);
    }
  }

  pLayers-&gt;push_back(pObjectLayer);
}</pre></div><p>We load the object in a very similar way to the state parser, yet this time we must check for the <code class="literal">name</code> of the<a class="indexterm" id="id460"/> property rather than grabbing the <code class="literal">attribute</code> directly:</p><div><pre class="programlisting">if(property-&gt;Attribute("name") == std::string("numFrames"))
{
  property-&gt;Attribute("value", &amp;numFrames);
}</pre></div><p>We can then create the object just like the state parser:</p><div><pre class="programlisting">pGameObject-&gt;load(new LoaderParams(x,y,width,height,textureID,numFrames,callbackID, animSpeed));</pre></div><p>And add it to this layer's game object array:</p><div><pre class="programlisting">pObjectLayer-&gt;getGameObjects()-&gt;push_back(pGameObject);</pre></div><p>Once we have loaded all of the objects for this layer, we can push it into our <code class="literal">Level</code> layer array:</p><div><pre class="programlisting">pLayers-&gt;push_back(pObjectLayer);</pre></div><p>Run the game and you<a class="indexterm" id="id461"/> will see our helicopter in the <code class="literal">PlayState</code> again.</p><div><img alt="Developing the ObjectLayer class" src="img/6821OT_07_17.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Summary</h1></div></div></div><p>We are getting closer to a fully-fledged game all the time. This chapter covered a quick way to create 2D maps through the use of tiles and also looked at using an external application to place objects within our levels. The next two chapters will tie up all of the remaining loose ends and we will create some actual games.</p></div></body></html>