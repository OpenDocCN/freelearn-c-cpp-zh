<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Introducing Lua!</h1></div></div></div><p class="calibre6">
<em class="calibre8">In our last game, we'll move to the new Cocos IDE and develop an entire game using the Lua scripting language. You'll get to know and use the Lua bindings for the Cocos2d-x API, which is not much different from what we've been using in C++; if anything, it's just a lot easier!</em>
</p><p class="calibre6">This time, you'll learn how to:</p><div><ul class="itemizedlist"><li class="listitem">Create and publish a project in Cocos IDE</li><li class="listitem">Code an entire game in Lua</li><li class="listitem">Use sprites, particles, labels, menus, and actions, but this time with the Lua bindings</li><li class="listitem">Build a match-three game</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec138" class="calibre1"/>So what is Lua like?</h1></div></div></div><p class="calibre6">At the<a id="id376" class="calibre1"/> heart of Lua (which means moon in Portuguese), you have the table. You may think of it as being similar to a JavaScript object, only it's much more than that. It plays the part of arrays, dictionaries, enumerations, structures, and classes, among other things. It makes Lua the perfect language to manage large sets of data. You write a script that handles the data, and then keep feeding it different "stuff." An inventory or shop system, an interactive children's book—these types of projects could all benefit from Lua's table-centric power, as they can be built around a fixed template with a data table at its core.</p><p class="calibre6">Its syntax, for those not used to a scripting language, can be a little odd, with its dos, thens, and ends. But once you get past this initial hurdle, you'll find Lua quite user-friendly. Here are some of the "oddities" in its syntax:</p><div><pre class="programlisting">-- a comment
--[[ 
a 
multiline 
comment 
]]
-- a table declared as a local variable
local myTable = {}
-- the length of a table
local len = #myTable
-- looping the table (starting with index 1!)
for i = 1, #myTable do
   local element = myTable[i]
   -- an if elseif else statement
   if (element ~= true ) then
      -- do something
   elseif (element == true) then
      -- do something else
   else
      -- we'll never get here!   
   end
end</pre></div><div><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre6">Semicolons are optional.</p></div><p class="calibre6">A table <a id="id377" class="calibre1"/>can be turned into a template to generate instances of it, in other words, a class. Methods of the instance of the table must be accessed with a <code class="email">:</code> notation:</p><div><pre class="programlisting">myTableClassObject:myMethod()</pre></div><p class="calibre6">From inside the method, you refer to the instance of the class as <code class="email">self</code>:</p><div><pre class="programlisting">self.myProperty = 1
self:myOtherMethod()</pre></div><p class="calibre6">Alternatively, you can call the template's method with a dot notation, passing the instance of that template to it as the first parameter:</p><div><pre class="programlisting">myTableClassObject.myMethod(myTableClassObject)</pre></div><p class="calibre6">I admit, it's weird, but it can be useful at times as pretty much every method you write in Lua can be made available for other parts of your code—sort of the way static methods are used in traditional OOP languages.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec127" class="calibre1"/>Debugging in Lua – the knights who say nil</h2></div></div></div><p class="calibre6">Debugging<a id="id378" class="calibre1"/> your Lua code can be frustrating at times. But you soon learn to distinguish between the minute subtleties in Lua's runtime errors. The compiler will say something is <code class="email">nil</code> (Lua's <code class="email">null</code>) in about 99.9 percent of cases. It's up to you to figure out why. Here are the main culprits:</p><div><ul class="itemizedlist"><li class="listitem">You are referencing an object's own property without prepending <code class="email">self.</code> or <code class="email">self:</code>.</li><li class="listitem">You are calling an instance method with a dot notation, and not passing the instance as the first parameter; something like <code class="email">myObject.myMethod()</code> instead of <code class="email">myObject.myMethod(myObject)</code>. Use <code class="email">myObject:myMethod()</code> instead.</li><li class="listitem">You <a id="id379" class="calibre1"/>are referencing a variable from a place outside its scope. For example, a local variable declared inside an <code class="email">if</code> statement is being referenced outside the conditional.</li><li class="listitem">You forgot to return the class object at the end of your class or module/table declaration.</li><li class="listitem">You tried to access the zero index of an array.</li><li class="listitem">You forgot to add a few dos and thens or ends.</li><li class="listitem">And finally, maybe you're just having one of those days. A <code class="email">nil</code> sort of day.</li></ul></div><p class="calibre6">The Cocos IDE will show errors in bold; the same bold it uses for global variables, which is confusing at times. But it helps nonetheless. Just make a habit of scanning your code for bold text!</p><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre6">You might need to increase the heap memory inside the IDE. The quickest way to accomplish this is to find the file called <code class="email">eclipse.ini</code> inside the Cocos IDE application folder. On a Mac, this means inside the Cocos IDE app package: right-click on the app icon, select <strong class="calibre7">Show Package Contents</strong>, and then navigate to <strong class="calibre7">Contents/MacOS/eclipse.ini</strong>.</p><p class="calibre6">Then find the line where you read <code class="email">-Xmx256m</code> or <code class="email">-Xmx512m</code> and change it to <code class="email">-Xmx1024m</code>.</p><p class="calibre6">This might help in slower computers. My laptop crashed a lot while running the IDE.</p></div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec139" class="calibre1"/>The game – Stone Age</h1></div></div></div><p class="calibre6">This is <a id="id380" class="calibre1"/>a match-three game. You know, the kind of game that is making a couple of companies a gazillion dollars and making a gazillion other companies clone those games in order to earn a couple of dollars. Yes, that game!</p><p class="calibre6">You must match three or more gems. If you match more than three, a random gem bursts and turns into a diamond, which you collect for more points.</p><p class="calibre6">The game has a timer, and when time runs out, it's game over.</p><p class="calibre6">I used pretty much the same structure as in the previous games in this book. But I broke it into separate modules so it's easier for you to use the code as a reference.</p><p class="calibre6">We have a <code class="email">MenuScene</code> and a <code class="email">GameScene</code> item. I have pretty much all Cocos2d-x actions in one module called <code class="email">GridAnimations</code> and most of the interactivity inside another module called <code class="email">GridController</code>. And all object pools are kept inside a class called <code class="email">ObjectPools</code>.</p><p class="calibre6">This is<a id="id381" class="calibre1"/> a grid game, so it's perfect to illustrate working with table arrays in Lua, and its main advantages over C++: it's much easier to create and memory manage dynamic lists (arrays) in Lua. This flexibility, aligned with Cocos2d-x's awesomeness, make for very rapid prototyping and development. The actual game will look like this:</p><div><img src="img/00039.jpeg" alt="The game – Stone Age" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">But before you import the starter project, let me show you how to create a new project inside the Cocos IDE.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec140" class="calibre1"/>Time for action – creating or importing a project</h1></div></div></div><p class="calibre6">Nothing<a id="id382" class="calibre1"/> could be simpler; since the IDE is based on<a id="id383" class="calibre1"/> Eclipse, you know most of its main functionalities already:</p><div><ol class="orderedlist"><li class="listitem" value="1">First let's set up the IDE to use the Lua bindings. Go to <strong class="calibre7">Preferences</strong> | <strong class="calibre7">Cocos</strong> | <strong class="calibre7">Lua</strong>, and in the drop-down menu for <strong class="calibre7">Lua Frameworks</strong>, find the Cocos2d-x framework folder you downloaded:<div><img src="img/00040.jpeg" alt="Time for action – creating or importing a project" class="calibre9"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Select <strong class="calibre7">File</strong> | <strong class="calibre7">New</strong> | <strong class="calibre7">Cocos Lua Project</strong>, if that option is already available, or select <strong class="calibre7">File</strong> | <strong class="calibre7">New</strong> | <strong class="calibre7">Other</strong> | <strong class="calibre7">Cocos Lua</strong> | <strong class="calibre7">Cocos Lua Project</strong>.</li><li class="listitem" value="3">In <a id="id384" class="calibre1"/>the <strong class="calibre7">New Cocos Project</strong> wizard, give<a id="id385" class="calibre1"/> your project a name and click <strong class="calibre7">Next</strong>.</li><li class="listitem" value="4">In the next dialogue, you can choose your project's orientation and design size. And that's it. Click <strong class="calibre7">Finish</strong>.</li><li class="listitem" value="5">In order to import a project, click <strong class="calibre7">File</strong> | <strong class="calibre7">Import</strong> then <strong class="calibre7">Cocos</strong> | <strong class="calibre7">Import Cocos Project</strong>, and navigate to the project start folder for this chapter. The game is called <code class="email">StoneAge</code>. (Download this chapter's source files from this book's website if you haven't done so already. There is a starter project and a final project that you can run and test.)</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec128" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You learned to create and import a project into the Cocos IDE. Since the IDE is an Eclipse-based program, the steps should be familiar to you by now.</p><p class="calibre6">You may also wish to change the settings for the simulator. For that, all you need to do is right-click on your project and select either <strong class="calibre7">Run As...</strong> or <strong class="calibre7">Debug As...</strong>, and then <strong class="calibre7">Run</strong> or <strong class="calibre7">Debug Configurations</strong>. </p><p class="calibre6">It's best to leave the default for the <strong class="calibre7">Mac OSX</strong> runtime (if you're on a Mac of course), as this is the fastest option. But if you wish to change the simulator, here is where you do it:</p><div><img src="img/00041.jpeg" alt="What just happened?" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre6">On <a id="id386" class="calibre1"/>my machine, version 3.4 of the framework<a id="id387" class="calibre1"/> threw compile errors. I had to add two fixes in order to run Stone Age. In <code class="email">cocos-cocos2d-Cocos2dConstants.lua</code>, just before the last table is declared, I added this line:</p><div><pre class="programlisting">cc.AsyncTaskPool = {}</pre></div><p class="calibre6">Similarly, in <code class="email">cocos-ui-GuiConstants.lua</code>, I added <code class="email">ccui.LayoutComponent = {}</code> before new tables are added to <code class="email">LayoutComponent</code>, also near the end of the file.</p><p class="calibre6">If you run into problems, switch to version 3.3, which was much more stable for Lua development.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec141" class="calibre1"/>Time for action – setting up our screen resolution</h1></div></div></div><p class="calibre6">The<a id="id388" class="calibre1"/> old <code class="email">AppDelegate</code> class logic now exists inside a file called <code class="email">main.lua</code>:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the IDE, open the <code class="email">main.lua</code> file inside the <code class="email">src</code> folder.</li><li class="listitem" value="2">After the line where we set the animation interval, type the following:<div><pre class="programlisting">cc.Director:getInstance():getOpenGLView(): setDesignResolutionSize(640, 960,  cc.ResolutionPolicy.SHOW_ALL)
   local screenSize =  cc.Director:getInstance():getVisibleSize()
   local designSize = cc.size(640, 960)
   if (screenSize.width &gt; 320) then
     cc.Director:getInstance():setContentScaleFactor(640/   designSize.width)       
     cc.FileUtils:getInstance():addSearchPath("res/hd/") 
   else
     cc.Director:getInstance():setContentScaleFactor(320/designSize.width)
     cc.FileUtils:getInstance():addSearchPath("res/sd/")         
   end</pre></div></li><li class="listitem" value="3">I designed <a id="id389" class="calibre1"/>the game for iPhone retina, and here we set the appropriate scale and asset folder for both retina and non-retina phones. Next, let's preload the sound files:<div><pre class="programlisting">       local bgMusicPath =  cc.FileUtils:getInstance():fullPathForFilename("background.mp3") 
       cc.SimpleAudioEngine:getInstance():preloadMusic(bgMusicPath)    
       local effectPath =  cc.FileUtils:getInstance():fullPathForFilename("match.wav")
       cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)
   effectPath =  cc.FileUtils:getInstance():fullPathForFilename("diamond.wav")
       cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)
       effectPath =  cc.FileUtils:getInstance():fullPathForFilename("diamond2.wav")
       cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)
       effectPath =  cc.FileUtils:getInstance():fullPathForFilename("wrong.wav")
   cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)</pre></div></li><li class="listitem" value="4">And finally, let's set the ball rolling by creating and running our first scene:<div><pre class="programlisting">--create scene 
local scene = require("MenuScene")
local menuScene = scene.create()
if cc.Director:getInstance():getRunningScene() then
        cc.Director:getInstance():replaceScene(menuScene)
    else
        cc.Director:getInstance():runWithScene(menuScene)
    end</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec129" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">Like we've done in pretty much every game so far, we set the resolution policy and scale factor for our application and preloaded the sounds we'll be using.</p><p class="calibre6">The<a id="id390" class="calibre1"/> game was designed only for phones this time, and it was designed with the iPhone 4 screen in mind, and it resizes to older phones.</p><p class="calibre6">But don't run the game just yet. Let's create our menu scene. It has a little of everything in it and it will be a perfect introduction to the Cocos2d-x API in Lua.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec142" class="calibre1"/>Time for action – creating a menu scene</h1></div></div></div><p class="calibre6">Let's <a id="id391" class="calibre1"/>create a new file and add a menu scene to our game:</p><div><ol class="orderedlist"><li class="listitem" value="1">Right-click on the <code class="email">src</code> folder and select <strong class="calibre7">New</strong> | <strong class="calibre7">Lua File</strong>; call the new file <code class="email">MenuScene.lua</code>.</li><li class="listitem" value="2">Let's create a class that extends a scene. We first load our own module of all the game's constants (this file already exists in the starter project):<div><pre class="programlisting">local constants = require ("constants")</pre></div></li><li class="listitem" value="3">Then we build our class:<div><pre class="programlisting">local MenuScene = class("MenuScene", function()
    return cc.Scene:create()
end)

function MenuScene.create()
    local scene = MenuScene.new()
    return scene
end

function MenuScene:ctor()
    self.visibleSize =  cc.Director:getInstance():getVisibleSize()
    self.middle = {x = self.visibleSize.width * 0.5,  y = self.visibleSize.height * 0.5}
    self.origin = cc.Director:getInstance():getVisibleOrigin()
    self:init()
end
return MenuScene</pre></div><p class="calibre13">We'll add the methods next, including the <code class="email">init</code> method we called in the class constructor (always called <code class="email">ctor</code>), but I wanted to stress the importance of returning the class at the end of its declaration.</p></li><li class="listitem" value="4">So moving just below the constructor, let's continue building up our scene:<div><pre class="programlisting">function MenuScene:init ()
    local bg = cc.Sprite:create("introbg.jpg")
    bg:setPosition(self.middle.x, self.middle.y)
    self:addChild(bg)
    --create pterodactyl animation
   local pterodactyl = cc.Sprite:create("ptero_frame1.png")
   pterodactyl:setPosition(cc.p(self.visibleSize.width + 100,  self.visibleSize.height * 0.8))
   self:addChild(pterodactyl)
   local animation = cc.Animation:create()
   local number, name
   for i = 1, 3 do
     number = i
     name = "ptero_frame"..number..".png"
     animation:addSpriteFrameWithFile(name)
   end
   animation:setDelayPerUnit(0.5 / 3.0)
   animation:setRestoreOriginalFrame(true)
   animation:setLoops(-1)
   local animate = cc.Animate:create(animation)
   pterodactyl:runAction( animate )
   local moveOut = cc.MoveTo:create(0, cc.p(self.visibleSize.width + 100, self.visibleSize.height *  0.8))
   local moveIn = cc.MoveTo:create(4.0, cc.p(-100,  self.visibleSize.height * 0.8))
   local delay = cc.DelayTime:create(2.5)
pterodactyl:runAction(cc.RepeatForever:create (cc.Sequence:create(moveOut, moveIn, delay) ) )
    local character = cc.Sprite:create("introCharacter.png")
    character:setPosition(self.middle.x, self.middle.y + 110)
    self:addChild(character)
    local frame = cc.Sprite:create("frame.png")
    frame:setPosition(self.middle.x, self.middle.y)
    self:addChild(frame)    
end</pre></div><p class="calibre13">With this, we added a background and two other sprites, plus an animation of a pterodactyl flying in the background. Once again, the calls are remarkably similar to the ones in C++.</p></li><li class="listitem" value="5">Now let's<a id="id392" class="calibre1"/> add a menu with a play button (all this still inside the <code class="email">init</code> method):<div><pre class="programlisting">--create play button
local function playGame()
   local bgMusicPath =    cc.FileUtils:getInstance():fullPathForFilename("background.mp3") 
   cc.SimpleAudioEngine:getInstance():playMusic(bgMusicPath, true)
   local scene = require("GameScene")
   local gameScene = scene.create()
   cc.Director:getInstance():replaceScene(gameScene)
end

local btnPlay = cc.MenuItemImage:create("playBtn.png",  "playBtnOver.png")
btnPlay:setPosition(0,0)
btnPlay:registerScriptTapHandler(playGame)
local menu  = cc.Menu:create(btnPlay)
menu:setPosition(self.middle.x, 80)
self:addChild(menu)</pre></div></li></ol><div></div><p class="calibre6">Typing<a id="id393" class="calibre1"/> the button's callback inside the same method where the callback is referenced is similar to writing a block or even a lambda function in C++.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec130" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You created a scene in Lua with Cocos2d-x using a menu, a few sprites, and an animation. It's easy to see how similar the calls are in the Lua bindings to the original C++ ones. And with code completion inside the IDE, finding the correct methods is a breeze.</p><p class="calibre6">Now let's tackle the <code class="email">GameScene</code> class.</p><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre6">One of the nicest features of Lua is something called <strong class="calibre7">live coding</strong>, and it's switched<a id="id394" class="calibre1"/> on by default in the Cocos IDE. To see what I mean by live coding, do this: while the game is running in the simulator, change the position of the character sprite in your code and save it. You should see the change taking effect in the simulator. This is a great way to build UI and game scenes.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec143" class="calibre1"/>Time for action – creating our game scene</h1></div></div></div><p class="calibre6">The <code class="email">GameScene</code> class is already added to the start project and some of the code is already in place. We'll <a id="id395" class="calibre1"/>focus first on building the game's interface and listening to touches:</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's work on the <code class="email">addTouchEvents</code> method:<div><pre class="programlisting">function GameScene:addTouchEvents()
    local bg = cc.Sprite:create("background.jpg")
    bg:setPosition(self.middle.x, self.middle.y)
    self:addChild(bg)
   
    local function onTouchBegan(touch, event)
        self.gridController:onTouchDown(touch:getLocation())
        return true
    end

    local function onTouchMoved(touch, event)
        self.gridController:onTouchMove(touch:getLocation())
    end

    local function onTouchEnded(touch, event)
        self.gridController:onTouchUp(touch:getLocation())
    end

    local listener = cc.EventListenerTouchOneByOne:create()
       listener:registerScriptHandler (onTouchBegan,cc.Handler.EVENT_TOUCH_BEGAN )
   listener:registerScriptHandler (onTouchMoved,cc.Handler.EVENT_TOUCH_MOVED )
    listener:registerScriptHandler (onTouchEnded,cc.Handler.EVENT_TOUCH_ENDED )
    local eventDispatcher = bg:getEventDispatcher()
       eventDispatcher:addEventListenerWithSceneGraphPriority (listener, bg)
end</pre></div></li><li class="listitem" value="2">Once <a id="id396" class="calibre1"/>again, we register the events with the node's instance of the event dispatcher. The actual touches are handled by our <code class="email">GridController</code> object. We'll go over those later; first, let's build the UI. Time to work on the <code class="email">init</code> method:<div><pre class="programlisting">function GameScene:init ()
    self.gridController = GridController:create()
    self.gridAnimations = GridAnimations:create()
    self.objectPools = ObjectPools.create()
    
    self.gridAnimations:setGameLayer(self)
    self.gridController:setGameLayer(self)
    self.objectPools:createPools(self)</pre></div><p class="calibre13">Create our special objects, one to handle user interactivity, another for animations, and our good old object pool.</p></li><li class="listitem" value="3">Next, we add a couple of nodes and our score labels:<div><pre class="programlisting">self:addChild( self.gemsContainer )
self.gemsContainer:setPosition( 25, 80)
--build interface
local frame = cc.Sprite:create("frame.png")
frame:setPosition(self.middle.x, self.middle.y)
self:addChild(frame)
local diamondScoreBg = cc.Sprite:create("diamondScore.png")
diamondScoreBg:setPosition(100, constants.SCREEN_HEIGHT - 30)
self:addChild(diamondScoreBg)
local scoreBg = cc.Sprite:create("gemsScore.png")
scoreBg:setPosition(280, constants.SCREEN_HEIGHT - 30)
self:addChild(scoreBg)
local ttfConfig = {}
ttfConfig.fontFilePath="fonts/myriad-pro.ttf"
ttfConfig.fontSize=20
self.diamondScoreLabel = cc.Label:createWithTTF(ttfConfig,  "0", cc.TEXT_ALIGNMENT_RIGHT , 150)    
self.diamondScoreLabel:setPosition  (140, constants.SCREEN_HEIGHT - 30)
self:addChild(self.diamondScoreLabel)
self.scoreLabel = cc.Label:createWithTTF(ttfConfig,  "0", cc.TEXT_ALIGNMENT_RIGHT , 150)    
self.scoreLabel:setPosition (330, constants.SCREEN_HEIGHT - 30)
self:addChild(self.scoreLabel) 
end</pre></div></li></ol><div></div><p class="calibre6">The<a id="id397" class="calibre1"/> main difference when compared to the C++ implementation of <code class="email">Label:createWithTTF</code> is that, in Lua, we have a configuration table for the font.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec131" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">This time, we saw how to register for touch events and how to create true type font labels. Next, we'll go over creating a typical grid for a match-three game.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec144" class="calibre1"/>Time for action – building the gems</h1></div></div></div><p class="calibre6">There are<a id="id398" class="calibre1"/> basically two types of match-three games, those in which the selection of matches takes place automatically and those in which the matches are selected by the player. <em class="calibre8">Candy Crush</em> is a good example of the former, and <em class="calibre8">Diamond Dash</em> of the latter. When building the first type of game, you must add extra logic to ensure you start the game with a grid that contains no matches. This is what we'll do now:</p><div><ol class="orderedlist"><li class="listitem" value="1">We start with the <code class="email">buildGrid</code> method:<div><pre class="programlisting">function GameScene:buildGrid ()
   math.randomseed(os.clock())
   self.enabled = false
    local g
    for c = 1, constants.GRID_SIZE_X do
        self.grid[c] = {}
        self.gridGemsColumnMap[c] = {}
        for r = 1, constants.GRID_SIZE_Y do
            if (c &lt; 3) then
                self.grid[c][r] =  constants.TYPES[ self:getVerticalUnique(c,r) ]
            else
                self.grid[c][r] =  constants.TYPES[ self:getVerticalHorizontalUnique(c,r) ]
            end
           g = Gem:create()
            g:setType(  self.grid[c][r] )
           g:setPosition ( c * (constants.TILE_SIZE +  constants.GRID_SPACE), 
                r * (constants.TILE_SIZE +  constants.GRID_SPACE))
           self.gemsContainer:addChild(g)           
            self.gridGemsColumnMap[c][r] = g
            table.insert(self.allGems, g)
       end
    end
    self.gridAnimations:animateIntro()    
end</pre></div><p class="calibre13">Ensure<a id="id399" class="calibre1"/> that we generate a different random series of gems each time we run the game by changing the <code class="email">randomseed</code> value.</p><p class="calibre13">The <code class="email">enabled</code> property will stop user interactions while the grid is being altered or animated.</p><p class="calibre13">The grid is a two-dimensional array of columns of gems. The magic happens in the <code class="email">getVerticalUnique</code> and <code class="email">getVerticalHorizontalUnique</code> methods.</p></li><li class="listitem" value="2">To ensure that none of the gems will form a three-gem-match on the first two columns, we check them vertically:<div><pre class="programlisting">function GameScene:getVerticalUnique (col, row)
   local type = math.floor (math.random () *  #constants.TYPES + 1 )
   if (self.grid[col][row-1] == constants.TYPES[type] and  self.grid[col][row-2] ~= nil and self.grid[col][row-2] ==  constants.TYPES[type]) then
        type = type + 1; 
        if (type == #constants.TYPES + 1) then type = 1 end
    end
    return type
end</pre></div><p class="calibre13">All this code is doing is checking a column to see if any gem is forming a string of three connected gems of the same type.</p></li><li class="listitem" value="3">Then, we check both vertically and horizontally, starting with column 3:<div><pre class="programlisting">function GameScene:getVerticalHorizontalUnique (col, row)
   local type = self:getVerticalUnique (col, row)
   if (self.grid[col - 1][row] == constants.TYPES[type] and  self.grid[col - 2][row] ~= nil and self.grid[col - 2][row] ==  constants.TYPES[type]) then
        local unique = false
        while unique == false do
          type = self:getVerticalUnique (col, row)
          if (self.grid[col-1][row] == constants.TYPES[type] and
          self.grid[col - 2 ][row] ~= nil and  self.grid[col -  2 ][row] == constants.TYPES[type]) then
            --do nothing
          else
             unique = true
          end           
        end
    end
    return type
end</pre></div></li></ol><div></div><p class="calibre6">This<a id="id400" class="calibre1"/> algorithm is doing the same thing we did previously with the columns, but it's also checking on individual rows.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec132" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We created a grid of gems, free of any three-gem matches. Again, if we had built the sort of match-three game where the user must select clusters of matched gems to have these removed from the grid (like <em class="calibre8">Diamond Dash</em>), we would not have to bother with this logic at all.</p><p class="calibre6">Next, let's manipulate the grid with gem swaps, identification of matches, and grid collapse.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec145" class="calibre1"/>Time for action – changing the grid with GridController</h1></div></div></div><p class="calibre6">The <code class="email">GridController</code> object initiates all grid changes since it's where we handle touches. In the<a id="id401" class="calibre1"/> game, the user can drag a gem to swap places with another, or first select the gem they want to move and then select the gem they want to swap places with in a two-touch process. Let's add the touch handling for that:</p><div><ol class="orderedlist"><li class="listitem" value="1">In <code class="email">GridController</code>, let's add the logic to <code class="email">onTouchDown</code>:<div><pre class="programlisting">function GridController:onTouchDown (touch)
    if (self.gameLayer.running == false) then
        local scene = require("GameScene")
        local gameScene = scene.create()
        cc.Director:getInstance():replaceScene(gameScene)
        local bgMusicPath =  cc.FileUtils:getInstance():fullPathForFilename("background.mp3") 
        cc.SimpleAudioEngine:getInstance():playMusic(bgMusicPath, true)
        return 
    end</pre></div><p class="calibre13">If we are displaying the game over screen, restart the scene.</p></li><li class="listitem" value="2">Next, <a id="id402" class="calibre1"/>we find the gem the user is trying to select:<div><pre class="programlisting">  self.touchDown = true
    if (self.enabled == false) then return end
    local touchedGem = self:findGemAtPosition (touch)
    if (touchedGem.gem ~= nil ) then 
        if (self.gameLayer.selectedGem == nil) then
            self:selectStartGem(touchedGem)
        else
            if (self:isValidTarget(touchedGem.x,  touchedGem.y, touch) == true) then 
                self:selectTargetGem(touchedGem)
            else
                if (self.gameLayer.selectedGem ~= nil)  then self.gameLayer.selectedGem:deselect() end
                self.gameLayer.selectedGem = nil
                self:selectStartGem (touchedGem)
            end
        end
    end
end</pre></div><p class="calibre13">We find the gem closest to the touch position. If the user has not selected a gem yet (<code class="email">selectedGem = nil</code>), we set the one just touched as the first gem selected. Otherwise, we determine whether the second gem selected can be used for a swap. Only gems above and below the first selected gem, or the ones to the left and right of it, can be swapped with. If that is valid, we use the second gem as the target gem.</p></li><li class="listitem" value="3">Before moving on to <code class="email">onTouchMove</code> and <code class="email">onTouchUp</code>, let's see how we determine which gem is being selected and which gem is a valid target gem. So let's work on the <code class="email">findGemAtPosition</code> value. Begin by determining where in the grid container the touch landed:<div><pre class="programlisting">function GridController:findGemAtPosition (position)
    local mx = position.x
    local my = position.y
    local gridWidth = constants.GRID_SIZE_X *  (constants.TILE_SIZE + constants.GRID_SPACE)
    local gridHeight = constants.GRID_SIZE_Y *  (constants.TILE_SIZE + constants.GRID_SPACE)
    mx = mx - self.gameLayer.gemsContainer:getPositionX()
    my = my - self.gameLayer.gemsContainer:getPositionY()
    if (mx &lt; 0) then mx = 0 end
    if (my &lt; 0) then my = 0 end
    if (mx &gt; gridWidth) then mx = gridWidth end
    if (my &gt; gridHeight) then my = gridHeight end</pre></div></li><li class="listitem" value="4">Here is<a id="id403" class="calibre1"/> where the magic happens. We use the <code class="email">x</code> and <code class="email">y</code> position of the touch inside the grid to determine the index of the gem inside the array:<div><pre class="programlisting">local x = math.ceil ((mx - constants.TILE_SIZE * 0.5) /  (constants.TILE_SIZE + constants.GRID_SPACE))
    local y = math.ceil ((my - constants.TILE_SIZE * 0.5) /  (constants.TILE_SIZE + constants.GRID_SPACE))
    if (x &lt; 1) then x = 1 end
    if (y &lt; 1) then y = 1 end
    if (x &gt; constants.GRID_SIZE_X) then x =  constants.GRID_SIZE_X end
    if (y &gt; constants.GRID_SIZE_Y) then y =  constants.GRID_SIZE_Y end
    return {x = x, y = y, gem =  self.gameLayer.gridGemsColumnMap[x][y]}
end</pre></div><p class="calibre13">We finish by checking whether the touch is out of array bounds.</p></li><li class="listitem" value="5">And now let's see the logic to determine whether the target gem is a valid target:<div><pre class="programlisting">function GridController:isValidTarget (px, py, touch)
    local offbounds = false
    if (px &gt; self.gameLayer.selectedIndex.x + 1) then 
offbounds = true end
    if (px &lt; self.gameLayer.selectedIndex.x - 1) then 
offbounds = true end
    if (py &gt; self.gameLayer.selectedIndex.y + 1) then 
offbounds = true end
    if (py &lt; self.gameLayer.selectedIndex.y - 1) then 
offbounds = true end</pre></div><p class="calibre13">We first check to see whether the target gem is at the top, bottom, left, or right of the selected gem:</p><div><pre class="programlisting">local cell = math.sin (math.atan2  (math.pow( self.gameLayer.selectedIndex.x - px, 2),  math.pow( self.gameLayer.selectedIndex.y- py, 2) ) )
    if (cell ~= 0 and cell ~= 1) then
        offbounds = true
    end
    if (offbounds == true) then
        return false
    end</pre></div><p class="calibre13">We next use a bit of trig magic to determine whether the selected target gem is diagonal to the selected gem:</p><div><pre class="programlisting">   local touchedGem = self.gameLayer.gridGemsColumnMap[px][py]
    if (touchedGem.gem == self.gameLayer.selectedGem or  (px == self.gameLayer.selectedIndex.x and  py == self.gameLayer.selectedIndex.y)) then
        self.gameLayer.targetGem = nil
        return false
    end
    return true
end</pre></div><p class="calibre13">We finish by checking whether the target gem is not the same as the previously selected gem.</p></li><li class="listitem" value="6">Now, let's <a id="id404" class="calibre1"/>move on to the <code class="email">onTouchUp</code> event handling:<div><pre class="programlisting">function GridController:onTouchUp (touch)
    if (self.gameLayer.running == false) then return end
    self.touchDown = false
    if (self.enabled == false) then return end
    if (self.gameLayer.selectedGem ~= nil) then  self.gameLayer:dropSelectedGem() end
end</pre></div><p class="calibre13">Pretty simple! We just change the <code class="email">z</code> layering of the selected gem, as we want to make sure that the gem is shown above the others when the swap takes place. So when we release the gem, we push it back to its original <code class="email">z</code> level (which is what the <code class="email">dropSelectedGem</code> method does, and we'll see how it does this soon).</p></li><li class="listitem" value="7">The <code class="email">onTouchMove</code> event handles the option of dragging the selected gem until it swaps places with another gem:<div><pre class="programlisting">function GridController:onTouchMove (touch)
    if (self.gameLayer.running == false) then return end
    if (self.enabled == false) then return end
    --track to see if we have a valid target
    if (self.gameLayer.selectedGem ~= nil and  self.touchDown == true) then
        self.gameLayer.selectedGem:setPosition(
        touch.x - self.gameLayer.gemsContainer:getPositionX(), 
        touch.y - self.gameLayer.gemsContainer:getPositionY())
        local touchedGem = self:findGemAtPosition (touch)
        if (touchedGem.gem ~= nil and self:isValidTarget(touchedGem.x, touchedGem.y, touch) == true ) then
            self:selectTargetGem(touchedGem)
        end
    end
end</pre></div><p class="calibre13">We run most of the same logic as we did with <code class="email">onTouchDown</code>. We move the <code class="email">selectedGem</code> object until a suitable target gem is identified, and then we pick the second one as the target. This is when the swap happens. Let's do that now.</p></li><li class="listitem" value="8">First, the <a id="id405" class="calibre1"/>logic that sets our selected gem:<div><pre class="programlisting">function GridController:selectStartGem (touchedGem)
       if (self.gameLayer.selectedGem == nil) then
        self.gameLayer.selectedGem = touchedGem.gem
        self.gameLayer.targetGem = nil
        self.gameLayer.targetIndex = nil
        touchedGem.gem:setLocalZOrder(constants.Z_SWAP_2)
        self.gameLayer.selectedIndex = {x = touchedGem.x,  y = touchedGem.y}
        self.gameLayer.selectedGemPosition =  {x = touchedGem.gem:getPositionX(),
                                              y =  touchedGem.gem:getPositionY()}
        self.gameLayer.gridAnimations:animateSelected  (touchedGem.gem)                                              
    end
end</pre></div><p class="calibre13">We start the swapping process; we have a selected gem but no target gem. We change the layering of the selected gem through <code class="email">setLocalZOrder</code>. We also make the selected gem rotate 360 degrees.</p></li><li class="listitem" value="9">Then, we're ready to select the target gem:<div><pre class="programlisting">function GridController:selectTargetGem (touchedGem)
    if (self.gameLayer.targetGem ~= nil) then return end
    self.enabled = false
    self.gameLayer.targetIndex = {x = touchedGem.x,  y = touchedGem.y}
    self.gameLayer.targetGem = touchedGem.gem
    self.gameLayer.targetGem:setLocalZOrder(constants.Z_SWAP_1)
    self.gameLayer:swapGemsToNewPosition()
end</pre></div></li></ol><div></div><p class="calibre6">It is now that we finally call our <code class="email">GameScene</code> class and ask it to swap the gems.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec133" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just added the logic to handle all the user interactivity. Now, all that's left for us to do is <a id="id406" class="calibre1"/>handle the swaps, checking for matches and collapsing the grid. Let's do it!</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec146" class="calibre1"/>Time for action – swapping the gems and looking for matches</h1></div></div></div><p class="calibre6">The <a id="id407" class="calibre1"/>swapping logic is found in <code class="email">GameScene</code> in the <code class="email">swapGemsToNewPosition</code> method:</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">swapGemsToNewPosition</code> method makes one call to <code class="email">GridAnimations</code> to animate the swap between the selected and target gem. Once this animation is complete, we fire a <code class="email">onNewSwapComplete</code> method. The majority of the logic takes place in there:<div><pre class="programlisting">function GameScene:swapGemsToNewPosition ()
    local function onMatchedAnimatedOut (sender)
        self:collapseGrid()
    end
  
    local function onReturnSwapComplete (sender)
        self.gridController.enabled = true
    end

    local function onNewSwapComplete (sender)
       self.gridGemsColumnMap[self.targetIndex.x][self.targetIndex.y]  = self.selectedGem
        self.gridGemsColumnMap[self.selectedIndex.x][self.selectedIndex.y] =  self.targetGem
        self.grid[self.targetIndex.x][self.targetIndex.y] =  self.selectedGem.type
        self.grid[self.selectedIndex.x][self.selectedIndex.y] =  self.targetGem.type
The call back switches the gems around inside the grid array.
        self.combos = 0
        self.addingCombos = true
Combos are used to track if we have more than 3 gems matched  after the player's move.        
        --check for new matches
        if (self.gridController:checkGridMatches() == true) then</pre></div></li><li class="listitem" value="2">If we have a match, we run animations on the matched gems, otherwise we play a swap back animation and play a sound effect to represent a wrong move by the player:<div><pre class="programlisting">                --animate matched gems
            if (#self.gridController.matchArray &gt; 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end 
            self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)
            self:showMatchParticle  (self.gridController.matchArray)
            self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)
            self:playFX("match2.wav")
        else
            --no matches, swap gems back
            self.gridAnimations:swapGems (self.targetGem,  self.selectedGem, onReturnSwapComplete)
            self.gridGemsColumnMap[self.targetIndex.x][self.targetIndex.y]  = self.targetGem
            self.gridGemsColumnMap[self.selectedIndex.x][self.selectedIndex.y]  = self.selectedGem
            self.grid[self.targetIndex.x][self.targetIndex.y] =  self.targetGem.type
            self.grid[self.selectedIndex.x][self.selectedIndex.y] =  self.selectedGem.type
            self:playFX("wrong.wav")
        end</pre></div><p class="calibre13">At<a id="id408" class="calibre1"/> the end of each new animation, be it the match one or the swap back one, we once again run callbacks listed at the top of the method. The most important thing these do is the call to <code class="email">collapseGrid</code> done when the matched gems finish animating inside the <code class="email">onMatchedAnimatedOut</code> callback:</p><div><pre class="programlisting">        self.selectedGem = nil
        self.targetGem = nil
   end</pre></div><p class="calibre13">We end the callback by clearing the selected gems and start with a clean slate.</p></li><li class="listitem" value="3">And here, at the end of the function, we call the swap gems animation with <code class="email">onNewSwapComplete</code> as its callback:<div><pre class="programlisting">   self.gridAnimations:swapGems (self.selectedGem, self.targetGem, onNewSwapComplete)
end</pre></div></li><li class="listitem" value="4">Let's move back to <code class="email">GridController</code> and add the <code class="email">checkGridMatches</code> method. This is broken into three parts:<div><pre class="programlisting">function GridController:checkGridMatches ()
    self.matchArray = {}
    for c = 1, constants.GRID_SIZE_X do
        for r = 1, constants.GRID_SIZE_Y do
            self:checkTypeMatch(c,r)
        end
    end
    if (#self.matchArray &gt;= 2) then
        self.gameLayer:addToScore()
        return true
    end
    print("no matches")
    return false
end</pre></div><p class="calibre13">This method starts the check by running <code class="email">checkTypeMatch</code> on each cell.</p></li><li class="listitem" value="5">The <code class="email">checkTypeMatch</code> method searches around the current index and looks for <a id="id409" class="calibre1"/>matches at the top, bottom, left, and right of the index:<div><pre class="programlisting">function GridController:checkTypeMatch (c, r)
    local type = self.gameLayer.grid[c][r]
    local stepC = c
    local stepR = r
    local temp_matches = {}
    --check top
    while stepR -1 &gt;= 1 and self.gameLayer.grid[c][stepR-1] ==  type do
        stepR = stepR - 1
        table.insert (temp_matches, {x = c, y = stepR})
    end 
    if (#temp_matches &gt;= 2) then self:addMatches (temp_matches) end
    temp_matches = {}
    --check bottom
    stepR = r
    while stepR + 1 &lt;= constants.GRID_SIZE_Y 
   and self.gameLayer.grid[c][stepR + 1] == type do
        stepR = stepR + 1
        table.insert (temp_matches, {x = c, y= stepR})
    end
    if (#temp_matches &gt;= 2) then self:addMatches (temp_matches) end
    temp_matches = {}
    --check left
    while stepC - 1 &gt;= 1 and self.gameLayer.grid[stepC - 1][r]  == type do
        stepC = stepC - 1
        table.insert (temp_matches, {x = stepC, y= r})
    end
    if (#temp_matches &gt;= 2) then self:addMatches (temp_matches) end
    temp_matches = {}
    --check right
    stepC = c;
    while stepC + 1 &lt;= constants.GRID_SIZE_X and  self.gameLayer.grid[stepC + 1][r] == type do
        stepC = stepC + 1
        table.insert (temp_matches, {x = stepC, y = r})
    end
    if (#temp_matches &gt;= 2) then self:addMatches (temp_matches) end
end</pre></div><p class="calibre13">If any matches are found, they are added to the <code class="email">matches</code> array.</p></li><li class="listitem" value="6">But first <a id="id410" class="calibre1"/>we need to make sure there are no duplicates listed there, so when we add a gem to the <code class="email">matches</code> array, we check whether it has not been added already:<div><pre class="programlisting">function GridController:addMatches (matches)
    for key, value in pairs(matches) do
        if (self:find(value, self.matchArray) == false) then
            table.insert(self.matchArray, value)
        end
    end
end</pre></div></li><li class="listitem" value="7">And the simple method to look for duplicates:<div><pre class="programlisting">function GridController:find (np, array)
    for key, value in pairs(array) do
        if (value.x == np.x and value.y == np.y) then return true end
    end
    return false
end</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec134" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">Finding matches is more than half the necessary logic for any match-three game. All you need to do is traverse the grid as effectively as you can and look for repeated patterns.</p><p class="calibre6">The rest of the logic concerns the grid collapse. We'll do that next and then we're ready to publish the game.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec147" class="calibre1"/>Time for action – collapsing the grid and repeating</h1></div></div></div><p class="calibre6">So the flow <a id="id411" class="calibre1"/>of the game is move pieces around, look<a id="id412" class="calibre1"/> for matches, remove those, collapse the grid and add new gems, look for matches again, and if necessary, do the whole process in a loop:</p><div><ol class="orderedlist"><li class="listitem" value="1">This is the longest method in the game, and again, most of the logic happens inside callbacks. First we tag the gems being removed by setting their type data to <code class="email">-1</code>. All the gems inside <code class="email">matchArray</code> will be removed:<div><pre class="programlisting">function GameScene:collapseGrid ()
    for i = 1, #self.gridController.matchArray do
        self.grid[self.gridController.matchArray[i].x]
        [self.gridController.matchArray[i].y] = -1
    end

    local column = nil
    local newColumn = nil
    local i</pre></div></li><li class="listitem" value="2">Next, we traverse the grid's columns and rearrange the gems whose type is not equal to <code class="email">-1</code> inside the column arrays. Essentially, we update the data here so that gems above the ones removed "fall down". The actual change will take place in the <code class="email">animateCollapse</code> method:<div><pre class="programlisting">    for c = 1, constants.GRID_SIZE_X do
        column = self.grid[c]
        newColumn = {}
        i = 1
        while #newColumn &lt; #column do
            if (#column &gt; i) then
                if (column[i] ~= -1) then
                    --move gem
                    table.insert(newColumn, column[i])
                end
            else
                --create new gem
                table.insert(newColumn, 1, column[i])
            end
            i = i+1            
        end
        self.grid[c] = newColumn
    end
    self.gridAnimations:animateCollapse  (onGridCollapseComplete)
end</pre></div></li><li class="listitem" value="3">But now, let's code the callback of that animation called <code class="email">onGridCollapseComplete</code>. So above the code we've entered already inside <code class="email">collapseGrid</code>, we add the <code class="email">local</code> function:<div><pre class="programlisting">local function onGridCollapseComplete (sender)
   local function onMatchedAnimatedOut (sender)
      self:collapseGrid()
   end
   for i = 1, #self.allGems do
      local gem = self.allGems[i]
      local xIndex = math.ceil ((gem:getPositionX() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))
      local yIndex = math.ceil ((gem:getPositionY() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))
      self.gridGemsColumnMap[xIndex][yIndex] = gem
      self.grid[xIndex][yIndex] = gem.type
   end</pre></div><p class="calibre13">First, we update the array of sprites, sorting them by the new <code class="email">x</code> and <code class="email">y</code> indexes of the grid.</p></li><li class="listitem" value="4">Then, <a id="id413" class="calibre1"/>we check for matches again. Remember<a id="id414" class="calibre1"/> that this callback runs after the grid collapse animation has finished, which means new gems have been added already and these may create new matches (we'll look at the logic soon):<div><pre class="programlisting">if (self.gridController:checkGridMatches () == true) then
      --animate matched games
      if (self.addingCombos == true) then
         if (#self.gridController.matchArray &gt; 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end
      end
      self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)
      self:showMatchParticle (self.gridController.matchArray)
      self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)
      self:playFX("match.wav")</pre></div></li><li class="listitem" value="5">Then, if we find no more matches, we replace some random gems with diamonds if the value for combos is above 0 (meaning we had more than a 3 gem match in the last player's move):<div><pre class="programlisting">else 
   --no more matches, check for combos
   if (self.combos &gt; 0) then
   --now turn random gems into diamonds
       local diamonds = {}
       local removeGems = {}
       local i = 0
         
       math.randomseed(os.clock())
       while i &lt; self.combos do
         i = i + 1
         local randomGem = nil
         local randomX,randomY = 0
         while randomGem == nil do
           randomX = math.random(1, constants.GRID_SIZE_X)
           randomY = math.random(1, constants.GRID_SIZE_Y)
           randomGem = self.gridGemsColumnMap[randomX][randomY]
           if (randomGem.type == constants.TYPE_GEM_WHITE)  then randomGem = nil end
       end</pre></div></li><li class="listitem" value="6">And<a id="id415" class="calibre1"/> we pick<a id="id416" class="calibre1"/> random gems for the diamonds:<div><pre class="programlisting">        local diamond = self.objectPools:getDiamond()
      diamond:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())
      local diamondParticle =  self.objectPools:getDiamondParticle()
      diamondParticle:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())
         table.insert(diamonds, diamond)   
         table.insert(removeGems, {x=randomX, y=randomY}) 
        end
        self:setDiamondScore(#diamonds *  constants.DIAMOND_POINTS)</pre></div><p class="calibre13">Animate the diamonds being collected, and at the end of that animation, call back <code class="email">onMatchedAnimatedOut</code>, which will collapse the grid once more now that we had gems "burst" into diamonds:</p><div><pre class="programlisting">        self.gridAnimations:animateMatches(removeGems,  onMatchedAnimatedOut)                
     self.gridAnimations:collectDiamonds(diamonds)
     self.combos = 0 
     self:playFX("diamond2.wav")  
    else
     self.gridController.enabled = true
    end
     self.addingCombos = false
   end
end</pre></div></li><li class="listitem" value="7">Here's the whole <code class="email">collapseGrid</code> method:<div><pre class="programlisting">function GameScene:collapseGrid ()
    local function onGridCollapseComplete (sender)
       local function onMatchedAnimatedOut (sender)
            self:collapseGrid()
        end
       for i = 1, #self.allGems do
            local gem = self.allGems[i]
            local xIndex = math.ceil ((gem:getPositionX() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))
            local yIndex = math.ceil ((gem:getPositionY() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))
            self.gridGemsColumnMap[xIndex][yIndex] = gem
            self.grid[xIndex][yIndex] = gem.type
        end
        if (self.gridController:checkGridMatches () == true) then
           --animate matched games
           if (self.addingCombos == true) then
               if (#self.gridController.matchArray &gt; 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end
           end
           self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)
           self:showMatchParticle  (self.gridController.matchArray)
           self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)
           self:playFX("match.wav")
        else 
            --no more matches, check for combos
            if (self.combos &gt; 0) then
                --now turn random gems into diamonds
                local diamonds = {}
                local removeGems = {}
                local i = 0
                math.randomseed(os.clock())
                while i &lt; self.combos do
                   i = i + 1
                   local randomGem = nil
                    local randomX,randomY = 0
                   while randomGem == nil do
                        randomX =  math.random(1, constants.GRID_SIZE_X)
                        randomY =  math.random(1, constants.GRID_SIZE_Y)
                        randomGem =  self.gridGemsColumnMap[randomX][randomY]
                        if (randomGem.type ==  constants.TYPE_GEM_WHITE) then randomGem = nil end
                    end
                    local diamond =  self.objectPools:getDiamond()
                    diamond:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())
                    local diamondParticle =  self.objectPools:getDiamondParticle()
                    diamondParticle:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())
                    table.insert(diamonds, diamond)
                    table.insert(removeGems, {x=randomX,  y=randomY}) 
                end
                self:setDiamondScore(#diamonds *  constants.DIAMOND_POINTS)
                self.gridAnimations:animateMatches(removeGems,  onMatchedAnimatedOut)                
                self.gridAnimations:collectDiamonds(diamonds)
                self.combos = 0 
                self:playFX("diamond2.wav")                 
            else
                self.gridController.enabled = true
            end
            self.addingCombos = false
        end
    end
    for i = 1, #self.gridController.matchArray do
        self.grid[self.gridController.matchArray[i].x] [self.gridController.matchArray[i].y] = -1
    end

    local column = nil
    local newColumn = nil
    local i
    for c = 1, constants.GRID_SIZE_X do
        column = self.grid[c]
        newColumn = {}
        i = 1
        while #newColumn &lt; #column do
            if (#column &gt; i) then
                if (column[i] ~= -1) then
                    --move gem
                    table.insert(newColumn, column[i])
                end
            else
                --create new gem
                table.insert(newColumn, 1, column[i])
            end
            i = i+1            
        end
        self.grid[c] = newColumn
    end
    self.gridAnimations:animateCollapse  (onGridCollapseComplete)
end</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec135" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">The <code class="email">collapseGrid</code> method collects all the gems affected by matches or gems which exploded<a id="id417" class="calibre1"/> into<a id="id418" class="calibre1"/> diamonds. The resulting array is sent to <code class="email">GridAnimations</code> for the proper animations to be performed.</p><p class="calibre6">We'll work on those next and finish our game.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec148" class="calibre1"/>Time for action – animating matches and collapses</h1></div></div></div><p class="calibre6">Now <a id="id419" class="calibre1"/>for <a id="id420" class="calibre1"/>the last bit of logic: the final animations:</p><div><ol class="orderedlist"><li class="listitem" value="1">We'll start with the easy ones:<div><pre class="programlisting">function GridAnimations:animateSelected (gem)
    gem:select()
    gem:stopAllActions()
    local rotate = cc.EaseBounceOut:create ( cc.RotateBy:create(0.5, 360) )
    gem:runAction(rotate)
end</pre></div><p class="calibre13">This rotates a gem; we use this animation when a gem is first selected.</p></li><li class="listitem" value="2">Next is the swap animation:<div><pre class="programlisting">function GridAnimations:swapGems  (gemOrigin, gemTarget, onComplete)
    gemOrigin:deselect()
   local origin = self.gameLayer.selectedGemPosition
    local target = cc.p(gemTarget:getPositionX(),  gemTarget:getPositionY()) 
   local moveSelected =  cc.EaseBackOut:create(cc.MoveTo:create(0.8, target) )   
    local moveTarget =  cc.EaseBackOut:create(cc.MoveTo:create(0.8, origin) )
    local callback = cc.CallFunc:create(onComplete)
   gemOrigin:runAction(moveSelected)
    gemTarget:runAction (cc.Sequence:create(moveTarget, callback))
end</pre></div><p class="calibre13">All this does is swap the places of the first selected gem and the target gem.</p></li><li class="listitem" value="3">Then, we add the<a id="id421" class="calibre1"/> animations we run for matched<a id="id422" class="calibre1"/> gems:<div><pre class="programlisting">function GridAnimations:animateMatches (matches, onComplete)
    local function onCompleteMe (sender)
       self.animatedMatchedGems = self.animatedMatchedGems - 1;
        if (self.animatedMatchedGems == 0) then
            if (onComplete ~= nil) then onComplete() end
        end
end
    self.animatedMatchedGems = #matches
   local gem = nil
    for i, point in ipairs(matches) do
        gem = self.gameLayer.gridGemsColumnMap[point.x] [point.y]
        gem:stopAllActions()
        local scale = cc.EaseBackOut:create  ( cc.ScaleTo:create(0.3, 0))
        local callback = cc.CallFunc:create(onCompleteMe)
        local action = cc.Sequence:create (scale, callback)
        gem.gemContainer:runAction(action)
    end
end</pre></div><p class="calibre13">This will scale down a gem to nothing, and only fire the final callback when all gems have finish scaling.</p></li><li class="listitem" value="4">Next is the collect diamonds animation:<div><pre class="programlisting">function GridAnimations:collectDiamonds(diamonds)
    local function removeDiamond (sender)
        sender:setVisible(false)
    end
    for i = 1, #diamonds do
        local delay = cc.DelayTime:create(i * 0.05)
        local moveTo = cc.EaseBackIn:create( cc.MoveTo:create ( 0.8, cc.p(50, constants.SCREEN_HEIGHT - 50) ) )
        local action = cc.Sequence:create  (delay, moveTo, cc.CallFunc:create(removeDiamond))
        diamonds[i]:runAction(action)
    end
end</pre></div><p class="calibre13">This moves the diamonds to where the diamond score label is.</p></li><li class="listitem" value="5">And<a id="id423" class="calibre1"/> now, <a id="id424" class="calibre1"/>finally, add the grid collapse:<div><pre class="programlisting">function GridAnimations:animateCollapse ( onComplete )
    self.animatedCollapsedGems = 0
    local gem = nil
    local drop  = 1
   for c = 1, constants.GRID_SIZE_X do 
        drop = 1
        for r = 1, constants.GRID_SIZE_Y do
            gem = self.gameLayer.gridGemsColumnMap[c][r]
            --if this gem has been resized, move it to the top 
            if (gem.gemContainer:getScaleX() ~= 1) then
                gem:setPositionY((constants.GRID_SIZE_Y +  (drop)) * (constants.TILE_SIZE + constants.GRID_SPACE))
                self.animatedCollapsedGems =  self.animatedCollapsedGems + 1
                gem:setType ( self.gameLayer:getNewGem() )
                gem:setVisible(true)
                local newY = (constants.GRID_SIZE_Y -  (drop - 1)) * (constants.TILE_SIZE + constants.GRID_SPACE)
                self:dropGemTo (gem, newY,  0.2, onComplete)
                drop = drop + 1
            else
               if (drop &gt; 1) then
                    self.animatedCollapsedGems =  self.animatedCollapsedGems + 1
                    local newY = gem:getPositionY() -  (drop - 1) * (constants.TILE_SIZE + constants.GRID_SPACE)
                    self:dropGemTo (gem, newY, 0, onComplete)
                end
           end
        end 
    end
end </pre></div><p class="calibre13">We loop through all the gems and identify the ones that have been scaled down, meaning the ones which were <em class="calibre8">removed</em>. We move these above the column, so they will fall down as new gems, and we pick a new type for them:</p><div><pre class="programlisting">gem:setType ( self.gameLayer:getNewGem() )</pre></div><p class="calibre13">The ones which were not removed will drop to their new positions. The way we do this is simple. We count how many gems were removed until we reached a gem which has not been removed. That count is stored in the local variable drop, which is reset to <code class="email">0</code> with every column.</p><p class="calibre13">That way, we know how many gems were removed below other gems. We use that to find the new <code class="email">y</code> position.</p></li><li class="listitem" value="6">The <code class="email">dropGemTo</code> new <a id="id425" class="calibre1"/>position looks<a id="id426" class="calibre1"/> like this:<div><pre class="programlisting">function GridAnimations:dropGemTo (gem, y, delay, onComplete)
      gem:stopAllActions()
    gem:reset()
    local function onCompleteMe  (sender)
        self.animatedCollapsedGems =  self.animatedCollapsedGems - 1;
        if ( self.animatedCollapsedGems == 0 ) then
            if (onComplete ~= nil) then onComplete() end
        end
    end
    local move = cc.EaseBounceOut:create  (cc.MoveTo:create (0.6, cc.p(gem:getPositionX(), y) ) )
    local action = cc.Sequence:create  (cc.DelayTime:create(delay), move,  cc.CallFunc:create(onCompleteMe))
    gem:runAction(action)
end</pre></div></li></ol><div></div><p class="calibre6">Again, we only fire the final callback once all gems have collapsed. This final callback will run another check for matches, as we've seen earlier, starting the whole process again.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec136" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">That's it; we have the three main parts of a match-three game: the swap, the matches, and the collapse.</p><p class="calibre6">There is only one animation we haven't covered, which is already included in the code for this chapter, and that is the column drop for the intro animation when the grid is first created. But there's nothing new with that one. Feel free to review it, though.</p><p class="calibre6">Now, it's time to publish the game.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec149" class="calibre1"/>Time for action – publishing the game with the Cocos IDE</h1></div></div></div><p class="calibre6">In <a id="id427" class="calibre1"/>order to build and publish the game, we'll need to tell the IDE a few things. I'll show you how to publish the game for Android, but the steps are very similar for any of the other targets:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, let's tell the IDE where to find the Android SDK, NDK, and ANT, just as we did when we installed the Cocos2d-x console. In the IDE, open the <strong class="calibre7">Preferences</strong> panel. Then, under <strong class="calibre7">Cocos</strong>, enter the three paths just like we did before (remember that for ANT, you need to navigate to its <code class="email">bin</code> folder).<div><img src="img/00042.jpeg" alt="Time for action – publishing the game with the Cocos IDE" class="calibre9"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Now, in <a id="id428" class="calibre1"/>order to build the project, you need to select the fourth button at the top of the IDE (from the left-hand side), or right-click on your project and select <strong class="calibre7">Cocos Tools</strong>. You'll have different options available depending on which stage you are at in the deployment process. <div><img src="img/00043.jpeg" alt="Time for action – publishing the game with the Cocos IDE" class="calibre9"/></div><p class="calibre14"> </p><p class="calibre13">First, the IDE needs to add the native code support, and then it builds the project inside a folder called frameworks (it will contain an iOS, Mac OS, Windows, Android, and Linux version of your project just as if you had created it through the Cocos console).</p></li><li class="listitem" value="3">You can then choose to package the application into an APK or IPA, which you can transfer to your phone. Or, you can use the generated project inside Eclipse or Xcode.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec137" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You just <a id="id429" class="calibre1"/>built your Lua game to Android, or iOS, or Windows, or Linux, or Mac OS, or all of them! Well done.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec150" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">That's it. You can now choose between C++ or Lua to build your games. The whole API can be accessed either way. So, every game created in this book can be done in either language (and yes, that includes the Box2D API.)</p><p class="calibre6">And this is it for the book. I hope you're not too tired to start working on your own ideas. And I hope to see your game sometime soon in an App Store near me!</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="appA" class="calibre1"/>Appendix A. Vector Calculations with Cocos2d-x</h1></div></div></div><p class="calibre6">This appendix will cover some of the math concepts used in <a class="calibre1" title="Chapter 5. On the Line – Rocket Through" href="part0072_split_000.html#page">Chapter 5</a>, <em class="calibre8">On the Line – Rocket Through</em>, in a little more detail.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec151" class="calibre1"/>What are vectors?</h1></div></div></div><p class="calibre6">First, let's do<a id="id430" class="calibre1"/> a quick refresh on vectors and the way you can use Cocos2d-x to deal with them.</p><p class="calibre6">So what is the difference between a vector and a point? At first, they seem to be the same. Consider the following point and vector:</p><div><ul class="itemizedlist"><li class="listitem">Point (2, 3.5)</li><li class="listitem">Vec2 (2, 3.5)</li></ul></div><p class="calibre6">The following figure illustrates a point and a vector:</p><div><img src="img/00044.jpeg" alt="What are vectors?" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">In this<a id="id431" class="calibre1"/> figure, they each have the same value for <em class="calibre8">x</em> and <em class="calibre8">y</em>. So what's the difference?</p><p class="calibre6">With a vector, you always have extra information. It is as if, besides those two values for <em class="calibre8">x</em> and <em class="calibre8">y</em>, we also have the <em class="calibre8">x</em> and <em class="calibre8">y</em> of the vector's origin, which in the previous figure we can assume to be point (0, 0). So the vector is <em class="calibre8">moving</em> in the direction described from point (0, 0) to point (2, 3.5). The extra information we can derive then from vectors is direction and length (usually referred to as magnitude).</p><p class="calibre6">It's as if a vector is a person's stride. We know how long each step is, and we know the direction in which the person is walking.</p><p class="calibre6">In game development, vectors can be used, among other things, to describe movement (speed, direction, acceleration, friction, and so on) or the combining forces acting upon a body.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec138" class="calibre1"/>The vector methods</h2></div></div></div><p class="calibre6">There is<a id="id432" class="calibre1"/> a lot you can do with vectors, and there are many ways to <a id="id433" class="calibre1"/>create them and manipulate them. And Cocos2d-x comes bundled with helper methods that will take care of most of the calculations for you. Here are some examples:</p><div><ul class="itemizedlist"><li class="listitem">You have a vector, and you want to get its angle—use <code class="email">getAngle()</code></li><li class="listitem">You want the length of a vector—use <code class="email">getLength()</code></li><li class="listitem">You want to subtract two vectors; for example, to reduce the amount of movement of a sprite by another vector—use <code class="email">vector1 - vector2</code></li><li class="listitem">You want to add two vectors; for example, to increase the amount of movement of a sprite by another vector—use <code class="email">vector1 + vector2</code></li><li class="listitem">You want to multiply a vector; for example, applying a friction value to the amount of movement of a sprite—use <code class="email">vector1 * vector2</code></li><li class="listitem">You <a id="id434" class="calibre1"/>want the vector that is perpendicular to another (also known as a vector's normal)—use <code class="email">getPerp()</code> or <code class="email">getRPerp()</code></li><li class="listitem">And, most<a id="id435" class="calibre1"/> importantly for our game example, you want the dot product of two vectors—use <code class="email">dot(vector1, vector2)</code></li></ul></div><p class="calibre6">Now let me show you how to use these methods in our game example.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec152" class="calibre1"/>Using ccp helper methods</h1></div></div></div><p class="calibre6">In the <a id="id436" class="calibre1"/>example of <em class="calibre8">Rocket Through</em>, the game we developed in <a class="calibre1" title="Chapter 5. On the Line – Rocket Through" href="part0072_split_000.html#page">Chapter 5</a>, <em class="calibre8">On the Line – Rocket Through</em>, we used vectors to describe movement, and now I want to show you the logic behind some of the methods we used to handle vector operations and what they mean.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec139" class="calibre1"/>Rotating the rocket around a point</h2></div></div></div><p class="calibre6">Let's<a id="id437" class="calibre1"/> start, as an example, with the rocket sprite moving with a vector of (5, 0):</p><div><img src="img/00045.jpeg" alt="Rotating the rocket around a point" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">We then draw a line from the rocket, say from point <strong class="calibre7">A</strong> to point <strong class="calibre7">B</strong>:</p><div><img src="img/00046.jpeg" alt="Rotating the rocket around a point" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Now we want the rocket to rotate around point <strong class="calibre7">B</strong>. So how can we change the rocket's vector<a id="id438" class="calibre1"/> to accomplish that? With Cocos2d-x, we can use the helper point method <code class="email">rotateByAngle</code> to rotate a point around any other point. In this case, we rotate the rocket's position point around point <strong class="calibre7">B</strong> by a certain angle.</p><p class="calibre6">But here's a question – in which direction should the rocket rotate?</p><div><img src="img/00047.jpeg" alt="Rotating the rocket around a point" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">By looking at this figure, you know that the rocket should rotate clockwise, since it's moving towards the right. But programmatically, how could we determine that, and in the easiest way possible? We can determine this by using vectors and another property derived from them: the dot product.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec140" class="calibre1"/>Using the dot product of vectors</h2></div></div></div><p class="calibre6">The<a id="id439" class="calibre1"/> dot product of two vectors describes their angular relationship. If their dot product is greater than zero, the two vectors form an angle smaller than 90 degrees. If it is less than zero, the angle is greater than 90 degrees. And if it is equal to zero, the vectors are perpendicular. Have a look at this descriptive figure:</p><div><img src="img/00048.jpeg" alt="Using the dot product of vectors" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">But one other way to think about this is that if the dot product is a positive value, then the vectors will "point" in the same direction. If it is a negative value, they point in opposite directions. How can we use that to help us?</p><p class="calibre6">A vector will always have two perpendiculars, as shown in the following figure:</p><div><img src="img/00049.jpeg" alt="Using the dot product of vectors" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">These perpendiculars are often called right and left, or clockwise and counterclockwise perpendiculars, and they are themselves vectors, known as normals.</p><p class="calibre6">Now, if <a id="id440" class="calibre1"/>we calculate the dot product between the rocket's vector and each of the perpendiculars on line <strong class="calibre7">AB</strong>, you can see that we can determine the direction the rocket should rotate in. If the dot product of the rocket and the vector's right perpendicular is a positive value, it means the rocket is moving towards the right (clockwise). If not, it means the rocket is moving towards the left (counterclockwise).</p><div><img src="img/00050.jpeg" alt="Using the dot product of vectors" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">The dot product is very easy to calculate. We don't even need to bother with the formula (though it's a simple one), because we can use the <code class="email">d</code>
<code class="email">ot(vector1, vector2)</code> method.</p><p class="calibre6">So we have the vector for the rocket already. How do we get the vector for the normals? First, we get the vector for the <strong class="calibre7">AB</strong> line. We use another method for this – <code class="email">point1 - point2</code>. This will subtract points <strong class="calibre7">A</strong> and <strong class="calibre7">B</strong> and return a vector representing that line.</p><p class="calibre6">Next, we can get the left and right perpendiculars of that line vector with the<code class="email"> getPerp()</code> and <code class="email">getRPerp()</code> methods respectively. However, we only need to check one of these. Then we get the dot product with <code class="email">dot(rocketVector, lineNormal)</code>.</p><p class="calibre6">If this is the correct normal, meaning the value for the dot product is a positive one, we can rotate the rocket to point to this normal's direction; so the rocket will be at a 90-degree angle with the line at all times as it rotates. This is easy, because we can convert the normal vector to an angle with the <code class="email">getAngle()</code> method. All we need to do is apply that angle to the rocket.</p><p class="calibre6">But <a id="id441" class="calibre1"/>how fast should the rocket rotate? We'll see how to calculate that next.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec141" class="calibre1"/>Moving from pixel-based speed to angular-based speed</h2></div></div></div><p class="calibre6">When rotating the<a id="id442" class="calibre1"/> rocket, we still want to show it moving at the same speed as it was when moving in a straight line, or as close to it as possible. How do we do that?</p><div><img src="img/00051.jpeg" alt="Moving from pixel-based speed to angular-based speed" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Remember that the vector is being used to update the rocket's position in every iteration. In the example I gave you, the (5, 0) vector is currently adding 5 pixels to the x position of the rocket in every iteration.</p><p class="calibre6">Now let's consider an angular speed. If the angular speed were 15 degrees, and we kept rotating the rocket's position by that angle, it would mean the rocket would complete a full circle in 24 iterations. Because 360 degrees of a full circle divided by 15 degrees equals 24.</p><p class="calibre6">But we don't have the correct angle yet; we only have the amount in pixels the rocket moves in every iteration. But math can tell us a lot here.</p><p class="calibre6">Math says that the length of a circle is <em class="calibre8">twice the value of Pi, multiplied by the radius of the circle</em>, usually written as <em class="calibre8">2πr</em>.</p><p class="calibre6">We know the radius of the circle we want the rocket to describe. It is the length of the line we drew.</p><div><img src="img/00052.jpeg" alt="Moving from pixel-based speed to angular-based speed" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">With that formula, we can get<a id="id443" class="calibre1"/> the length in pixels of that circle, also known as its circumference. Let's say the line has a length of 100 pixels; this would mean the circle about to be described by the rocket has a length (or circumference) of 628.3 pixels (2 * π * 100).</p><p class="calibre6">With the speed described in the vector (5, 0), we can determine how long it would take the rocket to complete that pixel length. We don't need this to be absolutely precise; the last iteration will most likely move beyond that total length, but it's good enough for our purposes.</p><div><img src="img/00053.jpeg" alt="Moving from pixel-based speed to angular-based speed" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">When we have the total number of iterations to complete the length, we can convert that to an angle. So, if the iteration value is 125, the angle would be 360 degrees divided by 125; that is, 2.88. That would be the angle required to describe a circle in 125 iterations.</p><div><img src="img/00054.jpeg" alt="Moving from pixel-based speed to angular-based speed" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Now the rocket can <a id="id444" class="calibre1"/>change from pixel-based movement to angular-based movement without much visual change.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="appB" class="calibre1"/>Appendix B. Pop Quiz Answers</h1></div></div></div><div><div><div><div><div></div></div></div></div></div>

<div><div><div><div><div><div><h1 class="title" id="calibre_pb_2"><a id="ch10lvl1sec153" class="calibre1"/>Chapter 4, Fun with Sprites – Sky Defense</h1></div></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec142" class="calibre1"/>Pop quiz – sprites and actions</h2></div></div></div><div><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><tbody class="calibre18"><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q1</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">2</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q2</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">1</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q3</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">3</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q4</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">4</p>
</td></tr></tbody></table></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec154" class="calibre1"/>Chapter 8, Getting Physical – Box2D</h1></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec143" class="calibre1"/>Pop quiz</h2></div></div></div><div><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><tbody class="calibre18"><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q1</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">3</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q2</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">2</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q3</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">1</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre20">
<p class="calibre21">Q4</p>
</td><td valign="top" class="calibre20">
<p class="calibre21">3</p>
</td></tr></tbody></table></div></div></div></body></html>