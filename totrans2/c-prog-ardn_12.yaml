- en: Chapter 12. Playing with Max 6 Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach us some tips and techniques that we can use with the
    Max 6 graphical programming framework and Arduino boards.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We introduced this amazing framework in [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sense the World – Feeling with Analog
    Inputs*, while we learned about Arduino analog input handling. Reading the previous
    chapter is a requirement to better understand and learn the techniques developed
    in this chapter. I even suggest you read the Max 6 introduction part again.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to send data to Arduino from Max 6\. We will
    also describe how we can handle and parse the data being received from Arduino.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Arduino adds a lot of features to your Max 6 programs. Indeed, it provides a
    way to plug Max 6 into the real physical world. Through two examples, we are going
    to understand a nice way of working with Arduino, the computer and most advanced
    programming framework ever.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Let's go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Communicating easily with Max 6 – the [serial] object
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already discussed in [Chapter 6](ch06.html "Chapter 6. Sensing the World
    – Feeling with Analog Inputs"), *Sensing the World – Feeling with Analog Inputs*,
    the easiest way to exchange data between your computer running a Max 6 patch and
    your Arduino board is via the serial port. The USB connector of our Arduino boards
    includes the FTDI integrated circuit EEPROM FT-232 that converts the RS-232 plain
    old serial standard to USB.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use again our basic USB connection between Arduino and our computer
    in order to exchange data here.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The [serial] object
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to remember the `[serial]` object's features. It provides a way to send
    and receive data from a serial port. To do this, there is a basic patch including
    basic blocks. We are going to improve it progressively all along this subchapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The `[serial]` object is like a buffer we have to poll as much as we need. If
    messages are sent from Arduino to the serial port of the computer, we have to
    ask the `[serial]` object to pop them out. We are going to do this in the following
    pages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![The [serial] object](img/7584_12_001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: You can find it in the `Chapter12` folder; the patch is named `serialObject.maxpat`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this chapter is also a pretext for me to give you some of my tips
    and tricks in Max 6 itself. Take them and use them; they will make your patching
    life easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right serial port
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog
    Inputs"), *Sense the World – Feeling with Analog Inputs*, we used the message
    `(print)` sent to `[serial]` in order to list all the serial ports available on
    the computer. Then we checked the Max window. That was not the smartest solution.
    Here, we are going to design a better one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We have to remember the `[loadbang]` object. It fires a bang, that is, a `(print)`
    message to the following object as soon as the patch is loaded. It is useful to
    set things up and initialize some values as we could inside our `setup()` block
    in our Arduino board's firmware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Here, we do that in order to fill the serial port selector menu. When the `[serial]`
    object receives the `(print)` message, it pops out a list of all the serial ports
    available on the computer from its right outlet prepended by the word `port`.
    We then process the result by using `[route port]` that only parses lists prepended
    with the word `port`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[t]` object is an abbreviation of `[trigger]`. This object sends the incoming
    message to many locations, as is written in the documentation, if you assume the
    use of the following arguments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`b` means bang'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` means float number'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` means integer'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` means symbol'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` means list (that is, at least one element)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use constants as arguments and as soon as the input is received,
    the constant will be sent as it is.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, the `[trigger]` output messages in a particular order: from the rightmost
    outlet to the leftmost one.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: So here we take the list of serial ports being received from the `[route]` object;
    we send the `clear` message to the `[umenu]` object (the list menu on the left
    side) in order to clear the whole list. Then the list of serial ports is sent
    as a list (because of the first argument) to `[iter]`. `[iter]` splits a list
    into its individual elements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`[prepend]` adds a message in front of the incoming input message.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'That means the global process sends messages to the `[umenu]` object similar
    to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: append `xxxxxx`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: append `yyyyyy`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here `xxxxxx` and `yyyyyy` are the serial ports that are available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: This creates the serial port selector menu by filling the list with the names
    of the serial ports. This is one of the typical ways to create some helpers, in
    this case the menu, in our patches using UI elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you load this patch, the menu is filled, and you only have to choose
    the right serial port you want to use. As soon as you select one element in the
    menu, the number of the element in the list is fired to its leftmost outlet. We
    prepend this number by port and send that to `[serial]`, setting it up to the
    right-hand serial port.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Polling system
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most used objects in Max 6 to send regular bangs in order to trigger
    things or count time is `[metro]`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: We have to use one argument at least; this is the time between two bangs in
    milliseconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Banging the `[serial]` object makes it pop out the values contained in its buffer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If we want to send data continuously from Arduino and process them with Max
    6, activating the `[metro]` object is required. We then send a regular bang and
    can have an update of all the inputs read by Arduino inside our Max 6 patch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a value between 15 ms and 150 ms is good but depends on your own needs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how we can read, parse, and select useful data being received
    from Arduino.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and selecting data coming from Arduino
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, I want to introduce you to a helper firmware inspired by the *Arduino2Max*
    page on the Arduino website but updated and optimized a bit by me. It provides
    a way to read all the inputs on your Arduino, to pack all the data read, and to
    send them to our Max 6 patch through the `[serial]` object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The readAll firmware
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is the firmware. You can find it in `Chapter12/ReadAll`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For starters, we begin the serial communication at 9600 bauds in the `setup()`
    block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: As usual with serial communication handling, we check if there is something
    in the serial buffer of Arduino at first by using the `Serial.available()` function.
    If something is available, we check if it is the character `r`. Of course, we
    can use any other character. `r` here stands for read, which is basic. If an `r`
    is received, it triggers the read of both analog and digital ports. Each value
    (the `val` variable) is passed to the `sendValue()`function; this basically prints
    the value into the serial port and adds a space character in order to format things
    a bit to provide an easier parsing by Max 6\. We could easily adapt this code
    to only read some inputs and not all. We could also remove the `sendValue()` function
    and find another way of packing data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we push a carriage return to the serial port by using `Serial.println()`.
    This creates a separator between each pack of data that is sent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's improve our Max 6 patch to handle this pack of data being received
    from Arduino.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The ReadAll Max 6 patch
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot is the `ReadAll` Max patch that provides a way to
    communicate with our Arduino:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![The ReadAll Max 6 patch](img/7584_12_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: You can find this patch in the `Chapter12` folder. It is named `ReadAll.maxpat`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We added a couple of more things to the basic building blocks in the previous
    patch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Requesting data from Arduino
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we will see a `[t b b]` object. It is also a trigger, ordering bangs
    provided by the `[metro]` object. Each bang received triggers another bang to
    another `[trigger]` object, then another one to the `[serial]` object itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The `[t 13 r]` object can seem tricky. It just triggers a character `r` and
    then the integer `13`. The character `r` is sent to `[spell]` that converts it
    to ASCII code and then sends the result to `[serial]`. `13` is the ASCII code
    for a carriage return.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: This structure provides a way to fire the character `r` to the `[serial]` object,
    which means to Arduino, each time that the metro bangs. As we already see in the
    firmware, it triggers Arduino to read all its inputs, then to pack the data, and
    then to send the pack to the serial port for the Max 6 patch.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize what the metro triggers at each bang, we can write this sequence:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Send the character `r` to Arduino.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a carriage return to Arduino.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bang the `[serial]` object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This triggers Arduino to send back all its data to the Max patch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the received data
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under the `[serial]` object, we can see a new structure beginning with the `[sel
    10 13]` object. This is an abbreviation for the `[select]` object. This object
    selects an incoming message and fires a bang to the specific output if the message
    equals the argument corresponding to the specific place of that output. Basically,
    here we select `10` or `13`. The last output pops the incoming message out if
    that one doesn't equal any argument.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Here, we don't want to consider a new line feed (ASCII code `10`). This is why
    we put it as an argument, but we don't do anything if that's the one that has
    been selected. It is a nice trick to avoid having this message trigger anything
    and even to not have it from the right output of `[select]`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Here, we send all the messages received from Arduino, except `10` or `13`, to
    the `[zl group 78]` object. The latter is a powerful list for processing many
    features. The `group` argument makes it easy to group the messages received in
    a list. The last argument is to make sure we don't have too many elements in the
    list. As soon as `[zl group]` is triggered by a bang *or* the list length reaches
    the length argument value, it pops out the whole list from its left outlet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Here, we "accumulate" all the messages received from Arduino, and as soon as
    a carriage return is sent (remember we are doing that in the last rows of the
    `loop()` block in the firmware), a bang is sent and all the data is passed to
    the next object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We currently have a big list with all the data inside it, with each value being
    separated from the other by a space character (the famous ASCII code 32 we added
    in the last function of the firmware).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: This list is passed to the `[itoa]` object. **itoa** stands for *integer to
    ASCII*. This object converts integers to ASCII characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The `[fromsymbol]` object converts a symbol to a list of messages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after this `[fromsymbol]` object we have our big list of values separated
    by spaces and totally readable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We then have to unpack the list. `[unpack]` is a very useful object that provides
    a way to cut a list of messages into individual messages. We can notice here that
    we implemented exactly the opposite process in the Arduino firmware while we packed
    each value into a big message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`[unpack]` takes as many arguments as we want. It requires knowing about the
    exact number of elements in the list sent to it. Here we send 12 values from Arduino,
    so we put 12 `i` arguments. `i` stands for *integer*. If we send a float, `[unpack]`
    would cast it as an integer. It is important to know this. Too many students are
    stuck with troubleshooting this in particular.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We are only playing with the integer here. Indeed, the ADC of Arduino provides
    data from 0 to 1023 and the digital input provides 0 or 1 only.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We attached a number box to each output of the `[unpack]` object in order to
    display each value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Then we used a `[change]` object. This latter is a nice object. When it receives
    a value, it passes it to its output only if it is different from the previous
    value received. It provides an effective way to avoid sending the same value each
    time when it isn't required.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Here, I chose the argument `-1` because this is not a value sent by the Arduino
    firmware, and I'm sure that the first element sent will be parsed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: So we now have all our values available. We can use them for different jobs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: But I propose to use a smarter way, and this will also introduce a new concept.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Distributing received data and other tricks
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's introduce here some other tricks to improve our patching style.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Cordless trick
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We often have to use some data in our patches. The same data has to feed more
    than one object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: A good way to avoid messy patches with a lot of cord and wires everywhere is
    to use the `[send]` and `[receive]` objects. These objects can be abbreviated
    with `[s]` and `[r]`, and they generate communication buses and provide a wireless
    way to communicate inside our patches.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Cordless trick](img/7584_12_003.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: These three structures are equivalent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a basic cord. As soon as we send data from the upper number
    box, it is transmitted to the one at the other side of the cord.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The second one generates a data bus named `busA`. As soon as you send data into
    `[send busA]`, each `[receive busA]` object in your patch will pop out that data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The third example is the same as the second one, but it generates another bus
    named `busB`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This is a good way to distribute data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: I often use this for my master clock, for instance. I have one and only one
    master clock banging a clock to `[send masterClock]`, and wherever I need to have
    that clock, I use `[receive masterClock]` and it provides me with the data I need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If you check the global patch, you can see that we distribute data to the structures
    at the bottom of the patch. But these structures could also be located elsewhere.
    Indeed, one of the strengths of any visual programming framework such as Max 6
    is the fact that you can visually organize every part of your code exactly as
    you want in your patcher. And please, do that as much as you can. This will help
    you to support and maintain your patch all through your long development months.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Cordless trick](img/7584_12_004.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Check the previous screenshot. I could have linked the `[r A1]` object at the
    top left corner to the `[p process03]` object directly. But maybe this will be
    more readable if I keep the process chains separate. I often work this way with
    Max 6.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the multiple tricks I teach in my Max 6 course. And of course,
    I introduced the `[p]` object, that is the `[patcher]` abbreviation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let's check a couple of tips before we continue with some good examples involving
    Max 6 and Arduino.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and subpatching
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you open Max 6 and go to **File** | **New Patcher**, it opens a blank patcher.
    The latter, if you recall, is the place where you put all the objects. There is
    another good feature named **subpatching** . With this feature, you can create
    new patchers inside patchers, and embed patchers inside patchers as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: A patcher contained inside another one is also named a subpatcher.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it works with the patch named `ReadAllCutest.maxpat`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_005.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: There are four new objects replacing the whole structures we designed before.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: These objects are subpatchers. If you double-click on them in **patch lock mode**
    or if you push the *command* key (or *Ctrl* for Windows), double-click on them
    in **patch edit mode** and you'll open them. Let's see what is there inside them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_006.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: The `[requester]` subpatcher contains the same architecture that we designed
    before, but you can see the brown **1** and **2** objects and another blue **1**
    object. These are inlets and outlets. Indeed, they are required if you want your
    subpatcher to be able to communicate with the patcher that contains it. Of course,
    we could use the `[send]` and `[receive]` objects for this purpose too. We are
    going to see that in the following pages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The position of these inlets and outlets in your subpatcher matters. Indeed,
    if you move the **1** object to the right of the **2** object, the numbers get
    swapped! And the different inlets in the upper patch get swapped too. You have
    to be careful about that. But again, you can organize them exactly as you want
    and need.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the next screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_006b.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: And now, check the root patcher containing this subpatcher. It automatically
    inverts the inlets, keeping things relevant.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_006c.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now have a look at the other subpatchers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: The [p portHandler] subpatcher
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_008.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: The [p dataHandler] subpatcher
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_009.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: The [p dataDispatcher] subpatcher
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In the last figure, we can see only one inlet and no outlets. Indeed, we just
    encapsulated the global data dispatcher system inside the subpatcher. And this
    latter generates its data buses with `[send]` objects. This is an example where
    we don't need and even don't want to use outlets. Using outlets would be messy
    because we would have to link each element requesting this or that value from
    Arduino with a lot of cords.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a subpatcher, you only have to type `n` to create a new object,
    and type `p`, a space, and the name of your subpatcher.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: While I designed these examples, I used something that works faster than creating
    a subpatcher, copying and pasting the structure on the inside, removing the structure
    from the outside, and adding inlets and outlets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: This feature is named encapsulate and is part of the **Edit** menu of Max 6.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You have to select the part of the patch you want to encapsulate inside a subpatcher,
    then click on **Encapsulate**, and voilà! You have just created a subpatcher including
    your structures that are connected to inlets and outlets in the correct order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation and subpatching](img/7584_12_010.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Encapsulate and de-encapsulate features
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You can also de-encapsulate a subpatcher. It would follow the opposite process
    of removing the subpatcher and popping out the whole structure that was inside
    directly outside.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Subpatching helps to keep things well organized and readable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine that we have to design a whole patch with a lot of wizardry and
    tricks inside it. This one is a processing unit, and as soon as we know what it
    does, after having finished it, *we don't want to know how it does it* but only
    *use it*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: This provides a nice abstraction level by keeping some processing units closed
    inside boxes and not messing the main patch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You can copy and paste the subpatchers. This is a powerful way to quickly duplicate
    process units if you need to. But each subpatcher is totally independent of the
    others. This means that if you need to modify one because you want to update it,
    you'd have to do that individually in each subpatcher of your patch.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This can be really hard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Let me introduce you to the last pure Max 6 concept now named abstractions before
    I go further with Arduino.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions and reusability
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any patch created and saved can be used as a new object in another patch. We
    can do this by creating a new object by typing `n` in a patcher; then we just
    have to type the name of our previously created and saved patch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: A patch used in this way is called an **abstraction**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In order to call a patch as an abstraction in a patcher, the patch has to be
    in the Max 6 *path* in order to be found by it. You can check the path known by
    Max 6 by going to **Options** | **File Preferences**. Usually, if you put the
    main patch in a folder and the other patches you want to use as abstractions in
    that same folder, Max 6 finds them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The concept of abstraction in Max 6 itself is very powerful because it provides
    **reusability**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, imagine you need and have a lot of small (or big) patch structures that
    you are using every day, every time, and in almost every project. You can put
    them into a specific folder on your disk included in your Max 6 path and then
    you can call (we say *instantiate*) them in every patch you are designing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Since each patch using it has only a reference to the one patch that was instantiated
    itself, you just need to improve your abstraction; each time you load a patch
    using it, the patch will have up-to-date abstractions loaded inside it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: It is really easy to maintain all through the development months or years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you totally change the abstraction to fit with a dedicated project/patch,
    you'll have some problems using it with other patches. You have to be careful
    to maintain even short documentation of your abstractions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Let's now continue by describing some good examples with Arduino.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sound-level meter with LEDs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This small project is a typical example of a Max 6/Arduino hardware and software
    collaboration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Max can easily listen for sounds and convert them from the analog to the digital
    domain.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We are going to build a small sound level visualizer using Arduino, some LEDs,
    and Max 6.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The circuit
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use the same circuit we designed in [Chapter 8](ch08.html "Chapter 8. Designing
    Visual Output Feedback"), *Designing Visual Output Feedbacks*, while we multiplexed
    LEDs with a daisy chain of shift registers of the type 595.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the circuit:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_12_011.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Our double series of eight LEDs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit](img/7584_12_012.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Our double series of eight LEDs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea is to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Use each series of eight LEDs for each sound channel (left and right)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the sound level all along the LED series
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each channel, the greater the number of LEDs switched on, the higher the
    sound level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Let's now check how we can handle this in Max 6 first.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The Max 6 patch for calculating sound levels
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following figure showing the `SoundLevelMeters` patch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![The Max 6 patch for calculating sound levels](img/7584_12_013.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Generating sounds and measuring sound levels
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We are using the MSP part of the Max 6 framework here that is related to sound
    signals. We have two sources (named `source 1` and `source 2`) in the patch. Each
    one generates two signals. I connected each one to one of the `[selector~ ]` objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Those latter are switches for signals. The source selector at the top left provides
    a way to switch between `source 1` and `source 2`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: I won't describe the cheap wizardry of sound sources; it would involve having
    a knowledge of synthesis and that would be out of the scope of this topic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a connection between each `[selector~ ]` output and a small symbol
    like a speaker. This is related to the sound output of your audio interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: I also used the `[meter~]` object to display the level of each channel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: At last, I added a `[flonum]` object to display the current value of the level
    each time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: These are the numbers we are going to send to Arduino.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the serial communication building blocks we already described.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![The Max 6 patch for calculating sound levels](img/7584_12_014.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Sending data to Arduino
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We have our serial communication setup ready.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `[zmap 0\. 1\. 0 255]` objects. These take a value intended
    to be between `0\. 1`, as was set up in the arguments, and scale it to the range
    `0 255`. This provides a byte of data for each channel.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We are using two data buses to send a value from each channel to a `[pak]` object.
    The latter collects the incoming messages and creates a list with them. The difference
    between `[pack]` and `[pak]` is that `[pak]` sends data as soon as it receives
    a message in one of its inputs, not only when it receives a message of its left
    input, as with `[pack]`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have lists of messages that are popped out from the computer to Arduino
    as soon as the level values change.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The firmware for reading bytes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to handle this in Arduino:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the same firmware as the one in [Chapter 8](ch08.html "Chapter 8. Designing
    Visual Output Feedback"), *Designing Visual Output Feedback*, except here we are
    pitreading real values and not generating random ones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We are doing that with `Serial.parseInt()` in the `Serial.available()` test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This means that as soon as the data is in the Arduino serial buffer, we'll read
    it. Actually, we are reading two values and storing them, after a byte conversion,
    in `LeftChannel` and `RightChannel`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We then process the data to the shift register to light the LEDs according to
    the value sent by the Max 6 patch.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another example of playing with sound files and a distance sensor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Pitch shift effect controlled by hand
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pitch shifting** is a well-known effect in all fields related to sound processing.
    It changes the pitch of an incoming sound. Here we are going to implement a very
    cheap pitch shifter with Max 6, but we will focus on how to control this sound
    effect. We will control it by moving our hand over a distance sensor.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the same circuit as the one in [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sense the World – Feeling with Analog
    Inputs*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The circuit with the sensor and the firmware
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following circuit shows the Arduino board connected to a sensor:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![The circuit with the sensor and the firmware](img/7584_12_015.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: The Sharp distance sensor connected to Arduino
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The firmware is almost the same too. I removed the part about the distance calculation
    because, indeed, we don't care about the distance itself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The ADC of Arduino provides a resolution of 10 bits, which will give numbers
    from 0 to 1023\. We are going to use this value to calibrate our system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the firmware. You can find it in the `Chapter12/PitchShift`
    folder:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As soon as Arduino runs this firmware, it sends values to the serial port.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The patch for altering the sound and parsing Arduino messages
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I cannot describe the whole pitch shifter itself. By the way, you can open the
    related subpatch to see how it has been designed. Everything is open.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![The patch for altering the sound and parsing Arduino messages](img/7584_12_017.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: The pitch shifter controlled by your hand over the distance sensor
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: As we described before, we have to choose the right serial port and then bang
    the `[serial]` object in order to make it pop out the values in its buffer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using the `[scale]` object. It is similar to `[zmap]`, which we
    already used, because it maps a range to another one but it can also work with
    inverted range and doesn't clip values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `[scale]` 对象。它与我们已经使用过的 `[zmap]` 类似，因为它可以将一个范围映射到另一个范围，但它也可以与反转范围一起工作，并且不会截断值。
- en: Here, I'm mapping values being received from the ADC of Arduino from 0 to 1023
    to something fitting our need from 12.0 to 0.5.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将从 Arduino 的 ADC 接收到的值从 0 到 1023 映射到适合我们需求的 12.0 到 0.5。
- en: If we place our hand close to the sensor, the distance is small, and if we move
    our hand further away, the distance changes and the effect is modulated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将手靠近传感器，距离就小，如果我们把手移远，距离就会改变，效果也会被调制。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us how to deal with Arduino using Max 6.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教我们如何使用 Max 6 处理 Arduino。
- en: We learnt a bit more about some usual techniques in Max 6, and we practiced
    some concepts previously learnt in this book. Obviously, there is more to learn
    in Max 6, and I'd like to give you some good pointers for better learning.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Max 6 中的一些常用技术有了更多的了解，并且我们练习了一些在这本书中学到的概念。显然，Max 6 中还有更多东西可以学习，我很乐意给你一些更好的学习指南。
- en: 'Firstly, I''d suggest you read *all* the tutorials, beginning with those about
    Max, then about MSP, and then about digital sound, and at last about Jitter if
    you are interested in visuals and OpenGL. That sounds obvious but I still have
    two or three persons a day asking me where to begin Max 6 from. The answer is:
    tutorials.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我建议你阅读 *所有* 的教程，从 Max 的教程开始，然后是 MSP，然后是数字声音，最后是如果你对视觉效果和 OpenGL 感兴趣的话，是 Jitter。听起来很明显，但我每天还是有两三个人问我从哪里开始学习
    Max 6。答案是：教程。
- en: Then, I'd suggest you design a small system. Less is definitely more. A small
    system provides easy ways to maintain, modify, and support. Using comments is
    also a nice way to quickly remember what you tried to do in this or that part.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我建议你设计一个小型系统。少即是多。小型系统提供了易于维护、修改和支持的便捷方式。使用注释也是一种快速记住你在这一部分或那一部分尝试做什么的好方法。
- en: Lastly, patching a bit everyday is the real key to success. It takes time, but
    don't we want to become masters?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每天稍微修补一下是成功的关键。这需要时间，但我们不是都想成为大师吗？
