- en: Chapter 3. Building a Tetris Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we develop a classic Tetris game. We look further into the
    `Window` class, including text writing and drawing figures that are more complex.
    We look also into timing, random numbers, and graphical updates such as falling
    figures and flash effects. An illustration of it is shown next:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Tetris Application](img/image_03_001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: The MainWindow function
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MainWindow` function is similar to the methods in [Chapter 2](ch02.html
    "Chapter 2. Hello, Small World!"), *Hello, Small World!*. It sets the application
    name and returns a pointer to the main window, which, in this case, is an instance
    of the `TetrisWindow` class. As stated in [Chapter 2](ch02.html "Chapter 2. Hello,
    Small World!"), *Hello, Small World!* the application name is used when accessing
    the registry, when opening or saving a file, and by the **About** menu item. However,
    none of that functionality is used in this application:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**MainWindow.cpp**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Tetris window
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this application, we do not use the `StandardDocument` framework from the
    [Chapter 2](ch02.html "Chapter 2. Hello, Small World!"), *Hello, Small World!*.
    Instead, the `TetrisWindow` class extends the Small Windows root class `Window`
    directly. The reason is simply that we do not need the functionality of the `StandardDocument`
    framework or its base class `Document`. We do not use menus or accelerators, and
    we do not save or load files:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**TetrisWindow.h**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this application, we ignore the mouse. Instead, we look into keyboard handling.
    The `OnKeyDown` method is called when the user presses or releases a key:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similar to the circle application, the `OnDraw` method is called every time
    the window''s client area needs to be redrawn:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `OnGainFocus` and `OnLoseFocus` methods are called when the window gains
    or loses input focus, respectively. When the window loses input focus, it will
    not receive any keyboard input and the timer is turned off, preventing the falling
    figure from moving:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `OnTimer` method is called every second the window has focus. It tries
    to move the falling figure one step downward. It calls the `NewFigure` method
    if it fails to move the figure downward. The `NewFigure` method tries to introduce
    a new figure on the game board. If that fails, the `GameOver` method is called,
    which asks the user if they want a new game. The `NewGame` method is called if
    the user wants a new game. If the user does not want a new game, it exits the
    application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'the `DeleteFullRows` examines each row by calling the `IsRowFull` method and
    calls the `FlashRow` and `DeleteRow` methods for each full row:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `TryClose`  method is called if the user tries to close the window by clicking
    on the cross in the top-right corner of the window. It displays a message box
    that asks the user if they really want to quit:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `gameGrid` field holds the grid on which the figures are displayed (see
    the next section). The falling figure (`fallingFigure`) is falling down on the
    grid, and the next figure to fall down (`nextFigure`) is displayed in the top-right
    corner. Each time the player fills a row, the score (`currScore`) is increased.
    The timer identity (`TimerId`) is needed to keep track of the timer and is given
    the arbitrary value of `1000`. Finally, the figure list (`figureList`) will be
    filled with seven figures, one of each color. Each time a new figure is needed,
    a randomly chosen figure from the list will be chosen and copied:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `PreviewCoordinate` parameter in the `Window` constructor call indicates
    that the window''s size is fixed, and the second parameter indicates that the
    size is 100 * 100 units. This means that unlike the circle application, the size
    of figures and game boards will change when the user changes the window''s size:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**TetrisWindow.cpp**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The upper 20 percent of the client area is reserved for the score and the next
    figure. The game grid covers the lower 80 percent of the client area (from height
    unit 20 to 100):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we extend the `Window` class, we need to set the window header manually:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The timer interval is set to `1000` milliseconds, which means that `OnTimer`
    will be called every second. The random generator is initialized by calling the
    C standard functions `srand` and `time`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The figure list is initialized with one figure of each color; the falling and
    next figure are randomly chosen from that list. One of the figures in the list
    will be copied every time we need a new figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Strictly speaking, it is not necessary to drop the timer when closing the Tetris
    window. The destructor is included only for the sake of completeness:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keyboard input
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnKeyDown` method overrides the method in the `Window` class and is called
    each time the user presses a key. We try to move the falling figure in accordance
    with the key pressed. We do not care whether the user has pressed the *Shift*
    or *Ctrl* key:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the user presses the Space key, the falling figure falls with visible
    speed to create the illusion of falling. We try to move the falling figure one
    step down every 10 milliseconds by calling the Win32 API function `Sleep`. The
    `TryMoveDown` method returns `false` when it is no longer possible to move the
    figure downward:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Drawing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnDraw` method starts by drawing the game grid and two lines dividing
    the client area into three parts. The top-left corner displays the current score,
    the top-right corner displays the next figure, and the lower part displays the
    actual game grid:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that we add an offset when drawing the next figure in order to move from
    the game grid to the top-right corner. The value `25` moves the figure from the
    middle of the grid to the middle of its right half, and the value `-18` moves
    from the grid up to the area preceding the grid:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The score font is set to `Times New Roman`, size `10`. Here, the size does
    not refer to typographical points, but to logical units. Since the call to the
    `Window` constructor states we gave the `PreviewCoordinate` coordinate system
    and the size 100 * 100, the height of the text will be 10 units, which is a tenth
    of the text client area''s height. It is also half the height of the part of the
    client area where the score is written:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final `false` parameter in the call to the `DrawText` method indicates
    that the size of the text won''t be recalculated. In the next chapters, we will
    display text that maintains the same size, regardless of the window size and the
    screen resolution. In this chapter, however, the size of the text will be changed
    when the user changes the size of window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Input focus
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnGainFocus` and `OnLoseFocus` methods start and stop the timer, respectively,
    so that the falling figure does not fall down when the window is out of focus:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The timer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The timer is active when it has the input focus. When active, the `TryMoveDown`
    method will be called every time the `OnTimer` method is called (once every second).
    When the figure cannot fall down any more (the `TryMoveDown` method returns `false`),
    the `EndOfFigure` method is called:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: New figures
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it is not possible for the falling figure to move downward, the `OnTimer`
    method calls the `NewFigure` method. First, we need to store the falling figure
    to the game grid by calling the `AddToGrid` method. Then, we let the next figure
    become the new falling figure and we choose by random the new next figure from
    the figure list. We invalidate the area of the new falling figure and the area
    of the top-right corner where the next figure is drawn:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We delete the possible full rows and update the window:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the new falling figure is not valid from the very beginning, the game is
    over and `GameOver` is called:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Game over
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GameOver` method presents the score and lets the user decide whether they
    want a new game. If they want a new game, it is initialized by the `NewGame` call.
    If the user does not want a new game, the call to the Win32 API function `PostQuitMessage`
    terminates the execution of the application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we call another version of the `Invalidate` method, without parameters.
    It invalidates the whole client area:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The timer is inactive while the message is displayed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: New game
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NewGame` method initializes the randomly chosen new falling and next figures,
    resets the score, and clears the game grid before activating the timer, as well
    as invalidates and updates the window, which makes the new falling figure starting
    to fall and the new game to begin:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting and flashing rows
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deleting full rows, we loop through the rows, flashing and removing each
    full row. We increase the score and update the area of the row. Note that the
    rows start at the top of the grid. This means that we have to loop from the highest
    row to the lowest row in order to delete the row in the right order.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if the row becomes flashed and deleted, we do not update the `row`
    variable since the deleted row will be replaced by the row above, which also needs
    to be examined:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A row is considered full if it does not contain a white square:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The flash effect is executed by redrawing the row in normal and inversed color
    (the `inverse` method is set) three times with an interval of 50 milliseconds.
    While doing this, it is especially important that we only invalidate the area
    of the chosen row. Otherwise, the whole window client area will be flashed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When deleting a row, we do not really delete it. Instead, we move each row
    above the deleted row one step downward and fill the top row with white squares.
    A complication is that we count rows from the top. This makes the lowest row on
    the screen the row with the highest index. This gives the appearance that we start
    from the bottom and remove every full row until we reach the top:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Closing the window
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, when the user wants to close the window by clicking in the cross on
    the top-right corner, we need to confirm that they really want to quit. If the
    `TryClose` method returns `true`, the window is closed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The TetrisFigure class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this application, there is the root `figure` class and one subclass for each
    type of falling figure. All figures can be moved sideways or rotated as a response
    to the user's requests. They are also moved downward by the timer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven figures, one for each color: red, brown, turquoise, green,
    yellow, blue, and purple. Each of them also has a unique shape. However, they
    all contain four squares. They can further be divided into three groups based
    on their ability to rotate. The red figure is the simplest one. It is a square
    and does not rotate at all. The brown, turquoise, and green figure can be rotated
    in vertical and horizontal directions, while the yellow, blue, and purple figures
    can be rotated in north, east, south, and west directions. For the red figure,
    it does not really matter since it does not rotate.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The `row` and `col` fields of the `TetrisFigure` class hold the center of the
    figure, which is marked by a cross in the illustrations of this section. The `color`
    field holds the color of the figure, and `direction` holds the current direction
    of the figure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `direction` array holds the relative positions of the three squares
    surrounding the marked square. There are four directions at most. Each direction
    holds three squares, which are the three remaining squares that are not the center
    of the figure. Each square holds two integers: the relative position of the center
    row and column.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The default constructor is needed to initialize the `fallingFigure` and `nextFigure`
    methods in the `TetrisWindow` class. The second constructor is protected since
    it is only called by its sub classes. Each figure has its own `TetrisFigure` subclass.
    Their constructors take a pointer to the color grid and define its color, start
    position, and figure patterns:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**TetrisFigure.h**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TryMoveLeft`, `TryMoveRight`, `TryRotateClockwise`, `TryRotateClockwise`,
    `TryRotateAnticlockwise`, and `TryMoveDown` methods all try to move the figure.
    They call the `IsFigureValid` method, which checks whether the new location is
    valid, that is, it is not located outside the game grid or at a location already
    occupied. The `IsFigureValid` method, in turn, calls the `IsSquareValid` method
    for each of its four squares:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two versions of the `IsFigureValid` method, where the first version
    is called by the `TetrisWindow` method and the other version is called by the
    preceding `try` methods in order to test whether a new location of the falling
    figure is valid:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `AddToGrid` method adds the four squares of the figure to the game grid:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `InvalidateFigure` method invalidates the area occupied by the figure,
    and the `DrawFigure` method draws the figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `gameGridPtr` field is a pointer to the game grid, which we access when
    we try to move a figure in order to decide whether its new location is valid.
    The `color` field is the color of the figure (red, brown, turquoise, green, yellow,
    blue, or purple). The `row`, `col`, and `direction` fields hold the current location
    and direction of the figure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `figureInfo` field holds the shape of the figure. The figure can hold up
    to four directions: north, east, south, and west. Remember that `row` and `col`
    hold the location of the figures. More specifically, they hold the location of
    the center square of the four squares constituting the figure (marked by a cross
    in the following illustrations). The other three squares are defined by integer
    pairs holding their locations relative to the center square.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, `figureInfo` is an array of four pointers (one each for the directions
    north, east, south, and west). Each pointer points at an array of three integer
    pairs, holding the locations of the three squares relative to the center square:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The default constructor is necessary because `fallingFigure` and `nextFigure`
    are member objects of the `TetrisWindow` class. However, they do not need to be
    initialized since their values are assigned one of the seven figures in the `figureList`
    array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**TetrisFigure.cpp**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second constructor is called by the colored figure sub class constructor
    in order to initialize the figure. It takes a pointer to the main window and the
    game grid, the color of the figure, its start location and direction, and its
    location lists in the north, east, south, and west directions. Each of the lists
    holds three integer pairs representing the location of the squares relative to
    the center square:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The assignment operator is necessary because the `fallingFigure` and `nextFigure`
    methods in the `TetrisWindow` class are copied from the figure list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `TryMoveLeft`, `TryMoveRight`, `TryRotateClockwise`, and `TryRotateAnticlockwise`
    methods are called when the user presses the arrow keys. They try to move the
    figure and invalidate its previous and current area if they succeed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `TryMoveDown` method is called by the timer when the player presses the
    Space key. It is also called by the `OnTimer` method in the `TetrisWindow` class;
    it returns a `Boolean` value indicating whether the movement succeeded:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first version of the `IsFigureValid` method is called by the `TetrisWindow`
    class and calls the second static version, with the current location and direction
    of the figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second version of the `IsFigureValid` method is called by the preceding
    `try` methods and checks if the figure is valid by calling the `IsSquareValid`
    method for each square in the figure. In order to do so, it needs to look up the
    relative positions of the included squares in the `figureInfo` method. The first
    value of the integer pairs is the row, and the second value is the column:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `IsSquareValid` method returns `true` if the given square is located inside
    the game grid and not already occupied. A square on the game board is considered
    unoccupied if it is white:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the falling figure has reached its final position, it is added to the
    game grid. It is performed by setting the figure''s color to the squares in the
    game grid at its current location. A falling figure has reached its final position
    when it cannot fall any longer without colliding with an earlier figure or has
    reached the game grid''s lower bound:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When a figure has been moved, we need to redraw it. In order to avoid dazzle,
    we want to invalidate only its area, which is done by the `InvalidateFigure` method.
    We look up the rows and columns of the figure''s four squares and call the `InvalidateSquare`
    method in the game grid for each of them:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When drawing the figure, we need to look up the locations of the squares of
    the figure before we draw them in a way similar to the `InvalidateFigure` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The red figure
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The red figure is one large square, built up by four smaller regular squares.
    It the simplest figure of the game since it does not change shape when rotating.
    This implies that we just need to look at one figure, shown as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![The red figure](img/B05475_03_02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'This also implies that it is enough to define the squares for one direction
    and this to define the shape of the figure in all four directions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**RedFigure.h**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**RedFigure.cpp**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first integer pair (`rel row 0`, `rel col 1`) of the generic list represents
    the square to the right of the marked square, the second integer pair (`rel row
    1`, `rel col 0`) represents the square below the marked square, and the third
    integer pair (`rel row 1`, `rel col 1`) represents the square below and to the
    right of the marked square. Note that the rows increase downward and the columns
    increase to the right.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The brown figure
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The brown figure can be oriented in a horizontal or vertical direction. It
    is initialized to vertical mode, as it can only be rotated into two directions.
    The north and south arrays are initialized with the vertical array and the east
    and west arrays are initialized with the horizontal array, as shown in the following
    image:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![The brown figure](img/B05475_03_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Since the row numbers increase downward and the column numbers increase to
    the right, the topmost square in the vertical direction (and the leftmost square
    in the horizontal direction) are represented by negative values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**BrownFigure.h**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**BrownFigure.cpp**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The turquoise figure
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the brown figure, the turquoise figure can be rotated in a vertical
    and horizontal direction, as shown in the following figure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![The turquoise figure](img/B05475_03_04.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: '**TurquoiseFigure.h**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**TurquoiseFigure cpp**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The green figure
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The green figure is mirrored in relation to the turquoise figure, shown as
    follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![The green figure](img/B05475_03_05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: '**GreenFigure.h**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**GreenFigure.cpp**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The yellow figure
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The yellow figure can be rotated in a north, east, south, and west direction.
    It is initialized to the south, as shown in the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![The yellow figure](img/B05475_03_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '**YellowFigure.h**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**YellowFigure.cpp**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The blue figure
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The blue figure can also be directed in all four directions. It is initialized
    to the south, as shown in the following figure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![The blue figure](img/B05475_03_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '**BlueFigure.h**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**BlueFigure.cpp**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The purple figure
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, the purple figure is mirrored in relation to the blue figure and also
    initialized to the south, as shown in the following image:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![The purple figure](img/B05475_03_08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '**PurpleFigure.h**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**PurpleFigure.cpp**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The GameGrid class
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the `GameGrid` class is quite simple. It keeps track of the squares
    on the game board. The `gridArea` field is the portion of the total client area
    that is occupied by the grid:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**GameGrid.h**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When called by the `TetrisWindow` constructor, the grid area will be set to
    (0, 20, 100, 100) units, placing it in the lower 80 percent of the client area
    of the window:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**GameGrid.cpp**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When clearing the grid, we actually set every square to white:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Invalidating and drawing squares
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DrawGameGrid` iterates through the squares of the grid. White squares
    are surrounded by white borders, while squares of every other color are surrounded
    by black borders. If the `inverseColor` parameter is true, the square color is
    inversed before drawn. This is useful when flashing rows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that the `InvalidateSquare` and `DrawSquare` methods add an offset. It
    is zero in all cases except when invalidating or drawing the next figure in the
    `TetrisWindow` class. Both methods calculate the size of the rows and columns
    of the grid and define the area of the square invalidated or drawn:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a Tetris game. You looked into timing and randomization,
    as well as a new coordinate system, more advanced drawing, how to catch keyboard
    events, and how to write text.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个俄罗斯方块游戏。你了解了时间控制和随机化，以及一个新的坐标系，更高级的绘图方法，如何捕捉键盘事件，以及如何编写文本。
- en: In [Chapter 4](ch04.html "Chapter 4. Working with Shapes and Figures"), *Working
    with Shapes and Figures*, we will develop a drawing program capable of drawing
    lines, arrows, rectangles, and ellipses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理形状和图形")，*处理形状和图形*中，我们将开发一个能够绘制线条、箭头、矩形和椭圆的绘图程序。
