- en: Chapter 3. Building a Tetris Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 构建俄罗斯方块应用程序
- en: 'In this chapter, we develop a classic Tetris game. We look further into the
    `Window` class, including text writing and drawing figures that are more complex.
    We look also into timing, random numbers, and graphical updates such as falling
    figures and flash effects. An illustration of it is shown next:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个经典的俄罗斯方块游戏。我们进一步探讨了`Window`类，包括文本写入和绘制更复杂的图形。我们还探讨了计时、随机数和图形更新，如下落图形和闪光效果。其示意图如下：
- en: '![Building a Tetris Application](img/image_03_001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![构建俄罗斯方块应用程序](img/image_03_001.jpg)'
- en: The MainWindow function
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MainWindow函数
- en: 'The `MainWindow` function is similar to the methods in [Chapter 2](ch02.html
    "Chapter 2. Hello, Small World!"), *Hello, Small World!*. It sets the application
    name and returns a pointer to the main window, which, in this case, is an instance
    of the `TetrisWindow` class. As stated in [Chapter 2](ch02.html "Chapter 2. Hello,
    Small World!"), *Hello, Small World!* the application name is used when accessing
    the registry, when opening or saving a file, and by the **About** menu item. However,
    none of that functionality is used in this application:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow`函数与[第2章](ch02.html "第2章. 小小世界！")中的*小小世界!*中的方法类似。它设置应用程序名称并返回主窗口的指针，在这种情况下，是一个`TetrisWindow`类的实例。正如[第2章](ch02.html
    "第2章. 小小世界！")中所述，*小小世界!*应用程序名称在访问注册表、打开或保存文件以及**关于**菜单项时使用。然而，在这个应用程序中，没有使用任何这些功能：'
- en: '**MainWindow.cpp**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.cpp**'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Tetris window
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 俄罗斯方块窗口
- en: 'In this application, we do not use the `StandardDocument` framework from the
    [Chapter 2](ch02.html "Chapter 2. Hello, Small World!"), *Hello, Small World!*.
    Instead, the `TetrisWindow` class extends the Small Windows root class `Window`
    directly. The reason is simply that we do not need the functionality of the `StandardDocument`
    framework or its base class `Document`. We do not use menus or accelerators, and
    we do not save or load files:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们不使用[第2章](ch02.html "第2章. 小小世界！")中的`StandardDocument`框架，即*小小世界！*。相反，`TetrisWindow`类直接扩展了Small
    Windows根类`Window`。原因很简单，我们不需要`StandardDocument`框架或其基类`Document`的功能。我们不使用菜单或快捷键，也不保存或加载文件：
- en: '**TetrisWindow.h**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**TetrisWindow.h**'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this application, we ignore the mouse. Instead, we look into keyboard handling.
    The `OnKeyDown` method is called when the user presses or releases a key:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们忽略了鼠标。相反，我们关注键盘处理。当用户按下或释放一个键时，会调用`OnKeyDown`方法：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similar to the circle application, the `OnDraw` method is called every time
    the window''s client area needs to be redrawn:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与圆形应用程序类似，每当窗口的客户区域需要重绘时，都会调用`OnDraw`方法：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `OnGainFocus` and `OnLoseFocus` methods are called when the window gains
    or loses input focus, respectively. When the window loses input focus, it will
    not receive any keyboard input and the timer is turned off, preventing the falling
    figure from moving:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口获得或失去输入焦点时，会分别调用`OnGainFocus`和`OnLoseFocus`方法。当窗口失去输入焦点时，它将不会接收任何键盘输入，计时器将被关闭，防止下落图形移动：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `OnTimer` method is called every second the window has focus. It tries
    to move the falling figure one step downward. It calls the `NewFigure` method
    if it fails to move the figure downward. The `NewFigure` method tries to introduce
    a new figure on the game board. If that fails, the `GameOver` method is called,
    which asks the user if they want a new game. The `NewGame` method is called if
    the user wants a new game. If the user does not want a new game, it exits the
    application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTimer`方法在窗口具有焦点时每秒被调用一次。它尝试将下落图形向下移动一步。如果无法将图形向下移动，它会调用`NewFigure`方法。`NewFigure`方法尝试在游戏板上引入一个新的图形。如果失败，则调用`GameOver`方法，询问用户是否想要新游戏。如果用户想要新游戏，则调用`NewGame`方法。如果用户不想要新游戏，则退出应用程序：'
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'the `DeleteFullRows` examines each row by calling the `IsRowFull` method and
    calls the `FlashRow` and `DeleteRow` methods for each full row:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteFullRows`通过调用`IsRowFull`方法检查每一行，并对每一行满的行调用`FlashRow`和`DeleteRow`方法：'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `TryClose`  method is called if the user tries to close the window by clicking
    on the cross in the top-right corner of the window. It displays a message box
    that asks the user if they really want to quit:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户通过点击窗口右上角的叉号尝试关闭窗口，则会调用`TryClose`方法。它显示一个消息框，询问用户是否真的想要退出：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `gameGrid` field holds the grid on which the figures are displayed (see
    the next section). The falling figure (`fallingFigure`) is falling down on the
    grid, and the next figure to fall down (`nextFigure`) is displayed in the top-right
    corner. Each time the player fills a row, the score (`currScore`) is increased.
    The timer identity (`TimerId`) is needed to keep track of the timer and is given
    the arbitrary value of `1000`. Finally, the figure list (`figureList`) will be
    filled with seven figures, one of each color. Each time a new figure is needed,
    a randomly chosen figure from the list will be chosen and copied:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameGrid`字段持有显示图形的网格（见下一节）。下落的图形（`fallingFigure`）正在网格上下降，下一个将要下降的图形（`nextFigure`）显示在右上角。每次玩家填满一行，分数（`currScore`）就会增加。计时器标识符（`TimerId`）用于跟踪计时器，并赋予任意值`1000`。最后，图形列表（`figureList`）将被填充七个图形，每种颜色一个。每次需要新的图形时，将从列表中随机选择一个图形并复制：'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `PreviewCoordinate` parameter in the `Window` constructor call indicates
    that the window''s size is fixed, and the second parameter indicates that the
    size is 100 * 100 units. This means that unlike the circle application, the size
    of figures and game boards will change when the user changes the window''s size:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Window`构造函数调用中的`PreviewCoordinate`参数表示窗口的大小是固定的，第二个参数表示大小为100 * 100个单位。这意味着与圆应用不同，图形和游戏板的大小会随着用户改变窗口大小而改变：
- en: '**TetrisWindow.cpp**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**TetrisWindow.cpp**'
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The upper 20 percent of the client area is reserved for the score and the next
    figure. The game grid covers the lower 80 percent of the client area (from height
    unit 20 to 100):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端区域的顶部20%被保留用于分数和下一个图形。游戏网格覆盖客户端区域的底部80%（从高度单位20到100）：
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we extend the `Window` class, we need to set the window header manually:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们扩展了`Window`类，我们需要手动设置窗口标题：
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The timer interval is set to `1000` milliseconds, which means that `OnTimer`
    will be called every second. The random generator is initialized by calling the
    C standard functions `srand` and `time`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器间隔设置为`1000`毫秒，这意味着`OnTimer`每秒会被调用一次。随机生成器通过调用C标准函数`srand`和`time`进行初始化：
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The figure list is initialized with one figure of each color; the falling and
    next figure are randomly chosen from that list. One of the figures in the list
    will be copied every time we need a new figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图形列表初始化时包含每种颜色的一个图形；下落和下一个图形从这个列表中随机选择。每次我们需要一个新的图形时，列表中的一个图形将被复制：
- en: '[PRE13]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Strictly speaking, it is not necessary to drop the timer when closing the Tetris
    window. The destructor is included only for the sake of completeness:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在关闭俄罗斯方块窗口时，没有必要丢弃计时器。析构函数仅为了完整性而包含：
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keyboard input
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘输入
- en: 'The `OnKeyDown` method overrides the method in the `Window` class and is called
    each time the user presses a key. We try to move the falling figure in accordance
    with the key pressed. We do not care whether the user has pressed the *Shift*
    or *Ctrl* key:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnKeyDown`方法覆盖了`Window`类中的方法，并在用户按下每个键时被调用。我们尝试根据按下的键移动下落的图形。我们不在乎用户是否按下了*Shift*或*Ctrl*键：'
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the user presses the Space key, the falling figure falls with visible
    speed to create the illusion of falling. We try to move the falling figure one
    step down every 10 milliseconds by calling the Win32 API function `Sleep`. The
    `TryMoveDown` method returns `false` when it is no longer possible to move the
    figure downward:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下空格键时，下落的图形以可见的速度下落，以产生下落的错觉。我们尝试通过调用Win32 API函数`Sleep`，每10毫秒将下落的图形下移一步：
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Drawing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图
- en: 'The `OnDraw` method starts by drawing the game grid and two lines dividing
    the client area into three parts. The top-left corner displays the current score,
    the top-right corner displays the next figure, and the lower part displays the
    actual game grid:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDraw`方法首先绘制游戏网格和两条将客户端区域分为三部分的线。左上角显示当前分数，右上角显示下一个图形，而下半部分显示实际的游戏网格：'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that we add an offset when drawing the next figure in order to move from
    the game grid to the top-right corner. The value `25` moves the figure from the
    middle of the grid to the middle of its right half, and the value `-18` moves
    from the grid up to the area preceding the grid:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在绘制下一个图形时添加了一个偏移量，以便从游戏网格移动到右上角。值`25`将图形从网格中间移动到其右半部分的中间，而值`-18`则从网格向上移动到网格前的区域：
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The score font is set to `Times New Roman`, size `10`. Here, the size does
    not refer to typographical points, but to logical units. Since the call to the
    `Window` constructor states we gave the `PreviewCoordinate` coordinate system
    and the size 100 * 100, the height of the text will be 10 units, which is a tenth
    of the text client area''s height. It is also half the height of the part of the
    client area where the score is written:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 分数字体设置为`Times New Roman`，大小`10`。在这里，大小不是指排版点数，而是指逻辑单位。由于调用`Window`构造函数时声明我们提供了`PreviewCoordinate`坐标系和大小100
    * 100，文本的高度将是10个单位，这是文本客户端区域高度的十分之一。它也是客户端区域中记分部分高度的一半：
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final `false` parameter in the call to the `DrawText` method indicates
    that the size of the text won''t be recalculated. In the next chapters, we will
    display text that maintains the same size, regardless of the window size and the
    screen resolution. In this chapter, however, the size of the text will be changed
    when the user changes the size of window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`DrawText`方法时的最终`false`参数表示文本的大小不会重新计算。在接下来的章节中，我们将显示保持相同大小的文本，无论窗口大小和屏幕分辨率如何。然而，在本章中，当用户更改窗口大小时，文本的大小将会改变：
- en: '[PRE20]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Input focus
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入焦点
- en: 'The `OnGainFocus` and `OnLoseFocus` methods start and stop the timer, respectively,
    so that the falling figure does not fall down when the window is out of focus:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnGainFocus`和`OnLoseFocus`方法分别开始和停止计时器，这样当窗口失去焦点时，下落图形不会下落：'
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The timer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器
- en: 'The timer is active when it has the input focus. When active, the `TryMoveDown`
    method will be called every time the `OnTimer` method is called (once every second).
    When the figure cannot fall down any more (the `TryMoveDown` method returns `false`),
    the `EndOfFigure` method is called:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时器具有输入焦点时，计时器处于活动状态。当活动时，每次调用`OnTimer`方法（每秒一次）时都会调用`TryMoveDown`方法。当图形无法再下落（`TryMoveDown`方法返回`false`）时，将调用`EndOfFigure`方法：
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: New figures
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新图形
- en: 'When it is not possible for the falling figure to move downward, the `OnTimer`
    method calls the `NewFigure` method. First, we need to store the falling figure
    to the game grid by calling the `AddToGrid` method. Then, we let the next figure
    become the new falling figure and we choose by random the new next figure from
    the figure list. We invalidate the area of the new falling figure and the area
    of the top-right corner where the next figure is drawn:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当下落图形无法向下移动时，`OnTimer`方法调用`NewFigure`方法。首先，我们需要通过调用`AddToGrid`方法将下落图形存储到游戏网格中。然后，我们将下一个图形变为新的下落图形，并从图形列表中随机选择新的下一个图形。我们使新的下落图形区域和绘制下一个图形的右上角区域无效：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We delete the possible full rows and update the window:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除可能的完整行并更新窗口：
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the new falling figure is not valid from the very beginning, the game is
    over and `GameOver` is called:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的下落图形从一开始就不有效，则游戏结束并调用`GameOver`：
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Game over
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束
- en: The `GameOver` method presents the score and lets the user decide whether they
    want a new game. If they want a new game, it is initialized by the `NewGame` call.
    If the user does not want a new game, the call to the Win32 API function `PostQuitMessage`
    terminates the execution of the application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameOver`方法显示分数并让用户决定他们是否想要新游戏。如果他们想要新游戏，它将通过`NewGame`调用进行初始化。如果用户不想玩新游戏，调用Win32
    API函数`PostQuitMessage`将终止应用程序的执行。'
- en: 'Note that we call another version of the `Invalidate` method, without parameters.
    It invalidates the whole client area:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们调用另一个版本的`Invalidate`方法，没有参数。它使整个客户端区域无效：
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The timer is inactive while the message is displayed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示消息时，计时器处于非活动状态：
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: New game
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新游戏
- en: 'The `NewGame` method initializes the randomly chosen new falling and next figures,
    resets the score, and clears the game grid before activating the timer, as well
    as invalidates and updates the window, which makes the new falling figure starting
    to fall and the new game to begin:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGame`方法初始化随机选择的新下落和下一个图形，重置分数，并在激活计时器之前清除游戏网格，以及使窗口无效并更新，这使得新的下落图形开始下落，新的游戏开始：'
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting and flashing rows
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除和闪烁行
- en: When deleting full rows, we loop through the rows, flashing and removing each
    full row. We increase the score and update the area of the row. Note that the
    rows start at the top of the grid. This means that we have to loop from the highest
    row to the lowest row in order to delete the row in the right order.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除完整行时，我们遍历行，闪烁并删除每一行。我们增加分数并更新行区域。请注意，行从网格的顶部开始。这意味着我们必须从最高行到最低行进行循环，以便按正确顺序删除行。
- en: 'Note that if the row becomes flashed and deleted, we do not update the `row`
    variable since the deleted row will be replaced by the row above, which also needs
    to be examined:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果行被闪烁并删除，我们不会更新`row`变量，因为被删除的行将被上面的行替换，这也需要被检查：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A row is considered full if it does not contain a white square:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行不包含白色正方形，则认为该行是满的：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The flash effect is executed by redrawing the row in normal and inversed color
    (the `inverse` method is set) three times with an interval of 50 milliseconds.
    While doing this, it is especially important that we only invalidate the area
    of the chosen row. Otherwise, the whole window client area will be flashed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁效果是通过三次以50毫秒的间隔重新绘制行，在正常和反转颜色（`inverse`方法被设置）下实现的。在这个过程中，特别重要的是我们只使所选行的区域无效。否则，整个窗口客户端区域都会闪烁：
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When deleting a row, we do not really delete it. Instead, we move each row
    above the deleted row one step downward and fill the top row with white squares.
    A complication is that we count rows from the top. This makes the lowest row on
    the screen the row with the highest index. This gives the appearance that we start
    from the bottom and remove every full row until we reach the top:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除一行时，我们实际上并没有删除它。相反，我们将被删除行上面的每一行向下移动一步，并用白色正方形填充顶部行。一个复杂的问题是，我们是从顶部开始计数行的。这使得屏幕上最低的行是具有最高索引的行。这给人一种我们从底部开始，直到达到顶部，移除每一行完整行的外观：
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Closing the window
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭窗口
- en: 'Finally, when the user wants to close the window by clicking in the cross on
    the top-right corner, we need to confirm that they really want to quit. If the
    `TryClose` method returns `true`, the window is closed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户通过点击右上角的交叉点来关闭窗口时，我们需要确认他们确实想要退出。如果`TryClose`方法返回`true`，则窗口将被关闭：
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The TetrisFigure class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TetrisFigure类
- en: In this application, there is the root `figure` class and one subclass for each
    type of falling figure. All figures can be moved sideways or rotated as a response
    to the user's requests. They are also moved downward by the timer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，有一个根`figure`类和每个下落图形类型的一个子类。所有图形都可以在用户请求时向侧面移动或旋转。它们也由计时器向下移动。
- en: 'There are seven figures, one for each color: red, brown, turquoise, green,
    yellow, blue, and purple. Each of them also has a unique shape. However, they
    all contain four squares. They can further be divided into three groups based
    on their ability to rotate. The red figure is the simplest one. It is a square
    and does not rotate at all. The brown, turquoise, and green figure can be rotated
    in vertical and horizontal directions, while the yellow, blue, and purple figures
    can be rotated in north, east, south, and west directions. For the red figure,
    it does not really matter since it does not rotate.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个图形，每个颜色一个：红色、棕色、青色、绿色、黄色、蓝色和紫色。每个图形都有独特的形状。然而，它们都包含四个正方形。根据它们旋转的能力，它们可以进一步分为三组。红色图形是最简单的。它是一个正方形，根本不会旋转。棕色、青色和绿色图形可以在垂直和水平方向旋转，而黄色、蓝色和紫色图形可以在北、东、南、西方向旋转。对于红色图形来说，这并不重要，因为它根本不会旋转。
- en: The `row` and `col` fields of the `TetrisFigure` class hold the center of the
    figure, which is marked by a cross in the illustrations of this section. The `color`
    field holds the color of the figure, and `direction` holds the current direction
    of the figure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`TetrisFigure`类的`row`和`col`字段持有图形的中心，这在本节插图中的图形上用十字标记。`color`字段持有图形的颜色，`direction`持有图形的当前方向。'
- en: 'Finally, the `direction` array holds the relative positions of the three squares
    surrounding the marked square. There are four directions at most. Each direction
    holds three squares, which are the three remaining squares that are not the center
    of the figure. Each square holds two integers: the relative position of the center
    row and column.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`direction`数组持有围绕标记正方形的三个正方形的相对位置。最多有四个方向。每个方向持有三个正方形，它们是除了图形中心之外剩下的三个正方形。每个正方形持有两个整数：中心行的相对位置和列的相对位置。
- en: 'The default constructor is needed to initialize the `fallingFigure` and `nextFigure`
    methods in the `TetrisWindow` class. The second constructor is protected since
    it is only called by its sub classes. Each figure has its own `TetrisFigure` subclass.
    Their constructors take a pointer to the color grid and define its color, start
    position, and figure patterns:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数用于初始化`TetrisWindow`类中的`fallingFigure`和`nextFigure`方法。第二个构造函数是受保护的，因为它只被它的子类调用。每个图形都有自己的`TetrisFigure`子类。它们的构造函数接受指向颜色网格的指针，并定义其颜色、起始位置和图形模式：
- en: '**TetrisFigure.h**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**TetrisFigure.h**'
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TryMoveLeft`, `TryMoveRight`, `TryRotateClockwise`, `TryRotateClockwise`,
    `TryRotateAnticlockwise`, and `TryMoveDown` methods all try to move the figure.
    They call the `IsFigureValid` method, which checks whether the new location is
    valid, that is, it is not located outside the game grid or at a location already
    occupied. The `IsFigureValid` method, in turn, calls the `IsSquareValid` method
    for each of its four squares:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryMoveLeft`、`TryMoveRight`、`TryRotateClockwise`、`TryRotateClockwise`、`TryRotateAnticlockwise`
    和 `TryMoveDown` 方法都试图移动图形。它们调用 `IsFigureValid` 方法，该方法检查新位置是否有效，即它不在游戏网格外部或位于已被占用的位置。`IsFigureValid`
    方法反过来又为它的四个方块调用 `IsSquareValid` 方法：'
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two versions of the `IsFigureValid` method, where the first version
    is called by the `TetrisWindow` method and the other version is called by the
    preceding `try` methods in order to test whether a new location of the falling
    figure is valid:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureValid` 方法有两种版本，其中第一个版本由 `TetrisWindow` 方法调用，另一个版本由前面的 `try` 方法调用，以测试下落图形的新位置是否有效：'
- en: '[PRE36]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `AddToGrid` method adds the four squares of the figure to the game grid:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToGrid` 方法将图形的四个方块添加到游戏网格：'
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `InvalidateFigure` method invalidates the area occupied by the figure,
    and the `DrawFigure` method draws the figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidateFigure` 方法使图形占据的区域无效，`DrawFigure` 方法绘制图形：'
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `gameGridPtr` field is a pointer to the game grid, which we access when
    we try to move a figure in order to decide whether its new location is valid.
    The `color` field is the color of the figure (red, brown, turquoise, green, yellow,
    blue, or purple). The `row`, `col`, and `direction` fields hold the current location
    and direction of the figure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameGridPtr` 字段是指向游戏网格的指针，我们在尝试移动图形时访问它，以决定其新位置是否有效。`color` 字段是图形的颜色（红色、棕色、青绿色、绿色、黄色、蓝色或紫色）。`row`、`col`
    和 `direction` 字段持有图形的当前位置和方向。'
- en: 'The `figureInfo` field holds the shape of the figure. The figure can hold up
    to four directions: north, east, south, and west. Remember that `row` and `col`
    hold the location of the figures. More specifically, they hold the location of
    the center square of the four squares constituting the figure (marked by a cross
    in the following illustrations). The other three squares are defined by integer
    pairs holding their locations relative to the center square.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`figureInfo` 字段持有图形的形状。图形可以持有最多四个方向：北、东、南、西。记住，`row` 和 `col` 持有图形的位置。更具体地说，它们持有构成图形的四个方块的中心方块的位置（以下插图中的十字标记）。其他三个方块由整数对定义，表示它们相对于中心方块的位置。'
- en: 'Technically, `figureInfo` is an array of four pointers (one each for the directions
    north, east, south, and west). Each pointer points at an array of three integer
    pairs, holding the locations of the three squares relative to the center square:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`figureInfo` 是一个包含四个指针的数组（每个方向一个），每个指针指向一个包含三个整数对的数组，持有三个方块相对于中心方块的位置：
- en: '[PRE39]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The default constructor is necessary because `fallingFigure` and `nextFigure`
    are member objects of the `TetrisWindow` class. However, they do not need to be
    initialized since their values are assigned one of the seven figures in the `figureList`
    array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数是必要的，因为 `fallingFigure` 和 `nextFigure` 是 `TetrisWindow` 类的成员对象。然而，它们不需要初始化，因为它们的值被分配给
    `figureList` 数组中的七个图形之一：
- en: '**TetrisFigure.cpp**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**TetrisFigure.cpp**'
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second constructor is called by the colored figure sub class constructor
    in order to initialize the figure. It takes a pointer to the main window and the
    game grid, the color of the figure, its start location and direction, and its
    location lists in the north, east, south, and west directions. Each of the lists
    holds three integer pairs representing the location of the squares relative to
    the center square:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数由彩色图形子类构造函数调用，以初始化图形。它接受指向主窗口和游戏网格的指针、图形的颜色、其起始位置和方向，以及北、东、南、西方向的位置列表。每个列表都包含三个整数对，表示方块相对于中心方块的位置：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The assignment operator is necessary because the `fallingFigure` and `nextFigure`
    methods in the `TetrisWindow` class are copied from the figure list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符是必要的，因为 `TetrisWindow` 类中的 `fallingFigure` 和 `nextFigure` 方法是从图形列表复制的：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `TryMoveLeft`, `TryMoveRight`, `TryRotateClockwise`, and `TryRotateAnticlockwise`
    methods are called when the user presses the arrow keys. They try to move the
    figure and invalidate its previous and current area if they succeed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下箭头键时，会调用`TryMoveLeft`、`TryMoveRight`、`TryRotateClockwise`和`TryRotateAnticlockwise`方法。如果成功，它们会尝试移动图形并使其之前和当前区域无效：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `TryMoveDown` method is called by the timer when the player presses the
    Space key. It is also called by the `OnTimer` method in the `TetrisWindow` class;
    it returns a `Boolean` value indicating whether the movement succeeded:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下空格键时，计时器会调用`TryMoveDown`方法。它也会在`TetrisWindow`类的`OnTimer`方法中被调用；它返回一个`Boolean`值，表示移动是否成功：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first version of the `IsFigureValid` method is called by the `TetrisWindow`
    class and calls the second static version, with the current location and direction
    of the figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版本的`IsFigureValid`方法由`TetrisWindow`类调用，并调用第二个静态版本，带有图形的当前位置和方向：
- en: '[PRE45]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second version of the `IsFigureValid` method is called by the preceding
    `try` methods and checks if the figure is valid by calling the `IsSquareValid`
    method for each square in the figure. In order to do so, it needs to look up the
    relative positions of the included squares in the `figureInfo` method. The first
    value of the integer pairs is the row, and the second value is the column:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二版本的`IsFigureValid`方法由前面的`try`方法调用，并通过为图形中的每个方块调用`IsSquareValid`方法来检查图形是否有效。为了做到这一点，它需要在`figureInfo`方法中查找包含方块的相对位置。整数对的第一个值是行，第二个值是列：
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `IsSquareValid` method returns `true` if the given square is located inside
    the game grid and not already occupied. A square on the game board is considered
    unoccupied if it is white:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的方块位于游戏网格内且未被占用，则`IsSquareValid`方法返回`true`。如果方块是白色的，则认为它未被占用：
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the falling figure has reached its final position, it is added to the
    game grid. It is performed by setting the figure''s color to the squares in the
    game grid at its current location. A falling figure has reached its final position
    when it cannot fall any longer without colliding with an earlier figure or has
    reached the game grid''s lower bound:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当下落的图形达到其最终位置时，它将被添加到游戏网格中。这是通过将图形的颜色设置为游戏网格中当前位置的方块来完成的。当一个下落图形无法再下落而不会与之前的图形碰撞，或者已经达到游戏网格的底部边界时，它就达到了最终位置：
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When a figure has been moved, we need to redraw it. In order to avoid dazzle,
    we want to invalidate only its area, which is done by the `InvalidateFigure` method.
    We look up the rows and columns of the figure''s four squares and call the `InvalidateSquare`
    method in the game grid for each of them:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当图形被移动后，我们需要重新绘制它。为了避免炫目，我们只想使其区域无效，这是通过`InvalidateFigure`方法完成的。我们查找图形四个方块的行和列，并在游戏网格中对每个方块调用`InvalidateSquare`方法：
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When drawing the figure, we need to look up the locations of the squares of
    the figure before we draw them in a way similar to the `InvalidateFigure` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制图形之前，我们需要查找图形方块的定位，以类似于`InvalidateFigure`方法的方式绘制它们：
- en: '[PRE50]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The red figure
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色图形
- en: 'The red figure is one large square, built up by four smaller regular squares.
    It the simplest figure of the game since it does not change shape when rotating.
    This implies that we just need to look at one figure, shown as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 红色图形是一个大正方形，由四个较小的规则正方形组成。它是游戏中最简单的图形，因为它在旋转时不会改变形状。这意味着我们只需要查看一个图形，如下所示：
- en: '![The red figure](img/B05475_03_02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![红色图形](img/B05475_03_02.jpg)'
- en: 'This also implies that it is enough to define the squares for one direction
    and this to define the shape of the figure in all four directions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着只需要定义一个方向的方块就足够了，这样就可以定义图形在所有四个方向上的形状：
- en: '**RedFigure.h**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**RedFigure.h**'
- en: '[PRE51]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**RedFigure.cpp**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**RedFigure.cpp**'
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first integer pair (`rel row 0`, `rel col 1`) of the generic list represents
    the square to the right of the marked square, the second integer pair (`rel row
    1`, `rel col 0`) represents the square below the marked square, and the third
    integer pair (`rel row 1`, `rel col 1`) represents the square below and to the
    right of the marked square. Note that the rows increase downward and the columns
    increase to the right.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通用列表中的第一个整数对（`rel row 0`，`rel col 1`）表示标记方块的右侧方块，第二个整数对（`rel row 1`，`rel col
    0`）表示标记方块的下方方块，第三个整数对（`rel row 1`，`rel col 1`）表示标记方块的下方和右侧方块。请注意，行向下增加，列向右增加。
- en: The brown figure
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 棕色图形
- en: 'The brown figure can be oriented in a horizontal or vertical direction. It
    is initialized to vertical mode, as it can only be rotated into two directions.
    The north and south arrays are initialized with the vertical array and the east
    and west arrays are initialized with the horizontal array, as shown in the following
    image:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 棕色图形可以水平或垂直定向。它被初始化为垂直模式，因为它只能旋转到两个方向。北和南数组被初始化为垂直数组，而东和西数组被初始化为水平数组，如下图所示：
- en: '![The brown figure](img/B05475_03_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![棕色图形](img/B05475_03_03.jpg)'
- en: 'Since the row numbers increase downward and the column numbers increase to
    the right, the topmost square in the vertical direction (and the leftmost square
    in the horizontal direction) are represented by negative values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行号向下增加，列号向右增加，因此在垂直方向上最顶部的方块（以及水平方向上最左边的方块）由负值表示：
- en: '**BrownFigure.h**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**BrownFigure.h**'
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**BrownFigure.cpp**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**BrownFigure.cpp**'
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The turquoise figure
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 湖蓝色图形
- en: 'Similar to the brown figure, the turquoise figure can be rotated in a vertical
    and horizontal direction, as shown in the following figure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与棕色图形类似，湖蓝色图形可以在垂直和水平方向旋转，如下图所示：
- en: '![The turquoise figure](img/B05475_03_04.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![湖蓝色图形](img/B05475_03_04.jpg)'
- en: '**TurquoiseFigure.h**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**TurquoiseFigure.h**'
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**TurquoiseFigure cpp**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**TurquoiseFigure cpp**'
- en: '[PRE56]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The green figure
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色图形
- en: 'The green figure is mirrored in relation to the turquoise figure, shown as
    follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色图形相对于湖蓝色图形是镜像的，如下所示：
- en: '![The green figure](img/B05475_03_05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![绿色图形](img/B05475_03_05.jpg)'
- en: '**GreenFigure.h**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**GreenFigure.h**'
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**GreenFigure.cpp**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**GreenFigure.cpp**'
- en: '[PRE58]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The yellow figure
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄色图形
- en: 'The yellow figure can be rotated in a north, east, south, and west direction.
    It is initialized to the south, as shown in the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 黄色图形可以在北、东、南、西方向旋转。它被初始化为南方，如下图所示：
- en: '![The yellow figure](img/B05475_03_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![黄色图形](img/B05475_03_06.jpg)'
- en: '**YellowFigure.h**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**YellowFigure.h**'
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**YellowFigure.cpp**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**YellowFigure.cpp**'
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The blue figure
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄色图形
- en: 'The blue figure can also be directed in all four directions. It is initialized
    to the south, as shown in the following figure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色图形也可以在四个方向上定向。它被初始化为南方，如下图所示：
- en: '![The blue figure](img/B05475_03_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![蓝色图形](img/B05475_03_07.jpg)'
- en: '**BlueFigure.h**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**BlueFigure.h**'
- en: '[PRE61]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**BlueFigure.cpp**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**BlueFigure.cpp**'
- en: '[PRE62]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The purple figure
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紫色图形
- en: 'Finally, the purple figure is mirrored in relation to the blue figure and also
    initialized to the south, as shown in the following image:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，紫色图形相对于蓝色图形是镜像的，并且也初始化为南方，如下图所示：
- en: '![The purple figure](img/B05475_03_08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![紫色图形](img/B05475_03_08.jpg)'
- en: '**PurpleFigure.h**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**PurpleFigure.h**'
- en: '[PRE63]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**PurpleFigure.cpp**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**PurpleFigure.cpp**'
- en: '[PRE64]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The GameGrid class
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameGrid类
- en: 'Finally, the `GameGrid` class is quite simple. It keeps track of the squares
    on the game board. The `gridArea` field is the portion of the total client area
    that is occupied by the grid:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GameGrid`类相当简单。它跟踪游戏板上的方块。`gridArea`字段是占据总客户端区域的部分：
- en: '**GameGrid.h**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameGrid.h**'
- en: '[PRE65]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When called by the `TetrisWindow` constructor, the grid area will be set to
    (0, 20, 100, 100) units, placing it in the lower 80 percent of the client area
    of the window:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当由`TetrisWindow`构造函数调用时，网格区域将被设置为(0, 20, 100, 100)单位，将其放置在窗口客户端区域的底部80%：
- en: '**GameGrid.cpp**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameGrid.cpp**'
- en: '[PRE66]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When clearing the grid, we actually set every square to white:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当清除网格时，我们实际上将每个正方形设置为白色：
- en: '[PRE67]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Invalidating and drawing squares
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无效化和绘制正方形
- en: 'The `DrawGameGrid` iterates through the squares of the grid. White squares
    are surrounded by white borders, while squares of every other color are surrounded
    by black borders. If the `inverseColor` parameter is true, the square color is
    inversed before drawn. This is useful when flashing rows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawGameGrid` 遍历网格中的方块。白色方块被白色边框包围，而其他颜色的方块被黑色边框包围。如果`inverseColor`参数为真，则在绘制之前反转方块颜色。这在闪烁行时很有用：'
- en: '[PRE68]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that the `InvalidateSquare` and `DrawSquare` methods add an offset. It
    is zero in all cases except when invalidating or drawing the next figure in the
    `TetrisWindow` class. Both methods calculate the size of the rows and columns
    of the grid and define the area of the square invalidated or drawn:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`InvalidateSquare` 和 `DrawSquare` 方法添加了一个偏移量。在所有情况下都是零，除非在`TetrisWindow`类中无效化或绘制下一个图形。两种方法都计算网格的行和列的大小，并定义无效化或绘制的正方形区域：
- en: '[PRE69]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a Tetris game. You looked into timing and randomization,
    as well as a new coordinate system, more advanced drawing, how to catch keyboard
    events, and how to write text.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个俄罗斯方块游戏。你了解了时间控制和随机化，以及一个新的坐标系，更高级的绘图方法，如何捕捉键盘事件，以及如何编写文本。
- en: In [Chapter 4](ch04.html "Chapter 4. Working with Shapes and Figures"), *Working
    with Shapes and Figures*, we will develop a drawing program capable of drawing
    lines, arrows, rectangles, and ellipses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理形状和图形")，*处理形状和图形*中，我们将开发一个能够绘制线条、箭头、矩形和椭圆的绘图程序。
