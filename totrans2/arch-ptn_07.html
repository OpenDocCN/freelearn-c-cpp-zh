<html><head></head><body>
        

                            
                    <h1 class="header-title">Service-Oriented Architecture (SOA)</h1>
                
            
            
                
<p>You might have wondered about many websites having different kinds of dashboards showing distinct yet relevant contents, and how in this world it is possible to combine a weather report and stock market quotes in one display.</p>
<p>Weather reports and stock quotes are functionally different systems; one is the meteorological area and the other one is the national stock exchange, yet they can be combined and shown in a single dashboard.</p>
<p>So, if we need to define what a web service is, then a<em>ny reusable, custom-developed software code that lets heterogeneous applications talk to each other and disparate systems get integrated in a cost-effective manner</em> could be our definition.</p>
<p>We can design a software system that integrates disparate data sources and different ecosystems that can evolve and mature over time in a better and cost-effective way by adopting fundamental SOA principles and characteristics in every service design.</p>
<p>In this chapter, we will cover the following topics as part of SOA:</p>
<ul>
<li>Web services and SOA</li>
<li>Introduction to SOA</li>
<li>Life cycle of SOA</li>
<li>Primary characteristics of SOA</li>
<li>Principles of SOA</li>
<li>SOA design patterns</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Web services and SOA</h1>
                
            
            
                
<p>The first step for any web service design is to start with strict adherence to SOA characteristics and principles. Basic building blocks and stepping stones for any web service design are the SOA architecture patterns.</p>
<p>SOA is the most favorable and proven architectural design style that helps to solve a few key problems within modern software systems to handle ever-changing user expectations efficiently.</p>
<div><img height="278" width="476" src="img/92c193f0-e544-4cc0-8ef5-ff6e73da500b.png"/></div>
<p>Recently, in many real-time cloud applications, SOA has become the foundation of cloud efforts, and a lot of convergence with the private and public cloud as well. Certainly, SOA is playing a significant role in the background with virtualization, event processing, business process management, and much more in real-world applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to SOA</h1>
                
            
            
                
<p>SOA is an architectural style of services and not a technology or any programming language. It defines standards and ways to design and develop a service. </p>
<p>Service is the logical representation of repeatable business activities* that have a specified outcome. It is self-contained, Provides guidelines to combine a service with other services. It is also an abstract or black box to the consumer who consumes it.</p>
<p>*The following are a few examples of business activities with specific outcomes:</p>
<ul>
<li>Get city's weather report</li>
<li>Get stock quote of given stock code</li>
<li>Get hotel booking details by booking ID</li>
<li>Get user profile information for given user ID</li>
</ul>
<p>In short, SOA is essentially a collection of services, and those services communicate with each other, and a service is an operation or a function that is well-defined, self-contained, and independent of other service contexts and states.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Life cycle of SOA</h1>
                
            
            
                
<p>Let's first touch upon the life cycle of SOA, and briefly discuss each stage in the life cycle, before we get into the characteristics of SOA.</p>
<div><img height="279" width="344" src="img/0ae4fd2a-c71b-4e3a-862a-fe0ac8dc7d09.png"/></div>
<p>Any services are discoverable by having a clear set of communication standards such as WSDL, SOAP, REST, and so on, and therefore they are picked up for consumption.</p>
<p>Service design is the next critical item in which we need to find a proper pattern and deliver services as model-driven, business function-specific, testable in isolation, and so on, and the most common patterns are discussed in detail later in this chapter.</p>
<p>For any business or organization, after the functional design phase, it is important to have services that are developed, deployed, and consumed. However, unlike waterfall methodology (customer waits until all the components are developed), it is better if the service development and deployment happen in an iterative and agile fashion, so customers meet ROI in short-term. </p>
<p>Governance and feedback are crucial for any evolving service, as they play a critical role in service adoption and help businesses to achieve ROI as soon as possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Primary characteristics of SOA</h1>
                
            
            
                
<p>Any functional system or component that is SOA-based has its unique characteristics. However, in this section, we will cover fundamental elements that are uncompromising in any SOA-based designs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service interconnectivity with well-defined interfaces</h1>
                
            
            
                
<p>Interoperability or interconnectivity between the two involving systems is a critical aspect of SOA. To achieve interoperability, architects should analyze the system deeper and come up with a greater level of detail so that they can define well-defined interfaces. Those interfaces in SOA embody interaction points between the system and its boundaries, which should be standardized, explicit, behavior predictable, scalable, and sustainable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard interfaces and Service level agreements</h1>
                
            
            
                
<p>The interfaces should be well-thought and standardized. The response of a weather report can evolve faster without any changes in the client's request (payload). In the weather forecast web service, the city name can be a key element; however, the city can have different climatic conditions within the city, and to get precise weather conditions, the interface needs longitude and latitude along with the city name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Event-driven and messaging</h1>
                
            
            
                
<p>Loose coupling is one of the essential primary characteristics of SOA, and it can be easily achieved by having event-driven and messaging as part of a service's design. The services that we design should represent a business function or domain and consider an application that needs to send an email to the user immediately after booking a hotel and assume we have a hotel booking service that can book a hotel and send a confirmation email to the user. As per the business functions, we can have two different services; one that takes care of the hotel booking, and another one that takes care of the post-booking process such as email, mobile confirmations, and so on. The email service can receive events from the booking service, or it can listen for any messages from other systems, depending on its event-driven design or message-driven design.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flexible</h1>
                
            
            
                
<p> Repeatable and Reusable is another essential characteristic of SOA, so services should be flexible with fewer constraints in the policies and accomplish reusability and repeatability with no impact on the clients who are already consuming the services. In these situations, designers would get concerns about service optimizations and performance improvements. However, the flexibility should be given preference over optimizations.</p>
<p class="mce-root">Let’s get some insights about flexibility. Consider a client (consumer) access a weather report for a given city by its name, there are chances that the given city can respond with more than one results (City’s airport, downtown and so on), so potentially the results can be more than one. In that situation how do we design a payload to respond with only one row, maybe the request payload should have a placeholder to accept longitude and latitude as seen in the below XML snippet and so the response of the service shows only one result, not many?</p>
<div><img height="258" width="455" src="img/46a4567d-e530-4700-b173-f6b7f1c0ab2c.png"/></div>
<p class="mce-root">In another scenario, assume the consumer wanted to search weather conditions for a city called Dover, which is a duplicate name across the world (more than 50 cities name is Dover around the world), so to find unique Dover, the payload should also have the flexibility to mention State and Country or Zip code.</p>
<p class="mce-root">To achieve flexibility, one should not hard-wire any elements in the client payloads that are prone to change, and also evaluate alternate approaches that yield advantages and greater flexibility for the services and its’ centralized functions.</p>
<p class="mce-root">How do we justify flexibility over service optimization? If we consider the service need to respond with weather conditions for the city name Dover, there may be multiple calls involved; one to find a list of cities by name Dover, the second one to call specific Dover with intended State, and Country or Zip code. So expected results for the consumer is vital than reducing the number of calls to the services. So in this kind of situations, considering the flexibility over optimization is a better approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Evolution</h1>
                
            
            
                
<p>The beauty of software product development is that <em>any software product can be given for consumption once it reaches the minimum viable stage in real quick while product development keeps introducing more and more features</em>.<br/>
This seamless feature usage may not be possible in other major industries. For instance, in the automobile sector, we may not have the luxury of releasing the product before its completion in all the aspects. As we cannot manufacture wheels or engines and start using them, we have to wait until it comes out as a car and is quality certified.<br/>
In software development, it is so beautiful that we can create financial systems with just a few features for a customer to use, while we keep developing and deploying new features into production so that more and more functionalities can be consumed by the customers seamlessly. SOA designs can create a perfect example of software and system evolution.</p>
<div><img height="224" width="222" src="img/d4c4f824-06d6-4099-a881-df76cea0dcd9.png"/></div>
<p>Let's pick our same weather report example; the services can start by accepting a city name and zip code, later enhanced with longitude and latitude, then with IP addresses, and then the location from where it is searched, with not just current weather details, but with hourly, daily, and weekly forecasts. In our introduction section, we mentioned that <em>to handle the ever-changing and high demand of user expectations very effectively,</em> services should be evolved and flexible in order to manage the demands and not force the client to modify their way of consuming services.</p>
<p>Other common characteristics of evolution are as follows:</p>
<ul>
<li>Services are transport independent</li>
<li>Services are software platform independent</li>
<li>Choreography versus orchestration of services</li>
<li>Explicit calls</li>
<li>Services represent a business function or domain</li>
<li>Location of services are transparent, discoverable, and support introspection</li>
</ul>
<p>However, we are not covering all of those in detail, and we encourage readers to refer to other materials on all these design principles for more detailed discussions.</p>
<p>Many authors and references point out that service orientation can be related to the separation of concern principles, and that is true as long as it does not share the states between the entities and maintains the atomicity of the services.</p>
<p>One must have faced challenges implementing these practices especially with legacy, non-service based monolithic systems. They may be still consumable and making money. However, they are not scalable and incurs high maintenance. So how can we change those legacy systems into independent, scalable, high-performance services?; It can be done by following SOA principles, practices and with suitable SOA patterns. So let us learn deeper and get insights into SOA principles and Patterns in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Principles of SOA</h1>
                
            
            
                
<p>Though there are no specifications or standards that are comprehensive of SOA principles, we can define some tenets as a core principle of SOA that helps to realize all the characteristics of SOA. Adherence to these principles is evident to stand up any service and for its consumptions.</p>
<p>We will touch upon those principles rather briefly in this section, and in addition to that, there is a handy matrix that depicts relationships of the SOA life cycle, characteristics, and principles at the end of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standardized service contract</h1>
                
            
            
                
<p>Standardization is a fundamental principle of any SOA. Services exhibit their functions and their capabilities through a service contract, forcing the SOA designer to focus on service granularity, data types to be exposed, purposes of services, service optimization, service versions to be exposed, service endpoints, and more, of all service standardizations. <strong>Service level agreement</strong> (<strong>SLA</strong>) for any services are established with this principle to provide clear vision and direction of consumptions, governance, security, versioning, requests, and responses. Standardization ensures, service contracts are well defined and way the path for rest o f the principles and leads to more and more service consumptions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service interoperability</h1>
                
            
            
                
<p>Interoperability is another important principle of SOA. The ability to share information between services is interoperability, and it helps applications to realize efficient communications across distributed services on various software platforms. Interoperability applies on different levels such as operational (business process), informational, and technical architecture stages that determine how systems can communicate with each other at each level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service abstraction</h1>
                
            
            
                
<p>Providing a simplified view of services by hiding internal details (complexity) helps better explain the function and operation of services, helps the consumer to focus on the core business logic of the services, and protects internal implementations from unintentional changes. Abstractions can be applied at every level from language implementation to the service level. Earlier in this chapter, the stock quote services talked only about getting quotes of a given stock ID and nothing else, it does not say how it interacts with details of the company that the customer asked for, neither how it connects to the stock exchange's dynamic data, nor how new business details get added to the system. What they all need to know as a consumer of a service is whether the service can pick the quote for their favorite company, not how you get it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service autonomy</h1>
                
            
            
                
<p>Autonomy is a way of achieving isolations of a service's executions from its shared resources, and releasing the services with no impact on the client who is already using the earlier version of the service. Services can be developed, versioned, tested, and deployed, while consumers continue to use previous versions or seamless changes to the service that they consume, and this brings enormous benefit to the customers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service composability</h1>
                
            
            
                
<p>Services are useful composition participants regardless of size and complexity of the composition. Services can be the orchestrator of different other services, and that orchestrator service adheres all the SOA characteristics.</p>
<p><br/>
Service compositions are often applied to legacy software applications to avoid the risk of retrofit; applying customized solutions and continuous operation of the production by retaining the existing software solutions.</p>
<p><br/>
If you observe this principle, it warrants a separation of concern to be exercised. In the life cycle of services, we understand clearly that the services evolve with more and more functionalities. With applying loose coupling as well as service reusability, it is inevitable that we need to keep providing more and more additional requirements or solve more and more problems for the customer. Recall the point of our evolution characteristic, and this principle is related to evolution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service discoverability</h1>
                
            
            
                
<p>Services lose their purpose if they are not exposed or published to internal or external entities. Services are rated by their usage and by the number of customers using the service, regardless of its consumption by external or internal customers. It is challenging to find the available services even within internal teams, but with utmost care and effort, we can bring best practices on discoverability. Standardization of services also helps to achieve better discoverability.</p>
<p>If the services are not exposed or published to internal or external entities, then they have lost their purpose. Services evaluated by their usage and number of customers using the service could be internal or external. Challenges still exist in finding the available services to consume even within internal teams, and utmost care and effort to bring best practices to ensure this principle is followed is the key so that the services evolve and the organization keeps getting its ROI iteratively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service loose coupling</h1>
                
            
            
                
<p>Loose coupling is one of the core design principles that help the services to realize automaticity, test in isolation, and so service can evolve with no impact on the service functionalities. This principle intends to apply various aspects of loose coupling at different levels, and it may vary according to the application contexts as well.</p>
<p>Let's take our email service as an example. The booking service sends a notification to the email service once it completes the hotel reservation, and regardless of the email server status (it may be even down, but the booking service doesn’t need to wait until the email servers come up). So, the email service can decide when to send an email; it may be during off-peak hours, there may be different scheduled times, maybe once the email server is up and running after its scheduled maintenance, perhaps resending the failed deliveries, and so on.</p>
<p>So, the design of email services handles the loose coupling principles as in this context, it is most elegant and preferable. Most of us would agree that it is not always in all the designs and at all the levels that we can bring this principle, as it may not help the business functions. For instance, in the email service and booking service, the booking and email services can be independent and loosely coupled; the email service is dependent on the email server and applying the loose coupling principle is not feasible. Our other service that provides the weather report is dependent on the location service, and in this context, coupling may be an acceptable design.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service reusability</h1>
                
            
            
                
<p>Service reusability is one of the core principles and brings a realization of flexible and evolution characteristics of services-oriented architecture. The design aspects should consider a set of business functions or logic that can be made available without duplicating the code to numerous internal or external clients.</p>
<p>Reuse is a strong OO principle, and it is imperative in the service level as well. With agnostic functional contexts, the services are resources, and so can be reused at maximum level; more the reuse, more the ROI.</p>
<p>In our examples, location services, email services, weather report services, and stock quote services are all reusable and logical separations of business functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service statelessness</h1>
                
            
            
                
<p>Services should be stateless as much as they can. Statelessness is another important principle that helps services to lower the consumption of resources, test in isolation, and reusability. To implement statelessness in the email service, it needs all the necessary information explicitly for sending emails, and so it does not need to pick up additional information from a database or any other resources as its focus is on the business logic of setting up schedules to send emails. The schema can have more details (message, email IDs, subject) explicitly, rather that just booking ID, and make an email service to pick up additional information from the database for that booking ID.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SOA design patterns</h1>
                
            
            
                
<p>In the current software design world, we already have time-tested software solutions for specific recurring problems. Best practices and the way that software design solves the repeatable problems in a quick and cost-effective manner creates reusable patterns over time, and it is a rule of thumb that we should be able to pick up and use the right ones for our design problems.</p>
<p>SOA deals with a number of design patterns, and numerous materials discuss each one in depth. We would like to touch upon a few of the most important ones that real-time software solutions often require.</p>
<p>We will deal with the following patterns in this chapter: </p>
<ul>
<li>Service messaging</li>
<li>Message screening</li>
<li>Agnostic services</li>
<li>Atomic service transaction</li>
<li>Authentication broker</li>
<li>Message origin authentication</li>
<li>Service façade</li>
<li>Multiple service contracts</li>
<li>Service callback</li>
<li>Event-driven messaging</li>
<li>Service refactor</li>
<li>Metadata centralization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Service messaging</h1>
                
            
            
                
<p>Service messaging provides a communication platform through which messages are transmitted and routed as independent units. It brings the efficient execution of loosely coupled service interactions and data exchanges.</p>
<p>Off the shelf, <strong>message-oriented middleware</strong> (<strong>MOM</strong>) queues are the best example of service messaging. MOM queues can have a single sender or receiver or multiple senders and receivers, and some applications even require to use of multiple Queues will help in decoupling discreet and distinct components of a system.</p>
<p>Most SOA implementations use MOM queues, and it is hard to find an SOA-compliant system without a messaging system.</p>
<p>The benefits of service messaging are as follows:</p>
<ul>
<li>A service messaging pattern in your design makes your design solution a best fit and elegant for any clients who want to communicate to services asynchronously</li>
<li>It is an implementation of loose coupling and one of the core principles of SOA</li>
<li>With service messaging, the following are made easy and elegant:
<ul>
<li>Fail-safe and loop back in services</li>
<li>Versioning of services</li>
<li>Record, defer, and replay</li>
<li>Multiplexed messages</li>
</ul>
</li>
<li>Best fit for concurrency models as immutable messages are thread safe</li>
</ul>
<p>The impacts of service messaging are as follows:</p>
<ul>
<li>Asynchronous communications lead to reliability concerns in some cases, unlike the services that receive the client response immediately</li>
<li>As service messaging involves Asynchronous communication to other systems, there may be a need to engage further systems that manage and supports the service process and executions (more systems to be operated and maintained).</li>
<li>Need to rely more on messaging systems (dependency on messaging systems)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Message screening</h1>
                
            
            
                
<p>The services are susceptible to injection attacks: injecting malicious data into services that leads to undesirable behavior. The services can prevent any harmful message content by screening data when it is received at the server side, even before the service uses it.</p>
<div><img src="img/35dcd842-ea67-4b37-a0e4-86d8781d2b5c.png"/></div>
<p>The services should assume that all input messages it receives are harmful, and therefore all those messages should undergo various checks to find any presence of malicious content and protect the services from any harmful content.</p>
<p>The benefits of message screening are as follows:</p>
<ul>
<li>Eliminates different types of injection attacks</li>
<li>Prevents resource exhaustion due to injection attacks</li>
<li>Service is protected from malicious content even before its consumption</li>
<li>Service validates messages regardless of whether the client validated it or not</li>
</ul>
<p>The impacts of message screening are as follows:</p>
<ul>
<li>Screening logic for each message incurs additional runtime</li>
<li>Processing binary messages or binary attachments needs to have specialized logic for screening</li>
<li>It is hard or even impossible to find and limit all potentially harmful content by message screening</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Agnostic services</h1>
                
            
            
                
<p>Consider various functions of financial banking such as account management, life insurance, lending or loan management, wealth management, and so on. Each service might need to share the abilities of other services, rather having them as duplicated rather then reused.</p>
<div><img height="226" width="585" src="img/03992ab2-9672-4259-a999-9257264bc5d3.png"/></div>
<p>Consider a home loan management service that needs to know the savings account details of the borrower, other retail lending information for credit reports, and mortgage information from property management. So, those capabilities are common concerns for any lending service that can be defined and used by not only the home loan systems but by any other major system such as credit cards, life insurance products, account management services, investment management services, and so on.</p>
<p>Implementing business logic for a set of well-defined capabilities that address major common concerns and are certainly not specific to one problem but common to multiple business problems, are called agnostic services.</p>
<p>The separation of agnostic business logic or capabilities into discrete services helps enterprises with service reuse and composability.</p>
<div><img height="259" width="523" src="img/a3070aff-0ca8-49c8-a78a-9b5a5f6a9466.png"/></div>
<p>As the preceding example depicts, having the services explicitly state that they are agnostic helps the imminent consumers and designers to reuse the existing agnostic services.</p>
<p>The benefits of agnostic services are as follows:</p>
<ul>
<li>Exercising service reusability and composability</li>
<li>Consumers benefit from iterative refinements of service capabilities beyond initial service definitions</li>
<li>Enables multi-purpose capabilities, and those would be the most preferred conventional capabilities</li>
</ul>
<p>The impacts of agnostic services are as follows:</p>
<ul>
<li>Improvement of a service's abilities through its advantages of preliminary analysis takes a lot of time and considerations, and more iterations are needed for development</li>
<li>Arriving at a universal consensus on service functions might be challenging as business functions of services might be too vague or too generic</li>
<li>Need more design planning and considerations, as agnostic services design push us to consider many design parts those are not necessarily need to be deliberated for short-term or mid-term delivery, and so may lead us to end up in missing delivery commitments</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Atomic service transaction</h1>
                
            
            
                
<p>The rollback of operations is so important in a distributed environment. When any one of the runtime activities that span across multiple services fails, then all the transactions that have happened so far should be rolled back, otherwise the distributed services may compromise the integrity of the software solution.</p>
<div><img height="242" width="435" src="img/76eb961b-ed15-4fe3-9672-c19cef2e2200.png"/></div>
<p>In a typical online savings account transaction, the banking system would have withdrawal and deposit services, and if either one of the service calls fail for any reason, the bank system would end up in an inconsistent state regardless of the sequence of the service calls (first withdrawal or deposit, or vice versa).</p>
<p>The preceding diagram shows a failed transaction of credit to the target account, which leads to the rollback of a debit transaction from the source account.</p>
<p>So, as an implementation, the runtime service activities are wrapped in a transaction with explicit reversal logic, ensuring all actions and changes are rolled back in case of the current operations failing.</p>
<p>The benefits of atomic service transactions are as follows:</p>
<ul>
<li>Helps to propagate the rollback mechanism across message-based business services</li>
<li>Effective implementation of the stateless principle</li>
</ul>
<p>The impacts of atomic service transactions is that it might need more memory resources depending on the number of transactions to be preserved its original state until commit or rollback notification.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication broker</h1>
                
            
            
                
<p>A service consumer uses a mechanism to validate an identity to the called resource, and a caller's identity is verified based on the credentials presented by that caller. Credentials can be passwords, the digital certificate provided by a certificate authority, biometrics, ATM PIN, or combinations of any of these types.</p>
<p>In most cases, authentication is the first step to determine the eligibility of access to the web service, and the second phase is to verify that the user is authorized to access the web service.</p>
<p>For identity-based authorization, one can verify the claims contained within the authenticated user's credentials. Depending on the privileges provided to the client, the service can either grant or deny access to the underlying resources. The token authentication mechanism is a useful authentication model of fine-grained authorization.</p>
<div><img height="315" width="448" src="img/b285237e-9cc0-4e99-a711-d962a4c822b2.png"/></div>
<p>The preceding diagram depicts an online banking user who gets access to online banking debit transactions by contacting the authentication services, which authenticates against the central identity store. Then, the service responds with the token so that the user can consume the withdrawal service and the deposit service.</p>
<p>The authentication broker pattern helps to realize the authentication and authorization by a centralized identity store. The authentication services assume complete responsibility and provide a token that the consumer can use to access the service.</p>
<p>The following example shows a digital signature and x509 information and messages to be validated for authentication and authorization of its content. The authentication service uses that information and validates the messages for any tampering, then the authentication service will not generate a valid token, and so the application denies access to the feature:</p>
<div><p>The benefits of the authentication broker are as follows:</p>
<ul>
<li>Centrally managed trust (authentication) and so helps to eliminate the need for each client and service to manage their authentication independently</li>
<li>Easy to accomplish agreements and updates happen at one place without impacting any clients</li>
<li>Participants of brokered authentication do not require prior knowledge of one another to communicate</li>
<li>Security tokens can be used across organizational boundaries and provide autonomous security domains</li>
</ul>
<p>The impact of the authentication is, it sometimes create a single point of failure, and any security breach could impact the entire service across inventory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message origin authentication</h1>
                
            
            
                
<p>Imagine a situation where Rose is doing an online money transfer from her bank account to Jack's account. However, Jack did not receive the amount to his account, but Rose's account is showing that the amount is deducted. So, what would've happened to the money that Rose transferred?</p>
<p>It is possible that Jack's account number got modified or tampered with by an intruder's account number in intermediate layers, and so all the money got credited to the different account.</p>
<div><img height="304" width="477" src="img/90189ca5-8926-47de-961e-bbe26d8f3260.png"/></div>
<p>The message sent by a service consumer gets processed by one or more intermediate layers such as routers, message queues, and so on. The attacker could manipulate the messages in any of the intermediate layers and influence the service behavior for the evil purpose.</p>
<p>Message origin authentication (or data origin authentication) suggests to use a digital signing mechanism for transmitting sensitive messages, and so the service can verify the signature to ensure received messages are initiated by the originator, and has not been tampered with on the way.</p>
<p>Applying the digital signature algorithm to the payload as proof of origin provides tamper-proof messages. Services that receive this information verify the signature by using an algorithm, and it should match. If it does not match, then the service rejects the messages.</p>
<p>So, the message origin authentication validates two important aspects of security:</p>
<ul>
<li>
<p><strong>Data integrity</strong>: The message has not been modified or tampered with on the way to the service</p>
</li>
<li>
<p><strong>Authenticated</strong>: The received message at the service side is originated from the intended sender and not from anyone else</p>
</li>
</ul>
<p>The benefits of message origin authentication are as follows:</p>
<ul>
<li>Detect tampering of received messages</li>
<li>Trace the origin of the messages to an identifiable source</li>
</ul>
<p class="mce-root">The impacts of message origin authentication are as follows:</p>
<ul>
<li>Performance issues due to cryptographic implementations</li>
<li>Choice of digital signing algorithm and variations in number and type of the key would be an additional overhead</li>
<li>Selection of digital signing algorithm can affect the level of security achieved as it varies according to the degree of security the application needs</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Service façade</h1>
                
            
            
                
<p>Imagine a building that needs to undergo maintenance work. The outer wall of the building is replaceable without impacting the internal structure, and it is called a façade. The exterior walls are torn off and replaced at one wing of the building at a time, while the other wing is in use.</p>
<p>Roughly, we can relate the same concept to the service façade in SOA. While some clients use the existing services, any enhancements to the services can be carried over with no impacts to consumer contracts as they continue to use an older service version.</p>
<div><img height="266" width="471" src="img/2a9afecd-5ee9-444b-ab7f-4d30d9b91a31.png"/></div>
<p>The pattern of segregating the core logic of services from the service contracts is called the service façade. The service façade facilitates loose coupling between the client contracts, thereby, in case of any changes to the services, it does not affect its customers and they do not need to modify their code.</p>
<p>When designing a service, the architect needs to watch out for any negative coupling, such as the contract to logic that creates dependencies upon the contract, and so whenever the service changes, the contract is also likely to change, so impacting all the service consumers who do not expect any impact.</p>
<p>The service façade eliminates this sort of coupling by establishing an interface between the core service logic and the service contract. The service façade logic allows contracts to remain decoupled from the underlying logic and further shields it from its core business logic. It applies to both functional and behavioral changes and so helps the services to evolve.</p>
<p>The service façade sits between the service and the service contract. Service façades can support multiple contracts. Note that multiple service contracts talk to the same service façade and only the service façades are coupled to the contract, not actual services, thus the services are independent and loosely coupled. If a contract changes, it minimizes the changes to the service.</p>
<div><img height="314" width="458" src="img/9d83093f-7445-45f4-a37d-2cf3e008ef70.png"/></div>
<p>The preceding diagram depicts a service that serves multiple contracts for different business functions. The <em>user info summary search</em> and <em>user info partial update</em> are good examples of a contract-specific service façades having specific business logic to serve the clients without having any impacts on the client or services.</p>
<p>The benefits of the service façade are as follows:</p>
<ul>
<li>Façade shields the services and consumers of the services from the changes in the canonical model</li>
<li>Façade hides the complexities of the canonical model</li>
<li>Façade returns data representations agreed by the consumer</li>
<li>Façade makes your design elegant</li>
</ul>
<p>The impacts of the service façade are as follows:</p>
<ul>
<li>Due to the service façade having very user-specific business logic, it incurs additional development and maintenance costs</li>
<li>Façades tend to create an extra physical distribution of services that lead to more complexity and additional processing overhead</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiple service contract</h1>
                
            
            
                
<p>One standard contract may not be suitable or applicable for all the potential service consumers. For instance, one service contract should be allowed to update complete profile information, while another contract should not be allowed a full update, but only partial updates are allowed. Though a profile update is one single service, two different consumers need two separate contracts. The multiple service contract pattern helps to exercise the preceding options. The service façade and the multiple service contract are related, and the service façade helps the systems to realize multiple or concurrent contracts.</p>
<p>Multiple contracts or concurrent contracts serve two purposes. One is to support backward compatibility of a service, and the other one is to bring different views of a service for various uses.</p>
<div><img height="279" width="407" src="img/29e30ee9-e67e-4571-b12f-0d446fc964fe.png"/></div>
<p>The encircled rectangles in the preceding diagram represent multi-service contracts, and both connect to the same service but for two different purposes. In the preceding example, one service contract is allowed to update only a few fields of a profile, while another contract can update all the fields of a profile. So, multiple contracts for the same service helps different consumers use the services for distinct purposes. </p>
<p>The benefits of the multiple service contract are as follows:</p>
<ul>
<li>Can support backward and forward compatibility</li>
<li>Multiple version management keeps the customer end with no impact on any new changes to the services</li>
</ul>
<p>The impact of the multiple service contract is such as this pattern considers as many contracts, however, each new contract, ends up in new service endpoint to inventory and might hamper the service governance and high maintenance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service callback</h1>
                
            
            
                
<p>Assume you are calling a customer care center from your telephone. Once connected, you hear an automated message saying that all of their customer care executives are busy, and so ask you to wait on the line. You may even be one of many waiting for the same service executive (concurrency and multiple threads). Now, you have two options to choose from; one is to hold the line and wait for someone to speak to, and two is to hang up and try again after some time. However, trying again after some time may have you ending up in the same situation. </p>
<p>How about the customer care executive calls you back? You dial the number, the system picks up your number, and says that it will call you back automatically when the customer care executive is free so that you do not need to wait. </p>
<p>Imagine a web service that takes a longer time to complete its tasks, but the caller or the consumer of the service does not want to wait for all the tasks to be completed, and also the consumer needs to know once all the process/tasks get completed. This is similar to our earlier example of a client calls a customer care executive but do not want to wait in the queue either.</p>
<p>Service callback pattern implementation is the best approach to fulfil such requirements.</p>
<div><img height="354" width="505" src="img/118d9dc5-4aa9-4e11-8129-214b410cb2fd.png"/></div>
<p>The preceding diagram depicts various calling systems (a web page, telephone, and contact center app) using a callback app that exercises the service callback pattern.</p>
<div><img height="314" width="592" src="img/8dbc4cb1-b4d1-46c5-a5fe-ae36bfb998c3.png"/></div>
<p>The service callback pattern suggests that the consumers of services communicate asynchronously with the services and make sure to provide callback addresses in the message, with which services can use the same callback address to communicate back with the client.</p>
<p>The preceding diagram depicts a scenario of a consumer calling the service asynchronously through the message. The message contains the callback address, so once the service completes its process, it uses the callback address to communicate and respond back. The service callback address can be a phone number, an email address, or it can be another service endpoint that can do further business logic and respond to consumers.</p>
<div><img height="201" width="410" src="img/1eec0305-ece0-44c1-830b-7726be663596.png"/></div>
<p>In our first example, the callback address is the client's phone number, which the service would call. The second example may contain an email address or callback URL (of the same or even another service) with the status of upload as a response.</p>
<p>The benefits of the service callback are as follows:</p>
<ul>
<li>Extremely useful in cases where the request needs to wait for a longer response time</li>
<li>Best implementation of loose coupling of services</li>
<li>Best choice for message broadcast requirements</li>
</ul>
<p>The impacts of the service callback are as follows:</p>
<ul>
<li>As this patterns mostly deals with asynchronous communication, it may introduce reliability concerns</li>
<li>May require more infrastructure upgrades to support the necessary callback correlation</li>
<li>Handling request and response errors is usually more challenging</li>
</ul>
<p>More examples of a service message with the service callback pattern design are as follows:</p>
<ul>
<li>A software system that needs a service to load a large file and read its content line by line then upload to the database probably after validating each line. As it is typically massive in size and the caller of the system cannot wait for the longer process to complete, at the same time, a notification is sent to the caller once the upload is complete.</li>
<li>Stock trading system and stock quote ticker services.</li>
<li>Booking complete status, email notifications, and so on.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Event-driven messaging</h1>
                
            
            
                
<p>One of the core patterns of event-driven architecture is event-driven messaging; services (publishers) notify their consumers (subscribers) with relevant events when they happen, while customers are not necessarily waiting or aware of that event.</p>
<p>Imagine a stock trading service notifying its users whenever a particular stock price goes up:</p>
<div><img height="405" width="390" src="img/3fc5b685-4d3a-4c9b-ac23-d979fc10b7d2.png"/></div>
<p>The preceding diagram depicts a cycle of notification process kicks in when a stock price hit a particular  threshold; the subscriber lets event manager knows the intention, and the publisher publish (informs) when the event occurs. The $X is the predefined limit or sale price, and it is the event here. The following diagram depicts a sample pay load of the same.</p>
<div><img height="246" width="392" src="img/779a495c-c129-48be-a3dd-b6048e638197.png"/></div>
<p>The benefits of event-driven messaging are as follows:</p>
<ul>
<li>Best pattern for integration intentions between cross-functional boundaries and services</li>
<li>Achieve a higher degree of automation of process with less complexity</li>
</ul>
<p>The impacts of event-driven messaging are as follows:</p>
<ul>
<li>Creates additional complexity while incorporating message exchanges as part of atomic services</li>
<li>Depends on publisher and subscriber services availability</li>
<li>Needs to address ripple effects of reliability issues by combining other relevant patterns in event-driven messaging design</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Service refactoring</h1>
                
            
            
                
<p>In many situations, the services undergo many changes without any impact to the service contracts. It could be a simple software update improving the performance of a system, database updates, programming version upgrades, and so on.</p>
<p>Service refactoring helps to improve the service by changing the internals without changing its behavior, and so causing no impact on service contracts.</p>
<div><img height="459" width="638" src="img/52deff5b-ce40-42a1-8002-164eefb4964c.png"/></div>
<p>In the preceding diagram (encircled at the top-right as service refactor), the identity management system has undergone refactoring to improve the performance of its response time and has been upgraded with fail fast capabilities. There is no impact on the banking client, and it continues to use the same authentication services but with improved service capabilities.</p>
<p>The benefits of service refactoring are as follows:</p>
<ul>
<li>Easy update of heavily dependent services without affecting any of its consumers</li>
<li>No changes to functional behavior after upgrades</li>
<li>With limited scope minimizes adverse impacts to the service consumers</li>
</ul>
<p>The impacts of service refactoring are as follows:</p>
<ul>
<li>May lead to add more governance efforts</li>
<li>Might introduce potentially adverse side effects (improved performance but handling of concurrent requests could lead to lower availability)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Metadata centralization</h1>
                
            
            
                
<p>Having a centralized service catalog and providing a formal process of service registration and discovery is inevitable to any organization, and so limiting the risk of building services or functionality that already exists, or that is already under development.</p>
<p>The following diagram depicts a service registry that holds the information of published services, and so the service consumers would look up and bind those registered services for a runtime bind and invoke:</p>
<div><img height="370" width="648" src="img/67fc4eed-f519-46eb-8a8c-2ee06575a618.png"/></div>
<p>The information of the services and its functionalities are available to benefit the enterprises with</p>
<ul>
<li>Services discoverability</li>
<li>Inventory normalization</li>
<li>Standardization for service reusability</li>
<li>Provide ways to minimize the risk of redundancy.</li>
<li>Publish services with functional and QoS meta-data.</li>
</ul>
<p>This pattern applies to one-domain service inventories, or even to several inventories.</p>
<div><img height="94" width="317" src="img/134d35fb-ffc1-462d-b239-e327484d3b37.png"/></div>
<div><img height="277" width="471" src="img/31805181-f227-4ca7-aafd-01703ddce40f.png"/></div>
<p>The benefits of the sample catalog are as follows:</p>
<ul>
<li>Minimizes the risk of building functionality that already exists</li>
<li>Helps in service normalization</li>
<li>Helps in compelling discovery and interpretation</li>
<li>Runtime discovery and binding</li>
<li>Ensures metadata standardization</li>
</ul>
<p>The impacts of the sample catalog are as follows:</p>
<ul>
<li>Due to metadata standardization, the documentation and registration need to be part of the service delivery lifecycle (additional governance)</li>
<li>Service registry needs to be adequately mature and reliable to lead to strict governing and maintenance</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Principles and patterns cross reference</h1>
                
            
            
                
<p>The following table has references to SOA principles and related SOA patterns for each principle. This matrix might come in handy when you want to refer to a common design pattern and its associated SOA design principle:</p>
<table>
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Principles</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Patterns</strong></p>
</td>
</tr>
<tr>
<td>
<p>Standardized service contract/service interoperability</p>
</td>
<td>
<ul>
<li>Service messaging</li>
<li>Message screening</li>
<li>Agnostic services</li>
<li>Multiple contracts</li>
<li>Event-driven messaging</li>
<li>Service callback</li>
<li>Service façade</li>
<li>Service refactoring</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service abstraction</p>
</td>
<td>
<ul>
<li>Service refactoring</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service autonomy</p>
</td>
<td>
<ul>
<li>Event-driven messaging</li>
<li>Service messaging</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service composability</p>
</td>
<td>
<ul>
<li>Agnostic services</li>
<li>Message origin authentication</li>
<li>Service callback</li>
<li>Authentication broker</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service discoverability</p>
</td>
<td>
<ul>
<li>Metadata centralization</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service loose coupling</p>
</td>
<td>
<ul>
<li>Service messaging</li>
<li>Event-driven messaging</li>
<li>Service callback</li>
<li>Service façade</li>
<li>Multiple contracts</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service reusability</p>
</td>
<td>
<ul>
<li>Agnostic services</li>
<li>Multiple contracts</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Service statelessness</p>
</td>
<td>
<ul>
<li>Atomic service transaction</li>
</ul>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned about what <em>SOA</em> is, and its fundamental characteristics such as service interconnectivity, event-driven and messaging, flexible, service evolution, along with a few other common characteristics. In later sections, we covered SOA principles such as service contract standards, interoperability abstraction, service autonomy, service composability, reusability, and statelessness in detail. </p>
<p>We also learned about the most common SOA design patterns and where those patterns can be applied so that one can build SOA-compliant services. The patterns that we touched upon are service messaging, message screening, agnostic services, atomic service transaction, authentication broker, message origin authentication, service façade, multiple service contract, service callback, event-driven messaging, service refactoring, and metadata centralization. </p>


            

            
        
    </body></html>