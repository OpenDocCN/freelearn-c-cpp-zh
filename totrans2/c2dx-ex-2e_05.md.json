["```cpp\nauto designSize = Size(1536, 2048);\n\nglview->setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy::EXACT_FIT);\n\nstd::vector<std::string> searchPaths;\nif (screenSize.width > 768) {\n  searchPaths.push_back(\"ipadhd\");\n  director->setContentScaleFactor(1536/designSize.width);\n} else if (screenSize.width > 320) {\n  searchPaths.push_back(\"ipad\");\n  director->setContentScaleFactor(768/designSize.width);\n} else {\n  searchPaths.push_back(\"iphone\");\n  director->setContentScaleFactor(380/designSize.width);\n}\nauto fileUtils = FileUtils::getInstance();\nfileUtils->setSearchPaths(searchPaths);\n```", "```cpp\n    _jet = ParticleSystemQuad::create(\"jet.plist\");\n    _jet->setSourcePosition(Vec2(-_rocket->getRadius() * 0.8f,0));\n    _jet->setAngle(180);\n    _jet->stopSystem();\n    this->addChild(_jet, kBackground);\n\n    _boom = ParticleSystemQuad::create(\"boom.plist\");\n    _boom->stopSystem();\n    this->addChild(_boom, kForeground);\n\n    _comet = ParticleSystemQuad::create(\"comet.plist\");\n    _comet->stopSystem();\n    _comet->setPosition(Vec2(0, _screenSize.height * 0.6f));\n    _comet->setVisible(false);\n    this->addChild(_comet, kForeground);\n\n    _pickup = ParticleSystemQuad::create(\"plink.plist\");\n    _pickup->stopSystem();\n    this->addChild(_pickup, kMiddleground);\n\n    _warp = ParticleSystemQuad::create(\"warp.plist\");\n    _warp->setPosition(_rocket->getPosition());\n    this->addChild(_warp, kBackground);\n\n    _star = ParticleSystemQuad::create(\"star.plist\");\n    _star->stopSystem();\n    _star->setVisible(false);\n    this->addChild(_star, kBackground, kSpriteStar);\n    ```", "```cpp\nstd::vector<Point> _grid;\n```", "```cpp\nCCLOG(\"POSSIBLE STARS: %i\", _grid.size());\n```", "```cpp\nstd::random_shuffle(_grid.begin(), _grid.end());\n```", "```cpp\n    _energy -= dt * _energyDecrement;\n    if (_energy < 0) _energy = 0;\n    clear();\n\n    switch (_lineType) {\n      case LINE_NONE:\n       break;\n      case LINE_TEMP:\n       drawLine(_tip, _pivot, Color4F(1.0, 1.0, 1.0, 1.0));\n       drawDot(_pivot, 5, Color4F(Color3B::WHITE));\n       break;\n\n      case LINE_DASHED:\n       drawDot(_pivot, 5, Color4F(Color3B::WHITE));\n       int segments = _lineLength / (_dash + _dashSpace);\n       float t = 0.0f;\n       float x_;\n       float y_;\n\n       for (int i = 0; i < segments + 1; i++) {\n          x_ = _pivot.x + t * (_tip.x - _pivot.x);\n          y_ = _pivot.y + t * (_tip.y - _pivot.y);\n          drawDot(Vec2(x_, y_), 5, Color4F(Color3B::WHITE));\n          t += (float) 1 / segments;\n       }\n       break;\n    }\n    ```", "```cpp\n    drawLine(Vec2(_energyLineX, _screenSize.height * 0.1f),  Vec2(_energyLineX, _screenSize.height * 0.9f), Color4F(0.0, 0.0, 0.0, 1.0)); \n    drawLine(Vec2(_energyLineX, _screenSize.height * 0.1f),  Vec2(_energyLineX, _screenSize.height * 0.1f + _energy *  _energyHeight ), Color4F(1.0, 0.5, 0.0, 1.0));\n    ```", "```cpp\ndrawLine(_tip, _pivot, Color4F(1.0, 1.0, 1.0, 1.0));\ndrawDot(_pivot, 5, Color4F(Color3B::WHITE));\n```", "```cpp\nfor (int i = 0; i < segments + 1; i++) {\n\n    x_ = _pivot.x + t * (_tip.x - _pivot.x);\n    y_ = _pivot.y + t * (_tip.y - _pivot.y);\n\n    drawDot(Vec2(x_, y_), 5, Color4F(Color3B::WHITE));\n    t += (float) 1 / segments;\n}\n```", "```cpp\nif (flag) {\n    this->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName(\"rocket_on.png\"));\n} else {\n    this->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName(\"rocket.png\"));\n}\n```", "```cpp\n    Point position = this->getPosition();\n    if (_rotationOrientation == ROTATE_NONE) {\n      position.x += _vector.x * dt;\n      position.y += _vector.y * dt;\n    } else {\n      float angle = _angularSpeed * dt;\n      Point rotatedPoint = position.rotateByAngle(_pivot, angle);\n      position.x = rotatedPoint.x;\n      position.y = rotatedPoint.y;\n      float rotatedAngle;\n\n      Point diff = position;\n      diff.subtract(_pivot);\n      Point clockwise = diff.getRPerp();\n\n      if (_rotationOrientation == ROTATE_COUNTER) {\n        rotatedAngle = atan2 (-1 * clockwise.y, -1 * clockwise.x);\n      } else {\n        rotatedAngle = atan2 (clockwise.y, clockwise.x);\n      }\n\n      _vector.x = _speed * cos (rotatedAngle);\n      _vector.y = _speed * sin (rotatedAngle);\n      this->setRotationFromVector();\n\n      if (this->getRotation() > 0) {\n        this->setRotation( fmodf(this->getRotation(), 360.0f) );\n      } else {\n        this->setRotation( fmodf(this->getRotation(), -360.0f) );\n      }\n    }\n    ```", "```cpp\n    if (_targetRotation > this->getRotation() + 180) {\n      _targetRotation -= 360;\n    }\n    if (_targetRotation < this->getRotation() - 180) {\n      _targetRotation += 360;\n    }\n\n    this->setPosition(position);\n    _dr = _targetRotation - this->getRotation() ;\n    _ar = _dr * _rotationSpring;\n    _vr += _ar ;\n    _vr *= _rotationDamping;\n    float rotationNow = this->getRotation();\n    rotationNow += _vr;\n    this->setRotation(rotationNow);\n    ```", "```cpp\n    if (!_running) return true;\n    Point tap = touch->getLocation();\n    float dx = _rocket->getPositionX() - tap.x;\n    float dy = _rocket->getPositionY() - tap.y;\n    if (dx * dx + dy * dy <= pow(_rocket->getRadius(), 2) ) {\n     _lineContainer->setLineType ( LINE_NONE );\n     _rocket->setRotationOrientation ( ROTATE_NONE );\n     _drawing = true;\n    }\n\n    return true;\n    ```", "```cpp\n    if (!_running) return;\n      if (_drawing) {\n         Point tap = touch->getLocation();\n         float dx = _rocket->getPositionX() - tap.x;\n         float dy = _rocket->getPositionY() - tap.y;\n         if (dx * dx + dy * dy > pow (_minLineLength, 2)) {\n           _rocket->select(true);\n           _lineContainer->setPivot ( tap );\n           _lineContainer->setLineType ( LINE_TEMP );\n         } else {\n           _rocket->select(false);\n           _lineContainer->setLineType ( LINE_NONE );\n        }\n     }\n    ```", "```cpp\n    } else if (_state == kGamePaused) {\n      _pauseBtn->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName (\"btn_pause_off.png\"));\n      _paused->setVisible(false);\n      _state = kGamePlay;\n      _running = true;\n      return;\n    } \n    ```", "```cpp\n    if (!_running) return;\n    if(touch != nullptr) {\n      Point tap = touch->getLocation();\n      if (_pauseBtn->getBoundingBox().containsPoint(tap)) {\n        _paused->setVisible(true);\n        _state = kGamePaused;\n        _pauseBtn->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName (\"btn_pause_on.png\"));\n        _running = false;\n        return;\n      }\n    }\n    ```", "```cpp\n        _drawing = false;\n       _rocket->select(false);\n       if (_lineContainer->getLineType() == LINE_TEMP) {\n          _lineContainer->setPivot (tap);\n          _lineContainer->setLineLength ( _rocket->getPosition().distance( tap ) );\n          _rocket->setPivot (tap);\n    ```", "```cpp\n    float circle_length = _lineContainer->getLineLength() * 2 * M_PI;\n    int iterations = floor(circle_length / _rocket->getSpeed());\n    _rocket->setAngularSpeed ( 2 * M_PI / iterations);\n    ```", "```cpp\n    Vec2 diff = _rocket->getPosition();\n    diff.subtract(_rocket->getPivot());\n    Point clockwise = diff.getRPerp();\n    float dot =clockwise.dot(_rocket->getVector());\n    if (dot > 0) {\n       _rocket->setAngularSpeed ( _rocket->getAngularSpeed() * -1 );\n       _rocket->setRotationOrientation ( ROTATE_CLOCKWISE );\n       _rocket->setTargetRotation  ( CC_RADIANS_TO_DEGREES( atan2(clockwise.y, clockwise.x) ) );\n    } else {\n       _rocket->setRotationOrientation ( ROTATE_COUNTER );\n       _rocket->setTargetRotation ( CC_RADIANS_TO_DEGREES  (atan2(-1 * clockwise.y, -1 * clockwise.x) ) );\n    }\n    _lineContainer->setLineType ( LINE_DASHED );\n    ```", "```cpp\n    if (!_running || _state != kGamePlay) return;\n    if (_lineContainer->getLineType() != LINE_NONE) {\n      _lineContainer->setTip (_rocket->getPosition() );\n    }\n\n    if (_rocket->collidedWithSides()) {\n      _lineContainer->setLineType ( LINE_NONE );\n    }\n    _rocket->update(dt);\n\n    //update jet particle so it follows rocket\n    if (!_jet->isActive()) _jet->resetSystem();\n    _jet->setRotation(_rocket->getRotation());\n    _jet->setPosition(_rocket->getPosition());\n    ```", "```cpp\n    _cometTimer += dt;\n    float newY;\n\n    if (_cometTimer > _cometInterval) {\n        _cometTimer = 0;\n        if (_comet->isVisible() == false) {\n            _comet->setPositionX(0);\n            newY = (float)rand()/((float)RAND_MAX/_screenSize.height * 0.6f) + _screenSize.height * 0.2f;\n            if (newY > _screenSize.height * 0.9f) \n               newY = _screenSize.height * 0.9f;\n               _comet->setPositionY(newY);\n               _comet->setVisible(true);\n               _comet->resetSystem();\n        }\n    }\n\n    if (_comet->isVisible()) {\n        //collision with comet\n        if (pow(_comet->getPositionX() - _rocket->getPositionX(), 2) + pow(_comet->getPositionY() - _rocket->getPositionY(), 2) <= pow (_rocket->getRadius() , 2)) {\n            if (_rocket->isVisible()) killPlayer();\n        }\n        _comet->setPositionX(_comet->getPositionX() + 50 * dt);\n\n        if (_comet->getPositionX() > _screenSize.width * 1.5f) {\n            _comet->stopSystem();\n            _comet->setVisible(false);\n        }\n    }\n    ```", "```cpp\n    _lineContainer->update(dt);\n    _rocket->setOpacity(_lineContainer->getEnergy() * 255);\n    ```", "```cpp\n    for (auto planet : _planets) {\n        if (pow(planet->getPositionX() - _rocket->getPositionX(),  2)\n        + pow(planet->getPositionY() - _rocket->getPositionY(), 2)  <=   pow (_rocket->getRadius() * 0.8f + planet->getRadius()  * 0.65f, 2)) {\n\n            if (_rocket->isVisible()) killPlayer();\n            break;\n        }\n    }\n    ```", "```cpp\n    if (pow(_star->getPositionX() - _rocket->getPositionX(), 2)\n        + pow(_star->getPositionY() - _rocket->getPositionY(), 2)  <=\n        pow (_rocket->getRadius() * 1.2f, 2)) {\n\n        _pickup->setPosition(_star->getPosition());\n        _pickup->resetSystem();\n        if (_lineContainer->getEnergy() + 0.25f < 1) {\n            _lineContainer->setEnergy(_lineContainer->getEnergy() +  0.25f);\n        } else {\n            _lineContainer->setEnergy(1.0);\n        }\n        _rocket->setSpeed(_rocket->getSpeed() + 2);\n        if (_rocket->getSpeed() > 70) _rocket->setSpeed(70);\n            _lineContainer->setEnergyDecrement(0.0002f);\n            SimpleAudioEngine::getInstance()->playEffect(\"pickup.wav\");\n            resetStar();\n\n            int points = 100 - _timeBetweenPickups;\n            if (points < 0) points = 0;\n\n            _score += points;\n            _scoreDisplay->setString(String::createWithFormat(\"%i\", _score)->getCString());\n            _timeBetweenPickups = 0;\n    }\n    ```", "```cpp\n    _timeBetweenPickups += dt;\n    if (_lineContainer->getEnergy() == 0) {\n        if (_rocket->isVisible()) killPlayer();\n    }\n    ```", "```cpp\n    void GameLayer::killPlayer() {\n\n        SimpleAudioEngine::getInstance()->stopBackgroundMusic();\n        SimpleAudioEngine::getInstance()->stopAllEffects();\n        SimpleAudioEngine::getInstance()->playEffect(\"shipBoom.wav\");\n\n        _boom->setPosition(_rocket->getPosition());\n        _boom->resetSystem();\n        _rocket->setVisible(false);\n        _jet->stopSystem();\n        _lineContainer->setLineType ( LINE_NONE );\n\n        _running = false;\n        _state = kGameOver;\n        _gameOver->setVisible(true);\n        _pauseBtn->setVisible(false);\n    }\n    ```", "```cpp\n    void GameLayer::resetStar() {\n        Point position = _grid[_gridIndex];\n        _gridIndex++;\n        if (_gridIndex == _grid.size()) _gridIndex = 0;\n        //reset star particles\n        _star->setPosition(position);\n        _star->setVisible(true);\n        _star->resetSystem();\n    }\n    ```", "```cpp\n    void GameLayer::resetGame () {\n\n        _rocket->setPosition(Vec2(_screenSize.width * 0.5f,  _screenSize.height * 0.1f));\n        _rocket->setOpacity(255);\n        _rocket->setVisible(true);\n        _rocket->reset();\n\n        _cometInterval = 4;\n        _cometTimer = 0;\n        _timeBetweenPickups = 0.0;\n\n        _score = 0;\n        _scoreDisplay->setString(String::createWithFormat(\"%i\", _score)->getCString());\n\n        _lineContainer->reset();\n\n        //shuffle grid cells\n\n        std::random_shuffle(_grid.begin(), _grid.end());\n        _gridIndex = 0;\n\n        resetStar();\n\n        _warp->stopSystem();\n\n        _running = true;\n\n        SimpleAudioEngine::getInstance()->playBackgroundMusic(\"background.mp3\", true);\n        SimpleAudioEngine::getInstance()->stopAllEffects();\n        SimpleAudioEngine::getInstance()->playEffect(\"rocket.wav\", true);\n\n    }\n    ```", "```cpp\n    LOCAL_SRC_FILES := hellocpp/main.cpp \\\n                       ../../Classes/AppDelegate.cpp \\\n                       ../../Classes/GameSprite.cpp \\\n                       ../../Classes/LineContainer.cpp \\\n                       ../../Classes/Rocket.cpp \\\n                       ../../Classes/GameLayer.cpp  \n    ```"]