<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Data-driven Design"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Data-driven Design</h1></div></div></div><p>With the previous chapter adding the ability to create and handle game states, our framework has really begun to take shape. In this chapter, we will explore a new way to create our states and objects by removing the need to hardcode the creation of our objects at compile time. To do this we will parse through an external file, in our case an XML file, which lists all of the objects needed for our state. This will make our states generic as they can be completely different simply by loading up an alternate XML file. Taking <code class="literal">PlayState</code> as an example, when creating a new level we would need to create a new state with different objects and set up objects we want for that level. If we could instead load the objects from an external file, we could reuse the same <code class="literal">PlayState</code> and simply load the correct file depending on the current level we want. Keeping classes generic like this and loading external data to determine their state is called <span class="strong"><strong>Data-driven Design</strong></span>.<a class="indexterm" id="id332"/></p><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading XML files using the <span class="strong"><strong>TinyXML</strong></span> library</li><li class="listitem" style="list-style-type: disc">Creating a <span class="strong"><strong>Distributed Factory</strong></span></li><li class="listitem" style="list-style-type: disc">Loading objects dynamically using the factory and an XML file</li><li class="listitem" style="list-style-type: disc">Parsing a state from an XML file</li><li class="listitem" style="list-style-type: disc">Fitting everything together into the framework</li></ul></div><div class="section" title="Loading XML files"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Loading XML files</h1></div></div></div><p>I have chosen to use XML<a class="indexterm" id="id333"/> files because they are so easy to parse. We are not going to write our own XML parser, rather we will use an open source library called TinyXML. TinyXML was written by <span class="emphasis"><em>Lee Thomason</em></span> and is available under the zlib license from <a class="ulink" href="http://sourceforge.net/projects/tinyxml/">http://sourceforge.net/projects/tinyxml/</a>. </p><p>Once downloaded the only setup we need to do is to include a few of the files in our project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">tinyxmlerror.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tinyxmlparser.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tinystr.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tinystr.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tinyxml.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tinyxml.h</code></li></ul></div><p>Also, at the top of <code class="literal">tinyxml.h</code>, add this line of code:</p><div class="informalexample"><pre class="programlisting">#define TIXML_USE_STL</pre></div><p>By doing<a class="indexterm" id="id334"/> this we ensure that we are using the STL versions of the TinyXML functions. We can now go through a little of how an XML file is structured. It's actually fairly simple and we will only give a brief overview to help you get up to speed with how we will use it.</p><div class="section" title="Basic XML structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Basic XML structure</h2></div></div></div><p>Here is a basic XML file:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;ROOT&gt;
    &lt;ELEMENT&gt;
    &lt;/ELEMENT&gt;
&lt;/ROOT&gt;</pre></div><p>The first line<a class="indexterm" id="id335"/> of the file defines the format of the XML file. The second line is our <code class="literal">Root</code> element; everything else is a child of this element. The third line is the first child of the root element. Now let's look at a slightly more complicated XML file:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;ROOT&gt;
    &lt;ELEMENTS&gt;
        &lt;ELEMENT&gt;Hello,&lt;/ELEMENT&gt;
        &lt;ELEMENT&gt; World!&lt;/ELEMENT&gt;
    &lt;/ELEMENTS&gt;
&lt;/ROOT&gt;</pre></div><p>As you can see we have now added children to the first child element. You can nest as many children as you like. But without a good structure, your XML file may become very hard to read. If we were to parse the above file, here are the steps we would take:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load the XML file.</li><li class="listitem">Get the root element, <code class="literal">&lt;ROOT&gt;</code>.</li><li class="listitem">Get the first child of the root element, <code class="literal">&lt;ELEMENTS&gt;</code>.</li><li class="listitem">For each child, <code class="literal">&lt;ELEMENT&gt;</code> of <code class="literal">&lt;ELEMENTS&gt;</code>, get the content.</li><li class="listitem">Close the file.</li></ol></div><p>Another useful <a class="indexterm" id="id336"/>XML feature is the use of attributes. Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;ROOT&gt;
    &lt;ELEMENTS&gt;
        &lt;ELEMENT text="Hello,"/&gt;
        &lt;ELEMENT text=" World!"/&gt;
    &lt;/ELEMENTS&gt;
&lt;/ROOT&gt;</pre></div><p>We have now stored the text we want in an attribute named <code class="literal">text</code>. When this file is parsed, we would now grab the <code class="literal">text</code> attribute for each element and store that instead of the content between the <code class="literal">&lt;ELEMENT&gt;&lt;/ELEMENT&gt;</code> tags. This is especially useful for us as we can use attributes to store lots of different values for our objects. So let's look at something closer to what we will use in our game:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;STATES&gt;

&lt;!--The Menu State--&gt;
&lt;MENU&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="button.png" ID="playbutton"/&gt;
  &lt;texture filename="exit.png" ID="exitbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="100" y="100" width="400" 
  height="100" textureID="playbutton"/&gt;
  &lt;object type="MenuButton" x="100" y="300" width="400" 
  height="100" textureID="exitbutton"/&gt;
&lt;/OBJECTS&gt;
&lt;/MENU&gt;

&lt;!--The Play State--&gt;
&lt;PLAY&gt;
&lt;/PLAY&gt;

&lt;!-- The Game Over State --&gt;
&lt;GAMEOVER&gt;
&lt;/GAMEOVER&gt;
&lt;/STATES&gt;</pre></div><p>This is slightly<a class="indexterm" id="id337"/> more complex. We define each state in its own element and within this element we have objects and textures with various attributes. These attributes can be loaded in to create the state.</p><p>With this knowledge of XML you can easily create your own file structures if what we cover within this book is not to your needs.</p></div></div></div>
<div class="section" title="Implementing Object Factories"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Implementing Object Factories</h1></div></div></div><p>We are now armed with a little XML knowledge but before we move forward, we are going to take a look at Object Factories. <a class="indexterm" id="id338"/>An object factory is a class that is tasked with the creation of our objects. Essentially, we tell the factory the object we would like it to create and it goes ahead and creates a new instance of that object and then returns it. We can start by looking at a rudimentary implementation:</p><div class="informalexample"><pre class="programlisting">GameObject* GameObjectFactory::createGameObject(ID id)
{
  switch(id)
  {
    case "PLAYER":
      return new Player();
    break;
    
    case "ENEMY":
      return new Enemy();
    break;
    
    // lots more object types 
  }
}</pre></div><p>This function is very simple. We pass in an ID for the object and the factory uses a big switch statement to look it up and return the correct object. Not a terrible solution but also not a particularly good one, as the factory will need to know about each type it needs to create and maintaining the switch statement for many different objects would be extremely tedious. Just as when we covered looping through game objects in <a class="link" href="ch03.html" title="Chapter 3. Working with Game Objects">Chapter 3</a>, <span class="emphasis"><em>Working with Game Objects</em></span>, we want this factory not to care about which type we ask for. It shouldn't need to know all of the specific types we want it to create. Luckily this is something that we <a class="indexterm" id="id339"/>can definitely achieve.</p><div class="section" title="Using Distributed Factories"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Using Distributed Factories</h2></div></div></div><p>Through the use of Distributed Factories we can make a generic object factory that will create any of our types. <a class="indexterm" id="id340"/>Distributed factories allow us to dynamically maintain the types of objects we want our factory to create, rather than hard code them into a function (like in the preceding simple example). The approach we will take is to have the factory contain <code class="literal">std::map</code> that maps a string (the type of our object) to a small class called <code class="literal">Creator</code> whose only purpose is the creation of a specific object. We will register a new type with the factory using a function that takes a string (the ID) and a <code class="literal">Creator</code> class and adds them to the factory's map. We are going to start with the base class for all the <code class="literal">Creator</code> types. Create <code class="literal">GameObjectFactory.h</code> and declare this class at the top of the file.</p><div class="informalexample"><pre class="programlisting">#include &lt;string&gt;
#include &lt;map&gt;
#include "GameObject.h"

class BaseCreator
{
  public:

  virtual GameObject* createGameObject() const = 0;
  virtual ~BaseCreator() {}
};</pre></div><p>We can now go ahead and create the rest of our factory and then go through it piece by piece.</p><div class="informalexample"><pre class="programlisting">class GameObjectFactory
{
  public:

  bool registerType(std::string typeID, BaseCreator* pCreator)
  {
    std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
    m_creators.find(typeID);

    // if the type is already registered, do nothing
    if(it != m_creators.end())
    {
      delete pCreator;
      return false;
    }

    m_creators[typeID] = pCreator;

    return true;
  }

  GameObject* create(std::string typeID)
  {
    std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
    m_creators.find(typeID);

    if(it == m_creators.end())
    {
      std::cout &lt;&lt; "could not find type: " &lt;&lt; typeID &lt;&lt; "\n";
      return NULL;
    }

    BaseCreator* pCreator = (*it).second;
    return pCreator-&gt;createGameObject();
  }

  private:

  std::map&lt;std::string, BaseCreator*&gt; m_creators;

};</pre></div><p>This is quite<a class="indexterm" id="id341"/> a small class but it is actually very powerful. We will cover each part separately starting with <code class="literal">std::map m_creators</code>.</p><div class="informalexample"><pre class="programlisting">std::map&lt;std::string, BaseCreator*&gt; m_creators;</pre></div><p>This map holds the important elements of our factory, the functions of the class essentially either add or remove from this map. This becomes apparent when we look at the <code class="literal">registerType</code> function:<a class="indexterm" id="id342"/>
</p><div class="informalexample"><pre class="programlisting">bool registerType(std::string typeID, BaseCreator* pCreator)</pre></div><p>This function takes the ID we want to associate the object type with (as a string), and the creator object for that class. <a class="indexterm" id="id343"/>The function then attempts to find the type using the <code class="literal">std::mapfind</code> function:</p><div class="informalexample"><pre class="programlisting">std::map&lt;std::string, BaseCreator*&gt;::iterator it = m_creators.find(typeID);</pre></div><p>If the type is found then it is already registered. The function then deletes the passed in pointer and returns <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">if(it != m_creators.end())
{
  delete pCreator;
  return false;
}</pre></div><p>If the type is not already registered then it can be assigned to the map and then <code class="literal">true</code> is returned:</p><div class="informalexample"><pre class="programlisting">m_creators[typeID] = pCreator;
return true;
}</pre></div><p>As you can see, the <code class="literal">registerType</code> function is actually very simple; it is just a way to add types to the map. The <code class="literal">create</code> function is very similar:</p><div class="informalexample"><pre class="programlisting">GameObject* create(std::string typeID)
{
  std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
  m_creators.find(typeID);

  if(it == m_creators.end())
  {
    std::cout &lt;&lt; "could not find type: " &lt;&lt; typeID &lt;&lt; "\n";
    return 0;
  }

  BaseCreator* pCreator = (*it).second;
  return pCreator-&gt;createGameObject();
}</pre></div><p>The function looks for the type in the same way as <code class="literal">registerType</code> does, but this time it checks whether the type was not found (as opposed to found). If the type is not found we return <code class="literal">0</code>, and if the type is found then we use the <code class="literal">Creator</code> object for that type to return a new instance of it as a pointer to <code class="literal">GameObject</code>.</p><p>It is worth noting that the <code class="literal">GameObjectFactory</code> class should probably be a singleton. We won't cover how to make it a singleton as this has been covered in the previous chapters. Try implementing <a class="indexterm" id="id344"/>it yourself or see how it is implemented in the source code download.</p></div></div>
<div class="section" title="Fitting the factory into the framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Fitting the factory into the framework</h1></div></div></div><p>With our factory now in place, we can start altering our <code class="literal">GameObject</code> classes to use it. Our first step is to ensure that we have a <a class="indexterm" id="id345"/>
<code class="literal">Creator</code> class for each of our objects. Here is one for <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">class PlayerCreator : public BaseCreator
{
  GameObject* createGameObject() const
  {
    return new Player();
  }
};</pre></div><p>This can be added to the bottom of the <code class="literal">Player.h</code> file. Any object we want the factory to create must have its own <code class="literal">Creator</code> implementation. Another addition we must make is to move <code class="literal">LoaderParams</code> from the constructor to their own function called <code class="literal">load</code>. This stops the need for us to pass the <code class="literal">LoaderParams</code> object to the factory itself. We will put the <code class="literal">load</code> function into the <code class="literal">GameObject</code> base class, as we want every object to have one.</p><div class="informalexample"><pre class="programlisting">class GameObject
{
  public:

  virtual void draw()=0;
  virtual void update()=0;
  virtual void clean()=0;

  // new load function 
  virtual void load(const LoaderParams* pParams)=0;

  protected:

  GameObject() {}
  virtual ~GameObject() {}
};</pre></div><p>Each of our derived classes will now need to implement this <code class="literal">load</code> function. The <code class="literal">SDLGameObject</code> class will now look like this:</p><div class="informalexample"><pre class="programlisting">SDLGameObject::SDLGameObject() : GameObject()
{
}

voidSDLGameObject::load(const LoaderParams *pParams)
{
  m_position = Vector2D(pParams-&gt;getX(),pParams-&gt;getY());
  m_velocity = Vector2D(0,0);
  m_acceleration = Vector2D(0,0);
  m_width = pParams-&gt;getWidth();
  m_height = pParams-&gt;getHeight();
  m_textureID = pParams-&gt;getTextureID();
  m_currentRow = 1;
  m_currentFrame = 1;
  m_numFrames = pParams-&gt;getNumFrames();
}</pre></div><p>Our objects<a class="indexterm" id="id346"/> that derive from <code class="literal">SDLGameObject</code> can use this <code class="literal">load</code> function as well; for example, here is the <code class="literal">Player::load</code> function:</p><div class="informalexample"><pre class="programlisting">Player::Player() : SDLGameObject()
{

}

void Player::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
}</pre></div><p>This may seem a bit pointless but it actually saves us having to pass through <code class="literal">LoaderParams</code> everywhere. Without it, we would need to pass <code class="literal">LoaderParams</code> through the factory's <code class="literal">create</code> function which would then in turn pass it through to the <code class="literal">Creator</code> object. We have eliminated the need for this by having a specific function that handles parsing our loading values. This will make more sense once we start parsing our states from a file.</p><p>We have another issue which needs rectifying; we have two classes with extra parameters in their constructors (<code class="literal">MenuButton</code> and <code class="literal">AnimatedGraphic</code>). Both classes take an extra parameter as well as <code class="literal">LoaderParams</code>. To combat this we will add these values to <code class="literal">LoaderParams</code> and give them default values.</p><div class="informalexample"><pre class="programlisting">LoaderParams(int x, int y, int width, int height, std::string textureID, int numFrames, int callbackID = 0, int animSpeed = 0) :
m_x(x),
m_y(y),
m_width(width),
m_height(height),
m_textureID(textureID),
m_numFrames(numFrames),
m_callbackID(callbackID),
m_animSpeed(animSpeed)
{

}</pre></div><p>In other words,<a class="indexterm" id="id347"/> if the parameter is not passed in, then the default values will be used (0 in both cases). Rather than passing in a function pointer as <code class="literal">MenuButton</code> did, we are using <code class="literal">callbackID</code> to decide which callback function to use within a state. We can now start using our factory and parsing our states from an XML file.</p></div>
<div class="section" title="Parsing states from an XML file"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Parsing states from an XML file</h1></div></div></div><p>The file <a class="indexterm" id="id348"/>we will be <a class="indexterm" id="id349"/>parsing is the following (<code class="literal">test.xml</code> in source code downloads):</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;STATES&gt;
&lt;MENU&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="assets/button.png" ID="playbutton"/&gt;
  &lt;texture filename="assets/exit.png" ID="exitbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="100" y="100" width="400" 
  height="100" textureID="playbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="100" y="300" width="400" 
  height="100" textureID="exitbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/MENU&gt;
&lt;PLAY&gt;
&lt;/PLAY&gt;

&lt;GAMEOVER&gt;
&lt;/GAMEOVER&gt;
&lt;/STATES&gt;</pre></div><p>We are going to create a new class that parses our states for us called <code class="literal">StateParser</code>. The <code class="literal">StateParser</code> class<a class="indexterm" id="id350"/> has no data members, it is to be used once in<a class="indexterm" id="id351"/> the <code class="literal">onEnter</code> function of a state and then discarded when it goes out of scope. Create a <code class="literal">StateParser.h</code> file and add the following code:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "tinyxml.h"

class GameObject;

class StateParser
{
  public:

  bool parseState(const char* stateFile, std::string stateID, 
  std::vector&lt;GameObject*&gt; *pObjects);

  private:

  void parseObjects(TiXmlElement* pStateRoot, 
  std::vector&lt;GameObject*&gt; *pObjects);
  void parseTextures(TiXmlElement* pStateRoot, 
  std::vector&lt;std::string&gt; *pTextureIDs);

};</pre></div><p>We have three functions here, one public and two private. The <code class="literal">parseState</code> function takes the filename of an XML file as a parameter, along with the current <code class="literal">stateID</code> value and a pointer to <code class="literal">std::vector</code> of <code class="literal">GameObject*</code> for that state. The <code class="literal">StateParser.cpp</code> file will define this function:</p><div class="informalexample"><pre class="programlisting">bool StateParser::parseState(const char *stateFile, string 
stateID, vector&lt;GameObject *&gt; *pObjects, std::vector&lt;std::string&gt; 
*pTextureIDs)
{
  // create the XML document
  TiXmlDocument xmlDoc;

  // load the state file
  if(!xmlDoc.LoadFile(stateFile))
  {
    cerr &lt;&lt; xmlDoc.ErrorDesc() &lt;&lt; "\n";
    return false;
  }

  // get the root element
  TiXmlElement* pRoot = xmlDoc.RootElement();

  // pre declare the states root node
  TiXmlElement* pStateRoot = 0;
  // get this states root node and assign it to pStateRoot
  for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = 
  e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == stateID)
    {
      pStateRoot = e;
    }
  }

  // pre declare the texture root
  TiXmlElement* pTextureRoot = 0;

  // get the root of the texture elements
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("TEXTURES"))
    {
      pTextureRoot = e;
    }
  }

  // now parse the textures
  parseTextures(pTextureRoot, pTextureIDs);

  // pre declare the object root node
  TiXmlElement* pObjectRoot = 0;

  // get the root node and assign it to pObjectRoot
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("OBJECTS"))
    {
      pObjectRoot = e;
    }
  }

  // now parse the objects
  parseObjects(pObjectRoot, pObjects);

  return true;
}</pre></div><p>There is a lot of code in this <a class="indexterm" id="id352"/>function so it is worth covering in some depth. We will note the corresponding part of the XML file, along with the code we use, to obtain it. The first part of the function attempts to load the XML file that is passed into<a class="indexterm" id="id353"/> the function:</p><div class="informalexample"><pre class="programlisting">// create the XML document
TiXmlDocument xmlDoc;

// load the state file
if(!xmlDoc.LoadFile(stateFile))
{
  cerr &lt;&lt; xmlDoc.ErrorDesc() &lt;&lt; "\n";
  return false;
}</pre></div><p>It displays an error to let you know what happened if the XML loading fails. Next we must grab the root node of the XML file:</p><div class="informalexample"><pre class="programlisting">// get the root element
TiXmlElement* pRoot = xmlDoc.RootElement(); // &lt;STATES&gt;</pre></div><p>The rest of the nodes in the file are all children of this root node. We must now get the root node of the state we are currently parsing; let's say we are looking for <code class="literal">MENU</code>:</p><div class="informalexample"><pre class="programlisting">// declare the states root node
TiXmlElement* pStateRoot = 0;
// get this states root node and assign it to pStateRoot
for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == stateID)
  {
    pStateRoot = e;
  }
}</pre></div><p>This piece<a class="indexterm" id="id354"/> of code goes through each direct child of the root node and checks if its name is the same as <code class="literal">stateID</code>. Once it finds the correct node it assigns it to <code class="literal">pStateRoot</code>. We now have the root node of the state we want to parse.</p><div class="informalexample"><pre class="programlisting">&lt;MENU&gt; // the states root node</pre></div><p>Now that we<a class="indexterm" id="id355"/> have a pointer to the root node of our state we can start to grab values from it. First we want to load the textures from the file so we look for the <code class="literal">&lt;TEXTURE&gt;</code> node using the children of the <code class="literal">pStateRoot</code> object we found before:</p><div class="informalexample"><pre class="programlisting">// pre declare the texture root
TiXmlElement* pTextureRoot = 0;

// get the root of the texture elements
for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != NULL;
e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == string("TEXTURES"))
  {
    pTextureRoot = e;
  }
}</pre></div><p>Once the <code class="literal">&lt;TEXTURE&gt;</code> node is found, we can pass it into the private <code class="literal">parseTextures</code> function (which we will cover a little later).</p><div class="informalexample"><pre class="programlisting">parseTextures(pTextureRoot, std::vector&lt;std::string&gt; *pTextureIDs);</pre></div><p>The function then moves onto searching for the <code class="literal">&lt;OBJECT&gt;</code> node and, once found, it passes it into the private<a class="indexterm" id="id356"/> <code class="literal">parseObjects</code> function. We also pass in the <code class="literal">pObjects</code> parameter:</p><div class="informalexample"><pre class="programlisting">  // pre declare the object root node
  TiXmlElement* pObjectRoot = 0;

  // get the root node and assign it to pObjectRoot
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("OBJECTS"))
    {
      pObjectRoot = e;
    }
  }
  parseObjects(pObjectRoot, pObjects);
  return true;
}</pre></div><p>At this point<a class="indexterm" id="id357"/> our state has been parsed. We can now cover the two private functions, starting with <code class="literal">parseTextures</code>.</p><div class="informalexample"><pre class="programlisting">void StateParser::parseTextures(TiXmlElement* pStateRoot, std::vector&lt;std::string&gt; *pTextureIDs)
{
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    string filenameAttribute = e-&gt;Attribute("filename");
    string idAttribute = e-&gt;Attribute("ID");
    pTextureIDs-&gt;push_back(idAttribute); // push into list

    TheTextureManager::Instance()-&gt;load(filenameAttribute, 
    idAttribute, TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>This function gets the <code class="literal">filename</code> and <code class="literal">ID</code> attributes from each of the texture values in this part of the XML:</p><div class="informalexample"><pre class="programlisting">&lt;TEXTURES&gt;
  &lt;texture filename="button.png" ID="playbutton"/&gt;
  &lt;texture filename="exit.png" ID="exitbutton"/&gt;
&lt;/TEXTURES&gt;</pre></div><p>It then adds them to <code class="literal">TextureManager</code>.</p><div class="informalexample"><pre class="programlisting">TheTextureManager::Instance()-&gt;load(filenameAttribute, idAttribute, TheGame::Instance()-&gt;getRenderer());</pre></div><p>The <code class="literal">parseObjects</code> function<a class="indexterm" id="id358"/> is quite a bit more complicated. It creates objects<a class="indexterm" id="id359"/> using our <code class="literal">GameObjectFactory</code> function and reads from this part of the XML file:</p><div class="informalexample"><pre class="programlisting">&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="100" y="100" width="400" 
  height="100" textureID="playbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="100" y="300" width="400" 
  height="100" textureID="exitbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;</pre></div><p>The <a class="indexterm" id="id360"/>
<code class="literal">parseObjects</code> function<a class="indexterm" id="id361"/> is defined like so:</p><div class="informalexample"><pre class="programlisting">void StateParser::parseObjects(TiXmlElement *pStateRoot, 
std::vector&lt;GameObject *&gt; *pObjects)
{
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    int x, y, width, height, numFrames, callbackID, animSpeed;
    string textureID;

    e-&gt;Attribute("x", &amp;x);
    e-&gt;Attribute("y", &amp;y);
    e-&gt;Attribute("width",&amp;width);
    e-&gt;Attribute("height", &amp;height);
    e-&gt;Attribute("numFrames", &amp;numFrames);
    e-&gt;Attribute("callbackID", &amp;callbackID);
    e-&gt;Attribute("animSpeed", &amp;animSpeed);

    textureID = e-&gt;Attribute("textureID");

    GameObject* pGameObject = TheGameObjectFactory::Instance()
    -&gt;create(e-&gt;Attribute("type"));
    pGameObject-&gt;load(new LoaderParams
    (x,y,width,height,textureID,numFrames,callbackID, animSpeed));
    pObjects-&gt;push_back(pGameObject);
  }
}</pre></div><p>First we get any values we need from the current node. Since XML files are pure text, we cannot simply grab<a class="indexterm" id="id362"/> ints or floats from the file. TinyXML has functions with which you can pass in the value you want to be set and the attribute name. For example:</p><div class="informalexample"><pre class="programlisting">e-&gt;Attribute("x", &amp;x);</pre></div><p>This sets the variable <code class="literal">x</code> to the value contained within attribute <code class="literal">"x"</code>. Next comes the creation of a <code class="literal">GameObject</code>
<span class="strong"><strong>*</strong></span> class using the factory.</p><div class="informalexample"><pre class="programlisting">GameObject* pGameObject = TheGameObjectFactory::Instance()-&gt;create(e-&gt;Attribute("type"));</pre></div><p>We pass in the value from the <code class="literal">type</code> attribute and use that to create the correct object from the factory. After this we must use the <code class="literal">load</code> function of <code class="literal">GameObject</code> to set our desired values using the values loaded from the XML file.</p><div class="informalexample"><pre class="programlisting">pGameObject-&gt;load(new LoaderParams(x,y,width,height,textureID,numFrames,callbackID));</pre></div><p>And finally we <a class="indexterm" id="id363"/>push <code class="literal">pGameObject</code> into the <code class="literal">pObjects</code> array, which is actually a pointer to the current state's object vector.</p><div class="informalexample"><pre class="programlisting">pObjects-&gt;push_back(pGameObject);</pre></div></div>
<div class="section" title="Loading the menu state from an XML file"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Loading the menu state from an XML file</h1></div></div></div><p>We now have most <a class="indexterm" id="id364"/>of our state loading code in place and can make use of this in the <code class="literal">MenuState</code> class. First we must do a little legwork and set up a new way of assigning the callbacks to our <code class="literal">MenuButton</code> objects, since this is not something we <a class="indexterm" id="id365"/>could pass in from an XML file. The approach we will take is to give any object that wants to make use of a callback an attribute named <code class="literal">callbackID</code> in the XML file. Other objects do not need this value and <code class="literal">LoaderParams</code> will use the default value of <code class="literal">0</code>. The <code class="literal">MenuButton</code> class will make use of this value and pull it from its <code class="literal">LoaderParams</code>, like so:</p><div class="informalexample"><pre class="programlisting">void MenuButton::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
  m_callbackID = pParams-&gt;getCallbackID();
  m_currentFrame = MOUSE_OUT;
}</pre></div><p>The <code class="literal">MenuButton</code> class<a class="indexterm" id="id366"/> will also need two other functions, one to set the callback function and another to return its callback ID:</p><div class="informalexample"><pre class="programlisting">void setCallback(void(*callback)()) { m_callback = callback;}
int getCallbackID() { return m_callbackID; }</pre></div><p>Next we must create a function to set callbacks. Any state that uses objects with callbacks will need an implementation of this function. The most likely states to have callbacks are menu states, so we will rename our <code class="literal">MenuState</code> class to <code class="literal">MainMenuState</code> and make <code class="literal">MenuState</code> an abstract class that extends from <code class="literal">GameState</code>. The class will declare a function that sets<a class="indexterm" id="id367"/> the callbacks for any items that need it and<a class="indexterm" id="id368"/> it will also have a vector of the <code class="literal">Callback</code> objects as a member; this will be used within the <code class="literal">setCallbacks</code> function for each state.</p><div class="informalexample"><pre class="programlisting">class MenuState : public GameState
{
  protected:

  typedef void(*Callback)();
  virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; callbacks) 
  = 0;

  std::vector&lt;Callback&gt; m_callbacks;
};</pre></div><p>The <code class="literal">MainMenuState</code> class <a class="indexterm" id="id369"/>(previously <code class="literal">MenuState</code>) will now derive from this <code class="literal">MenuState</code> class.</p><div class="informalexample"><pre class="programlisting">#include "MenuState.h"
#include "GameObject.h"

class MainMenuState : public MenuState
{
  public:

  virtual void update();
  virtual void render();

  virtual bool onEnter(); 
  virtual bool onExit(); 

  virtual std::string getStateID() const { return s_menuID; }

  private:

  virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; 
  callbacks);

  // call back functions for menu items
  static void s_menuToPlay();
  static void s_exitFromMenu();

  static const std::string s_menuID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Because <code class="literal">MainMenuState</code> now<a class="indexterm" id="id370"/> derives from <code class="literal">MenuState</code>, it must of course declare and define the <code class="literal">setCallbacks</code> function. We are now ready to use <a class="indexterm" id="id371"/>our state parsing to load the <code class="literal">MainMenuState</code> class. Our <code class="literal">onEnter</code> function will now look like this:</p><div class="informalexample"><pre class="programlisting">bool MainMenuState::onEnter()
{
  // parse the state
  StateParser stateParser;
  stateParser.parseState("test.xml", s_menuID, &amp;m_gameObjects, 
  &amp;m_textureIDList);

  m_callbacks.push_back(0); //pushback 0 callbackID start from 1
  m_callbacks.push_back(s_menuToPlay);
  m_callbacks.push_back(s_exitFromMenu);

  // set the callbacks for menu items
  setCallbacks(m_callbacks);

  std::cout &lt;&lt; "entering MenuState\n";
  return true;
}</pre></div><p>We create a state parser and then use it to parse the current state. We push any callbacks into the <code class="literal">m_callbacks</code> array inherited from <code class="literal">MenuState</code>. Now we need to define the <code class="literal">setCallbacks</code> function:</p><div class="informalexample"><pre class="programlisting">void MainMenuState::setCallbacks(const std::vector&lt;Callback&gt;&amp; 
callbacks)
{
  // go through the game objects
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    // if they are of type MenuButton then assign a callback 
    based on the id passed in from the file
    if(dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]))
    {
      MenuButton* pButton = 
      dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]);
      pButton-&gt;setCallback(callbacks[pButton-&gt;getCallbackID()]);
    }
  }
}</pre></div><p>We use <code class="literal">dynamic_cast</code> to check whether the object is a <code class="literal">MenuButton</code> type; if it is then we do the actual cast and then use the objects <code class="literal">callbackID</code> as the index into the <code class="literal">callbacks</code> vector and assign the correct function. While this method of assigning callbacks could be seen as not very <a class="indexterm" id="id372"/>extendable and could possibly be better<a class="indexterm" id="id373"/> implemented, it does have a redeeming feature; it allows us to keep our callbacks inside the state they will need to be called from. This means that we won't need a huge header file with all of the callbacks in.</p><p>One last alteration we need is to add a list of texture IDs to each state so that we can clear all of the textures that were loaded for that state. Open up <code class="literal">GameState.h</code> and we will add a <code class="literal">protected</code> variable.</p><div class="informalexample"><pre class="programlisting">protected:
std::vector&lt;std::string&gt; m_textureIDList;</pre></div><p>We will pass this into the state parser in <code class="literal">onEnter</code> and then we can clear any used textures in the <code class="literal">onExit</code> function of each state, like so:</p><div class="informalexample"><pre class="programlisting">// clear the texture manager
for(int i = 0; i &lt; m_textureIDList.size(); i++)
{
  TheTextureManager::Instance()-&gt;
  clearFromTextureMap(m_textureIDList[i]);
}</pre></div><p>Before we start running the game we need to register our <code class="literal">MenuButton</code> type with the <code class="literal">GameObjectFactory</code>. Open up <code class="literal">Game.cpp</code> and in the <code class="literal">Game::init</code> function we can register the type.</p><div class="informalexample"><pre class="programlisting">TheGameObjectFactory::Instance()-&gt;registerType("MenuButton", new MenuButtonCreator());</pre></div><p>We can now run the game and see our fully data-driven <code class="literal">MainMenuState</code>.</p></div>
<div class="section" title="Loading other states from an XML file"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Loading other states from an XML file</h1></div></div></div><p>Our <a class="indexterm" id="id374"/>
<code class="literal">MainMenuState</code> class now loads from an XML file. We need to make our other states do the same. We<a class="indexterm" id="id375"/> will only cover the code that has changed, so assume that everything else has remained the same when following through this section.</p><div class="section" title="Loading the play state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Loading the play state</h2></div></div></div><p>We will start<a class="indexterm" id="id376"/> with <a class="indexterm" id="id377"/>
<code class="literal">PlayState.cpp</code> and its <code class="literal">onEnter</code> function.</p><div class="informalexample"><pre class="programlisting">bool PlayState::onEnter()
{
  // parse the state
  StateParser stateParser;
  stateParser.parseState("test.xml", s_playID, &amp;m_gameObjects, 
  &amp;m_textureIDList);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}</pre></div><p>We must also add the new texture clearing code that we had in <code class="literal">MainMenuState</code> to the <code class="literal">onExit</code> function.</p><div class="informalexample"><pre class="programlisting">// clear the texture manager
for(int i = 0; i &lt; m_textureIDList.size(); i++)
{
  TheTextureManager::Instance()-&gt;
  clearFromTextureMap(m_textureIDList[i]);
}</pre></div><p>These are the only alterations that we will need to do here but we must also update our XML file to have something to load in <code class="literal">PlayState</code>.</p><div class="informalexample"><pre class="programlisting">&lt;PLAY&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="helicopter.png" ID="helicopter"/&gt;
  &lt;texture filename="helicopter2.png" ID="helicopter2"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="Player" x="500" y="100" width="128" height="55" 
  textureID="helicopter" numFrames="4"/&gt;
  &lt;object type="Enemy" x="100" y="100" width="128" height="55" 
  textureID="helicopter2" numFrames="4"/&gt;
&lt;/OBJECTS&gt;
&lt;/PLAY&gt;</pre></div><p>Our <code class="literal">Enemy</code> object <a class="indexterm" id="id378"/>will now need to set its initial velocity in its load function rather than the constructor, otherwise the <code class="literal">load</code> function would override it.</p><div class="informalexample"><pre class="programlisting">void Enemy::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
  m_velocity.setY(2);
}</pre></div><p>Finally we must<a class="indexterm" id="id379"/> register these objects with the factory. We can do this in the <code class="literal">Game::init</code> function just like the <code class="literal">MenuButton</code> object.</p><div class="informalexample"><pre class="programlisting">TheGameObjectFactory::Instance()-&gt;registerType("Player", new PlayerCreator());
TheGameObjectFactory::Instance()-&gt;registerType("Enemy", new EnemyCreator());</pre></div></div><div class="section" title="Loading the pause state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Loading the pause state</h2></div></div></div><p>Our <code class="literal">PauseState</code> class<a class="indexterm" id="id380"/> must now inherit from <code class="literal">MenuState</code> as we want it to contain callbacks. We must update the <code class="literal">PauseState.h</code> file to first inherit <a class="indexterm" id="id381"/>from <code class="literal">MenuState</code>.</p><div class="informalexample"><pre class="programlisting">class PauseState : public MenuState</pre></div><p>We must also declare the <code class="literal">setCallbacks</code> function.</p><div class="informalexample"><pre class="programlisting">virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; callbacks);</pre></div><p>Now we must update the <code class="literal">PauseState.cpp</code> file, starting with the <code class="literal">onEnter</code> function.</p><div class="informalexample"><pre class="programlisting">bool PauseState::onEnter()
{
  StateParser stateParser;
  stateParser.parseState("test.xml", s_pauseID, &amp;m_gameObjects, 
  &amp;m_textureIDList);

  m_callbacks.push_back(0);
  m_callbacks.push_back(s_pauseToMain);
  m_callbacks.push_back(s_resumePlay);

  setCallbacks(m_callbacks);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>The <code class="literal">setCallbacks</code> function <a class="indexterm" id="id382"/>is exactly like <code class="literal">MainMenuState</code>.</p><div class="informalexample"><pre class="programlisting">void PauseState::setCallbacks(const std::vector&lt;Callback&gt;&amp; 
callbacks)
{
  // go through the game objects
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    // if they are of type MenuButton then assign a callback based 
    on the id passed in from the file
    if(dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]))
    {
      MenuButton* pButton = 
      dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]);
      pButton-&gt;setCallback(callbacks[pButton-&gt;getCallbackID()]);
    }
  }
}</pre></div><p>Finally <a class="indexterm" id="id383"/>we must <a class="indexterm" id="id384"/>add the texture clearing code to <code class="literal">onExit</code>.</p><div class="informalexample"><pre class="programlisting">// clear the texture manager
for(int i = 0; i &lt; m_textureIDList.size(); i++)
{
  TheTextureManager::Instance()-&gt;
  clearFromTextureMap(m_textureIDList[i]);
}</pre></div><p>And then update our XML file to include this state.</p><div class="informalexample"><pre class="programlisting">&lt;PAUSE&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="resume.png" ID="resumebutton"/&gt;
  &lt;texture filename="main.png" ID="mainbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="200" y="100" width="200" 
  height="80" textureID="mainbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="200" y="300" width="200" 
  height="80" textureID="resumebutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/PAUSE&gt;</pre></div></div><div class="section" title="Loading the game over state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Loading the game over state</h2></div></div></div><p>Our final state is <code class="literal">GameOverState</code>. Again this will be very similar to other states and we will only cover <a class="indexterm" id="id385"/>what has changed. Since we want <code class="literal">GameOverState</code> to handle callbacks it will now inherit from <code class="literal">MenuState</code>.</p><div class="informalexample"><pre class="programlisting">class GameOverState : public MenuState</pre></div><p>We will then declare<a class="indexterm" id="id386"/> the <code class="literal">setCallbacks</code> function.</p><div class="informalexample"><pre class="programlisting">virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; callbacks);</pre></div><p>The <code class="literal">onEnter</code> function should be looking very familiar now.</p><div class="informalexample"><pre class="programlisting">bool GameOverState::onEnter()
{
  // parse the state
  StateParser stateParser;
  stateParser.parseState("test.xml", s_gameOverID, &amp;m_gameObjects, 
  &amp;m_textureIDList);
  m_callbacks.push_back(0);
  m_callbacks.push_back(s_gameOverToMain);
  m_callbacks.push_back(s_restartPlay);

  // set the callbacks for menu items
  setCallbacks(m_callbacks);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>The texture clearing method is the same as in the previous states, so we will leave you to implement that yourself. In fact <code class="literal">onExit</code> is looking so similar between states that it would be a good idea to make a generic implementation for it in <code class="literal">GameState</code> and just use that; again we will leave that to you.</p><p>You may have noticed the similarity between the <code class="literal">onEnter</code> functions<a class="indexterm" id="id387"/>. It would be great to have a default <code class="literal">onEnter</code> implementation but, unfortunately, due to the need to specify different callback<a class="indexterm" id="id388"/> functions, our callback implementation will not allow this and this is one of its main flaws.</p><p>Our <a class="indexterm" id="id389"/>
<code class="literal">AnimatedGraphic</code> class will now need to grab the <code class="literal">animSpeed</code> value from <code class="literal">LoaderParams</code> in its <code class="literal">load</code> function<a class="indexterm" id="id390"/>.</p><div class="informalexample"><pre class="programlisting">void AnimatedGraphic::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
  m_animSpeed = pParams-&gt;getAnimSpeed();
}</pre></div><p>We will also have to register this type with <code class="literal">GameObjectFactory</code>.</p><div class="informalexample"><pre class="programlisting">TheGameObjectFactory::Instance()-&gt;registerType("AnimatedGraphic", new AnimatedGraphicCreator());</pre></div><p>And finally <a class="indexterm" id="id391"/>we can update the XML file to include this state:</p><div class="informalexample"><pre class="programlisting">&lt;GAMEOVER&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="gameover.png" ID="gameovertext"/&gt;
  &lt;texture filename="main.png" ID="mainbutton"/&gt;
  &lt;texture filename="restart.png" ID="restartbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="AnimatedGraphic" x="200" y="100" width="190" 
  height="30" textureID="gameovertext" numFrames="2" 
  animSpeed="2"/&gt;
  &lt;object type="MenuButton" x="200" y="200" width="200" 
  height="80" textureID="mainbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="200" y="300" width="200" 
  height="80" textureID="restartbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/GAMEOVER&gt;</pre></div><p>We now have all of our states loading from the XML file and one of the biggest benefits of this is that you do not have to recompile the game when you change a value. Go ahead and change the XML file to move positions or even use different textures for objects; if the XML is saved then you can just run the game again and it will use the new values. This is a huge time saver for us and gives us complete control over a state without the need to recompile our game.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Summary</h1></div></div></div><p>Loading data from external files is an extremely useful tool in programming games. This chapter enabled our game to do this and applied it to all of our existing states. We also covered how the use of factories enabled us to create objects dynamically at runtime. The next chapter will cover even more data-driven design as well as tile maps so that we can really decouple our game and allow it to use external sources rather than hardcoded values.</p></div></body></html>