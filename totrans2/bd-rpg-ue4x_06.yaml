- en: Chapter 6. NPCs and Dialog
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：NPC和对话
- en: By now, you already have a player character by default that interacts with battles
    on the field, but the game is in dire need of **non-player characters** (**NPCs**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有了一个默认的玩家角色，它可以与战场上的战斗交互，但游戏迫切需要**非玩家角色**（NPC）。
- en: In this chapter, you will create an NPC that will act as an information hub
    and shop owner. Since we have not yet given useable items and equipment to the
    character, or a reason for the character to have gold, the next logical step is
    to create a shop owner who will play the role of an NPC by talking to the player
    and offering the player business transactions when the player decides to interact
    with the NPC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将创建一个NPC，它将充当信息中心和店主。由于我们尚未为角色提供可用的物品和装备，或者让角色拥有金币的理由，下一步合乎逻辑的步骤是创建一个店主，他将通过与玩家交谈并当玩家决定与NPC交互时提供商业交易来扮演NPC的角色。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the NPC Character Blueprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建NPC角色蓝图
- en: Interacting with the NPC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与NPC交互
- en: Dialog box setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框设置
- en: Creating an NPC welcome box
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建NPC欢迎框
- en: Adding an NPC talk box
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加NPC对话框
- en: Creating the NPC Character Blueprint
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NPC角色蓝图
- en: 'To get started, we will need to create a new Character Blueprint class. Since
    we already have a location for characters, navigate to the `character` folder
    located in your **Content Browser** under **Content** | **Blueprints** | **Characters**
    (create a new `character` folder in `content/blueprints` if one is not there already,
    just to stay more organized; you can even drag your **FieldPlayer** Blueprint
    into the `character` folder if you''d like), and add a new character by clicking
    on **Add New** | **Blueprint Class**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个新的角色蓝图类。由于我们已经有了一个角色的位置，导航到位于**内容浏览器**下的**内容** | **蓝图** | **角色**中的`character`文件夹（如果还没有，请在`content/blueprints`中创建一个新的`character`文件夹，以保持更整洁；如果你愿意，甚至可以将你的**FieldPlayer**蓝图拖到`character`文件夹中），然后通过点击**添加新**
    | **蓝图类**来添加一个新的角色：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_01.jpg)'
- en: 'The **Pick Parent Class** window will pop up. This will allow you to pick a
    common parent class for your Blueprint class or create your own class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择父类**窗口将弹出。这将允许你为你的蓝图类选择一个通用的父类或创建你自己的类：'
- en: '![Creating the NPC Character Blueprint](img/B04548_06_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_02.jpg)'
- en: UE4 has a lot of common classes built in, which have a lot of the frameworks
    of several different types of classes already built for us. One of those classes
    is **Character** which allows us to work with a common character framework for
    use with any type of character pawn we want. So, from this window, select **Character**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: UE4内置了许多常见的类，这些类已经为我们构建了许多不同类型类的框架。其中之一是**角色**类，它允许我们使用一个通用的角色框架来与任何类型的角色棋子一起使用。因此，从此窗口中选择**角色**。
- en: 'Once you have selected **Character**, a new Character Blueprint should now
    be in **Content** | **Blueprints** | **Characters**. Rename the character as **NPC_ShopOwner**
    since we will be using this character as the shop owner:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了**角色**，一个新的角色蓝图现在应该在**内容** | **蓝图** | **角色**中。将角色重命名为**NPC_ShopOwner**，因为我们将会使用这个角色作为店主：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_03.jpg)'
- en: 'From here, open **NPC_ShopOwner** to enter the viewport of your new character:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，打开**NPC_ShopOwner**以进入你新角色的视口：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_04.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_04.jpg)'
- en: You should see that, as mentioned earlier, this class inherits `Character.h`
    which already has a framework for a lot of components. This will now make it easy
    for us to make a visible NPC. Within the **Components** panel, you will see **CapsuleComponent**,
    which holds inherited data such as **ArrowComponent** that determines which way
    the object is pointing, and **Mesh**, which holds an instance of a skeletal mesh.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到，如前所述，这个类继承了`Character.h`，它已经为许多组件提供了一个框架。这将使我们能够轻松地制作一个可见的非玩家角色（NPC）。在**组件**面板中，你会看到**胶囊组件**，它包含继承的数据，例如**箭头组件**，它决定了对象指向的方向，以及**网格**，它包含一个骨骼网格的实例。
- en: 'Let us first apply a mesh and animations to our **Mesh** component. Since we
    are not creating character models and animations in this book, we can simply use
    built-in assets. First, click on **Mesh** within **Components** | **CapsuleComponent**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的**网格**组件应用网格和动画。由于我们在这本书中没有创建角色模型和动画，我们可以简单地使用内置资源。首先，点击**组件** | **CapsuleComponent**中的**网格**：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_05.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_05.jpg)'
- en: 'From here, you will notice that your **Details** panel changes in order to
    display the **Mesh** variable and its components. For now, we will want to keep
    most of the defaults here since the character has everything we would want out
    of an NPC. However, the character does not have a mesh, so let''s give it one
    by navigating to **Details** | **Mesh** and, in **Skeletal Mesh**, selecting the
    **None** drop-down menu that would house a skeletal mesh. Then, you should see
    all the skeletal meshes available in our project. In our game, there is a skeletal
    mesh called **SK_Mannequin**, we will select this as our skeletal mesh:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你会注意到你的**细节**面板会改变，以便显示**网格**变量及其组件。目前，我们希望在这里保留大多数默认设置，因为角色已经拥有了从NPC中期望得到的一切。然而，角色没有网格，所以让我们通过导航到**细节**
    | **网格**，并在**骨骼网格**中选择包含骨骼网格的**无**下拉菜单来给它一个网格。然后，你应该能看到我们项目中所有可用的骨骼网格。在我们的游戏中，有一个名为**SK_Mannequin**的骨骼网格，我们将选择它作为我们的骨骼网格：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_06.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_06.jpg)'
- en: 'Now that we have selected a skeletal mesh, you should see it displayed in your
    viewport. At this point, you may notice that your skeletal mesh is much higher
    than the bottom of the capsule because the skeletal mesh''s origin is at its feet
    and is attached to the origin of the capsule that is located in the middle of
    the capsule. There are a lot of ways to fix this problem, but the quickest way
    would be to reposition the character manually by bringing the character down on
    the *Z* axis. A value of **-90** for **Z Location** seems to work perfectly in
    this example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了一个骨骼网格，你应该能在视口中看到它。在这个阶段，你可能注意到你的骨骼网格比胶囊底端要高得多，因为骨骼网格的起点在其脚部，并且连接到位于胶囊中间的胶囊原点。解决这个问题有很多方法，但最快的方法是通过将角色在*Z*轴上向下移动来手动重新定位角色。在这个例子中，**Z位置**的**-90**值似乎效果很好：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_07.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_07.jpg)'
- en: 'You will also want the character to be facing the right way. You can see that
    the character is faced the wrong way because the arrow component is pointing perpendicular
    to the way the character is facing. Simply adjust the character rotation on the
    *Z* axis. A value of **-90** for **Z Rotation** seems to do the trick:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望角色面向正确的方向。你可以看到角色面向错误的方向，因为箭头组件与角色面向的方向垂直。只需调整角色在*Z*轴上的旋转。**Z旋转**的**-90**值似乎很有效：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_08.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_08.jpg)'
- en: 'Lastly, we need to get the character out of the relaxed pose. So navigate to
    **Details** | **Animation** and select the **Anim Class** drop-down menu. In this
    drop-down menu, select **ThirdPerson_AnimBP**, which is the animation class for
    the character we selected. If you are using another character with a different
    animation class, be sure to select the animation class that is built for your
    character:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将角色从放松的姿态中解脱出来。因此，导航到**细节** | **动画**并选择**Anim Class**下拉菜单。在这个下拉菜单中，选择为所选角色提供的动画类**ThirdPerson_AnimBP**。如果你使用的是具有不同动画类的另一个角色，请确保选择为你的角色构建的动画类：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_09.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_09.jpg)'
- en: 'We also need a way to interact with this character. For this, we are going
    to create a volume that expands a certain distance in front of the character;
    this will be the area in which the player is able to interact with the NPC. To
    do this, we will need to add another component to **CapsuleComponent**. Navigate
    to the **Components** panel and select **Add Component** | **Collision** | **Box
    Collision**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种与这个角色交互的方法。为此，我们将创建一个在角色前方扩展一定距离的体积；这将是在玩家能够与NPC交互的区域。为此，我们需要向**CapsuleComponent**添加另一个组件。导航到**组件**面板，并选择**添加组件**
    | **碰撞** | **箱形碰撞**：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_10.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_10.jpg)'
- en: 'This creates a box collision at the character''s origin:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在角色的原点创建一个盒子碰撞：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_11.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_11.jpg)'
- en: We are going to use this collision by calculating whether the player is inside
    the box or outside the box. If they are in the box, the player will be able to
    interact with the NPC; if the player is outside the box, the player will not be
    able to interact with the NPC. Since we want to make this as realistic as possible,
    the player should only interact with the NPC if the character is standing in front
    of the NPC. So adjust the location and scale of the box until it is in front of
    the character and sized such that the player can easily walk a forgivable distance
    in front of the NPC to interact with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过计算玩家是否在盒子内或盒子外来使用这个碰撞。如果他们在盒子内，玩家将能够与NPC交互；如果玩家在盒子外，玩家将无法与NPC交互。由于我们希望使其尽可能真实，玩家只有在角色站在NPC前面时才能与NPC交互。因此调整盒子的位置和缩放，直到它位于角色前面，并且大小使得玩家可以轻松地走到NPC前面与它交互。
- en: 'For this character, I will edit the **Location X** value to be **60**, **Scale
    X** value to be **2**, **Scale Y** value to be **2**, and **Scale Z** value to
    be **3**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个角色，我将编辑**位置X**值为**60**，**缩放X**值为**2**，**缩放Y**值为**2**，以及**缩放Z**值为**3**：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_12.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_12.jpg)'
- en: 'Finally, we want to give the collision box a type that does not block the player,
    but allows the player to enter the collision box. Navigate to **Details** | **Collision**
    and under **Collision Presets**, select **Trigger**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望给碰撞盒一个类型，它不会阻止玩家，但允许玩家进入碰撞盒。导航到**详情** | **碰撞**，在**碰撞预设**下，选择**触发**：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_13.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_13.jpg)'
- en: This will essentially turn the collision box into a trigger volume that can
    be used to trigger events such as dialog and shop menus.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基本上将碰撞盒转换为可以触发如对话和商店菜单等事件的触发体积。
- en: 'At this point, you can drag and drop your **NPC_ShopOwner** into your level:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以将你的**NPC_ShopOwner**拖放到你的关卡中：
- en: '![Creating the NPC Character Blueprint](img/B04548_06_14.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC角色蓝图](img/B04548_06_14.jpg)'
- en: If you playtest this, you should notice that you will collide with the skeletal
    mesh, but you will not collide with the trigger volume. You are now ready to create
    Blueprints to make this NPC interactive.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行测试，你应该注意到你会与骨骼网格发生碰撞，但你不会与触发体积发生碰撞。你现在可以准备创建蓝图来使这个NPC交互式。
- en: Interacting with the NPC
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与NPC交互
- en: Now that you have made the NPC and volume that will trigger interaction with
    the NPC, it is time to program interaction with the NPC by using the trigger volume.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了将触发与NPC交互的NPC和体积，是时候通过使用触发体积来编程NPC的交互了。
- en: 'Let us first think about the logic. What we will want to do is only allow the
    player to interact with the NPC if the player is within the NPC''s line of sight
    (in this case, the trigger volume). If the player is not within the trigger volume,
    we do not want to allow the player to interact with the NPC. In this case, we
    will need some sort of Boolean that will return *true* if the player is in the
    trigger volume and *false* if the character is not within the trigger volume.
    We also want to allow the player to press a key to interact with the NPC, but
    only when the Boolean we create is set to true, since the Boolean we create to
    keep track of the NPC trigger volume may span across multiple classes. Just like
    in the previous chapters, let''s declare that global variable in `RPGGameInstance.h`.
    We will put the variable in the same `Game Data` category that our other global
    variables are in, but this time, instead of only allowing the Blueprint to read
    the variable, we need to allow Blueprint to write the variable since we will be
    switching the variable between true and false. We will add a Boolean called `TalkShop`
    as one of our public variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先思考一下逻辑。我们希望做到的是，只有当玩家在 NPC 的视线范围内（在这种情况下，触发体积）时，才允许玩家与 NPC 交互。如果玩家不在触发体积内，我们不想允许玩家与
    NPC 交互。在这种情况下，我们需要某种布尔值，当玩家在触发体积内时返回 *true*，当角色不在触发体积内时返回 *false*。我们还希望允许玩家按下一个键与
    NPC 交互，但只有在创建的布尔值设置为 true 时才允许，因为我们创建的用于跟踪 NPC 触发体积的布尔值可能跨越多个类。就像前面的章节一样，让我们在
    `RPGGameInstance.h` 中声明这个全局变量。我们将把这个变量放在与我们的其他全局变量相同的 `Game Data` 类别中，但这次，我们不仅需要允许蓝图读取变量，还需要允许蓝图写入变量，因为我们将在
    true 和 false 之间切换变量。我们将添加一个名为 `TalkShop` 的布尔值作为我们的公共变量之一：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you are finished editing `RPGGameInstance.h`, your header file should
    now look like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成编辑 `RPGGameInstance.h` 后，你的头文件现在应该看起来像以下这样：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compile the code and then head into the **NPC_ShopOwner** Character Blueprint.
    Select the **Box** component in the **Components** panel, and within the **Details**
    panel, scroll down to **Events**. You will notice that there are many different
    types of events that can be created here based around how the box is interacted
    with:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码后，进入 **NPC_ShopOwner** 角色蓝图。在 **Components** 面板中选择 **Box** 组件，然后在 **Details**
    面板中向下滚动到 **Events**。你会注意到，根据如何与盒子交互，这里可以创建许多不同类型的事件：
- en: '![Interacting with the NPC](img/B04548_06_15.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_15.jpg)'
- en: 'We are most interested in **On Component Begin Overlap** and **On Component
    End Overlap** because these are the events that will trigger if something either
    intersects the box or does not intersect the box. Let us first work on triggering
    an event if the player intersects the box. So, within **Details** | **Events**
    | **On Component Begin Overlap**, select **+**. This will automatically open **Event
    Graph** and create an **OnComponentBeginOverlap** event:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的是 **On Component Begin Overlap** 和 **On Component End Overlap**，因为这些事件将在有东西与盒子相交或不相交时触发。让我们首先处理如果玩家与盒子相交时触发事件的情况。因此，在
    **Details** | **Events** | **On Component Begin Overlap** 中选择 **+**。这将自动打开 **Event
    Graph** 并创建一个 **OnComponentBeginOverlap** 事件：
- en: '![Interacting with the NPC](img/B04548_06_16.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_16.jpg)'
- en: 'All we will need to do here is simply set the `TalkShop` Boolean that we created
    previously to `true` if the player intersects the box. To do so, first cast to
    the **FieldPlayer** using **Cast To FieldPlayer** located under **Utilities**
    | **Casting** and set the interaction component to the **FieldPlayer** object
    by linking the **OtherActor** pin within **OnComponentBeginOverlap** to the **Object**
    pin within the **Cast To FieldPlayer** node:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只需要简单地设置之前创建的 `TalkShop` 布尔值为 `true`，如果玩家与盒子相交。要做到这一点，首先使用 **Utilities**
    | **Casting** 下的 **Cast To FieldPlayer** 将 **FieldPlayer** 强制转换为，并通过将 **OnComponentBeginOverlap**
    中的 **OtherActor** 插针链接到 **Cast To FieldPlayer** 节点中的 **Object** 插针来设置交互组件为 **FieldPlayer**
    对象：
- en: '![Interacting with the NPC](img/B04548_06_17.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_17.jpg)'
- en: 'From here, we have **FieldPlayer** triggering a cast to **RPGGameInstance**
    using the **Cast To RPGGameInstance** node located under **Utilities** | **Casting**,
    whose **Object** pin is **Get Game Instance** since the `TalkShop` variable is
    located within **RPGGameInstance**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们有 **FieldPlayer** 触发使用位于 **Utilities** | **Casting** 下的 **Cast To RPGGameInstance**
    节点的 **RPGGameInstance** 强制转换，其 **Object** 插针是 **Get Game Instance**，因为 `TalkShop`
    变量位于 **RPGGameInstance** 中：
- en: '![Interacting with the NPC](img/B04548_06_18.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_18.jpg)'
- en: 'Lastly, create a **Set Talk Shop** action by unchecking **Context Sensitive**,
    navigating to **Class** | **RPGGameInstance**, and selecting **Set Talk Shop**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过取消选择**Context Sensitive**，导航到**Class** | **RPGGameInstance**，并选择**Set Talk
    Shop**来创建一个**Set Talk Shop**动作：
- en: '![Interacting with the NPC](img/B04548_06_19.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_19.jpg)'
- en: 'Have **Cast To RPGGameInstance** trigger the **Set Talk Shop** action and be
    sure that we are referencing the `TalkShop` variable within **RPGGameInstance**
    by linking the **As RPGGameInstance** pin from **Cast To RPGGameInstance** to
    the **Target** pin from **Set Talk Shop**. Also, be sure to set the `TalkShop`
    variable to `true` by checking the **Talk Shop** Boolean within the **Set Talk
    Shop** node. When you are finished, your Blueprint should look like the following
    screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让**Cast To RPGGameInstance**触发**Set Talk Shop**动作，并确保我们通过将**Cast To RPGGameInstance**的**As
    RPGGameInstance**引脚链接到**Set Talk Shop**的**Target**引脚来引用位于**RPGGameInstance**中的`TalkShop`变量。此外，确保在**Set
    Talk Shop**节点中检查**Talk Shop**布尔值，将`TalkShop`变量设置为`true`。完成时，你的Blueprint应该看起来像以下截图：
- en: '![Interacting with the NPC](img/B04548_06_20.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_20.jpg)'
- en: Now that we are finished creating the **Begin Overlap** event, let us create
    our player/key interaction and check whether or not the **Talk Shop** Boolean
    is true or false. Since the player controller won't have direct access to **NPC_ShopOwner**,
    we will need to create the key interaction either within the Field Player class
    or the Level Blueprint class. Because the NPC is specifically part of this particular
    level and different levels will most likely house different NPCs, it would make
    the most sense for the key and Boolean check to be located within the Level Blueprint.
    So at this point, navigate to **Blueprints** | **Open Level Blueprint** to enter
    the Level Blueprint.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了创建**Begin Overlap**事件，让我们创建玩家/键交互并检查**Talk Shop**布尔值是否为真或假。由于玩家控制器无法直接访问**NPC_ShopOwner**，我们需要在Field
    Player类或Level Blueprint类中创建键交互。因为NPC是特定级别的特定部分，而不同的级别可能包含不同的NPC，所以将键和布尔检查放在Level
    Blueprint中最为合理。因此，此时导航到**Blueprints** | **Open Level Blueprint**以进入Level Blueprint。
- en: 'Within the Level Blueprint, we will create a key event to the letter *E* by
    navigating to **Input** | **Key Events** | **E**. Then, upon release of the *E*
    key (because we want the player to commit to the key press), trigger **Cast To
    RPGGameInstance** whose object is **Get Game Instance** because upon the key press,
    we will want to check the status of the `TalkShop` variable that is located within
    **RPGGameInstance**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Level Blueprint中，我们将通过导航到**Input** | **Key Events** | **E**创建一个字母*E*的键事件。然后，在*E*键释放时（因为我们希望玩家对按键做出承诺），触发**Cast
    To RPGGameInstance**，其对象为**Get Game Instance**，因为在按键时，我们想要检查位于**RPGGameInstance**中的`TalkShop`变量的状态：
- en: '![Interacting with the NPC](img/B04548_06_21.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_21.jpg)'
- en: 'Reference the `TalkShop` variable by dragging out the **As RPGGameInstance**
    pin within **Cast To RPGGameInstance**, navigate to **Variables** | **Game Data**
    and then select **Get Talk Shop**, since we will be checking **Talk Shop**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在**Cast To RPGGameInstance**中拖出**As RPGGameInstance**引脚来引用`TalkShop`变量，导航到**Variables**
    | **Game Data**然后选择**Get Talk Shop**，因为我们将会检查**Talk Shop**：
- en: '![Interacting with the NPC](img/B04548_06_22.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_22.jpg)'
- en: 'Now that we are referencing the `TalkShop` variable, we can check the condition
    of **Talk Shop** by creating a **Branch** statement located under **Utilities**
    | **Flow Control**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在引用`TalkShop`变量，我们可以通过创建位于**Utilities** | **Flow Control**下的**Branch**语句来检查**Talk
    Shop**的条件：
- en: '![Interacting with the NPC](img/B04548_06_23.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_23.jpg)'
- en: 'Link the **Talk Shop** pin to the **Condition** pin within the **Branch** node
    to check the condition of `TalkShop`, and have the **Cast To RPGGameInstance**
    activate **Branch**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Talk Shop**引脚链接到**Branch**节点中的**Condition**引脚以检查`TalkShop`的条件，并让**Cast To
    RPGGameInstance**激活**Branch**：
- en: '![Interacting with the NPC](img/B04548_06_24.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![与NPC交互](img/B04548_06_24.jpg)'
- en: 'Now that we have this framework set up, we can do something if the `TalkShop`
    condition is true or false. For now, we will just run a test by printing some
    text to the screen by navigating to **Utilities** | **Text** | **Print Text**,
    which will create a **Print Text** function. Link the **True** pin from the **Branch**
    node to the **In** pin of **Print Text**. When you are finished, your Level Blueprint
    should look like the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了这个框架，我们可以根据 `TalkShop` 条件为真或假来做一些事情。现在，我们将通过导航到 **实用工具** | **文本** |
    **打印文本** 来运行一个测试，这将创建一个 **打印文本** 函数。将 **分支** 节点的 **True** 插针链接到 **打印文本** 的 **In**
    插针。完成操作后，你的关卡蓝图应该看起来像以下截图：
- en: '![Interacting with the NPC](img/B04548_06_25.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_25.jpg)'
- en: 'If you test this now, you should notice that if the player presses the *E*
    key outside the NPC trigger volume, nothing will happen; however, if the player
    presses *E* when they are within the trigger volume, text will appear on the screen.
    However, if we exit the volume and continue to press *E*, the text will continue
    to appear on the screen. This is because we are never setting the `TalkShop` Boolean
    back to `false`. Doing this is very simple. Navigate back to **NPC_ShopOwner**
    and select **+** under **Details** | **On Component End Overlap** to create an
    **OnComponentEndOverlap** event:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试这个功能，你应该会注意到，如果玩家在 NPC 触发体积外按下 *E* 键，将不会发生任何事情；然而，如果玩家在触发体积内按下 *E* 键，屏幕上会出现文本。但是，如果我们退出体积并继续按下
    *E* 键，文本将继续出现在屏幕上。这是因为我们从未将 `TalkShop` 布尔值设置回 `false`。这样做非常简单。导航回 **NPC_ShopOwner**
    并在 **详情** | **On Component End Overlap** 下的 **+** 处创建一个 **OnComponentEndOverlap**
    事件：
- en: '![Interacting with the NPC](img/B04548_06_26.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_26.jpg)'
- en: 'Since we have already created a reference to **Talk Shop** when creating the
    **OnComponentBeginOverlap** event, and set that reference to true, we can simply
    make the **OnComponentEndOverlap** event that does the exact same thing as the
    **OnComponentBeginOverlap**; however, instead of setting `TalkShop` to `true`,
    set `TalkShop` to `false` by making sure the **Talk Shop** pin within the **Set
    Talk Shop** node is unchecked. Your **OnComponentEndOverlap** event should now
    look like the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在创建 **OnComponentBeginOverlap** 事件时已经创建了一个对 **Talk Shop** 的引用，并将其设置为 true，因此我们可以简单地创建一个与
    **OnComponentBeginOverlap** 完全相同功能的 **OnComponentEndOverlap** 事件；然而，不是将 `TalkShop`
    设置为 `true`，而是通过确保 **Set Talk Shop** 节点内的 **Talk Shop** 插针未被勾选来将 `TalkShop` 设置为
    `false`。你的 **OnComponentEndOverlap** 事件现在应该看起来像以下截图：
- en: '![Interacting with the NPC](img/B04548_06_27.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![与 NPC 交互](img/B04548_06_27.jpg)'
- en: When you test this now, interaction with the NPC via the *E* key should only
    work if the player is intersecting the NPC's trigger volume as intended.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在测试这个功能时，通过 *E* 键与 NPC 的交互应该只在没有玩家意图中穿过 NPC 的触发体积时才有效。
- en: Dialog box setup
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框设置
- en: We are now ready to create dialog that our NPC will state to the character.
    To do this, we will first create a Widget Blueprint that will be responsible for
    housing all parent variables of the NPC, such as the dialog in the game, so that
    we can simply pull dialog anytime we need it by calling the dialog variable within
    the function. This process will be better than the hardcoding text in UMG because
    it will allow us to need only a single dialog UMG that we will dynamically place
    text into.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建 NPC 将对角色说的话的对话。为此，我们将首先创建一个 Widget 蓝图，该蓝图将负责存放所有 NPC 的父变量，例如游戏中的对话，这样我们就可以通过在函数中调用对话变量来随时获取对话。这个过程将比在
    UMG 中硬编码文本更好，因为它将允许我们只需要一个动态放置文本的单一对话 UMG。
- en: 'So let''s first create a new Widget Blueprint by navigating to **Content Browser**
    | **Content** | **Blueprints** | **UI** and then selecting **Add New** | **User
    Interface** | **Widget Blueprint**. Then, name it **NPC_Parent**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先通过导航到 **内容浏览器** | **内容** | **蓝图** | **UI** 并选择 **添加新** | **用户界面** |
    **Widget 蓝图** 来创建一个新的 Widget 蓝图。然后，将其命名为 **NPC_Parent**：
- en: '![Dialog box setup](img/B04548_06_28.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_28.jpg)'
- en: 'Once created, open the new Widget Blueprint and then navigate to the graph.
    From here, head to the **My Blueprint** panel and select **+** to the right of
    **Variables**; this will create a new variable. Name this variable **NPCDialog**
    and make it public by clicking the eye to the right of the variable name:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，打开新的 Widget 蓝图，然后导航到图。从这里，转到 **我的蓝图** 面板，并选择 **变量** 右侧的 **+**；这将创建一个新的变量。将此变量命名为
    **NPCDialog** 并通过点击变量名右侧的眼睛将其设置为公共变量：
- en: '![Dialog box setup](img/B04548_06_29.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_29.jpg)'
- en: 'In the **Details** panel, change **Variable Type** to **Text** since we will
    be using text to display dialog. Also, click on the square icon to the right of
    **Variable Type** to make the variable a text array:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，将**变量类型**更改为**文本**，因为我们将会使用文本来显示对话框。同时，点击**变量类型**右侧的方形图标，使该变量成为文本数组：
- en: '![Dialog box setup](img/B04548_06_30.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_30.jpg)'
- en: 'Next, scroll down to the **Default Value** tab within the **Details** panel
    to the area that contains elements of an array. By default, it does not have elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**详细信息**面板内的**默认值**选项卡中向下滚动到包含数组元素的区域。默认情况下，它没有任何元素：
- en: '![Dialog box setup](img/B04548_06_31.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_31.jpg)'
- en: 'In **Details** | **Default Value**, click on **+** next to **elements** to
    add an element that will create a text box next to the element **0**. Put a value
    in this element by writing some text. You can write any form of text you want
    here; since at one point I plan to have the NPC give the player information, I
    will make the dialog say *You can check out your Character Status by pressing
    P when you are outside of battle*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在**详细信息** | **默认值**中，点击**元素**旁边的**+**来添加一个元素，该元素将在**0**元素旁边创建一个文本框。在这个元素中输入一些文本作为值。您可以在这里写入任何形式的文本；由于我计划让NPC在玩家离开战斗时向玩家提供信息，我将使对话框显示*当您在战斗外按P键时，您可以检查您的角色状态*：
- en: '![Dialog box setup](img/B04548_06_32.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_32.jpg)'
- en: 'Since our NPC is a shop owner, they can greet us, for example, by saying *Greetings.
    I am Roy, the shop owner, what can I do for you?* You can add this text as a second
    element in the **NPCDialog** array:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的NPC是店主，他们可以像这样问候我们，例如，说*问候。我是罗伊，店主，我能为您做什么？*您可以将此文本作为**NPCDialog**数组中的第二个元素添加：
- en: '![Dialog box setup](img/B04548_06_33.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_33.jpg)'
- en: 'Whenever we need a new NPC variable that we may not want hardcoded, we can
    go back to this Widget Blueprint and add dialog like we did just now. Next, we
    can create the actual dialog for our NPC by navigating back to our **Content Browser**.
    Since we may end up having many different characters using the same dialog box
    just with different text in it, we may want to create another Widget Blueprint
    that just has a basic window and a button to exit the dialog box. In **Content
    Browser**, navigate to **Content** | **Blueprints** | **UI** and then select **Add
    New** | **User Interface** | **Widget Blueprint**. Then, name it **DialogBox**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要一个新的NPC变量，而我们可能不希望它被硬编码时，我们可以回到这个Widget Blueprint，并像刚才那样添加对话框。接下来，我们可以通过导航回我们的**内容浏览器**来为我们的NPC创建实际的对话框。由于我们最终可能会有许多不同的角色使用相同的对话框，只是里面的文本不同，我们可能想要创建另一个Widget
    Blueprint，它只包含一个基本窗口和一个退出对话框的按钮。在**内容浏览器**中，导航到**内容** | **蓝图** | **UI**，然后选择**添加新项**
    | **用户界面** | **Widget Blueprint**。然后，将其命名为**DialogBox**：
- en: '![Dialog box setup](img/B04548_06_34.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_34.jpg)'
- en: 'Open the new Widget Blueprint. From here, navigate to **File** | **Reparent
    Blueprint** and reparent it to **NPC_Parent**, which holds all our variables:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新的Widget Blueprint。从这里，导航到**文件** | **重新父化蓝图**，并将其重新父化到**NPC_Parent**，它包含我们所有的变量：
- en: '![Dialog box setup](img/B04548_06_35.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_35.jpg)'
- en: 'Since dialog boxes are rarely the size of the entire screen, we are going to
    create a Canvas Panel within our default Canvas Panel by navigating to **Panel**
    | **Canvas Panel** and dragging the new Canvas Panel within the parent Canvas
    Panel:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对话框的大小很少会覆盖整个屏幕，我们将在默认的画布面板内创建一个画布面板，通过导航到**面板** | **画布面板**并拖动新的画布面板到父画布面板内来完成：
- en: '![Dialog box setup](img/B04548_06_36.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_36.jpg)'
- en: 'Rename this new Canvas Panel **CanvasPanel_DialogBox**. Also, anchor this Canvas
    Panel to the middle of the screen:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新的画布面板重命名为**CanvasPanel_DialogBox**。此外，将这个画布面板锚定在屏幕中间：
- en: '![Dialog box setup](img/B04548_06_37.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_37.jpg)'
- en: 'You may also want to resize the text box to hold a decent amount of text. I
    will resize this text box to have a **Size X** value of **1024** and **Size Y**
    value of **512**. You should also center the box by setting **Position X** to
    -1024/2 which is equal to **-512**, and **Position Y** to -512/2 which is equal
    to **-256**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想调整文本框的大小，以便容纳适量的文本。我将调整这个文本框的**Size X**值为**1024**，**Size Y**值为**512**。您还应该通过将**Position
    X**设置为-1024/2，即**-512**，以及将**Position Y**设置为-512/2，即**-256**来居中文本框：
- en: '![Dialog box setup](img/B04548_06_38.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_38.jpg)'
- en: 'Within **CanvasPanel_DialogBox**, add an image from **Palette** | **Common**
    | **Image** that we can use to add a background color in a similar way to what
    we did for the pause menu:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CanvasPanel_DialogBox**内，从**调色板** | **常用** | **图像**中添加一个图像，我们可以用它以类似我们在暂停菜单中做的方式添加背景颜色：
- en: '![Dialog box setup](img/B04548_06_39.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_39.jpg)'
- en: 'In the **Details** panel, rename this image **BGColor** and position and resize
    it so that it is in the middle of the screen. This can easily be done by choosing
    a center anchor:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在**详情**面板中，将此图像重命名为**BGColor**，并调整其位置和大小，使其位于屏幕中央。这可以通过选择中心锚点轻松完成：
- en: '![Dialog box setup](img/B04548_06_40.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_40.jpg)'
- en: 'Resize and position this to be the same as the Canvas Panel, that is, the **Size
    X** value as **1024**, **Size Y** value as **512**, **Position X** value as **-512**,
    and **Position Y** value as **256**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调整大小和位置，使其与画布面板相同，即**Size X**值为**1024**，**Size Y**值为**512**，**Position X**值为**-512**，**Position
    Y**值为**256**：
- en: '![Dialog box setup](img/B04548_06_41.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_41.jpg)'
- en: 'Lastly, under **Details** | **Appearance** | **Color and Opacity**, adjust
    the color to be the same as the other menus. In this case, we can select the color
    picker and pass in the linear hex value of **267FFFFF**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**详情** | **外观** | **颜色和透明度**下，调整颜色以与其他菜单相同。在这种情况下，我们可以选择颜色选择器并传入线性十六进制值**267FFFFF**：
- en: '![Dialog box setup](img/B04548_06_42.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_42.jpg)'
- en: 'Next, let us insert an exit button to leave this menu by selecting and dragging
    a button from **Palette** | **Common** | **Button** into **CanvasPanel_DialogBox**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们插入一个退出按钮，通过从**调色板** | **常用** | **按钮**中选择并拖动一个按钮到**CanvasPanel_DialogBox**中，以离开此菜单：
- en: '![Dialog box setup](img/B04548_06_43.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_43.jpg)'
- en: 'Rename this button **Button_Exit** and position it towards the right-hand side
    of your Canvas Panel by first changing the size of your button to match the size
    of the pause menu buttons, which have the **Size X** value as **300** and the
    **Size Y** value as **100**. Then, position the button in the bottom-right of
    the Canvas Panel, by changing the anchor to bottom-right aligned. Then, use simple
    positions such as the one that gives 20 pixels of padding, that is, **Position
    X** as **-320** and **Position Y** as **-120**. You will also notice that the
    button is behind **BGColor**; simply change the **ZOrder** value to **1**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将此按钮重命名为**Button_Exit**，并通过首先将按钮的大小调整为与暂停菜单按钮的大小相匹配，将按钮定位在画布面板的右侧。这些按钮的**Size
    X**值为**300**，**Size Y**值为**100**。然后，通过将锚点更改为右下对齐，将按钮定位在画布面板的右下角。然后，使用简单的位置，例如提供20像素填充的位置，即**Position
    X**为**-320**，**Position Y**为**-120**。你还会注意到按钮位于**BGColor**之后；只需将**ZOrder**值更改为**1**：
- en: '![Dialog box setup](img/B04548_06_44.jpg)![Dialog box setup](img/B04548_06_45.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_44.jpg)![对话框设置](img/B04548_06_45.jpg)'
- en: 'Now that you have a button created and positioned, add a Text Block to it.
    Rename the text **TextBlock_Exit** and under **Details** | **Appearance** | **Font**,
    change the font size to **48**. Also, change the content of the Text Block to
    **Exit**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建并定位了一个按钮，向其中添加一个文本块。将文本重命名为**TextBlock_Exit**，然后在**详情** | **外观** | **字体**下，将字体大小更改为**48**。同时，将文本块的内容更改为**退出**：
- en: '![Dialog box setup](img/B04548_06_46.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_46.jpg)'
- en: 'Program the button to exit as well, just like you did in the previous menu
    creations, by selecting the button, scrolling down to **OnClicked** in **Details**
    | **Events**, and then clicking on the **+** button. This will open up **Event
    Graph** and populate the **OnClicked** event for the exit button. Drag out the
    **Out** pin from the **OnClicked** event and select **Remove from Parent** located
    under **Widget**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编程按钮以退出，就像你在之前的菜单创建中做的那样，通过选择按钮，在**详情** | **事件**中向下滚动到**OnClicked**，然后点击**+**按钮。这将打开**事件图**并为退出按钮填充**OnClicked**事件。从**OnClicked**事件中拖出**Out**引脚，并选择位于**小部件**下的**从父级移除**：
- en: '![Dialog box setup](img/B04548_06_47.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_47.jpg)'
- en: 'Navigate back to the **Designer** view and add a Text Block to **CanvasPanel_DialogBox**,
    name it **TextBlock_Dialog**, and have it take up most of the Canvas Panel. For
    this, we can position the Text Block to have a padding of 20 pixels by giving
    **Position X** a value of **20** and **Position Y** a value of **20**. We can
    also set the size of the Text Block giving **Size X** a value of **986** and **Size
    Y** a value of **300**. Lastly, set the **ZOrder** value to **1**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**设计器**视图，向**CanvasPanel_DialogBox**添加一个文本块，命名为**TextBlock_Dialog**，并使其占据大部分画布面板。为此，我们可以通过将**Position
    X**设置为**20**和**Position Y**设置为**20**来定位文本块，使其具有20像素的填充。我们还可以设置文本块的大小，将**Size X**设置为**986**和**Size
    Y**设置为**300**。最后，将**ZOrder**值设置为**1**：
- en: '![Dialog box setup](img/B04548_06_48.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![对话框设置](img/B04548_06_48.jpg)'
- en: At this point, we are finished with creating the dialog box template. We can
    now move on to creating dialog boxes for our NPC.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了对话框模板的创建。现在我们可以继续为我们的NPC创建对话框。
- en: Creating an NPC welcome box
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NPC欢迎框
- en: 'Now that we have a template for our dialog boxes, let''s use them by creating
    custom dialog boxes for our NPC that are based on what we just created. To stay
    organized, we should make a separate folder for NPCs since we will most likely
    have a lot more UMG and opportunities to use our dialog box outside of the NPC
    creation. So within **Content Browser**, navigate to **Content** | **Blueprints**
    | **UI** and create a new folder under **Add New**. Name this folder `NPC` and
    then navigate into the folder. Create a duplicate of the **DialogBox** Widget
    Blueprint that you made in the previous section and move it into the `NPC` folder.
    Name the duplicated widget **Shop_Welcome**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了对话框模板，让我们通过为我们的NPC创建基于我们刚刚创建的内容的定制对话框来使用它们。为了保持组织有序，我们应该为NPC创建一个单独的文件夹，因为我们很可能会拥有更多的UMG和机会在NPC创建之外使用我们的对话框。所以，在**内容浏览器**中，导航到**内容**
    | **蓝图** | **UI**，并在**添加新内容**下创建一个新文件夹。将此文件夹命名为`NPC`，然后进入该文件夹。创建之前章节中制作的**DialogBox**
    Widget蓝图的一个副本，并将其移动到`NPC`文件夹中。将复制的控件命名为**Shop_Welcome**：
- en: '![Creating an NPC welcome box](img/B04548_06_50.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_50.jpg)'
- en: 'Open the **Shop_Welcome** widget and select the **TextBlock_Dialog** Text Block.
    In **Details** | **Content**, create a new text binding that will then open up
    the graph:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Shop_Welcome**控件，并选择**TextBlock_Dialog**文本块。在**详细信息** | **内容**中创建一个新的文本绑定，这将打开图表：
- en: '![Creating an NPC welcome box](img/B04548_06_51.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_51.jpg)'
- en: 'At this point, you can right click to find **All Actions for this Blueprint**,
    and under **Variables** | **Default**, you should find the **Get NPCDialog** variable
    which you can use:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您可以右键点击以找到**此蓝图的所有操作**，然后在**变量** | **默认**下，您应该找到可以使用的**Get NPCDialog**变量：
- en: '![Creating an NPC welcome box](img/B04548_06_52.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_52.jpg)'
- en: 'From here, drag out the **NPCDialog** array pin and select the **Get** function
    under **Utilities** | **Array**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，拖出**NPCDialog**数组引脚，并在**实用工具** | **数组**下选择**获取**函数：
- en: '![Creating an NPC welcome box](img/B04548_06_53.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_53.jpg)'
- en: 'From here, you can select any of the text that is in **NPCDialog** by choosing
    the right element. Since the welcome text is in element 1, change the **0** in
    the **Get** function to **1**. To have this text return to the Text Block, link
    **GET** to **Return Value** of **ReturnNode**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以通过选择正确的元素来选择**NPCDialog**中的任何文本。由于欢迎文本在元素1中，将**获取**函数中的**0**更改为**1**。为了使此文本返回到文本块，将**GET**链接到**ReturnNode**的**返回值**：
- en: '![Creating an NPC welcome box](img/B04548_06_54.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_54.jpg)'
- en: 'Since this is the welcome dialog box, we will still allow the player to exit,
    but we should also allow them to get general details from the NPC or visit their
    shop. So let''s copy the **Exit** button and put place holders for both talking
    and shopping. Navigate back to the **Designer** view and make two more buttons
    on the left-hand side of the **Exit** button, one that says **Shop** and one that
    says **Talk**. You don''t have to program these buttons yet since we do not have
    a shop or talk UMG yet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是欢迎对话框，我们仍然允许玩家退出，但我们也应该允许他们从NPC那里获取一般信息或访问他们的商店。所以，让我们复制**退出**按钮，并为谈话和购物放置占位符。导航回**设计器**视图，在**退出**按钮的左侧再添加两个按钮，一个写着**商店**，另一个写着**谈话**。您不必现在就编程这些按钮，因为我们还没有商店或谈话UMG：
- en: '![Creating an NPC welcome box](img/B04548_06_55.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_55.jpg)'
- en: 'Next, make this screen appear at the proper time by opening the Level Blueprint
    that you started at the beginning of this chapter. Instead of printing text to
    the screen when the **Talk Shop** condition is true, link **Create Widget** under
    **User Interface** to **True**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过打开本章开头创建的关卡蓝图，使此屏幕在正确的时间出现。当**谈话商店**条件为真时，不要将文本打印到屏幕上，而是将**用户界面**下的**创建Widget**链接到**True**：
- en: '![Creating an NPC welcome box](img/B04548_06_56.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_56.jpg)'
- en: 'For the class, select **Shop_Welcome**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，选择**Shop_Welcome**：
- en: '![Creating an NPC welcome box](img/B04548_06_57.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_57.jpg)'
- en: 'Lastly, display this to the screen by linking the Return Value pin of **Create
    Shop_Welcome Widget** to **Add to Viewport**, which is located under **User Interface**
    | **Viewport**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将**Create Shop_Welcome Widget**的返回值引脚链接到位于**用户界面** | **视口**下的**添加到视口**，将此内容显示到屏幕上：
- en: '![Creating an NPC welcome box](img/B04548_06_58.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_58.jpg)'
- en: 'Also, give the player access to a mouse cursor by creating a **Get Player Controller**
    function under **Game** and linking its **Return Value** to **Set Show Mouse Cursor**
    located under **Class** | **Player Controller**. Finally, link the **Add to Viewport**
    node to the **Set Show Mouse Cursor** node and check **Show Mouse Cursor**. When
    you are finished, your Level Blueprint should look like the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过在**游戏**下创建一个**获取玩家控制器**函数，并将它的**返回值**链接到位于**类** | **玩家控制器**下的**设置显示鼠标光标**，给玩家访问鼠标光标的权限。最后，将**添加到视口**节点链接到**设置显示鼠标光标**节点，并检查**显示鼠标光标**。完成之后，你的关卡蓝图应该看起来像以下截图：
- en: '![Creating an NPC welcome box](img/B04548_06_59.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_59.jpg)'
- en: 'If you playtest this now, you should be able to still go up to the NPC and
    press *E* to interact with him, but this time a dialog box will appear:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在进行游戏测试，您应该仍然可以走到NPC那里并按*E*键与他交互，但这次会弹出一个对话框：
- en: '![Creating an NPC welcome box](img/B04548_06_60.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建NPC欢迎框](img/B04548_06_60.jpg)'
- en: Congratulations, you have created your first dialog box. Now let us move on
    to making navigation buttons that open up other interactive widgets.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经创建了您的第一个对话框。现在让我们继续制作打开其他交互式小部件的导航按钮。
- en: Adding an NPC talk box
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加NPC对话框
- en: Now that you have already created a dialog box that pops up when the player
    interacts with the NPC, you can easily add dialog for the player to see when they
    click on the **Talk** button. Simply duplicate the **DialogBox** Widget Blueprint
    that you made previously and place it in the `NPC` folder under **Content Browser**
    located in **Content** | **Blueprints** | **UI**. Rename the duplicated Widget
    Blueprint **Shop_Talk**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个当玩家与NPC交互时弹出的对话框，您可以轻松地为玩家添加当他们在**谈话**按钮上点击时可以看到的对话。只需复制您之前创建的**DialogBox**
    Widget 蓝图，并将其放置在**内容浏览器**下的**NPC**文件夹中，该文件夹位于**内容** | **蓝图** | **UI**。将复制的 Widget
    蓝图重命名为**Shop_Talk**。
- en: We will now add some proper dialog to this menu by opening the **Shop_Talk**
    Widget Blueprint. Then, within the **Designer** viewport, select the Text Block
    that is already placed into your Canvas Panel.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过打开**Shop_Talk** Widget 蓝图向此菜单添加一些适当的对话。然后在**设计师**视图中，选择已经放置到您的画布面板中的文本块。
- en: Once selected, navigate to **Details** | **Content** and, within **Text**, select
    **Bind** | **+ Create Binding**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，导航到**详情** | **内容**，然后在**文本**中，选择**绑定** | **+ 创建绑定**。
- en: As always, this action will automatically bring you to the Graph Editor and
    set the **Get Text** function to return a null value from a **Return** node. The
    next steps are identical to the steps that you did when calling dialog from the
    **NPCDialog** variable in the previous sections. You must navigate to the **My
    Blueprint** tab and use the **GET** version of the **NPCDialog** variable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，此操作将自动将您带到图形编辑器，并将**获取文本**函数设置为从**返回**节点返回空值。接下来的步骤与您在上一节中从**NPCDialog**变量调用对话框时所做的步骤相同。您必须导航到**我的蓝图**选项卡，并使用**NPCDialog**变量的**GET**版本。
- en: 'Then, drag out the **NPCDialog** array pin and select the **Get** function
    under **Utilities** | **Array**. Lastly, have the **GET** function select the
    correct element of the **NPCDialog** array. In this case, we would keep element
    0 selected since we set our dialog in element 0 earlier in this chapter. Once
    the proper dialog is chosen, link **GET** to **Return Value** of the **ReturnNode**.
    At this point, your Graph Editor should look like the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，拖出**NPCDialog**数组引脚并选择位于**Utilities** | **Array**下的**Get**函数。最后，让**GET**函数选择**NPCDialog**数组中的正确元素。在这种情况下，我们会保持元素0被选中，因为我们之前在本章中设置了元素0的对话。一旦选择了正确的对话，将**GET**链接到**ReturnNode**的**Return
    Value**。此时，你的Graph Editor应该看起来像以下截图：
- en: '![Adding an NPC talk box](img/B04548_06_64.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![添加NPC对话框](img/B04548_06_64.jpg)'
- en: 'You are now finished with the **Shop_Talk** Widget Blueprint. You need to now
    bind it to the **Talk** button in the **Shop_Welcome** Widget Blueprint, so open
    the **Designer** view in **Shop_Welcome** and select the **Talk** button. In the
    **Details** panel, navigate to **Events** and press the **+** button next to **OnClicked**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了**Shop_Talk** Widget Blueprint。你需要现在将其绑定到**Shop_Welcome** Widget Blueprint
    中的**Talk**按钮上，因此打开**Shop_Welcome**中的**Designer**视图并选择**Talk**按钮。在**Details**面板中，导航到**Events**并按下**OnClicked**旁边的**+**按钮：
- en: '![Adding an NPC talk box](img/B04548_06_65.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![添加NPC对话框](img/B04548_06_65.jpg)'
- en: 'This should now create an **OnClicked** event bound to your **Talk** button
    and the Event Graph should now have automatically opened. From here, what we need
    to do is upon the button being clicked, we need to close the **Shop_Welcome**
    Widget Blueprint and open the **Shop_Talk** Widget Blueprint. These steps should
    be very similar to what you did many times previously when you opened and closed
    Widget Blueprints after button presses. Link the **OnClicked** event to **Remove
    from Parent** located under **Widget**, which will close your current Widget Blueprint.
    Then, link the **Create Widget** node to **Remove from Parent**, which is located
    under **User Interface**. Change the class of **Create Widget** to **Shop_Talk**
    so that your **Shop_Talk** Widget Blueprint is generated. From here, link **Add
    to Viewport** to **Return Value** of the **Create Shop_Talk Widget** node that
    is located under **User Interface** | **Viewport**. Also, be sure **Add to Viewport**
    is linked to the out pin of **Create Shop_Talk Widget** so that the Widget Blueprint
    is displayed in the player''s view only after the **Shop_Talk** widget is created.
    When you are finished, your **EventGraph** for your **Talk** button should look
    like the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该创建一个与你的**Talk**按钮绑定的**OnClicked**事件，并且事件图现在应该已经自动打开。从这里开始，我们需要做的是在按钮被点击时，我们需要关闭**Shop_Welcome**
    Widget Blueprint并打开**Shop_Talk** Widget Blueprint。这些步骤应该与你之前多次在按钮点击后打开和关闭 Widget
    Blueprint 时所做的非常相似。将**OnClicked**事件链接到位于**Widget**下的**Remove from Parent**，这将关闭你的当前
    Widget Blueprint。然后，将**Create Widget**节点链接到位于**User Interface**下的**Remove from
    Parent**。将**Create Widget**的类更改为**Shop_Talk**，以便生成你的**Shop_Talk** Widget Blueprint。从这里开始，将**Add
    to Viewport**链接到位于**User Interface** | **Viewport**下的**Create Shop_Talk Widget**节点的**Return
    Value**。同时，确保**Add to Viewport**链接到**Create Shop_Talk Widget**的输出引脚，这样只有在**Shop_Talk**
    widget 创建后，Widget Blueprint 才会在玩家的视图中显示。当你完成时，你的**Talk**按钮的**EventGraph**应该看起来像以下截图：
- en: '![Adding an NPC talk box](img/B04548_06_66.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![添加NPC对话框](img/B04548_06_66.jpg)'
- en: 'You may have noticed that the **Talk** button now works perfectly, but the
    text will get cut off:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，**Talk**按钮现在工作得非常完美，但文本会被截断：
- en: '![Adding an NPC talk box](img/B04548_06_67.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![添加NPC对话框](img/B04548_06_67.jpg)'
- en: 'This is because we are not wrapping the text. To wrap the text, go back into
    the **Shop_Talk** Widget Blueprint and, in the **Designer** view, select the **Dialog**
    Text Block. Then, in the **Details** panel, navigate to **Appearance** and check
    **Auto Text Wrap**. This will ensure that the text is always wrapped around the
    content, which in this case will move the text to a new line when it hits the
    border of the Text Block. If you test the **Talk** button, the words should now
    wrap like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有包裹文本。要包裹文本，请回到**Shop_Talk** Widget Blueprint，并在**Designer**视图中选择**Dialog**文本块。然后，在**Details**面板中，导航到**Appearance**并勾选**Auto
    Text Wrap**。这将确保文本始终围绕内容包裹，在这种情况下，当文本达到文本块的边界时，文本将移动到新的一行。如果你测试**Talk**按钮，单词应该现在这样包裹：
- en: '![Adding an NPC talk box](img/B04548_06_68.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![添加NPC对话框](img/B04548_06_68.jpg)'
- en: At this point, you should have the interaction working perfectly between the
    player and the NPC with all buttons working properly, with the exception of the
    **Shop** button.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经实现了玩家与NPC之间的交互，所有按钮都工作正常，除了**商店**按钮。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an NPC that can communicate with the player through
    the use of a trigger volume and key binding. Now, we can display dialog from an
    array of strings at any point in our game. In the next chapter, we will transform
    our NPC into a shop owner and allow the player to purchase equipment from the
    shop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个可以通过触发体积和按键绑定与玩家进行通信的非玩家角色（NPC）。现在，我们可以在游戏的任何时刻从字符串数组中显示对话。在下一章中，我们将我们的NPC转换成店主，并允许玩家从商店购买装备。
