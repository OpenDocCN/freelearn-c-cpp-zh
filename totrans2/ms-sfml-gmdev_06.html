<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Adding Some Finishing Touches - Using Shaders</h1></div></div></div><p>Having good art is important for any game, as it greatly compliments the content game designers bring to the table. However, simply tacking on any and all graphics to some logic and calling it a day just does not cut it anymore. Good visual aesthetics of a game are now formed by hand-in-hand cooperation of amazing art and the proper post-processing that follows. Dealing with graphics as if they are paper cut-outs feels dated, while incorporating them in the dynamic universe of your game world and making sure they react to their surroundings by properly shading them has become the new standard. For a brief moment, let us put aside gameplay and discuss the technique of that special kind of post-processing, known as shading.</p><p>In this chapter, we are going to be covering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics of the SFML shader class</li><li class="listitem" style="list-style-type: disc">Implementing a unified way of drawing objects</li><li class="listitem" style="list-style-type: disc">Adding a day-night cycle to the game</li></ul></div><p>Let us get started with giving our project that extra graphical enhancement!</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Understanding shaders</h1></div></div></div><p>In the modern world of computer graphics, many different calculations are offloaded to the GPU. Anything from simple pixel colour calculations, to complex lighting effects can and should be handled by hardware that is specifically designed for this purpose. This is where shaders come in.</p><p>A <strong>shader</strong> is a little program that runs on your graphics card instead of the CPU, and controls how each pixel of a shape is rendered. The main purpose of a shader, as the name suggests, is performing lighting and shading calculations, but they can be used for much more than that. Because of the power modern GPUs have, libraries exist that are designed to perform calculations on the GPU that would usually be executed on the CPU, in order to cut down the computation time significantly. Anything from physics computations to cracking password hashes can be done on the GPU, and the entry point to that horsepower is a shader.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>GPUs are good at performing tons of very specific calculations in parallel at once. Using less predictable or unparallel algorithms is very inefficient on the GPU, which is what the CPU excels at. However, as long as the data can be processed exactly the same in parallel, the task is deemed worthy of being pushed to the GPU for further handling.</p></div></div><p>There are two main types of shader that SFML provides: <strong>vertex</strong> and <strong>fragment</strong>. Newer versions of SFML (<em>2.4.0</em> and up) have added support for geometry shaders as well, but it is not necessary to cover this for our purposes.</p><p>A <strong>vertex shader</strong> is executed once per vertex. This process is commonly referred to as <strong>per-vertex</strong> shading. For example, any given triangle has three vertices. This means that the shader would be executed once for each vertex for a grand total of three times.</p><p>A <strong>fragment shader</strong> is executed once per pixel (otherwise known as a fragment), which results in the process being referred to as <strong>per-pixel</strong> shading. This is much more taxing than simply performing per-vertex calculations, but is much more accurate and generally produces better visual results.</p><p>Both types of shader can be used at once on a single piece of geometry being drawn, and can also communicate with each other.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Shader examples</h2></div></div></div><p>The <strong>OpenGL Shading Language</strong> (<strong>GLSL</strong>) is extremely similar to <em>C</em> or <em>C++</em>. It even uses the same basic syntax, as seen in this vertex shader example:</p><pre class="programlisting">#version 450 
 
void main() 
{ 
    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix 
      * gl_Vertex; 
    gl_FrontColor = gl_Color; // Send colour to fragment shader. 
} 
</pre><p>Notice the version on the very first line. The number <code class="literal">450</code> indicates the version of OpenGL that should be used, in this case <em>4.5</em>. Newer versions of SFML support OpenGL versions <em>3.3+</em>; however the success of running it also depends on the capabilities of your graphics card.</p><p>For now, simply ignore the first line of the <code class="literal">main</code> function. It has to do with positions transformations from one coordinate system to another, and is specific to a few possible approaches to shading. These concepts will be covered in the next chapter.</p><p>GLSL provides quite a few <em>hooks</em> that allow direct control of vertex and pixel information, such as <code class="literal">gl_Position</code> and <code class="literal">gl_Color</code>. The former is simply the position of the vertex that will be used in further calculations down the line, while the latter is the vertex colour, which is being assigned to <code class="literal">gl_FrontColor</code>, ensuring the colour is passed down the pipeline to the fragment shader.</p><p>Speaking of the fragment shader, here is a very minimal example of what it may look like:</p><pre class="programlisting">#version 450 
 
void main() 
{ 
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White pixel. 
} 
</pre><p>In this particular case, <code class="literal">gl_FragColor</code> is used to set a static value of the pixel being rendered. Any shape being rendered while using this shader will come out white.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>The values of this vector are normalized, meaning they have to fall in the range of <em>0.f &lt; n &lt;= 1.0f</em>.</p></div></div><p>Keep in mind that <code class="literal">gl_Color</code> can be used here to sample the colour that is passed down from the vertex shader. However, because there may be multiple pixels in between vertices, the colour for each fragment is interpolated. In a case where each vertex of a triangle is set to colours red, green, and blue, the interpolated result would look like this:</p><div><img src="img/image_06_001.jpg" alt="Shader examples"/></div><p>One last thing to note about any shader is that they support communication from outside sources. This is done by using the <code class="literal">uniform</code> keyword, followed by the variable type and capped off by its name like so:</p><pre class="programlisting">#version 450 
uniform float r; 
uniform float g; 
uniform float b; 
 
void main() 
{ 
    gl_FragColor = vec4(r, g, b, 1.0); 
} 
</pre><p>In this particular example, outside code passes in three <code class="literal">float</code> that will be used as color values for the fragment. Uniforms are simply <strong>global</strong> variables that can be manipulated by outside code before a shader is used.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec50"/>SFML and shaders</h2></div></div></div><p>Storing and using shaders in SFML is made simple by introducing the <code class="literal">sf::Shader</code> class. Although shaders are generally supported by most devices out there, it is still a good idea to perform a check that determines if the system the code is being executed on supports shaders as well:</p><pre class="programlisting">if(!sf::Shader::isAvailable()){ // Shaders not available! } 
</pre><p>This shader class can hold either one of the two types of shader just by itself or a single instance of each type at the same time. Shaders can be loaded in one of two ways. The first is by simply reading a text file:</p><pre class="programlisting">sf::Shader shader; // Create a shader instance. 
 
// Loading a single type of shader. 
if (!shader.loadFromFile("shader.vert", sf::Shader::Vertex)) { 
  // Failed loading. 
} 
// OR 
if (!shader.loadFromFile("shader.frag", sf::Shader::Fragment)) { 
  // Failed loading. 
} 
 
// load both shaders 
if (!shader.loadFromFile("shader.vert", "shader.frag")) { 
  // Failed loading. 
} 
</pre><div><div><h3 class="title"><a id="note14"/>Note</h3><p>File extensions of these shaders do not have to match the preceding ones. Because we are working with text files, the extension simply exists for clarity.</p></div></div><p>The second way to load a shader is by parsing a string loaded in memory:</p><pre class="programlisting">sf::Shader shader; 
const std::string code = "..."; 
// String that contains all shader code. 
</pre><pre class="programlisting">if (!shader.loadFromMemory(code, sf::Shader::Vertex)) { 
  // Failed loading. 
} 
</pre><p>Using a shader is fairly straightforward as well. Its address simply needs to be passed in to a render targets <code class="literal">draw()</code> call as the second argument when something is being rendered to it:</p><pre class="programlisting">window.draw(drawable, &amp;shader); 
</pre><p>Since our shaders may need to be communicated with through <code class="literal">uniform</code> variables, there has to be a way to set them. Enter <code class="literal">sf::Shader::setUniform(...)</code>:</p><pre class="programlisting">shader.setUniform("r",  0.5f); 
</pre><p>This simple bit of code manipulates the <code class="literal">r</code> uniform inside whatever shader(s) happen to be loaded inside the <code class="literal">shader</code> instance. The method itself supports many more types besides <em>float</em>, which we will be covering in the next chapter.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Localizing rendering</h1></div></div></div><p>Shading is a powerful concept. The only problem with injecting a stream of extra-graphical-fanciness to our game at this point is the fact that it is simply not architected to deal with using shaders efficiently. Most, if not all of our classes that do any kind of drawing do so by having direct access to the <code class="literal">sf::RenderWindow</code> class, which means they would have to pass in their own shader instances as arguments. This is not efficient, re-usable, or flexible at all. A better approach, such as a separate class dedicated to rendering, is a necessity.</p><p>In order to be able to switch from shader to shader with relative ease, we must work on storing them properly within the class:</p><pre class="programlisting">using ShaderList = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;sf::Shader&gt;&gt;; 
</pre><p>Because the <code class="literal">sf::Shader</code> class is a non-copyable object (inherits from <code class="literal">sf::NonCopyable</code>), it is stored as a unique pointer, resulting in avoidance of any and all move semantics. This list of shaders is directly owned by the class that is going to do all of the rendering, so let us take a look at its definition:</p><pre class="programlisting">class Renderer { 
public: 
  Renderer(Window* l_window, bool l_useShaders = true); 
 
  void AdditiveBlend(bool l_flag); 
  bool UseShader(const std::string&amp; l_name); 
  void DisableShader(); 
  sf::Shader* GetShader(const std::string&amp; l_name); 
 
  void BeginDrawing(); 
  bool IsDrawing()const; 
  void Draw(const sf::Shape&amp; l_shape, 
    sf::RenderTarget* l_target = nullptr); 
  void Draw(const sf::Sprite&amp; l_sprite, 
    sf::RenderTarget* l_target = nullptr); 
  void Draw(const sf::Drawable&amp; l_drawable, 
    sf::RenderTarget* l_target = nullptr); 
  void EndDrawing(); 
private: 
  void LoadShaders(); 
 
  Window* m_window; 
  ShaderList m_shaders; 
  sf::Shader* m_currentShader; 
  bool m_addBlend; 
  bool m_drawing; 
  bool m_useShaders; 
  unsigned int m_drawCalls; // For debug purposes. 
}; 
</pre><p>Since shaders need to be passed in as arguments to the window <code class="literal">draw()</code> calls, it is obviously imperative for the renderer to have access to the <code class="literal">Window</code> class. In addition to that and the list of shaders that can be used at any given time, we also keep a pointer to the current shader being used in order to cut down on container access time, as well as a couple of flags that will be used when choosing the right shader to use, or determining whether the drawing is currently happening in the first place. Lastly, a fairly useful debug feature is having information about how many draw calls happen during each update. For this, a simple <em>unsigned integer </em>is going to be used.</p><p>The class itself provides the basic features of enabling/disabling additive blending instead of a regular shader, switching between all available shaders, and disabling the current shader, as well as obtaining it. The <code class="literal">BeginDrawing()</code> and <code class="literal">EndDrawing()</code> methods are going to be used by the <code class="literal">Window</code> class in order to provide us with <em>hooks</em> for obtaining information about the rendering process. Note the overloaded <code class="literal">Draw()</code> method. It is designed to take in any drawable type and draw it on either the current window, or the appropriate render target that can be provided as the second argument.</p><p>Finally, the <code class="literal">LoadShaders()</code> private method is going to be used during the initialization stage of the class. It holds all of the logic necessary to load every single shader inside the appropriate directory, and store them for later use.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Implementing the renderer</h2></div></div></div><p>Let us begin by quickly going over the construction of the <code class="literal">Renderer</code> object, and the initialization of all of its data members:</p><pre class="programlisting">Renderer::Renderer(Window* l_window, bool l_useShaders) 
  : m_window(l_window), m_useShaders(l_useShaders), 
     m_drawing(false), m_addBlend(false), m_drawCalls(0), 
  m_currentShader(nullptr) {} 
</pre><p>Once the pointer to the <code class="literal">Window*</code> instance is safely stored, all of the data members of this class are initialized to their default values. The body of the constructor simply consists of a private method call, responsible for actually loading and storing all of the shader files:</p><pre class="programlisting">void Renderer::LoadShaders() { 
  if(!m_useShaders) { return; } 
  auto directory = Utils::GetWorkingDirectory() +"media/Shaders/"; 
  auto v_shaders = Utils::GetFileList(directory, "*.vert", false); 
  auto f_shaders = Utils::GetFileList(directory, "*.frag", false); 
 
  for (auto&amp; shader : v_shaders) { 
    auto&amp; file = shader.first; 
    auto name = file.substr(0, file.find(".vert")); 
    auto fragShader = std::find_if( 
      f_shaders.begin(), f_shaders.end(), 
      [&amp;name](std::pair&lt;std::string, bool&gt;&amp; l_pair) { 
        return l_pair.first == name + ".frag"; 
      } 
    ); 
 
    auto shaderItr = m_shaders.emplace(name, 
      std::move(std::make_unique&lt;sf::Shader&gt;())); 
    auto&amp; shader = shaderItr.first-&gt;second; 
    if (fragShader != f_shaders.end()) { 
      shader-&gt;loadFromFile(directory + name + ".vert", 
        directory + name + ".frag"); 
      f_shaders.erase(fragShader); 
    } else { 
      shader-&gt;loadFromFile(directory + name + ".vert", 
        sf::Shader::Vertex); 
    } 
  } 
 
  for (auto&amp; shader : f_shaders) { 
    auto&amp; file = shader.first; 
    auto name = file.substr(0, file.find(".frag")); 
    auto shaderItr = m_shaders.emplace(name, 
      std::move(std::make_unique&lt;sf::Shader&gt;())); 
    auto&amp; shader = shaderItr.first-&gt;second; 
    shader-&gt;loadFromFile(directory + name + ".frag", 
      sf::Shader::Fragment); 
  } 
} 
</pre><p>We begin by establishing a local variable that is going to hold the path to our <code class="literal">shader</code> directory. It is then used to obtain two lists of files with <code class="literal">.vert</code> and <code class="literal">.frag</code> extensions respectively. These will be the vertex and fragment shaders to be loaded. The goal here is to group vertex and fragment shaders with identical names, and assign them to a single instance of <code class="literal">sf::Shader</code>. Any shaders that do not have a vertex or fragment counterpart will simply be loaded alone in a separate instance.</p><p>Vertex shaders are as good a place as any to begin. After the filename is obtained and stripped of its extension, a fragment shader with the same name is attempted to be located. At the same time, a new <code class="literal">sf::Shader</code> instance is inserted into the shader container, and a reference to it is obtained. If a fragment counterpart has been found, both files are loaded into the shader. The fragment shader name is then removed from the list, as it will no longer need to be loaded in on its own.</p><p>As the first part of the code does all of the pairing, all that is really left to do at this point is load the fragment shaders. It is safe to assume that anything on the fragment shader list is a standalone fragment shader, not associated with a vertex counterpart.</p><p>Since shaders can have uniform variables that need to be initialized, it is important that outside classes have access to the shaders they use:</p><pre class="programlisting">sf::Shader* Renderer::GetShader(const std::string&amp; l_name) { 
  if(!m_useShaders) { return nullptr;  } 
  auto shader = m_shaders.find(l_name); 
  if (shader == m_shaders.end()) { return nullptr; } 
  return shader-&gt;second.get(); 
} 
</pre><p>If the shader with the provided name has not been located, <code class="literal">nullptr</code> is returned. On the other hand, a raw pointer to the <code class="literal">sf::Shader*</code> instance is obtained from the smart pointer and returned instead.</p><p>The same outside classes need to be able to instruct the <code class="literal">Renderer</code> when a specific shader should be used. For this purpose, the <code class="literal">UseShader()</code> method comes in handy:</p><pre class="programlisting">bool Renderer::UseShader(const std::string&amp; l_name) { 
  if(!m_useShaders) { return false; } 
  m_currentShader = GetShader(l_name); 
  return (m_currentShader != nullptr); 
} 
</pre><p>Since the <code class="literal">GetShader()</code> method already does the error-checking for us, it is used here as well. The value returned from it is stored as the pointer to the current shader, if any, and is then evaluated in order to return a <em>boolean</em> value, signifying success/failure.</p><p>The actual drawing of geometry is what we are all about here, so let us take a look at the overloaded <code class="literal">Draw()</code> method:</p><pre class="programlisting">void Renderer::Draw(const sf::Shape&amp; l_shape, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { 
    if (<strong>!m_window-&gt;GetViewSpace().intersects( 
      l_shape.getGlobalBounds())</strong>) 
    { return; } 
  } 
  Draw((const sf::Drawable&amp;)l_shape, l_target); 
} 
 
void Renderer::Draw(const sf::Sprite&amp; l_sprite, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { 
    if (<strong>!m_window-&gt;GetViewSpace().intersects( 
      l_sprite.getGlobalBounds())</strong>) 
    { return; } 
  } 
  Draw((const sf::Drawable&amp;)l_sprite, l_target); 
} 
</pre><p>Whether a <code class="literal">sf::Sprite</code> or <code class="literal">sf::Shape</code> is being rendered, the actual idea behind this is exactly the same. First, we check if the intention behind the method call was indeed to render to the main window by looking at the <code class="literal">l_target</code> argument. If so, a fair thing to do here is to make sure the drawable object actually is on screen. It would be pointless to draw it if it was not. Provided the test passes, the main <code class="literal">Draw()</code> method overload is invoked, with the current arguments being passed down:</p><pre class="programlisting">void Renderer::Draw(const sf::Drawable&amp; l_drawable, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { l_target = m_window-&gt;GetRenderWindow(); } 
  l_target-&gt;draw(l_drawable, 
    (m_addBlend ? sf::BlendAdd : m_currentShader &amp;&amp; m_useShaders ? 
      m_currentShader : sf::RenderStates::Default)); 
  ++m_drawCalls; 
} 
</pre><p>This is where all of the actual magic happens. The <code class="literal">l_target</code> argument is again checked for being equal to <code class="literal">nullptr</code>. If it is, the render window is stored inside the argument pointer. Whatever the target, at this point its <code class="literal">Draw()</code> method is invoked, with the drawable being passed in as the first argument, as well as the appropriate shader or blend mode passed in as the second. The additive blending obviously takes precedence here, enabling a quicker way of switching between using a shader and the additive blending modes by simply needing to use the <code class="literal">AdditiveBlend()</code> method.</p><p>Once the drawing is done, the <code class="literal">m_drawCalls</code> data member is incremented, so that we can keep track of how many drawables have been rendered in total at the end of each cycle.</p><p>Finally, we can wrap this class up by looking at a couple of essential yet basic setter/getter code:</p><pre class="programlisting">void Renderer::AdditiveBlend(bool l_flag) { m_addBlend = l_flag; } 
void Renderer::DisableShader() { m_currentShader = nullptr; } 
void Renderer::BeginDrawing(){ m_drawing = true; m_drawCalls = 0;} 
bool Renderer::IsDrawing() const { return m_drawing; } 
void Renderer::EndDrawing() { m_drawing = false; } 
</pre><p>As you can see, disabling the use of shaders for whatever is being drawn currently is as simple as setting the <code class="literal">m_currentShader</code> data member to <code class="literal">nullptr</code>. Also note the <code class="literal">BeginDrawing()</code> method. It conveniently resets the <code class="literal">m_drawCalls</code> counter, which makes it easier to manage.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Integrating the Renderer class</h1></div></div></div><p>There is obviously no point in even having the <code class="literal">Renderer</code> class, if it is not going to be in its proper place or used at all. Since its only job is to draw things on screen with the correct effect being applied, a fitting place for it would be inside the <code class="literal">Window</code> class:</p><pre class="programlisting">class Window{ 
public: 
  ... 
  Renderer* GetRenderer(); 
  ... 
private: 
  ... 
  Renderer m_renderer; 
}; 
</pre><p>Because outside classes rely on it as well, it is a good idea to provide a getter method for easy retrieval of this object.</p><p>Actually integrating it into the rest of the code is surprisingly easy. A good place to start is giving the <code class="literal">Renderer</code> access to the <code class="literal">Window</code> class like so:</p><pre class="programlisting">Window::Window(...) : <strong>m_renderer(this, l_useShaders)</strong> { ... } 
</pre><p>The renderer also has <em>hooks</em> for knowing when we begin and end the drawing process. Luckily, the <code class="literal">Window</code> class already supports this idea, so it's really easy to tap into it:</p><pre class="programlisting">void Window::BeginDraw() { 
  m_window.clear(sf::Color::Black); 
  <strong>m_renderer.BeginDrawing();</strong> 
} 
void Window::EndDraw() { 
  m_window.display(); 
  <strong>m_renderer.EndDrawing();</strong> 
} 
</pre><p>Finally, in order to make use of the newest versions of OpenGL, the window needs to be instructed to create a version of the newest context available:</p><pre class="programlisting">void Window::Create() { 
  ... 
  sf::ContextSettings settings; 
  settings.depthBits = 24; 
  settings.stencilBits = 8; 
  settings.antialiasingLevel = 0; 
  <strong>settings.majorVersion = 4;</strong>
  <strong>settings.minorVersion = 5;</strong>
  m_window.create(sf::VideoMode(m_windowSize.x, m_windowSize.y, 
    32), m_windowTitle, style, <strong>settings</strong>); 
  if (!m_shadersLoaded) { 
    m_renderer.LoadShaders(); 
    m_shadersLoaded = true; 
  } 
} 
</pre><p>Note the shader loading bit at the end of this code snippet. The <code class="literal">Renderer</code> class is instructed to load the shaders available in the designated directory, provided shaders are being used in the first place. These several simple additions conclude the integration of the <code class="literal">Renderer</code> class.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Adapting existing classes</h2></div></div></div><p>Up until this point, rendering something on screen was as simple as passing it as a drawable object to a <code class="literal">Draw()</code> method of a <code class="literal">Window</code> class. While great for smaller projects, this is problematic for us, simply because that heavily handicaps any use of shaders. A good way to upgrade from there is to simply take in <code class="literal">Window</code> pointers:</p><pre class="programlisting">class ParticleSystem : ... { 
public: 
  ... 
  void Draw(<strong>Window* l_window</strong>, int l_elevation); 
}; 
 
class S_Renderer : ... { 
public: 
  ... 
  void Render(<strong>Window* l_wind</strong>, unsigned int l_layer); 
}; 
 
class SpriteSheet{ 
public: 
  ... 
  void Draw(<strong>Window* l_wnd</strong>); 
}; 
</pre><p>Let us go over each of these classes and see what needs to be changed in order to add proper support for shaders.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec7"/>Updating the ParticleSystem</h3></div></div></div><p>Going all the way back to <a class="link" href="ch03.html" title="Chapter 3.  Make It Rain! - Building a Particle System">Chapter 3
</a>, <em>Make it rain! - Building a particle system</em> we have already used a certain amount of shading trickery without even knowing it! The additive blending used for fire effects is a nice feature, and in order to preserve it without having to write a separate shader for it, we can simply use the <code class="literal">AdditiveBlend()</code> method of the <code class="literal">Renderer</code> class:</p><pre class="programlisting">void ParticleSystem::Draw(Window* l_window, int l_elevation) { 
  ... 
  auto state = m_stateManager-&gt;GetCurrentStateType(); 
  if (state == StateType::Game || state == StateType::MapEditor) { 
    renderer-&gt;UseShader("default"); 
  } else { 
    renderer-&gt;DisableShader(); 
  } 
 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    ... 
    renderer-&gt;AdditiveBlend(blendModes[i]); 
    renderer-&gt;Draw(drawables[i]); 
  } 
  renderer-&gt;AdditiveBlend(false); 
} 
</pre><p>First, note the check of the current application state. For now, we do not really need to use shaders inside any other states besides <code class="literal">Game</code> or <code class="literal">MapEditor</code>. Provided we are in one of them, the default shader is used. Otherwise, shading is disabled.</p><p>When dealing with actual particles, the <code class="literal">AdditiveBlend()</code> method is invoked with the blend mode flag being passed in as its argument, either enabling or disabling it. The particle drawable is then drawn on screen. After all of them have been processed, additive blending is turned off.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec8"/>Updating entity and map rendering</h3></div></div></div><p>The default shader is not only used when rendering particles. As it happens, we want to be able to apply unified shading, at least to some extent, to all world objects. Let us begin with entities:</p><pre class="programlisting">void S_Renderer::Render(Window* l_wind, unsigned int l_layer) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  <strong>l_wind-&gt;GetRenderer()-&gt;UseShader("default");</strong> 
  for(auto &amp;entity : m_entities) { 
    ... 
    <strong>drawable-&gt;Draw(l_wind);</strong> 
  } 
} 
 
void SpriteSheet::Draw(Window* l_wnd) { 
  l_wnd-&gt;GetRenderer()-&gt;Draw(m_sprite); 
} 
</pre><p>The only real changes to the rendering system are the invocation of the <code class="literal">UseShader()</code> method, and the fact that a pointer to the <code class="literal">Window</code> class is being passed down to the sprite-sheets <code class="literal">Draw()</code> call as an argument, instead of the usual <code class="literal">sf::RenderWindow</code>. The <code class="literal">SpriteSheet</code> class, in turn, is also modified to use the <code class="literal">Renderer</code> class, even though it does not actually interact with or modify shaders at all.</p><p>The game map should be shaded in exactly the same way as well:</p><pre class="programlisting">void Map::Draw(unsigned int l_layer) { 
  if (l_layer &gt;= Sheet::Num_Layers) { return; } 
  ... 
  m_window-&gt;GetRenderer()-&gt;UseShader("default"); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite); 
} 
</pre><p>The only real difference here is the fact that the <code class="literal">Map</code> class already has access to the <code class="literal">Window</code> class internally, so it does not have to be passed in as an argument.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Creating a day/night cycle</h1></div></div></div><p>Unifying the shading across many different world objects in our game gave us a very nice way of manipulating how the overall scene is actually represented. Many interesting effects are now possible, but we are going to focus on a rather simple yet effective one-lighting. The actual subtleties of the lighting subject will be covered in later chapters, but what we can do now is build a system that allows us to shade the world differently, based on the current time of the day, like so:</p><div><img src="img/image_06_002.jpg" alt="Creating a day/night cycle"/></div><p>As you can tell, this effect can add a lot to a game and make it feel very dynamic. Let us take a look at how it can be implemented.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Updating the Map class</h2></div></div></div><p>In order to accurately represent a day/night cycle, the game must keep a clock. Because it is relative to the world, the best place to keep track of this information is the <code class="literal">Map</code> class:</p><pre class="programlisting">class Map : ... { 
  ... 
protected: 
  ... 
  float m_gameTime; 
  float m_dayLength; 
}; 
</pre><p>For the sake of having dynamic and customizable code, two additional data members are stored: the current game time, and the overall length of the day. The latter allows the user to potentially create maps with a variable length of a day, which could offer some interesting opportunities for game designers.</p><p>Using these values is fairly simple:</p><pre class="programlisting">void Map::Update(float l_dT) { 
  m_gameTime += l_dT; 
  if (m_gameTime &gt; m_dayLength * 2) { m_gameTime = 0.f; } 
  float timeNormal = m_gameTime / m_dayLength; 
  if(timeNormal &gt; 1.f){ timeNormal = 2.f - timeNormal; } 
   m_window-&gt;GetRenderer()-&gt;GetShader("default")-&gt; 
    setUniform("timeNormal", timeNormal); 
} 
</pre><p>The actual game time is first manipulated by adding the frame time to it. It is then checked for having exceeded the boundaries of twice the value of the length of a day, in which case the game time is set back to <code class="literal">0.f</code>. This relationship represents a 1:1 proportion between the length of a day and the length of a night.</p><p>Finally, ensuring the light properly fades between day and night, a <code class="literal">timeNormal</code> local variable is established, and used to calculate the amount of darkness that should be cast over the scene. It is then checked for having exceeded the value of <code class="literal">1.f</code>, in which case it is adjusted to start moving back down, representing the fade from darkness to dawn. The value is then passed to the default shader.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>It is important to remember that shaders work with normalized values most of the time. This is why we are striving to provide it with a value between <code class="literal">0.f</code> to <code class="literal">1.f</code>.</p></div></div><p>The final piece of the puzzle is actually initializing our two additional data members to their default values:</p><pre class="programlisting">Map::Map(...) : ..., m_gameTime(0.f), m_dayLength(30.f) 
{ ... } 
</pre><p>As you can see, we have given the day length a value of <code class="literal">30.f</code>, which means the full day/night cycle will last a minute. This is obviously not going to be very useful for a game, but can come in handy when testing the shaders.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Writing the shaders</h2></div></div></div><p>With all of the <em>C++</em> code out of the way, we can finally focus on GLSL. Let us begin by implementing the default vertex shader:</p><pre class="programlisting">#version 450 
void main() 
{ 
  // transform the vertex position 
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; 
   
  // transform the texture coordinates 
  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; 
   
  // forward the vertex color 
  gl_FrontColor = gl_Color; 
} 
</pre><p>This is nothing different from the examples used during the introduction stage of this chapter. The purpose of adding the vertex shader now is simply to avoid having to write it again later, when something needs to be done in it. With that said, let us move on to the fragment shader:</p><pre class="programlisting">#version 450 
uniform sampler2D texture; 
uniform float timeNormal; 
 
void main() 
{ 
  // lookup the pixel in the texture 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  if(pixel == vec4(0.0, 0.0, 0.0, 1.0)) 
    pixel = vec4(1.0, 1.0, 1.0, 1.0); 
   
  // multiply it by the color 
  gl_FragColor = gl_Color * pixel; 
  gl_FragColor[0] -= timeNormal; 
  gl_FragColor[1] -= timeNormal; 
  gl_FragColor[2] -= timeNormal; 
  gl_FragColor[2] += 0.2; 
} 
</pre><div><div><h3 class="title"><a id="note16"/>Note</h3><p>The <code class="literal">sampler2D</code> type in this instance is simply the texture being passed into the shader by SFML. Other textures may also be passed into the shader manually, by using the <code class="literal">shader.setUniform("texture", &amp;texture);</code> call.</p></div></div><p>In order to properly draw a pixel, the fragment shader needs to sample the texture of the current object being drawn. If a simple shape is being drawn, the pixel being sampled from the texture is checked for being completely black. If that's the case, it's simply set to a white pixel. In addition to that, we also need the <code class="literal">timeNormal</code> value discussed earlier. After the current pixel of the texture has been sampled, it is multiplied by the colour passed in from the vertex shader and stored as <code class="literal">gl_FragColor</code>. The <code class="literal">timeNormal</code> value is then subtracted from all three colour channels. Finally, a slight tint of blue is added to the pixel in the end. This gives our scene a blue tint, and is purely an aesthetic choice.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Summary</h1></div></div></div><p>Many argue that graphics should be a secondary concern for a game developer. While it is clear that the visual side of a project should not be its primary concern, the visuals can serve a player more than simply acting as pretty backdrops. Graphical enhancements can even help tell a story better by making the player feel more engrossed in the environment, using clever visual cues, or simply controlling the overall mood and atmosphere. In this chapter, we have taken one of our first steps towards building a system that will serve as a massive helper when conquering the world of special effects.</p><p>In the next chapter, we will be delving deeper into the lower levels of graphical enhancements. See you there!</p></div></div></div></body></html>