<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 6. Adding Some Finishing Touches - Using Shaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/><span class="koboSpan" id="kobo.1.1">Chapter 6. Adding Some Finishing Touches - Using Shaders</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having good art is important for any game, as it greatly compliments the content game designers bring to the table. </span><span class="koboSpan" id="kobo.2.2">However, simply tacking on any and all graphics to some logic and calling it a day just does not cut it anymore. </span><span class="koboSpan" id="kobo.2.3">Good visual aesthetics of a game are now formed by hand-in-hand cooperation of amazing art and the proper post-processing that follows. </span><span class="koboSpan" id="kobo.2.4">Dealing with graphics as if they are paper cut-outs feels dated, while incorporating them in the dynamic universe of your game world and making sure they react to their surroundings by properly shading them has become the new standard. </span><span class="koboSpan" id="kobo.2.5">For a brief moment, let us put aside gameplay and discuss the technique of that special kind of post-processing, known as shading.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to be covering:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">The basics of the SFML shader class</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Implementing a unified way of drawing objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Adding a day-night cycle to the game</span></li></ul></div><p><span class="koboSpan" id="kobo.7.1">Let us get started with giving our project that extra graphical enhancement!</span></p><div class="section" title="Understanding shaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/><span class="koboSpan" id="kobo.8.1">Understanding shaders</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">In the modern world of computer graphics, many different calculations are offloaded to the GPU. </span><span class="koboSpan" id="kobo.9.2">Anything from simple pixel colour calculations, to complex lighting effects can and should be handled by hardware that is specifically designed for this purpose. </span><span class="koboSpan" id="kobo.9.3">This is where shaders come in.</span></p><p><span class="koboSpan" id="kobo.10.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">shader</span></strong></span><span class="koboSpan" id="kobo.12.1"> is a little program that runs on your graphics card instead of the CPU, and controls how each pixel of a shape is rendered. </span><span class="koboSpan" id="kobo.12.2">The main purpose of a shader, as the name suggests, is performing lighting and shading calculations, but they can be used for much more than that. </span><span class="koboSpan" id="kobo.12.3">Because of the power modern GPUs have, libraries exist that are designed to perform calculations on the GPU that would usually be executed on the CPU, in order to cut down the computation time significantly. </span><span class="koboSpan" id="kobo.12.4">Anything from physics computations to cracking password hashes can be done on the GPU, and the entry point to that horsepower is a shader.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/><span class="koboSpan" id="kobo.13.1">Tip</span></h3><p><span class="koboSpan" id="kobo.14.1">GPUs are good at performing tons of very specific calculations in parallel at once. </span><span class="koboSpan" id="kobo.14.2">Using less predictable or unparallel algorithms is very inefficient on the GPU, which is what the CPU excels at. </span><span class="koboSpan" id="kobo.14.3">However, as long as the data can be processed exactly the same in parallel, the task is deemed worthy of being pushed to the GPU for further handling.</span></p></div></div><p><span class="koboSpan" id="kobo.15.1">There are two main types of shader that SFML provides: </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">vertex</span></strong></span><span class="koboSpan" id="kobo.17.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">fragment</span></strong></span><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">Newer versions of SFML (</span><span class="emphasis"><em><span class="koboSpan" id="kobo.20.1">2.4.0</span></em></span><span class="koboSpan" id="kobo.21.1"> and up) have added support for geometry shaders as well, but it is not necessary to cover this for our purposes.</span></p><p><span class="koboSpan" id="kobo.22.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">vertex shader</span></strong></span><span class="koboSpan" id="kobo.24.1"> is executed once per vertex. </span><span class="koboSpan" id="kobo.24.2">This process is commonly referred to as </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">per-vertex</span></strong></span><span class="koboSpan" id="kobo.26.1"> shading. </span><span class="koboSpan" id="kobo.26.2">For example, any given triangle has three vertices. </span><span class="koboSpan" id="kobo.26.3">This means that the shader would be executed once for each vertex for a grand total of three times.</span></p><p><span class="koboSpan" id="kobo.27.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">fragment shader</span></strong></span><span class="koboSpan" id="kobo.29.1"> is executed once per pixel (otherwise known as a fragment), which results in the process being referred to as </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">per-pixel</span></strong></span><span class="koboSpan" id="kobo.31.1"> shading. </span><span class="koboSpan" id="kobo.31.2">This is much more taxing than simply performing per-vertex calculations, but is much more accurate and generally produces better visual results.</span></p><p><span class="koboSpan" id="kobo.32.1">Both types of shader can be used at once on a single piece of geometry being drawn, and can also communicate with each other.</span></p><div class="section" title="Shader examples"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/><span class="koboSpan" id="kobo.33.1">Shader examples</span></h2></div></div></div><p><span class="koboSpan" id="kobo.34.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">OpenGL Shading Language</span></strong></span><span class="koboSpan" id="kobo.36.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">GLSL</span></strong></span><span class="koboSpan" id="kobo.38.1">) is extremely similar to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.39.1">C</span></em></span><span class="koboSpan" id="kobo.40.1"> or </span><span class="emphasis"><em><span class="koboSpan" id="kobo.41.1">C++</span></em></span><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">It even uses the same basic syntax, as seen in this vertex shader example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">#version 450 
 
void main() 
{ 
    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix 
      * gl_Vertex; 
    gl_FrontColor = gl_Color; // Send colour to fragment shader. 
</span><span class="koboSpan" id="kobo.43.2">} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">Notice the version on the very first line. </span><span class="koboSpan" id="kobo.44.2">The number </span><code class="literal"><span class="koboSpan" id="kobo.45.1">450</span></code><span class="koboSpan" id="kobo.46.1"> indicates the version of OpenGL that should be used, in this case </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">4.5</span></em></span><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">Newer versions of SFML support OpenGL versions </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">3.3+</span></em></span><span class="koboSpan" id="kobo.50.1">; however the success of running it also depends on the capabilities of your graphics card.</span></p><p><span class="koboSpan" id="kobo.51.1">For now, simply ignore the first line of the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">main</span></code><span class="koboSpan" id="kobo.53.1"> function. </span><span class="koboSpan" id="kobo.53.2">It has to do with positions transformations from one coordinate system to another, and is specific to a few possible approaches to shading. </span><span class="koboSpan" id="kobo.53.3">These concepts will be covered in the next chapter.</span></p><p><span class="koboSpan" id="kobo.54.1">GLSL provides quite a few </span><span class="emphasis"><em><span class="koboSpan" id="kobo.55.1">hooks</span></em></span><span class="koboSpan" id="kobo.56.1"> that allow direct control of vertex and pixel information, such as </span><code class="literal"><span class="koboSpan" id="kobo.57.1">gl_Position</span></code><span class="koboSpan" id="kobo.58.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.59.1">gl_Color</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">The former is simply the position of the vertex that will be used in further calculations down the line, while the latter is the vertex colour, which is being assigned to </span><code class="literal"><span class="koboSpan" id="kobo.61.1">gl_FrontColor</span></code><span class="koboSpan" id="kobo.62.1">, ensuring the colour is passed down the pipeline to the fragment shader.</span></p><p><span class="koboSpan" id="kobo.63.1">Speaking of the fragment shader, here is a very minimal example of what it may look like:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.64.1">#version 450 
 
void main() 
{ 
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White pixel. 
</span><span class="koboSpan" id="kobo.64.2">} 
</span></pre><p><span class="koboSpan" id="kobo.65.1">In this particular case, </span><code class="literal"><span class="koboSpan" id="kobo.66.1">gl_FragColor</span></code><span class="koboSpan" id="kobo.67.1"> is used to set a static value of the pixel being rendered. </span><span class="koboSpan" id="kobo.67.2">Any shape being rendered while using this shader will come out white.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/><span class="koboSpan" id="kobo.68.1">Note</span></h3><p><span class="koboSpan" id="kobo.69.1">The values of this vector are normalized, meaning they have to fall in the range of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">0.f &lt; n &lt;= 1.0f</span></em></span><span class="koboSpan" id="kobo.71.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.72.1">Keep in mind that </span><code class="literal"><span class="koboSpan" id="kobo.73.1">gl_Color</span></code><span class="koboSpan" id="kobo.74.1"> can be used here to sample the colour that is passed down from the vertex shader. </span><span class="koboSpan" id="kobo.74.2">However, because there may be multiple pixels in between vertices, the colour for each fragment is interpolated. </span><span class="koboSpan" id="kobo.74.3">In a case where each vertex of a triangle is set to colours red, green, and blue, the interpolated result would look like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.75.1"><img src="graphics/image_06_001.jpg" alt="Shader examples"/></span></div><p><span class="koboSpan" id="kobo.76.1">One last thing to note about any shader is that they support communication from outside sources. </span><span class="koboSpan" id="kobo.76.2">This is done by using the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">uniform</span></code><span class="koboSpan" id="kobo.78.1"> keyword, followed by the variable type and capped off by its name like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.79.1">#version 450 
uniform float r; 
uniform float g; 
uniform float b; 
 
void main() 
{ 
    gl_FragColor = vec4(r, g, b, 1.0); 
} 
</span></pre><p><span class="koboSpan" id="kobo.80.1">In this particular example, outside code passes in three </span><code class="literal"><span class="koboSpan" id="kobo.81.1">float</span></code><span class="koboSpan" id="kobo.82.1"> that will be used as color values for the fragment. </span><span class="koboSpan" id="kobo.82.2">Uniforms are simply </span><span class="strong"><strong><span class="koboSpan" id="kobo.83.1">global</span></strong></span><span class="koboSpan" id="kobo.84.1"> variables that can be manipulated by outside code before a shader is used.</span></p></div><div class="section" title="SFML and shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/><span class="koboSpan" id="kobo.85.1">SFML and shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.86.1">Storing and using shaders in SFML is made simple by introducing the </span><code class="literal"><span class="koboSpan" id="kobo.87.1">sf::Shader</span></code><span class="koboSpan" id="kobo.88.1"> class. </span><span class="koboSpan" id="kobo.88.2">Although shaders are generally supported by most devices out there, it is still a good idea to perform a check that determines if the system the code is being executed on supports shaders as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.89.1">if(!sf::Shader::isAvailable()){ // Shaders not available! </span><span class="koboSpan" id="kobo.89.2">} 
</span></pre><p><span class="koboSpan" id="kobo.90.1">This shader class can hold either one of the two types of shader just by itself or a single instance of each type at the same time. </span><span class="koboSpan" id="kobo.90.2">Shaders can be loaded in one of two ways. </span><span class="koboSpan" id="kobo.90.3">The first is by simply reading a text file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.91.1">sf::Shader shader; // Create a shader instance. 
 
</span><span class="koboSpan" id="kobo.91.2">// Loading a single type of shader. 
</span><span class="koboSpan" id="kobo.91.3">if (!shader.loadFromFile("shader.vert", sf::Shader::Vertex)) { 
  // Failed loading. 
</span><span class="koboSpan" id="kobo.91.4">} 
// OR 
if (!shader.loadFromFile("shader.frag", sf::Shader::Fragment)) { 
  // Failed loading. 
</span><span class="koboSpan" id="kobo.91.5">} 
 
// load both shaders 
if (!shader.loadFromFile("shader.vert", "shader.frag")) { 
  // Failed loading. 
</span><span class="koboSpan" id="kobo.91.6">} 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/><span class="koboSpan" id="kobo.92.1">Note</span></h3><p><span class="koboSpan" id="kobo.93.1">File extensions of these shaders do not have to match the preceding ones. </span><span class="koboSpan" id="kobo.93.2">Because we are working with text files, the extension simply exists for clarity.</span></p></div></div><p><span class="koboSpan" id="kobo.94.1">The second way to load a shader is by parsing a string loaded in memory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.95.1">sf::Shader shader; 
const std::string code = "..."; 
// String that contains all shader code. 
</span></pre><pre class="programlisting"><span class="koboSpan" id="kobo.96.1">if (!shader.loadFromMemory(code, sf::Shader::Vertex)) { 
  // Failed loading. 
</span><span class="koboSpan" id="kobo.96.2">} 
</span></pre><p><span class="koboSpan" id="kobo.97.1">Using a shader is fairly straightforward as well. </span><span class="koboSpan" id="kobo.97.2">Its address simply needs to be passed in to a render targets </span><code class="literal"><span class="koboSpan" id="kobo.98.1">draw()</span></code><span class="koboSpan" id="kobo.99.1"> call as the second argument when something is being rendered to it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.100.1">window.draw(drawable, &amp;shader); 
</span></pre><p><span class="koboSpan" id="kobo.101.1">Since our shaders may need to be communicated with through </span><code class="literal"><span class="koboSpan" id="kobo.102.1">uniform</span></code><span class="koboSpan" id="kobo.103.1"> variables, there has to be a way to set them. </span><span class="koboSpan" id="kobo.103.2">Enter </span><code class="literal"><span class="koboSpan" id="kobo.104.1">sf::Shader::setUniform(...)</span></code><span class="koboSpan" id="kobo.105.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">shader.setUniform("r",  0.5f); 
</span></pre><p><span class="koboSpan" id="kobo.107.1">This simple bit of code manipulates the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">r</span></code><span class="koboSpan" id="kobo.109.1"> uniform inside whatever shader(s) happen to be loaded inside the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">shader</span></code><span class="koboSpan" id="kobo.111.1"> instance. </span><span class="koboSpan" id="kobo.111.2">The method itself supports many more types besides </span><span class="emphasis"><em><span class="koboSpan" id="kobo.112.1">float</span></em></span><span class="koboSpan" id="kobo.113.1">, which we will be covering in the next chapter.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Localizing rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/><span class="koboSpan" id="kobo.1.1">Localizing rendering</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Shading is a powerful concept. </span><span class="koboSpan" id="kobo.2.2">The only problem with injecting a stream of extra-graphical-fanciness to our game at this point is the fact that it is simply not architected to deal with using shaders efficiently. </span><span class="koboSpan" id="kobo.2.3">Most, if not all of our classes that do any kind of drawing do so by having direct access to the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">sf::RenderWindow</span></code><span class="koboSpan" id="kobo.4.1"> class, which means they would have to pass in their own shader instances as arguments. </span><span class="koboSpan" id="kobo.4.2">This is not efficient, re-usable, or flexible at all. </span><span class="koboSpan" id="kobo.4.3">A better approach, such as a separate class dedicated to rendering, is a necessity.</span></p><p><span class="koboSpan" id="kobo.5.1">In order to be able to switch from shader to shader with relative ease, we must work on storing them properly within the class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.6.1">using ShaderList = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;sf::Shader&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.7.1">Because the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">sf::Shader</span></code><span class="koboSpan" id="kobo.9.1"> class is a non-copyable object (inherits from </span><code class="literal"><span class="koboSpan" id="kobo.10.1">sf::NonCopyable</span></code><span class="koboSpan" id="kobo.11.1">), it is stored as a unique pointer, resulting in avoidance of any and all move semantics. </span><span class="koboSpan" id="kobo.11.2">This list of shaders is directly owned by the class that is going to do all of the rendering, so let us take a look at its definition:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">class Renderer { 
public: 
  Renderer(Window* l_window, bool l_useShaders = true); 
 
  void AdditiveBlend(bool l_flag); 
  bool UseShader(const std::string&amp; l_name); 
  void DisableShader(); 
  sf::Shader* GetShader(const std::string&amp; l_name); 
 
  void BeginDrawing(); 
  bool IsDrawing()const; 
  void Draw(const sf::Shape&amp; l_shape, 
    sf::RenderTarget* l_target = nullptr); 
  void Draw(const sf::Sprite&amp; l_sprite, 
    sf::RenderTarget* l_target = nullptr); 
  void Draw(const sf::Drawable&amp; l_drawable, 
    sf::RenderTarget* l_target = nullptr); 
  void EndDrawing(); 
private: 
  void LoadShaders(); 
 
  Window* m_window; 
  ShaderList m_shaders; 
  sf::Shader* m_currentShader; 
  bool m_addBlend; 
  bool m_drawing; 
  bool m_useShaders; 
  unsigned int m_drawCalls; // For debug purposes. 
</span><span class="koboSpan" id="kobo.12.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.13.1">Since shaders need to be passed in as arguments to the window </span><code class="literal"><span class="koboSpan" id="kobo.14.1">draw()</span></code><span class="koboSpan" id="kobo.15.1"> calls, it is obviously imperative for the renderer to have access to the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Window</span></code><span class="koboSpan" id="kobo.17.1"> class. </span><span class="koboSpan" id="kobo.17.2">In addition to that and the list of shaders that can be used at any given time, we also keep a pointer to the current shader being used in order to cut down on container access time, as well as a couple of flags that will be used when choosing the right shader to use, or determining whether the drawing is currently happening in the first place. </span><span class="koboSpan" id="kobo.17.3">Lastly, a fairly useful debug feature is having information about how many draw calls happen during each update. </span><span class="koboSpan" id="kobo.17.4">For this, a simple </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">unsigned integer </span></em></span><span class="koboSpan" id="kobo.19.1">is going to be used.</span></p><p><span class="koboSpan" id="kobo.20.1">The class itself provides the basic features of enabling/disabling additive blending instead of a regular shader, switching between all available shaders, and disabling the current shader, as well as obtaining it. </span><span class="koboSpan" id="kobo.20.2">The </span><code class="literal"><span class="koboSpan" id="kobo.21.1">BeginDrawing()</span></code><span class="koboSpan" id="kobo.22.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.23.1">EndDrawing()</span></code><span class="koboSpan" id="kobo.24.1"> methods are going to be used by the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Window</span></code><span class="koboSpan" id="kobo.26.1"> class in order to provide us with </span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">hooks</span></em></span><span class="koboSpan" id="kobo.28.1"> for obtaining information about the rendering process. </span><span class="koboSpan" id="kobo.28.2">Note the overloaded </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Draw()</span></code><span class="koboSpan" id="kobo.30.1"> method. </span><span class="koboSpan" id="kobo.30.2">It is designed to take in any drawable type and draw it on either the current window, or the appropriate render target that can be provided as the second argument.</span></p><p><span class="koboSpan" id="kobo.31.1">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">LoadShaders()</span></code><span class="koboSpan" id="kobo.33.1"> private method is going to be used during the initialization stage of the class. </span><span class="koboSpan" id="kobo.33.2">It holds all of the logic necessary to load every single shader inside the appropriate directory, and store them for later use.</span></p><div class="section" title="Implementing the renderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/><span class="koboSpan" id="kobo.34.1">Implementing the renderer</span></h2></div></div></div><p><span class="koboSpan" id="kobo.35.1">Let us begin by quickly going over the construction of the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">Renderer</span></code><span class="koboSpan" id="kobo.37.1"> object, and the initialization of all of its data members:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">Renderer::Renderer(Window* l_window, bool l_useShaders) 
  : m_window(l_window), m_useShaders(l_useShaders), 
     m_drawing(false), m_addBlend(false), m_drawCalls(0), 
  m_currentShader(nullptr) {} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">Once the pointer to the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">Window*</span></code><span class="koboSpan" id="kobo.41.1"> instance is safely stored, all of the data members of this class are initialized to their default values. </span><span class="koboSpan" id="kobo.41.2">The body of the constructor simply consists of a private method call, responsible for actually loading and storing all of the shader files:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void Renderer::LoadShaders() { 
  if(!m_useShaders) { return; } 
  auto directory = Utils::GetWorkingDirectory() +"media/Shaders/"; 
  auto v_shaders = Utils::GetFileList(directory, "*.vert", false); 
  auto f_shaders = Utils::GetFileList(directory, "*.frag", false); 
 
  for (auto&amp; shader : v_shaders) { 
    auto&amp; file = shader.first; 
    auto name = file.substr(0, file.find(".vert")); 
    auto fragShader = std::find_if( 
      f_shaders.begin(), f_shaders.end(), 
      [&amp;name](std::pair&lt;std::string, bool&gt;&amp; l_pair) { 
        return l_pair.first == name + ".frag"; 
      } 
    ); 
 
    auto shaderItr = m_shaders.emplace(name, 
      std::move(std::make_unique&lt;sf::Shader&gt;())); 
    auto&amp; shader = shaderItr.first-&gt;second; 
    if (fragShader != f_shaders.end()) { 
      shader-&gt;loadFromFile(directory + name + ".vert", 
        directory + name + ".frag"); 
      f_shaders.erase(fragShader); 
    } else { 
      shader-&gt;loadFromFile(directory + name + ".vert", 
        sf::Shader::Vertex); 
    } 
  } 
 
  for (auto&amp; shader : f_shaders) { 
    auto&amp; file = shader.first; 
    auto name = file.substr(0, file.find(".frag")); 
    auto shaderItr = m_shaders.emplace(name, 
      std::move(std::make_unique&lt;sf::Shader&gt;())); 
    auto&amp; shader = shaderItr.first-&gt;second; 
    shader-&gt;loadFromFile(directory + name + ".frag", 
      sf::Shader::Fragment); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">We begin by establishing a local variable that is going to hold the path to our </span><code class="literal"><span class="koboSpan" id="kobo.44.1">shader</span></code><span class="koboSpan" id="kobo.45.1"> directory. </span><span class="koboSpan" id="kobo.45.2">It is then used to obtain two lists of files with </span><code class="literal"><span class="koboSpan" id="kobo.46.1">.vert</span></code><span class="koboSpan" id="kobo.47.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.48.1">.frag</span></code><span class="koboSpan" id="kobo.49.1"> extensions respectively. </span><span class="koboSpan" id="kobo.49.2">These will be the vertex and fragment shaders to be loaded. </span><span class="koboSpan" id="kobo.49.3">The goal here is to group vertex and fragment shaders with identical names, and assign them to a single instance of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">sf::Shader</span></code><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">Any shaders that do not have a vertex or fragment counterpart will simply be loaded alone in a separate instance.</span></p><p><span class="koboSpan" id="kobo.52.1">Vertex shaders are as good a place as any to begin. </span><span class="koboSpan" id="kobo.52.2">After the filename is obtained and stripped of its extension, a fragment shader with the same name is attempted to be located. </span><span class="koboSpan" id="kobo.52.3">At the same time, a new </span><code class="literal"><span class="koboSpan" id="kobo.53.1">sf::Shader</span></code><span class="koboSpan" id="kobo.54.1"> instance is inserted into the shader container, and a reference to it is obtained. </span><span class="koboSpan" id="kobo.54.2">If a fragment counterpart has been found, both files are loaded into the shader. </span><span class="koboSpan" id="kobo.54.3">The fragment shader name is then removed from the list, as it will no longer need to be loaded in on its own.</span></p><p><span class="koboSpan" id="kobo.55.1">As the first part of the code does all of the pairing, all that is really left to do at this point is load the fragment shaders. </span><span class="koboSpan" id="kobo.55.2">It is safe to assume that anything on the fragment shader list is a standalone fragment shader, not associated with a vertex counterpart.</span></p><p><span class="koboSpan" id="kobo.56.1">Since shaders can have uniform variables that need to be initialized, it is important that outside classes have access to the shaders they use:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">sf::Shader* Renderer::GetShader(const std::string&amp; l_name) { 
  if(!m_useShaders) { return nullptr;  } 
  auto shader = m_shaders.find(l_name); 
  if (shader == m_shaders.end()) { return nullptr; } 
  return shader-&gt;second.get(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">If the shader with the provided name has not been located, </span><code class="literal"><span class="koboSpan" id="kobo.59.1">nullptr</span></code><span class="koboSpan" id="kobo.60.1"> is returned. </span><span class="koboSpan" id="kobo.60.2">On the other hand, a raw pointer to the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">sf::Shader*</span></code><span class="koboSpan" id="kobo.62.1"> instance is obtained from the smart pointer and returned instead.</span></p><p><span class="koboSpan" id="kobo.63.1">The same outside classes need to be able to instruct the </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Renderer</span></code><span class="koboSpan" id="kobo.65.1"> when a specific shader should be used. </span><span class="koboSpan" id="kobo.65.2">For this purpose, the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">UseShader()</span></code><span class="koboSpan" id="kobo.67.1"> method comes in handy:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.68.1">bool Renderer::UseShader(const std::string&amp; l_name) { 
  if(!m_useShaders) { return false; } 
  m_currentShader = GetShader(l_name); 
  return (m_currentShader != nullptr); 
} 
</span></pre><p><span class="koboSpan" id="kobo.69.1">Since the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">GetShader()</span></code><span class="koboSpan" id="kobo.71.1"> method already does the error-checking for us, it is used here as well. </span><span class="koboSpan" id="kobo.71.2">The value returned from it is stored as the pointer to the current shader, if any, and is then evaluated in order to return a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.72.1">boolean</span></em></span><span class="koboSpan" id="kobo.73.1"> value, signifying success/failure.</span></p><p><span class="koboSpan" id="kobo.74.1">The actual drawing of geometry is what we are all about here, so let us take a look at the overloaded </span><code class="literal"><span class="koboSpan" id="kobo.75.1">Draw()</span></code><span class="koboSpan" id="kobo.76.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.77.1">void Renderer::Draw(const sf::Shape&amp; l_shape, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { 
    if (</span><span class="strong"><strong><span class="koboSpan" id="kobo.78.1">!m_window-&gt;GetViewSpace().intersects( 
      l_shape.getGlobalBounds())</span></strong></span><span class="koboSpan" id="kobo.79.1">) 
    { return; } 
  } 
  Draw((const sf::Drawable&amp;)l_shape, l_target); 
} 
 
void Renderer::Draw(const sf::Sprite&amp; l_sprite, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { 
    if (</span><span class="strong"><strong><span class="koboSpan" id="kobo.80.1">!m_window-&gt;GetViewSpace().intersects( 
      l_sprite.getGlobalBounds())</span></strong></span><span class="koboSpan" id="kobo.81.1">) 
    { return; } 
  } 
  Draw((const sf::Drawable&amp;)l_sprite, l_target); 
} 
</span></pre><p><span class="koboSpan" id="kobo.82.1">Whether a </span><code class="literal"><span class="koboSpan" id="kobo.83.1">sf::Sprite</span></code><span class="koboSpan" id="kobo.84.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.85.1">sf::Shape</span></code><span class="koboSpan" id="kobo.86.1"> is being rendered, the actual idea behind this is exactly the same. </span><span class="koboSpan" id="kobo.86.2">First, we check if the intention behind the method call was indeed to render to the main window by looking at the </span><code class="literal"><span class="koboSpan" id="kobo.87.1">l_target</span></code><span class="koboSpan" id="kobo.88.1"> argument. </span><span class="koboSpan" id="kobo.88.2">If so, a fair thing to do here is to make sure the drawable object actually is on screen. </span><span class="koboSpan" id="kobo.88.3">It would be pointless to draw it if it was not. </span><span class="koboSpan" id="kobo.88.4">Provided the test passes, the main </span><code class="literal"><span class="koboSpan" id="kobo.89.1">Draw()</span></code><span class="koboSpan" id="kobo.90.1"> method overload is invoked, with the current arguments being passed down:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.91.1">void Renderer::Draw(const sf::Drawable&amp; l_drawable, 
  sf::RenderTarget* l_target) 
{ 
  if (!l_target) { l_target = m_window-&gt;GetRenderWindow(); } 
  l_target-&gt;draw(l_drawable, 
    (m_addBlend ? </span><span class="koboSpan" id="kobo.91.2">sf::BlendAdd : m_currentShader &amp;&amp; m_useShaders ? 
      </span><span class="koboSpan" id="kobo.91.3">m_currentShader : sf::RenderStates::Default)); 
  ++m_drawCalls; 
} 
</span></pre><p><span class="koboSpan" id="kobo.92.1">This is where all of the actual magic happens. </span><span class="koboSpan" id="kobo.92.2">The </span><code class="literal"><span class="koboSpan" id="kobo.93.1">l_target</span></code><span class="koboSpan" id="kobo.94.1"> argument is again checked for being equal to </span><code class="literal"><span class="koboSpan" id="kobo.95.1">nullptr</span></code><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">If it is, the render window is stored inside the argument pointer. </span><span class="koboSpan" id="kobo.96.3">Whatever the target, at this point its </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Draw()</span></code><span class="koboSpan" id="kobo.98.1"> method is invoked, with the drawable being passed in as the first argument, as well as the appropriate shader or blend mode passed in as the second. </span><span class="koboSpan" id="kobo.98.2">The additive blending obviously takes precedence here, enabling a quicker way of switching between using a shader and the additive blending modes by simply needing to use the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">AdditiveBlend()</span></code><span class="koboSpan" id="kobo.100.1"> method.</span></p><p><span class="koboSpan" id="kobo.101.1">Once the drawing is done, the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">m_drawCalls</span></code><span class="koboSpan" id="kobo.103.1"> data member is incremented, so that we can keep track of how many drawables have been rendered in total at the end of each cycle.</span></p><p><span class="koboSpan" id="kobo.104.1">Finally, we can wrap this class up by looking at a couple of essential yet basic setter/getter code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.105.1">void Renderer::AdditiveBlend(bool l_flag) { m_addBlend = l_flag; } 
void Renderer::DisableShader() { m_currentShader = nullptr; } 
void Renderer::BeginDrawing(){ m_drawing = true; m_drawCalls = 0;} 
bool Renderer::IsDrawing() const { return m_drawing; } 
void Renderer::EndDrawing() { m_drawing = false; } 
</span></pre><p><span class="koboSpan" id="kobo.106.1">As you can see, disabling the use of shaders for whatever is being drawn currently is as simple as setting the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">m_currentShader</span></code><span class="koboSpan" id="kobo.108.1"> data member to </span><code class="literal"><span class="koboSpan" id="kobo.109.1">nullptr</span></code><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Also note the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">BeginDrawing()</span></code><span class="koboSpan" id="kobo.112.1"> method. </span><span class="koboSpan" id="kobo.112.2">It conveniently resets the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">m_drawCalls</span></code><span class="koboSpan" id="kobo.114.1"> counter, which makes it easier to manage.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Integrating the Renderer class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/><span class="koboSpan" id="kobo.1.1">Integrating the Renderer class</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There is obviously no point in even having the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Renderer</span></code><span class="koboSpan" id="kobo.4.1"> class, if it is not going to be in its proper place or used at all. </span><span class="koboSpan" id="kobo.4.2">Since its only job is to draw things on screen with the correct effect being applied, a fitting place for it would be inside the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Window</span></code><span class="koboSpan" id="kobo.6.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class Window{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.7.2">Renderer* GetRenderer(); 
  ... 
</span><span class="koboSpan" id="kobo.7.3">private: 
  ... 
  </span><span class="koboSpan" id="kobo.7.4">Renderer m_renderer; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">Because outside classes rely on it as well, it is a good idea to provide a getter method for easy retrieval of this object.</span></p><p><span class="koboSpan" id="kobo.9.1">Actually integrating it into the rest of the code is surprisingly easy. </span><span class="koboSpan" id="kobo.9.2">A good place to start is giving the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Renderer</span></code><span class="koboSpan" id="kobo.11.1"> access to the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Window</span></code><span class="koboSpan" id="kobo.13.1"> class like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">Window::Window(...) : </span><span class="strong"><strong><span class="koboSpan" id="kobo.15.1">m_renderer(this, l_useShaders)</span></strong></span><span class="koboSpan" id="kobo.16.1"> { ... </span><span class="koboSpan" id="kobo.16.2">} 
</span></pre><p><span class="koboSpan" id="kobo.17.1">The renderer also has </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">hooks</span></em></span><span class="koboSpan" id="kobo.19.1"> for knowing when we begin and end the drawing process. </span><span class="koboSpan" id="kobo.19.2">Luckily, the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Window</span></code><span class="koboSpan" id="kobo.21.1"> class already supports this idea, so it's really easy to tap into it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void Window::BeginDraw() { 
  m_window.clear(sf::Color::Black); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">m_renderer.BeginDrawing();</span></strong></span><span class="koboSpan" id="kobo.24.1"> 
} 
void Window::EndDraw() { 
  m_window.display(); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">m_renderer.EndDrawing();</span></strong></span><span class="koboSpan" id="kobo.26.1"> 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">Finally, in order to make use of the newest versions of OpenGL, the window needs to be instructed to create a version of the newest context available:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">void Window::Create() { 
  ... 
  </span><span class="koboSpan" id="kobo.28.2">sf::ContextSettings settings; 
  settings.depthBits = 24; 
  settings.stencilBits = 8; 
  settings.antialiasingLevel = 0; 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">settings.majorVersion = 4;</span></strong></span>
  <span class="strong"><strong><span class="koboSpan" id="kobo.30.1">settings.minorVersion = 5;</span></strong></span><span class="koboSpan" id="kobo.31.1">
  m_window.create(sf::VideoMode(m_windowSize.x, m_windowSize.y, 
    32), m_windowTitle, style, </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">settings</span></strong></span><span class="koboSpan" id="kobo.33.1">); 
  if (!m_shadersLoaded) { 
    m_renderer.LoadShaders(); 
    m_shadersLoaded = true; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">Note the shader loading bit at the end of this code snippet. </span><span class="koboSpan" id="kobo.34.2">The </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Renderer</span></code><span class="koboSpan" id="kobo.36.1"> class is instructed to load the shaders available in the designated directory, provided shaders are being used in the first place. </span><span class="koboSpan" id="kobo.36.2">These several simple additions conclude the integration of the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Renderer</span></code><span class="koboSpan" id="kobo.38.1"> class.</span></p><div class="section" title="Adapting existing classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/><span class="koboSpan" id="kobo.39.1">Adapting existing classes</span></h2></div></div></div><p><span class="koboSpan" id="kobo.40.1">Up until this point, rendering something on screen was as simple as passing it as a drawable object to a </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Draw()</span></code><span class="koboSpan" id="kobo.42.1"> method of a </span><code class="literal"><span class="koboSpan" id="kobo.43.1">Window</span></code><span class="koboSpan" id="kobo.44.1"> class. </span><span class="koboSpan" id="kobo.44.2">While great for smaller projects, this is problematic for us, simply because that heavily handicaps any use of shaders. </span><span class="koboSpan" id="kobo.44.3">A good way to upgrade from there is to simply take in </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Window</span></code><span class="koboSpan" id="kobo.46.1"> pointers:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">class ParticleSystem : ... </span><span class="koboSpan" id="kobo.47.2">{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.47.3">void Draw(</span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">Window* l_window</span></strong></span><span class="koboSpan" id="kobo.49.1">, int l_elevation); 
}; 
 
class S_Renderer : ... </span><span class="koboSpan" id="kobo.49.2">{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.49.3">void Render(</span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">Window* l_wind</span></strong></span><span class="koboSpan" id="kobo.51.1">, unsigned int l_layer); 
}; 
 
class SpriteSheet{ 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.51.2">void Draw(</span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">Window* l_wnd</span></strong></span><span class="koboSpan" id="kobo.53.1">); 
}; 
</span></pre><p><span class="koboSpan" id="kobo.54.1">Let us go over each of these classes and see what needs to be changed in order to add proper support for shaders.</span></p><div class="section" title="Updating the ParticleSystem"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec7"/><span class="koboSpan" id="kobo.55.1">Updating the ParticleSystem</span></h3></div></div></div><p><span class="koboSpan" id="kobo.56.1">Going all the way back to </span><a class="link" href="ch03.html" title="Chapter 3.  Make It Rain! - Building a Particle System"><span class="koboSpan" id="kobo.57.1">Chapter 3
</span></a><span class="koboSpan" id="kobo.58.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.59.1">Make it rain! </span><span class="koboSpan" id="kobo.59.2">- Building a particle system</span></em></span><span class="koboSpan" id="kobo.60.1"> we have already used a certain amount of shading trickery without even knowing it! </span><span class="koboSpan" id="kobo.60.2">The additive blending used for fire effects is a nice feature, and in order to preserve it without having to write a separate shader for it, we can simply use the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">AdditiveBlend()</span></code><span class="koboSpan" id="kobo.62.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">Renderer</span></code><span class="koboSpan" id="kobo.64.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.65.1">void ParticleSystem::Draw(Window* l_window, int l_elevation) { 
  ... 
  </span><span class="koboSpan" id="kobo.65.2">auto state = m_stateManager-&gt;GetCurrentStateType(); 
  if (state == StateType::Game || state == StateType::MapEditor) { 
    renderer-&gt;UseShader("default"); 
  } else { 
    renderer-&gt;DisableShader(); 
  } 
 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    ... 
    </span><span class="koboSpan" id="kobo.65.3">renderer-&gt;AdditiveBlend(blendModes[i]); 
    renderer-&gt;Draw(drawables[i]); 
  } 
  renderer-&gt;AdditiveBlend(false); 
} 
</span></pre><p><span class="koboSpan" id="kobo.66.1">First, note the check of the current application state. </span><span class="koboSpan" id="kobo.66.2">For now, we do not really need to use shaders inside any other states besides </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Game</span></code><span class="koboSpan" id="kobo.68.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.69.1">MapEditor</span></code><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Provided we are in one of them, the default shader is used. </span><span class="koboSpan" id="kobo.70.3">Otherwise, shading is disabled.</span></p><p><span class="koboSpan" id="kobo.71.1">When dealing with actual particles, the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">AdditiveBlend()</span></code><span class="koboSpan" id="kobo.73.1"> method is invoked with the blend mode flag being passed in as its argument, either enabling or disabling it. </span><span class="koboSpan" id="kobo.73.2">The particle drawable is then drawn on screen. </span><span class="koboSpan" id="kobo.73.3">After all of them have been processed, additive blending is turned off.</span></p></div><div class="section" title="Updating entity and map rendering"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec8"/><span class="koboSpan" id="kobo.74.1">Updating entity and map rendering</span></h3></div></div></div><p><span class="koboSpan" id="kobo.75.1">The default shader is not only used when rendering particles. </span><span class="koboSpan" id="kobo.75.2">As it happens, we want to be able to apply unified shading, at least to some extent, to all world objects. </span><span class="koboSpan" id="kobo.75.3">Let us begin with entities:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.76.1">void S_Renderer::Render(Window* l_wind, unsigned int l_layer) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  </span><span class="strong"><strong><span class="koboSpan" id="kobo.77.1">l_wind-&gt;GetRenderer()-&gt;UseShader("default");</span></strong></span><span class="koboSpan" id="kobo.78.1"> 
  for(auto &amp;entity : m_entities) { 
    ... 
    </span><span class="strong"><strong><span class="koboSpan" id="kobo.79.1">drawable-&gt;Draw(l_wind);</span></strong></span><span class="koboSpan" id="kobo.80.1"> 
  } 
} 
 
void SpriteSheet::Draw(Window* l_wnd) { 
  l_wnd-&gt;GetRenderer()-&gt;Draw(m_sprite); 
} 
</span></pre><p><span class="koboSpan" id="kobo.81.1">The only real changes to the rendering system are the invocation of the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">UseShader()</span></code><span class="koboSpan" id="kobo.83.1"> method, and the fact that a pointer to the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">Window</span></code><span class="koboSpan" id="kobo.85.1"> class is being passed down to the sprite-sheets </span><code class="literal"><span class="koboSpan" id="kobo.86.1">Draw()</span></code><span class="koboSpan" id="kobo.87.1"> call as an argument, instead of the usual </span><code class="literal"><span class="koboSpan" id="kobo.88.1">sf::RenderWindow</span></code><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">The </span><code class="literal"><span class="koboSpan" id="kobo.90.1">SpriteSheet</span></code><span class="koboSpan" id="kobo.91.1"> class, in turn, is also modified to use the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">Renderer</span></code><span class="koboSpan" id="kobo.93.1"> class, even though it does not actually interact with or modify shaders at all.</span></p><p><span class="koboSpan" id="kobo.94.1">The game map should be shaded in exactly the same way as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.95.1">void Map::Draw(unsigned int l_layer) { 
  if (l_layer &gt;= Sheet::Num_Layers) { return; } 
  ... 
  </span><span class="koboSpan" id="kobo.95.2">m_window-&gt;GetRenderer()-&gt;UseShader("default"); 
  m_window-&gt;GetRenderer()-&gt;Draw(m_layerSprite); 
} 
</span></pre><p><span class="koboSpan" id="kobo.96.1">The only real difference here is the fact that the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Map</span></code><span class="koboSpan" id="kobo.98.1"> class already has access to the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Window</span></code><span class="koboSpan" id="kobo.100.1"> class internally, so it does not have to be passed in as an argument.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Creating a day/night cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/><span class="koboSpan" id="kobo.1.1">Creating a day/night cycle</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Unifying the shading across many different world objects in our game gave us a very nice way of manipulating how the overall scene is actually represented. </span><span class="koboSpan" id="kobo.2.2">Many interesting effects are now possible, but we are going to focus on a rather simple yet effective one-lighting. </span><span class="koboSpan" id="kobo.2.3">The actual subtleties of the lighting subject will be covered in later chapters, but what we can do now is build a system that allows us to shade the world differently, based on the current time of the day, like so:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.3.1"><img src="graphics/image_06_002.jpg" alt="Creating a day/night cycle"/></span></div><p><span class="koboSpan" id="kobo.4.1">As you can tell, this effect can add a lot to a game and make it feel very dynamic. </span><span class="koboSpan" id="kobo.4.2">Let us take a look at how it can be implemented.</span></p><div class="section" title="Updating the Map class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/><span class="koboSpan" id="kobo.5.1">Updating the Map class</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">In order to accurately represent a day/night cycle, the game must keep a clock. </span><span class="koboSpan" id="kobo.6.2">Because it is relative to the world, the best place to keep track of this information is the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Map</span></code><span class="koboSpan" id="kobo.8.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class Map : ... </span><span class="koboSpan" id="kobo.9.2">{ 
  ... 
</span><span class="koboSpan" id="kobo.9.3">protected: 
  ... 
  </span><span class="koboSpan" id="kobo.9.4">float m_gameTime; 
  float m_dayLength; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">For the sake of having dynamic and customizable code, two additional data members are stored: the current game time, and the overall length of the day. </span><span class="koboSpan" id="kobo.10.2">The latter allows the user to potentially create maps with a variable length of a day, which could offer some interesting opportunities for game designers.</span></p><p><span class="koboSpan" id="kobo.11.1">Using these values is fairly simple:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">void Map::Update(float l_dT) { 
  m_gameTime += l_dT; 
  if (m_gameTime &gt; m_dayLength * 2) { m_gameTime = 0.f; } 
  float timeNormal = m_gameTime / m_dayLength; 
  if(timeNormal &gt; 1.f){ timeNormal = 2.f - timeNormal; } 
   m_window-&gt;GetRenderer()-&gt;GetShader("default")-&gt; 
    setUniform("timeNormal", timeNormal); 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">The actual game time is first manipulated by adding the frame time to it. </span><span class="koboSpan" id="kobo.13.2">It is then checked for having exceeded the boundaries of twice the value of the length of a day, in which case the game time is set back to </span><code class="literal"><span class="koboSpan" id="kobo.14.1">0.f</span></code><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">This relationship represents a 1:1 proportion between the length of a day and the length of a night.</span></p><p><span class="koboSpan" id="kobo.16.1">Finally, ensuring the light properly fades between day and night, a </span><code class="literal"><span class="koboSpan" id="kobo.17.1">timeNormal</span></code><span class="koboSpan" id="kobo.18.1"> local variable is established, and used to calculate the amount of darkness that should be cast over the scene. </span><span class="koboSpan" id="kobo.18.2">It is then checked for having exceeded the value of </span><code class="literal"><span class="koboSpan" id="kobo.19.1">1.f</span></code><span class="koboSpan" id="kobo.20.1">, in which case it is adjusted to start moving back down, representing the fade from darkness to dawn. </span><span class="koboSpan" id="kobo.20.2">The value is then passed to the default shader.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/><span class="koboSpan" id="kobo.21.1">Note</span></h3><p><span class="koboSpan" id="kobo.22.1">It is important to remember that shaders work with normalized values most of the time. </span><span class="koboSpan" id="kobo.22.2">This is why we are striving to provide it with a value between </span><code class="literal"><span class="koboSpan" id="kobo.23.1">0.f</span></code><span class="koboSpan" id="kobo.24.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.25.1">1.f</span></code><span class="koboSpan" id="kobo.26.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.27.1">The final piece of the puzzle is actually initializing our two additional data members to their default values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">Map::Map(...) : ..., m_gameTime(0.f), m_dayLength(30.f) 
{ ... </span><span class="koboSpan" id="kobo.28.2">} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">As you can see, we have given the day length a value of </span><code class="literal"><span class="koboSpan" id="kobo.30.1">30.f</span></code><span class="koboSpan" id="kobo.31.1">, which means the full day/night cycle will last a minute. </span><span class="koboSpan" id="kobo.31.2">This is obviously not going to be very useful for a game, but can come in handy when testing the shaders.</span></p></div><div class="section" title="Writing the shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/><span class="koboSpan" id="kobo.32.1">Writing the shaders</span></h2></div></div></div><p><span class="koboSpan" id="kobo.33.1">With all of the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">C++</span></em></span><span class="koboSpan" id="kobo.35.1"> code out of the way, we can finally focus on GLSL. </span><span class="koboSpan" id="kobo.35.2">Let us begin by implementing the default vertex shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">#version 450 
void main() 
{ 
  // transform the vertex position 
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; 
   
  // transform the texture coordinates 
  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; 
   
  // forward the vertex color 
  gl_FrontColor = gl_Color; 
} 
</span></pre><p><span class="koboSpan" id="kobo.37.1">This is nothing different from the examples used during the introduction stage of this chapter. </span><span class="koboSpan" id="kobo.37.2">The purpose of adding the vertex shader now is simply to avoid having to write it again later, when something needs to be done in it. </span><span class="koboSpan" id="kobo.37.3">With that said, let us move on to the fragment shader:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">#version 450 
uniform sampler2D texture; 
uniform float timeNormal; 
 
void main() 
{ 
  // lookup the pixel in the texture 
  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); 
  if(pixel == vec4(0.0, 0.0, 0.0, 1.0)) 
    pixel = vec4(1.0, 1.0, 1.0, 1.0); 
   
  // multiply it by the color 
  gl_FragColor = gl_Color * pixel; 
  gl_FragColor[0] -= timeNormal; 
  gl_FragColor[1] -= timeNormal; 
  gl_FragColor[2] -= timeNormal; 
  gl_FragColor[2] += 0.2; 
} 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/><span class="koboSpan" id="kobo.39.1">Note</span></h3><p><span class="koboSpan" id="kobo.40.1">The </span><code class="literal"><span class="koboSpan" id="kobo.41.1">sampler2D</span></code><span class="koboSpan" id="kobo.42.1"> type in this instance is simply the texture being passed into the shader by SFML. </span><span class="koboSpan" id="kobo.42.2">Other textures may also be passed into the shader manually, by using the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">shader.setUniform("texture", &amp;texture);</span></code><span class="koboSpan" id="kobo.44.1"> call.</span></p></div></div><p><span class="koboSpan" id="kobo.45.1">In order to properly draw a pixel, the fragment shader needs to sample the texture of the current object being drawn. </span><span class="koboSpan" id="kobo.45.2">If a simple shape is being drawn, the pixel being sampled from the texture is checked for being completely black. </span><span class="koboSpan" id="kobo.45.3">If that's the case, it's simply set to a white pixel. </span><span class="koboSpan" id="kobo.45.4">In addition to that, we also need the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">timeNormal</span></code><span class="koboSpan" id="kobo.47.1"> value discussed earlier. </span><span class="koboSpan" id="kobo.47.2">After the current pixel of the texture has been sampled, it is multiplied by the colour passed in from the vertex shader and stored as </span><code class="literal"><span class="koboSpan" id="kobo.48.1">gl_FragColor</span></code><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">The </span><code class="literal"><span class="koboSpan" id="kobo.50.1">timeNormal</span></code><span class="koboSpan" id="kobo.51.1"> value is then subtracted from all three colour channels. </span><span class="koboSpan" id="kobo.51.2">Finally, a slight tint of blue is added to the pixel in the end. </span><span class="koboSpan" id="kobo.51.3">This gives our scene a blue tint, and is purely an aesthetic choice.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Many argue that graphics should be a secondary concern for a game developer. </span><span class="koboSpan" id="kobo.2.2">While it is clear that the visual side of a project should not be its primary concern, the visuals can serve a player more than simply acting as pretty backdrops. </span><span class="koboSpan" id="kobo.2.3">Graphical enhancements can even help tell a story better by making the player feel more engrossed in the environment, using clever visual cues, or simply controlling the overall mood and atmosphere. </span><span class="koboSpan" id="kobo.2.4">In this chapter, we have taken one of our first steps towards building a system that will serve as a massive helper when conquering the world of special effects.</span></p><p><span class="koboSpan" id="kobo.3.1">In the next chapter, we will be delving deeper into the lower levels of graphical enhancements. </span><span class="koboSpan" id="kobo.3.2">See you there!</span></p></div></div></div></body></html>