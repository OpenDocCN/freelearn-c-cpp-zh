["```cpp\n       #version 450 \n       layout( location = 0 ) in vec4 app_position; \n       layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n       }; \n\n       layout( location = 0 ) out vec3 vert_texcoord; \n\n       void main() { \n         vec3 position = mat3(ModelViewMatrix) * app_position.xyz; \n         gl_Position = (ProjectionMatrix * vec4( position, 0.0 )).xyzz; \n         vert_texcoord = app_position.xyz; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec3 vert_texcoord; \n       layout( set = 0, binding = 1 ) uniform samplerCube Cubemap; \n       layout( location = 0 ) out vec4 frag_color; \n\n       void main() { \n         frag_color = texture( Cubemap, vert_texcoord ); \n       }\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, CubemapImage ); \nInitVkDestroyer( LogicalDevice, CubemapImageMemory ); \nInitVkDestroyer( LogicalDevice, CubemapImageView ); \nInitVkDestroyer( LogicalDevice, CubemapSampler ); \nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { 1024, 1024, 1 }, 1, 6, \n  VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR, \n  VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, \n  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, \n  false, *CubemapSampler, *CubemapImage, *CubemapImageMemory, *CubemapImageView ) ) { \n  return false; \n} \nstd::vector<std::string> cubemap_images = { \n  \"Data/Textures/Skansen/posx.jpg\", \n  \"Data/Textures/Skansen/negx.jpg\", \n  \"Data/Textures/Skansen/posy.jpg\", \n  \"Data/Textures/Skansen/negy.jpg\", \n  \"Data/Textures/Skansen/posz.jpg\", \n  \"Data/Textures/Skansen/negz.jpg\" \n}; \nfor( size_t i = 0; i < cubemap_images.size(); ++i ) { \n  std::vector<unsigned char> cubemap_image_data; \n  int image_data_size; \n  if( !LoadTextureDataFromFile( cubemap_images[i].c_str(), 4, cubemap_image_data, nullptr, nullptr, nullptr, &image_data_size ) ) { \n    return false; \n  } \n  VkImageSubresourceLayers image_subresource = { \n    VK_IMAGE_ASPECT_COLOR_BIT, \n    0, \n    static_cast<uint32_t>(i), \n    1 \n  }; \n  UseStagingBufferToUpdateImageWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, image_data_size, &cubemap_image_data[0], \n    *CubemapImage, image_subresource, { 0, 0, 0 }, { 1024, 1024, 1 }, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, \n    0, VK_ACCESS_SHADER_READ_BIT, VK_IMAGE_ASPECT_COLOR_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ); \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n} \n\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n} \n\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \n\nImageDescriptorInfo image_descriptor_update = { \n  DescriptorSets[0], \n  1, \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  { \n    { \n      *CubemapSampler, \n      *CubemapImageView, \n      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, { image_descriptor_update }, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nvec3 position = mat3(ModelViewMatrix) * app_position.xyz; \ngl_Position = (ProjectionMatrix * vec4( position, 0.0 )).xyzz;\n\n```", "```cpp\nVkPipelineRasterizationStateCreateInfo rasterization_state_create_info; \nSpecifyPipelineRasterizationState( false, false, VK_POLYGON_MODE_FILL, VK_CULL_MODE_FRONT_BIT, VK_FRONT_FACE_COUNTER_CLOCKWISE, false, 0.0f, 1.0f, 0.0f, 1.0f, rasterization_state_create_info );\n\n```", "```cpp\nBindVertexBuffers( command_buffer, 0, { { *VertexBuffer, 0 } } ); \n\nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *PipelineLayout, 0, DescriptorSets, {} ); \n\nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *Pipeline ); \n\nfor( size_t i = 0; i < Skybox.Parts.size(); ++i ) { \n  DrawGeometry( command_buffer, Skybox.Parts[i].VertexCount, 1, Skybox.Parts[i].VertexOffset, 0 ); \n}\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec4 app_position; \n       layout( set = 0, binding = 0 ) uniform UniformBuffer { \n         mat4 ModelViewMatrix; \n         mat4 ProjectionMatrix; \n       }; \n\n       layout( push_constant ) uniform TimeState { \n        float Time; \n       } PushConstant; \n\n       void main() { \n         gl_Position = ModelViewMatrix * app_position; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( points ) in; \n       layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n       }; \n\n       layout( triangle_strip, max_vertices = 4 ) out; \n       layout( location = 0 ) out vec2 geom_texcoord; \n\n       const float SIZE = 0.1; \n\n       void main() { \n         vec4 position = gl_in[0].gl_Position; \n\n         gl_Position = ProjectionMatrix * (gl_in[0].gl_Position + vec4( \n         -SIZE, SIZE, 0.0, 0.0 )); \n         geom_texcoord = vec2( -1.0, 1.0 ); \n         EmitVertex(); \n\n         gl_Position = ProjectionMatrix * (gl_in[0].gl_Position + vec4( \n         -SIZE, -SIZE, 0.0, 0.0 )); \n         geom_texcoord = vec2( -1.0, -1.0 ); \n         EmitVertex(); \n\n         gl_Position = ProjectionMatrix * (gl_in[0].gl_Position + vec4( \n         SIZE, SIZE, 0.0, 0.0 )); \n         geom_texcoord = vec2( 1.0, 1.0 ); \n         EmitVertex(); \n\n         gl_Position = ProjectionMatrix * (gl_in[0].gl_Position + vec4( \n         SIZE, -SIZE, 0.0, 0.0 )); \n         geom_texcoord = vec2( 1.0, -1.0 ); \n         EmitVertex(); \n\n         EndPrimitive(); \n       }\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec2 geom_texcoord; \n       layout( location = 0 ) out vec4 frag_color; \n\n       void main() { \n         float alpha = 1.0 - dot( geom_texcoord, geom_texcoord ); \n         if( 0.2 > alpha ) { \n           discard; \n         } \n         frag_color = vec4( alpha ); \n       }\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_GEOMETRY_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n} \n\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n} \n\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, {}, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<VkVertexInputBindingDescription> vertex_input_binding_descriptions = { \n  { \n    0, \n    3 * sizeof( float ), \n    VK_VERTEX_INPUT_RATE_VERTEX \n  } \n}; \n\nstd::vector<VkVertexInputAttributeDescription> vertex_attribute_descriptions = { \n  { \n    0, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    0 \n  } \n}; \n\nVkPipelineVertexInputStateCreateInfo vertex_input_state_create_info; \nSpecifyPipelineVertexInputState( vertex_input_binding_descriptions, vertex_attribute_descriptions, vertex_input_state_create_info );\n\n```", "```cpp\nVkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info; \nSpecifyPipelineInputAssemblyState( VK_PRIMITIVE_TOPOLOGY_POINT_LIST, false, input_assembly_state_create_info );\n\n```", "```cpp\nvec4 position = gl_in[0].gl_Position; \n\ngl_Position = ProjectionMatrix * (gl_in[0].gl_Position + vec4( -SIZE, SIZE, 0.0, 0.0 )); \ngeom_texcoord = vec2( -1.0, 1.0 ); \nEmitVertex();\n\n```", "```cpp\nfloat alpha = 1.0 - dot( geom_texcoord, geom_texcoord ); \nif( 0.2 > alpha ) { \n  discard; \n}\n\n```", "```cpp\n       #version 450 \n       layout( local_size_x = 32, local_size_y = 32 ) in; \n       layout( set = 0, binding = 0, rgba32f ) uniform imageBuffer \n       StorageTexelBuffer; \n\n       layout( push_constant ) uniform TimeState { \n         float DeltaTime; \n       } PushConstant; \n\n       const uint PARTICLES_COUNT = 2000; \n\n       void main() { \n         if( gl_GlobalInvocationID.x < PARTICLES_COUNT ) { \n           vec4 position = imageLoad( StorageTexelBuffer, \n           int(gl_GlobalInvocationID.x * 2) ); \n           vec4 color = imageLoad( StorageTexelBuffer, \n           int(gl_GlobalInvocationID.x * 2 + 1) ); \n\n           vec3 speed = normalize( cross( vec3( 0.0, 1.0, 0.0 ), \n           position.xyz ) ) * color.w; \n\n           position.xyz += speed * PushConstant.DeltaTime; \n\n           imageStore( StorageTexelBuffer, int(gl_GlobalInvocationID.x \n           * \n           2), position ); \n         } \n       }\n\n```", "```cpp\nstd::vector<float> particles; \n\nfor( uint32_t i = 0; i < PARTICLES_COUNT; ++i ) { \n  Vector3 position = /* generate position */; \n  Vector3 color = /* generate color */; \n  float speed = /* generate speed scale */; \n  particles.insert( particles.end(), position.begin(), position.end() ); \n  particles.push_back( 1.0f ); \n  particles.insert( particles.end(), color.begin(), color.end() ); \n  particles.push_back( speed ); \n}\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, VertexBuffer ); \nInitVkDestroyer( LogicalDevice, VertexBufferMemory ); \nInitVkDestroyer( LogicalDevice, VertexBufferView ); \nif( !CreateStorageTexelBuffer( PhysicalDevice, *LogicalDevice, VK_FORMAT_R32G32B32A32_SFLOAT, sizeof( particles[0] ) * particles.size(), \n  VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, false, \n  *VertexBuffer, *VertexBufferMemory, *VertexBufferView ) ) { \n  return false; \n} \n\nif( !UseStagingBufferToUpdateBufferWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, sizeof( particles[0] ) * particles.size(), \n  &particles[0], *VertexBuffer, 0, 0, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, \n  GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_GEOMETRY_BIT, \n    nullptr \n  }, \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, \n    1, \n    VK_SHADER_STAGE_COMPUTE_BIT, \n    nullptr \n  } \n}; \n\nDescriptorSetLayout.resize( 2 ); \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout[0] ); \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout[1] ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, { descriptor_set_layout_bindings[0] }, *DescriptorSetLayout[0] ) ) { \n  return false; \n} \nif( !CreateDescriptorSetLayout( *LogicalDevice, { descriptor_set_layout_bindings[1] }, *DescriptorSetLayout[1] ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 2, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout[0], *DescriptorSetLayout[1] }, DescriptorSets ) ) { \n  return false; \n} \n\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \n\nTexelBufferDescriptorInfo storage_texel_buffer_descriptor_update = { \n  DescriptorSets[1], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, \n  { \n    { \n      *VertexBufferView \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, {}, { buffer_descriptor_update }, { storage_texel_buffer_descriptor_update }, {} );\n\n```", "```cpp\nstd::vector<unsigned char> compute_shader_spirv; \nif( !GetBinaryFileContents( \"Data/Shaders/Recipes/12 Advanced Rendering Techniques/03 Drawing particles using compute and graphics pipelines/shader.comp.spv\", compute_shader_spirv ) ) { \n  return false; \n} \n\nVkDestroyer<VkShaderModule> compute_shader_module( LogicalDevice ); \nif( !CreateShaderModule( *LogicalDevice, compute_shader_spirv, *compute_shader_module ) ) { \n  return false; \n} \nstd::vector<ShaderStageParameters> compute_shader_stage_params = { \n  { \n    VK_SHADER_STAGE_COMPUTE_BIT, \n    *compute_shader_module, \n    \"main\", \n    nullptr \n  } \n}; \nstd::vector<VkPipelineShaderStageCreateInfo> compute_shader_stage_create_infos; \nSpecifyPipelineShaderStages( compute_shader_stage_params, compute_shader_stage_create_infos ); \nVkPushConstantRange push_constant_range = { \n  VK_SHADER_STAGE_COMPUTE_BIT, \n  0, \n  sizeof( float ) \n}; \n\nInitVkDestroyer( LogicalDevice, ComputePipelineLayout ); \nif( !CreatePipelineLayout( *LogicalDevice, { *DescriptorSetLayout[1] }, { push_constant_range }, *ComputePipelineLayout ) ) { \n  return false; \n} \n\nInitVkDestroyer( LogicalDevice, ComputePipeline ); \nif( !CreateComputePipeline( *LogicalDevice, 0, compute_shader_stage_create_infos[0], *ComputePipelineLayout, VK_NULL_HANDLE, VK_NULL_HANDLE, *ComputePipeline ) ) { \n  return false; \n}\n\n```", "```cpp\nlayout( set = 0, binding = 0, rgba32f ) uniform imageBuffer StorageTexelBuffer;\n\n```", "```cpp\nvec4 position = imageLoad( StorageTexelBuffer, int(gl_GlobalInvocationID.x * 2) ); \nvec4 color = imageLoad( StorageTexelBuffer, int(gl_GlobalInvocationID.x * 2 + 1) );\n\n```", "```cpp\nimageStore( StorageTexelBuffer, int(gl_GlobalInvocationID.x * 2), position );\n\n```", "```cpp\nstd::vector<VkVertexInputBindingDescription> vertex_input_binding_descriptions = { \n  { \n    0,    VK_VERTEX_INPUT_RATE_VERTEX \n  } \n}; \n\nstd::vector<VkVertexInputAttributeDescription> vertex_attribute_descriptions = { \n  { \n    0, \n    0, \n    VK_FORMAT_R32G32B32A32_SFLOAT, \n    0 \n  }, \n  { \n    1, \n    0, \n    VK_FORMAT_R32G32B32A32_SFLOAT, \n    4 * sizeof( float ) \n  } \n}; \n\nVkPipelineVertexInputStateCreateInfo vertex_input_state_create_info; \nSpecifyPipelineVertexInputState( vertex_input_binding_descriptions, vertex_attribute_descriptions, vertex_input_state_create_info );\n\n```", "```cpp\nVkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info; \nSpecifyPipelineInputAssemblyState( VK_PRIMITIVE_TOPOLOGY_POINT_LIST, false, input_assembly_state_create_info );\n\n```", "```cpp\nstd::vector<VkPipelineColorBlendAttachmentState> attachment_blend_states = { \n  { \n    true, \n    VK_BLEND_FACTOR_SRC_ALPHA, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_OP_ADD, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_OP_ADD, \n    VK_COLOR_COMPONENT_R_BIT | \n    VK_COLOR_COMPONENT_G_BIT | \n    VK_COLOR_COMPONENT_B_BIT | \n    VK_COLOR_COMPONENT_A_BIT \n  } \n}; \nVkPipelineColorBlendStateCreateInfo blend_state_create_info; \nSpecifyPipelineBlendState( false, VK_LOGIC_OP_COPY, attachment_blend_states, { 1.0f, 1.0f, 1.0f, 1.0f }, blend_state_create_info );\n\n```", "```cpp\nif( !BeginCommandBufferRecordingOperation( ComputeCommandBuffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { \n  return false; \n} \n\nBindDescriptorSets( ComputeCommandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, *ComputePipelineLayout, 0, { DescriptorSets[1] }, {} ); \n\nBindPipelineObject( ComputeCommandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, *ComputePipeline ); \n\nfloat time = TimerState.GetDeltaTime(); \nProvideDataToShadersThroughPushConstants( ComputeCommandBuffer, *ComputePipelineLayout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof( float ), &time ); \n\nDispatchComputeWork( ComputeCommandBuffer, PARTICLES_COUNT / 32 + 1, 1, 1 ); \n\nif( !EndCommandBufferRecordingOperation( ComputeCommandBuffer ) ) { \n  return false; \n} \n\nif( !SubmitCommandBuffersToQueue( ComputeQueue.Handle, {}, { ComputeCommandBuffer }, { *ComputeSemaphore }, *ComputeFence ) ) { \n  return false; \n}\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec4 app_position; \n       layout( location = 1 ) in vec2 app_texcoord; \n       layout( location = 0 ) out vec2 vert_texcoord; \n\n       void main() { \n         gl_Position = app_position; \n         vert_texcoord = app_texcoord; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec2 vert_texcoord[]; \n       layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n       }; \n\n       layout( set = 0, binding = 1 ) uniform sampler2D ImageSampler; \n       layout( vertices = 3 ) out; \n       layout( location = 0 ) out vec2 tesc_texcoord[]; \n\n       void main() { \n         if( 0 == gl_InvocationID ) { \n           float distances[3]; \n           float factors[3]; \n\n           for( int i = 0; i < 3; ++i ) { \n             float height = texture( ImageSampler, vert_texcoord[i] \n             ).x; \n             vec4 position = ModelViewMatrix * (gl_in[i].gl_Position + \n             vec4( 0.0, height, 0.0, 0.0 )); \n             distances[i] = dot( position, position ); \n           } \n           factors[0] = min( distances[1], distances[2] ); \n           factors[1] = min( distances[2], distances[0] ); \n           factors[2] = min( distances[0], distances[1] ); \n\n           gl_TessLevelInner[0] = max( 1.0, 20.0 - factors[0] ); \n           gl_TessLevelOuter[0] = max( 1.0, 20.0 - factors[0] ); \n           gl_TessLevelOuter[1] = max( 1.0, 20.0 - factors[1] ); \n           gl_TessLevelOuter[2] = max( 1.0, 20.0 - factors[2] ); \n         } \n         gl_out[gl_InvocationID].gl_Position = \n         gl_in[gl_InvocationID].gl_Position; \n         tesc_texcoord[gl_InvocationID] = \n         vert_texcoord[gl_InvocationID]; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( triangles, fractional_even_spacing, cw ) in; \n       layout( location = 0 ) in vec2 tesc_texcoord[]; \n       layout( set = 0, binding = 1 ) uniform sampler2D HeightMap; \n       layout( location = 0 ) out float tese_height; \n       void main() { \n         vec4 position = gl_in[0].gl_Position * gl_TessCoord.x + \n                         gl_in[1].gl_Position * gl_TessCoord.y + \n                         gl_in[2].gl_Position * gl_TessCoord.z; \n         vec2 texcoord = tesc_texcoord[0] * gl_TessCoord.x + \n                         tesc_texcoord[1] * gl_TessCoord.y + \n                         tesc_texcoord[2] * gl_TessCoord.z; \n         float height = texture( HeightMap, texcoord ).x; \n         position.y += height; \n         gl_Position = position; \n         tese_height = height; \n       }\n\n```", "```cpp\n       #version 450 \n\n       layout( triangles ) in; \n       layout( location = 0 ) in float tese_height[]; \n\n       layout( set = 0, binding = 0 ) uniform UniformBuffer { \n         mat4 ModelViewMatrix; \n         mat4 ProjectionMatrix; \n       }; \n       layout( triangle_strip, max_vertices = 3 ) out; \n       layout( location = 0 ) out vec3  geom_normal; \n       layout( location = 1 ) out float geom_height; \n\n       void main() { \n         vec3 v0v1 = gl_in[1].gl_Position.xyz - \n         gl_in[0].gl_Position.xyz; \n         vec3 v0v2 = gl_in[2].gl_Position.xyz - \n         gl_in[0].gl_Position.xyz; \n         vec3 normal = normalize( cross( v0v1, v0v2 ) ); \n\n         for( int vertex = 0; vertex < 3; ++vertex ) { \n           gl_Position = ProjectionMatrix * ModelViewMatrix * \n           gl_in[vertex].gl_Position; \n           geom_height = tese_height[vertex]; \n           geom_normal = normal; \n           EmitVertex(); \n         } \n\n         EndPrimitive(); \n       }\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec3  geom_normal; \n       layout( location = 1 ) in float geom_height; \n       layout( location = 0 ) out vec4 frag_color; \n\n       void main() { \n         const vec4 green = vec4( 0.2, 0.5, 0.1, 1.0 ); \n         const vec4 brown = vec4( 0.6, 0.5, 0.3, 1.0 ); \n         const vec4 white = vec4( 1.0 ); \n         vec4 color = mix( green, brown, smoothstep( 0.0, 0.4, \n         geom_height ) ); \n         color = mix( color, white, smoothstep( 0.6, 0.9, geom_height ) \n         ); \n\n         float diffuse_light = max( 0.0, dot( geom_normal, vec3( 0.58, \n         0.58, 0.58 ) ) ); \n         frag_color = vec4( 0.05, 0.05, 0.0, 0.0 ) + diffuse_light * \n         color; \n       }\n\n```", "```cpp\nint width = 1; \nint height = 1; \nstd::vector<unsigned char> image_data; \nif( !LoadTextureDataFromFile( \"Data/Textures/heightmap.png\", 4, image_data, &width, &height ) ) { \n  return false; \n} \n\nInitVkDestroyer( LogicalDevice, HeightSampler ); \nInitVkDestroyer( LogicalDevice, HeightMap ); \nInitVkDestroyer( LogicalDevice, HeightMapMemory ); \nInitVkDestroyer( LogicalDevice, HeightMapView ); \nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { (uint32_t)width, (uint32_t)height, 1 }, \n  1, 1, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR, \n  VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, \n  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, \n  false, *HeightSampler, *HeightMap, *HeightMapMemory, *HeightMapView ) ) { \n  return false; \n} \n\nVkImageSubresourceLayers image_subresource_layer = { \n  VK_IMAGE_ASPECT_COLOR_BIT, \n  0, \n  0, \n  1 \n}; \nif( !UseStagingBufferToUpdateImageWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, static_cast<VkDeviceSize>(image_data.size()), \n&image_data[0], *HeightMap, image_subresource_layer, { 0, 0, 0 }, { (uint32_t)width, (uint32_t)height, 1 }, VK_IMAGE_LAYOUT_UNDEFINED, \nVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 0, VK_ACCESS_SHADER_READ_BIT, VK_IMAGE_ASPECT_COLOR_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \nVK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \nreturn false; \n}\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, UniformBuffer ); \nInitVkDestroyer( LogicalDevice, UniformBufferMemory ); \nif( !CreateUniformBuffer( PhysicalDevice, *LogicalDevice, 2 * 16 * sizeof( float ), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, \n  *UniformBuffer, *UniformBufferMemory ) ) { \n  return false; \n} \n\nif( !UpdateStagingBuffer( true ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_GEOMETRY_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n} \n\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    2 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n}\n\n```", "```cpp\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \n\nstd::vector<ImageDescriptorInfo> image_descriptor_updates = { \n  { \n    DescriptorSets[0], \n    1, \n    0, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    { \n      { \n        *HeightSampler, \n        *HeightMapView, \n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n      } \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, image_descriptor_updates, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<ShaderStageParameters> shader_stage_params = { \n  { \n    VK_SHADER_STAGE_VERTEX_BIT, \n    *vertex_shader_module, \n    \"main\", \n    nullptr \n  }, \n  { \n    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, \n    *tessellation_control_shader_module, \n    \"main\", \n    nullptr \n},\n  { \n    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, \n    *tessellation_evaluation_shader_module, \n    \"main\", \n    nullptr \n  }, \n  { \n    VK_SHADER_STAGE_GEOMETRY_BIT, \n    *geometry_shader_module, \n    \"main\", \n    nullptr \n  }, \n  { \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    *fragment_shader_module, \n    \"main\", \n    nullptr \n  } \n\n}; \n\nstd::vector<VkPipelineShaderStageCreateInfo> shader_stage_create_infos; \nSpecifyPipelineShaderStages( shader_stage_params, shader_stage_create_infos );\n\n```", "```cpp\nfloat distances[3]; \nfloat factors[3]; \n\nfor( int i = 0; i < 3; ++i ) { \n  float height = texture( ImageSampler, vert_texcoord[i] ).x; \n  vec4 position = ModelViewMatrix * (gl_in[i].gl_Position + vec4( 0.0, \n  height, 0.0, 0.0 )); \n  distances[i] = dot( position, position ); \n} \nfactors[0] = min( distances[1], distances[2] ); \nfactors[1] = min( distances[2], distances[0] ); \nfactors[2] = min( distances[0], distances[1] ); \n\ngl_TessLevelInner[0] = max( 1.0, 20.0 - factors[0] ); \ngl_TessLevelOuter[0] = max( 1.0, 20.0 - factors[0] ); \ngl_TessLevelOuter[1] = max( 1.0, 20.0 - factors[1] ); \ngl_TessLevelOuter[2] = max( 1.0, 20.0 - factors[2] );\n\n```", "```cpp\nvec4 position = gl_in[0].gl_Position * gl_TessCoord.x + \n                gl_in[1].gl_Position * gl_TessCoord.y + \n                gl_in[2].gl_Position * gl_TessCoord.z; \n\nvec2 texcoord = tesc_texcoord[0] * gl_TessCoord.x + \n                tesc_texcoord[1] * gl_TessCoord.y + \n                tesc_texcoord[2] * gl_TessCoord.z;\n\n```", "```cpp\nfloat height = texture( HeightMap, texcoord ).x; \nposition.y += height; \ngl_Position = position;\n\n```", "```cpp\nvec3 v0v1 = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz; \nvec3 v0v2 = gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz; \nvec3 normal = normalize( cross( v0v1, v0v2 ) );\n\n```", "```cpp\nfor( int vertex = 0; vertex < 3; ++vertex ) { \n  gl_Position = ProjectionMatrix * ModelViewMatrix * gl_in[vertex].gl_Position; \n  geom_height = tese_height[vertex]; \n  geom_normal = normal; \n  EmitVertex(); \n} \n\nEndPrimitive();\n\n```", "```cpp\nVkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info; \nSpecifyPipelineInputAssemblyState( VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, false, input_assembly_state_create_info ); \nVkPipelineTessellationStateCreateInfo tessellation_state_create_info; \nSpecifyPipelineTessellationState( 3, tessellation_state_create_info );\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec4 app_position; \n       void main() { \n         gl_Position = app_position; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( set = 0, binding = 0 ) uniform sampler2D Image; \n       layout( location = 0 ) out vec4 frag_color; \n       void main() { \n        vec4 color = vec4( 0.5 ); \n        color -= texture( Image, gl_FragCoord.xy + vec2( -1.0,  0.0 ) ); \n        color += texture( Image, gl_FragCoord.xy + vec2(  1.0,  0.0 ) ); \n\n        color -= texture( Image, gl_FragCoord.xy + vec2(  0.0, -1.0 ) ); \n        color += texture( Image, gl_FragCoord.xy + vec2(  0.0,  1.0 ) ); \n\n        frag_color = abs( 0.5 - color ); \n       }\n\n```", "```cpp\nstd::vector<float> vertices = { \n  -1.0f, -1.0f, 0.0f, \n  -1.0f,  1.0f, 0.0f, \n   1.0f, -1.0f, 0.0f, \n   1.0f,  1.0f, 0.0f, \n};\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, VertexBuffer ); \nif( !CreateBuffer( *LogicalDevice, sizeof( vertices[0] ) * vertices.size(), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, *VertexBuffer ) ) { \n  return false; \n} \n\nInitVkDestroyer( LogicalDevice, BufferMemory ); \nif( !AllocateAndBindMemoryObjectToBuffer( PhysicalDevice, *LogicalDevice, *VertexBuffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, *BufferMemory ) ) { \n  return false; \n} \n\nif( !UseStagingBufferToUpdateBufferWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, sizeof( vertices[0] ) * vertices.size(), &vertices[0], *VertexBuffer, 0, 0, \n  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \n  return false;\n\n```", "```cpp\nint width = 1; \nint height = 1; \nstd::vector<unsigned char> image_data; \nif( !LoadTextureDataFromFile( \"Data/Textures/sunset.jpg\", 4, image_data, &width, &height ) ) { \n  return false; \n} \n\nInitVkDestroyer( LogicalDevice, Sampler ); \nInitVkDestroyer( LogicalDevice, Image ); \nInitVkDestroyer( LogicalDevice, ImageMemory ); \nInitVkDestroyer( LogicalDevice, ImageView ); \nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { (uint32_t)width, (uint32_t)height, 1 }, \n  1, 1, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_NEAREST, \n  VK_FILTER_NEAREST, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, \n  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, true, \n  *Sampler, *Image, *ImageMemory, *ImageView ) ) { \n  return false; \n} \n\nVkImageSubresourceLayers image_subresource_layer = { \n  VK_IMAGE_ASPECT_COLOR_BIT, \n  0, \n  0, \n  1 \n}; \nif( !UseStagingBufferToUpdateImageWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, static_cast<VkDeviceSize>(image_data.size()), \n  &image_data[0], *Image, image_subresource_layer, { 0, 0, 0 }, { (uint32_t)width, (uint32_t)height, 1 }, VK_IMAGE_LAYOUT_UNDEFINED, \n  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 0, VK_ACCESS_SHADER_READ_BIT, VK_IMAGE_ASPECT_COLOR_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \n  return false; \n}\n\n```", "```cpp\nVkDescriptorSetLayoutBinding descriptor_set_layout_binding = { \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  1, \n  VK_SHADER_STAGE_FRAGMENT_BIT, \n  nullptr \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, { descriptor_set_layout_binding }, *DescriptorSetLayout ) ) { \n  return false; \n} \n\nVkDescriptorPoolSize descriptor_pool_size = { \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  1 \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, { descriptor_pool_size }, *DescriptorPool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n} \n\nImageDescriptorInfo image_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  { \n    { \n      *Sampler, \n      *ImageView, \n      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, { image_descriptor_update }, {}, {}, {} );\n\n```", "```cpp\nvec4 color = vec4( 0.5 ); \n\ncolor -= texture( Image, gl_FragCoord.xy + vec2( -1.0,  0.0 ) ); \ncolor += texture( Image, gl_FragCoord.xy + vec2(  1.0,  0.0 ) ); \n\ncolor -= texture( Image, gl_FragCoord.xy + vec2(  0.0, -1.0 ) ); \ncolor += texture( Image, gl_FragCoord.xy + vec2(  0.0,  1.0 ) ); \n\nfrag_color = abs( 0.5 - color );\n\n```", "```cpp\n       #version 450 \n       layout( location = 0 ) in vec4 app_position; \n       void main() { \n         gl_Position = app_position; \n       }\n\n```", "```cpp\n       #version 450 \n       layout( input_attachment_index = 0, set = 0, binding = 0 ) \n       uniform subpassInput InputAttachment; \n       layout( location = 0 ) out vec4 frag_color; \n\n       void main() { \n         vec4 color = subpassLoad( InputAttachment ); \n         float grey = dot( color.rgb, vec3( 0.2, 0.7, 0.1 ) ); \n         frag_color = grey * vec4( 1.5, 1.0, 0.5, 1.0 ); \n       }\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, SceneImage ); \nInitVkDestroyer( LogicalDevice, SceneImageMemory ); \nInitVkDestroyer( LogicalDevice, SceneImageView ); \nif( !CreateInputAttachment( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, Swapchain.Format, { Swapchain.Size.width, \nSwapchain.Size.height, 1 }, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, VK_IMAGE_VIEW_TYPE_2D, \nVK_IMAGE_ASPECT_COLOR_BIT, *SceneImage, *SceneImageMemory, *SceneImageView ) ) { \nreturn false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> scene_descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, PostprocessDescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, scene_descriptor_set_layout_bindings, *PostprocessDescriptorSetLayout ) ) { \n  return false; \n} \n\nstd::vector<VkDescriptorPoolSize> scene_descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, PostprocessDescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, scene_descriptor_pool_sizes, *PostprocessDescriptorPool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( *LogicalDevice, *PostprocessDescriptorPool, { *PostprocessDescriptorSetLayout }, PostprocessDescriptorSets ) ) { \n  return false; \n}\n\n```", "```cpp\nImageDescriptorInfo scene_image_descriptor_update = { \n  PostprocessDescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, \n  { \n    { \n      VK_NULL_HANDLE, \n      *SceneImageView, \n      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n    } \n  } \n}; \n\nUpdateDescriptorSets( *LogicalDevice, { scene_image_descriptor_update }, {}, {}, {} );\n\n```", "```cpp\nstd::vector<VkAttachmentDescription> attachment_descriptions = { \n  { \n    0, \n    Swapchain.Format, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n  }, \n  { \n    0, \n    DepthFormat, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL \n  }, \n  { \n    0, \n    Swapchain.Format, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \n  } \n};\n\n```", "```cpp\nVkAttachmentReference depth_attachment = { \n  1, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL \n}; \n\nstd::vector<SubpassParameters> subpass_parameters = { \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, \n      } \n    }, \n    {}, \n    &depth_attachment, \n    {} \n  }, \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, \n      } \n    }, \n    { \n      { \n        2, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, \n      } \n    }, \n    {}, \n    nullptr, \n    {} \n  } \n};\n\n```", "```cpp\nstd::vector<VkSubpassDependency> subpass_dependencies = { \n  { \n    0, \n    1, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  }, \n  { \n    VK_SUBPASS_EXTERNAL, \n    1, \n    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  }, \n  { \n    1, \n    VK_SUBPASS_EXTERNAL, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  } \n};\n\n```", "```cpp\nlayout( input_attachment_index = 0, set = 0, binding = 0 ) uniform subpassInput InputAttachment;\n\n```", "```cpp\nvec4 color = subpassLoad( InputAttachment );\n\n```"]