["```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"TreeNode.h\" \n#include \"Parser.h\" \n#include \"Cell.h\" \n#include \"CalcDocument.h\" \n\nvoid MainWindow(vector<String> /* argumentList */, \n                WindowShow windowShow) { \n  Application::ApplicationName() = TEXT(\"Calc\"); \n  Application::MainWindowPtr() = new CalcDocument(windowShow); \n} \n\n```", "```cpp\nclass CalcDocument : public StandardDocument { \n  public: \n    CalcDocument(WindowShow windowShow);       \n\n```", "```cpp\n    void OnMouseDown(MouseButton mouseButtons, Point mousePoint,\n                     bool shiftPressed, bool controlPressed);\n    void OnMouseMove(MouseButton mouseButtons, Point mousePoint,\n                     bool shiftPressed, bool controlPressed);\n    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint,\n                     bool shiftPressed, bool controlPressed);\n    void OnMouseUp(MouseButton mouseButtons, Point mousePoint,\n                     bool shiftPressed, bool controlPressed);\n\n```", "```cpp\n    virtual void OnHorizontalScroll(WORD flags, WORD x); \n    virtual void OnVerticalScroll(WORD flags, WORD y); \n\n```", "```cpp\n    enum ClickArea {ClickAll, ClickRow, ClickColumn, ClickCell}; \n\n```", "```cpp\n    ClickArea GetMouseLocation(Point mousePoint, \n                               Reference& cellRef) const; \n\n```", "```cpp\n    void MarkBlock(ClickArea clickArea, Reference newFirstMarkRef,\n                   Reference newLastMarkRef);\n\n```", "```cpp\n    void OnDraw(Graphics& graphics, DrawMode drawMode) const; \n    void UpdateCaret(); \n\n```", "```cpp\n    bool IsCellVisible(Reference cellRef) const; \n    void MakeCellVisible(); \n    void MakeCellVisible(Reference cellRect); \n\n```", "```cpp\n    bool ToMarkMode(); \n\n```", "```cpp\n    void Remark(Reference newFirstRef, Reference newLastRef); \n\n```", "```cpp\n    void OnChar(TCHAR tChar); \n\n```", "```cpp\n    bool OnKeyDown(WORD key, bool shiftPressed, \n                   bool controlPressed); \n    void OnLeftArrowKey(bool shiftPressed); \n    void OnRightArrowKey(bool shiftPressed); \n    void OnUpArrowKey(bool shiftPressed); \n    void OnDownArrowKey(bool shiftPressed); \n    void OnHomeKey(bool shiftPressed, bool controlPressed); \n    void OnEndKey(bool shiftPressed, bool controlPressed); \n\n```", "```cpp\n    void OnReturnKey(); \n    void OnTabulatorKey(bool shiftPressed); \n    void OnEscapeKey(); \n\n```", "```cpp\n    void OnDeleteKey(); \n    void OnBackspaceKey(); \n\n```", "```cpp\n    void ClearDocument(); \n    bool ReadDocumentFromStream(String name, istream& inStream); \n    bool WriteDocumentToStream(String name, ostream& outStream) \n                               const; \n\n```", "```cpp\n    static bool WriteSetMapToStream(const map<Reference, \n                     set<Reference>>& setMap, ostream& outStream); \n    static bool ReadSetMapFromStream(map<Reference,set<Reference>> \n                                     &setMap, istream& inStream); \n\n```", "```cpp\n    bool CopyEnable() const; \n    bool IsCopyAsciiReady() const {return true;} \n    bool IsCopyUnicodeReady() const {return true;} \n    bool IsCopyGenericReady(int format) const {return true;} \n\n```", "```cpp\n    void CopyAscii(vector<String>& textList) const; \n    void CopyUnicode(vector<String>& textList) const; \n    void CopyGeneric(int format, InfoList& infoList) const; \n\n```", "```cpp\n    bool IsPasteAsciiReady(const vector<String>& textList) const; \n    bool IsPasteUnicodeReady(const vector<String>& textList)const; \n    bool IsPasteGenericReady(int format, InfoList& infoList)const; \n\n```", "```cpp\n    void PasteAscii(const vector<String>& textList); \n    void PasteUnicode(const vector<String>& textList); \n    void PasteGeneric(int format, InfoList& infoList); \n\n```", "```cpp\n    bool DeleteEnable() const; \n    void OnDelete(); \n\n```", "```cpp\n    DEFINE_VOID_LISTENER(CalcDocument, OnFont); \n    DEFINE_VOID_LISTENER(CalcDocument, OnBackgroundColor); \n\n```", "```cpp\n    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalLeftRadio); \n    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalCenterRadio); \n    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalRightRadio); \n    DEFINE_BOOL_LISTENER(CalcDocument, HorizontalJustifiedRadio); \n\n    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalLeft); \n    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalCenter); \n    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalRight); \n    DEFINE_VOID_LISTENER(CalcDocument, OnHorizontalJustified); \n\n    bool IsHorizontalAlignment(Alignment alignment) const; \n    void SetHorizontalAlignment(Alignment alignment); \n\n    DEFINE_BOOL_LISTENER(CalcDocument, VerticalTopRadio); \n    DEFINE_BOOL_LISTENER(CalcDocument, VerticalCenterRadio); \n    DEFINE_BOOL_LISTENER(CalcDocument, VerticalBottomRadio); \n\n    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalTop); \n    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalCenter); \n    DEFINE_VOID_LISTENER(CalcDocument, OnVerticalBottom);     \n\n    bool IsVerticalAlignment(Alignment alignment) const; \n    void SetVerticalAlignment(Alignment alignment); \n\n```", "```cpp\n    bool InterpretEditCell(); \n    bool IsCircular(Reference cellRef, set<Reference>& targetSet); \n    void RemoveTargetSetMap(Reference cellRef); \n    void AddTargetSetMap(Reference cellRef, \n                         set<Reference>& newSourceSet); \n    void InvalidateCell(Reference cellRef); \n\n    void EvaluateRecursive(Reference cellRef, \n                           set<Reference>& invalidateSet); \n    void EvaluateCell(Reference cellRef); \n\n```", "```cpp\n  private: \n    enum CalcMode {Edit, Mark} calcMode = Mark; \n\n```", "```cpp\n    bool markOk; \n\n```", "```cpp\n    Reference firstMarkRef, lastMarkRef, editRef; \n\n```", "```cpp\n    int editIndex; \n\n```", "```cpp\n    Matrix<Rows,Cols,Cell> cellMatrix; \n\n```", "```cpp\n    map<Reference,set<Reference>> sourceSetMap, targetSetMap; \n\n```", "```cpp\n    static const unsigned int CalcFormat = 1003; \n\n```", "```cpp\n    Cell prevCell; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"TreeNode.h\" \n#include \"Parser.h\" \n#include \"Cell.h\" \n#include \"CalcDocument.h\" \n\n```", "```cpp\nCalcDocument::CalcDocument(WindowShow windowShow) \n :StandardDocument(LogicalWithoutScroll, USLetterPortrait, \n                   TEXT(\"Calc Files, clc; Text Files, txt\"), \n                   nullptr, OverlappedWindow, windowShow, \n                   {CalcFormat, UnicodeFormat, AsciiFormat}, \n                   {CalcFormat, UnicodeFormat, AsciiFormat}) { \n\n```", "```cpp\n  Menu menuBar(this); \n  menuBar.AddMenu(StandardFileMenu(false)); \n  menuBar.AddMenu(StandardEditMenu()); \n\n  Menu formatMenu(this, TEXT(\"F&ormat\")); \n  formatMenu.AddItem(TEXT(\"&Font ...\\tCtrl+F\"), OnFont); \n  formatMenu.AddItem(TEXT(\"&Background Color ...\\tCtrl+B\"), \n                     OnBackgroundColor); \n\n  Menu horizontalMenu(this, TEXT(\"&Horizontal Alignment\")); \n  horizontalMenu.AddItem(TEXT(\"&Left\"), OnHorizontalLeft, \n                         nullptr, nullptr, HorizontalLeftRadio); \n  horizontalMenu.AddItem(TEXT(\"&Center\"), OnHorizontalCenter, \n                         nullptr, nullptr, HorizontalCenterRadio); \n  horizontalMenu.AddItem(TEXT(\"&Right\"), OnHorizontalRight, \n                         nullptr, nullptr, HorizontalRightRadio); \n  horizontalMenu.AddItem(TEXT(\"&Justified\"),OnHorizontalJustified,                              \n                    nullptr, nullptr, HorizontalJustifiedRadio); \n  Menu verticalMenu(this, TEXT(\"&Vertical Alignment\")); \n  verticalMenu.AddItem(TEXT(\"&Top\"), OnVerticalTop, \n                       nullptr, nullptr, VerticalTopRadio); \n  verticalMenu.AddItem(TEXT(\"&Center\"), OnVerticalCenter, \n                       nullptr, nullptr, VerticalCenterRadio); \n\n  verticalMenu.AddItem(TEXT(\"&Bottom\"), OnVerticalBottom, \n                       nullptr, nullptr, VerticalBottomRadio); \n\n  formatMenu.AddMenu(horizontalMenu); \n  formatMenu.AddMenu(verticalMenu); \n  menuBar.AddMenu(formatMenu); \n\n  menuBar.AddMenu(StandardHelpMenu()); \n  SetMenuBar(menuBar); \n\n```", "```cpp\n  for (int row = 0; row < Rows; ++row) { \n    for (int col = 0; col < Cols; ++col) { \n      cellMatrix[Reference(row, col)].GenerateCaretList(this); \n    } \n  } \n\n```", "```cpp\nvoid CalcDocument::OnMouseDown(MouseButton mouseButtons, \n                   Point mousePoint, bool shiftPressed /*=false*/, \n                   bool controlPressed /* = false */) { \n  if ((calcMode == Mark) || ToMarkMode()) { \n    markOk = true; \n    Reference newFirstMarkRef; \n    ClickArea clickArea = \n      GetMouseLocation(mousePoint, newFirstMarkRef); \n    MarkBlock(clickArea, newFirstMarkRef, newFirstMarkRef); \n    UpdateCaret(); \n  } \n  else { \n    markOk = false; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnMouseMove(MouseButton mouseButtons, \n                   Point mousePoint, bool shiftPressed /*=false*/, \n                   bool controlPressed /* = false */) { \n  if ((mouseButtons == LeftButton) && markOk) { \n    Reference newLastMarkRef; \n    ClickArea clickArea = \n      GetMouseLocation(mousePoint, newLastMarkRef); \n    MarkBlock(clickArea, firstMarkRef, newLastMarkRef); \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnDoubleClick(MouseButton mouseButtons, \n                   Point mousePoint, bool shiftPressed /*=false*/, \n                   bool controlPressed /* = false */) { \n  if ((mouseButtons == LeftButton) && markOk) { \n    ClickArea clickArea = GetMouseLocation(mousePoint, editRef); \n\n    if (clickArea == ClickCell) { \n      calcMode = Edit; \n      Cell& editCell = cellMatrix[editRef]; \n      prevCell = editCell; \n      editCell.DisplayFormula(); \n      editIndex = editCell.MouseDown(mousePoint.X() % ColWidth); \n      InvalidateCell(editRef); \n      UpdateWindow(); \n      UpdateCaret(); \n    } \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnHorizontalScroll(WORD flags, WORD x) { \n  int col = x / ColWidth; \n  SetHorizontalScrollPosition(col * ColWidth); \n} \n\nvoid CalcDocument::OnVerticalScroll(WORD flags, WORD y) { \n  int row = y / RowHeight; \n  SetVerticalScrollPosition(row * RowHeight); \n} \n\n```", "```cpp\nCalcDocument::ClickArea CalcDocument::GetMouseLocation \n                        (Point mousePoint, Reference& cellRef) const { \n  if ((mousePoint.X() <= HeaderWidth) && \n      (mousePoint.Y() <= HeaderHeight)) { \n    return ClickAll; \n  } \n\n```", "```cpp\n  else if (mousePoint.X() <= HeaderWidth) { \n    mousePoint.Y() += GetVerticalScrollPosition() - HeaderHeight; \n    cellRef = Reference(min(Rows-1, mousePoint.Y()/RowHeight), 0); \n    return ClickRow; \n  } \n\n```", "```cpp\n  else if (mousePoint.Y() <= HeaderHeight) { \n    mousePoint.X() += GetHorizontalScrollPosition() - HeaderWidth; \n    cellRef = Reference(0, min(Cols - 1, \n                               mousePoint.X() / ColWidth)); \n    return ClickColumn; \n  } \n\n```", "```cpp\n  else { \n    mousePoint.X() += GetHorizontalScrollPosition() - HeaderWidth; \n    mousePoint.Y() += GetVerticalScrollPosition() - HeaderHeight; \n    cellRef = Reference(min(Rows - 1, mousePoint.Y() / RowHeight), \n                        min(Cols - 1, mousePoint.X() / ColWidth)); \n    return ClickCell; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::MarkBlock(ClickArea clickArea, \n         Reference newFirstMarkRef, Reference newLastMarkRef) { \n  switch (clickArea) { \n\n```", "```cpp\n    case ClickAll: \n      Remark(ZeroReference, Reference(Rows - 1, Cols - 1)); \n      break; \n\n```", "```cpp\n    case ClickRow: \n      Remark(Reference(newFirstMarkRef.Row(), 0), \n             Reference(newLastMarkRef.Row(), Cols - 1)); \n      break; \n\n```", "```cpp\n    case ClickColumn: \n      Remark(Reference(0, newFirstMarkRef.Col()), \n             Reference(Rows - 1, newLastMarkRef.Col())); \n      break; \n\n```", "```cpp\n    case ClickCell: \n      Remark(newFirstMarkRef, newLastMarkRef); \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnDraw(Graphics& graphics,\n                          DrawMode /* drawMode */) const {\n  int horizontalScroll = GetHorizontalScrollPosition(), \n      verticalScroll = GetVerticalScrollPosition(); \n\n```", "```cpp\n  int startRow = horizontalScroll / RowHeight, \n      startCol = verticalScroll / ColWidth; \n\n```", "```cpp\n  graphics.DrawRectangle(Rect(0, 0, HeaderWidth, HeaderHeight), \n                         Black); \n\n```", "```cpp\n  for (int col = startCol; col < Cols; ++col) { \n    int x = (col * ColWidth) - horizontalScroll + HeaderWidth; \n    Rect headerRect(x, 0, x + ColWidth, HeaderHeight); \n    graphics.DrawRectangle(Rect(x, 0, x + ColWidth, HeaderHeight), \n                           Black); \n    TCHAR buffer[] = {(TCHAR) (TEXT('A') + col), TEXT('\\0')}; \n    graphics.DrawText(headerRect, buffer, \n                      SystemFont, Black, White); \n  } \n\n```", "```cpp\n  for (int row = startRow; row < Rows; ++row) { \n    int y = (row * RowHeight) - verticalScroll + HeaderHeight; \n    Rect headerRect(0, y, HeaderWidth, y + RowHeight); \n    graphics.DrawRectangle(Rect(0, y, HeaderWidth, y + RowHeight), \n                           Black); \n    String buffer = to_String(row + 1); \n    graphics.DrawText(headerRect, buffer, \n                      SystemFont, Black, White); \n  } \n\n```", "```cpp\n  int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n      maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), \n      maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); \n\n```", "```cpp\n  for (int row = startRow; row < Rows; ++row) { \n    for (int col = startCol; col < Cols; ++col) { \n      bool edit = (calcMode == Edit) && \n                  (row == editRef.Row())&&(col == editRef.Col()); \n\n      bool mark = (calcMode == Mark) && \n                  (row >= minMarkRow) && (row <= maxMarkRow) && \n                  (col >= minMarkCol) && (col <= maxMarkCol); \n\n      Reference cellRef(row, col); \n      Cell cell = cellMatrix[cellRef]; \n      cell.DrawCell(graphics, cellRef, edit || mark); \n    } \n  } \n} \n\n```", "```cpp\nbool CalcDocument::IsCellVisible(Reference cellRef) const{ \n  int horizontalScrollPos = GetHorizontalScrollPosition(), \n      horizontalScrollPage = GetHorizontalScrollPageWidth(); \n  int firstVisibleRow = horizontalScrollPos / RowHeight; \n  int lastVisibleRow = firstVisibleRow + \n                       (horizontalScrollPage / RowHeight); \n\n  int verticalScrollPos = GetVerticalScrollPosition(), \n      verticalScrollPage = GetVerticalScrollPageHeight(); \n  int firstVisibleCol = verticalScrollPos / ColWidth; \n  int lastVisibleCol = firstVisibleCol + \n                       (verticalScrollPage / ColWidth); \n\n  int row = cellRef.Row(), col = cellRef.Col(); \n  return (row >= firstVisibleRow) && (row <= lastVisibleRow) && \n         (col >= firstVisibleCol) && (col <= lastVisibleCol); \n} \n\n```", "```cpp\nvoid CalcDocument::MakeCellVisible() { \n  switch (calcMode) { \n    case Edit: \n      MakeCellVisible(editRef); \n      break; \n\n    case Mark: \n      MakeCellVisible(lastMarkRef); \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::MakeCellVisible(Reference cellRef) { \n  Point topLeft(cellRef.Col() * ColWidth, \n                cellRef.Row() * RowHeight); \n  Rect cellRect(topLeft, Size(ColWidth, RowHeight)); \n  Size clientSize = GetClientSize(); \n\n```", "```cpp\n  if (clientSize.Width() < (HeaderWidth + Cols * ColWidth)) { \n    int left = GetHorizontalScrollPosition(), \n        xPage = GetHorizontalScrollPageWidth(); \n    int right = left + xPage - 1; \n\n```", "```cpp\n    if (cellRect.Left() < left) { \n      SetHorizontalScrollPosition(cellRect.Left()); \n      Invalidate(); \n      UpdateWindow(); \n    }  \n    if (cellRect.Right() > right) { \n      int distance = cellRect.Right() - right; \n      distance += ColWidth - distance % ColWidth; \n      SetHorizontalScrollPosition(left + distance); \n      Invalidate(); \n      UpdateWindow(); \n    } \n  } \n\n```", "```cpp\n  if (clientSize.Height() < (HeaderHeight + Rows * RowHeight)) { \n    int top = GetHorizontalScrollPosition(), \n        yPage = GetHorizontalScrollPageWidth(); \n    int bottom = top + yPage - 1; \n\n```", "```cpp\n    if (cellRect.Top() < top) { \n      SetVerticalScrollPosition(cellRect.Top()); \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    if (cellRect.Bottom() > bottom) { \n      int distance = cellRect.Bottom() - bottom; \n      distance += RowHeight - distance % RowHeight; \n      SetVerticalScrollPosition(top + distance); \n      Invalidate(); \n      UpdateWindow(); \n    } \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::UpdateCaret() { \n  if ((calcMode == Edit) && IsCellVisible(editRef)) { \n    Point topLeft(HeaderWidth + (editRef.Col() * ColWidth) + \n                  CellMargin, HeaderHeight + (editRef.Row() * \n                  RowHeight) + CellMargin); \n    Cell& editCell = cellMatrix[editRef]; \n    Rect caretRect = editCell.CaretList()[editIndex]; \n\n    if (GetKeyboardMode() == InsertKeyboard) { \n      caretRect.Right() = caretRect.Left() + 1; \n    } \n\n    SetCaret(topLeft + caretRect); \n  } \n  else { \n    ClearCaret(); \n  } \n} \n\n```", "```cpp\nbool CalcDocument::ToMarkMode() { \n  if (calcMode == Edit) { \n    if (InterpretEditCell()) { \n      calcMode = Mark; \n      firstMarkRef = editRef; \n      lastMarkRef = editRef; \n      return true; \n    } \n\n    return false; \n  } \n\n  return true; \n} \n\n```", "```cpp\nvoid CalcDocument::Remark(Reference newFirstRef, \n                          Reference newLastRef) { \n  Reference \n    minOldMarked(min(firstMarkRef.Row(), lastMarkRef.Row()), \n                 min(firstMarkRef.Col(), lastMarkRef.Col())), \n    maxOldMarked(max(firstMarkRef.Row(), lastMarkRef.Row()), \n                 max(firstMarkRef.Col(), lastMarkRef.Col())), \n    minNewMarked(min(newFirstRef.Row(), newLastRef.Row()), \n                 min(newFirstRef.Col(), newLastRef.Col())), \n    maxNewMarked(max(newFirstRef.Row(), newLastRef.Row()), \n                 max(newFirstRef.Col(), newLastRef.Col())); \n\n```", "```cpp\n  for (int row = minOldMarked.Row(); \n       row <= maxOldMarked.Row(); ++row) { \n    for (int col = minOldMarked.Col(); \n         col <= maxOldMarked.Col(); ++col) { \n      Reference cellRef(row, col); \n      if (!cellRef.Inside(minNewMarked, maxNewMarked)) { \n        InvalidateCell(cellRef); \n      } \n    } \n  } \n\n```", "```cpp\n  for (int row = minNewMarked.Row(); \n       row <= maxNewMarked.Row(); ++row) { \n    for (int col = minNewMarked.Col(); \n         col <= maxNewMarked.Col(); ++col) { \n      Reference cellRef(row, col); \n      if (!cellRef.Inside(minOldMarked, maxOldMarked)) { \n        InvalidateCell(Reference(row, col)); \n      } \n    } \n  } \n\n```", "```cpp\n  firstMarkRef = newFirstRef; \n  lastMarkRef = newLastRef; \n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid CalcDocument::OnChar(TCHAR tChar) { \n  if (calcMode == Mark) { \n    calcMode = Edit; \n    editRef = firstMarkRef; \n    Remark(editRef, editRef); \n    editIndex = 0; \n    Cell& editCell = cellMatrix[editRef]; \n    prevCell = *editCell; \n    editCell.Reset(); \n  } \n\n```", "```cpp\n  MakeCellVisible(editRef); \n  Cell& cell = cellMatrix[editRef]; \n  cell.CharDown(editIndex++, tChar, GetKeyboardMode()); \n  cell.GenerateCaretList(this); \n  InvalidateCell(editRef); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nbool CalcDocument::OnKeyDown(WORD key, bool shiftPressed, \n                             bool controlPressed) { \n  switch (key) { \n    case KeyLeft: \n      OnLeftArrowKey(shiftPressed); \n      break; \n\n    case KeyRight: \n      OnRightArrowKey(shiftPressed); \n      break; \n\n    case KeyUp: \n      OnUpArrowKey(shiftPressed); \n      break; \n\n    case KeyDown: \n      OnDownArrowKey(shiftPressed); \n      break; \n\n    case KeyHome: \n      OnHomeKey(shiftPressed, controlPressed); \n      break; \n\n    case KeyEnd: \n      OnEndKey(shiftPressed, controlPressed); \n      break; \n\n    case KeyReturn: \n      OnReturnKey(); \n      break; \n\n    case KeyTabulator: \n      OnTabulatorKey(shiftPressed); \n      break; \n\n    case KeyEscape: \n      OnEscapeKey(); \n      break; \n\n    case KeyDelete: \n      OnDeleteKey(); \n      break; \n\n    case KeyBackspace: \n      OnBackspaceKey(); \n      break; \n  } \n  UpdateCaret(); \n  UpdateWindow(); \n  return true; \n} \n\n```", "```cpp\nvoid CalcDocument::OnLeftArrowKey(bool shiftPressed) { \n  switch (calcMode) { \n    case Edit: { \n        MakeCellVisible(editRef); \n        if (editIndex > 0) { \n          --editIndex; \n        } \n      } \n      break; \n\n```", "```cpp\n    case Mark: \n      if (lastMarkRef.Col() > 0) { \n        if (!shiftPressed) { \n          Reference newLastMarkRef(lastMarkRef.Row(), \n                                   lastMarkRef.Col() - 1); \n          MakeCellVisible(newLastMarkRef); \n          Remark(newLastMarkRef, newLastMarkRef); \n        } \n\n```", "```cpp\n        else { \n          Reference newLastRefMark(lastMarkRef.Row(), \n                                   lastMarkRef.Col() - 1); \n          MakeCellVisible(newLastRefMark); \n          Remark(firstMarkRef, newLastRefMark); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnRightArrowKey(bool shiftPressed) { \n  switch (calcMode) { \n    case Edit: { \n        MakeCellVisible(editRef); \n\n        if (editIndex < \n            ((int) cellMatrix[editRef].GetText().length())) { \n          ++editIndex; \n        } \n      } \n      break; \n\n```", "```cpp\n    case Mark: \n      if (lastMarkRef.Col() < (Cols - 1)) { \n        if (!shiftPressed) { \n          Reference newLastMarkRef(lastMarkRef.Row(), \n                                   lastMarkRef.Col() + 1); \n          MakeCellVisible(newLastMarkRef); \n          Remark(newLastMarkRef, newLastMarkRef); \n        } \n\n```", "```cpp\n        else { \n          Reference newLastRefMark(lastMarkRef.Row(), \n                                   lastMarkRef.Col() + 1); \n          MakeCellVisible(newLastRefMark); \n          Remark(firstMarkRef, newLastRefMark); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnUpArrowKey(bool shiftPressed) { \n  switch (calcMode) { \n    case Edit: \n      break; \n\n```", "```cpp\n    case Mark: \n      if (lastMarkRef.Row() > 0) { \n        if (!shiftPressed) { \n          Reference newLastMarkRef(lastMarkRef.Row() - 1, \n                                   lastMarkRef.Col()); \n          MakeCellVisible(newLastMarkRef); \n          Remark(newLastMarkRef, newLastMarkRef); \n        } \n\n```", "```cpp\n        else { \n          Reference newLastRefMark(lastMarkRef.Row() - 1, \n                                   lastMarkRef.Col()); \n          MakeCellVisible(newLastRefMark); \n          Remark(firstMarkRef, newLastRefMark); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnDownArrowKey(bool shiftPressed) { \n  switch (calcMode) { \n    case Edit: \n      break; \n\n```", "```cpp\n    case Mark: \n      if (lastMarkRef.Row() < (Rows - 1)) { \n        if (!shiftPressed) { \n          Reference newMarkRef(lastMarkRef.Row() + 1, \n                               lastMarkRef.Col()); \n          MakeCellVisible(newMarkRef); \n          Remark(newMarkRef, newMarkRef); \n        } \n\n```", "```cpp\n        else { \n          Reference newLastRefMark(lastMarkRef.Row() + 1, \n                                   lastMarkRef.Col()); \n          MakeCellVisible(newLastRefMark); \n          Remark(firstMarkRef, newLastRefMark); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnHomeKey(bool shiftPressed, \n                             bool controlPressed) { \n  switch (calcMode) { \n    case Edit: { \n        MakeCellVisible(editRef); \n        editIndex = 0; \n        UpdateCaret(); \n      } \n      break; \n\n```", "```cpp\n    case Mark: \n      if (!shiftPressed && !controlPressed) { \n        Remark(Reference(firstMarkRef.Row(), 0), \n               Reference(firstMarkRef.Row(), 0)); \n        MakeCellVisible(firstMarkRef); \n      } \n      else if (shiftPressed && !controlPressed) { \n        Remark(firstMarkRef, Reference(firstMarkRef.Row(), 0)); \n        MakeCellVisible(lastMarkRef); \n      } \n\n```", "```cpp\n      else if (!shiftPressed && controlPressed) { \n        Remark(ZeroReference, ZeroReference); \n        MakeCellVisible(lastMarkRef); \n      } \n      else if (shiftPressed && controlPressed) { \n        Remark(firstMarkRef, ZeroReference); \n        MakeCellVisible(lastMarkRef); \n      } \n    break; \n    } \n} \n\n```", "```cpp\nvoid CalcDocument::OnEndKey(bool shiftPressed, bool controlPressed) { \n  switch (calcMode) { \n    case Edit: { \n        MakeCellVisible(editRef); \n        editIndex = cellMatrix[editRef].GetText().length(); \n        UpdateCaret(); \n      } \n      break; \n\n```", "```cpp\n    case Mark: \n      if (!shiftPressed && !controlPressed) { \n        Remark(Reference(firstMarkRef.Row(), Cols - 1), \n               Reference(firstMarkRef.Row(), Cols - 1)); \n        MakeCellVisible(firstMarkRef); \n      } \n      else if (shiftPressed && !controlPressed) { \n        Remark(firstMarkRef, \n               Reference(firstMarkRef.Row(), Cols - 1)); \n        MakeCellVisible(lastMarkRef); \n      } \n\n```", "```cpp\n      else if (!shiftPressed && controlPressed) { \n        Remark(Reference(Rows - 1, Cols - 1), \n               Reference(Rows - 1, Cols - 1)); \n        MakeCellVisible(lastMarkRef); \n      } \n      else if (shiftPressed && controlPressed) { \n        Remark(firstMarkRef, Reference(Rows - 1, Cols - 1)); \n        MakeCellVisible(lastMarkRef); \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnReturnKey() { \n  if ((calcMode == Mark) || ToMarkMode()) { \n    Reference newMarkedRef(min(firstMarkRef.Row() + 1, Rows - 1), \n                           firstMarkRef.Col()); \n    Remark(newMarkedRef, newMarkedRef); \n    MakeCellVisible(newMarkedRef); \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnTabulatorKey(bool shiftPressed) { \n  if ((calcMode == Mark) || ToMarkMode()) { \n    if (shiftPressed && (lastMarkRef.Col() > 0)) { \n      Reference firstMarkRef(lastMarkRef.Row(), \n                             firstMarkRef.Col() - 1); \n      Remark(firstMarkRef, firstMarkRef); \n      MakeCellVisible(firstMarkRef); \n    } \n\n    if (!shiftPressed && (lastMarkRef.Col() < (Cols - 1))) { \n      Reference firstMarkRef(firstMarkRef.Row(), \n                             firstMarkRef.Col() + 1); \n      Remark(firstMarkRef, firstMarkRef); \n      MakeCellVisible(firstMarkRef); \n    } \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnEscapeKey() { \n  if (calcMode == Edit) { \n    Cell& editCell = cellMatrix[editRef]; \n    editCell = prevCell; \n    InvalidateCell(editRef); \n    calcMode = Mark; \n    firstMarkRef = lastMarkRef = editRef; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnDeleteKey() { \n  switch (calcMode) { \n    case Edit: { \n      Cell& editCell = cellMatrix[editRef]; \n      String& cellText = editCell.GetText(); \n\n      if (editIndex < ((int) cellText.length())) { \n        String leftPart = cellText.substr(0, editIndex), \n               rightPart = cellText.substr(editIndex + 1); \n        editCell.SetText(leftPart + rightPart); \n        editCell.GenerateCaretList(this); \n        InvalidateCell(editRef); \n        UpdateWindow(); \n        SetDirty(true); \n      } \n    } \n    break; \n\n  case Mark: { \n      int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n          minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n          maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), \n          maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); \n\n      set<Reference> invalidateSet; \n      for (int row = minMarkRow; row <= minMarkRow; ++row) { \n        for (int col = minMarkCol; col <= minMarkCol; ++col) { \n          Reference cellRef = Reference(row, col); \n          cellMatrix[cellRef].Reset(); \n          EvaluateRecursive(editRef, invalidateSet); \n        } \n      }  \n      for (Reference cellRef : invalidateSet) { \n        InvalidateCell(cellRef); \n      }  \n      UpdateWindow(); \n      SetDirty(true); \n    } \n    break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnBackspaceKey() { \n  switch (calcMode) { \n    case Edit: \n      if (editIndex > 0) { \n        --editIndex; \n        OnDeleteKey(); \n      } \n      break; \n\n    case Mark: \n      OnDeleteKey(); \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::ClearDocument() { \n  for (int row = 0; row < Rows; ++row) { \n    for (int col = 0; col < Cols; ++col) { \n      cellMatrix[Reference(row, col)].Clear(); \n    } \n  } \n\n  sourceSetMap.clear(); \n  targetSetMap.clear(); \n\n  calcMode = Mark; \n  firstMarkRef.Clear(); \n  lastMarkRef.Clear(); \n} \n\n```", "```cpp\nvoid WriteCellToStream(Cell cell, ostream& outStream) { \n  cell.WriteCellToStream(outStream); \n} \n\nvoid ReadCellFromStream(Cell& cell, istream& inStream) { \n  cell.ReadCellFromStream(inStream); \n} \n\n```", "```cpp\nbool CalcDocument::WriteDocumentToStream(String name, \n                                         ostream& outStream)const{ \n  if (EndsWith(name, TEXT(\".clc\"))) { \n    outStream.write((char*) &calcMode, sizeof calcMode); \n    outStream.write((char*) &editIndex, sizeof editIndex); \n    editRef.WriteReferenceToStream(outStream); \n    firstMarkRef.WriteReferenceToStream(outStream); \n    lastMarkRef.WriteReferenceToStream(outStream); \n    prevCell.WriteCellToStream(outStream); \n    WriteSetMapToStream(sourceSetMap, outStream); \n    WriteSetMapToStream(targetSetMap, outStream); \n\n    for (int row = 0; row < Rows; ++row) { \n      for (int col = 0; col < Cols; ++col) { \n        cellMatrix[row][col].WriteCellToStream(outStream); \n      } \n    } \n  } \n  else if (EndsWith(name, TEXT(\".txt\"))) { \n    for (int row = 0; row < Rows; ++row) { \n      if (row > 0) { \n        outStream << \"\\n\"; \n      } \n\n      for (int col = 0; col < Cols; ++col) { \n        if (col > 0) { \n          outStream << \"\\t\"; \n        } \n\n        const Cell& cell = cellMatrix[row][col]; \n        String text = cell.IsFormula() \n                      ? (TEXT(\"=\") + cell.TreeToString()) \n                      : cell.GetText(); \n\n        for (TCHAR c : text) { \n          outStream << ((char) c); \n        } \n      } \n    } \n  } \n\n  return ((bool) outStream); \n} \n\n```", "```cpp\nbool CalcDocument::ReadDocumentFromStream(String name, \n                                          istream& inStream) { \n  if (EndsWith(name, TEXT(\".clc\")) && \n      ReadPrintSetupInfoFromStream(inStream)){ \n    inStream.read((char*)&calcMode, sizeof calcMode); \n    inStream.read((char*) &editIndex, sizeof editIndex); \n    editRef.ReadReferenceFromStream(inStream); \n    firstMarkRef.ReadReferenceFromStream(inStream); \n    lastMarkRef.ReadReferenceFromStream(inStream); \n    prevCell.ReadCellFromStream(inStream); \n    ReadSetMapFromStream(sourceSetMap, inStream); \n    ReadSetMapFromStream(targetSetMap, inStream); \n    MakeCellVisible(); \n\n    for (int row = 0; row < Rows; ++row) { \n      for (int col = 0; col < Cols; ++col) { \n        cellMatrix[Reference(row, col)]. \n            ReadCellFromStream(inStream); \n      } \n    } \n  }   \n\n  else if (EndsWith(name, TEXT(\".txt\"))) { \n    String text; \n    int row = 0, col = 0; \n\n    while (inStream) { \n      char c; \n      inStream.read(&c, sizeof c); \n\n      if (inStream) { \n        switch (c) { \n          case ';': \n            cellMatrix[Reference(row, col++)].SetText(text); \n            text.clear(); \n            break; \n\n          case '\\n': \n            cellMatrix[Reference(row++, col)].SetText(text); \n            text.clear(); \n            col = 0; \n            break; \n\n          default: \n            text.push_back((TCHAR) c); \n            break; \n        } \n      } \n    } \n  } \n\n  return ((bool) inStream); \n} \n\n```", "```cpp\nbool CalcDocument::WriteSetMapToStream(const \n                   map<Reference,set<Reference>>& setMap, \n                   ostream& outStream) { \n  int mapSize = setMap.size(); \n  outStream.write((char*) &mapSize, sizeof mapSize); \n\n  for (pair<Reference,set<Reference>> entry : setMap) { \n    Reference cellRef = entry.first; \n    cellRef.WriteReferenceToStream(outStream); \n\n    set<Reference> set = entry.second; \n    int setSize = set.size(); \n    outStream.write((char*) &setSize, sizeof setSize); \n\n    for (Reference ref : set) { \n      ref.WriteReferenceToStream(outStream); \n    } \n  } \n\n  return ((bool) outStream); \n} \n\nbool CalcDocument::ReadSetMapFromStream \n                   (map<Reference,set<Reference>>& setMap, \n                    istream& inStream) { \n  int mapSize; \n  inStream.read((char*) &mapSize, sizeof mapSize); \n\n  for (int mapIndex = 0; mapIndex < mapSize; ++mapIndex) { \n    Reference cellRef; \n    cellRef.ReadReferenceFromStream(inStream); \n\n    int setSize; \n    inStream.read((char*) &setSize, sizeof setSize); \n\n    set<Reference> set; \n    for (int setIndex = 0; setIndex < setSize; ++setIndex) { \n      Reference ref; \n      ref.ReadReferenceFromStream(inStream); \n      set.insert(ref); \n    } \n\n    setMap[cellRef] = set; \n  } \n\n  return ((bool) inStream); \n} \n\n```", "```cpp\nbool CalcDocument::CopyEnable() const { \n  return (calcMode == Mark); \n} \n\n```", "```cpp\nvoid CalcDocument::CopyAscii(vector<String>& textList) const { \n  CopyUnicode(textList); \n} \n\nvoid CalcDocument::CopyUnicode(vector<String>& textList) const { \n  int minMarkRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      maxMarkRow = max(firstMarkRef.Row(), lastMarkRef.Row()), \n      minMarkCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n      maxMarkCol = max(firstMarkRef.Col(), lastMarkRef.Col()); \n\n  for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n    String text; \n\n    for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n      Reference markRef = Reference(row, col); \n      const Cell& markCell = cellMatrix[markRef]; \n      text.append(((col > 0) ? TEXT(\";\") : TEXT(\"\")) + \n                  markCell.TreeToString()); \n    } \n\n    textList.push_back(text); \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::CopyGeneric(int /* format */, \n                               InfoList& infoList) const { \n  int minRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      minCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n      copyRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) + 1, \n      copyCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) + 1; \n\n  infoList.AddValue<int>(copyRows); \n  infoList.AddValue<int>(copyCols); \n  infoList.AddValue<int>(minRow); \n  infoList.AddValue<int>(minCol); \n\n  for (int row = 0; row < copyRows; ++row) { \n    for (int col = 0; col < copyCols; ++col) { \n      Reference sourceRef(minRow + row, minCol + col); \n      const Cell& cell = cellMatrix[sourceRef]; \n      cell.WriteCellToClipboard(infoList); \n    } \n  } \n} \n\n```", "```cpp\nbool CalcDocument::IsPasteAsciiReady \n                   (const vector<String>& textList) const { \n  return IsPasteUnicodeReady(textList); \n}  \nbool CalcDocument::IsPasteUnicodeReady \n                   (const vector<String>& textList) const { \n  int markedRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) +1, \n      markedCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) +1, \n      minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col());  \n  if ((markedRows == 1) && (markedCols == 1)) { \n    int copyRows = textList.size(); \n    int maxCopyCols = 0;  \n    for (String text : textList) { \n      maxCopyCols = max(maxCopyCols, \n                        ((int) Split(text, ';').size())); \n    }  \n    return ((minMarkedRow + copyRows) < Rows) && \n           ((minMarkedCol + maxCopyCols) < Cols); \n  } \n  else { \n    if (textList.size() != markedRows) { \n      return false; \n    }  \n    for (String text : textList) { \n      if (((int) Split(text, ';').size()) != markedCols) { \n        return false; \n      } \n    }  \n    return true; \n  } \n} \n\n```", "```cpp\nbool CalcDocument::IsPasteGenericReady(int /* format */, \n                                     InfoList& infoList) const { \n  int markedRows = abs(firstMarkRef.Row() - lastMarkRef.Row()) +1, \n      markedCols = abs(firstMarkRef.Col() - lastMarkRef.Col()) +1, \n      minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n      copyRows, copyCols; \n\n  infoList.PeekValue<int>(copyRows, 0); \n  infoList.PeekValue<int>(copyCols, sizeof(int)); \n\n  return (((markedRows == copyRows)&&(markedCols == copyCols)) || \n          ((markedRows == 1) && (markedCols == 1))) && \n         ((minMarkedRow + copyRows) <= Rows) && \n         ((minMarkedCol + copyCols) <= Cols); \n} \n\n```", "```cpp\nvoid CalcDocument::PasteAscii(const vector<String>& textList) { \n  PasteUnicode(textList); \n} \n\nvoid CalcDocument::PasteUnicode(const vector<String>& textList) { \n  Matrix<Rows,Cols,Cell> backupMatrix = \n    Matrix<Rows,Cols,Cell>(cellMatrix); \n  map<Reference,set<Reference>> backupSourceSetMap = sourceSetMap, \n                                backupTargetSetMap = targetSetMap; \n\n  try { \n    set<Reference> invalidateSet; \n    int row = min(firstMarkRef.Row(), lastMarkRef.Row()), \n        minCol = min(firstMarkRef.Col(), lastMarkRef.Col()); \n    Reference diffRef(row, minCol); \n\n    for (String rowText : textList) { \n      int col = minCol; \n      vector<String> columnList = Split(rowText, ';'); \n\n```", "```cpp\n      for (String colText : columnList) { \n        Reference targetRef(row, col++); \n        RemoveTargetSetMap(targetRef); \n        Cell& targetCell = cellMatrix[targetRef]; \n        targetCell.Reset(); \n        targetCell.SetText(colText) \n        set<Reference> sourceSet; \n        targetCell.InterpretCell(sourceSet); \n        targetCell.GenerateCaretList(this); \n\n```", "```cpp\n        if (!diffRef.IsEmpty()) { \n          sourceSet.clear(); \n          targetCell.UpdateTree(diffRef, sourceSet); \n        } \n\n```", "```cpp\n        AddTargetSetMap(targetRef, sourceSet); \n        sourceSetMap[targetRef] = sourceSet; \n        EvaluateRecursive(targetRef, invalidateSet); \n        targetCell.GenerateCaretList(this); \n      } \n\n      ++row; \n    } \n\n```", "```cpp\n    for (Reference cellRef : invalidateSet) { \n      InvalidateCell(cellRef); \n    } \n  } \n\n```", "```cpp\n  catch (Error error) { \n    cellMatrix = backupMatrix; \n    sourceSetMap = backupSourceSetMap; \n    targetSetMap = backupTargetSetMap; \n    MessageBox(error.ErrorText(), TEXT(\"Syntax Error\"), Ok, Stop); \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::PasteGeneric(int /* format */, \n                                InfoList& infoList) { \n  int minMarkedRow = min(firstMarkRef.Row(), lastMarkRef.Row()), \n      minMarkedCol = min(firstMarkRef.Col(), lastMarkRef.Col()), \n      copyRows, copyCols, minCopyRow, minCopyCol; \n\n  infoList.GetValue<int>(copyRows); \n  infoList.GetValue<int>(copyCols); \n  infoList.GetValue<int>(minCopyRow); \n  infoList.GetValue<int>(minCopyCol); \n\n  Reference diffRef(minMarkedRow - minCopyRow, \n                    minMarkedCol - minCopyCol); \n  int maxCopyRow = minCopyRow + copyRows - 1, \n      maxCopyCol = minCopyCol + copyCols - 1; \n\n```", "```cpp\n  for (int row = minCopyRow; row <= maxCopyRow; ++row) { \n    for (int col = minCopyCol; col <= maxCopyCol; ++col) { \n      Cell pastedCell; \n      pastedCell.ReadCellFromClipboard(infoList); \n\n      Reference pastedRef(row, col); \n      Reference targetRef = pastedRef + diffRef; \n\n      RemoveTargetSetMap(targetRef); \n      Cell& targetCell = cellMatrix[targetRef]; \n      targetCell = pastedCell; \n\n      set<Reference> sourceSet; \n      if (diffRef.IsEmpty()) { \n        targetCell.GenerateSourceSet(sourceSet); \n      } \n      else { \n        targetCell.UpdateTree(diffRef, sourceSet); \n      } \n\n      AddTargetSetMap(targetRef, sourceSet); \n      sourceSetMap[targetRef] = sourceSet; \n\n      set<Reference> invalidateSet; \n      EvaluateRecursive(targetRef, invalidateSet); \n\n      for (Reference cellRef : invalidateSet) { \n        InvalidateCell(cellRef); \n      } \n    } \n  } \n\n  UpdateWindow(); \n  SetDirty(true); \n} \n\n```", "```cpp\nbool CalcDocument::DeleteEnable() const { \n  if (calcMode == Edit) { \n    const Cell& editCell = cellMatrix[editRef]; \n    return (editIndex < ((int)editCell.GetText().length())); \n  } \n  else { \n    return true; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnDelete() { \n  OnDeleteKey(); \n} \n\n```", "```cpp\nvoid CalcDocument::OnFont() { \n  switch (calcMode) { \n    case Edit: { \n        Cell& editCell = cellMatrix[editRef]; \n        Font font = editCell.CellFont(); \n        Font previousFont = font; \n\n```", "```cpp\n        if (StandardDialog::FontDialog(this, font) && \n            (font != previousFont)) { \n          editCell.CellFont() = font; \n          editCell.GenerateCaretList(this); \n          InvalidateCell(editRef); \n          SetDirty(true); \n          UpdateCaret(); \n          UpdateWindow(); \n        } \n      } \n      break; \n\n```", "```cpp\n    case Mark: { \n        Font font = cellMatrix[lastMarkRef].CellFont(); \n\n        if (StandardDialog::FontDialog(this, font)) { \n          int minMarkRow = min(firstMarkRef.Row(), \n                               lastMarkRef.Row()), \n              maxMarkRow = max(firstMarkRef.Row(), \n                               lastMarkRef.Row()), \n              minMarkCol = min(firstMarkRef.Col(), \n                               lastMarkRef.Col()), \n              maxMarkCol = max(firstMarkRef.Col(), \n                               lastMarkRef.Col()); \n\n          for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n            for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n              Reference markRef = Reference(row, col); \n              Cell& markCell = cellMatrix[markRef]; \n\n              if (markCell.CellFont() != font) { \n                markCell.CellFont() = font; \n                markCell.GenerateCaretList(this); \n                InvalidateCell(markRef); \n                SetDirty(true); \n              } \n            } \n          } \n\n          UpdateWindow(); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::OnBackgroundColor() { \n  switch (calcMode) { \n    case Edit: { \n        Cell& editCell = cellMatrix[editRef]; \n        Color color = editCell.BackgroundColor(); \n        Color previousColor = color; \n\n        if (StandardDialog::ColorDialog(this, color) && \n            (color != previousColor)){ \n          editCell.BackgroundColor() = color; \n          InvalidateCell(editRef); \n          SetDirty(true); \n        } \n      } \n      break; \n\n    case Mark: { \n        Color color = cellMatrix[lastMarkRef].BackgroundColor(); \n\n        if (StandardDialog::ColorDialog(this, color)) { \n          int minMarkRow = min(firstMarkRef.Row(), \n                               lastMarkRef.Row()), \n              maxMarkRow = max(firstMarkRef.Row(), \n                               lastMarkRef.Row()), \n              minMarkCol = min(firstMarkRef.Col(), \n                               lastMarkRef.Col()), \n              maxMarkCol = max(firstMarkRef.Col(), \n                               lastMarkRef.Col()); \n\n          for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n            for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n              Reference markRef = Reference(row, col); \n              Cell& markCell = cellMatrix[markRef]; \n\n              if (markCell.BackgroundColor() != color) { \n                markCell.BackgroundColor() = color; \n                InvalidateCell(markRef); \n                SetDirty(true); \n              } \n            } \n          } \n        } \n      } \n      break; \n  } \n\n  UpdateWindow(); \n} \n\n```", "```cpp\nbool CalcDocument::HorizontalLeftRadio() const { \n  return (IsHorizontalAlignment(Left)); \n} \n\nbool CalcDocument::HorizontalCenterRadio() const { \n  return (IsHorizontalAlignment(Center)); \n} \n\nbool CalcDocument::HorizontalRightRadio() const { \n  return (IsHorizontalAlignment(Right)); \n} \n\nbool CalcDocument::HorizontalJustifiedRadio() const { \n  return (IsHorizontalAlignment(Justified)); \n} \n\n```", "```cpp\nbool CalcDocument::IsHorizontalAlignment(Alignment alignment) \n                                         const { \n  switch (calcMode) { \n    case Edit: \n      return cellMatrix[editRef].HorizontalAlignment() == \n             alignment; \n\n    case Mark: { \n        int minMarkRow = min(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            maxMarkRow = max(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            minMarkCol = min(firstMarkRef.Col(), \n                             lastMarkRef.Col()), \n            maxMarkCol = max(firstMarkRef.Col(), \n                             lastMarkRef.Col()); \n\n        for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n          for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n            Reference markRef = Reference(row, col); \n            if (cellMatrix[markRef].VerticalAlignment()!= \n                alignment) { \n              return true; \n            } \n          } \n        } \n\n        return false; \n      } \n  } \n\n  return true; \n} \n\n```", "```cpp\nvoid CalcDocument::OnHorizontalLeft() { \n  SetHorizontalAlignment(Left); \n} \n\nvoid CalcDocument::OnHorizontalCenter() { \n  SetHorizontalAlignment(Center); \n} \n\nvoid CalcDocument::OnHorizontalRight() { \n  SetHorizontalAlignment(Right); \n} \n\nvoid CalcDocument::OnHorizontalJustified() { \n  SetHorizontalAlignment(Justified); \n} \n\n```", "```cpp\nvoid CalcDocument::SetHorizontalAlignment(Alignment alignment) { \n  switch (calcMode) { \n    case Edit: { \n        Cell& editCell = cellMatrix[editRef]; \n        editCell.HorizontalAlignment() = alignment; \n        editCell.GenerateCaretList(this); \n        InvalidateCell(editRef); \n        UpdateCaret(); \n      } \n      break; \n    case Mark: { \n        int minMarkRow = min(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            maxMarkRow = max(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            minMarkCol = min(firstMarkRef.Col(), \n                             lastMarkRef.Col()), \n            maxMarkCol = max(firstMarkRef.Col(), \n                             lastMarkRef.Col()); \n\n        for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n          for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n            Reference markRef = Reference(row, col); \n            Cell& markCell = cellMatrix[markRef]; \n\n```", "```cpp\n            if (markCell.HorizontalAlignment() != alignment) { \n              markCell.HorizontalAlignment() = alignment; \n              markCell.GenerateCaretList(this); \n              InvalidateCell(markRef); \n            } \n          } \n        } \n      } \n      break; \n  } \n\n```", "```cpp\n  UpdateWindow(); \n  SetDirty(true); \n} \n\n```", "```cpp\nbool CalcDocument::VerticalTopRadio() const { \n  return (IsVerticalAlignment(Top)); \n} \n\nbool CalcDocument::VerticalCenterRadio() const { \n  return (IsVerticalAlignment(Center)); \n} \n\nbool CalcDocument::VerticalBottomRadio() const { \n  return (IsVerticalAlignment(Bottom)); \n} \n\nbool CalcDocument::IsVerticalAlignment(Alignment alignment) const { \n  switch (calcMode) { \n    case Edit: \n      return cellMatrix[editRef].VerticalAlignment() == alignment; \n\n    case Mark: { \n        int minMarkRow = min(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            maxMarkRow = max(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            minMarkCol = min(firstMarkRef.Col(), \n                             lastMarkRef.Col()), \n            maxMarkCol = max(firstMarkRef.Col(), \n                             lastMarkRef.Col()); \n\n        for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n          for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n            Reference markRef = Reference(row, col); \n            if (cellMatrix[markRef].VerticalAlignment() != \n                alignment){ \n              return true; \n            } \n          } \n        } \n\n        return false; \n      } \n  } \n\n  return true; \n} \n\nvoid CalcDocument::OnVerticalTop() { \n  SetVerticalAlignment(Top); \n} \n\nvoid CalcDocument::OnVerticalCenter() { \n  SetVerticalAlignment(Center); \n} \n\nvoid CalcDocument::OnVerticalBottom() { \n  SetVerticalAlignment(Bottom); \n} \n\nvoid CalcDocument::SetVerticalAlignment(Alignment alignment) { \n  switch (calcMode) { \n    case Edit: { \n        Cell& editCell = cellMatrix[editRef]; \n        editCell.VerticalAlignment() = alignment; \n        editCell.GenerateCaretList(this); \n        InvalidateCell(editRef); \n        UpdateCaret(); \n      } \n      break; \n\n    case Mark: { \n        int minMarkRow = min(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            maxMarkRow = max(firstMarkRef.Row(), \n                             lastMarkRef.Row()), \n            minMarkCol = min(firstMarkRef.Col(), \n                             lastMarkRef.Col()), \n            maxMarkCol = max(firstMarkRef.Col(), \n                             lastMarkRef.Col()); \n\n        for (int row = minMarkRow; row <= maxMarkRow; ++row) { \n          for (int col = minMarkCol; col <= maxMarkCol; ++col) { \n            Reference markRef = Reference(row, col); \n            Cell& markCell = cellMatrix[markRef]; \n\n            if (markCell.VerticalAlignment() != alignment) { \n              markCell.VerticalAlignment() = alignment; \n              markCell.GenerateCaretList(this); \n              InvalidateCell(markRef); \n            } \n          } \n        } \n      } \n      break; \n  } \n\n  UpdateWindow(); \n  SetDirty(true); \n}  \n\n```", "```cpp\nbool CalcDocument::InterpretEditCell() { \n  try { \n    Cell& editCell = cellMatrix[editRef]; \n    set<Reference> sourceSet; \n    editCell.InterpretCell(sourceSet); \n\n```", "```cpp\n    RemoveTargetSetMap(editRef); \n    AddTargetSetMap(editRef, sourceSet); \n    sourceSetMap[editRef] = sourceSet; \n\n```", "```cpp\n    set<Reference> invalidateSet; \n    EvaluateRecursive(editRef, invalidateSet); \n    editCell.GenerateCaretList(this); \n\n```", "```cpp\n    for (Reference cellRef : invalidateSet) { \n      InvalidateCell(cellRef); \n    } \n\n    SetDirty(true); \n    return true; \n  } \n\n```", "```cpp\n  catch (Error error) { \n    MessageBox(error.ErrorText(), TEXT(\"Syntax Error\"), Ok, Stop); \n    return false; \n  } \n} \n\n```", "```cpp\nvoid CalcDocument::InvalidateCell(Reference cellRef) { \n  Point topLeft(HeaderWidth + (cellRef.Col() * ColWidth), \n                HeaderHeight + (cellRef.Row() * RowHeight)); \n  Size cellSize(ColWidth, RowHeight); \n  Rect cellRect(topLeft, cellSize); \n  Invalidate(cellRect); \n} \n\n```", "```cpp\nbool CalcDocument::IsCircular(Reference cellRef, \n                              set<Reference>& targetSet){ \n  for (Reference targetRef : targetSet) { \n    if ((cellRef == targetRef) || \n        IsCircular(cellRef, targetSetMap[targetRef])) { \n      return true; \n    } \n  } \n\n  return false; \n} \n\n```", "```cpp\nvoid CalcDocument::EvaluateCell(Reference cellRef) { \n  Cell& cell = cellMatrix[cellRef]; \n\n  if (IsCircular(cellRef, targetSetMap[cellRef])) { \n    cell.SetText(Error(CircularReference).ErrorText()); \n  } \n  else { \n    set<Reference> sourceSet = sourceSetMap[cellRef]; \n    map<Reference, double> valueMap; \n\n    for (Reference sourceRef : sourceSet) {   \n      Cell& sourceCell = cellMatrix[sourceRef]; \n\n      if (sourceCell.HasValue()) { \n        valueMap[sourceRef] = sourceCell.GetValue(); \n      } \n    } \n\n    cell.Evaluate(valueMap); \n  } \n\n  cell.GenerateCaretList(this); \n} \n\n```", "```cpp\nvoid CalcDocument::EvaluateRecursive(Reference cellRef, \n                           set<Reference>& invalidateSet) { \n\n```", "```cpp\n  set<Reference> targetSet, evaluatedSet; \n  targetSet.insert(cellRef); \n\n  while (!targetSet.empty()) { \n    Reference targetRef = *targetSet.begin(); \n    targetSet.erase(targetRef); \n\n    if (evaluatedSet.count(targetRef) == 0) { \n      EvaluateCell(targetRef); \n      evaluatedSet.insert(targetRef); \n      invalidateSet.insert(targetRef); \n      set<Reference> nextTargetSet = targetSetMap[targetRef]; \n      targetSet.insert(nextTargetSet.begin(), \n                       nextTargetSet.end()); \n    } \n  } \n} \n\n```", "```cpp\n  cell.GenerateCaretList(this); \n} \n\n```", "```cpp\nvoid CalcDocument::RemoveTargetSetMap(Reference cellRef) { \n  for (Reference sourceRef : sourceSetMap[cellRef]) { \n    int row = sourceRef.Row(), col = sourceRef.Col(); \n    if ((row >= 0) && (row < Rows) && (col >= 0) && (col < Cols)){ \n      targetSetMap[sourceRef].erase(cellRef); \n    } \n  } \n} \n\nvoid CalcDocument::AddTargetSetMap(Reference cellRef, \n                                   set<Reference>& sourceSet) { \n  for (Reference sourceRef : sourceSet) { \n    int row = sourceRef.Row(), col = sourceRef.Col(); \n    if ((row >= 0) && (row < Rows) && (col >= 0) && (col < Cols)){ \n      targetSetMap[sourceRef].insert(cellRef); \n    } \n  } \n\n  sourceSetMap[cellRef] = sourceSet; \n} \n\n```", "```cpp\nenum ErrorId {SyntaxError, CircularReference, ReferenceOutOfRange, \n              DivisionByZero, MissingValue}; \n\nclass Error : public exception { \n  public: \n    Error(ErrorId errorId); \n    String ErrorText() const; \n\n  private: \n    ErrorId errorId; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Error.h\" \n\nError::Error(ErrorId errorId) \n :errorId(errorId) { \n  // Empty. \n} \n\nString Error::ErrorText() const{ \n  switch (errorId) { \n    case SyntaxError: \n      return TEXT(\"Syntax Error.\"); \n\n    case CircularReference: \n      return TEXT(\"#Circular reference#\"); \n\n    case DivisionByZero: \n      return TEXT(\"#Division by Zero#\"); \n\n    case MissingValue: \n      return TEXT(\"#Missing Value#\"); \n\n    case ReferenceOutOfRange: \n      return TEXT(\"#Reference out of Range.#\"); \n  } \n\n  return TEXT(\"\"); \n} \n\n```"]