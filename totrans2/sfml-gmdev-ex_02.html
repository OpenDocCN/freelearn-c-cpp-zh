<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Give It Some Structure – Building the Game Framework</h1></div></div></div><p>Working on a project with poor structure is much like building a house with no foundation: it's difficult to maintain, extremely unstable, and will probably cause you to abandon it shortly. While the code we worked on in <a class="link" href="ch01.html" title="Chapter 1. It's Alive! It's Alive! – Setup and First Program">Chapter 1</a>, <em>It's Alive! It's Alive! – Setup and First Program</em>, is functional and can be managed on a very small scale, expanding it without first building a solid framework would most likely result in tons of <em>spaghetti code</em> (not to be confused with ravioli code or lasagna code) being present. Although it sounds delicious, this pejorative term describes the pain of a new feature being exponentially more difficult to implement within the source code that is unstructured and executes in a "tangled" manner, which is something we'll be focusing on avoiding.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing a window class, along with a main game class</li><li class="listitem" style="list-style-type: disc">Code restructuring and proper architecture</li><li class="listitem" style="list-style-type: disc">The importance of proper time management in applications</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">sf::Clock</code> and <code class="literal">sf::Time</code> classes</li><li class="listitem" style="list-style-type: disc">Fixed and variable time-steps</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Graduating to ravioli</h1></div></div></div><p>Let's start<a id="id30" class="indexterm"/> small. Every game needs to have a window, and as you already know from <a class="link" href="ch01.html" title="Chapter 1. It's Alive! It's Alive! – Setup and First Program">Chapter 1</a>, <em>It's Alive! It's Alive! – Setup and First Program</em>, it needs to be created, destroyed, and its events need to be processed. It also needs to be able to clear the screen and update itself to show anything drawn after the screen was cleared. Additionally, keeping track of whether the window is being closed and if it's in full-screen mode, as well as having a method to toggle the latter would be quite useful. Lastly, we will, of course, need to draw to the window. Knowing all of that, the header <a id="id31" class="indexterm"/>of our window class will predictably look something like this:</p><div><pre class="programlisting">class Window{
public:
    Window();
    Window(const std::string&amp; l_title,const sf::Vector2u&amp; l_size);
    ~Window();

    void BeginDraw(); // Clear the window.
    void EndDraw(); // Display the changes.

    void Update();

    bool IsDone();
    bool IsFullscreen();
    sf::Vector2u GetWindowSize();

    void ToggleFullscreen();

    void Draw(sf::Drawable&amp; l_drawable);
private:
    void Setup(const std::string&amp; l_title, const sf::Vector2u&amp; l_size);
    void Destroy();
    void Create();

    sf::RenderWindow m_window;
    sf::Vector2u m_windowSize;
    std::string m_windowTitle;
    bool m_isDone;
    bool m_isFullscreen;
};</pre></div><p>Because we want to handle setting up our window internally, the setup method is made private, as well as the destroy and create methods. Think of these as just helper methods that the user of this class doesn't need to know about. It's a good idea to keep certain information around after the setup is done, such as the window size or the title that's being displayed above it. Lastly, we keep around two Boolean variables to keep track of the window being closed and its state regarding full screen.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>The<a id="id32" class="indexterm"/> naming convention that's being employed in our window class is referred to as the <strong>Hungarian notation</strong>. Using it is, of course, not required, but it can prove useful when dealing with lots of code, trying to track down bugs, and working in larger groups of people. We'll be utilizing it<a id="id33" class="indexterm"/> throughout this book. More information about it can be found here: <a class="ulink" href="http://en.wikipedia.org/wiki/Hungarian_notation">http://en.wikipedia.org/wiki/Hungarian_notation</a>
</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Implementing the window class</h1></div></div></div><p>Now<a id="id34" class="indexterm"/> that we have our blueprint, let's begin actually building our window class. The entry and exit points seem as good a place as any to start with:</p><div><pre class="programlisting">Window::Window(){ Setup("Window", sf::Vector2u(640,480)); }

Window::Window(const std::string&amp; l_title, const sf::Vector2u&amp; l_size)
{
    Setup(l_title,l_size);
}

Window::~Window(){ Destroy(); }</pre></div><p>Both implementations of the constructor and destructor simply utilize the helper methods which we'll be implementing shortly. There's also a default constructor that takes no arguments and initializes some pre-set default values, which is not necessary, but it's convenient. With that said, let's take a look at the setup method:</p><div><pre class="programlisting">void Window::Setup(const std::string l_title, const sf::Vector2u&amp; l_size)
{
    m_windowTitle = l_title;
    m_windowSize = l_size;
    m_isFullscreen = false;
    m_isDone = false;
    Create();
}</pre></div><p>Once again, this is quite simple. As mentioned before, it initializes and keeps track of some of the window properties that will be passed to the constructor. Aside from that, it calls another method named <code class="literal">Create</code> to break up the code even more, which is what we'll be implementing next in addition to the <code class="literal">Destroy</code> method:</p><div><pre class="programlisting">void Window::Create(){
    auto style = (m_isFullscreen ? sf::Style::Fullscreen 
        : sf::Style::Default);
    m_window.create({ m_windowSize.x, m_windowSize.y, 32 },
        m_windowTitle, style);
}

void Window::Destroy(){
    m_window.close();
}</pre></div><p>Here,<a id="id35" class="indexterm"/> we introduce a new data type that SFML offers: <code class="literal">sf::Uint32</code>. It gets stored inside the <code class="literal">style</code> local variable, which is automatically deduced to said type by using the <code class="literal">auto</code> keyword. It's simply an unsigned, fixed size integer type. In this particular case, we're using the <em>32-bit</em> integer, although SFML offers both signed and unsigned types of <em>8</em>, <em>16</em>, and <em>32</em> bits. We use this value to hold the current style for a window using a <em>ternary operator</em> and assigning it to either the default or full screen styles of the window style enumeration. This is the full list of all possible window styles within SFML:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Enumerator</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Mutually exclusive</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>No border or title bar. The most minimalistic style.</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Fullscreen</p>
</td><td style="text-align: left" valign="top">
<p>Full screen mode.</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Titlebar</p>
</td><td style="text-align: left" valign="top">
<p>Title bar and a fixed border.</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Close</p>
</td><td style="text-align: left" valign="top">
<p>Title bar and a close button.</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Resize</p>
</td><td style="text-align: left" valign="top">
<p>Title bar, resizable border and a maximize button.</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Default</p>
</td><td style="text-align: left" valign="top">
<p>Title bar, resizable border, maximize and close buttons.</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr></tbody></table></div><p>The mutually exclusive column simply denotes whether the style in question can be used with other styles in tandem. For example, it is possible to have a window with a title bar, resizable border, the maximize button, and a close button by combining two styles together using the bitwise <em>or</em> operator in C++:</p><div><pre class="programlisting">auto style = sf::Style::Resize | sf::Style::Close;</pre></div><p>If, however, a style is mutually exclusive, it cannot be used with any other styles in this way.</p><p>Once we have our style, we can simply pass it to the <code class="literal">create</code> method of our window, in addition to the <code class="literal">sf::VideoMode</code> type that gets constructed, using uniform initialization. It's that simple.</p><p>The <code class="literal">destroy</code> method of our <code class="literal">Window</code> class will simply close the window by invoking its <code class="literal">close</code> method. It's important to note here that the closed window will have all of its attached resources destroyed, but you can still call its <code class="literal">create</code> method again to re-create the window. Polling events and calling the <code class="literal">display</code> method will still work if a window is closed. It will just have no effect.</p><p>Let's proceed in breaking up our once solid chunk of code by processing the events of the window in the appropriate <code class="literal">update</code> method:</p><div><pre class="programlisting">void Window::Update(){
   sf::Event event;
   while(m_window.pollEvent(event)){
      if(event.type == sf::Event::Closed){
         m_isDone = true;
      } else if(event.type == sf::Event::KeyPressed &amp;&amp;
         event.key.code == sf::Keyboard::F5)
      {
         ToggleFullscreen();
      }
   }
}</pre></div><p>It's the <a id="id36" class="indexterm"/>same drill as before, we're simply handling events. Instead of closing the window right off the bat, however, we simply flip the Boolean flag we keep around for checking if the window has been closed or not: <code class="literal">m_isDone</code>. Since we're also interested in toggling between full screen and normal states of our window, we need to keep an eye out for another type of event: <code class="literal">sf::Event::KeyPressed</code>. This event gets dispatched whenever a keyboard key is pressed down and it includes information about that key stored in the <code class="literal">event.key</code> struct. For now, we're only interested in the code of the key being pressed, which we can then check against the <code class="literal">sf::Keyboard</code> enumeration table. Upon receiving an event of an <em>F5</em> key being pressed, we call the <code class="literal">ToggleFullscreen</code> method, which is fairly simple to implement now that we have broken up the code into manageable sections:</p><div><pre class="programlisting">void Window::ToggleFullscreen(){
    m_isFullscreen = !m_isFullscreen;
    Destroy();
    Create();
}</pre></div><p>As you can see, the only thing we do here is invert the value of our <em>Boolean</em> class member, <code class="literal">m_isFullscreen</code>, that keeps track of the window state. Afterwards, we need to destroy and re-create the window in order to make it honor our changes. Let's take a look at the drawing methods:</p><div><pre class="programlisting">void Window::BeginDraw(){ m_window.clear(sf::Color::Black); }
void Window::EndDraw(){ m_window.display(); }</pre></div><p>Nothing new gets introduced here. We're simply wrapping the functionality of clearing and displaying in <code class="literal">BeginDraw</code> and <code class="literal">EndDraw</code> methods. All that's left now are the simple helper methods:</p><div><pre class="programlisting">bool Window::IsDone(){ return m_isDone; }
bool Window::IsFullscreen(){ return m_isFullscreen; }
sf::Vector2u Window::GetWindowSize(){ return m_windowSize; }

void Window::Draw(sf::Drawable&amp;l_drawable){
    m_window.draw(l_drawable);
}</pre></div><p>These <a id="id37" class="indexterm"/>basic methods provide the means for retrieving information about the window without giving too much control to anything outside the window class. For now, our window class is more than sufficient.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Building the game class</h1></div></div></div><p>We've<a id="id38" class="indexterm"/> done a good job at wrapping up the basic functionality of our window class, but that's not the only chunk of code in need of refactoring. In <a class="link" href="ch01.html" title="Chapter 1. It's Alive! It's Alive! – Setup and First Program">Chapter 1</a>, <em>It's Alive! It's Alive! – Setup and First Program</em>, we've discussed the main game loop and its contents, mainly processing input, updating the game world and the player, and finally, rendering everything on screen. Cramming all of that functionality into the game loop alone is generally known to produce spaghetti code, and since we want to move away from that, let's consider a better structure that would allow this kind of behavior:</p><div><pre class="programlisting">#include "Game.h"

void main(int argc, void** argv[]){
    // Program entry point.
    Game game; // Creating our game object.
    while(!game.GetWindow()-&gt;IsDone()){
        // Game loop.
        game.HandleInput();
        game.Update();
        game.Render();
    }
}</pre></div><p>The code above represents the <em>entire</em> content of our <code class="literal">main.cpp</code> file and perfectly illustrates the use of a properly structured game class, which doesn't go beyond calling the proper methods in the right order in an endless loop until the window is closed. Just for the sake of clarity, let's take a look at a simplified version of the game class header:</p><div><pre class="programlisting">class Game{
public:
    Game();
    ~Game();

    void HandleInput();
    void Update();
    void Render();
    Window* GetWindow();
    ...
private:
    void MoveMushroom();
    Window m_window;
    ...
};</pre></div><p>Note that <a id="id39" class="indexterm"/>the game class holds an instance of our window. It can be done differently, but for our current needs this will more than suffice.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Putting our code to work</h2></div></div></div><p>We're <a id="id40" class="indexterm"/>now ready to re-implement the bouncing mushroom demo from <a class="link" href="ch01.html" title="Chapter 1. It's Alive! It's Alive! – Setup and First Program">Chapter 1</a>, <em>It's Alive! It's Alive! – Setup and First Program</em>. Given how simple it is, we'll walk you through the entire process of adapting our previously written code to our new structure. Let's begin by setting up our window and graphics we'll be using:</p><div><pre class="programlisting">Game::Game(): m_window("Chapter 2", sf::Vector2u(800,600)){
    // Setting up class members.
    m_mushroomTexture.loadFromFile("Mushroom.png");
    m_mushroom.setTexture(m_mushroomTexture);
    m_increment = sf::Vector2i(4,4);
}</pre></div><p>Because we have nothing to clean up, our game destructor will remain empty for now:</p><div><pre class="programlisting">Game::~Game(){}</pre></div><p>We have no need to check for input for this example, so let's leave that method alone for now. What we will be doing, however, is updating the position of our sprite each frame:</p><div><pre class="programlisting">void Game::Update(){
    m_window.Update(); // Update window events.
    MoveMushroom();
}
void Game::MoveMushroom(){
   sf::Vector2u l_windSize = m_window.GetWindowSize();
   sf::Vector2u l_textSize = m_mushroomTexture.getSize();

   if((m_mushroom.getPosition().x &gt;
      l_windSize.x - l_textSize.x&amp;&amp;m_increment.x&gt; 0) ||
      (m_mushroom.getPosition().x &lt; 0 &amp;&amp;m_increment.x&lt; 0)){
         m_increment.x = -m_increment.x;
   }

   if((m_mushroom.getPosition().y &gt;
      l_windSize.y - l_textSize.y&amp;&amp;m_increment.y&gt; 0) ||
      (m_mushroom.getPosition().y &lt; 0 &amp;&amp;m_increment.y&lt; 0)){
         m_increment.y = -m_increment.y;
   }

   m_mushroom.setPosition(
      m_mushroom.getPosition().x + m_increment.x, 
      m_mushroom.getPosition().y + m_increment.y);
}</pre></div><p>Literally<a id="id41" class="indexterm"/> the first thing you'll probably notice is the update method call of our window class. We've already covered the importance of <em>event processing</em> in SFML, but it's still worthy to note that one more time. The rest of the code is pretty much the same, except we now have a separate method that is responsible for updating the position of the mushroom sprite. We used two local variables to hold the window and texture sizes in order to increase readability, but that's about it. Time to draw our sprite to the screen:</p><div><pre class="programlisting">void Game::Render(){
    m_window.BeginDraw(); // Clear.
    m_window.Draw(m_mushroom);
    m_window.EndDraw(); // Display.
}</pre></div><p>Once again, the code is fairly straight forward. Our window class does all the work, and all we have to do is call the <code class="literal">Draw</code> method and pass in our <code class="literal">sf::Drawable</code> right in between the wrapper methods for clearing the screen and displaying the changes.</p><p>Putting everything together and running it should produce the exact same bouncing mushroom we had back in <a class="link" href="ch01.html" title="Chapter 1. It's Alive! It's Alive! – Setup and First Program">Chapter 1</a>, <em>It's Alive! It's Alive! – Setup and First Program</em>. However, you may have noticed that the sprite moves differently based on how busy your computer is. In this observation lies an important lesson about game development.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Hardware and execution time</h1></div></div></div><p>Let's<a id="id42" class="indexterm"/> travel back in time to May 5, 1992. Apogee Software begins publishing the now known cult classic <em>Wolfenstein 3D</em> developed by <em>id Software</em>:</p><div><img src="img/4284_02_01.jpg" alt="Hardware and execution time"/></div><p>The<a id="id43" class="indexterm"/> man with the vision, <em>John Carmack</em>, took massive strides forward and not only popularized, but also revolutionized the first person shooter genre on the PC. Its massive success cannot be overstated, as even now it's difficult to accurately predict how many times it has been downloaded. Having grown up at right around that time, one can't help but feel nostalgic sometimes and attempt to play this game again. Ever since its original release for the <em>DOS</em> operating system on the PC, it has been ported to many other operating systems and consoles. While it's still possible to play it, we've come a long way since the days of using DOS. The environment our software runs in has fundamentally changed, ergo the software from the past is no longer compatible, hence the need for emulation.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>An <strong>emulator</strong> is <a id="id44" class="indexterm"/>either software, hardware, or the combination of both, that simulates the functionality of a certain system, usually referred to as a guest, on a primary system, referred to as the host.</p></div></div><p>Every emulator used for this purpose not only has to imitate the software of a system that would be compatible with a title you're attempting to play, but also the hardware. Why is that important? Most games in the days of DOS counted on the hardware being roughly similar. In the case of Wolfenstein 3D, it assumed it was running on a <em>4.77 MHz</em> system, which allowed the developers to save some clock cycles for the sake of efficiency by not writing internal timing loops. A game like Wolfenstein 3D consumed all of the processing power, which was a fine strategy for the time, until more powerful and faster processors came about. Today, the puny 4.77 MHz speed is dwarfed by comparison, even when looking at all of the cheapest consumer-grade processors, so proper emulation of a specific system also requires the reduction of CPU clock cycles, otherwise these games will run too fast, which is exactly what happens when an emulator is set up in the wrong way and doesn't throttle the speed enough.</p><p>While this is the most extreme example, speed management is an important component of any piece of software today that has to run at a constant speed. Different choices of hardware and architecture aside, your software might run faster or slower simply based on how <a id="id45" class="indexterm"/>busy your system is at the time or the different tasks your code needs to accomplish every iteration before the image is rendered. Consider the following illustration:</p><div><img src="img/4284_02_02.jpg" alt="Hardware and execution time"/></div><p>The changes on the left side as well as the right side both take place over a 1 second interval. The code is exactly the same in both cases. The only difference is the number of iterations the main loop manages to complete during that interval. Predictably, the slower hardware will take longer to execute your code and therefore will yield fewer iterations, resulting in the sprite being moved fewer times during our 1 second time interval and end up looking like the left side. As a game developer, it is important to ensure that your product runs the same on all systems within the designated specification guidelines. This is where SFML time management comes in.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Controlling the frame-rate</h2></div></div></div><p>SFML<a id="id46" class="indexterm"/> provides a means of setting a frame-rate cap for your applications. It's a method in the <code class="literal">sf::RenderWindow</code> class, appropriately called <code class="literal">setFramerateLimit</code>:</p><div><pre class="programlisting">m_window.setFramerateLimit(60); // 60 FPS cap.</pre></div><p>Although this feature is not absolutely reliable, it ensures that the application's frame-rate is capped at the provided maximum value with reasonable precision, as long as the provided cap isn't too high. Keep in mind that capping the frame-rate reduces the overall CPU consumption of the program as well, since it doesn't need to update and re-draw the same <a id="id47" class="indexterm"/>scene as many times anymore. It does, however, raise a problem for slower hardware. If the frame-rate is lower than the provided value, the simulation will run slower too. Setting the limit solves only half of our problem. Let's take a look at something more practical. Enter <code class="literal">sf::Clock</code>!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using the SFML clock</h1></div></div></div><p>The <code class="literal">sf::Clock</code> class is <a id="id48" class="indexterm"/>very simple and lightweight, so it has only two methods: <code class="literal">getElapsedTime()</code> and <code class="literal">restart()</code>. Its sole purpose is to measure elapsed time since the last instance of the clock being restarted, or since its creation, in the most precise manner the operating system can provide. When retrieving the elapsed time using the <code class="literal">getElapsedTime</code> method, it returns a type <code class="literal">sf::Time</code>. The main reasoning behind that is an additional layer of abstraction to provide flexibility and avoid imposing any fixed data types. The <code class="literal">sf::Time</code> class is also lightweight and provides three useful methods for conversion of elapsed time to seconds which returns a <em>floating point</em> value, milliseconds, which returns <em>a 32-bit integer</em> value and microseconds, which returns a <em>64-bit integer</em> value, as represented here:</p><div><pre class="programlisting">sf::Clock clock;
...
sf::Time time = clock.getElapsedTime();

float seconds = time.asSeconds();
sf::Int32 milliseconds = time.asMilliseconds();
sf::Int64 microseconds = time.asMicroseconds();
...
time = clock.restart();</pre></div><p>As you can see, the <code class="literal">restart</code> method also returns an <code class="literal">sf::Time</code> value. This is provided in order to avoid calling <code class="literal">getElapsedTime</code> right before calling the <code class="literal">restart</code> method and having some time pass between those two calls that would otherwise be unaccounted for. How is this useful for us? Well, the problem we were dealing with was the same code running differently on other platforms because we couldn't account for their speed. We moved our sprite across the screen using this line of code:</p><div><pre class="programlisting">m_mushroom.setPosition(
    m_mushroom.getPosition().x + m_increment.x, 
    m_mushroom.getPosition().y + m_increment.y);</pre></div><p>The <code class="literal">m_increment</code> vector here is used with an assumption that the time between iterations is constant, but that's obviously not true. Recall the magic triangle for the speed, time, and distance formula:</p><div><img src="img/4284_02_03.jpg" alt="Using the SFML clock"/></div><p>Finding the <a id="id49" class="indexterm"/>distance a sprite should travel in between updates can be done by first defining a set speed at which it moves. The time value here is simply how long it takes for an entire cycle of the program to finish. In order to accurately measure that, we're going to be adjusting the <code class="literal">Game</code> class to utilize the <code class="literal">sf::Clock</code>:</p><div><pre class="programlisting">class Game{
public:
...
    sf::Time GetElapsed();
    void RestartClock();
private:
...
    sf::Clock m_clock;
    sf::Time m_elapsed;
...
};</pre></div><p>The two new public methods we've added can be implemented like so:</p><div><pre class="programlisting">sf::Time Game::GetElapsed(){ return m_elapsed; }
void Game::RestartClock(){ m_elapsed = m_clock.restart(); }</pre></div><p>Once that is done, it's important to actually utilize this functionality and restart the game clock after each iteration. That can be achieved in the main game loop by simply calling the <code class="literal">RestartClock</code> method after all the work is done:</p><div><pre class="programlisting">while(!game.GetWindow()-&gt;IsDone()){
    // Game loop.
    game.HandleInput();
    game.Update();
    game.Render();
    game.RestartClock(); // Restarting our clock.
}</pre></div><p>The last line<a id="id50" class="indexterm"/> in the loop will make sure that the <code class="literal">m_elapsed</code> member of the game class will always have a value of the time passed during the previous iteration, so let's use that time and determine how far our sprite should have moved:</p><div><pre class="programlisting">float fElapsed = m_elapsed.asSeconds();

m_mushroom.setPosition(
    m_mushroom.getPosition().x + (m_increment.x * fElapsed), 
    m_mushroom.getPosition().y + (m_increment.y * fElapsed));</pre></div><p>We're now using <code class="literal">m_increment</code> as a variable of speed, not distance. By looking at our previous code in the constructor, we've set both <em>x</em> and <em>y</em> values of the <code class="literal">m_increment</code> vector to a value of <code class="literal">4</code>. Since we're expressing our elapsed time as seconds, this is essentially like saying that the sprite needs to move <em>4</em> pixels a second. That's really slow, so let's change it to something a little bit more stimulating:</p><div><pre class="programlisting">Game::Game(){
...
    m_increment = sf::Vector2i(400,400); // 400px a second.
}</pre></div><p>Upon compiling and running the project, you should see our sprite happily bouncing across the screen. It will now be moved the same distance on every single machine it's executed on, no matter how choppy the frame-rate is. For extra points, try it out yourself by artificially slowing down the game loop with the <code class="literal">sf::sleep</code> function that SFML provides, like so:</p><div><pre class="programlisting">while(!game.GetWindow()-&gt;IsDone()){
    // Game loop.
    game.HandleInput();
    game.Update();
    game.Render();
    <strong>sf::sleep(sf::seconds(0.2)); // Sleep for 0.2 seconds.</strong>
    game.RestartClock();
}</pre></div><p>Feel free to adjust the argument passed to the sleep function. You will notice that it moves the sprite across exactly the same distance, no matter how long each iteration takes to finish.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Fixed time-step</h1></div></div></div><p>In some<a id="id51" class="indexterm"/> cases, the code for time management that we've written doesn't really apply correctly. Let's say we only want to call certain methods at a fixed rate of 60 times per second. It could be a physics system that requires updating only a certain amount of times, or it can be useful if the game is grid-based. Whatever the case is, when an update rate is really important, a fixed time-step is your friend. Unlike the variable time-step, where the next update and draw happens as soon as the previous one is done, the fixed time-step approach will ensure that certain game logic is only happening at a provided rate. It's fairly simple to implement a fixed time-step. First, we must make sure that instead of overwriting the elapsed time value of the previous iteration, we add to it like so:</p><div><pre class="programlisting">void Game::RestartClock(){
    m_elapsed += m_clock.restart();
}</pre></div><p>The basic expression for calculating the amount of time for an individual update throughout a 1 second interval is illustrated here:</p><div><img src="img/4284_02_04.jpg" alt="Fixed time-step"/></div><p>Let's say we want our game to update <em>60</em> times a second. To find the frame time, we would divide <em>1</em> by <em>60</em> and check if the elapsed time has exceeded that value, as shown here:</p><div><pre class="programlisting">float frametime = 1.0f / 60.0f;

if(m_elapsed.asSeconds() &gt;= frametime){
    // Do something 60 times a second.
    ...
    m_elapsed -= sf::seconds(frametime); // Subtracting.
}</pre></div><p>Notice the subtraction at the end. This is how we reset the cycle and keep the simulation running at a <em>constant</em> speed. Depending on your application, you might want to put it to <em>sleep</em> in between updates in order to relieve the CPU. Aside from that detail, these are the bare bones of the fixed time-step. This is the exact technique that will be used in the game that<a id="id52" class="indexterm"/> we will finish building in the next chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Common mistakes</h1></div></div></div><p>Often, when<a id="id53" class="indexterm"/> using clocks, newbies to SFML tend to stick them in the wrong places and restart them at the wrong times. Things like that can result in "funky" behavior at best.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Keep in mind that every line of code that isn't empty or commented out takes time to execute. Depending on how a function that is being called, or a class that is being constructed, is implemented, the time value might range from miniscule to infinite.</p></div></div><p>Things like updating all of the game entities in the world, performing calculations, and rendering are fairly computationally expensive, so make sure to not somehow exclude these calls from the span of your time measurement. Always make sure that restarting the clock and grabbing the elapsed time is the <em>last</em> thing you're doing before the main game loop ends.</p><p>Another mistake is having your clock object within the wrong scope. Consider this example:</p><div><pre class="programlisting">void Game::SomeMethod(){
    sf::Clock clock;
    ...
    sf::Time time = clock.getElapsedTime();
}</pre></div><p>Assuming that the intention of this code was to measure anything else other than the time since the <code class="literal">sf::Clock</code> object was initiated, this code will produce faulty results. Creating an instance of a clock simply measures the time it has been alive within its scope, not anything else. This is the reason why the clock in the game class was declared as the class member. Since the clock is <em>created on the stack</em>, as soon as the method above concludes, the clock will be destroyed again.</p><p>Keeping an elapsed time in a <code class="literal">float</code> data type, or any other data type that isn't <code class="literal">sf::Time</code> for that matter, is also something that's generally frowned upon. Something like this would not be a great example of proper use of SFML:</p><div><pre class="programlisting">class Game{
...
private:
...
    float m_elapsed;
...
};</pre></div><p>Although it works, this isn't exactly type-safe. It also requires more type conversions along the way, since you have to call one of the three conversion methods each time the clock gets restarted. One more nail to seal the coffin would be code readability. SFML provides<a id="id54" class="indexterm"/> its own time class for a reason and convenience, so unless there's a good reason not to use it, do avoid any other data types.</p><p>One last thing that deserves a mention since we're talking about time is the console output in C++. While it's just fine to print something out every now and then, even for just debugging purposes, constant console spam will slow your application down. The console output itself is quite slow and cannot be expected to execute at exactly the same speed as the rest of your program. Printing something on every iteration of the main game loop, for example, would throttle your application speed horribly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>Congratulations on finishing the second chapter of this book! As mentioned previously, it is imperative that you understand everything covered in this chapter, since everything that follows will rely heavily on what we covered here.</p><p>Smooth and consistent results on different platforms and under different conditions are just as important as a good structure of an application, which is yet another layer of lasagna, if you will. Upon successful completion of this chapter, you are left yet again with sufficient knowledge to produce applications that can utilize both fixed and variable time-steps in order to create simulations that run identically and independently of the underlying architecture.</p><p>Finally, we will leave you with a piece of good advice. The first few chapters are something most readers follow relatively closely and literally. While that's an acceptable way of doing things, we'd prefer you to use this more like a guide instead of a recipe. The most amazing thing about human knowledge is that it isn't simply absorbed through endless memorization. Experimentation and gaining actual experience is the other half of the key to successfully mastering this, so go ahead and write code. Write it good or bad, compile it, or get a bunch of errors, run it or crash it, it's good either way. Try out new things and fail miserably in order to one day succeed spectacularly. You are well on your way to getting your hands dirty, as we will actually begin implementing our first game project for this book in the next chapter. See you there!</p></div></body></html>