- en: Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 光之诞生 - 高级光照简介
- en: There is a certain standard expected of a game in this day and age. As technology
    progresses and the number of transistors in any given computational unit increases,
    there is more and more power at our disposal to do what was previously unheard
    of. One thing that definitely makes use of all of this extra horse power is dynamic
    lighting. Because of its stunning visual results, it has become an integral part
    of most video games, and is now one of the core technologies that are expected
    to come with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时代，对游戏有一定的标准期望。随着技术的进步和任何给定计算单元中晶体管数量的增加，我们可用的能力越来越多，可以做到以前无法想象的事情。肯定利用了所有这些额外马力的就是动态光照。由于其惊人的视觉效果，它已经成为大多数视频游戏的一个基本组成部分，现在也是人们期望与之一起到来的核心技术之一。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the technique of deferred rendering/shading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延迟渲染/着色技术
- en: Implementing a multi-pass lighting shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多遍光照着色器
- en: Faking geometry complexity using normal maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用法线图伪造几何复杂性
- en: Using specular maps to create shiny surfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高光图创建闪亮的表面
- en: Using height maps to make lighting feel more three-dimensional
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高度图使光照感觉更立体
- en: Let's start shedding some light on this subject!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探讨这个主题的细节！
- en: Using third-party software
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方软件
- en: None of the material maps used in this chapter are hand-drawn. For the generation
    of certain material maps, *Crazybump* was used, which can be found at [http://crazybump.com/](http://crazybump.com/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有材料图都不是手工绘制的。为了生成某些材料图，使用了*Crazybump*，可以在[http://crazybump.com/](http://crazybump.com/)找到。
- en: There are other free alternatives that can be found online.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上还可以找到其他免费替代方案。
- en: Deferred rendering
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: Deferred rendering/shading is a technique that gives us greater control over
    how certain effects are applied to a scene by not enabling them during the first
    pass. Instead, the scene can be rendered to an off screen buffer, along with other
    buffers that hold other material types of the same image, and then drawn on the
    screen in a later pass, after the effects have been applied, potentially in multiple
    passes as well. Using this approach allows us to separate and compartmentalize
    certain logic that would otherwise be entangled with our main rendering code.
    It also gives us an opportunity to apply as many effects to the final image as
    we want. Let's see what it takes to implement this technique.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟渲染/着色是一种技术，它通过不在第一次遍历中启用某些效果来让我们对场景中某些效果的应用有更大的控制权。相反，场景可以被渲染到一个离屏缓冲区中，以及其他包含相同图像的其他材料类型的缓冲区，然后在效果应用之后，可能是在多个遍历之后，绘制到屏幕上。使用这种方法允许我们将某些逻辑与我们的主渲染代码分离和模块化。它还给我们提供了将尽可能多的效果应用到最终图像的机会。让我们看看实现这项技术需要什么。
- en: Modifying the renderer
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改渲染器
- en: 'In order to support all the fancy new techniques we''re about to utilize, we
    need to make some changes to our renderer. It should be able to keep a buffer
    texture and render to it in multiple passes in order to create the lighting we''re
    looking for:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们即将利用的所有新技巧，我们需要对我们的渲染器做一些修改。它应该能够保持一个缓冲纹理，并在多个遍历中渲染到它，以创建我们想要的光照：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For convenience, we have a couple of methods for toggling the deferred rendering
    process. Also, since rendering a scene to a texture is slightly different than
    rendering a texture to another texture, because of where the camera (view) is
    positioned, we will use the `BeginSceneRendering()` and `BeginTextureRendering()`
    methods to properly handle the task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们有一些方法可以切换延迟渲染过程。此外，由于渲染场景到纹理与渲染纹理到另一个纹理略有不同，因为相机的（视图）位置不同，我们将使用`BeginSceneRendering()`和`BeginTextureRendering()`方法来正确处理这项任务。
- en: Note the use of two textures in this class as well as a pointer to point to
    the texture that is currently in use. The essence of a multi-pass approach is
    being able to sample the texture holding the information of the previous render
    pass while drawing to the current render target.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个类中使用了两个纹理，以及一个指向当前正在使用的纹理的指针。多遍方法的核心是能够在绘制当前渲染目标的同时采样包含前一次渲染遍历信息的纹理。
- en: Lastly, we'll discuss three methods for clearing the current texture, the texture
    of a previous render pass, and both of these. The most recent render pass texture
    can then be rendered by calling the `DrawBufferTexture()` method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论三种清除当前纹理、前一个渲染通道的纹理以及这两个纹理的方法。然后，可以通过调用`DrawBufferTexture()`方法来渲染最新的渲染通道纹理。
- en: Implementing changes in the Renderer class
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`Renderer`类中实现更改
- en: 'Let''s start with something simple. Implement the deferred rendering toggle
    methods; they will help you keep track of the current rendering state:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始。实现延迟渲染切换方法；它们将帮助您跟踪当前的渲染状态：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, it's as simple as flipping a flag. In the case of enabling deferred
    rendering, we also need to check whether the use of shaders is allowed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这就像翻转一个标志一样简单。在启用延迟渲染的情况下，我们还需要检查是否允许使用着色器。
- en: 'Also, the textures we''re using as buffers clearly need to be created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们用作缓冲区的纹理显然需要被创建：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This particular method is invoked inside the constructor of `Renderer`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定方法是在`Renderer`构造函数中调用的。
- en: 'Next, we have something equally as simple, yet quite a bit more important:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些同样简单但更为重要的内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By using these methods at the appropriate time, we can successfully draw shapes
    that would have world coordinates for a standalone texture buffer the size of
    a window. We can also simply draw information from another window-sized texture
    to the buffer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在适当的时间使用这些方法，我们可以成功绘制出具有世界坐标的形状，这些形状对于一个独立纹理缓冲区来说大小为窗口大小。我们也可以简单地从另一个窗口大小的纹理中绘制信息到缓冲区。
- en: 'Some helpful getter methods are always useful:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的获取器方法总是很有用的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While the first one simply returns a pointer to the current buffer texture being
    used, the second method does the exact opposite. It determines which texture is
    *not* the current buffer; once it identifies this, it returns a pointer to that
    object instead. Why exactly this is useful will become apparent shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个方法只是返回当前正在使用的缓冲纹理的指针，但第二个方法则正好相反。它确定哪个纹理不是当前缓冲区；一旦确定，它就返回该对象的指针。为什么这会如此有用，我们很快就会明白。
- en: 'Clearing these textures is just as simple as one might think:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清除这些纹理就像人们想象的那样简单：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to prepare for another render pass and display all the changes made
    to the first buffer, the textures must be swapped like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备另一个渲染通道并显示对第一个缓冲区所做的所有更改，纹理必须这样交换：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the call to the texture's `display` method. Calling `display` is required
    because we want all of the changes made to the texture to be reflected. Without
    calling this method, our progress would not manifest.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对纹理的`display`方法的调用。调用`display`是必需的，因为我们希望纹理所做的所有更改都能反映出来。如果不调用此方法，我们的进度就不会显现。
- en: 'Another key alteration to this class is making sure the buffer texture is being
    used while deferred rendering is enabled:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个类的一个关键修改是确保在启用延迟渲染时使用缓冲纹理：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After a couple of checks to make sure we're not overwriting an already provided
    render target and that the use of shaders is enabled, we select the buffer texture
    by overwriting the `l_target` pointer with its address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行几项检查以确保我们不会覆盖已提供的渲染目标并且着色器使用已启用之后，我们通过覆盖`l_target`指针的地址来选择缓冲纹理。
- en: 'Finally, the buffer texture that has all of the render pass information can
    be drawn on the screen like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，包含所有渲染通道信息的缓冲纹理可以这样绘制到屏幕上：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple, yet powerful, design provides us with the possibilities of implementing
    almost any postprocessing effect imaginable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单而强大的设计为我们提供了实现几乎所有可想象的后处理效果的可行性。
- en: A minimal example
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个最小示例
- en: One of the effects incidentally, the focus of this chapter is dynamic lighting.
    Before we go further and implement the more advanced features or delve into more
    complex concepts, let's walk through the process of using the newly implemented
    renderer features. Let's take one step at a time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的一个效果，本章的重点是动态照明。在我们进一步实现更高级的功能或深入研究更复杂的概念之前，让我们逐步了解使用新实现的渲染器功能的过程。让我们一步一步来。
- en: 'First, the scene should be drawn to the texture buffer as usual:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，场景应该像往常一样绘制到纹理缓冲区：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, once deferred rendering is enabled, the default shader is used
    and the scene rendering process begins. For each layer, the map, entities, and
    particles are all drawn as usual. The only difference now is that the buffer texture
    is being used behind the scenes. Once everything is rendered, the textures are
    swapped; this allows the current back buffer texture to display all the changes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦启用延迟渲染，将使用默认的着色器，场景渲染过程开始。对于每一层，地图、实体和粒子都像往常一样绘制。现在唯一的区别是，在幕后使用缓冲纹理。一旦一切都被渲染，纹理被交换；这允许当前的背缓冲纹理显示所有变化：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the scene is rendered, we enter what from now on is going to be referred
    to as the light pass. This special pass uses its own shader and is responsible
    for the illumination of the scene. It sets up what is known as *ambient light*
    as well as regular omnidirectional light.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦场景被渲染，我们就进入从现在开始将被称作光照通道的阶段。这个特殊的通道使用它自己的着色器，并负责场景的照明。它设置了所谓的*环境光*以及常规的全向光。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Ambient light** is a type of light that has no position. It illuminates any
    part of the scene evenly, regardless of the distance.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境光**是一种没有位置的光。它均匀地照亮场景的任何部分，无论距离如何。'
- en: As illustrated in the preceding code, the point light first has its world coordinates
    converted into screen-space coordinates, which are then passed as a uniform to
    the shader. Then, the light color and radius are passed to the shader along with
    the texture of the previous pass, which, in this case, is simply the color (diffuse)
    map of the scene.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，点光源首先将它的世界坐标转换为屏幕空间坐标，然后作为统一变量传递给着色器。然后，将光颜色和半径传递给着色器，以及前一个通道的纹理，在这个例子中，仅仅是场景的颜色（漫反射）图。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Point light** is a type of light that emits light in all directions (omnidirectional)
    from a single point, creating a sphere of illumination.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**点光源**是一种从单个点向所有方向（全向）发射光的光源，形成一个照明球体。'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The screen-space coordinate system has its *Y* axis inversed from the world
    coordinate format, meaning the positive *Y* values go up, not down. This is the
    reason the light position's *Y* coordinate has to be adjusted before it is passed
    to the shader.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕空间坐标系中的*Y*轴与世界坐标格式相反，这意味着正的*Y*值向上而不是向下。这就是为什么在传递给着色器之前必须调整光位置*Y*坐标的原因。
- en: 'The next portion of the code is essentially meant to just trigger a full redraw
    of the diffuse texture onto the buffer texture. We''re making a quad comprised
    of two triangular strips represented as `sf::VertexArray`. It''s made to be the
    size of the entire window so that all the pixels could surely be redrawn. Once
    the quad is drawn, the textures are once again swapped to reflect all the changes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分主要是用来触发将漫反射纹理完整重绘到缓冲纹理上的操作。我们创建了一个由两个三角形条组成的四边形，表示为`sf::VertexArray`。它的大小被设置为整个窗口的大小，以确保所有像素都能被重绘。一旦四边形被绘制，纹理再次交换以反映所有变化：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last bit of this example simply turns off deferred rendering so that all
    render operations from now on are done to the window. The window view is then
    set to its default state, so that the buffer texture can be drawn onscreen easily.
    Finally, we reset the view back, shortly before whatever shader is still active
    is disabled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的最后一部分只是关闭了延迟渲染，这样从现在开始所有的渲染操作都将对窗口进行。然后设置窗口视图为默认状态，以便缓冲纹理可以轻松地绘制到屏幕上。最后，在禁用任何仍然活跃的着色器之前，我们重新设置了视图。
- en: Shader code
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器代码
- en: 'We''re almost done! The last, but definitely not the least, important piece
    of this puzzle is writing the lighting pass shader correctly in order to get proper
    results. Given what we already know about the light pass procedure in our C++
    code, let''s see what GLSL has to offer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！这个谜题中最后但绝对不是最不重要的一个部分是正确编写光照通道着色器以获得正确的结果。鉴于我们已经在C++代码中对光照过程有所了解，让我们看看GLSL能提供什么：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As expected, we need to process the diffuse texture in this pass in order to
    preserve color information. The other uniform values consist of a 3D vector that
    represents the ambient color, two 3D vectors for the position and color of a regular
    source of light, and a floating point value for the radius of the same light.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们需要在这个通道中处理漫反射纹理以保留颜色信息。其他统一值包括表示环境颜色的3D向量，两个表示常规光源位置和颜色的3D向量，以及表示相同光源半径的浮点值。
- en: 'The texture that was passed to the shader is sampled at the appropriate, interpolated
    texture coordinates and stored in the `pixel` variable. The distance between the
    pixel being processed and the light''s center is then calculated using the Pythagorean
    variant distance formula:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给着色器的纹理在适当的插值纹理坐标处采样，并存储在 `pixel` 变量中。然后使用勾股定理距离公式计算正在处理的像素与光源中心的距离：
- en: '![Shader code](img/B05590_08_01-1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![着色器代码](img/B05590_08_01-1.jpg)'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `gl_FragCoord` parameter holds the pixel coordinates in the screen space.
    Its *Z* component is a depth value, which we're not going to use for the time
    being.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_FragCoord` 参数在屏幕空间中持有像素坐标。它的 *Z* 分量是一个深度值，目前我们不会使用它。'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `pow` function simply returns a value that is raised to the power of its
    second argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow` 函数简单地返回一个值，该值是其第二个参数的幂。'
- en: After the distance is calculated, a check is made to determine whether the distance
    between the light and the pixel we're working with is within the light's radius.
    If it is, the color information of our pixel is multiplied by the light color
    and added to the final pixel that's going to be written. Otherwise, the color
    information is simply multiplied by the ambient color.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算距离之后，会进行检查以确定我们正在处理的光与像素之间的距离是否在光源的半径内。如果是，我们的像素的颜色信息将与光颜色相乘并添加到最终要写入的像素中。否则，颜色信息将简单地乘以环境颜色。
- en: 'This fairly basic principle gives us, as one should expect, fairly basic and
    non-realistic lighting:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当基本的原则给我们带来了，正如预期的那样，相当基本和非现实的光照效果：
- en: '![Shader code](img/image_08_002.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![着色器代码](img/image_08_002.jpg)'
- en: Although it works, in reality, light is emitted in all directions. It also slowly
    loses its brightness. Let's see what it takes to make this happen in our game.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可行，但在现实中，光线是向所有方向发射的。它也会逐渐失去亮度。让我们看看在我们的游戏中实现这一效果需要什么。
- en: Attenuating light
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线衰减
- en: 'Light attenuation, also known as gradual loss in intensity, is what we''re
    going to use when creating the effect of a light source that is slowly bleeding
    away. It essentially comes down to using yet another formula inside the light
    pass shader. There are many variations of attenuating light that work for different
    purposes. Let''s take a look:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 光线衰减，也称为强度逐渐减弱，是我们将在创建光源逐渐减弱效果时使用的技术。它本质上归结为在光线通过着色器中使用另一个公式。有许多衰减光线的变体适用于不同的目的。让我们看看：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once again, we're dealing with the same uniform values being passed in, but
    with one additional value of `LightFalloff`. It's a factor between *0* and *1*
    that determines how fast a source of light would lose its brightness.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们处理的是相同的统一值，但增加了一个额外的 `LightFalloff` 值。这是一个介于 *0* 和 *1* 之间的因子，决定了光源亮度衰减的速度。
- en: Inside the `main()` function, the diffused pixel is sampled as usual. This is
    done before we calculate a vector `L` that represents the position difference
    between the pixel and the light's center. This vector is then converted into distance
    using the `length` function. This is the same type of distance that we calculated
    manually in the first iteration of this shader. The floating number variable `d`
    is then used to calculate the distance between the fragment and the outside of
    the light by subtracting the light's radius from it. The `max()` function simply
    makes sure we don't get a negative value back if the pixel is inside the light's
    bubble.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数内部，漫反射像素按常规采样。这在我们计算表示像素与光源中心位置差异的向量 `L` 之前完成。然后使用 `length` 函数将此向量转换为距离。这是我们在这个着色器的第一次迭代中手动计算的那种类型的距离。然后使用浮点数变量
    `d` 通过从光源半径中减去它来计算片段与光源外部的距离。`max()` 函数确保如果像素在光源的气泡内部，我们不会得到一个负值。
- en: The attenuation itself, as mentioned before, can have many variations. This
    particular variation visually works best for the type of game we're dealing with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，衰减本身可以有多种变体。这种特定的变体在视觉上最适合我们正在处理的类型游戏。
- en: 'After the calculations are performed, the final output pixel is multiplied
    by the ambient light (which should only be done during the first pass if there
    are multiple light passes). Additionally, the light information is multiplied
    by the diffuse pixel and the attenuation factor is added to it. This last bit
    of multiplication ensures that, given the pixel is outside the effective light
    range, no additional light is added to it. The result of this is slightly more
    appealing to look at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算完成后，最终输出像素乘以环境光（如果有多遍光遍历，则仅在第一遍执行）。此外，光信息乘以漫反射像素，并将衰减因子加到它上面。这次乘法确保了，如果像素在有效光范围内，则不会添加额外的光。结果是稍微更吸引人：
- en: '![Attenuating light](img/image_08_003.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![衰减光](img/image_08_003.jpg)'
- en: At this point, a very good question you could ask is 'How on earth is this going
    to work with multiple light input?' Luckily, this is a bit simpler than one might
    think.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以提出一个非常好的问题：“究竟如何才能处理多个光源输入？”幸运的是，这比想象中要简单一些。
- en: Multi-pass shading
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多遍着色
- en: Much like *C/C++* code, GLSL does support the use of data arrays. Using them
    can seem like an obvious choice to just push information about multiple light
    streams into the shader and have it all done in one pass. Unlike *C++*, however,
    GLSL needs to know the sizes of these arrays at compile time, which is very much
    like *C*. At the time of writing, dynamic size arrays aren't supported. While
    this information can put a damper on a naive plan of handling multiple light sources
    with ease, there are still options to choose from, obviously.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 *C/C++* 代码一样，GLSL 也支持使用数据数组。使用它们似乎是一个明显的选择，只需将关于多个光流的信息推送到着色器，并在一次遍历中完成所有操作。然而，与
    *C++* 不同的是，GLSL 需要在编译时知道这些数组的大小，这非常类似于 *C*。截至写作时，动态大小数组还不受支持。虽然这个信息可能会让处理多个光源的简单计划变得困难，但显然还是有其他选择。
- en: One approach to combat this may be to have a very large, statically sized array
    of data. Only some of that data would be filled in and the shader would process
    it by looping over the array while using a uniform integer that tells it how many
    lights were actually passed to it. This idea comes with a few obvious bottlenecks.
    First, there would be a threshold for the maximum number of light streams allowed
    on the screen. The second issue is performance. Sending data over to the GPU is
    costly and can quickly become inefficient if we send over too much information
    all at once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对抗这种情况的方法可能是使用一个非常大的、静态大小的数据数组。只有其中的一部分数据会被填充，着色器会通过遍历数组来处理它，同时使用一个统一的整数来告诉它实际传递给它多少个光源。这个想法有几个明显的瓶颈。首先，屏幕上允许的最大光流数量会有一个阈值。第二个问题是性能。将数据发送到
    GPU 是昂贵的，如果我们一次性发送过多的信息，这会迅速变得低效。
- en: 'As flawed as the first idea is, it has one component that comes in handy when
    considering a better strategy: the maximum number of light streams allowed. Instead
    of pushing tons and tons of data through to the GPU at once, why not just do it
    a little bit at a time in different passes. If the right number of light streams
    is sent each time, both the CPU and GPU performance bottlenecks can be minimized.
    The results of each pass can then be blended together into a single texture.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一个想法有缺陷，但它有一个在考虑更好的策略时很有用的组成部分：允许的最大光流数量。为什么不一次只发送一小部分数据，在不同的遍历中进行呢？如果每次发送正确数量的光流，CPU
    和 GPU 的性能瓶颈都可以最小化。然后，可以将每个遍历的结果混合成一个单一的纹理。
- en: Modifying the light pass shader
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改光遍历着色器
- en: There are a couple of challenges we need to overcome in order to correctly blend
    the buffer textures of multiple passes. First, there's loss of information due
    to ambient lighting. If the light is too dark, every subsequent pass becomes less
    and less visible. To fix this problem, in addition to the color information of
    the last render pass, we're going to need access to the actual diffuse map.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确混合多个遍历的缓冲区纹理，我们需要克服一些挑战。首先，由于环境光，信息会有损失。如果光线太暗，后续的遍历就会越来越不明显。为了解决这个问题，除了最后渲染遍历的颜色信息外，我们还需要访问实际的漫反射图。
- en: 'The second issue is choosing the right number of light streams per shader pass.
    This can be benchmarked or simply gotten right through trial and error. For our
    purposes, we''ll go with 3-4 light streams per pass. Let''s take a look at how
    the light shader can be modified to achieve this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是选择每个着色器传递的光流数量。这可以通过基准测试或简单地通过试错得到正确答案。就我们的目的而言，我们将选择每个传递3-4条光流。让我们看看如何修改光着色器以实现这一点：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, note the new `sampler2D` uniform type being passed in for the diffuse
    map. This is going to be invaluable in order to avoid light colors from being
    washed out with additional passes. The other two bits of additional information
    we're going to need are values that determine the number of light streams that
    have been sent to the shader for the current pass and the pass we're dealing with
    at the moment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意新的 `sampler2D` 统一类型，它被传递给漫反射图。这将非常有价值，以避免在额外的传递中光颜色被冲淡。我们将需要的其他两块额外信息是确定发送到当前传递的着色器的光流数量的值，以及我们目前正在处理的传递。
- en: The actual light information is now neatly stored away in a `struct` that holds
    the usual data we expect. Underneath it, we need to declare a constant integer
    for the number of maximum light streams per shader pass and the uniform array
    that's going to be filled in by our C++ code for the light information.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的光信息现在被整洁地存储在一个 `struct` 中，该 `struct` 包含我们期望的常规数据。在其下方，我们需要声明一个表示每个着色器传递最大光流数量的常量整数，以及将被我们的C++代码填充光信息的统一数组。
- en: 'Let''s see the changes that the body of the shader needs to undergo in order
    to support this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看着色器主体需要经历哪些变化才能支持这一点：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we need to sample the diffuse pixel as well as the pixel from the previous
    shader pass. The `finalPixel` variable is established early on and uses the information
    from the previous shader pass. It is important you note this, because the previous
    pass would be lost otherwise. Since we have access to the pass number in the shader
    now, we can selectively apply the ambient light to the pixel only during the first
    pass.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要采样漫反射像素以及来自前一个着色器传递的像素。`finalPixel` 变量在早期就建立了，并使用前一个着色器传递的信息。请注意这一点，因为否则前一个传递将会丢失。由于我们现在可以在着色器中访问传递编号，因此我们可以在第一个传递期间仅对像素应用环境光。
- en: We can then jump into a `for` loop that uses the `LightCount` uniform passed
    in from the C++ side. This design gives us control to only use as much data as
    was sent to the shader and not go overboard if the last shader pass has fewer
    light streams than the maximum number allowed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以跳入一个 `for` 循环，该循环使用从C++端传入的 `LightCount` 常量。这种设计让我们能够只使用发送到着色器的数据，而不会过度使用，如果最后一个着色器传递的光流数量少于允许的最大数量。
- en: Finally, let's see what needs to change when it comes to the actual shading
    of the fragment. All our calculations remain the same, except for using light
    data. The lights uniform is now accessed with the square brackets to fetch the
    correct information during each iteration of the loop. Note the final pixel calculation
    at the very bottom of the loop. It now uses the diffuse pixel instead of the pixel
    of a previous shader pass.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看在片段的实际着色方面需要做出哪些改变。我们的所有计算保持不变，只是现在使用光数据。灯光常量现在通过方括号访问，以在循环的每次迭代中获取正确的信息。注意循环底部的最终像素计算。现在它使用漫反射像素而不是前一个着色器传递的像素。
- en: Changes in the C++ code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++代码中的更改
- en: 'None of the fanciness in the GLSL we''ve just finished is complete without
    appropriate support from our actual code base. First, let''s start with something
    simple and conveniently represent a light stream in a proper `struct`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的GLSL中的所有花哨之处，如果没有我们实际代码库的适当支持，都是不完整的。首先，让我们从简单的东西开始，并方便地在一个合适的 `struct`
    中表示光流：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s better! Now let''s begin passing in all of the additional information
    to the shader itself:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好了！现在让我们开始将所有额外的信息传递给着色器本身：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Right after we're done with drawing onto the diffuse texture, it's copied over
    and stored in a separate buffer. It's then flipped along the *Y* axis, as the
    copying process inverts it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成绘制到漫反射纹理之后，它被复制并存储在一个单独的缓冲区中。然后它沿 *Y* 轴翻转，因为复制过程会反转它。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The copying and flipping of the texture here is a proof of concept. It shouldn't
    be performed in production code, as it's highly inefficient.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里纹理的复制和翻转只是一个概念验证。它不应该在生产代码中执行，因为它非常低效。
- en: At this point, we're ready to begin the light pass. Just before we start this,
    ensure that a couple of light streams are added to `std::vector` and are waiting
    to be passed in. Also, declare a constant at the very bottom that denotes how
    many light streams are supposed to be passed to a shader every time. This number
    has to match the constant inside the shader.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好开始光照遍历。在我们开始之前，确保添加了一些光照流到`std::vector`中，并等待传递。此外，在底部声明一个常量，表示每次传递给着色器的光照流数量。这个数字必须与着色器内部的常量匹配。
- en: 'Let''s begin with the actual light pass and see what it involves:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实际的轻量级遍历开始，看看它包含哪些内容：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ambient lighting is first set up, as it's not going to change between the iterations.
    In this case, we're giving it a slight blue tint. Additionally, a couple of local
    variables for the iteration and pass are created in order to have this information
    handy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光照首先设置，因为它在迭代之间不会改变。在这种情况下，我们给它一点蓝色调。此外，还创建了几个用于迭代和遍历的局部变量，以便随时获取这些信息。
- en: 'As we''re iterating over each light stream, a string called `id` is created
    with the integer of each iteration passed inside. This is meant to represent the
    array access analysis of the light streams'' uniform inside the shader, and it
    will serve as a helpful way of allowing us to access and overwrite that data.
    The light information is then passed in using the `id` string with an attached
    dot operator and the name of the `struct` data member. The light''s identifier
    `i` is incremented shortly after. At this point, we need to decide whether the
    required number of light streams have been processed in order to invoke the shader.
    If the last light stream for the pass has been added, or if we''re dealing with
    the last light stream of the scene, the rest of the uniforms are initialized and
    the fullscreen `sf::VertexArray` quad we talked about earlier is drawn, invoking
    a shader for each visible pixel. This effectively gives us a result like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历每个光照流时，会创建一个名为`id`的字符串，其中包含每次迭代的整数。这是为了表示着色器内部光照流的统一数组访问分析，它将作为帮助我们访问和覆盖这些数据的有用方式。然后使用带有附加点操作符的`id`字符串和`struct`数据成员的名称，通过`id`字符串传递光照信息。不久之后，光照标识符`i`会增加。在这个时候，我们需要决定是否已经处理了所需数量的光照流，以便调用着色器。如果已经添加了遍历的最后一个光照流，或者我们正在处理场景的最后一个光照流，那么将初始化其余的统一变量，并绘制我们之前提到的全屏`sf::VertexArray`四边形，为每个可见像素调用一个着色器。这实际上给我们一个这样的结果：
- en: '![Changes in the C++ code](img/image_08_004.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![C++代码中的更改](img/image_08_004.jpg)'
- en: Now we're getting somewhere! The only downside to this is all of the mess we
    have to deal with in our C++ code, as none of this data is managed properly. Let's
    fix this now!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有进展了！这个方法的唯一缺点是我们必须处理C++代码中的所有混乱，因为所有这些数据都没有得到妥善管理。现在就让我们来解决这个问题吧！
- en: Managing light input
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理光照输入
- en: Good data organization is important in every aspect of software design. It's
    hard to imagine an application that would run quickly and efficiently, yet wants
    have a strong, powerful, and flexible framework running in the backend. Our situation
    up until this point has been fairly manageable, but imagine you want to draw additional
    textures for the map, entities, and all your particles. This would quickly become
    tiresome to deal with and maintain. It's time to utilize our engineering ingenuity
    and come up with a better system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计的各个方面，良好的数据组织都很重要。很难想象一个运行快速且高效的程序，同时希望在后台运行一个强大、强大且灵活的框架。到目前为止，我们的情况相当容易管理，但想象一下，如果你想为地图、实体以及所有的粒子绘制额外的纹理。这很快就会变得令人厌烦，难以维护。是时候利用我们的工程智慧，提出一个更好的系统了。
- en: Interface for light users
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于轻量级用户
- en: 'First and foremost, each class that desires to use our lighting engine would
    need to implement their own version of drawing certain types of textures to the
    buffer(s). For diffuse maps, we already have the plain old regular `Draw` calls,
    but even if they are all lucky enough to have the same signature, that''s not
    good enough. A common interface for these classes is needed in order to make them
    a successful part of the lighting family:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首要的是，任何希望使用我们的光照引擎的类都需要实现它们自己的版本，将某些类型的纹理绘制到缓冲区（s）。对于漫反射贴图，我们已经有普通的`Draw`调用，但即使它们都有相同的签名，这也还不够好。这些类需要一个通用的接口，以便它们成为光照家族中成功的部分：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `LightUser` class forces any derivatives to implement a special `Draw` method
    that uses a material container. It also has access to the `Window` class and knows
    which layer it's trying to draw to. 'What's a material container?' you may ask?
    Let's find out by taking this design further.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightUser`类强制任何派生类实现一个特殊的`Draw`方法，该方法使用材料容器。它还可以访问`Window`类，并知道它试图绘制到哪个层。你可能会问：“什么是材料容器？”让我们通过进一步探讨这个设计来找出答案。'
- en: The light manager class
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光管理器类
- en: 'Before we design a grand class that would take care of all our lighting needs,
    let''s talk about materials. As it so happens, we''ve already dealt with one type
    of material: the diffuse map. There are many other possible materials we''re going
    to work with, so let''s not beat around the bush any longer and see what they
    are:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设计一个可以处理所有照明需求的大类之前，让我们谈谈材料。碰巧的是，我们已经处理过一种类型的材料：漫反射贴图。我们还将使用许多其他可能的材料，所以我们不再绕弯子，来看看它们是什么：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition to diffuse maps, we're going to build *height*, *normal*, and *specular*
    maps as well. None of these terms will probably make sense right now, but that's
    alright. Each one will be explained in detail as we cross that bridge.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了漫反射贴图，我们还将构建*高度*、*法线*和*镜面*贴图。现在这些术语可能都不太容易理解，但没关系。随着我们一步步深入，每个术语都会被详细解释。
- en: The material map container type is simply a map that links a type to a `sf::RenderTexture`.
    This way, we can have a separate texture for each material type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 材料贴图容器类型只是一个将类型链接到`sf::RenderTexture`的映射。这样，我们可以为每种材料类型拥有一个单独的纹理。
- en: 'For the light manager, we''re only going to need two type definitions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于光管理器，我们只需要两个类型定义：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, they''re extremely simple. We''re going to store the light
    streams themselves along with pointers to the light user classes in vectors, as
    nothing fancier is necessary here. With that, let''s take a look at the actual
    definition of the `LightManager` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们极其简单。我们将存储光流本身以及指向光用户类的指针，因为这里不需要更复杂的东西。有了这个，让我们看看`LightManager`类的实际定义：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, this is as basic as it can be. The constructor takes in a pointer
    to the `Window` class. We have a couple of `add`methods for the light users, as
    well as the light streams themselves. We also have a few render methods for specific
    tasks. Note the constant integer that this class defines for the maximum number
    of light streams allowed per shader pass. Rendering only three light streams like
    we did before is a bit wasteful, so this can be upped even more, provided it doesn't
    become detrimental to the performance of the process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这已经是最基本的了。构造函数接收一个指向`Window`类的指针。我们为轻度用户提供了几个`add`方法，以及轻量级流本身。我们还为特定任务提供了一些渲染方法。注意这个类定义的常量整数，它表示每个着色器通道允许的最大光流数量。像我们之前那样只渲染三个光流有点浪费，所以这个数字可以进一步提高，前提是不会对处理过程的性能产生不利影响。
- en: The helper methods of which there are three--deal with clearing the buffer textures,
    setting their views, and displaying the changes made to them. We also store the
    `sf::VertexArray` of the quad that we're going to use to perform a light pass
    operation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中有三个辅助方法--处理清除缓冲区纹理、设置它们的视图以及显示对它们的更改。我们还存储了我们将用于执行光通操作的四边形的`sf::VertexArray`。
- en: Implementing the light manager
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现光管理器
- en: 'As always, let''s begin by seeing what needs to be constructed when the light
    manager is created:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，让我们先看看当创建光管理器时需要构建什么：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The initializer list is useful for storing the `Window` pointer, as well as
    initializing the ambient lighting to absolute black. Once this is done, the window
    size is obtained and all the material textures are created. Lastly, the window-sized
    quad is set up for later use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表对于存储`Window`指针以及将环境光照初始化为绝对黑色很有用。一旦完成，就获取窗口大小并创建所有材料纹理。最后，设置窗口大小的四边形以供以后使用。
- en: 'The adder and getter methods are quite simple, yet they are necessary:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加器和获取器方法相当简单，但它们是必要的：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Dealing with material maps all at once can be quite wasteful typing-wise, so
    we need a few methods to help us do this quickly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 处理所有材料贴图一次在打字上可能会相当浪费，因此我们需要一些方法来帮助我们快速完成这项工作：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note the view we're using in `SetViews()`. Since these material maps are going
    to be used instead of the window, they must use the window's view in order to
    handle the world coordinates of all the visuals being drawn.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`SetViews()`中使用的视图。由于这些材料贴图将代替窗口使用，它们必须使用窗口的视图来处理所有被绘制视觉的世界坐标。
- en: 'Speaking of material maps, every class that wishes to use our light manager
    should be able to draw to every single one of them. Luckily, we''ve made it easier
    on ourselves by making it a requirement that these classes implement a purely
    virtual `Draw` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 说到材质贴图，任何希望使用我们的光照管理器的类都应该能够绘制到其中的每一个。幸运的是，我们已经通过使这些类实现一个纯虚`Draw`方法来简化了这一点：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After all the textures are cleared and their views are set, each light user
    needs to draw something for each of the allowed layers our game engine supports.
    Quite literally, on top of this, any visuals that are above these elevations also
    need to have a chance to be rendered, which we can achieve by using the second
    loop. All the material textures are then updated by invoking the `DisplayAll()`
    method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有纹理都被清除并设置其视图之后，每个光照用户都需要为游戏引擎支持的每个允许的层绘制一些内容。实际上，在这些高度之上的任何视觉元素也需要有机会被渲染，这可以通过使用第二个循环来实现。然后通过调用`DisplayAll()`方法更新所有材质纹理。
- en: 'Once the materials are drawn, we need to go through the same process of multi-pass
    shading as we did in our minimal code example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 材质绘制完成后，我们需要进行与我们在最小代码示例中所做的多通道着色相同的处理过程：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is very close to the already established model we discussed before. A
    couple of changes to note here are: the use of an internal data member called
    `m_materialMaps` for passing material information to the light pass shader and
    the check near the bottom where the diffuse texture is passed in as the `"LastPass"`
    uniform if it is the very first shader pass. This has to be done otherwise we''d
    be sampling a completely black texture.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前讨论的已建立模型非常相似。这里需要注意的是一些更改：使用一个名为`m_materialMaps`的内部数据成员来将材质信息传递给光照通道着色器，以及在底部附近检查的地方，如果这是第一个着色器通道，则将漫反射纹理作为`"LastPass"`统一变量传递。否则，我们将采样一个完全黑色的纹理。
- en: Integrating the light manager class
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成光照管理器类
- en: 'Once the light manager is implemented, we can add all the classes that use
    it to its list:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 光照管理器实现后，我们可以将其添加到使用它的所有类的列表中：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, we're only working with the game map, the system manager, and
    the particle manager classes as light users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只与游戏地图、系统管理器和粒子管理器类作为光照用户一起工作。
- en: 'Setting up our previous light information is equally as easy now as it was
    before:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们之前的光照信息现在与之前一样简单：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we just need to make sure the material maps are drawn, just like the
    scene itself:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需确保材质贴图被绘制，就像场景本身一样：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, the only thing left to do is to adapt those pesky classes to the new lighting
    model we have set up here.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的事情就是将这些讨厌的类适配到我们在这里设置的新光照模型中。
- en: Adapting classes to use lights
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类适配以使用光照
- en: Obviously, each and every single class that does any rendering in our game does
    it differently. Rendering the same graphics to different types of material maps
    is no exception to this rule. Let's see how every light-supporting class should
    implement their respective `Draw` methods in order to stay in sync with our lighting
    system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们游戏中每个进行渲染的类都有其独特的渲染方式。将相同的图形渲染到不同类型的材质贴图上也不例外。让我们看看每个支持光照的类应该如何实现它们各自的`Draw`方法，以确保与我们的光照系统保持同步。
- en: The Map class
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Map`类'
- en: 'The first class we need to deal with is the `Map` class. It will be a bit different
    due to the way it handles the drawing of tiles. So let''s take a look at what
    needs to be added in:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先处理的是`Map`类。由于它处理瓦片绘制的方式不同，所以会有所不同。让我们看看需要添加什么：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So far, so good! The `Map` class is now using the `LightUser` interface. The
    `m_textures` data member is an established array that existed before all of this
    and it simply stores different textures for each supported elevation. One new
    protected member function is added though, called `CheckTextureSizes`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！`Map`类现在正在使用`LightUser`接口。`m_textures`数据成员是一个在所有这些之前就存在的已建立数组，它简单地存储每个支持高度的纹理。尽管如此，还是增加了一个新的受保护成员函数，名为`CheckTextureSizes`：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is just a handy way of making sure all the future textures, as well as
    the current diffuse maps, have the appropriate size.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是一种确保所有未来的纹理，以及当前的漫反射贴图，都有适当大小的便捷方式。
- en: 'Let''s see what the `Redraw` method now needs to do in order to fully support
    the light manager:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Redraw`方法现在需要做什么，以便完全支持光照管理器：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Only a few extra lines add the support here. We just need to make sure the renderer
    is involved when the drawing is happening because it allows the right shader to
    be used in the process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加几行额外的代码即可添加支持。我们只需确保在绘图发生时渲染器被涉及，因为这允许在过程中使用正确的着色器。
- en: 'Since we''re going to add more material maps quite soon, clearing of these
    textures also needs to be integrated into the existing code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们很快就会添加更多的材质图，因此这些纹理的清除也需要集成到现有代码中：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The spaces for doing so are marked with comments, which is exactly the same
    for the helper methods that aid in displaying all the changes made to these buffer
    textures:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的空间用注释标记，这与辅助方法完全相同，这些方法有助于显示对这些缓冲区纹理所做的所有更改：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The actual `Draw` method from the `LightUser` class can be implemented like
    this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightUser` 类的实际 `Draw` 方法可以像这样实现：'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because of the way the `Map` class works, all we have to do is set up the sprite
    we're working with to use the right texture for the appropriate material type.
    In this case, all we need is the diffuse texture.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Map` 类的工作方式，我们只需设置我们正在处理的精灵使用适当的材质类型的正确纹理。在这种情况下，我们只需要漫反射纹理。
- en: The entity renderer system
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体渲染系统
- en: 'If you recall, the `SystemManager` class is the one we added to `LightManager`
    as `LightUser`. Although there''s only one system that does the rendering for
    now, we still want to keep it this way and simply forward all the arguments passed
    to `SystemManager`. This keeps our options for additional systems doing the same
    thing open in the future:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`SystemManager` 类是我们添加到 `LightManager` 作为 `LightUser` 的。尽管现在只有一个系统负责渲染，我们仍然希望保持这种方式，并且简单地转发传递给
    `SystemManager` 的所有参数。这保留了未来添加执行相同任务的其他系统的选项：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The forwarded arguments are sent to `S_Renderer` and can be used like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 转发的参数被发送到 `S_Renderer` 并可以像这样使用：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s fairly similar to how the `Map` class handles its redrawing process.
    All we need to do is make sure the Renderer class is used to do the drawing to
    the diffuse texture, which is what happens under the hood, as `C_Drawable` simply
    passes these arguments down the line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Map` 类处理其重绘过程的方式相当相似。我们只需确保使用 `Renderer` 类将绘图绘制到漫反射纹理上，这是在底层发生的，因为 `C_Drawable`
    简单地将这些参数传递下去：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The particle system
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子系统
- en: 'Drawing particles in this way is not much different from how other `LightUser`
    do it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式绘制粒子与其他 `LightUser` 的方式没有太大区别：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once again, it's all about making sure the materials are passed through `Renderer`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这一切都是为了确保材质通过 `Renderer` 传递。
- en: Preparing for additional materials
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备额外的材质
- en: 'Drawing basic light streams is fairly nifty. But let''s face it, we want to
    do more than that! Any additional processing is going to require further material
    information about the surfaces we''re working with. As far as storing those materials
    goes, the `Map` class needs to allocate additional space for textures that will
    be used for this purpose:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式绘制基本的光流相当巧妙。但让我们面对现实，我们想要做的不仅仅是这些！任何额外的处理都需要关于我们正在处理的表面的进一步材质信息。至于存储这些材质，`Map`
    类需要为用于此目的的纹理分配额外的空间：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These textures will also need to be checked for incorrect sizes and adjusted
    if it ever comes to that:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些纹理还需要检查其尺寸是否正确，并在必要时进行调整：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Clearing the material maps is equally as simple; we just need to add a couple
    of extra lines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 清除材质图同样简单；我们只需添加几行额外的代码：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Displaying the changes that were made to the buffer textures follows the same
    easy and manageable approach:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对缓冲区纹理所做的更改遵循相同简单且易于管理的做法：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, drawing this information to the internal buffers of `LightManager`,
    in the case of the `Map` class, can be done like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将此信息绘制到 `LightManager` 的内部缓冲区，对于 `Map` 类，可以这样做：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Easy enough? Good! Let's keep progressing and build shaders that can handle
    the process of drawing these material maps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 容易吗？很好！让我们继续前进，构建可以处理绘制这些材质图的过程的着色器。
- en: Preparing the texture manager
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备纹理管理器
- en: 'In order to automatically load the additional material maps when loading diffuse
    images, we need to make some very quick and painless changes to the `ResourceManager`
    and `TextureManager` classes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在加载漫反射图像时自动加载额外的材质图，我们需要对 `ResourceManager` 和 `TextureManager` 类进行一些非常快速且不痛苦的修改：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By adding the `OnRequire()` and `OnRelease()` methods and integrating them properly
    with the `l_notifyDerived` flag to avoid infinite recursion, `TextureManager`
    can safely load in both the normal and specular material maps when a diffuse texture
    is loaded, provided they are found. Note that the texture manager actually passes
    in `false` as the second argument when it needs these maps to avoid infinite recursion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`OnRequire()`和`OnRelease()`方法，并正确地将它们与`l_notifyDerived`标志集成以避免无限递归，当加载漫反射纹理时，`TextureManager`可以安全地加载法线和镜面材质图，前提是它们被找到。请注意，当纹理管理器需要这些图时，实际上会将`false`作为第二个参数传递，以避免无限递归。
- en: Material pass shaders
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材质通道着色器
- en: 'There will be two types of material pass shaders we''ll use. One type, simply
    referred to as *MaterialPass*, will sample the material color from a texture:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种类型的材质通道着色器。一种类型，简单地称为*MaterialPass*，将从纹理中采样材质颜色：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It retrieves the diffuse pixel and the material texture pixel, as well as uses
    the diffuse alpha value to display the right color. This effectively means that
    if we're dealing with a transparent pixel on a diffuse map, no material color
    is going to be rendered for it. Otherwise, the material color is completely independent
    of the diffuse pixel. This is useful for drawing images that also have material
    maps located in a different texture.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它检索漫反射像素和材质纹理像素，并使用漫反射alpha值来显示正确的颜色。这意味着，如果我们处理的是漫反射图上的透明像素，则不会为其渲染材质颜色。否则，材质颜色与漫反射像素完全独立。这对于绘制同时具有位于不同纹理中的材质图的图像非常有用。
- en: 'The second type of material shader, known from here on out as *MaterialValuePass*,
    will also sample the diffuse pixel. Instead of using a material texture, however,
    it''ll simply use a static color value for all the pixels that aren''t transparent:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的材质着色器，从现在起称为*MaterialValuePass*，也将采样漫反射像素。然而，它不会使用材质纹理，而是简单地为所有非透明像素使用静态颜色值：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we first verify that the sampled pixel isn't completely black. If it is,
    the `alpha` value of `gl_Color` is used instead of that of the pixel. Then, we
    simply write the static material color value to the fragment. This type of shader
    is useful for drawable objects that don't have material maps and instead use a
    static color for every single pixel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先验证采样像素不是完全黑色的。如果是，则使用`gl_Color`的`alpha`值而不是像素的`alpha`值。然后，我们只需将静态材质颜色值写入片段。这种着色器对于没有材质图且每个像素都使用静态颜色的可绘制对象非常有用。
- en: Normal maps
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法线图
- en: Lighting can be used to create visually complex and breath taking scenes. One
    of the massive benefits of having a lighting system is the ability it provides
    to add extra details to your scene, which wouldn't have been possible otherwise.
    One way of doing so is using **normal maps**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光可以用来创建视觉复杂且令人叹为观止的场景。拥有照明系统的一个巨大好处是它提供了添加额外细节的能力，这在其他情况下是不可能的。实现这一目标的一种方法就是使用**法线贴图**。
- en: 'Mathematically speaking, the word *normal* in the context of a surface is simply
    a directional vector that is perpendicular to said surface. Consider the following
    illustration:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，在表面的上下文中，*法线*这个词简单地是一个垂直于该表面的方向向量。考虑以下插图：
- en: '![Normal maps](img/image_08_005.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![法线图](img/image_08_005.jpg)'
- en: 'In this case, what''s normal is facing up because that''s the direction perpendicular
    to the plane. How is this helpful? Well, imagine you have a really complex model
    with many vertices; it''d be extremely taxing to render said model because of
    all the geometry that would need to be processed with each frame. A clever trick
    to work around this, known as **normal mapping**, is to take the information of
    all of those vertices and save them on a texture that looks similar to this one:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，法线朝上，因为那是垂直于平面的方向。这有什么帮助呢？好吧，想象一下你有一个非常复杂的模型，有很多顶点；渲染这个模型会非常耗时，因为需要处理大量的几何形状。一个聪明的技巧，称为**法线贴图**，就是将所有这些顶点的信息保存到一个看起来类似这样的纹理上：
- en: '![Normal maps](img/image_08_006.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![法线图](img/image_08_006.jpg)'
- en: 'It probably looks extremely funky, especially if being looked at in a physical
    release of this book that''s in grayscale, but try not to think of this in terms
    of colors, but directions. The red channel of a normal map encodes the *-x* and
    *+x* values. The green channel does the same for *-y* and *+y* values, and the
    blue channel is used for *-z* to *+z*. Looking back at the previous image now,
    it''s easier to confirm which direction each individual pixel is facing. Using
    this information on geometry that''s completely flat would still allow us to light
    it in such a way that it would make it look like it has all of the detail in there;
    yet, it would still remain flat and light on performance:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常奇特，尤其是在以灰度形式查看这本书的物理版本时，但请尽量不要从颜色的角度考虑，而是从方向的角度考虑。法线贴图的红色通道编码了 *-x*
    和 *+x* 值。绿色通道对 *-y* 和 *+y* 值做同样的处理，而蓝色通道用于 *-z* 到 *+z*。现在回顾一下之前的图像，更容易确认每个单独像素的方向。在完全平坦的几何体上使用这些信息仍然可以让我们以这种方式对其进行照明，使其看起来具有所有这些细节；然而，它仍然保持平坦且对性能影响不大：
- en: '![Normal maps](img/image_08_007.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![法线贴图](img/image_08_007.jpg)'
- en: These normal maps can be hand-drawn or simply generated using software such
    as *Crazybump*. Let's see how all of this can be done in our game engine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些法线贴图可以是手工绘制，或者简单地使用如 *Crazybump* 这样的软件生成。让我们看看如何在我们的游戏引擎中实现这一切。
- en: Implementing normal map rendering
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现法线贴图渲染
- en: 'In the case of maps, implementing normal map rendering is extremely simple.
    We already have all the material maps integrated and ready to go, so at this time,
    it''s simply a matter of sampling the texture of the tile sheet normals:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图的情况下，实现法线贴图渲染非常简单。我们已经有所有材质贴图集成并准备就绪，所以现在这只是一个采样瓦片贴图法线纹理的问题：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The process is exactly the same as drawing a normal tile to a diffuse map, except
    that here we have to provide the material shader with the texture of the tile-sheet
    normal map. Also note that we're now drawing to a normal buffer texture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与将法线瓦片绘制到漫反射贴图上的过程完全相同，只是在这里我们必须向材质着色器提供瓦片贴图法线的纹理。同时请注意，我们现在正在绘制到法线缓冲区纹理。
- en: 'The same is true for drawing entities as well:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘制实体也是如此：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can try obtaining a normal texture through the texture manager. If you find
    one, you can draw it to the normal map material buffer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过纹理管理器尝试获取一个正常纹理。如果您找到了，您可以将它绘制到法线贴图材质缓冲区中。
- en: 'Dealing with particles isn''t much different from what we''ve seen already,
    except for one small detail:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 处理粒子与我们已经看到的方法没有太大区别，除了一个小细节：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, we''re actually using the material value shader in order to
    give particles static normals, which are always sort of pointing to the camera.
    A normal map buffer should look something like this after you render all the normal
    maps to it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们实际上正在使用材质值着色器来给粒子提供静态法线，这些法线总是指向相机。在将所有法线贴图渲染到它上面后，法线贴图缓冲区应该看起来像这样：
- en: '![Implementing normal map rendering](img/image_08_008.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![实现法线贴图渲染](img/image_08_008.jpg)'
- en: Changing the lighting shader
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改照明着色器
- en: 'Now that we have all of this information, let''s actually use it when calculating
    the illumination of the pixels inside the light pass shader:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有这些信息，让我们在计算光照着色器内部的像素照明时实际使用它：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, the normal map texture needs to be passed to it, as well as sampled,
    which is where the first two highlighted lines of code come in. Once this is done,
    for each light we're drawing on the screen, the normal directional vector is calculated.
    This is done by first making sure that it can go into the negative range and then
    normalizing it. A normalized vector only represents a direction.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要将法线贴图纹理传递给它，并进行采样，这就是前两行高亮代码的作用所在。一旦完成，对于我们在屏幕上绘制的每个光源，都会计算法线方向向量。这是通过首先确保它可以进入负范围，然后归一化它来完成的。归一化向量只表示一个方向。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the color values range from *0* to *255*, negative values cannot be directly
    represented. This is why we first bring them into the right range by multiplying
    them by *2.0* and subtracting by *1.0*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于颜色值范围从 *0* 到 *255*，负值不能直接表示。这就是为什么我们首先通过乘以 *2.0* 并减去 *1.0* 来将它们带入正确的范围。
- en: A **dot product** is then calculated between the normal vector and the normalized
    `L` vector, which now represents the direction from the light to the pixel. How
    much a pixel is lit up from a specific light is directly contingent upon the dot
    product, which is a value from *1.0* to *0.0* and represents magnitude.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后计算法线向量和归一化`L`向量之间的点积，现在它代表从光到像素的方向。一个像素从特定光源照亮的程度直接取决于点积，这是一个从*1.0*到*0.0*的值，代表大小。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **dot product** is an algebraic operation that takes in *two vectors*, as
    well as the *cosine* of the angle between them, and produces a scalar value between
    *0.0* and *1.0* that essentially represents how "orthogonal" they are. We use
    this property to light pixels less and less, given greater and greater angles
    between their normals and the light.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**点积**是一种代数运算，它接受*两个向量*以及它们之间角度的*余弦值*，并产生一个介于*0.0*和*1.0*之间的标量值，这基本上代表了它们有多“正交”。我们利用这个特性，随着它们法线与光之间的角度越来越大，逐渐减少对像素的照明。'
- en: Finally, the dot product is used again when calculating the final pixel value.
    The entire influence of the light is multiplied by it, which allows every pixel
    to be drawn differently as if it had some underlying geometry that was pointing
    in a different direction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在计算最终像素值时再次使用点积。整个光的影响都乘以它，这使得每个像素都可以以不同的方式绘制，就像它有一些指向不同方向的底层几何形状一样。
- en: 'The last thing left to do now is to pass the normal map buffer to the shader
    in our C++ code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后要做的就是将正常映射缓冲区传递到我们的C++代码中的着色器：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This effectively enables normal mapping and gives us beautiful results such
    as this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效地启用了正常映射，并给我们带来了如下的美丽效果：
- en: '![Changing the lighting shader](img/image_08_009.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![修改光照着色器](img/image_08_009.jpg)'
- en: The leaves, the character, and pretty much everything in this image, now look
    like they have a definition, ridges, and crevices; it is lit as if it had geometry,
    although it's paper-thin. Note the lines around each tile in this particular instance.
    This is one of the main reasons why normal maps for pixel art, such as tile sheets,
    shouldn't be automatically generated; it can sample the tiles adjacent to it and
    incorrectly add bevelled edges.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 树叶、角色以及这张图片中的几乎所有东西，现在看起来都有定义、棱角和凹槽；它被照亮，就像它有几何形状一样，尽管它是纸薄的。注意这个特定实例中每个瓦片周围的线条。这就是为什么像素艺术（如瓦片图集）的正常映射不应该自动生成的原因之一；它可以采样它旁边的瓦片，并错误地添加斜边。
- en: Specular maps
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜面映射
- en: 'While normal maps provide us with the possibility of faking how bumpy a surface
    is, specular maps allow us to do the same with the shininess of a surface. This
    is what the same segment of the tile sheet we used as an example for a normal
    map looks like in a specular map:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正常映射为我们提供了模拟表面凹凸度的可能性，但镜面映射允许我们以相同的方式处理表面的光泽度。这就是我们用作正常映射示例的瓦片图集的相同段在镜面映射中的样子：
- en: '![Specular maps](img/image_08_010.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![镜面映射](img/image_08_010.jpg)'
- en: 'It''s not as complex as a normal map, since it only needs to store one value:
    the shininess factor. We can leave it up to each light to decide how much *shine*
    it will cast upon the scenery by letting it have its own values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有普通映射那么复杂，因为它只需要存储一个值：光泽度因子。我们可以让每个光照决定它将在场景上产生多少*光泽*，让它有自己的值：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Adding support for specularity
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对镜面反射的支持
- en: 'Similar to normal maps, we need to use the material pass shader to render to
    a specularity buffer texture:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常映射类似，我们需要使用材质通道着色器将渲染输出到镜面反射缓冲纹理：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The texture for specularity is once again attempted to be obtained; it is passed
    down to the material pass shader if found. The same is true when you render entities:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面反射的纹理再次尝试获取；如果找到，则将其传递到材质通道着色器。当你渲染实体时也是如此：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Particles, on the other hand, also use the material value pass shader:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，粒子也使用材质值通道着色器：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For now, we don''t want any of them to be specular at all. This can obviously
    be tweaked later on, but the important thing is that we have that functionality
    available and yielding results, such as the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不想让任何东西都有镜面反射。这显然可以在以后进行调整，但重要的是我们有了这个功能，并且它产生了以下这样的结果：
- en: '![Adding support for specularity](img/image_08_011.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![添加对镜面反射的支持](img/image_08_011.jpg)'
- en: This specularity texture needs to be sampled inside a light pass, just like
    a normal texture. Let's see what this involves.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种具有光泽的纹理需要在光照通道内进行采样，就像普通纹理一样。让我们看看这涉及到什么。
- en: Changing the lighting shader
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改光照着色器
- en: 'Just as before, a uniform `sampler2D` needs to be added to sample the specularity
    of a particular fragment:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，需要添加一个统一的`sampler2D`来采样特定片段的镜面度：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We also need to add in the specular exponent and strength to each light's `struct`,
    as it's now part of it. Once the specular pixel is sampled, we need to set up
    the direction of the camera as well. Since that's static, we can leave it as is
    in the shader.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将每个光线的`struct`中的镜面指数和强度添加进去，因为现在它是它的一部分。一旦采样了镜面像素，我们还需要设置摄像机的方向。由于这是静态的，我们可以在着色器中保持原样。
- en: The specularity of the pixel is then calculated by taking into account the dot
    product between the pixel's normal and the light, the color of the specular pixel
    itself, and the specular strength of the light. Note the use of a specular constant
    in the calculation. This is a value that can, and should, be tweaked in order
    to obtain the best results, as 100% specularity rarely looks good.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过考虑像素的法线与光之间的点积、镜面像素本身的颜色和光的镜面强度来计算像素的镜面度。注意计算中使用了镜面常数。这是一个可以，并且应该调整以获得最佳结果的价值，因为100%的镜面度很少看起来很好。
- en: 'Then, all that''s left is to make sure the specularity texture is also sent
    to the light pass shader, in addition to the light''s specular exponent and strength
    values:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，剩下的就是确保将镜面纹理也发送到光通道着色器，除了光线的镜面指数和强度值：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result may not be visible right away, but upon closer inspection of moving
    a light stream, we can see that correctly mapped surfaces will have a glint that
    will move around with the light:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不会立即可见，但通过仔细检查移动光流，我们可以看到正确映射的表面将会有一个随着光线移动的闪光：
- en: '![Changing the lighting shader](img/image_08_012.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![更改照明着色器](img/image_08_012.jpg)'
- en: While this is nearly perfect, there's still some room for improvement.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这几乎是完美的，但仍有改进的空间。
- en: Height maps
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高度图
- en: The main point of illuminating the world is to make all the visual details pop
    up in a realistic manner. We have already added artificial dynamic lighting, fake
    3D geometry, and shininess, so what's left? Well, there's nothing that shows the
    proper height of the scene yet. Until this very moment, we've been dealing with
    the scene as if it's completely flat when calculating the lighting distances.
    Instead of this, we need to work on something referred to as the height map that
    will store the heights of the pixels.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 照亮世界的要点是使所有视觉细节以逼真的方式突出。我们已经添加了人工动态照明、假3D几何形状和光泽，那么剩下什么呢？嗯，还没有显示场景正确高度的东西。直到现在，我们在计算照明距离时一直将场景视为完全平坦。相反，我们需要处理被称为高度图的东西，它将存储像素的高度。
- en: Adapting the existing code
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配现有代码
- en: 'Drawing heights properly can be quite tricky, especially in the case of tile
    maps. We need to know which way a tile is facing when drawing realistic heights.
    Consider the following illustration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正确绘制高度可能相当棘手，尤其是在瓦片图的情况下。我们需要知道在绘制逼真高度时瓦片面向哪个方向。考虑以下插图：
- en: '![Adapting the existing code](img/image_08_013.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![适配现有代码](img/image_08_013.jpg)'
- en: 'The tiles right next to point **A** have no normals associated with them, while
    the tiles next to point **B** are all facing the camera. We can store normal data
    inside our map files by making these few simple alterations:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 点**A**旁边的瓦片没有与之关联的法线，而点**B**旁边的瓦片都面向摄像机。我们可以通过进行这些简单的修改在地图文件中存储法线数据：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `Tile` structure itself holds on to a normal value now, which will be used
    later on. When tiles are being read in from a file, additional information is
    loaded at the very end. The last two lines here show the actual entries from a
    map file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tile`结构本身现在保留了一个正常值，这个值将在以后使用。当从文件中读取瓦片时，附加信息将在最后加载。这里最后两行显示了来自地图文件的实际条目。'
- en: 'Drawing the heights of these tiles based on their normals is all done in the
    appropriate shader, so let''s pass all of the information it needs:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些瓦片法线绘制高度的所有操作都在适当的着色器中完成，所以让我们传递它所需的所有信息：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The height pass shader uses a value for the base height of the drawable, which,
    in this case, is just elevation in world coordinates. It also uses the *Y* world
    coordinate of the `Drawable` class and takes in the surface normal. The same values
    need to be set up for the entities as well:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 高度通道着色器使用可绘制基高度的一个值，在这个例子中，它只是世界坐标中的高程。它还使用`Drawable`类的*Y*世界坐标并获取表面法线。同样，实体也需要设置相同的值：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this case, however, we''re using the same normal for all the entities. This
    is because we want them to face the camera and be illuminated as if they''re standing
    perpendicular to the ground. Particles, on the other hand, are not facing the
    camera, but instead have normals pointing up toward the positive *Y* axis:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们为所有实体使用相同的法线。这是因为我们希望它们面向相机，并且像垂直于地面站立一样被照亮。另一方面，粒子没有面向相机，而是法线指向正*Y*轴：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Writing the height pass shader
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写高度传递着色器
- en: The height pass is the only program we've written so far that uses both the
    vertex and the fragment shaders.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 高度传递是我们迄今为止编写的唯一一个同时使用顶点和片段着色器的程序。
- en: 'Let''s take a look at what needs to happen in the vertex shader:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看顶点着色器中需要发生什么：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's only one line here that isn't standard from what is traditionally known
    as a vertex shader, outside of the uniform variable and the out variable, of course.
    The vertex shader outputs a floating point value called `Height` to the fragment
    shader. It's simply the height between the *Y* component of the vertex of a shape
    in world coordinates and the base *Y* position of that same shape. The height
    is then interpolated between all the fragments, giving a nice, gradient distribution.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一行不是传统意义上的顶点着色器标准，当然除了统一变量和输出变量之外。顶点着色器输出一个名为`Height`的浮点值到片段着色器。它只是形状在世界坐标中*Y*分量和相同形状的基础*Y*位置之间的高度。然后，高度在所有片段之间进行插值，从而得到一个很好的，渐变分布。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `gl_Vertex` information is stored in world coordinates. The bottom *Y* coordinates
    always start at the same height as the drawable, which makes the top *Y* coordinates
    equal to the sum of its position and height.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_Vertex`信息存储在世界坐标中。底部*Y*坐标始终从可绘制对象的相同高度开始，这使得顶部*Y*坐标等于其位置和高度的之和。'
- en: 'Finally, we can take a look at the fragment shader and actually do some filling
    up of fragments:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看看片段着色器，并实际填充一些片段：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As shown previously, it takes in the diffuse texture, the surface normal, the
    base height of the drawable, and the interpolated `Height` value from the vertex
    shader. The diffuse pixel is then sampled in order to use its alpha value for
    transparency. The height value itself is calculated by subtracting the result
    of the pixel height being multipled by the surface normal's *Z* component from
    the base height of the drawable. The whole thing is finally divided by *255* because
    we want to store color information in a normalized format.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，它接受漫反射纹理、表面法线、可绘制对象的基础高度以及从顶点着色器中插值的`Height`值。然后对漫反射像素进行采样，以便使用其alpha值进行透明度。高度值本身是通过从可绘制对象的基础高度中减去像素高度乘以表面法线的*Z*分量来计算的。最后，整个值除以*255*，因为我们希望以归一化格式存储颜色信息。
- en: Changing the lighting shader
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改光照着色器
- en: 'Finally, the light pass shader can be changed as well by sampling the height
    map:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过采样高度图来更改光照传递着色器：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Once the pixel height is sampled and multiplied by *255* to bring it back to
    world coordinates, all we need to do is replace the `gl_FragCoord.z` value with
    `pixelHeight` when calculating the distance between a pixel and a fragment. Yes,
    that's really all it takes!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦采样像素高度并将其乘以*255*以将其恢复到世界坐标，我们只需要在计算像素和片段之间的距离时，将`gl_FragCoord.z`值替换为`pixelHeight`。是的，这真的只需要这么简单！
- en: 'The `HeightMap` can then be actually passed to the shader for sampling, like
    so:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`HeightMap`可以实际传递给着色器进行采样，如下所示：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This gives us a very nice effect that can actually show off the height of a
    particular structure, given it has elevated properly and has the right normals:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个非常棒的效果，实际上可以展示特定结构的**高度**，前提是它被正确地提升并且具有正确的法线：
- en: '![Changing the lighting shader](img/image_08_014.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![更改光照着色器](img/image_08_014.jpg)'
- en: The light post on the left has no normals, while the post on the right has normals
    that face the *+Z* direction. The light position is exactly the same in both these
    images.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的灯柱没有法线，而右侧的灯柱的法线朝向*+Z*方向。在这两张图片中，灯光的位置完全相同。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you are still here, congratulations! That was quite a bit of information
    to take in, but just as our world is finally beginning to take shape visually,
    we're about to embark on an even more stunning feature that will be discussed
    in the next chapter. See you there!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在这里，恭喜你！你已经吸收了相当多的信息，但正如我们的世界终于开始在视觉上成形一样，我们即将踏上下一章将讨论的更加惊人的特性。那里见！
