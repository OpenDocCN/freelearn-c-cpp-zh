- en: Enterprise Integration Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业集成模式
- en: 'This chapter is going to cover deeper topics of enterprise integration patterns.
    These topics are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖企业集成模式的更深入话题。这些话题包括：
- en: Need for integration patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成模式的需求
- en: Integration scenarios in enterprises
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业中的集成场景
- en: Main challenges in enterprise integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业集成的主要挑战
- en: Getting started with messaging patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用消息模式
- en: Need for integration patterns
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成模式的需求
- en: Present day enterprises are comprised of thousands of applications. Many of
    them are commercial, off-the-shelf applications; some of them are in-house applications,
    and some others are legacy applications that have been part of the enterprise
    for a very long time. Though there will be thousands of applications, it is impossible
    for employees to access each one of them separately using separate consoles.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的企业由成千上万的应用程序组成。其中许多是商业化的现成应用；一些是内部应用，还有一些是长期作为企业一部分的遗留应用。尽管有数千个应用程序，但员工不可能使用单独的控制台分别访问每一个。
- en: Why are so many applications required in an enterprise? The answer to that question
    is that each enterprise has thousands of business functions that are impossible
    to be performed by a single application. Even an application such as an ERP can
    do very limited functions when compared to the actual needs of the enterprise.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么企业需要这么多应用程序？这个问题的答案是，每个企业都有数千个业务功能，这些功能无法由单个应用程序完成。即使是像ERP这样的应用程序，与企业的实际需求相比，也只能执行非常有限的功能。
- en: Another reason for multiple applications is that spreading various functions
    across multiple applications ensures a better level of business continuity in
    the sense that even if one application fails; others will continue to run without
    causing impediment to business functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 多个应用程序的另一个原因是，将各种功能分散到多个应用程序中可以确保更高的业务连续性水平，即即使一个应用程序失败，其他应用程序也会继续运行，而不会阻碍业务功能。
- en: Vendors in the market have also learned the art of developing applications that
    are focused on catering to the needs of specific business functions. However,
    with the change in dynamics of the various business functions, vendors are trying
    to integrate multiple functions into a single business application. For example,
    many billing system applications started to incorporate additional functions for
    accounting. So in short, in the present scenario, it is not possible to define
    clear boundaries for applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上的供应商也已经学会了开发专注于满足特定业务功能需求的应用程序的艺术。然而，随着各种业务功能动态的变化，供应商们正试图将多个功能集成到一个单一的业务应用程序中。例如，许多计费系统应用程序开始整合额外的会计功能。简而言之，在当前情况下，无法为应用程序定义清晰的边界。
- en: Users, such as customers and partners, tend to access various functions without
    much of a concern about the underlying applications that are involved in performing
    the function. All these parameters warrant the need for a proper integration mechanism
    across various applications that are part of the enterprise ecosystem. In the
    past, integration used to be confined only to applications that exist within an
    organization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户，如客户和合作伙伴，往往在关注底层应用程序参与执行功能时不太关心。所有这些参数都要求在企业的生态系统中的各种应用程序之间有一个适当的集成机制。在过去，集成仅限于组织内部存在的应用程序。
- en: In the present-day scenario, there are a host of new paradigms such as social
    media applications, **Internet of Things** (**IoT**) based applications, cloud-based
    applications, microservices-enabled applications, and so on, to name a few prominent
    ones. To enable seamless data sharing and support business process across the
    enterprise, it is necessary for enterprises to ensure that all the applications
    are integrated. The diverse types of applications have created a need for the
    enterprises to develop a robust set of capabilities for their integration platform
    so that they can continue to remain competitive in the present-day dynamics of
    agile enterprises that are in a constantly changing mode to suit the customer
    demands and expectations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的背景下，有许多新的范例，如社交媒体应用、基于物联网（IoT）的应用、基于云的应用、支持微服务的应用等，仅举一些突出的例子。为了实现无缝的数据共享并支持企业内部业务流程，企业必须确保所有应用程序都是集成的。不同类型的应用程序使得企业需要为其集成平台开发一套强大的功能，以便他们能够在当今敏捷企业的动态环境中保持竞争力，这些企业处于不断变化的状态，以满足客户的需求和期望。
- en: There is no shortcut for enterprise integration. It is a very broad and difficult
    area to handle, but inevitable for the present-day enterprise. Enterprise integration
    patterns do not provide any ready-made code that can be used for integrating applications.
    In fact, they suggest proven and tested approaches for solving enterprise integration
    problems. If used correctly, enterprise integration patterns can help organizations
    fill up the huge gap that exists between their integration vision and its actual
    implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 企业集成没有捷径。这是一个非常广泛且难以处理的领域，但对于当今的企业来说是不可避免的。企业集成模式不提供任何现成的代码，可以用于集成应用程序。实际上，它们建议经过验证和测试的方法来解决企业集成问题。如果正确使用，企业集成模式可以帮助组织填补其集成愿景与实际实施之间存在的巨大差距。
- en: In the next section, we will examine the diverse types of scenarios that demand
    integration in enterprises.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查企业中需要集成的各种不同场景。
- en: Integration scenarios in enterprises
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业集成场景
- en: 'The concept of integration is a very broad area. However, some of the most
    common integration scenarios in enterprises are the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的概念是一个非常广泛的领域。然而，企业中最常见的集成场景包括以下几种：
- en: Information portals
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息门户
- en: Data replication
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据复制
- en: Shared business functions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享商业功能
- en: Service-oriented architectures
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: Distributed business processes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式商业流程
- en: Business-to-business integration
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业对商业集成
- en: There could be several other scenarios in enterprises based on the nature of
    the business and the domain handled by them. We will examine some of the prominent
    integration scenarios now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务性质和它们处理的领域，企业可能会有几种其他场景。现在我们将检查一些突出的集成场景。
- en: Information portal
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息门户
- en: 'Many users in an organization will have the need to access more than one application
    to perform a single business function. For example, an HR professional may have
    to access several applications, such as talent acquisition, compensation and benefits,
    learning and development, talent branding, and so on, to pull out details pertaining
    to various aspects of talent management. This scenario makes it extremely difficult
    for them to carry out their daily business functions at pace. This is where the
    concept of information portals comes to their help. An information portal can
    access information from diverse systems, aggregate, and present them in a single
    view. Simple information portals divide the display screen into several zones.
    Each zone will display data from a specific application. These information portals
    also have the capability to provide drill down information in one zone based on
    the information selected by the user in the other zone. An example of an information
    portal is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 组织中的许多用户将需要访问多个应用程序以执行单一的商业功能。例如，人力资源专业人士可能需要访问多个应用程序，如人才招聘、薪酬和福利、学习和开发、人才品牌等，以提取与人才管理各个方面相关的详细信息。这种场景使得他们难以以适当的速度执行日常业务功能。这就是信息门户概念对他们有所帮助的地方。信息门户可以从不同的系统中获取信息，汇总并在单一视图中展示。简单的信息门户将显示屏幕划分为几个区域。每个区域将显示来自特定应用程序的数据。这些信息门户还具有根据用户在另一个区域选择的信息在某个区域提供钻取信息的功能。以下是一个信息门户的示例：
- en: '![](img/03fb8109-c68f-48be-99dd-af235b7293cb.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03fb8109-c68f-48be-99dd-af235b7293cb.png)'
- en: Data replication
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据复制
- en: 'In an enterprise, many applications will have a copy of the same data. For
    example, customer details could be there in the order management system, billing
    system, advertising and promotions system, and so on. So, if the address is updated
    in one system, it is mandatory to ensure that it is updated in other systems also.
    Replication is one of the techniques to ensure this required consistency. How
    is data replication done? Many organizations define policies that will ensure
    that there is continuous synchronization and replication of data at regular intervals
    of time to ensure that data stays up to date on all the systems. Another technique
    is to export data into files and import them to other systems. Another technique,
    called **message-oriented middleware**, is used to embed data records into messages
    and send them to other applications for synchronization purposes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中，许多应用程序将拥有相同数据的副本。例如，客户详细信息可能存在于订单管理系统、计费系统、广告和促销系统中等。因此，如果在一个系统中更新了地址，则必须确保在其他系统中也进行更新。复制是确保这种所需一致性的技术之一。数据复制是如何进行的？许多组织定义了政策，确保数据在规定的时间间隔内持续同步和复制，以确保所有系统上的数据保持最新。另一种技术是将数据导出到文件中，然后导入到其他系统中。另一种称为**面向消息的中间件**的技术用于将数据记录嵌入到消息中，并将它们发送到其他应用程序以进行同步目的：
- en: '![](img/ab1d1900-b4c8-4c8f-9b05-44bab42eedc3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab1d1900-b4c8-4c8f-9b05-44bab42eedc3.png)'
- en: Shared business function
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享业务函数
- en: If the same set of data is stored in multiple systems, it leads to redundancy
    of data. The functions that are used to handle this data (such as a customer address
    in the previous example) could be implemented as a shared business function once
    and exposed as a service to other systems that have the same set of data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一组数据存储在多个系统中，会导致数据冗余。用于处理这些数据的功能（如前例中的客户地址）可以一次实现为共享业务函数，并作为服务暴露给具有相同数据集的其他系统。
- en: A **shared business function** can be used as a good functionality to replace
    redundant data. For example, let us take the case of a customer address that is
    stored in multiple systems across the organization. Instead of storing the same
    data in multiple systems, a business function called `GetCustomerAddress` could
    be used by a system to fetch the data from other systems instead of permanently
    storing it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享业务函数**可以用作良好的功能来替换冗余数据。例如，让我们以客户地址为例，该地址存储在组织内的多个系统中。而不是在多个系统中存储相同的数据，一个名为`GetCustomerAddress`的业务函数可以被系统用来从其他系统中获取数据，而不是永久存储它。'
- en: 'The trade-off between the use of redundant data versus shared business functions
    is based on several criteria. Some of the parameters that define the criteria
    are the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冗余数据与共享业务函数之间的权衡基于几个标准。定义这些标准的参数包括以下内容：
- en: Amount of control over the systems where the data is present (in some situations,
    invoking a `shared` function could be a more intensive task than loading data
    into the database)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据所在系统的控制程度（在某些情况下，调用`共享`函数可能比将数据加载到数据库中更耗费资源）
- en: Rate of change of data under consideration (for example, a customer address
    may be needed very frequently whereas it may change only infrequently)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑的数据变化率（例如，客户地址可能非常频繁地需要，而可能很少改变）
- en: 'The diagram depicting the use of a `shared` function is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个展示使用`共享`函数的图示：
- en: '![](img/04678409-fbeb-4195-a154-acded38281c9.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04678409-fbeb-4195-a154-acded38281c9.png)'
- en: Service-oriented architecture
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: 'Shared business functions, which we discussed earlier, are commonly referred
    to as *services*. A service is typically a well-defined function that is universally
    available to perform a specific operation. These services are made available for
    use by other systems that act as service consumers. Once a set of services are
    created, it is very important to ensure that they are maintained and made available
    to other systems in an appropriate manner. The two important aspects of service
    management are the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的共享业务函数通常被称为*服务*。服务通常是一个定义良好的函数，它对所有系统普遍可用，以执行特定操作。这些服务可供其他作为服务消费者的系统使用。一旦创建了一组服务，确保它们以适当的方式维护并提供给其他系统就非常重要。服务管理的两个重要方面如下：
- en: '**Service discovery**: All services are made available in a centralized service
    directory through which the other applications can discover them'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：所有服务都通过一个集中的服务目录提供，其他应用程序可以通过该目录发现它们'
- en: '**Service negotiation**: Each service must describe its interface in such a
    way that other applications in the enterprise can negotiate and set up a communication
    contract with them'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务协商**：每个服务必须以这种方式描述其接口，使得企业中的其他应用能够与他们协商并建立通信合同。'
- en: '**Service-oriented** **architecture** (**SOA**) is also a mechanism for application
    integration, which in turn blurs the line between integration and distributed
    applications. The SOA was discussed in detail in [Chapter 7](45460494-ac40-47e3-9d76-731dd2a48e12.xhtml),
    *Service-Oriented Architecture (SOA)*. The block diagram depicting SOA is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务**的**架构**（**SOA**）也是一种应用集成的机制，这反过来又模糊了集成和分布式应用之间的界限。SOA在[第7章](45460494-ac40-47e3-9d76-731dd2a48e12.xhtml)，《面向服务架构（SOA）》中进行了详细讨论。描述SOA的框图如下：'
- en: '![](img/0f57f104-d2f3-45a8-8ff2-dffea73661e2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![框图](img/0f57f104-d2f3-45a8-8ff2-dffea73661e2.png)'
- en: Another important aspect of service-oriented architecture is the concept of
    **enterprise service bus** (**ESB**), which provides connectivity between the
    sender and receiver components of the SOA in a loosely coupled manner.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务架构的另一个重要方面是**企业服务总线**（**ESB**）的概念，它以松耦合的方式提供SOA发送者和接收者组件之间的连接性。
- en: Distributed business process management
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式业务流程管理
- en: 'As we have already discussed, a single business function can be spread across
    several applications present in an enterprise. In such situations, it is very
    important to ensure coordination between the various applications. This can be
    done by implementing a business process management system. The business process
    management system will coordinate with all relevant applications that are part
    of a specific business function and ensure seamless execution. However, in this
    context, it is important to remember that there exists a very blurred line between
    business process management and SOA. There is always a possibility that all services
    are made available as services, and a business process function can be made available
    as an application to access all services through SOA. The diagram of a distributed
    process management system is depicted as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，一个单一的商业功能可以分布在企业中存在的几个应用中。在这种情况下，确保各种应用之间的协调非常重要。这可以通过实施业务流程管理系统来实现。业务流程管理系统将与属于特定商业功能的全部相关应用协调，并确保无缝执行。然而，在这个背景下，重要的是要记住，业务流程管理和SOA之间存在一条非常模糊的界限。始终存在所有服务都作为服务提供，而一个业务流程功能可以作为应用程序提供，以便通过SOA访问所有服务的可能性。分布式流程管理系统的图示如下：
- en: '![](img/598a0cc1-d305-4714-866a-a4dd548f800c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![框图](img/598a0cc1-d305-4714-866a-a4dd548f800c.png)'
- en: The business-to-business integration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业对商业集成
- en: 'As discussed at the start of the chapter, present-day enterprises need to interact
    with several components that are external to their ecosystem, such as customers,
    partners, and so on. These external elements need access to many applications
    that are a part of the enterprise. For example, in the case of a product organization,
    there will be several partners who implement the services that are part of the
    product. In such cases, it is very important for partners to get access to some
    critical enterprise applications to stay up to date with the new product features,
    updates, learning resources, product user forums, and groups. The reverse is also
    true in the sense that the enterprise also relies heavily on certain external
    organizations for some of their functions, and hence it is important to ensure
    the flow of data from certain external applications to the enterprise. Such scenarios
    give rise to situations that warrant a business-to-business integration. This
    is not a very straightforward situation like an integration of applications within
    an enterprise. This is primarily due to the fact that when it comes to business-to-business
    integration, several other aspects of security, legal implications, and governance
    need to be considered to enable smooth integration. The graphic depicting a business-to-business
    integration scenario is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，当今的企业需要与其生态系统之外的多个组件进行交互，例如客户、合作伙伴等。这些外部元素需要访问企业的一部分应用。例如，在产品组织的案例中，将会有几个合作伙伴实施产品的一部分服务。在这种情况下，合作伙伴能够访问一些关键的企业应用以了解新产品功能、更新、学习资源、产品用户论坛和群组非常重要。反之亦然，企业也严重依赖某些外部组织的一些功能，因此确保某些外部应用向企业传输数据非常重要。这些场景引发了需要企业对企业集成的情形。这并不是一个像企业内部应用集成那样非常直接的情况。这主要是因为在企业对企业集成时，还需要考虑许多其他方面，如安全性、法律影响和治理，以实现顺利集成。描述企业对企业集成场景的图形如下：
- en: '![](img/4e2fc087-7ef2-4698-8773-5d66b75f264f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e2fc087-7ef2-4698-8773-5d66b75f264f.png)'
- en: In the next section, we will analyze the various challenges that exist while
    integrating enterprise applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析在集成企业应用时存在的各种挑战。
- en: Main challenges in enterprise integration
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业集成的主要挑战
- en: 'Some of the main challenges associated with enterprise application integration
    are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与企业应用集成相关的一些主要挑战如下：
- en: '**Networks are slow and unreliable**: Enterprise integration applications need
    to transfer data from one application to another. These applications may reside
    in different states, countries, or continents. In such situations, data needs
    to be transferred through a LAN or a WAN, or a combination of both. Transferring
    data through diverse network topologies and protocols introduces significant transmission
    delays and other types of interruptions that become a stumbling block in enterprise
    application integration.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络速度慢且不可靠**：企业集成应用需要将数据从一个应用传输到另一个应用。这些应用可能位于不同的州、国家或大陆。在这种情况下，数据需要通过LAN、WAN或两者的组合进行传输。通过不同的网络拓扑和协议传输数据引入了显著的传输延迟和其他类型的干扰，这些干扰成为企业应用集成的绊脚石。'
- en: '**Heterogeneous application platforms**: While integrating multiple applications,
    it is important to keep in mind that each application will have its own platform
    and operating system. To ensure seamless integration between such applications,
    it is vital to ensure that data transfer between applications happens in a format
    that can be understood by all the applications that are involved. For this to
    happen, there should be a middleware component that converts data into a generic
    format understandable by all the applications.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异构应用平台**：在集成多个应用时，重要的是要记住每个应用都将有自己的平台和操作系统。为了确保这些应用之间无缝集成，必须确保数据在应用之间以所有相关应用都能理解的形式进行传输。为了实现这一点，应该有一个中间件组件，将数据转换为所有应用都能理解的通用格式。'
- en: '**Application updates and upgrades**: Applications that are integrated will
    constantly keep getting upgraded due to system updates. In some situations, some
    system upgrades will introduce drastic changes in the overall application. This
    may impact all other applications that are involved in the integration. It is
    important for integration solutions to minimize dependencies between various applications
    that are part of the integration. One of the ways to achieve this is by ensuring
    loose coupling between the applications.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用更新和升级**：集成的应用将因系统更新而不断进行升级。在某些情况下，某些系统升级将对整体应用引入重大变化。这可能会影响所有参与集成的其他应用。对于集成解决方案来说，最小化集成中各个应用之间的依赖关系非常重要。实现这一目标的一种方法是通过确保应用之间的松散耦合。'
- en: '**Security**: Certain applications in domains such as healthcare and insurance
    are bound by stringent security policies and frameworks. If such applications
    are involved in the integration process, it is important to adhere to the security
    guidelines. Otherwise, it will lead to the violation of legal guidelines.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在医疗保健和保险等领域的某些应用受到严格的网络安全政策和框架的约束。如果这些应用参与集成过程，遵守安全指南非常重要。否则，将导致违反法律指南。'
- en: 'Some of the key techniques that are used to overcome the aforementioned challenges
    are the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用于克服上述挑战的一些关键技术如下：
- en: '![](img/02d68672-1cf3-4044-88b3-ca06ea3c0131.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02d68672-1cf3-4044-88b3-ca06ea3c0131.png)'
- en: Let's discuss these techniques briefly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论这些技术。
- en: File transfer
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件传输
- en: 'Here, file is the basic mode for transfer of data between applications that
    need to be integrated. One application will perform a write operation on a file
    that will be read by the other application. However, for this to happen successfully
    and create the necessary impact, it is important for the involved applications
    to agree upon the following parameters about the file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件是需要在集成的应用之间传输数据的基本模式。一个应用将对文件执行写操作，该文件将被另一个应用读取。然而，为了成功执行并产生必要的影响，涉及的应用就以下关于文件的参数达成一致非常重要：
- en: Filename and location
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名和位置
- en: Format of the file
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件格式
- en: Time at which the file will be written and read
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入和读取文件的时间
- en: How the file will be deleted
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件将如何被删除
- en: Shared database
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享数据库
- en: In this case, the database becomes the point at which integration happens. Multiple
    applications that need to be integrated share a common database schema, which
    is in the same database. This prevents duplicate data storage and prevents the
    need for data transfer from one application to another.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据库成为集成发生的点。需要集成的多个应用共享一个共同的数据库模式，该模式位于同一个数据库中。这防止了重复数据存储，并防止了从应用之间进行数据传输的需求。
- en: Remote procedure invocation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: In this case, integration of applications happens through some functionality
    that is exposed by one application. The other application(s) access these functionalities
    remotely as a remote procedure. The process of invoking these functionalities
    as a remote procedure is called **remote procedure invocation**. Remote procedure
    invocation occurs in real time and is a synchronous communication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用的集成是通过一个应用暴露的功能来实现的。其他应用作为远程过程远程访问这些功能。将功能作为远程过程调用的过程称为**远程过程调用**。远程过程调用是实时发生的，是一种同步通信。
- en: Messaging
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: In this case, integration of applications happens through messaging. One of
    the applications publishes a message to a message channel that can be accessed
    by all other applications. Other applications access the message channel and reach
    the message at some later point in time. The only criteria here is that the applications
    that are involved should have a predefined agreement on the message channel and
    the format of the message that is sent to the channel. In the next section, we
    will dive deep into the concepts of messaging and how enterprise applications
    can be integrated using the concept of messaging. In the next section, we will
    dwell deep into the various types of messaging patterns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用的集成是通过消息传递来实现的。其中一个应用向一个所有其他应用都可以访问的消息通道发布消息。其他应用访问消息通道并在稍后的某个时间点获取消息。这里唯一的条件是，涉及的应用应该就消息通道和发送到通道的消息格式有一个预定义的协议。在下一节中，我们将深入探讨消息传递的概念以及企业应用如何通过消息传递的概念进行集成。在下一节中，我们将深入探讨各种消息传递模式。
- en: Getting started with messaging patterns
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用消息模式
- en: 'Messaging is a reliable technique that is used for interconnecting applications
    using the concept of packets called **messages**. These packets are sent to channels,
    which are logical pathways providing interconnection between the various applications.
    These channels are also called **queues**. Several messages can be queued up in
    a channel and can be made accessible to multiple applications at the same point
    in time. There are two main types of applications in messaging, they are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递是一种可靠的连接应用程序的技术，它使用称为**消息**的包的概念。这些包被发送到通道，这些通道是逻辑路径，提供各种应用程序之间的互连。这些通道也称为**队列**。可以在通道中排队多个消息，并在同一时间点使多个应用程序可访问。在消息传递中，主要有两种类型的应用程序，它们是：
- en: Sender/producer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者/生产者
- en: Receiver/consumer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者/消费者
- en: A sender is an application that sends a message to the channel. A receiver is
    an application that reads the message that is sent to the channel. Messaging is
    an asynchronous mode of communication, meaning it is not necessary that the receiver
    should read the message from the channel as soon as it reaches the channel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者是一个向通道发送消息的应用程序。接收者是一个读取发送到通道的消息的应用程序。消息传递是一种异步通信模式，这意味着接收者不必在消息到达通道后立即从通道中读取消息。
- en: 'A message could be any kind of data structure, such as an array, string, or
    object. Every message contains two parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以是任何类型的数据结构，例如数组、字符串或对象。每个消息包含两个部分：
- en: Header
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: Body
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息体
- en: The header contains metadata about the message, such as details of the sender,
    receiver, timestamp, and so on. This information is used by the messaging system
    but is usually ignored by the applications. The message body contains the actual
    data that is sent by the application. The body of the message is ignored by the
    messaging system but is used by the applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 标题包含有关消息的元数据，例如发送者、接收者、时间戳等详细信息。这些信息由消息系统使用，但通常被应用程序忽略。消息体包含应用程序实际发送的数据。消息体被消息系统忽略，但被应用程序使用。
- en: 'Messaging capabilities are provided to a system by a specialized software application
    called **message-oriented middleware** (**MOM**). MOM is also called a **messaging
    system**. MOM is required to ensure smooth transmission of messages across applications.
    One of the main reasons for the existence of MOM is the unreliable state of networks
    that interconnect the systems. Even if a message is sent by an application, it
    is not necessary that it reaches the intended destination if the network is not
    proper. MOM helps to overcome this network-related limitation and other limitations,
    and ensures that a message is repeatedly transmitted until it reaches its destination.
    The communication of applications through messaging is depicted in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递功能由一个称为**面向消息的中间件**（**MOM**）的专用软件应用程序提供。MOM也称为**消息系统**。MOM是确保消息在应用程序之间平稳传输所必需的。MOM存在的一个主要原因是连接系统的网络不可靠状态。即使应用程序发送了消息，如果网络不正常，也不一定能够到达预期的目的地。MOM有助于克服这种与网络相关的限制和其他限制，并确保消息在到达目的地之前会重复传输。以下图表展示了通过消息传递的应用程序通信：
- en: '![](img/e88c15a4-ba46-4a02-8398-361b0d9d6988.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e88c15a4-ba46-4a02-8398-361b0d9d6988.png)'
- en: 'The following are the five steps involved in message transmission:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传输涉及的五个步骤如下：
- en: '![](img/4bab54a5-c168-46e8-b19a-74f71ef6c51e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bab54a5-c168-46e8-b19a-74f71ef6c51e.png)'
- en: 'In each of these steps, the following activities are performed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中的每一个，都会执行以下活动：
- en: '**Create**: In this step, the sender or producer adds a header and data and
    creates the message'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**: 在这一步，发送者或生产者添加标题和数据，创建消息'
- en: '**Send**: In this step, the sender sends out the message to the channel'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送**: 在这一步，发送者将消息发送到通道'
- en: '**Deliver**: In this step, MOM moves the message from the sender''s system
    to the receiver''s system making the message available for the receiver'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**投递**: 在这一步，消息队列（MOM）将消息从发送者的系统移动到接收者的系统，使消息对接收者可用'
- en: '**Receive**: In this step, the receiver or consumer reads the message from
    the channel'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接收**: 在这一步，接收者或消费者从通道中读取消息'
- en: '**Process**: In this step, the receiver extracts the data from the message'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过程**: 在这一步，接收者从消息中提取数据'
- en: In the next section, we will examine the prominent messaging patterns that are
    used in the design of enterprise systems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在企业系统设计中使用的突出消息模式。
- en: Pipe and filter pattern
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和过滤器模式
- en: 'In many situations, a single event could trigger a series of actions and each
    will perform a specific function. So, pipe and filter patterns are used to handle
    such situations that require complex processing of messages while maintaining
    flexibility and independence. A large task is split into a series of smaller,
    sequential, independent tasks (filters) that are connected by channels (pipes).
    The diagram of the pipe and filter pattern is depicted as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，单一事件可能触发一系列动作，每个动作将执行特定的功能。因此，管道和过滤器模式被用来处理需要复杂消息处理同时保持灵活性和独立性的情况。一个大任务被分解成一系列较小的、顺序的、独立的任务（过滤器），这些任务通过通道（管道）连接起来。管道和过滤器模式的图示如下：
- en: '![](img/cd3f71a2-3eca-469b-82ac-87645a7d3cff.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd3f71a2-3eca-469b-82ac-87645a7d3cff.png)'
- en: Each filter has a simple interface that consists of an inbound pipe that receives,
    processes, and publishes the result to the outbound pipe. The role of a pipe is
    to connect one filter to the next. In the case of the pipe and filter pattern,
    all components use the same external interface, and hence they can be present
    in different solutions. These solutions can be interconnected by means of different
    pipes. The connection outlet that provides a connection between the pipe and filter
    is called a **port**. Typically, each filter has one input port and one output
    port.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过滤器都有一个简单的接口，它由一个接收、处理并将结果发布到输出管道的输入管道组成。管道的作用是将一个过滤器连接到下一个过滤器。在管道和过滤器模式中，所有组件使用相同的外部接口，因此它们可以存在于不同的解决方案中。这些解决方案可以通过不同的管道相互连接。提供管道和过滤器之间连接的连接出口称为**端口**。通常，每个过滤器有一个输入端口和一个输出端口。
- en: Message router pattern
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息路由模式
- en: 'This pattern is used in situations where sequential execution of steps may
    not always be possible. In some situations, the output of a filter may have to
    be passed to one of the several pipes based on the fulfillment of certain criteria
    or conditions. In such situations, message router patterns are used. The diagram
    depicting the message router pattern is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式用于那些步骤的顺序执行可能并不总是可行的情况。在某些情况下，过滤器的输出可能需要根据某些标准或条件传递到几个管道之一。在这种情况下，会使用消息路由模式。描述消息路由模式的图示如下：
- en: '![](img/2f12d258-0441-477d-ad13-480b00b5e7e3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f12d258-0441-477d-ad13-480b00b5e7e3.png)'
- en: Message translator pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息翻译器模式
- en: 'In the beginning of the chapter, we discussed scenarios where there could be
    a need to integrate certain third-party applications/partner applications to some
    of the applications that are part of the enterprise. These applications will use
    diverse data models and may sometimes use totally different data formats for communication.
    For present-day agile enterprises, it is necessary to use patterns that can interconnect
    diverse types of applications by converting data from one format to another. This
    is where the **message translator pattern** plays a key role. The message translator
    pattern acts as a special filter between other filters or applications and translates
    data from one format to another. The diagram depicting the message translator
    pattern is given as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了可能需要将某些第三方应用程序/合作伙伴应用程序集成到企业中的一些应用程序的场景。这些应用程序将使用不同的数据模型，有时可能使用完全不同的数据格式进行通信。对于当今敏捷的企业来说，使用能够通过将数据从一种格式转换为另一种格式来连接不同类型应用程序的模式是必要的。这就是**消息翻译器模式**发挥关键作用的地方。消息翻译器模式充当其他过滤器或应用程序之间的特殊过滤器，将数据从一种格式转换为另一种格式。描述消息翻译器模式的图示如下：
- en: '![](img/6ed3f99e-bc54-48e3-bcbf-136d54fee73e.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ed3f99e-bc54-48e3-bcbf-136d54fee73e.png)'
- en: Message endpoint pattern
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息端点模式
- en: 'Applications in an enterprise communicate with each other by sending messages
    through a message channel. But the next issue is that there needs to be a mechanism
    in place that will help applications to connect to the message channel. This is
    applicable for the sender application to send messages and for the receiver application
    to receive messages. This is where the message endpoint pattern comes into the
    picture. The message endpoint acts as a client of the messaging system, which
    the sender and receiver application can use to send and receive messages. Message
    endpoint code is accessible to both the application and the MOM''s client API.
    The remaining application knows nothing about message formats, messaging channels,
    or any other details of the applications with which it is communicating through
    messaging. It just knows that it has sent some data to another application or
    that it will receive data from another application. Message endpoint code takes
    the data, converts it into a message, and sends it to the correct messaging channel.
    Similarly, on the receiving end, the message endpoint receives the message, extracts
    the contents, and gives it to the application. The diagram depicting the message
    endpoint pattern is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用通过消息通道发送消息来相互通信。但接下来需要解决的问题是需要有一个机制来帮助应用连接到消息通道。这对于发送应用发送消息和接收应用接收消息都是适用的。这就是消息端点模式出现的地方。消息端点充当消息系统的客户端，发送和接收应用可以使用它来发送和接收消息。消息端点代码对应用和MOM的客户端API都是可访问的。剩余的应用不知道关于消息格式、消息通道或它通过消息通信的其他应用的任何细节。它只知道它已经向另一个应用发送了一些数据，或者它将接收来自另一个应用的数据。消息端点代码接收数据，将其转换为消息，并发送到正确的消息通道。同样，在接收端，消息端点接收消息，提取内容，并将其交给应用。描述消息端点模式的图如下：
- en: '![](img/3f01076c-d3f9-4fb6-b55e-aea16d1946b3.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f01076c-d3f9-4fb6-b55e-aea16d1946b3.png)'
- en: Point-to-point channel pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对点通道模式
- en: 'Consider the scenario in which an application is using messaging to make a
    remote procedure call. In this situation, it is necessary to ensure that only
    one receiver will perform the call. This is where the **point-to-point channel**
    pattern helps us. If a message is sent through a point-to-point channel, it ensures
    that only one receiver will receive the message. In case the channel has multiple
    receivers, only one of them will be able to receive the message. If multiple receivers
    try to consume the message, the channel will make sure that only one of them will
    be successful in their attempts. But this does not prevent the channel from having
    multiple receivers and them receiving multiple messages concurrently. The only
    criteria here is that only one receiver will receive a specific message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个应用使用消息进行远程过程调用的场景。在这种情况下，必须确保只有一个接收者执行调用。这就是**点对点通道模式**帮助我们的地方。如果通过点对点通道发送消息，它将确保只有一个接收者会收到消息。如果通道有多个接收者，只有其中之一能够接收到消息。如果有多个接收者尝试消费消息，通道将确保其中只有一个能够成功。但这并不阻止通道有多个接收者，并且它们可以同时接收多个消息。这里唯一的条件是只有一个接收者会收到特定的消息：
- en: '![](img/c5f7a89b-ab4c-4abf-aa70-2491f1e8c2fb.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5f7a89b-ab4c-4abf-aa70-2491f1e8c2fb.png)'
- en: Publish-subscribe channel pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布-订阅通道模式
- en: 'This pattern will be of use for applications that use messaging to announce
    events. The announcement of events will involve sending messages to multiple receivers
    simultaneously. If the message is sent on a publish-subscribe channel, a copy
    of the message will be sent to each receiver:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将适用于使用消息来宣布事件的那些应用。事件的宣布将涉及同时向多个接收者发送消息。如果消息是在发布-订阅通道上发送的，消息的副本将被发送到每个接收者：
- en: '![](img/0035adc9-cfb5-4b78-8c4c-599b05d74cba.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0035adc9-cfb5-4b78-8c4c-599b05d74cba.png)'
- en: A publish-subscribe channel works basically like a broadcast mechanism. It has
    one input channel which is split into several output channels, one for each subscriber.
    When an event is published in the channel, a copy of the message is delivered
    to each of the output channels that are attached to it. Each output channel has
    only one subscriber attached to it. Each subscriber can consume the message only
    once. In this way, each subscriber gets a message only once and the message copies
    disappear from the channel once they are consumed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅通道基本上就像一个广播机制。它有一个输入通道，该通道被分成几个输出通道，每个订阅者一个。当一个事件在通道中发布时，消息的副本被发送到与之相连的每个输出通道。每个输出通道只有一个订阅者。每个订阅者只能消费消息一次。这样，每个订阅者只能得到一次消息，一旦被消费，消息副本就会从通道中消失。
- en: Datatype channel pattern
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型通道模式
- en: 'If several types of data are transmitted through a channel, it is important
    to differentiate the various formats of data. This is where the datatype channel
    pattern comes in handy. The diagram of a datatype channel pattern is depicted
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过一个通道传输多种类型的数据，区分各种数据格式就很重要。这就是数据类型通道模式派上用场的地方。数据类型通道模式的图示如下：
- en: '![](img/3a5f93fc-1daa-4709-9370-858824766d29.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a5f93fc-1daa-4709-9370-858824766d29.png)'
- en: If a datatype channel is used for each type of data, messages on a specific
    channel will contain only the same type of data. The sender should know the type
    of data and send it through the appropriate channel for that type of data. The
    receiver should be able to know the type of data based on the channel from which
    it received the data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每种类型的数据使用数据类型通道，特定通道上的消息将只包含相同类型的数据。发送者应该知道数据的类型，并通过适合该类型数据的适当通道发送它。接收者应该能够根据接收数据所在的通道知道数据的类型。
- en: Message bus patterns
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息总线模式
- en: 'In enterprises, there will be several disparate systems. These systems should
    be able to communicate and share data with one another and operate seamlessly
    for the effective functioning of the enterprise. This is where the message bus
    pattern comes in handy. The architecture of the message bus pattern is depicted
    in the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中，将存在几个不同的系统。这些系统应该能够相互通信和共享数据，以便企业能够无缝地运作。这就是消息总线模式派上用场的地方。消息总线模式的架构在以下图中展示：
- en: '![](img/89a0d428-a63a-44ef-ace0-e23bce53b1b7.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89a0d428-a63a-44ef-ace0-e23bce53b1b7.png)'
- en: 'If the various applications are interconnected using a message bus, it allows
    them to communicate seamlessly using messages. The following are the main components
    of a message bus:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果各种应用程序通过消息总线相互连接，它允许它们通过消息无缝地通信。以下是一个消息总线的主要组件：
- en: '**Common data model**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用数据模型**'
- en: '**Common command set**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常用命令集**'
- en: '**Messaging infrastructure**: This component allows the various systems to
    communicate using a shared set of interfaces'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息基础设施**：该组件允许各种系统通过共享的接口进行通信'
- en: The concept of a message bus is very similar to that of a communication bus
    which is used in a computer. The communication bus facilitates communication among
    the various components of a computer such as CPU, memory, peripheral devices,
    and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消息总线概念与计算机中使用的通信总线概念非常相似。通信总线促进了计算机各个组件（如CPU、内存、外围设备等）之间的通信。
- en: Command message patterns
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令消息模式
- en: 'If an application wants to invoke the functionality provided by another application,
    the most commonly used method is remote procedure invocation. But if remote procedure
    invocation has to be used along with the concept of messaging, command message
    patterns are very useful. The diagram of the **command message** pattern is depicted
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序想要调用另一个应用程序提供的功能，最常用的方法是远程过程调用。但如果必须结合消息的概念使用远程过程调用，命令消息模式就非常有用。**命令消息**模式的图示如下：
- en: '![](img/48ab2050-00ff-430f-962e-f2112b71a30e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48ab2050-00ff-430f-962e-f2112b71a30e.png)'
- en: A command message is a message that is reliably used to invoke a procedure that
    is running in another application. There is no specific type for a command message.
    Command messages are normal messages that have a command embedded in them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命令消息是一种可靠地用于调用在另一个应用程序中运行的程序的消息。命令消息没有特定的类型。命令消息是嵌入命令的正常消息。
- en: Event message patterns
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件消息模式
- en: 'Several applications communicate with one another using events. If event-based
    communication happens from using messages, then event message patterns are used.
    The event message pattern is depicted in the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 几个应用程序通过事件相互通信。如果基于消息的事件通信发生，则使用事件消息模式。以下图示了事件消息模式：
- en: '![](img/b675b2ad-762b-4724-b6f5-fc78a230a087.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b675b2ad-762b-4724-b6f5-fc78a230a087.png)'
- en: In an event message pattern, if the subject has to announce an event, it will
    first create an event object. This object is then wrapped in a message and sent
    on a channel. The observer will receive the event from the channel and process
    it. Messaging in events does not alter the event notification; it just ensures
    that the notification reaches the observer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件消息模式中，如果主题需要宣布一个事件，它将首先创建一个事件对象。然后，这个对象被封装在一个消息中，并通过一个通道发送。观察者将从通道接收事件并处理它。事件中的消息传递不会改变事件通知；它只是确保通知到达观察者。
- en: Request-reply pattern
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-回复模式
- en: 'When applications communicate through messaging, it is typically one-way communication.
    Suppose if the applications want a two-way communication, then a request-reply
    pattern is used. In a request-reply pattern, the request message and the reply
    message will have their own channels. The diagram of a request-reply pattern is
    depicted as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序通过消息通信时，通常是单向通信。假设如果应用程序想要双向通信，那么将使用请求-回复模式。在请求-回复模式中，请求消息和回复消息将有自己的通道。请求-回复模式的图示如下：
- en: '![](img/e49510e7-dfd4-4bde-b7d2-bde80a4f8e45.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e49510e7-dfd4-4bde-b7d2-bde80a4f8e45.png)'
- en: Content-based router pattern
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的路由器模式
- en: 'In many enterprises, a single function is spread across several systems. In
    such situations, it is important to ensure that the message goes through each
    of the systems that contain the function. In such situations, the content-based
    router pattern becomes very helpful. The content-based router pattern is depicted
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多企业中，单个功能分布在几个系统中。在这种情况下，确保消息通过包含该功能的每个系统非常重要。在这种情况下，基于内容的路由器模式非常有帮助。以下图示了基于内容的路由器模式：
- en: '![](img/0b0ea4aa-52f2-4a84-8f94-6b8ece299f6f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b0ea4aa-52f2-4a84-8f94-6b8ece299f6f.png)'
- en: 'The content-based router pattern examines the content of the message and then
    routes the message onto the correct channel based on the data that is contained
    in the message. The parameters on which the message is routed could be one of
    the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的路由器模式检查消息的内容，然后根据消息中包含的数据将消息路由到正确的通道。消息路由的参数可能是以下之一：
- en: Existence of certain data values in specific fields
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些特定字段中存在或不存在某些数据值
- en: Presence or absence of certain fields in the message
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息中某些字段的呈现或缺失
- en: It is very important to ensure that in a content-based router, the routing function
    that is implemented in the router should be easy to maintain. It is also possible
    to maintain a content-based router in the form of a rules engine that calculates
    the destination channel based on a set of pre-configured rules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容路由器中，确保实现的路由功能易于维护非常重要。也可以将基于内容的路由器维护为一种规则引擎，该引擎根据一组预配置的规则计算目标通道。
- en: Message filter pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息过滤器模式
- en: 'In many scenarios, there will be situations in which we are interested in receiving
    some kind of promotional messages/discounting messages, say for example from an
    e-commerce website based on a certain product that you may be interested in buying.
    But this may not be applicable to all messages. So in such situations, it is important
    to ensure that the unwanted messages get blocked or filtered. In such situations,
    the message filter pattern becomes very useful. The diagram depicting the message
    filter pattern is given as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，我们可能会对接收某些促销消息/折扣消息感兴趣，例如来自一个你可能感兴趣购买产品的电子商务网站。但这可能不适用于所有消息。因此，在这种情况下，确保不希望的消息被阻止或过滤非常重要。在这种情况下，消息过滤器模式非常有用。以下图示了消息过滤器模式：
- en: '![](img/08924386-a3c8-4f1a-aa26-35ccfcda4a63.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08924386-a3c8-4f1a-aa26-35ccfcda4a63.png)'
- en: The message filter has only a single output channel. If the data present in
    the message matches the specific output criteria that are mentioned by the message
    filter, the message is routed to the output channel, else it is discarded.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 消息过滤器只有一个输出通道。如果消息中的数据与消息过滤器提到的特定输出标准匹配，则消息将被路由到输出通道，否则将被丢弃。
- en: Resequencer pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新排序模式
- en: 'When a message routing pattern is used, messages get routed through several
    systems based on the fulfillment of certain criteria or rules. But when messages
    pass through several systems, there is a likelihood that they get out of order.
    In these situations, the **resequencer** pattern comes in handy. The diagram depicting
    the resequencer pattern is given as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用消息路由模式时，消息会根据某些标准或规则的满足情况进行路由。但是，当消息通过多个系统时，它们可能会出现顺序混乱。在这些情况下，**重排序器**模式就派上用场。描述重排序器模式的图示如下：
- en: '![](img/6fe3ffd4-a06f-484b-a006-ce7bca2dd763.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fe3ffd4-a06f-484b-a006-ce7bca2dd763.png)'
- en: The resequencer is a stateful filter that can be used to reorder messages so
    that they can be published in a specific sequence to the output channel. The resequencer
    contains an internal buffer that stores a sequence of messages until the complete
    sequence is obtained. The in-sequence messages are published immediately to the
    output channel. The out-of-sequence messages are kept in the internal buffer until
    they are placed in sequence and then they are sent to the output channel. The
    resequencer just makes the message in-sequence; it does not generally modify the
    contents of the message.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重排序器是一个有状态的过滤器，可以用来重新排序消息，以便它们可以按照特定的顺序发布到输出通道。重排序器包含一个内部缓冲区，用于存储一系列消息，直到获得完整的序列。顺序正确的消息会立即发布到输出通道。顺序不正确的消息将保留在内部缓冲区中，直到它们被放置在正确的顺序，然后发送到输出通道。重排序器只是确保消息的顺序，通常不会修改消息的内容。
- en: Polling consumer pattern
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询消费者模式
- en: 'There will be several situations in which the application may not always be
    ready to consume messages. In such situations, the application would like to reach
    a state of readiness before it starts consuming messages. In such situations,
    the polling consumer pattern becomes very helpful. The diagram of a polling consumer
    pattern is depicted as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序可能并不总是准备好消费消息。在这种情况下，应用程序希望在开始消费消息之前达到一个准备就绪的状态。在这种情况下，轮询消费者模式非常有帮助。轮询消费者模式的图示如下：
- en: '![](img/5d9c4c53-a8d1-40ef-bfb8-881c8b3ff469.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d9c4c53-a8d1-40ef-bfb8-881c8b3ff469.png)'
- en: In this pattern, the application uses a polling consumer, which makes a call
    as and when it is ready to receive a message. The polling consumer is also known
    as a **synchronous receiver**. This is because the receiver thread is in a blocked
    state until a message is received. Most of the messaging APIs provide a `receive`
    method, which blocks until a message is delivered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，应用程序使用轮询消费者，它在准备好接收消息时进行调用。轮询消费者也被称为**同步接收器**。这是因为接收线程在接收到消息之前处于阻塞状态。大多数消息API都提供了一个`receive`方法，该方法会阻塞直到消息被投递。
- en: Channel adapter
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道适配器
- en: 'If applications communicate with the help of messaging, it is necessary to
    ensure that the applications can connect to the messaging system to send and receive
    messages. This is where the **channel adapter** is helpful. The diagram depicting
    the channel adapter pattern is shown as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序通过消息传递进行通信，确保应用程序可以连接到消息系统以发送和接收消息是必要的。这就是**通道适配器**发挥作用的地方。描述通道适配器模式的图示如下：
- en: '![](img/5ae36fb1-af71-4146-a095-16859e79f39a.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ae36fb1-af71-4146-a095-16859e79f39a.png)'
- en: A channel adapter should be able to access the application's API or data and
    publish messages on a channel based on this data. It should also be able to invoke
    the functionality inside the application and receive messages. The adapter ideally
    acts as a client to the messaging system. The channel adapter invokes the functions
    of the application through an interface that is supplied by the application. This
    helps an application to remain integrated with a messaging system if it has a
    proper channel adapter. In the next section, we will focus on mobile integration
    patterns, that is, patterns that are used for integrating mobile devices to enterprise
    systems.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通道适配器应该能够访问应用程序的API或数据，并根据这些数据在通道上发布消息。它还应该能够调用应用程序内的功能并接收消息。理想情况下，适配器充当消息系统的客户端。通道适配器通过应用程序提供的接口调用应用程序的功能。这有助于应用程序在拥有适当的通道适配器的情况下与消息系统保持集成。在下一节中，我们将关注移动集成模式，即用于将移动设备集成到企业系统中的模式。
- en: Mobile integration pattern
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动集成模式
- en: 'We need a faster way for mobile devices to integrate with enterprise services,
    and this necessitates the need for a mobile integration pattern. When we talk
    about the integration of mobile services with enterprises, there are two main
    possibilities that could arise during the integration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更快的方法来使移动设备与企业服务集成，这需要移动集成模式。当我们谈论移动服务与企业集成时，在集成过程中可能会出现两种主要可能性：
- en: A mobile application that is integrated with some function of the enterprise
    sends a request message to the enterprise system and gets a response in return
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与企业某些功能集成的移动应用程序向企业系统发送请求消息，并得到相应的响应
- en: An enterprise system sends a push notification message to a mobile application
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业系统向移动应用程序发送推送通知消息
- en: 'This flow is shown in the following diagram:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了该流程：
- en: '![](img/e062f8b9-83da-497b-9620-d222772195a9.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/e062f8b9-83da-497b-9620-d222772195a9.png)'
- en: Request-response pattern
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应模式
- en: 'To define a request-response pattern, it is necessary to ensure that mobile-ready
    interfaces are present in the enterprise services that are created in the ESB.
    This pattern provides support for the integration of mobile services in an ESB
    architecture. A special type of adapter customized for mobile services called
    a **mobile integration adapter** helps to integrate mobile applications with the
    mobile-related services that are running in the ESB. The major steps involved
    in this mobile integration are depicted in the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义请求-响应模式，必须确保在ESB中创建的企业服务中存在移动就绪的接口。此模式为在ESB架构中集成移动服务提供支持。一种专门为移动服务定制的适配器，称为**移动集成适配器**，有助于将移动应用程序与在ESB中运行的与移动相关的服务集成。以下图表展示了该移动集成涉及的主要步骤：
- en: '![](img/d55b340d-4615-48f4-8567-4ff11b773d15.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/d55b340d-4615-48f4-8567-4ff11b773d15.png)'
- en: 'Here is how the integration happens:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何进行集成的：
- en: As a first step, the mobile adapter sends the inbound request directly to the
    enterprise service.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，移动适配器将传入请求直接发送到企业服务。
- en: Then the enterprise service present in the ESB establishes a connection with
    the required backend systems to process the inbound request. The ESB also works
    with the backend systems to get a response.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，存在于ESB中的企业服务与所需的后端系统建立连接以处理传入请求。ESB还与后端系统协作以获取响应。
- en: At last, the ESB sends the response to the mobile adapter which in turn passes
    the response back to the mobile application.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，ESB将响应发送到移动适配器，然后适配器将响应回传给移动应用程序。
- en: Defining a push notification pattern
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义推送通知模式
- en: 'Push notification patterns are used if an enterprise application wants to send
    push notifications to the mobile devices. The steps involved in defining the push
    notification are depicted in the following diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果企业应用程序想要向移动设备发送推送通知，则使用推送通知模式。定义推送通知涉及的步骤在以下图表中展示：
- en: '![](img/5cc4d665-0a99-4f7e-b45b-53c05609e9d7.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/5cc4d665-0a99-4f7e-b45b-53c05609e9d7.png)'
- en: 'Enterprise applications typically use a backend service that is running on
    the mobile integration server to push the notification messages to devices. The
    following are the main steps in the workflow of the process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常使用在移动集成服务器上运行的后端服务来将通知消息推送到设备。以下是该流程的主要步骤：
- en: The enterprise application sends a push notification to the mobile device using
    the ESB and mobile backend service
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 企业应用程序使用ESB和移动后端服务向移动设备发送推送通知
- en: Once the ESB receives the notification, it calls the mobile backend service
    to send push notifications to the mobile device
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦ESB收到通知，它就调用移动后端服务向移动设备发送推送通知
- en: Messages pass through the mobile integration server to reach the mobile application
    and the mobile device
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息通过移动集成服务器传递，以到达移动应用程序和移动设备
- en: At the start of the chapter, we discussed several types of external applications
    getting integrated with the enterprise systems. In the next section, we will have
    an overview of the API management pattern. In this section, we will focus briefly
    on the integration aspects while using microservices/API-based design concepts
    in architecture.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了几种外部应用程序与企业系统集成的类型。在下一节中，我们将概述API管理模式。在本节中，我们将简要关注在架构中使用基于微服务/API的设计概念时的集成方面。
- en: API management pattern
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API管理模式
- en: 'The API management pattern integrates applications with enterprise systems
    and other cloud-based services using APIs. The following are the main components
    of the API management pattern:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: API管理模式通过API将应用程序与企业系统和其他基于云的服务集成。以下是API管理模式的主要组成部分：
- en: API management portal
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API管理门户
- en: API user
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API用户
- en: Enterprise services
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业服务
- en: The consumer of each API service first sends a request to the API management
    portal. The API management portal interacts with the enterprise service before
    sending a response to the consumer. APIs use industry-standard formats for messages
    such as SOAP for web services and XML or JSON for representational state transfer.
    The API management portal acts as a simple proxy and helps to forward request
    and response messages to and from the backend.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API服务的消费者首先向API管理门户发送请求。API管理门户在向消费者发送响应之前与企业服务进行交互。API使用行业标准的消息格式，例如，对于Web服务使用SOAP，对于表示状态转移使用XML或JSON。API管理门户充当简单的代理，并帮助将请求和响应消息转发到后端。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'At the start of the chapter, we examined several types of integration scenarios
    that exist in enterprises. Some of the key integration scenarios that exist in
    enterprises are the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们检查了企业中存在的一些集成场景。企业中存在的一些关键集成场景包括以下内容：
- en: Information portals
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息门户
- en: Data replication
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据复制
- en: Shared business functions
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享业务功能
- en: Service-oriented architectures
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: Distributed business processes
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式业务流程
- en: Business-to-business integration
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业对商业集成
- en: After covering these topics, the main challenges faced in application integration
    were discussed. The techniques to overcome these challenges were also discussed.
    In the next section of the chapter, we discussed several types of messaging patterns
    at length. After messaging patterns, prominent mobile integration patterns were
    discussed. We concluded the chapter with a brief discussion of the API management
    pattern, which is the most recent trend in the industry.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖这些主题之后，我们讨论了在应用集成中面临的主要挑战。同时也讨论了克服这些挑战的技术。在章节的下一段，我们详细讨论了几种消息模式。在消息模式之后，我们讨论了突出的移动集成模式。我们以对API管理模式的简要讨论结束了本章，这是行业中最新的趋势。
