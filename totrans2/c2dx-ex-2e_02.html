<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. You Plus C++ Plus Cocos2d-x</h1></div></div></div><p class="calibre6">
<em class="calibre8">This chapter will be aimed at two types of developers: the original Cocos2d developer who is scared of C++ but won't admit it to his friends and the C++ coder who never even heard of Cocos2d and finds Objective-C funny looking.</em>
</p><p class="calibre6">
<em class="calibre8">I'll go over the main syntax differences Objective-C developers should pay attention to and the few code style changes involved in developing with Cocos2d-x that C++ developers should be aware of. But first, a quick introduction to Cocos2d-x and what it is all about.</em>
</p><p class="calibre6">You will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem">What Cocos2d-x is and what it can do for you</li><li class="listitem">How to create classes in C++</li><li class="listitem">How to memory manage your objects in Cocos2d-x and C++</li><li class="listitem">What you get out of Ref</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec20" class="calibre1"/>Cocos2d-x – an introduction</h1></div></div></div><p class="calibre6">So <a id="id44" class="calibre1"/>what is a 2D framework? If I had to define it in as few words as possible, I'd say rectangles in a loop.</p><p class="calibre6">At the heart of Cocos2d-x, you find the <code class="email">Sprite</code> class and what that class does, in simple terms, is keep a reference to two very important rectangles. One is the image (or texture) rectangle, also called the source rectangle, and the other is the destination rectangle. If you want an image to appear in the center of the screen, you will use <code class="email">Sprite</code>. You will pass it the information of what and where that image source is and where on the screen you want it to appear.</p><p class="calibre6">There is not much that needs to be done to the first rectangle, the source one; but there is a lot that can be changed in the destination rectangle, including its position on the screen, its size, opacity, rotation, and so on.</p><p class="calibre6">Cocos2d-x will then take care of all the OpenGL drawing necessary to display your image where you want it and how you want it, and it will do so inside a render loop. Your code will most likely tap into that same loop to update its own logic.</p><p class="calibre6">Pretty<a id="id45" class="calibre1"/> much any 2D game you can think of can be built with Cocos2d-x with a few sprites and a loop.</p><div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre6">In Version 3.x of the framework, there was a mild separation between Cocos2d-x and its counterpart Cocos2d. It dropped the prefix CC in favor of namespaces, embraced C++11 features, and became that much nicer to work with because of it.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec21" class="calibre1"/>Containers</h2></div></div></div><p class="calibre6">Also<a id="id46" class="calibre1"/> important in Cocos2d-x is the notion of containers (or nodes). These are all the objects that can have sprites inside them (or other nodes.) This is extremely useful at times because by changing aspects of the container, you automatically<a id="id47" class="calibre1"/> change aspects of its children. Move the container and all its children will move with it. Rotate the container and well, you get the picture!</p><p class="calibre6">The <a id="id48" class="calibre1"/>containers are: <code class="email">Scene</code>, <code class="email">Layer</code>, and <code class="email">Sprite</code>. They all inherit from a base container class called <strong class="calibre7">node</strong>. Each container will have its peculiarities, but basically you will arrange them as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Scene</code>: This <a id="id49" class="calibre1"/>will contain one or more <code class="email">Node</code>, usually <code class="email">Layer</code> types. It is common to break applications into multiple scenes; for instance, one for the main menu, one for settings, and one for the actual game. Technically, each scene will behave as a separate entity in your application, almost as subapplications themselves, and you can run a series of transition effects when changing between scenes.</li><li class="listitem"><code class="email">Layer</code>: This will <a id="id50" class="calibre1"/>most likely contain <code class="email">Sprite</code>. There are a number of specialized <code class="email">Layer</code> objects aimed at saving you, the developer, some time in creating things such as menus for instance (<code class="email">Menu</code>), or a colored background (<code class="email">LayerColor</code>). You can have more than one <code class="email">Layer</code> per scene, but good planning makes this usually unnecessary.</li><li class="listitem"><code class="email">Sprite</code>: This <a id="id51" class="calibre1"/>will contain your images and be added as children to <code class="email">Layer</code> derived containers. To my mind, this is the most important class in all of Cocos2d-x, so much so, that after your application initializes, when both a <code class="email">Scene</code> and a <code class="email">Layer</code> object are created, you could build your entire game only with sprites and never use another container class in Cocos2d-x.</li><li class="listitem"><code class="email">Node</code>: This super class to all containers blurs the line between itself and <code class="email">Layer</code>, and even <code class="email">Sprite</code> at times. It has its own set of specialized subclasses (besides the ones mentioned earlier), such as <code class="email">MotionStreak</code>, <code class="email">ParallaxNode</code>, and <code class="email">SpriteBatchNode</code>, to name a few. It can, with a few adjustments, behave just <a id="id52" class="calibre1"/>as <code class="email">Layer</code>. But most of the time you will use it to<a id="id53" class="calibre1"/> create your own specialized nodes or as a general reference in polymorphism.</li></ul></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec22" class="calibre1"/>The Director and cache classes</h2></div></div></div><p class="calibre6">After <a id="id54" class="calibre1"/>containers comes the all-knowing <code class="email">Director</code> and all-encompassing cache objects. The <code class="email">Director</code> object manages scenes and knows all about <a id="id55" class="calibre1"/>your application. You will make calls to it to get to that information and to change some of the things such as screen size, frame rate, scale factor, and so forth.</p><p class="calibre6">The caches are collector objects. The most important ones are <code class="email">TextureCache</code>, <code class="email">SpriteFrameCache</code>, and <code class="email">AnimationCache</code>. These are responsible for storing key information regarding those two important rectangles I mentioned about earlier. But every type of data that is used repeatedly in Cocos2d-x will be kept in some sort of cache list.</p><p class="calibre6">Both <code class="email">Director</code> and all cache objects are singletons. These are special sort of classes that are instantiated only once; and this one instance can be accessed by any other object.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec23" class="calibre1"/>The other stuff</h2></div></div></div><p class="calibre6">After the basic containers, the caches and the <code class="email">Director</code> object, comes the remaining 90 percent of the framework. Among all this, you will find:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre7">Actions</strong>: Animations<a id="id56" class="calibre1"/> will be handled through these and what a treat they are!</li><li class="listitem"><strong class="calibre7">Particles</strong>: Particles<a id="id57" class="calibre1"/> systems for your delight.</li><li class="listitem"><strong class="calibre7">Specialized nodes</strong>: For things such as menus, progress bars, special effects, parallax<a id="id58" class="calibre1"/> effect, tile maps, and much, much more.</li><li class="listitem"><strong class="calibre7">The macros, structures, and helper methods</strong>: Hundreds of time-saving, magical <a id="id59" class="calibre1"/>bits of logic. You don't need to know them all, but <a id="id60" class="calibre1"/>chances are that you will be coding<a id="id61" class="calibre1"/> something that can be easily replaced by a macro or a helper method and feel incredibly silly when you find out about it later.</li></ul></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec24" class="calibre1"/>Do you know C++?</h2></div></div></div><p class="calibre6">Don't worry, the<a id="id62" class="calibre1"/> C part is easy. The first plus goes by really fast, but that second plus, oh boy!</p><p class="calibre6">Remember, it is C. And if you have coded in Objective-C with the original Cocos2d, you know good old C already even if you saw it in between brackets most of the time.</p><p class="calibre6">But C++ also has classes, just like Objective-C, and these classes are declared in the interface files just like in Objective-C. So let's go over the creation of a C++ class.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>The class interface</h1></div></div></div><p class="calibre6">This <a id="id63" class="calibre1"/>will be done in a <code class="email">.h</code> file. We'll use a text editor to create this file since I don't want any code hinting and autocompletion features getting in the way of you learning the basics of C++ syntax. So for now at least, open up your favorite text editor. Let's create a class interface!</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Time for action – creating the interface</h1></div></div></div><p class="calibre6">The<a id="id64" class="calibre1"/> interface, or header file, is just a text file with the <code class="email">.h</code> extension.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new text file and save it as <code class="email">HelloWorld.h</code>. Then, enter the following lines at the top:<div><pre class="programlisting">#ifndef __HELLOWORLD_H__
#define __HELLOWORLD_H__
#include "cocos2d.h" </pre></div></li><li class="listitem" value="2">Next, add the namespace declaration:<div><pre class="programlisting">using namespace cocos2d;</pre></div></li><li class="listitem" value="3">Then, declare your class name and the name of any inherited classes:<div><pre class="programlisting">class HelloWorld : <strong class="calibre7">public cocos2d::Layer {</strong>
</pre></div></li><li class="listitem" value="4">Next, we add the properties and methods:<div><pre class="programlisting">protected:
int _score;

public:

    HelloWorld();
    virtual ~HelloWorld();

    virtual bool init();
    static cocos2d::Scene* scene();
    CREATE_FUNC(HelloWorld);
    void update(float dt);
    inline int addTwoIntegers (int one, int two) {
        return one + two;
    }
};</pre></div></li><li class="listitem" value="5">We<a id="id65" class="calibre1"/> finish by closing the <code class="email">#ifndef</code> statement:<div><pre class="programlisting">#endif // __HELLOWORLD_H__</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec25" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You created a header file in C++. Let's go over the important bits of information:</p><div><ul class="itemizedlist"><li class="listitem">In C++ you include, you do not import. The <code class="email">import</code> statement in Objective-C checks whether something needs to be included; <code class="email">include</code> does not. But we accomplish the same thing through that clever use of definitions at the top. There are other ways to run the same check (with <code class="email">#pragma once</code>, for instance) but this one is added to any new C++ files you create in Xcode.</li><li class="listitem">You can make your life easier by declaring the namespaces you'll use in the class. These are similar to packages in some languages. You may have noticed that all the uses of <code class="email">cocos2d::</code> in the code are not necessary because of the namespace declaration. But I wanted to show you the bit you can get rid of by adding a namespace declaration.</li><li class="listitem">So next you give your class a name and you may choose to inherit from some other class. In C++ you can have as many super classes as you want. And you must declare whether your super class is public or not.</li><li class="listitem">You declare your <code class="email">public</code>, <code class="email">protected</code> and <code class="email">private</code> methods and members between the curly braces. <code class="email">HelloWorld</code> is the constructor and <code class="email">~HelloWorld</code> is the destructor (it will do what <code class="email">dealloc</code> does in Objective-C).</li><li class="listitem">The <code class="email">virtual</code> keyword is related to overrides. When you mark a method as <code class="email">virtual,</code> you are telling the compiler not to set in stone the owner of the method, but to keep it in memory as execution will reveal the obvious owner. Otherwise, the compiler may erroneously decide that a method belongs to the super and not its inheriting class.<p class="calibre13">Also, it's good practice to make all your destructors <code class="email">virtual</code>. You only need use the keyword once in the super class to mark potential overrides, but it is common practice to repeat the <code class="email">virtual</code> keyword in all subclasses so developers know which methods are overrides (C++11 adds a tag <code class="email">override,</code> which makes this distinction even clearer, and you will see examples of it in this book's code). In this case, <code class="email">init</code> comes from <code class="email">Layer</code> and <code class="email">HelloWorld</code> wants to override it.</p><div><pre class="programlisting">    virtual bool init();</pre></div></li><li class="listitem">Oh yes, in C++ you must declare overrides in your interfaces. No exceptions!</li></ul></div><p class="calibre6">The <code class="email">inline</code> method is something new to you, probably. These methods are added to the code by the compiler wherever they are called for. So every time I make a call to <code class="email">addTwoIntegers</code>, the compiler will replace it with the lines for the method declared in the interface. So the <code class="email">inline</code> method works just as statements inside a method; they do not require <a id="id66" class="calibre1"/>their own bit of memory in the stack. But if you have a two-line <code class="email">inline</code> method called 50 times in your program, it means that the compiler will add a hundred lines to your code.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>The class implementation</h1></div></div></div><p class="calibre6">This <a id="id67" class="calibre1"/>will be done in a <code class="email">.cpp</code> file. So let's go back to our text editor and create the implementation for our <code class="email">HelloWorld</code> class.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Time for action – creating the implementation</h1></div></div></div><p class="calibre6">The<a id="id68" class="calibre1"/> implementation is a text file with the <code class="email">.cpp</code> extension:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new text file and save it as <code class="email">HelloWorld.cpp</code>. At the top, let's start by including our header file:<div><pre class="programlisting">#include "HelloWorld.h"</pre></div></li><li class="listitem" value="2">Next, we implement our constructor and destructor:<div><pre class="programlisting">
<strong class="calibre7">HelloWorld::HelloWorld () {</strong>
    //constructor
}

HelloWorld::~HelloWorld () {
    //destructor
}</pre></div></li><li class="listitem" value="3">Then comes our static method:<div><pre class="programlisting">Scene* HelloWorld::scene() {
    auto scene = Scene::create();
    
    auto layer = HelloWorld::create();

    scene-&gt;addChild(layer);

    return scene;
}</pre></div></li><li class="listitem" value="4">And then come our two remaining public methods:<div><pre class="programlisting">bool HelloWorld::init() {
    // call to super
    if ( !Layer::<strong class="calibre7">init()</strong> )
    {
        return false;
    }
    
    //create main loop 
    this-&gt;scheduleUpdate();
    
    return true;
}

void HelloWorld::update (float dt) {
    //the main loop
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec26" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We <a id="id69" class="calibre1"/>created the implementation for our <code class="email">HelloWorld</code> class. Here are the most important bits to take notice of:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">HelloWorld::</code> scope resolution is not optional here. Every single method declared in your interface belongs to the new class that needs the correct scope resolution in the implementation file.</li><li class="listitem">You also need the scope resolution when calling the super class like <code class="email">Layer::init()</code>. There is no built-in <code class="email">super</code> keyword in the standard C++ library.</li><li class="listitem">You use <code class="email">this</code> instead of <code class="email">self</code>. The <code class="email">-&gt;</code> notation is used when you're trying to access an object's properties or methods through a pointer to the object (a pointer is the information of where you find the actual object in memory). The <code class="email">.</code> (dot) notation is used to access an object's methods and properties through its actual instance (the blob of memory that comprises the actual object).</li><li class="listitem">We create an <code class="email">update</code> loop, which takes a float for its delta time value simply by calling <code class="email">scheduleUpdate</code>. You will see more options related to this later in this book.</li><li class="listitem">You can use the <code class="email">auto</code> keyword as the type of an object if it's obvious enough to the compiler which type an object is.</li><li class="listitem">The <code class="email">inline</code> methods, of course, are not implemented in the class since they exist only in the interface.</li></ul></div><p class="calibre6">And that's enough of syntax for now. C++ is one of the most extensive languages out there and I do not wish to leave you with the impression that I have covered all of it. But it is a language made by developers for developers. Trust me, you will feel right at home working with it.</p><p class="calibre6">The information listed previously will become clearer once we move on to building the games. But<a id="id70" class="calibre1"/> now, onwards to the big scary monster: memory management.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec25" class="calibre1"/>Instantiating objects and managing memory</h1></div></div></div><p class="calibre6">There <a id="id71" class="calibre1"/>is no <strong class="calibre7">Automatic Reference Counting</strong> (<strong class="calibre7">ARC</strong>) in Cocos2d-x, so Objective-C developers who have forgotten memory management might have a <a id="id72" class="calibre1"/>problem here. However, the rule regarding memory management is <a id="id73" class="calibre1"/>very simple with C++: if you use <code class="email">new</code>, you must delete. C++11 makes this even easier by introducing special pointers that are memory-managed (these are <code class="email">std::unique_ptr</code> and <code class="email">std::shared_ptr</code>).</p><p class="calibre6">Cocos2d-x, however, will add a few other options and commands to help with memory management, similar to the ones we have in Objective-C (without ARC). This is because Cocos2d-x, unlike C++ and very much like Objective-C, has a root class. The framework is more than just a C++ port of Cocos2d. It also ports certain notions of Objective-C to C++ in order to recreate its memory-management system.</p><p class="calibre6">Cocos2d-x has a <code class="email">Ref</code> class that is the root of every major object in the framework. It allows the framework to have <code class="email">autorelease</code> pools and <code class="email">retain</code> counts, as well other Objective-C equivalents.</p><p class="calibre6">When instantiating Cocos2d-x objects, you have basically two options:</p><div><ul class="itemizedlist"><li class="listitem">Using static methods</li><li class="listitem">The C++ and Cocos2d-x style</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec27" class="calibre1"/>Using static methods</h2></div></div></div><p class="calibre6">Using static methods is the <a id="id74" class="calibre1"/>recommended way. The three-stage instantiation process <a id="id75" class="calibre1"/>of Objective-C, with <code class="email">alloc</code>, <code class="email">init</code>, and <code class="email">autorelease</code>/<code class="email">retain</code>, is recreated here. So, for instance, a <code class="email">Player</code> class, which extends <code class="email">Sprite</code>, might have the following methods:</p><div><pre class="programlisting">Player::Player () {
    this-&gt;setPosition  ( Vec2(0,0) );
}

Player* Player::create () {
    
    auto player = new Player();
    if (player &amp;&amp; player-&gt;initWithSpriteFrameName("player.png")) {
        player-&gt;autorelease();
        return player;
    }
    CC_SAFE_DELETE(player);
    return nullptr;
}</pre></div><p class="calibre6">For<a id="id76" class="calibre1"/> instantiation, you call the static <code class="email">create</code> method. It will create a <a id="id77" class="calibre1"/>new <code class="email">Player</code> object as an empty husk version of <code class="email">Player</code>. No major initialization should happen inside the constructor, just in case you may have to delete the object due to some failure in the instantiation process. Cocos2d-x has a series of macros for object deletion and release, like the <code class="email">CC_SAFE_DELETE</code> macro used previously.</p><p class="calibre6">You then initialize the super through one of its available methods. In Cocos2d-x, these <code class="email">init</code> methods return a <code class="email">boolean</code> value for success. You may now begin filling the <code class="email">Player</code> object with some data.</p><p class="calibre6">If successful, then initialize your object with its proper data if not done in the previous step, and return it as an <code class="email">autorelease</code> object.</p><p class="calibre6">So in your code the object would be instantiated as follows:</p><div><pre class="programlisting">auto player = Player::create();
this-&gt;addChild(player);//this will retain the object</pre></div><p class="calibre6">Even if the <code class="email">player</code> variable were a member of the class (say, <code class="email">m_player</code>), you wouldn't have to retain it to keep it in scope. By adding the object to some Cocos2d-x list or cache, the object is automatically retained. So you may continue to address that memory through its pointer:</p><div><pre class="programlisting">m_player = Player::create();
this-&gt;addChild(m_player);//this will retain the object
//m_player still references the memory address 
//but does not need to be released or deleted by you</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec28" class="calibre1"/>The C++ and Cocos2d-x style</h2></div></div></div><p class="calibre6">In this <a id="id78" class="calibre1"/>option, you would instantiate the previous <code class="email">Player</code> object as follows:</p><div><pre class="programlisting">auto player = new Player();
player-&gt;initWithSpriteFrameName("player.png");
this-&gt;addChild(player);
player-&gt;autorelease();</pre></div><p class="calibre6">
<code class="email">Player</code> could do <a id="id79" class="calibre1"/>without a static method in this case and the <code class="email">player</code> pointer <a id="id80" class="calibre1"/>will not access the same memory in future as it's set to be autoreleased (so it would not stick around for long). In this case, however, the memory would not leak. It would still be retained by a Cocos2d-x list (the <code class="email">addChild</code> command takes care of that). You can still access that memory by going over the children list added to <code class="email">this</code>.</p><p class="calibre6">If you needed the pointer to be a member property you could use <code class="email">retain()</code> instead of <code class="email">autorelease()</code>:</p><div><pre class="programlisting">m_player = new Player();
m_player-&gt;initWithSpriteFrameName("player.png");
this-&gt;addChild(m_player);
m_player-&gt;retain();</pre></div><p class="calibre6">Then <a id="id81" class="calibre1"/>sometime later, you would have to release it; otherwise, it will leak:</p><div><pre class="programlisting">m_player-&gt;release();</pre></div><p class="calibre6">Hardcore C++ developers may choose to forget all about the <code class="email">autorelease</code> pool and simply <a id="id82" class="calibre1"/>use <code class="email">new</code> and <code class="email">delete</code>:</p><div><pre class="programlisting">Player * player = new Player();
player-&gt;initWithSpriteFrameName("player.png");
this-&gt;addChild(player);
delete player;//This will crash!</pre></div><p class="calibre6">This <a id="id83" class="calibre1"/>will not work. You have to use <code class="email">autorelease</code>, <code class="email">retain</code>, or leave the previous code without the <code class="email">delete</code> command and hope there won't be any leak.</p><p class="calibre6">C++ developers must keep in mind that <code class="email">Ref</code> is managed by the framework. This means that objects are being internally added to caches and the <code class="email">autorelease</code> pool even though you may not want this to happen. When you create that <code class="email">Player</code> sprite, for instance, the <code class="email">player.png</code> file you used will be added to the texture cache, or the sprite frame cache. When you add the sprite to a layer, the sprite will be added to a list of all children of that layer, and this list will be managed by the framework. My advice is, relax and let the framework work for you.</p><p class="calibre6">Non-C++ developers should keep in mind that any class not derived from <code class="email">Ref</code> should be managed the usual way, that is, if <em class="calibre8">you</em> are creating a new object you must delete it at some point:</p><div><pre class="programlisting">MyObject* object = new MyObject();
delete object;</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec26" class="calibre1"/>What you get with Ref</h1></div></div></div><p class="calibre6">With <code class="email">Ref</code> you<a id="id84" class="calibre1"/> get managed objects. This means that <code class="email">Ref</code> derived objects will have a reference count property, which will be used to determine whether an object should be deleted from memory or not. The reference count is updated every time an object is added or removed from a Cocos2d-x collection object.</p><p class="calibre6">For instance, Cocos2d-x comes with a <code class="email">Vector</code> collection object that extends the functionality of the C++ standard library vector (<code class="email">std::vector</code>) by increasing and decreasing the reference count when objects are added and removed from it. For that reason, it can only store <code class="email">Ref</code> derived objects.</p><p class="calibre6">Once again, every <code class="email">Ref</code> derived class can be managed the way things used to be managed in Objective-C before ARC- with <code class="email">retain</code> counts and <code class="email">autorelease</code> pools.</p><p class="calibre6">C++, however, <a id="id85" class="calibre1"/>comes packed with its own wonderful dynamic list classes, similar to the ones you would find in Java and C#. But for <code class="email">Ref</code> derived objects, you would probably be best served by Cocos2d-x managed lists, or else remember to retain and release each object when applicable. If you create a class which does not extend <code class="email">Ref</code> and you need to store instances of this class in a list container, then choose the standard library ones.</p><p class="calibre6">In the examples that follow in this book I will code primarily from within the framework, so you will get to see plenty of examples of <code class="email">cocos2d::Vector</code> being used, for instance, but I will also use a <code class="email">std::vector</code> instance or two in some of the games.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec27" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">Hopefully, non-C++ developers have now learned that there is nothing to be feared from the language, and hardcore C++ developers have not scoffed too much at the notion of a root class and its retains and autoreleases.</p><p class="calibre6">All the stuff that root classes have brought to languages such as Java and Objective-C will forever be a moot point. The creepy, underlying operations that go on behind your back with root objects cannot be shut down or controlled. They are not optional, and this forceful nature of root objects has bothered C++ developers ever since notions such as garbage collectors first surfaced.</p><p class="calibre6">Having said that, memory management of <code class="email">Ref</code> objects is extremely helpful and I hope even the most distrustful developers will soon learn to be thankful for it.</p><p class="calibre6">Furthermore, Cocos2d-x is awesome. So let's create a game already!</p></div></body></html>