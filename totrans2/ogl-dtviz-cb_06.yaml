- en: Chapter 6. Rendering Stereoscopic 3D Models using OpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：使用 OpenGL 渲染立体 3D 模型
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing the Open Asset Import Library (Assimp)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Open Asset Import Library (Assimp)
- en: Loading the first 3D model in the Wavefront Object (.obj) format
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载第一个 Wavefront Object (.obj) 格式的 3D 模型
- en: Rendering 3D models with points, lines, and triangles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点、线和三角形渲染 3D 模型
- en: Stereoscopic 3D rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立体 3D 渲染
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will demonstrate how to visualize data with stunning stereoscopic
    3D technology using OpenGL. Stereoscopic 3D devices are becoming increasingly
    popular, and the latest generation's wearable computing devices (such as the 3D
    vision glasses from NVIDIA, Epson, and more recently, the augmented reality 3D
    glasses from Meta) can now support this feature natively.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何使用 OpenGL 将数据以惊人的立体 3D 技术可视化。立体 3D 设备越来越受欢迎，最新一代的可穿戴计算设备（如 NVIDIA、Epson
    的 3D 视觉眼镜，以及最近 Meta 的增强现实 3D 眼镜）现在可以原生支持此功能。
- en: The ability to visualize data in a stereoscopic 3D environment provides a powerful
    and highly intuitive platform for the interactive display of data in many applications.
    For example, we may acquire data from the 3D scan of a model (such as in architecture,
    engineering, and dentistry or medicine) and would like to visualize or manipulate
    3D objects in real time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在立体 3D 环境中可视化数据的能力为许多应用程序中数据的交互式显示提供了一个强大且高度直观的平台。例如，我们可能从模型的 3D 扫描（如建筑、工程、牙科或医学）中获取数据，并希望实时可视化或操作
    3D 对象。
- en: Unfortunately, OpenGL does not provide any mechanism to load, save, or manipulate
    3D models. Thus, to support this, we will integrate a new library named **Open
    Asset Import Library** (**Assimp**) into our code. The source code in this chapter
    is built on top of the *OpenGL point cloud rendering with texture mapping and
    overlays* recipe in [Chapter 5](ch05.html "Chapter 5. Rendering of Point Cloud
    Data for 3D Range-sensing Cameras"), *Rendering of Point Cloud Data for 3D Range-sensing
    Cameras*. The main dependencies include the GLFW library that requires OpenGL
    version 3.2 and higher. We will assume that you have all the prerequisite packages
    installed from earlier chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，OpenGL 不提供任何加载、保存或操作 3D 模型的机制。因此，为了支持这一点，我们将把一个名为 **Open Asset Import Library**
    (**Assimp**) 的新库集成到我们的代码中。本章中的源代码建立在 [第 5 章](ch05.html "第 5 章：为 3D 范围感应相机渲染点云数据")
    中 *OpenGL 点云渲染带纹理映射和叠加* 的配方之上，即 *为 3D 范围感应相机渲染点云数据*。主要依赖项包括需要 OpenGL 版本 3.2 及更高版本的
    GLFW 库。我们将假设您已经从早期章节安装了所有先决软件包。
- en: Installing the Open Asset Import Library (Assimp)
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Open Asset Import Library (Assimp)
- en: Assimp is an open source library that loads and processes 3D geometric scenes
    from various 3D model data formats. The library provides a unified interface to
    load many different data formats, such as **Wavefront Object** (**.obj**), **3ds
    Max 3DS** (**.3ds**), and **Stereolithography** (**.stl**). Moreover, this library
    is written in portable, ISO-compliant C++, and thus, it allows further customization
    and long-term support. Since the library is cross-platform, we can easily install
    it in Mac OS X, Linux, as well as Windows with the instructions given in the next
    section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Assimp 是一个开源库，可以从各种 3D 模型数据格式中加载和处理 3D 几何场景。该库提供了一个统一的接口来加载许多不同的数据格式，例如 **Wavefront
    Object** (**.obj**)、**3ds Max 3DS** (**.3ds**) 和 **Stereolithography** (**.stl**)。此外，这个库是用可移植的、符合
    ISO 标准的 C++ 编写的，因此它允许进一步的定制和长期支持。由于该库是跨平台的，我们可以很容易地按照下一节中给出的说明在 Mac OS X、Linux
    以及 Windows 中安装它。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To obtain the library source files or binary library for Assimp 3.0, download
    them directly from Assimp's official website at [http://sourceforge.net/projects/assimp/files/assimp-3.0/](http://sourceforge.net/projects/assimp/files/assimp-3.0/).
    Alternatively, for Linux and Mac OS X users, use the command-line interface to
    simplify the installation steps described next.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Assimp 3.0 的库源文件或二进制库，请直接从 Assimp 的官方网站 [http://sourceforge.net/projects/assimp/files/assimp-3.0/](http://sourceforge.net/projects/assimp/files/assimp-3.0/)
    下载。或者，对于 Linux 和 Mac OS X 用户，使用命令行界面简化下一节中描述的安装步骤。
- en: 'In Mac OS X, install Assimp using the MacPort''s command-line interface. It
    automatically resolves all dependencies, so this is recommended:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 中，使用 MacPort 的命令行界面安装 Assimp。它自动解决所有依赖项，因此这是推荐的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Linux, install Assimp using the `apt-get` command interface:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，使用 `apt-get` 命令界面安装 Assimp：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the installation, modify the Makefile to ensure the libraries are linked
    to the source files by appending the following to the `LIBS` variable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，修改 Makefile 以确保库文件通过将以下内容追加到 `LIBS` 变量中来链接到源文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'and the `INCLUDES` path variable, respectively:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分别添加到 `INCLUDES` 路径变量中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The final Makefile is shown here for your reference:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 Makefile 如下所示，供您参考：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To install Assimp in Windows, first, download the binary library from this
    link: [http://sourceforge.net/projects/assimp/files/assimp-3.0/assimp--3.0.1270-full.zip/download](http://sourceforge.net/projects/assimp/files/assimp-3.0/assimp--3.0.1270-full.zip/download).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Assimp，首先，从以下链接下载二进制库：[http://sourceforge.net/projects/assimp/files/assimp-3.0/assimp--3.0.1270-full.zip/download](http://sourceforge.net/projects/assimp/files/assimp-3.0/assimp--3.0.1270-full.zip/download)。
- en: 'Then, we configure the environment with the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照以下步骤配置环境：
- en: Unpack `assimp--3.0.1270-full.zip` and save it in `C:/Program Files (x86)/`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压 `assimp--3.0.1270-full.zip` 并将其保存到 `C:/Program Files (x86)/`。
- en: Add the DLL path, `C:/Program Files (x86)/assimp--3.0.1270-sdk/bin/assimp_release-dll_win32`,
    to the PATH environment variable.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 DLL 路径，`C:/Program Files (x86)/assimp--3.0.1270-sdk/bin/assimp_release-dll_win32`，添加到
    PATH 环境变量中。
- en: 'Include the `CMakeLists.txt` file to the project:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CMakeLists.txt` 文件添加到项目中：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, generate the build files with the same steps as described in [Chapter
    4](ch04.html "Chapter 4. Rendering 2D Images and Videos with Texture Mapping"),
    *Rendering 2D Images and Videos with Texture Mapping* and [Chapter 5](ch05.html
    "Chapter 5. Rendering of Point Cloud Data for 3D Range-sensing Cameras"), *Rendering
    of Point Cloud Data for 3D Range-sensing Cameras*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照 [第 4 章](ch04.html "第 4 章。使用纹理映射渲染 2D 图像和视频") 中描述的相同步骤，*使用纹理映射渲染 2D 图像和视频*
    和 [第 5 章](ch05.html "第 5 章。为 3D 范围感应相机渲染点云数据") 中描述的步骤，*为 3D 范围感应相机渲染点云数据*，生成构建文件。
- en: See also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In addition to importing 3D model objects, Assimp also supports the exporting
    of 3D models in `.obj`, `.stl`, and `.ply` formats. By combining this library
    with the OpenGL graphics rendering engine, we have created a simple yet powerful
    mechanism to visualize and exchange 3D models collaboratively or remotely. The
    Assimp library can also handle some postprocessing tasks of 3D scenes after importing
    the model (for example, splitting large meshes to overcome certain GPU limitations
    on vertex count). These additional features are documented on the official website
    and may be of interest to advanced users ([http://assimp.sourceforge.net/lib_html/index.html](http://assimp.sourceforge.net/lib_html/index.html)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入 3D 模型对象外，Assimp 还支持以 `.obj`、`.stl` 和 `.ply` 格式导出 3D 模型。通过将此库与 OpenGL 图形渲染引擎结合，我们创建了一个简单而强大的机制，用于协作或远程可视化并交换
    3D 模型。在导入模型后，Assimp 库还可以处理一些 3D 场景的后处理任务（例如，将大型网格分割以克服某些 GPU 对顶点数的限制）。这些附加功能在官方网站上有文档说明，可能对高级用户感兴趣（[http://assimp.sourceforge.net/lib_html/index.html](http://assimp.sourceforge.net/lib_html/index.html)）。
- en: Loading the first 3D model in the Wavefront Object (.obj) format
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载第一个 Wavefront Object (.obj) 格式的 3D 模型
- en: 'Now, we are ready to integrate a 3D object loader into our code. The first
    step is to create an empty class called `ObjLoader` along with the source (`.cpp`)
    and header (`.h`) files. This class handles all the functions related to 3D object
    loading, parsing, and drawing using the OpenGL and Assimp libraries. The headers
    of the class will include the Assimp core functions for the handling of the data
    structures and all I/O mechanisms of the 3D data format:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好将 3D 对象加载器集成到我们的代码中。第一步是创建一个名为 `ObjLoader` 的空类，以及相应的源文件（`.cpp`）和头文件（`.h`）。此类处理与
    3D 对象加载、解析和绘制相关的所有函数，使用 OpenGL 和 Assimp 库。类的头文件将包括用于处理数据结构和所有 3D 数据格式 I/O 机制的
    Assimp 核心函数：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `ObjLoader.h` file, we provide interfaces for the main program to create,
    destroy, load, and display the 3D data. In the `ObjLoader.cpp` file, we implement
    a set of functions to parse the scene (a hierarchical representation of the 3D
    objects in terms of meshes and faces) using the built-in functions from Assimp.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ObjLoader.h` 文件中，我们为主程序提供了创建、销毁、加载和显示 3D 数据的接口。在 `ObjLoader.cpp` 文件中，我们实现了一套函数，使用
    Assimp 的内置函数来解析场景（以网格和面为术语的 3D 对象的分层表示）。
- en: 'The Assimp library can support various 3D model data formats; however, in our
    example, we will focus on the Wavefront Object (`.obj`) format due to its simplicity.
    The `.obj` file is a simple geometric definition file that was first developed
    by Wavefront Technologies. The file contains the core elements of graphics, such
    as vertex, vertex position, normal face and so on, and is stored in a simple text
    format. Since the files are stored in ASCII text, we can easily open and examine
    the files without any parsers. For example, the following is the `.obj` file of
    a front-facing square:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Assimp库可以支持各种3D模型数据格式；然而，在我们的示例中，我们将专注于Wavefront Object（`.obj`）格式，因为它简单。`.obj`文件是一个简单的几何定义文件，最初由Wavefront
    Technologies开发。该文件包含图形的核心元素，如顶点、顶点位置、法线面等，并以简单的文本格式存储。由于文件以ASCII文本存储，我们可以轻松地打开和检查文件而无需任何解析器。例如，以下是一个面向前的正方形`.obj`文件：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see from the preceding example, the representation is quite simple
    and intuitive for beginners. The vertices can be read and extracted one line at
    a time, and then they can be modified.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，表示对于初学者来说非常简单直观。顶点可以逐行读取和提取，然后可以修改。
- en: In the next section, we will show the full implementation, which allows users
    to load the `.obj` file, store the scene in a vertex buffer object, and display
    the scene.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示完整的实现过程，它允许用户加载`.obj`文件，将场景存储在顶点缓冲对象中，并显示场景。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create the `ObjLoader.h` file in the common folder and append the
    class function definitions and variables that will be used in our implementation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在公共文件夹中创建`ObjLoader.h`文件，并附加将在我们的实现中使用的类函数定义和变量：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The names of classes from the Assimp library are preceded by the prefix `ai-`
    (for example, `aiScene` and `aiVector3D`). The `ObjLoader` file provides ways
    to dynamically load and draw the object loaded into the memory. It also handles
    simple dynamic scaling so that the object will fit on the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Assimp库中的类名前面带有前缀`ai-`（例如，`aiScene`和`aiVector3D`）。`ObjLoader`文件提供了动态加载和绘制内存中加载的对象的方法。它还处理简单的动态缩放，以便对象可以适应屏幕。
- en: 'In the source file, `ObjLoader.cpp`, we start by adding the constructor for
    the class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件`ObjLoader.cpp`中，我们首先添加类的构造函数：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we implement the file-loading mechanism with the `aiImportFile` function.
    The scene is processed to extract the bounding box size for proper scaling to
    fit the screen. The number of vertices of the scene is then used to allow dynamic
    vertex buffer creation in later steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`aiImportFile`函数实现文件加载机制。场景被处理以提取边界框大小，以便正确缩放以适应屏幕。然后，场景的顶点数被用于允许在后续步骤中动态创建顶点缓冲区：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To extract the total number of vertices required to draw the scene, we recursively
    walk through every node in the tree hierarchy. The implementation requires a simple
    recursive function that returns the number of vertices in each node, and then
    the total is calculated based on the summation of all nodes upon the return of
    the function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取绘制场景所需的顶点总数，我们递归地遍历树形层次结构中的每个节点。实现需要一个简单的递归函数，该函数返回每个节点中的顶点数，然后根据所有节点的总和计算总数：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, to calculate the size of the bounding box (that is, the minimum
    volume that is required to contain the scene), we recursively examine each node
    and extract the points that are farthest away from the center of the object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了计算边界框的大小（即包含场景所需的最小体积），我们递归地检查每个节点并提取距离对象中心最远的点：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The resulting bounding box allows us to calculate the scaling factor and recenter
    the object coordinate to fit within the viewable screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的边界框使我们能够计算缩放因子并将对象坐标重新居中，以适应可查看的屏幕。
- en: 'In the `main.cpp` file, we integrate the code by first inserting the header
    file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中，我们首先通过插入头文件来集成代码：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we create the `ObjLoader` object and load the model with the given filename
    in the main function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在主函数中创建`ObjLoader`对象，并使用给定的文件名加载模型：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ObjLoader` contains an algorithm that recursively examines each mesh and
    computes the bounding box and the number of vertices in the scene. Then, we dynamically
    allocate the vertex buffer based on the number of vertices and load the vertices
    into the buffer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjLoader`包含一个算法，该算法递归地检查每个网格，计算场景的边界框和顶点数。然后，我们根据顶点数动态分配顶点缓冲区并将顶点加载到缓冲区中：'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have all the necessary vertex information for display with our custom
    shader program written in OpenGL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了所有必要的顶点信息，可以使用我们用OpenGL编写的自定义着色器程序进行显示。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Assimp provides the mechanism to load and parse the 3D data format efficiently.
    The key feature we utilized is the hierarchical way to import 3D objects, which
    allows us to unify our rendering pipeline regardless of the 3D format. The `aiImportFile`
    function reads the given file and returns its content in the `aiScene` structure.
    The second parameter of this function specifies the optional postprocessing steps
    to be executed after a successful import. The `aiProcessPreset_TargetRealtime_MaxQuality`
    flag is a predefined variable, which combines the following set of parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Assimp提供了高效加载和解析3D数据格式的机制。我们利用的关键特性是以分层方式导入3D对象，这使得我们可以统一我们的渲染管线，无论3D格式如何。`aiImportFile`函数读取指定的文件，并将其内容以`aiScene`结构返回。此函数的第二个参数指定了在成功导入后要执行的可选后处理步骤。`aiProcessPreset_TargetRealtime_MaxQuality`标志是一个预定义变量，它组合了以下参数集：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These postprocessing options are described in further detail at [http://assimp.sourceforge.net/lib_html/postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410](http://assimp.sourceforge.net/lib_html/postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410).
    Advanced users can look into each option and understand whether these functions
    need to be enabled or disabled based on the content.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后处理选项的详细描述请参阅[http://assimp.sourceforge.net/lib_html/postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410](http://assimp.sourceforge.net/lib_html/postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410)。高级用户可以查看每个选项，并了解是否需要启用或禁用这些功能。
- en: At this point, we have a simple mechanism to load graphics into the Assimp `aiScene`
    object, present the bounding box size, as well as extract the number of vertices
    required to render the scene. Next, we will create a simple shader program as
    well as various drawing functions to visualize the content with different styles.
    In short, by integrating this with the OpenGL graphics rendering engine, we now
    have a flexible way to visualize 3D models using the various tools we developed
    in the previous chapters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个简单的机制来将图形加载到Assimp的`aiScene`对象中，显示边界框大小，以及提取渲染场景所需的顶点数量。接下来，我们将创建一个简单的着色器程序以及各种绘图函数，以不同的风格可视化内容。简而言之，通过将其与OpenGL图形渲染引擎集成，我们现在有了一种灵活的方式来使用我们在前几章中开发的各种工具来可视化3D模型。
- en: Rendering 3D models with points, lines, and triangles
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点、线和三角形渲染3D模型
- en: The next step after importing the 3D model is to display the content on the
    screen using an intuitive and aesthetically pleasing way. Many complex scenes
    consist of multiple surfaces (meshes) and many vertices. In the previous chapter,
    we implemented a simple shader program to visualize the point cloud at various
    depth values based on a heat map. In this section, we will utilize very simple
    primitives (points, lines, and triangles) with transparency to create skeleton-like
    rendering effects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入3D模型之后的下一步是，以直观和美观的方式在屏幕上显示内容。许多复杂的场景由多个表面（网格）和许多顶点组成。在前一章中，我们实现了一个简单的着色器程序，根据热图在各个深度值上可视化点云。在本节中，我们将使用非常简单的原语（点、线和三角形）以及透明度来创建类似骨骼的渲染效果。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will continue the implementation of the `ObjLoader` class to support loading
    vertices and draw the graphics for each mesh in the scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续实现`ObjLoader`类，以支持加载顶点并在场景中的每个网格上绘制图形。
- en: 'In the source file of `ObjLoader.cpp`, we add a recursive function to extract
    all vertices from the scene and store them in a single vertex buffer array. This
    allows us to reduce the number of vertex buffers to be managed, thus reducing
    the complexity of the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ObjLoader.cpp`的源文件中，我们添加了一个递归函数来从场景中提取所有顶点并将它们存储在一个单独的顶点缓冲区数组中。这使我们能够减少要管理的顶点缓冲区数量，从而降低代码的复杂性：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To draw the graphics, we traverse the `aiScene` object from the root node and
    draw the meshes one piece at a time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制图形，我们遍历从根节点开始的`aiScene`对象，一次绘制一个网格：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the vertex shader, `pointcloud.vert`, we compute the color of vertices based
    on their positions in space. The remapping algorithm creates a heat map representation
    of the object in space, and it serves as an important depth cue for the human
    eye (depth perception):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器`pointcloud.vert`中，我们根据顶点在空间中的位置计算顶点的颜色。重映射算法创建了一个空间中对象的热图表示，这为人类眼睛提供了重要的深度线索（深度感知）：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The vertex shader passes the heat-mapped color information along to the fragment
    shader through the `color_based_on_position` variable. Then, the final color is
    returned through the fragment shader (`pointcloud.frag`) directly without further
    processing. The implementation of such a simple pipeline is shown as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器通过`color_based_on_position`变量将热图颜色信息传递给片段着色器。然后，最终颜色通过片段着色器（`pointcloud.frag`）直接返回，无需进一步处理。这样一个简单管道的实现如下所示：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we draw the scene with various styles: lines, points, and triangles
    with transparency. The following is the code snippet inside the drawing loop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以各种风格绘制场景：线条、点和三角形（表面）带有透明度。以下是在绘图循环中的代码片段：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The series of screenshots that follow illustrate the aesthetically pleasing
    results we can achieve with our custom shader. The color mapping based on the
    depth position using the heat map shader provides a strong depth perception that
    helps us understand the 3D structure of the objects more easily. Furthermore,
    we can enable and disable various rendering options separately to achieve various
    effects. For example, the same object can be rendered with different styles: points,
    lines, and triangles (surfaces) with transparency.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的系列截图展示了我们可以使用自定义着色器实现的令人愉悦的结果。基于热图着色器的深度位置颜色映射提供了强烈的深度感知，帮助我们更容易地理解物体的3D结构。此外，我们可以分别启用和禁用各种渲染选项以实现各种效果。例如，同一个物体可以用不同的风格渲染：点、线和三角形（表面）带有透明度。
- en: 'To demonstrate the effects, we will first render two objects with points only.
    The first example is a dragon model:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示效果，我们首先仅用点渲染两个物体。第一个例子是一个龙模型：
- en: '![How to do it...](img/9727OS_06_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_01.jpg)'
- en: 'The second example is an architectural model:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是一个建筑模型：
- en: '![How to do it...](img/9727OS_06_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_02.jpg)'
- en: 'The point-based rendering style is great for visualizing a large dataset with
    unknown relations or distribution. Next, we will render the same objects with
    lines only:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于点的渲染风格非常适合可视化具有未知关系或分布的大量数据集。接下来，我们将仅用线条渲染相同的物体：
- en: '![How to do it...](img/9727OS_06_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_03.jpg)'
- en: 'Here''s the architectural model rendered with lines only:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是仅用线条渲染的建筑模型：
- en: '![How to do it...](img/9727OS_06_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_04.jpg)'
- en: 'With the lines, now we can see the structure of the object more easily. This
    rendering technique is great for simple structures, such as architectural models
    and other well-defined models. In addition, we can render the scene with both
    points and lines enabled, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线条后，我们现在可以更轻松地看到物体的结构。这种渲染技术非常适合简单的结构，例如建筑模型和其他定义良好的模型。此外，我们还可以同时启用点和线条来渲染场景，如下所示：
- en: '![How to do it...](img/9727OS_06_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_05.jpg)'
- en: 'Here''s the architectural model rendered with points and lines enabled:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是启用点和线条渲染的建筑模型：
- en: '![How to do it...](img/9727OS_06_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_06.jpg)'
- en: 'The combination of both points and lines provides additional visual cue to
    the structure of the object (that is, emphasis on the intersection points). Finally,
    we render the scene with all options enabled: points, lines, and triangles (surfaces)
    with transparency:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 点和线的组合为物体的结构提供了额外的视觉提示（即强调交点）。最后，我们以所有选项启用的方式渲染场景：点、线和三角形（表面）带有透明度：
- en: '![How to do it...](img/9727OS_06_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_07.jpg)'
- en: 'Here''s the architectural model rendered using points, lines and triangles
    with transparency:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用点、线和三角形（表面）以及透明度渲染的建筑模型：
- en: '![How to do it...](img/9727OS_06_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_08.jpg)'
- en: 'The final combination with all the options enabled provides an even more intuitive
    visualization of the volume of the object as well as the overall 3D structure.
    Alternatively, we can also enable the depth test and render the solid model with
    no transparency:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 启用所有选项的最终组合提供了对物体体积以及整体3D结构的更直观的可视化。或者，我们也可以启用深度测试，以不透明的方式渲染实体模型：
- en: '![How to do it...](img/9727OS_06_09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_06_09.jpg)'
- en: Instructions on how to enable/disable these options at runtime are documented
    in the source code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在运行时启用/禁用这些选项的说明在源代码中有文档记录。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By combining the Assimp library and OpenGL, we can now dynamically load 3D models
    on the screen and create visually appealing 3D effects through an OpenGL-based
    interactive visualization tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 Assimp 库和 OpenGL，我们现在可以在屏幕上动态加载 3D 模型，并通过基于 OpenGL 的交互式可视化工具创建视觉上吸引人的 3D
    效果。
- en: In `ObjLoader.cpp`, the `loadVertices` function converts the scene into a single
    vertex buffer array to reduce the complexity of memory management. In particular,
    this approach reduces the number of OpenGL memory copies and the number of memory
    buffers on the rendering side (that is, `glBufferData` and `glGenBuffers`). In
    addition, the loading function handles the scaling and centering of vertices based
    on the bounding box. This step is critical as most 3D formats do not normalize
    their coordinate system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ObjLoader.cpp` 中，`loadVertices` 函数将场景转换为单个顶点缓冲区数组，以减少内存管理的复杂性。特别是，这种方法减少了
    OpenGL 内存复制的次数和渲染侧（即 `glBufferData` 和 `glGenBuffers`）的内存缓冲区数量。此外，加载函数根据边界框处理顶点的缩放和居中。这一步至关重要，因为大多数
    3D 格式都没有标准化它们的坐标系。
- en: Next, the `draw` function in `ObjLoader.cpp` traverses the `aiScene` object
    and draws each part of the scene with the vertex buffer. In the case of point-based
    rendering, we can skip this step and directly draw the entire array using `glDrawArray`
    because there is no dependency among the neighboring vertices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ObjLoader.cpp` 中的 `draw` 函数遍历 `aiScene` 对象，并使用顶点缓冲区绘制场景的每个部分。在基于点的渲染情况下，我们可以跳过此步骤，直接使用
    `glDrawArray` 绘制整个数组，因为相邻顶点之间没有依赖关系。
- en: 'The vertex shader (`pointcloud.vert`) contains the implementation of the heat
    map color generator. The `heatmap` function takes in three parameters: the input
    value (that is, the depth or *z* value), the minimum value, and maximum value.
    It returns the heat map color representation in the RGBA format.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器（`pointcloud.vert`）包含了热图颜色生成器的实现。`heatmap` 函数接受三个参数：输入值（即深度或 *z* 值）、最小值和最大值。它返回
    RGBA 格式的热图颜色表示。
- en: Inside the drawing loop, the `computeStereoViewProjectionMatrices` function
    constructs the view and projection matrices. The details are explained in the
    next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘图循环内部，`computeStereoViewProjectionMatrices` 函数构建视图和投影矩阵。详细内容将在下一节中解释。
- en: Finally, we can mix and match various rendering techniques; for example, by
    enabling both points and lines only for skeleton-based rendering. Various depth
    visual cues, such as occlusion and motion parallax, can be easily added by supporting
    rotation or translation of the object. To further improve the result, other rendering
    techniques such as lighting or shading can be added based on the application requirements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以混合和匹配各种渲染技术；例如，只为基于骨骼的渲染启用点和线。通过支持对象的旋转或平移，可以轻松添加各种深度视觉提示，如遮挡和运动视差。为了进一步提高结果，可以根据应用需求添加其他渲染技术，如光照或阴影。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The Assimp library also supports many file formats in addition to `.obj` files.
    For example, we can load `.stl` files into our system without changing the source
    code at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `.obj` 文件外，Assimp 库还支持许多文件格式。例如，我们可以将 `.stl` 文件加载到我们的系统中，而无需更改任何源代码。
- en: 'To download more 3D models, visit various 3D model-sharing websites such as
    *Makerbot ThingiVerse* ([http://www.thingiverse.com/](http://www.thingiverse.com/))
    or *Turbosquid* ([http://www.turbosquid.com/](http://www.turbosquid.com/)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载更多 3D 模型，请访问各种 3D 模型共享网站，如 *Makerbot ThingiVerse* ([http://www.thingiverse.com/](http://www.thingiverse.com/))
    或 *Turbosquid* ([http://www.turbosquid.com/](http://www.turbosquid.com/))：
- en: '![See also](img/9727OS_06_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![参见](img/9727OS_06_10.jpg)'
- en: Stereoscopic 3D rendering
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立体 3D 渲染
- en: '3D television and 3D glasses are becoming much more prevalent with the latest
    trends in consumer electronics and technological advances in wearable computing.
    In the market, there are currently many hardware options that allow us to visualize
    information with stereoscopic 3D technology. One common format is side-by-side
    3D, which is supported by many 3D glasses as each eye sees an image of the same
    scene from a different perspective. In OpenGL, creating side-by-side 3D rendering
    requires asymmetric adjustment as well as viewport adjustment (that is, the area
    to be rendered) – asymmetric frustum parallel projection or equivalently to lens-shift
    in photography. This technique introduces no vertical parallax and widely adopted
    in the stereoscopic rendering. To illustrate this concept, the following diagram
    shows the geometry of the scene that a user sees from the right eye:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着消费电子的最新趋势和可穿戴计算技术的进步，3D电视和3D眼镜变得越来越普遍。在市场上，目前有许多硬件选项允许我们使用立体3D技术可视化信息。一种常见的格式是左右并排3D，许多3D眼镜都支持这种格式，因为每只眼睛都从不同的视角看到同一场景的图像。在OpenGL中，创建左右并排3D渲染需要非对称调整以及视口调整（即要渲染的区域）——非对称截锥体平行投影或相当于摄影中的镜头偏移。这项技术不引入垂直视差，并且在立体渲染中得到广泛应用。为了说明这个概念，以下图显示了用户从右眼看到的场景的几何形状：
- en: '![Stereoscopic 3D rendering](img/9727OS_06_11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![立体3D渲染](img/9727OS_06_11.jpg)'
- en: The **intraocular distance** (**IOD**) is the distance between two eyes. As
    we can see from the diagram, the **Frustum Shift** represents the amount of skew/shift
    for asymmetric frustrum adjustment. Similarly, for the left eye image, we perform
    the transformation with a mirrored setting. The implementation of this setup is
    described in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**眼内距离**（**IOD**）是两眼之间的距离。从图中我们可以看出，**截锥体偏移**表示非对称截锥体调整的倾斜/偏移量。同样，对于左眼图像，我们使用镜像设置进行变换。该设置的实现将在下一节中描述。'
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code illustrates the steps to construct the projection and view
    matrices for stereoscopic 3D visualization. The code uses the intraocular distance,
    the distance of the image plane, and the distance of the near clipping plane to
    compute the appropriate frustum shifts value. In the source file, `common/controls.cpp`,
    we add the implementation for the stereo 3D matrix setup:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了构建用于立体3D可视化的投影和视图矩阵的步骤。该代码使用眼内距离、图像平面距离和近裁剪平面距离来计算适当的截锥体偏移值。在源文件`common/controls.cpp`中，我们添加了立体3D矩阵设置的实现：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the rendering loop in `main.cpp`, we define the viewports for each eye (*left*
    and *right*) and set up the projection and view matrices accordingly. For each
    eye, we translate our camera position by half of the intraocular distance, as
    illustrated in the previous figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中的渲染循环中，我们为每只眼睛（*左*和*右*）定义视口，并相应地设置投影和视图矩阵。对于每只眼睛，我们根据前一个图所示，将我们的相机位置沿眼内距离的一半进行平移：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The final rendering result consists of two separate images on each side of the
    display, and note that each image is compressed horizontally by a scaling factor
    of two. For some display systems, each side of the display is required to preserve
    the same aspect ratio depending on the specifications of the display.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最终渲染结果由显示器的两侧的两个单独图像组成，并且请注意，每个图像都通过一个缩放因子为二的水平压缩。对于某些显示系统，显示器的每一侧都需要根据显示器的规格保持相同的纵横比。
- en: 'Here are the final screenshots of the same models in true 3D using stereoscopic
    3D rendering:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用立体3D渲染在真实3D中显示的相同模型的最终截图：
- en: '![How to do it...](img/9727OS_06_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/9727OS_06_12.jpg)'
- en: 'Here''s the rendering of the architectural model in stereoscopic 3D:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是建筑模型的立体3D渲染：
- en: '![How to do it...](img/9727OS_06_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/9727OS_06_13.jpg)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The stereoscopic 3D rendering technique is based on the parallel axis and asymmetric
    frustum perspective projection principle. In simpler terms, we rendered a separate
    image for each eye as if the object was seen at a different eye position but viewed
    on the same plane. Parameters such as the intraocular distance and frustum shift
    can be dynamically adjusted to provide the desired 3D stereo effects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 立体3D渲染技术基于平行轴和非对称截锥体透视投影原理。简单来说，我们为每只眼睛渲染了一个单独的图像，就像物体从不同的眼睛位置看到，但视图在同一平面上。参数如眼内距离和截锥体偏移可以动态调整，以提供所需的3D立体效果。
- en: For example, by increasing or decreasing the frustum asymmetry parameter, the
    object will appear to be moved in front or behind the plane of the screen. By
    default, the zero parallax plane is set to the middle of the view volume. That
    is, the object is set up so that the center position of the object is positioned
    at the screen level, and some parts of the object will appear in front of or behind
    the screen. By increasing the frustum asymmetry (that is, positive parallax),
    the scene will appear to be pushed behind the screen. Likewise, by decreasing
    the frustum asymmetry (that is, negative parallax), the scene will appear to be
    pulled in front of the screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过增加或减少截锥体不对称参数，物体看起来就像是在屏幕的前面或后面移动。默认情况下，零视差平面被设置为视体积的中间。也就是说，物体被设置得使其中心位置位于屏幕水平，物体的某些部分将出现在屏幕的前面或后面。通过增加截锥体不对称（即正视差），场景看起来就像被推到了屏幕后面。同样，通过减少截锥体不对称（即负视差），场景看起来就像被拉到了屏幕前面。
- en: The `glm::frustum` function sets up the projection matrix, and we implemented
    the asymmetric frustum projection concept illustrated in the drawing. Then, we
    use the `glm::lookAt` function to adjust the eye position based on the IOP value
    we have selected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`glm::frustum`函数设置投影矩阵，我们实现了图中所示的不对称截锥体投影概念。然后，我们使用`glm::lookAt`函数根据我们选择的IOP值调整眼睛位置。'
- en: To project the images side by side, we use the `glViewport` function to constrain
    the area within which the graphics can be rendered. The function basically performs
    an affine transformation (that is, scale and translation) which maps the normalized
    device coordinate to the window coordinate. Note that the final result is a side-by-side
    image in which the graphic is scaled by a factor of two vertically (or compressed
    horizontally). Depending on the hardware configuration, we may need to adjust
    the aspect ratio.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现图像并排显示，我们使用`glViewport`函数限制图形可以渲染的区域。该函数基本上执行一个仿射变换（即缩放和平移），将归一化设备坐标映射到窗口坐标。请注意，最终结果是一个并排图像，其中图形在垂直方向上按因子二缩放（或水平方向上压缩）。根据硬件配置，我们可能需要调整纵横比。
- en: 'The current implementation supports side-by-side 3D, which is commonly used
    in most wearable **Augmented Reality** (**AR**) or **Virtual Reality** (**VR**)
    glasses. Fundamentally, the rendering technique, namely the asymmetric frustum
    perspective projection described in our chapter, is platform-independent. For
    example, we have successfully tested our implementation on the Meta 1 Developer
    Kit ([https://www.getameta.com/products](https://www.getameta.com/products)) and
    rendered the final results on the optical see-through stereoscopic 3D display:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现支持并排3D，这在大多数可穿戴的**增强现实**（**AR**）或**虚拟现实**（**VR**）眼镜中很常见。从根本上说，渲染技术，即我们章节中描述的不对称截锥体透视投影，是平台无关的。例如，我们在Meta
    1开发者套件([https://www.getameta.com/products](https://www.getameta.com/products))上成功测试了我们的实现，并在光学透视立体3D显示器上渲染了最终结果：
- en: '![How it works...](img/9727OS_06_14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_06_14.jpg)'
- en: 'Here is the front view of the Meta 1 Developer Kit, showing the optical see-through
    stereoscopic 3D display and 3D range-sensing camera (introduced in [Chapter 5](ch05.html
    "Chapter 5. Rendering of Point Cloud Data for 3D Range-sensing Cameras"), *Rendering
    of Point Cloud Data for 3D Range-sensing Cameras*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Meta 1开发者套件的前视图，显示了光学透视立体3D显示器和3D范围感应相机（在第5章中介绍，*3D范围感应相机的点云数据渲染*），*Rendering
    of Point Cloud Data for 3D Range-sensing Cameras*）：
- en: '![How it works...](img/9727OS_06_15.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_06_15.jpg)'
- en: 'The result is shown as follows, with the stereoscopic 3D graphics rendered
    onto the real world (which forms the basis of augmented reality):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示，立体3D图形被渲染到真实世界中（这构成了增强现实的基础）：
- en: '![How it works...](img/9727OS_06_16.jpg)![How it works...](img/9727OS_06_17.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_06_16.jpg)![如何工作...](img/9727OS_06_17.jpg)'
- en: In the upcoming chapters, we will transition to the increasingly powerful and
    ubiquitous mobile platform and introduce how to use OpenGL to visualize data in
    interesting ways using built-in motion sensors on mobile devices. Further details
    on implementing augmented reality applications will be covered in [Chapter 9](ch09.html
    "Chapter 9. Augmented Reality-based Visualization on Mobile or Wearable Platforms"),
    *Augmented reality-based visualization on mobile or wearable platforms*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将转向越来越强大且无处不在的移动平台，并介绍如何使用移动设备内置的运动传感器，通过OpenGL以有趣的方式可视化数据。关于实现增强现实应用的更多细节将在[第9章](ch09.html
    "第9章. 移动或可穿戴平台上的基于增强现实的可视化") *基于增强现实的移动或可穿戴平台可视化* 中介绍。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In addition, we can easily extend our code to support shutter glasses-based
    3D monitors by utilizing the Quad Buffered OpenGL APIs (refer to the `GL_BACK_RIGHT`
    and `GL_BACK_LEFT` flags in the `glDrawBuffer` function). Unfortunately, such
    3D formats require specific hardware synchronization and often require higher
    frame rate display (for example, 120Hz) as well as a professional graphics card.
    Further information on how to implement stereoscopic 3D in your application can
    be found at [http://www.nvidia.com/content/GTC-2010/pdfs/2010_GTC2010.pdf](http://www.nvidia.com/content/GTC-2010/pdfs/2010_GTC2010.pdf).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以轻松扩展我们的代码以支持基于快门眼镜的3D显示器，通过利用四缓冲OpenGL API（参考`glDrawBuffer`函数中的`GL_BACK_RIGHT`和`GL_BACK_LEFT`标志）。不幸的是，这种3D格式需要特定的硬件同步，并且通常需要更高的帧率显示（例如，120Hz）以及专业显卡。有关如何在您的应用程序中实现立体3D的更多信息，请参阅[http://www.nvidia.com/content/GTC-2010/pdfs/2010_GTC2010.pdf](http://www.nvidia.com/content/GTC-2010/pdfs/2010_GTC2010.pdf)。
