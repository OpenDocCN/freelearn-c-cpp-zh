["```cpp\n    #include <stdio.h>\n\n    int main()\n    {\n      puts(\"hello world\");\n    }\n```", "```cpp\n    #include <iostream>\n\n    int main()\n    {\n      std::cout << \"hello world\" << std::endl;\n    }\n```", "```cpp\n    #include <cassert>\n    #include <string>\n    #include <unistd.h>\n    #include <fcntl.h>\n\n    int main()\n    {\n      int fdw = open(\"myfile.txt\", O_WRONLY | O_CREAT | O_TRUNC);\n      int fdr = open(\"myfile.txt\", O_RDONLY);\n      if (fdw == -1 || fdr == -1)\n        return EXIT_FAILURE;\n\n      write(fdw, \"hello world\", 11);\n      lseek(fdw, 6, SEEK_SET);\n      write(fdw, \"neighbor\", 8);\n\n      std::string buffer(14, '\\0');\n      int b = read(fdr, buffer.data(), 14);\n      assert(b == 14);\n      assert(buffer == \"hello neighbor\");\n      close(fdr);\n      close(fdw);\n    }\n```", "```cpp\n    struct fcloser {\n      void operator()(FILE *fp) const {\n        fclose(fp);\n      }\n\n      static auto open(const char *name, const char *mode) {\n        return std::unique_ptr<FILE, fcloser>(fopen(name, mode));\n      }\n    };\n\n    void test() {\n      auto f = fcloser::open(\"test.txt\", \"w\");\n      fprintf(f.get(), \"hello world\\n\");\n        // f will be closed automatically\n    }\n```", "```cpp\n    auto f = fcloser::open(\"test.txt\", \"w\");\n    std::shared_ptr<FILE> g1 = std::move(f);\n      // now f is empty and g1's use-count is 1\n    if (true) {\n      std::shared_ptr<FILE> g2 = g1;\n        // g1's use-count is now 2\n      fprintf(g2.get(), \"hello \");\n        // g1's use-count drops back to 1\n    }\n    fprintf(g1.get(), \"world\\n\");\n      // g1's use-count drops to 0; the file is closed\n```", "```cpp\n    long ftell(FILE *fp)\n    {\n      int fd = fileno(fp);\n      return lseek(fd, 0, SEEK_CUR);\n    }\n```", "```cpp\n    struct LWC {\n      int lines, words, chars;\n    };\n\n    LWC word_count(FILE *fp)\n    {\n      LWC r {};\n      bool in_space = true;\n      while (true) {\n        int ch = getc(fp);\n        if (ch == EOF) break;\n        r.lines += (ch == '\\n');\n        r.words += (in_space && !isspace(ch));\n        r.chars += 1;\n        in_space = isspace(ch);\n      }\n      return r;\n    }\n\n    int main(int argc, const char **argv)\n    {\n      FILE *fp = (argc < 2) ? stdin : fopen(argv[1], \"r\");\n      auto [lines, words, chars] = word_count(fp);\n      printf(\"%8d %7d %7d\\n\", lines, words, chars);\n    }\n```", "```cpp\nFILE *fp = fopen(\"myfile.txt\", \"w\");\n    int fd = fileno(fp);\n    char buffer[150];\n    setvbuf(fp, buffer, _IOFBF, 150);\n      // setvbuf returns 0 on success, or EOF on failure.\n\n    std::string AAAA(160, 'A');\n    int bytes_written = fwrite(AAAA.data(), 1, 160, fp);\n      // This fills the buffer with 150 bytes, flushes it,\n      // and writes 10 more bytes into the buffer.\n\n    assert(bytes_written == 160);\n    assert(lseek(fd, 0, SEEK_CUR) == 150);\n    assert(ftell(fp) == 160);\n```", "```cpp\n    // Flush the FILE's buffer by force.\n    fflush(fp);\n    // Now, fd and fp agree about the state of the file.\n    assert(lseek(fd, 0, SEEK_CUR) == 160);\n```", "```cpp\n    #include <cassert>\n    #include <cstdio>\n    #include <string>\n\n    int main()\n    {\n      FILE *fpw = fopen(\"myfile.txt\", \"w\");\n      FILE *fpr = fopen(\"myfile.txt\", \"r\");\n      if (fpw == nullptr || fpr == nullptr)\n        return EXIT_FAILURE;\n\n      fwrite(\"hello world\", 1, 11, fpw);\n      fseek(fpw, 6, SEEK_SET);\n      fwrite(\"neighbor\", 1, 8, fpw);\n      fflush(fpw);\n\n      std::string buffer(14, '\\0');\n      int b = fread(buffer.data(), 1, 14, fpr);\n      assert(b == 14 && buffer == \"hello neighbor\");\n      fclose(fpr);\n      fclose(fpw);\n    }\n```", "```cpp\n    int tuners = 225;\n    const char *where = \"Chicago\";\n    printf(\"There are %d piano tuners in %s.\\n\", tuners, where);\n```", "```cpp\n    tuners = 225\n    where = \"Chicago\"\n    print \"There are %d piano tuners in %s.\" % (tuners, where)\n```", "```cpp\n    char buf[13];\n    int needed = snprintf(\n      buf, sizeof buf,\n      \"There are %d piano tuners in %s\", tuners, where\n    );\n    assert(needed == 37);\n    assert(std::string_view(buf) == \"There are 22\");\n```", "```cpp\n    template<class... Args>\n    std::string format(const char *fmt, const Args&... args)\n    {\n      int needed = snprintf(nullptr, 0, fmt, args...);\n      std::string s(needed + 1, '\\0');\n      snprintf(s.data(), s.size(), fmt, args...);\n      s.pop_back(); // remove the written '\\0'\n      return s;\n    }\n\n    void test()  \n    {\n      std::string s = format(\"There are %d piano tuners in %s\", tuners, where);\n      assert(s == \"There are 225 piano tuners in Chicago\"); \n    } \n```", "```cpp\n    std::string better_format(const char *fmt, ...)\n    {\n      va_list ap;\n      va_start(ap, fmt);\n      int needed = vsnprintf(nullptr, 0, fmt, ap);\n      va_end(ap);\n      std::string s(needed + 1, '\\0');\n      va_start(ap, fmt);\n      vsnprintf(s.data(), s.size(), fmt, ap);\n      va_end(ap);\n      s.pop_back(); // remove the written '\\0'\n      return s;\n    }\n```", "```cpp\n    #include <cassert>\n    #include <fstream>\n    #include <string>\n\n    int main()\n    {\n      std::fstream fsw(\"myfile.txt\", std::ios_base::out);\n      std::fstream fsr(\"myfile.txt\", std::ios_base::in);\n      if (fsw.fail() || fsr.fail())\n        return EXIT_FAILURE;\n\n      fsw.write(\"hello world\", 11);\n      fsw.seekp(6, std::ios_base::beg);\n      fsw.write(\"neighbor\", 8);\n      fsw.flush();\n\n      std::string buffer(14, '\\0');\n      fsr.read(buffer.data(), 14);\n      assert(fsr.gcount() == 14 && buffer == \"hello neighbor\");\n    }\n```", "```cpp\n    int tuners = 225;\n    const char *where = \"Chicago\";\n    std::cout << \"There are \" << tuners << \" piano tuners in \" << where << \"\\n\";\n```", "```cpp\n    namespace std {\n      ostream& operator<< (ostream& os, const string& s)\n      {\n        os.write(s.data(), s.size());\n        return os;\n      }\n    } // namespace std\n```", "```cpp\n    void pad(std::ostream& os, size_t from, size_t to)\n    {\n      char ch = os.fill();\n      for (auto i = from; i < to; ++i) {\n        os.write(&ch, 1);\n      }\n    }\n\n    std::ostream& operator<< (std::ostream& os, const std::string& s)\n    {\n      auto column_width = os.width();\n      auto padding = os.flags() & std::ios_base::adjustfield;\n\n      if (padding == std::ios_base::right) {\n        pad(os, s.size(), column_width);\n      }\n      os.write(s.data(), s.size());\n      if (padding == std::ios_base::left) {\n        pad(os, s.size(), column_width);\n      }\n      os.width(0); // reset \"column width\" to 0\n      return os;\n    }\n```", "```cpp\n    struct WidthSetter { int n; };\n\n    auto& operator<< (std::ostream& os, WidthSetter w)\n    {\n      os.width(w.n);\n      return os;\n    }\n\n    auto setw(int n) { return WidthSetter{n}; }\n```", "```cpp\n    using Manip = std::ostream& (*)(std::ostream&);\n\n    auto& operator<< (std::ostream& os, Manip f) {\n      return f(os);\n    }\n\n    std::ostream& flush(std::ostream& os) {\n      return os.flush();\n    }\n\n    std::ostream& endl(std::ostream& os) {\n      return os << '\\n' << flush; \n    }\n```", "```cpp\n    printf(\"%-10s.%6x\\n\", where, tuners);\n      // \"Chicago . e1\"\n\n    std::cout << std::setw(8) << std::left << where << \".\"\n              << std::setw(4) << std::right << std::hex\n              << tuners << \"\\n\";\n      // \"Chicago . e1\"\n```", "```cpp\n    printf(\"%d\\n\", 42); // \"42\"\n\n    std::cout << 42 << \"\\n\"; // \"2a\" -- oops!\n```", "```cpp\n    template<class InputIt, class OutputIt>\n    OutputIt do_quote(InputIt begin, InputIt end,\n      OutputIt dest)\n    {\n      *dest++ = '\"';\n      while (begin != end) {\n        auto ch = *begin++;\n        if (ch == '\"') {\n            *dest++ = '\\\\';\n        }\n        *dest++ = ch;\n      }\n      *dest++ = '\"';\n      return dest;\n    }\n```", "```cpp\n    struct quoted {\n      std::string_view m_view;\n      quoted(const char *s) : m_view(s) {}\n      quoted(const std::string& s) : m_view(s) {}\n    };\n\n    std::ostream& operator<< (std::ostream& os, const quoted& q)\n    {\n      do_quote(\n        q.m_view.begin(),\n        q.m_view.end(),\n        std::ostreambuf_iterator<char>(os)\n      );\n      return os;\n    }\n```", "```cpp\n    std::cout << quoted(\"I said \\\"hello\\\".\");\n```", "```cpp\n    std::cout << boost::format(\"There are %d piano tuners in %s.\") % tuners % where\n              << std::endl;\n```", "```cpp\n    void test() {\n      std::ios old_state(nullptr);\n      old_state.copyfmt(std::cout);\n        std::cout << std::hex << 225; // \"e1\"\n      std::cout.copyfmt(old_state);\n\n      std::cout << 42; // \"42\"\n    }\n```", "```cpp\n    void test() {\n      std::ostream os(std::cout.rdbuf());\n      os << std::hex << 225; // \"e1\"\n\n      std::cout << 42; // \"42\"\n    }\n```", "```cpp\n    void test() {\n      try {\n        std::cout << \"There are \"\n                  << computation_that_may_throw()\n                  << \"piano tuners here.\\n\";\n      } catch (...) {\n        std::cout << \"An exception was thrown\";\n      }\n    }\n```", "```cpp\n    template<class T>\n    std::string to_string(T&& t)\n    {\n      std::ostringstream oss;\n      oss << std::forward<T>(t);\n      return oss.str();\n    }\n```", "```cpp\n    template<class... Ts>\n    std::string to_string(Ts&&... ts)\n    {\n      std::ostringstream oss;\n      (oss << ... << std::forward<Ts>(ts));\n      return oss.str();\n    }\n```", "```cpp\n    std::setlocale(LC_ALL, \"C.UTF-8\");\n    std::locale::global(std::locale(\"C.UTF-8\"));\n\n    auto json = to_string('[', 3.14, ']');\n    assert(json == \"[3.14]\"); // Success!\n\n    std::setlocale(LC_ALL, \"en_DK.UTF-8\");\n    std::locale::global(std::locale(\"en_DK.UTF-8\"));\n\n    json = to_string('[', 3.14, ']');\n    assert(json == \"[3,14]\"); // Silent, abject failure!\n```", "```cpp\n    std::ostringstream oss;\n    std::string str;\n    char buffer[100];\n    int intvalue = 42;\n    float floatvalue = 3.14;\n    std::to_chars_result r;\n```", "```cpp\n    snprintf(buffer, sizeof buffer, \"%d\", intvalue);\n      // available in <stdio.h>\n      // locale-independent (%d is unaffected by locales)\n      // non-allocating\n      // bases 8, 10, 16 only\n\n    oss << intvalue;\n    str = oss.str();\n      // available in <sstream>\n      // locale-problematic (thousands separator may be inserted)\n      // allocating; allocator-aware\n      // bases 8, 10, 16 only\n\n    str = std::to_string(intvalue);\n      // available since C++11 in <string>\n      // locale-independent (equivalent to %d)\n      // allocating; NOT allocator-aware\n      // base 10 only\n\n    r = std::to_chars(buffer, std::end(buffer), intvalue, 10);\n    *r.ptr = '\\0';\n      // available since C++17 in <charconv>\n      // locale-independent by design\n      // non-allocating\n      // bases 2 through 36\n```", "```cpp\n    std::string response =\n      \"Content-Length: \" + std::to_string(body.size()) + \"\\r\\n\" +\n      \"\\r\\n\" +\n      body;\n```", "```cpp\n    char *write_string(char *p, char *end, const char *from)  \n    {\n      while (p != end && *from != '\\0') *p++ = *from++;\n      return p;\n    }\n\n    char *write_response_headers(char *p, char *end, std::string body)\n    {\n      p = write_string(p, end, \"Content-Length: \");\n      p = std::to_chars(p, end, body.size(), 10).ptr;\n      p = write_string(p, end, \"\\r\\n\\r\\n\");\n      return p;\n    }\n```", "```cpp\n    snprintf(buffer, sizeof buffer, \"%.6e\", floatvalue);\n    snprintf(buffer, sizeof buffer, \"%.6f\", floatvalue);\n    snprintf(buffer, sizeof buffer, \"%.6g\", floatvalue);\n      // available in <stdio.h>\n      // locale-problematic (decimal point)\n      // non-allocating\n\n    oss << floatvalue;\n    str = oss.str();\n      // available in <sstream>\n      // locale-problematic (decimal point)\n      // allocating; allocator-aware\n\n    str = std::to_string(floatvalue);\n      // available since C++11 in <string>\n      // locale-problematic (equivalent to %f)\n      // allocating; NOT allocator-aware\n      // no way to adjust the formatting\n\n    r = std::to_chars(buffer, std::end(buffer), floatvalue,\n                      std::chars_format::scientific, 6);\n    r = std::to_chars(buffer, std::end(buffer), floatvalue,\n                      std::chars_format::fixed, 6);\n    r = std::to_chars(buffer, std::end(buffer), floatvalue,\n                      std::chars_format::general, 6);\n    *r.ptr = '\\0';\n      // available since C++17 in <charconv>\n      // locale-independent by design\n      // non-allocating\n```", "```cpp\n    std::istringstream iss;\n    std::string str = \"42\";\n    char buffer[] = \"42\";\n    int intvalue;\n    float floatvalue;\n    int rc;\n    char *endptr;\n    size_t endidx;\n    std::from_chars_result r;\n```", "```cpp\n    intvalue = strtol(buffer, &endptr, 10);\n      // saturates on overflow\n      // sets global \"errno\" on most errors\n      // sets endptr==buffer when input cannot be parsed\n      // available in <stdlib.h>\n      // locale-problematic, in theory\n      // non-allocating\n      // bases 0 and 2 through 36\n      // always skips leading whitespace\n      // skips leading 0x for base 16\n      // recognizes upper and lower case\n\n    rc = sscanf(buffer, \"%d\", &intvalue);\n      // fails to detect overflow\n      // returns 0 (instead of 1) when input cannot be parsed\n      // available in <stdio.h>\n      // locale-problematic (equivalent to strtol)\n      // non-allocating\n      // bases 0, 8, 10, 16 only\n      // always skips leading whitespace\n      // skips leading 0x for base 16\n      // recognizes upper and lower case\n\n    intvalue = std::stoi(str, &endidx, 10);\n      // throws on overflow or error\n      // available since C++11 in <string>\n      // locale-problematic (equivalent to strtol)\n      // NOT allocator-aware\n      // bases 0 and 2 through 36\n      // always skips leading whitespace\n      // skips leading 0x for base 16\n      // recognizes upper and lower case\n\n    iss.str(\"42\");\n    iss >> intvalue;\n      // saturates on overflow\n      // sets iss.fail() on any error\n      // available in <sstream>\n      // locale-problematic\n      // allocating; allocator-aware\n      // bases 8, 10, 16 only\n      // skips leading 0x for base 16\n      // skips whitespace by default\n\n    r = std::from_chars(buffer, buffer + 2, intvalue, 10);\n      // sets r.ec != 0 on any error\n      // available since C++17 in <charconv>\n      // locale-independent by design\n      // non-allocating\n      // bases 2 through 36\n      // always skips leading whitespace\n      // recognizes lower case only\n```", "```cpp\n    floatvalue = strtof(buffer, &endptr);\n      // saturates on overflow\n      // sets global \"errno\" on most errors\n      // sets endptr==buffer when input cannot be parsed\n      // available in <stdlib.h>\n      // locale-problematic\n      // non-allocating\n      // base 10 or 16, auto-detected\n      // always skips leading whitespace\n\n    rc = sscanf(buffer, \"%f\", &floatvalue);\n      // fails to detect overflow\n      // returns 0 (instead of 1) when input cannot be parsed\n      // available in <stdio.h>\n      // locale-problematic (equivalent to strtof)\n      // non-allocating\n      // base 10 or 16, auto-detected\n      // always skips leading whitespace\n\n    floatvalue = std::stof(str, &endidx);\n      // throws on overflow or error\n      // available since C++11 in <string>\n      // locale-problematic (equivalent to strtol)\n      // NOT allocator-aware\n      // base 10 or 16, auto-detected\n      // always skips leading whitespace\n\n    iss.str(\"3.14\");\n    iss >> floatvalue;\n      // saturates on overflow\n      // sets iss.fail() on any error\n      // available in <sstream>\n      // locale-problematic\n      // allocating; allocator-aware\n      // base 10 or 16, auto-detected\n      // skips whitespace by default\n      // non-portable behavior on trailing text\n\n    r = std::from_chars(buffer, buffer + 2, floatvalue,\n                        std::chars_format::general);\n      // sets r.ec != 0 on any error\n      // available since C++17 in <charconv>\n      // locale-independent by design\n      // non-allocating\n      // base 10 or 16, auto-detected\n      // always skips leading whitespace\n```", "```cpp\n    std::setlocale(LC_ALL, \"C.UTF-8\");\n    assert(std::stod(\"3.14\") == 3.14); // Success!\n    std::setlocale(LC_ALL, \"en_DK.UTF-8\");\n    assert(std::stod(\"3.14\") == 3.00); // Silent, abject failure!\n```", "```cpp\n    double d = 17;\n    std::istringstream iss(\"42abc\");\n    iss >> d;\n    if (iss.good() && d == 42) {\n      puts(\"Your library vendor is libstdc++\");\n    } else if (iss.fail() && d == 0) {\n      puts(\"Your library vendor is libc++\");\n    }\n```", "```cpp\n    for line in sys.stdin:\n    # preserves trailing newlines\n    process(line)\n```", "```cpp\n    while (<>) {\n      # preserves trailing newlines\n      process($_);\n    }\n```", "```cpp\n    std::string line;  \n    while (std::getline(std::cin, line)) {\n      // automatically chomps trailing newlines\n      process(line);\n    }\n```", "```cpp\nisspace to separate words correctly, of course):\n```", "```cpp\n    template<class T>\n    struct streamer {\n      std::istream& m_in;\n      explicit streamer(std::istream& in) : m_in(in) {}\n      auto begin() const\n        { return std::istream_iterator<T>(m_in); }\n      auto end() const\n        { return std::istream_iterator<T>{}; }\n    };\n\n    int main()\n    {\n      for (auto word : streamer<std::string>(std::cin)) {\n        process(word);\n      }\n    }\n```", "```cpp\n    // Double every int the user gives us\n    for (auto value : streamer<int>(std::cin)) {\n      printf(\"%d\\n\", 2*value);\n    }\n```"]