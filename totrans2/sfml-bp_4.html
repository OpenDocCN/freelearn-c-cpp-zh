<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Playing with Physics</h1></div></div></div><p>In the previous chapter, we built several games, including a Tetris clone. In this chapter, we will add physics into this game and turn it into a new one. By doing this, we will learn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is a physics engine</li><li class="listitem" style="list-style-type: disc">How to install and use the Box2D library</li><li class="listitem" style="list-style-type: disc">How to pair the physics engine with SFML for the display</li><li class="listitem" style="list-style-type: disc">How to add physics in the game</li></ul></div><p>In this chapter, we will learn the magic of physics. We will also do some mathematics but relax, it's for conversion only. Now, let's go!</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>A physics engine – késako?</h1></div></div></div><p>In this chapter, we will <a id="id222" class="indexterm"/>speak about physics engine, but the first question is "what is a physics engine?" so let's explain it.</p><p>A physics engine is a software or library that is able to simulate Physics, for example, the Newton-Euler equation that describes the movement of a rigid body. A physics engine is also able to manage collisions, and some of them can deal with soft bodies and even fluids.</p><p>There are different kinds of physics engines, mainly categorized into real-time engine and non-real-time engine. The first one is mostly used in video games or simulators and the second one is used in high performance scientific simulation, in the conception of special effects in cinema and animations.</p><p>As our goal is to use the engine in a video game, let's focus on real-time-based engine. Here again, there are two important types of engines. The first one is for 2D and the other for 3D. Of course you can use a 3D engine in a 2D world, but it's preferable to use a 2D engine for an optimization purpose. There are plenty of engines, but not all of them are open source.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>3D physics engines</h2></div></div></div><p>For 3D games, I advise you to use the <code class="literal">Bullet</code> physics library. This was integrated in the Blender software, and was used in the<a id="id223" class="indexterm"/> creation of some commercial games <a id="id224" class="indexterm"/>and also in the making of films. This is a really good engine written in C/C++ that can deal with rigid and soft bodies, fluids, collisions, forces… and all that you need.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>2D physics engines</h2></div></div></div><p>As previously said, in a 2D<a id="id225" class="indexterm"/> environment, you can use a 3D physics engine; you just have to ignore the depth (Z axes). However, the most interesting thing is to <a id="id226" class="indexterm"/>use an engine optimized for the 2D environment. There are several engines like this one and the most famous ones are Box2D and Chipmunk. Both of them are really good and none of them are better than the other, but I had to make a choice, which was Box2D. I've made this choice not only because of its C++ API that allows you to use overload, but also because of the big community involved in the project.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Physics engine comparing game engine</h1></div></div></div><p>Do not mistake a physics <a id="id227" class="indexterm"/>engine for a game engine. A physics engine only simulates a physical world without anything else. There are no graphics, no logics, only physics simulation. On the contrary, a game engine, most of the time includes a <a id="id228" class="indexterm"/>physics engine paired with a render technology (such as OpenGL or DirectX). Some predefined logics depend on the goal of the engine (RPG, FPS, and so on) and sometimes artificial intelligence. So as you can see, a game engine is more complete than a physics engine. The two mostly known engines are Unity and Unreal engine, which are both very complete. Moreover, they are free for non-commercial usage.</p><p>So why don't we directly use a game engine? This is a good question. Sometimes, it's better to use something that is already made, instead of reinventing it. However, do we really need all the functionalities of a game engine for this project? More importantly, what do we need it for? Let's see the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A graphic output</li><li class="listitem" style="list-style-type: disc">Physics engine that can manage collision</li></ul></div><p>Nothing else is required. So as you can see, using a game engine for this project would be like killing a fly with a bazooka. I hope that you have understood the aim of a physics engine, the differences between a game and physics engine, and the reason for the choices made for the project described in this chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Using Box2D</h1></div></div></div><p>As previously said, Box2D is a physics engine. It has a lot of features, but the most important for the project are the<a id="id229" class="indexterm"/> following (taken from the Box2D <a id="id230" class="indexterm"/>documentation):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Collision</strong>: This functionality is<a id="id231" class="indexterm"/> very interesting as it allows our tetrimino to interact with each other<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Continuous collision detection</li><li class="listitem" style="list-style-type: disc">Rigid bodies (convex polygons and circles)</li><li class="listitem" style="list-style-type: disc">Multiple shapes per body </li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Physics</strong>: This functionality <a id="id232" class="indexterm"/>will allow a piece to fall down and more<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Continuous physics with the time of impact solver</li><li class="listitem" style="list-style-type: disc">Joint limits, motors, and friction</li><li class="listitem" style="list-style-type: disc">Fairly accurate reaction forces/impulses</li></ul></div></li></ul></div><p>As you can see, Box2D provides all that we need in order to build our game. There are a lot of other features usable with this engine, but they don't interest us right now so I will not describe them in detail. However, if you are interested, you can take a look at the official website for more details<a id="id233" class="indexterm"/> on the Box2D features (<a class="ulink" href="http://box2d.org/about/">http://box2d.org/about/</a>).</p><p>It's important to note that Box2D uses meters, kilograms, seconds, and radians for the angle as units; SFML uses pixels, seconds, and degrees. So we will need to make some conversions. I will come back to this later.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Preparing Box2D</h2></div></div></div><p>Now that Box2D is<a id="id234" class="indexterm"/> introduced, let's install it. You will find the list of available versions on the Google code project page at <a class="ulink" href="https://code.google.com/p/box2d/downloads/list">https://code.google.com/p/box2d/downloads/list</a>. Currently, the latest stable version is 2.3. Once you have<a id="id235" class="indexterm"/> downloaded the source code (from compressed file or using SVN), you will need to build it.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Build</h3></div></div></div><p>Here is the good news, Box2D uses CMake as build <a id="id236" class="indexterm"/>process so you just have to follow the exact same steps as the SFML build described in the first chapter of this book and you will successfully build Box2D. If everything is fine, you will find the example project at this place: <code class="literal">path/to/Box2D/build/Testbed/Testbed</code>. Now, let's install it.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Install</h3></div></div></div><p>Once you have<a id="id237" class="indexterm"/> successfully built your Box2D library, you will need to configure your system or IDE to find the Box2D library and headers. The newly built library can be found in the <code class="literal">/path/to/Box2D/build/Box2D/</code> directory and is named <code class="literal">libBox2D.a</code>. On the other hand, the headers are located in the <code class="literal">path/to/Box2D/Box2D/</code> directory. If everything is okay, you will find a <code class="literal">Box2D.h</code> file in the folder.</p><p>On Linux, the following command adds Box2D to your system without requiring any configuration:</p><div><pre class="programlisting">
<strong>sudo make install</strong>
</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Pairing Box2D and SFML</h1></div></div></div><p>Now that Box2D is installed and your system is configured to find it, let's build the physics "hello world": a falling square.</p><p>It's important to note that Box2D uses meters, kilograms, seconds, and radian for angle as units; SFML uses<a id="id238" class="indexterm"/> pixels, seconds, and degrees. So we will need to make some conversions.</p><p>Converting radians to degrees or vice versa is not difficult, but pixels to meters… this is another story. In fact, there is no way to convert a pixel to meter, unless if the number of pixels per meter is fixed. This<a id="id239" class="indexterm"/> is the technique that we will use.</p><p>So let's start by creating some utility functions. We should be able to convert radians to degrees, degrees to radians, meters to pixels, and finally pixels to meters. We will also need to fix the pixel per meter value. As we don't need any class for these functions, we will define them in a namespace converter. This will result as the following code snippet:</p><div><pre class="programlisting">namespace converter
{
    constexpr double PIXELS_PER_METERS = 32.0;
    constexpr double PI = 3.14159265358979323846;
                                                  
    template&lt;typename T&gt;
    constexpr  T pixelsToMeters(const T&amp; x){return x/PIXELS_PER_METERS;};
                                                  
    template&lt;typename T&gt;
    constexpr T metersToPixels(const T&amp; x){return x*PIXELS_PER_METERS;};
                                                  
    template&lt;typename T&gt;
    constexpr T degToRad(const T&amp; x){return PI*x/180.0;};
                                                  
    template&lt;typename T&gt;
    constexpr T radToDeg(const T&amp; x){return 180.0*x/PI;}
}</pre></div><p>As you can see, there is no difficulty here. We start to define some constants and then the convert functions. I've chosen to make the function template to allow the use of any number type. In <a id="id240" class="indexterm"/>practice, it will mostly be <code class="literal">double</code> or <code class="literal">int</code>. The conversion functions are also declared as <code class="literal">constexpr</code> to allow the compiler to calculate the value at compile time if it's possible (for example, with constant as a parameter). It's interesting<a id="id241" class="indexterm"/> because we will use this primitive a lot.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Box2D, how does it work?</h2></div></div></div><p>Now that we can convert SFML unit to Box2D unit and vice versa, we can pair Box2D with SFML. But first, how exactly does Box2D work?</p><p>Box2D works a lot like<a id="id242" class="indexterm"/> a physics engine:</p><div><ol class="orderedlist arabic"><li class="listitem">You start by creating an empty world with some gravity.</li><li class="listitem">Then, you create some object patterns. Each pattern contains the shape of the object position, its type (static or dynamic), and some other characteristics such as its density, friction, and energy restitution.</li><li class="listitem">You ask the world to create a new object defined by the pattern.</li><li class="listitem">In each game loop, you have to update the physical world with a small step such as our world in the games we've already made.</li></ol></div><p>Because the physics engine does not display anything on the screen, we will need to loop all the objects and display them by ourselves.</p><p>Let's start by creating a simple scene with two kinds of objects: a ground and square. The ground will be fixed and the squares will not. The square will be generated by a user event: mouse click.</p><p>This project is very simple, but the goal is to show you how to use Box2D and SFML together with a simple case study. A more complex one will come later.</p><p>We will need three functionalities for this small project to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a shape</li><li class="listitem" style="list-style-type: disc">Display the world</li><li class="listitem" style="list-style-type: disc">Update/fill the world</li></ul></div><p>Of course there is also the initialization of the world and window. Let's start with the main function:</p><div><ol class="orderedlist arabic"><li class="listitem">As always, we create a window for the display and we limit the FPS number to 60. I will come back to this point with the <code class="literal">displayWorld</code> function.</li><li class="listitem">We create the physical world from Box2D, with gravity as a parameter.</li><li class="listitem">We create a container that will store all the physical objects for the memory clean purpose.</li><li class="listitem">We create the ground by calling the <code class="literal">createBox</code> function (explained just after).</li><li class="listitem">Now it is time<a id="id243" class="indexterm"/> for the minimalist <code class="literal">game</code> loop:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Close event managements</li><li class="listitem" style="list-style-type: disc">Create a box by detecting that the right button of the mouse is pressed</li></ul></div></li><li class="listitem">Finally, we clean the memory before exiting the program:<div><pre class="programlisting">int main(int argc,char* argv[])
{
    sf::RenderWindow window(sf::VideoMode(800, 600, 32), "04_Basic");
    window.setFramerateLimit(60);
    b2Vec2 gravity(0.f, 9.8f);
    b2World world(gravity);
    std::list&lt;b2Body*&gt; bodies;
    bodies.emplace_back(book::createBox(world,400,590,800,20,b2_staticBody));

    while(window.isOpen()) {
        sf::Event event;
        while(window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {
            int x = sf::Mouse::getPosition(window).x;
            int y = sf::Mouse::getPosition(window).y;
            bodies.emplace_back(book::createBox(world,x,y,32,32));
        }
        displayWorld(world,window);
    }

    for(b2Body* body : bodies) {
        delete static_cast&lt;sf::RectangleShape*&gt;(body-&gt;GetUserData());
        world.DestroyBody(body);
    }
    return 0;
}</pre></div></li></ol></div><p>For the moment, except the Box2D world, nothing should surprise you so let's continue with the box creation.</p><p>This function is<a id="id244" class="indexterm"/> under the <code class="literal">book</code> namespace.</p><div><pre class="programlisting">b2Body* createBox(b2World&amp; world,int pos_x,int pos_y, int size_x,int size_y,b2BodyType type = b2_dynamicBody)
{
    b2BodyDef bodyDef;
    bodyDef.position.Set(converter::pixelsToMeters&lt;double&gt;(pos_x),
                        converter::pixelsToMeters&lt;double&gt;(pos_y));
    bodyDef.type = type;                  
    b2PolygonShape b2shape;
    b2shape.SetAsBox(converter::pixelsToMeters&lt;double&gt;(size_x/2.0),
                    converter::pixelsToMeters&lt;double&gt;(size_y/2.0));
                                        
    b2FixtureDef fixtureDef;
    fixtureDef.density = 1.0;
    fixtureDef.friction = 0.4;
    fixtureDef.restitution= 0.5;
    fixtureDef.shape = &amp;b2shape;
                                         
    b2Body* res = world.CreateBody(&amp;bodyDef);
    res-&gt;CreateFixture(&amp;fixtureDef);
                                         
    sf::Shape* shape = new sf::RectangleShape(sf::Vector2f(size_x,size_y));
    shape-&gt;setOrigin(size_x/2.0,size_y/2.0);
    shape-&gt;setPosition(sf::Vector2f(pos_x,pos_y));
                                               
    if(type == b2_dynamicBody)
        shape-&gt;setFillColor(sf::Color::Blue);
    else
        shape-&gt;setFillColor(sf::Color::White);
                                                         
    res-&gt;SetUserData(shape);
                  
    return res;
}</pre></div><p>This function contains a lot of new functionalities. Its goal is to create a rectangle of a specific size at a predefined position. The type of this rectangle is also set by the user (dynamic or static). Here again, let's explain the function step-by-step:</p><div><ol class="orderedlist arabic"><li class="listitem">We create <code class="literal">b2BodyDef</code>. This <a id="id245" class="indexterm"/>object contains the definition of the body to create. So we set the position and its type. This position will be in relation to the gravity center of the object.</li><li class="listitem">Then, we create <code class="literal">b2Shape</code>. This is the physical shape of the object, in our case, a box. Note that the <code class="literal">SetAsBox()</code> method doesn't take the same parameter as <code class="literal">sf::RectangleShape</code>. The parameters are half the size of the box. This is why we need to divide the values by two.</li><li class="listitem">We create <code class="literal">b2FixtureDef</code> and initialize it. This object holds all the physical characteristics of the object such as its density, friction, restitution, and shape.</li><li class="listitem">Then, we properly create the object in the physical world.</li><li class="listitem">Now, we create the display of the object. This will be more familiar because we will only use SFML. We create a rectangle and set its position, origin, and color.</li><li class="listitem">As we need to associate and display SFML object to the physical object, we use a functionality of Box2D: the <code class="literal">SetUserData()</code> function. This function takes <code class="literal">void*</code> as a parameter and internally holds it. So we use it to keep track of our SFML shape.</li><li class="listitem">Finally, the body is returned by the function. This pointer has to be stored to clean the memory later. This is the reason for the body's container in <code class="literal">main()</code>.</li></ol></div><p>Now, we have the capability to simply create a box and add it to the world. Now, let's render it to the screen. This is the goal of the <code class="literal">displayWorld</code> function:</p><div><pre class="programlisting">void displayWorld(b2World&amp; world,sf::RenderWindow&amp; render)
{
    world.Step(1.0/60,int32(8),int32(3));
    render.clear();
    for (b2Body* body=world.GetBodyList(); body!=nullptr; body=body-&gt;GetNext())
    {   
        sf::Shape* shape = static_cast&lt;sf::Shape*&gt;(body-&gt;GetUserData());
        shape-&gt;setPosition(converter::metersToPixels(body-&gt;GetPosition().x),
        converter::metersToPixels(body-&gt;GetPosition().y));
        shape-&gt;setRotation(converter::radToDeg&lt;double&gt;(body-&gt;GetAngle()));
        render.draw(*shape);
    }
    render.display();
}</pre></div><p>This function takes the physics world and window as a parameter. Here again, let's explain this function step-by-step:</p><div><ol class="orderedlist arabic"><li class="listitem">We update the physical world. If you remember, we have set the frame rate to 60. This is why we use 1,0/60 as a parameter here. The two others are for precision only. In a good code, the time step should not be hardcoded as here. We have to use a clock to be sure that the value will always be the same. Here, it has not been the case to focus on the important part: physics. And more importantly, the physics loop should be different from the display loop as already said in <a class="link" href="ch02.html" title="Chapter 2. General Game Architecture, User Inputs, and Resource Management">Chapter 2</a>, <em>General Game Architecture, User Inputs, and Resource Management</em>. I will come back to this point in the next section.</li><li class="listitem">We reset the screen, as usual.</li><li class="listitem">Here is the new <a id="id246" class="indexterm"/>part: we loop the body stored by the world and get back the SFML shape. We update the SFML shape with the information taken from the physical body and then render it on the screen.</li><li class="listitem">Finally, we render the result on the screen.</li></ol></div><p>That's it. The final result should look like the following screenshot:</p><div><img src="img/8477OS_04_01.jpg" alt="Box2D, how does it work?"/></div><p>As you can see, it's not really difficult to pair SFML with Box2D. It's not a pain to add it. However, we have to<a id="id247" class="indexterm"/> take care of the data conversion. This is the real trap. Pay attention to the precision required (<code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">double</code>) and everything should be fine.</p><p>Now that you have all the keys in hand, let's build a real game with physics.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Adding physics to a game</h1></div></div></div><p>Now that Box2D<a id="id248" class="indexterm"/> is introduced with a basic project, let's focus on the real one. We will modify our basic Tetris to get Gravity-Tetris alias Gravitris. The game control will be the same as in Tetris, but the game engine will not be. We will replace the board with a real physical engine.</p><p>With this project, we will reuse a lot of work previously done. As already said, the goal of some of our classes is to be reusable in any game using SFML. Here, this will be made without any difficulties as you will see. The classes concerned are those you deal with user event <code class="literal">Action</code>, <code class="literal">ActionMap</code>, <code class="literal">ActionTarget</code>—but also <code class="literal">Configuration</code> and <code class="literal">ResourceManager</code>. Because all these classes have already been explained in detail in the previous chapters, I will not waste time to explain them again in this one.</p><p>There are still some changes that will occur in the <code class="literal">Configuration</code> class, more precisely, in the enums and <code class="literal">initialization</code> methods of this class because we don't use the exact same sounds and events that were used in the Asteroid game. So we need to adjust them to our needs.</p><p>Enough with explanations, let's do it with the following code:</p><div><pre class="programlisting">class Configuration
{
    public:
        Configuration() = delete;
        Configuration(const Configuration&amp;) = delete;
        Configuration&amp; operator=(const Configuration&amp;) = delete;
        
        enum Fonts : int {Gui};
        static ResourceManager&lt;sf::Font,int&gt; fonts;
        
        enum PlayerInputs : int { TurnLeft,TurnRight, MoveLeft, MoveRight,HardDrop};
        static ActionMap&lt;int&gt; playerInputs;
        
        enum Sounds : int {Spawn,Explosion,LevelUp,};
        static ResourceManager&lt;sf::SoundBuffer,int&gt; sounds;
        
        enum Musics : int {Theme};
        static ResourceManager&lt;sf::Music,int&gt; musics;
        
        static void initialize();
        
    private:
        static void initTextures();
        static void initFonts();
        static void initSounds();
        static void initMusics();
        static void initPlayerInputs();
};</pre></div><p>As you can see, the changes are in the <code class="literal">enum</code>, more precisely in <code class="literal">Sounds</code> and <code class="literal">PlayerInputs</code>. We change<a id="id249" class="indexterm"/> the values into more adapted ones to this project. We still have the font and music theme. Now, take a look at the initialization methods that have changed:</p><div><pre class="programlisting">void Configuration::initSounds()
{
    sounds.load(Sounds::Spawn,"media/sounds/spawn.flac");
    sounds.load(Sounds::Explosion,"media/sounds/explosion.flac");
    sounds.load(Sounds::LevelUp,"media/sounds/levelup.flac");
}
void Configuration::initPlayerInputs()
{
    playerInputs.map(PlayerInputs::TurnRight,Action(sf::Keyboard::Up));
    playerInputs.map(PlayerInputs::TurnLeft,Action(sf::Keyboard::Down));
    playerInputs.map(PlayerInputs::MoveLeft,Action(sf::Keyboard::Left));
    playerInputs.map(PlayerInputs::MoveRight,Action(sf::Keyboard::Right));
    playerInputs.map(PlayerInputs::HardDrop,Action(sf::Keyboard::Space,
    Action::Type::Released));
}</pre></div><p>No real surprises here. We simply adjust the resources to our needs for the project. As you can see, the changes are really minimalistic and easily done. This is the aim of all reusable modules or classes. Here<a id="id250" class="indexterm"/> is a piece of advice, however: keep your code as modular as possible, this will allow you to change a part very easily and also to import any generic part of your project to another one easily.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>The Piece class</h2></div></div></div><p>Now that we have the configuration class done, the next step is the <code class="literal">Piece</code> class. This class will be the most modified one. Actually, as there is too much change involved, let's build it from scratch. A piece <a id="id251" class="indexterm"/>has to be considered as an ensemble of four squares that are independent from one another. This will allow us to split a piece at runtime. Each of these squares will be a different fixture attached to the same body, the piece.</p><p>We will also need to add some force to a piece, especially to the current piece, which is controlled by the player. These forces can move the piece horizontally or can rotate it.</p><p>Finally, we will need to draw the piece on the screen.</p><p>The result will show the following code snippet:</p><div><pre class="programlisting">constexpr int BOOK_BOX_SIZE = 32;
constexpr int BOOK_BOX_SIZE_2 = BOOK_BOX_SIZE / 2;
class Piece : public sf::Drawable
{
    public:
        Piece(const Piece&amp;) = delete;
        Piece&amp; operator=(const Piece&amp;) = delete;

        enum TetriminoTypes {O=0,I,S,Z,L,J,T,SIZE}; 
        static const sf::Color TetriminoColors[TetriminoTypes::SIZE];        

        Piece(b2World&amp; world,int pos_x,int pos_y,TetriminoTypes type,float rotation); 
        ~Piece();
        void update();
        void rotate(float angle);
        void moveX(int direction);
        b2Body* getBody()const;

    private:
        virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
        b2Fixture* createPart((int pos_x,int pos_y,TetriminoTypes type); ///&lt; position is relative to the piece int the matrix coordinate (0 to 3)
        b2Body * _body;
        b2World&amp; _world;
};</pre></div><p>Some parts of the class don't change such as the <code class="literal">TetriminoTypes</code> and <code class="literal">TetriminoColors</code> enums. This is normal because we don't change any piece's shape or colors. The rest is still the same.</p><p>The implementation<a id="id252" class="indexterm"/> of the class, on the other side, is very different from the precedent version. Let's see it:</p><div><pre class="programlisting">Piece::Piece(b2World&amp; world,int pos_x,int pos_y,TetriminoTypes type,float rotation) : _world(world)
{
    b2BodyDef bodyDef;
    bodyDef.position.Set(converter::pixelsToMeters&lt;double&gt;(pos_x),
    converter::pixelsToMeters&lt;double&gt;(pos_y));
    bodyDef.type = b2_dynamicBody;
    bodyDef.angle = converter::degToRad(rotation);
    _body = world.CreateBody(&amp;bodyDef);

    switch(type)
    {
        case TetriminoTypes::O : {
            createPart((0,0,type); createPart((0,1,type);
            createPart((1,0,type); createPart((1,1,type);
        }break;
        case TetriminoTypes::I : {
            createPart((0,0,type); createPart((1,0,type);
            createPart((2,0,type); createPart((3,0,type);
        }break;
        case TetriminoTypes::S : {
            createPart((0,1,type); createPart((1,1,type);
            createPart((1,0,type); createPart((2,0,type);
        }break;
        case TetriminoTypes::Z : {
            createPart((0,0,type); createPart((1,0,type);
            createPart((1,1,type); createPart((2,1,type);
        }break;
        case TetriminoTypes::L : {
            createPart((0,1,type); createPart((0,0,type);
            createPart((1,0,type); createPart((2,0,type);
        }break;
        case TetriminoTypes::J : {
            createPart((0,0,type); createPart((1,0,type);
            createPart((2,0,type); createPart((2,1,type);
        }break;
        case TetriminoTypes::T : {
            createPart((0,0,type); createPart((1,0,type);
            createPart((1,1,type); createPart((2,0,type);
        }break;
        default:break;
    }
    body-&gt;SetUserData(this);
    update();
}</pre></div><p>The constructor is the most important method of this class. It initializes the physical body and adds each square to it by calling <code class="literal">createPart()</code>. Then, we set the user data to the piece itself. This will <a id="id253" class="indexterm"/>allow us to navigate through the physics to SFML and vice versa. Finally, we synchronize the physical object to the drawable by calling the <code class="literal">update()</code> function:</p><div><pre class="programlisting">Piece::~Piece()
{
    for(b2Fixture* fixture=_body-&gt;GetFixtureList();fixture!=nullptr;
    fixture=fixture-&gt;GetNext())
{
        sf::ConvexShape* shape = static_cast&lt;sf::ConvexShape*&gt;(fixture-&gt;GetUserData());
        fixture-&gt;SetUserData(nullptr);
        delete shape;
    }
    _world.DestroyBody(_body);
}</pre></div><p>The destructor loop on all the fixtures attached to the body, destroys all the SFML shapes and then removes the<a id="id254" class="indexterm"/> body from the world:</p><div><pre class="programlisting">b2Fixture* Piece::createPart((int pos_x,int pos_y,TetriminoTypes type)
{
    b2PolygonShape b2shape;
    b2shape.SetAsBox(converter::pixelsToMeters&lt;double&gt;(BOOK_BOX_SIZE_2),
    converter::pixelsToMeters&lt;double&gt;(BOOK_BOX_SIZE_2)
    ,b2Vec2(converter::pixelsToMeters&lt;double&gt;(BOOK_BOX_SIZE_2+(pos_x*BOOK_BOX_SIZE)),
converter::pixelsToMeters&lt;double&gt;(BOOK_BOX_SIZE_2+(pos_y*BOOK_BOX_SIZE))),0);

    b2FixtureDef fixtureDef;
    fixtureDef.density = 1.0;
    fixtureDef.friction = 0.5;
    fixtureDef.restitution= 0.4;
    fixtureDef.shape = &amp;b2shape;

    b2Fixture* fixture = _body-&gt;CreateFixture(&amp;fixtureDef);

    sf::ConvexShape* shape = new sf::ConvexShape((unsigned int) b2shape.GetVertexCount());
    shape-&gt;setFillColor(TetriminoColors[type]);
    shape-&gt;setOutlineThickness(1.0f);
    shape-&gt;setOutlineColor(sf::Color(128,128,128));
    fixture-&gt;SetUserData(shape);
    
    return fixture;
}</pre></div><p>This method adds a square to the body at a specific place. It starts by creating a physical shape as the desired box and then adds this to the body. It also creates the SFML square that will be used for the display, and it will attach this as user data to the fixture. We don't set the initial position because the constructor will do it.</p><div><pre class="programlisting">void Piece::update()
{
    const b2Transform&amp; xf = _body-&gt;GetTransform();
    
    for(b2Fixture* fixture = _body-&gt;GetFixtureList(); fixture != nullptr;
    fixture=fixture-&gt;GetNext())
{
        sf::ConvexShape* shape = static_cast&lt;sf::ConvexShape*&gt;(fixture-&gt;GetUserData());
        const b2PolygonShape* b2shape = static_cast&lt;b2PolygonShape*&gt;(fixture-&gt;GetShape());
        const uint32 count = b2shape-&gt;GetVertexCount();
        for(uint32 i=0;i&lt;count;++i) 
{
            b2Vec2 vertex = b2Mul(xf,b2shape-&gt;m_vertices[i]);
            shape-&gt;setPoint(i,sf::Vector2f(converter::metersToPixels(vertex.x),
            converter::metersToPixels(vertex.y)));
        }
    }
}</pre></div><p>This method synchronizes the position and rotation of all the SFML shapes from the physical position and <a id="id255" class="indexterm"/>rotation calculated by Box2D. Because each piece is composed of several parts—fixture—we need to iterate through them and update them one by one.</p><div><pre class="programlisting">void Piece::rotate(float angle) {
    body-&gt;ApplyTorque((float32)converter::degToRad(angle),true);
}
void Piece::moveX(int direction) {
    body-&gt;ApplyForceToCenter(b2Vec2(converter::pixelsToMeters(direction),0),true);
}</pre></div><p>These two methods add some force to the object to move or rotate it. We forward the job to the Box2D library.</p><div><pre class="programlisting">b2Body* Piece::getBody()const {return _body;}

void Piece::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
    for(const b2Fixture* fixture=_body-&gt;GetFixtureList();fixture!=nullptr; fixture=fixture-&gt;GetNext())
{
        sf::ConvexShape* shape = static_cast&lt;sf::ConvexShape*&gt;(fixture-&gt;GetUserData());
        if(shape)
            target.draw(*shape,states);
    }
}</pre></div><p>This function draws the entire piece. However, because the piece is composed of several parts, we need to iterate on them and draw them one by one in order to display the entire piece. This is done by<a id="id256" class="indexterm"/> using the user data saved in the fixtures.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>The World class</h2></div></div></div><p>Now that we have built our pieces, let's make a world that will be populated by them. This class will be very similar to the one previously made in the Tetris clone. But now, the game is based on physics. So we need to<a id="id257" class="indexterm"/> separate the physics and the display updates. To do this, two <code class="literal">update</code> methods will be used. </p><p>The big change is that the board is no longer a grid, but a physical world. Because of this, a lot of internal logic will be changed. Now, let's see it:</p><div><pre class="programlisting">class World : public sf::Drawable
{
    public:
        World(const World&amp;) = delete;
        World&amp; operator=(const World&amp;) = delete;

        World(int size_x,int size_y);
        ~World();
        void update(sf::Time deltaTime);
        void updatePhysics(sf::Time deltaTime);
        Piece* newPiece();
        int clearLines(bool&amp; del,const Piece&amp; current);
        void updateGravity(int level);
        void add(Configuration::Sounds sound_id);
        bool isGameOver()const;

    private:
        virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
        b2World _physicalWorld;
        void createWall(int pos_x, int pos_y, int size_x, int size_y);
        const int _x;
        const int _y;
        std::list&lt;std::unique_ptr&lt;sf::Sound&gt;&gt; _sounds;
};</pre></div><p>We make the class non-replicable, with size as a parameter. As you can see, there are now two <code class="literal">update</code> methods. One for the physics and another one for the SFML objects. We still have some methods specific for the game such as <code class="literal">newPiece()</code>, <code class="literal">clearLines()</code>, <code class="literal">isGameOver()</code>, a new one relative to the <code class="literal">updateGravity()</code> physic, and a method to add sounds to our world. This method directly comes from the Meteor game by copying and pasting it.</p><p>Now that the class is introduced, take a look at its implementation. The following constructor initializes the <a id="id258" class="indexterm"/>physical world with a default gravity and adds some walls to it:</p><div><pre class="programlisting">World::World(int size_x,int size_y) : _physicalWorld(b2Vec2(0.f, 1.5f)),_x(size_x), _y(size_y)
{
    createWall(0,0,BOOK_BOX_SIZE,_y*BOOK_BOX_SIZE);
    createWall(BOOK_BOX_SIZE*(_x+1.2),0,BOOK_BOX_SIZE,_y*BOOK_BOX_SIZE);
    createWall(0,BOOK_BOX_SIZE*_y,BOOK_BOX_SIZE*(_x+2.2),BOOK_BOX_SIZE);
}</pre></div><p>The destructor removes all the SFML shapes attached to the bodies still present in the world:</p><div><pre class="programlisting">World::~World()
{
    for (b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;)
{
        b2Body* next = body-&gt;GetNext();
        if(body-&gt;GetType() == b2_dynamicBody)
            delete static_cast&lt;Piece*&gt;(body-&gt;GetUserData());
        else
            delete static_cast&lt;sf::RectangleShape*&gt;(body-&gt;GetUserData());
        body = next;
    }
}</pre></div><p>The following method synchronizes the physical bodies with the SFML objects that display it. It also removes all the sounds effects that are finished, as already explained in the previous chapter:</p><div><pre class="programlisting">void World::update(sf::Time deltaTime)
{
    for (b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;
    body=body-&gt;GetNext())
{
        if(body-&gt;GetType() == b2_dynamicBody){
            Piece* piece = static_cast&lt;Piece*&gt;(body-&gt;GetUserData());
            piece-&gt;update();
        }
    }
    _sounds.remove_if([](const std::unique_ptr&lt;sf::Sound&gt;&amp; sound) -&gt; bool {
          return sound-&gt;getStatus() != sf::SoundSource::Status::Playing;
        });
}</pre></div><p>Now, we construct a class inside the <code class="literal">World.cpp</code> file because we don't need the class anywhere else. This class will be used to query the physical world by getting all the fixtures inside an area. This <a id="id259" class="indexterm"/>will be used more, especially to detect the completed lines:</p><div><pre class="programlisting">Class _AABB_callback  : public b2QueryCallback
{
    public :
        std::&lt;b2Fixture*&gt; fixtures;
        
        virtual bool ReportFixture(b2Fixture* fixture) override {
            if(fixture-&gt;GetBody()-&gt;GetType() == b2_dynamicBody)
                fixtures.emplace_back(fixture);
            return true;
        }
};</pre></div><p>The following method clears the completed lines by querying the world, especially with the made class. Then, we count the number of fixtures (squares) on each line; if this number satisfies our criteria, we delete all the fixtures and the line. However, by doing this, we could have some bodies with no fixture. So, if we remove the last fixture attached to a body, we also remove the body. Of course, we also remove all the SFML shapes corresponding to those deleted objects. Finally, for more fun, we add some sounds to the world if needed:</p><div><pre class="programlisting">int World::clearLines(bool&amp; del,const Piece&amp; current)
{
    int nb_lines = 0;
    _AABB_callback callback;
    del = false;
    for(int y=0;y&lt;=_y;++y) 
{ //loop on Y axies
        b2AABB aabb; //world query
        //set the limit of the query
        aabb.lowerBound = b2Vec2(converter::pixelsToMeters&lt;double&gt;(0),
        converter::pixelsToMeters&lt;double&gt;((y+0.49)*BOOK_BOX_SIZE));
        aabb.upperBound = b2Vec2(converter::pixelsToMeters&lt;double&gt;(_x*BOOK_BOX_SIZE),
             converter::pixelsToMeters&lt;double&gt;((y+0.51)*BOOK_BOX_SIZE));
        //query the world
        _physicalWorld.QueryAABB(&amp;callback,aabb);

        if((int)callback.fixtures.size() &gt;= _x) 
{
            for(b2Fixture* fixture : callback.fixtures) 
{
                b2Body* body = fixture-&gt;GetBody();
                del |= body == current.getBody();

                if(body-&gt;GetFixtureList()-&gt;GetNext() != nullptr)
               {//no more fixture attached to the body
                    sf::ConvexShape* shape = static_cast&lt;sf::ConvexShape*&gt;(fixture-&gt;GetUserData());
                    body-&gt;DestroyFixture(fixture);
                    delete shape;
                } else {
                    Piece* piece = static_cast&lt;Piece*&gt;(body-&gt;GetUserData());
                    delete piece;
                }
                fixture = nullptr;
            }
            ++nb_lines;
        }
        callback.fixtures.clear();
    }
    if(nb_lines &gt; 0)
        add(Configuration::Sounds::Explosion);
    return nb_lines;
}</pre></div><p>The following function sets the gravity depending on the current level. Bigger the level, stronger is the gravity:</p><div><pre class="programlisting">void World::updateGravity(int level) {
    physical_world.SetGravity(b2Vec2(0,1.5+(level/2.0)));
}</pre></div><p>The following<a id="id260" class="indexterm"/> function is directly taken from the Asteroid clone, and was already explained. It just adds sound to our world:</p><div><pre class="programlisting">void World::add(Configuration::Sounds sound_id)
{
    std::unique_ptr&lt;sf::Sound&gt; sound(new sf::Sound(Configuration::sounds.get(sound_id)));
    sound-&gt;setAttenuation(0);
    sound-&gt;play();
    _sounds.emplace_back(std::move(sound));
}</pre></div><p>This method checks if the game is over with a simple criterion, "are there any bodies out of the board?":</p><div><pre class="programlisting">bool World::isGameOver()const
{
    for (const b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;
    body=body-&gt;GetNext())
{
        if(body-&gt;GetType() == b2_staticBody)
            continue;
        if(body-&gt;GetPosition().y &lt; 0)
            return true;
    }
    return false;
};</pre></div><p>This function updates only the physical world by forwarding the job to Box2D:</p><div><pre class="programlisting">void World::updatePhysics(sf::Time deltaTime)
{
    float seconds = deltaTime.asSeconds();  
    _physicalWorld.Step(seconds,8,3);
}</pre></div><p>Now, we create a<a id="id261" class="indexterm"/> piece and set its initial position to the top of our board. We also add a sound to alert the player about this:</p><div><pre class="programlisting">Piece* World::newPiece()
{
    add(Configuration::Sounds::Spawn);
    return new Piece(_physicalWorld,_x/2*BOOK_BOX_SIZE, BOOK_BOX_SIZE,static_cast&lt;Piece::TetriminoTypes&gt;( random(0, Piece::TetriminoTypes::SIZE-1)), random(0.f,360.f));
}</pre></div><p>The <code class="literal">draw()</code> function is pretty simple. We iterate on all the bodies still alive in the world and display the SFML object attached to them:</p><div><pre class="programlisting">void World::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
    for (const b2Body* body=_physicalWorld.GetBodyList(); body!=nullptr;body=body-&gt;GetNext())
{
        if(body-&gt;GetType() == b2_dynamicBody){
            Piece* piece = static_cast&lt;Piece*&gt;(body-&gt;GetUserData());
            target.draw(*piece,states);
        } else {//static body
            sf::RectangleShape* shape = static_cast&lt;sf::RectangleShape*&gt;(body-&gt;GetUserData());
            target.draw(*shape,states);
        }
    }
}</pre></div><p>The following functions are helpful. Its aim is to create a static body that will represent a wall. All the functionalities<a id="id262" class="indexterm"/> used were already explained in the first part of this chapter, so nothing should surprise you:</p><div><pre class="programlisting">void World::creatWeall(int pos_x, int pos_y,int size_x,int size_y)
{
    b2BodyDef bodyDef;
    bodyDef.position.Set(converter::pixelsToMeters&lt;double&gt;(pos_x),
    converter::pixelsToMeters&lt;double&gt;(pos_y));
    bodyDef.type = b2_staticBody;
    
    b2PolygonShape b2shape;
    double sx = converter::pixelsToMeters&lt;double&gt;(size_x)/2.0;
    double sy = converter::pixelsToMeters&lt;double&gt;(size_y)/2.0;
    b2shape.SetAsBox(sx,sy,b2Vec2(sx,sy),0);                
    
    b2FixtureDef fixtureDef;
    fixtureDef.density = 1.0;
    fixtureDef.friction = 0.8;
    fixtureDef.restitution= 0.1;
    fixtureDef.shape = &amp;b2shape;
    
    b2Body* body = _physicalWorld.CreateBody(&amp;bodyDef);
    body-&gt;CreateFixture(&amp;fixtureDef);
    
    sf::Shape* shape = new sf::RectangleShape(sf::Vector2f(size_x,size_y));
    shape-&gt;setOrigin(size_x/2.0,size_y/2.0);
    shape-&gt;setPosition(sf::Vector2f(pos_x+size_x/2.0,pos_y+size_y/2.0));
    shape-&gt;setFillColor(sf::Color(50,50,50));
    body-&gt;SetUserData(shape);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>The Game class</h2></div></div></div><p>Now, we have a world that can be populated by some pieces, let's build the last important class—the <code class="literal">Game</code> class.</p><p>There is a big change in this class. If you remember, in <a class="link" href="ch02.html" title="Chapter 2. General Game Architecture, User Inputs, and Resource Management">Chapter 2</a>, <em>General Game Architecture, User Inputs, and Resource Management</em>, I said that a game with physics should use two game loops instead of one. The reason for this is that most of the physical engine works well with a fixed time step. Moreover, this can avoid a really bad thing. Imagine that your physical engine takes 0.01 second to compute the new position of all the bodies in your world, but the delta time passed as argument to your <code class="literal">update</code> function is fewer. The result will be that your game <a id="id263" class="indexterm"/>will enter in a death state and will finally freeze.</p><p>The solution is to separate the physics from the rendering. Here, the physics will run at 60 FPS and the game at a minimum of 30 FPS. The solution presented here is not perfect because we don't separate the computation in different threads, but this will be done later, in the sixth chapter.</p><p>Take a look at the <code class="literal">Game</code> header file:</p><div><pre class="programlisting">class Game: public ActionTarget&lt;int&gt;
{
    public:
        Game(const Game&amp;) = delete;
        Game&amp; operator=(const Game&amp;) = delete;
        Game(int x,int y,int word_x=10,int word_y=20);
        void run(int minimum_frame_per_seconds=30,int phyiscs_frame_per_seconds=60);

    private:
        void processEvents();
        void update(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame);
        void updatePhysics(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame);
        void render();

        sf::RenderWindow _window;
        int _moveDirection;
        int _rotateDirection;
        Piece* _currentPiece;
        World _world;
        Stats _stats;
        sf::Time timeSinceLastFall;
};</pre></div><p>No surprises here. The usual methods are present. We just duplicate the <code class="literal">update</code> function, one for logic and the other for physics.</p><p>Now, let's see the<a id="id264" class="indexterm"/> implementation. The constructor initializes <code class="literal">World</code> and binds the player inputs. It also creates the initial piece that will fall on the board:</p><div><pre class="programlisting">Game::Game(int X, int Y,int word_x,int word_y) : ActionTarget(Configuration::playerInputs), _window(sf::VideoMode(X,Y),"04_Gravitris"),_currentPiece(nullptr), _world(word_x,word_y)
{
    bind(Configuration::PlayerInputs::HardDrop,[this](const sf::Event&amp;){
         _currentPiece = _world.newPiece();
         timeSinceLastFall = sf::Time::Zero;
    });
    bind(Configuration::PlayerInputs::TurnLeft,[this](const sf::Event&amp;){
         _rotateDirection-=1;
    });
    bind(Configuration::PlayerInputs::TurnRight,[this](const sf::Event&amp;){
         _rotateDirection+=1;
    });
    bind(Configuration::PlayerInputs::MoveLeft,[this](const sf::Event&amp;){
         _moveDirection-=1;
    });
    bind(Configuration::PlayerInputs::MoveRight,[this](const sf::Event&amp;){
         _moveDirection+=1;
    });
    _stats.setPosition(BOOK_BOX_SIZE*(word_x+3),BOOK_BOX_SIZE);
    _currentPiece = _world.newPiece();
}</pre></div><p>The following function has nothing new except that the two <code class="literal">update()</code> functions are called instead of one:</p><div><pre class="programlisting">void Game::run(int minimum_frame_per_seconds, int physics_frame_per_seconds)
{
    sf::Clock clock;
    const sf::Time timePerFrame = sf::seconds(1.f/minimum_frame_per_seconds);
    const sf::Time timePerFramePhysics = sf::seconds(1.f/physics_frame_per_seconds);
    
    while (_window.isOpen())
    {
        sf::Time time = clock.restart();
        processEvents();
        if(not _stats.isGameOver()) 
{
            updatePhysics(time,timePerFramePhysics);
            update(time,timePerFrame);
        }
        render();
    }
}</pre></div><p>The following function updates the logic of our game:</p><div><pre class="programlisting">void Game::update(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame)
{
    sf::Time timeSinceLastUpdate = sf::Time::Zero;

    timeSinceLastUpdate+=deltaTime;
    timeSinceLastFall+=deltaTime;
    if(timeSinceLastUpdate &gt; timePerFrame)
    {
        if(_currentPiece != nullptr)
        {
            _currentPiece-&gt;rotate(_rotateDirection*3000);
            _currentPiece-&gt;moveX(_moveDirection*5000);
                         
            bool new_piece;
            int old_level =_stats.getLevel();
            _stats.addLines(_world.clearLines(new_piece,*_currentPiece));
            if(_stats.getLevel() != old_level) //add sound
                _world.add(Configuration::Sounds::LevelUp);

            if(new_piece or timeSinceLastFall.asSeconds() &gt; std::max(1.0,10-_stats.getLevel()*0.2))
            {//create new piece
                _currentPiece = _world.newPiece();
                timeSinceLastFall = sf::Time::Zero;
            }
        }
        _world.update(timePerFrame);
        _stats.setGameOver(_world.isGameOver());
        timeSinceLastUpdate = sf::Time::Zero;
    }
    _rotateDirection=0;
    _moveDirection=0;
}</pre></div><p>Here is the step-by-step evaluation of the preceding code:</p><div><ol class="orderedlist arabic"><li class="listitem">We start by updating some time value by adding the <code class="literal">deltaTime</code> parameter to them.</li><li class="listitem">Then, we apply some forces to the current piece if needed.</li><li class="listitem">We update the world by cleaning all the complete lines and also update the score.</li><li class="listitem">If needed, we create a new piece that will replace the current one.</li></ol></div><p>Now, take a look at the physics:</p><div><pre class="programlisting">void Game::updatePhysics(const sf::Time&amp; deltaTime,const sf::Time&amp; timePerFrame)
{
    static sf::Time timeSinceLastUpdate = sf::Time::Zero;
    timeSinceLastUpdate+=deltaTime;
    _world.updateGravity(_stats.getLevel());

    while (timeSinceLastUpdate &gt; timePerFrame)
{
        _world.updatePhysics(timePerFrame);
        timeSinceLastUpdate -= timePerFrame;
    }
}</pre></div><p>This function updates<a id="id265" class="indexterm"/> all the physics, including the gravity that changes with the current level. Here again, nothing is too complicated.</p><p>The <code class="literal">processEvents()</code> and <code class="literal">render()</code> functions don't change at all, and are exactly the same as in the first Tetris.</p><p>As you can see, the <code class="literal">Game</code> class doesn't change a lot and is very similar to the one previously made. The two loops—logics and physics—are the only real changes that occur.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>The Stats class</h2></div></div></div><p>Now, the last thing to build is the <code class="literal">Stats</code> class. However, we have already made it in the previous version of Tetris, so just copy and paste it. A little change has been made for the game over, by adding a getter and <a id="id266" class="indexterm"/>setter. That's it.</p><p>Now, you have all the keys in hand to build your new Tetris with sounds and gravity. The final result should<a id="id267" class="indexterm"/> look like the following screenshot:</p><div><img src="img/8477OS_04_02.jpg" alt="The Stats class"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>Since the usage of a physics engine has its own particularities such as the units and game loop, we have learned how to deal with them. Finally, we learned how to pair Box2D with SFML, integrate our fresh knowledge to our existing Tetris project, and build a new funny game.</p><p>In the next chapter, we will learn how to add a user interface to our game in order to interact with the user easily, by creating our own game user interface or by using an existing one.</p></div></body></html>