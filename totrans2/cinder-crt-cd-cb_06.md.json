["```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/ImageIo.h\"\n    ```", "```cpp\n    gl::Texture particleTexture;\n    ```", "```cpp\n    particleTexture=gl::Texture(loadImage(loadAsset(\"particle.png\")));\n    ```", "```cpp\n    float radius = Rand::randFloat(2.f, 10.f);\n    ```", "```cpp\n    gl::enableAlphaBlending();\n    particleTexture.enableAndBind();\n    gl::color(ColorA::white());\n    mParticleSystem.draw();\n    ```", "```cpp\n    void Particle::draw(){\n    ci::gl::drawSolidRect(ci::Rectf(position.x-radius, position.y-radius,\n    position.x+radius, position.y+radius));\n    }\n    ```", "```cpp\nvoid MainApp::draw()\n{   \ngl::enableAlphaBlending();\ngl::setViewport(getWindowBounds());\ngl::setMatricesWindow(getWindowWidth(), getWindowHeight());\n\ngl::color( ColorA(0.f,0.f,0.f, 0.05f) );\ngl::drawSolidRect(getWindowBounds());\ngl::color( ColorA(1.f,1.f,1.f, 1.f) );\nmParticleSystem.draw();\n}\n```", "```cpp\n    std::vector<ci::Vec2f> positionHistory;\n    int tailLength;\n    ```", "```cpp\n    tailLength = 10;\n    ```", "```cpp\n    position History.push_back(position);\n    if(positionHistory.size() >tailLength) {\n    positionHistory.erase( positionHistory.begin() );\n    }\n    ```", "```cpp\n    void Particle::draw(){\n      glBegin( GL_LINE_STRIP );\n      for( int i=0; i<positionHistory.size(); i++ ){\n    float alpha = (float)i/(float)positionHistory.size();\n    ci::gl::color( ci::ColorA(1.f,1.f,1.f, alpha));\n    ci::gl::vertex( positionHistory[i] );\n      }\n      glEnd();\n\n    ci::gl::color( ci::ColorA(1.f,1.f,1.f, 1.f) );\n    ci::gl::drawSolidCircle( position, radius );\n    }\n    ```", "```cpp\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    using namespace ci;\n    using namespace ci::app;\n    using namespace std;\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n      Vec2f mLeftCorner, \n    mRightCorner;\n      intmNumRows, mNumLines;\n    ```", "```cpp\n    Void MyApp::update(){\n      mParticleSystem.update();\n    }\n\n    void MyApp::draw(){\n      gl::clear( Color( 0, 0, 0 ) ); \n      mParticleSystem.draw();\n    }\n    ```", "```cpp\n    mLeftCorner = Vec2f( 50.0f, 50.0f );\n    mRightCorner = Vec2f( getWindowWidth() - 50.0f, 50.0f );\n    mNumRows = 20;\n    mNumLines = 15;\n    ```", "```cpp\n    float gap = ( mRightCorner.x - mLeftCorner.x ) / ( mNumRows-1 );\n    ```", "```cpp\n    for( int i=0; i<mNumRows; i++ ){\n    for( int j=0; j<mNumLines; j++ ){\n    float x = mLeftCorner.x + ( gap * i );\n    float y = mLeftCorner.y + ( gap * j );\n    Particle *particle = new Particle( Vec2f( x, y ), 5.0f, 5.0f, 0.95f );\n    mParticleSystem.addParticle( particle );\n            }\n        }\n    ```", "```cpp\n    for( int i=0; i<mNumRows; i++ ){\n    for( int j=0; j<mNumLines-1; j++ ){\n    int indexA = i * mNumLines + j;\n    int indexB = i * mNumLines + j + 1;\n                Particle *partA = mParticleSystem.particles[ indexA ];\n                Particle *partB = mParticleSystem.particles[ indexB ];\n    float rest = partA->position.distance( partB->position );\n                Spring *spring = new Spring( partA, partB, rest, 1.0f );\n    mParticleSystem.addSpring( spring );\n            }\n        }\n    ```", "```cpp\n    Vec2f gravity( 0.0f, 1.0f );\n    for( vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){\n            (*it)->forces += gravity;\n        }\n    ```", "```cpp\n    int topLeftIndex = 0;\n    int topRightIndex = ( mNumRows-1 ) * mNumLines;\n    mParticleSystem.particles[ topLeftIndex ]->position = mLeftCorner;\n    mParticleSystem.particles[ topRightIndex ]->position = mRightCorner;\n    ```", "```cpp\n    Particle *mDragParticle;\n    ```", "```cpp\n    mDragParticle = NULL;\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\n    void mouseUp( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n    for( vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){\n            Particle *part = *it;\n            float dist = part->position.distance( event.getPos() );\n    if( dist< part->radius ){\n    mDragParticle = part;\n    return;\n            }\n        }\n    }\n    ```", "```cpp\n    void MyApp::mouseUp( MouseEvent event ){\n    mDragParticle = NULL;\n    }\n    ```", "```cpp\n    if( mDragParticle != NULL ){\n    mDragParticle->position = getMousePos();\n        }\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/ImageIo.h\"\n    ```", "```cpp\n    gl::Texture mTexture;\n    ```", "```cpp\n    mTexture = loadImage( loadAsset( \"image.jpg\" ) );\n    ```", "```cpp\n    void MyApp::draw(){\n      gl::clear( Color( 0, 0, 0 ) );\n    }\n    ```", "```cpp\n    glEnableClientState( GL_VERTEX_ARRAY );\n    glEnableClientState( GL_TEXTURE_COORD_ARRAY );\n    mTexture.enableAndBind();\n    ```", "```cpp\n    for( int i=0; i<mNumRows-1; i++ ){\n      vector<Vec2f>vertexCoords, textureCoords;\n    }\n    ```", "```cpp\n    or( int j=0; j<mNumLines; j++ ){\n     int indexTopLeft = i * mNumLines + j;\n     int indexTopRight = ( i+1) * mNumLines + j;\n     Particle *left = mParticleSystem.particles[ indexTopLeft ];\n     Particle *right = mParticleSystem.particles[indexTopRight ];\n     float texX = ( (float)i / (float)(mNumRows-1) ) * mTexture.getRight();\n     float texY = ( (float)j / (float)(mNumLines-1) ) * mTexture.getBottom();\n     textureCoords.push_back( Vec2f( texX, texY ) );\n     vertexCoords.push_back( left->position );\n     texX = ( (float)(i+1) / (float)(mNumRows-1) ) * mTexture.getRight();\n     textureCoords.push_back( Vec2f( texX, texY ) );\n     vertexCoords.push_back( right->position );\n    }\n    ```", "```cpp\n    for( int i=0; i<mNumRows-1; i++ ){\n     vector<Vec2f> vertexCoords, textureCoords;\n     for( int j=0; j<mNumLines; j++ ){\n      int indexTopLeft = i * mNumLines + j;\n      int indexTopRight = ( i+1) * mNumLines + j;\n      Particle *left = mParticleSystem.particles[ indexTopLeft ];\n      Particle *right = mParticleSystem.particles[ indexTopRight ];\n      float texX = ( (float)i / (float)(mNumRows-1) ) * mTexture.getRight();\n      float texY = ( (float)j / (float)(mNumLines-1) ) * mTexture.getBottom();\n      textureCoords.push_back( Vec2f( texX, texY ) );\n      vertexCoords.push_back( left->position );\n      texX = ( (float)(i+1) / (float)(mNumRows-1) ) * mTexture.getRight();\n      textureCoords.push_back( Vec2f( texX, texY ) );\n      vertexCoords.push_back( right->position );\n     }\n     glVertexPointer 2, GL_FLOAT, 0, &vertexCoords[0] );\n     glTexCoordPointer( 2, GL_FLOAT, 0, &textureCoords[0] );\n     glDrawArrays( GL_TRIANGLE_STRIP, 0, vertexCoords.size() );\n    }\n    ```", "```cpp\n    mTexture.unbind();\n    ```", "```cpp\n    uniform sampler2D tex; \n    ```", "```cpp\n    void main (void) {\n      gl_FragColor = texture2D(tex, gl_TexCoord[0].st) * gl_Color;\n    }\n    ```", "```cpp\n    attribute float particleRadius;\n    void main(void)\n    {\n      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n      gl_PointSize = particleRadius;\n      gl_FrontColor = gl_Color;\n    }\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/ImageIo.h\"\n    #include \"cinder/Rand.h\"\n    #include \"cinder/gl/GlslProg.h\"\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    int mNumParticles;\n    Vec2f *mPositions;\n    float *mRadiuses;\n    ```", "```cpp\n    mNumParticles = 1000;\n    mPositions = new Vec2f[ mNumParticles ];\n    mRadiuses = new float[ mNumParticles ];\n\n    for( int i=0; i<mNumParticles; i++ ){\n     float x = randFloat( 0.0f, getWindowWidth() );\n     float y = randFloat( 0.0f, getWindowHeight() );\n     float radius = randFloat( 5.0f, 50.0f );\n     Particle *particle = new Particle( Vec2f( x, y ), radius, 1.0f, 0.9f );\n     mParticleSystem.addParticle( particle );\n    }\n    mParticleSystem.addParticle( particle );\n    ```", "```cpp\n    mParticleSystem.update();\n    for( int i=0; i<mNumParticles; i++ ){\n     mPositions[i] = mParticleSystem.particles[i]->position;\n     mRadiuses[i] = mParticleSystem.particles[i]->radius;\n    }\n    ```", "```cpp\n    gl::Texture mTexture;\n    gl::GlslProg mShader;\n    ```", "```cpp\n    mTexture = loadImage( loadAsset( \"particle.png\" ) );\n    mShader = gl::GlslProg( loadAsset( \"shader.vert\"), loadAsset( \"shader.frag\" ) );\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n    gl::enableAdditiveBlending();\n    mShader.bind();\n    ```", "```cpp\n    GLint particleRadiusLocation = mShader.getAttribLocation( \"particleRadius\" );\n    glEnableVertexAttribArray(particleRadiusLocation);\n    glVertexAttribPointer(particleRadiusLocation, 1, GL_FLOAT, false, 0, mRadiuses);\n    ```", "```cpp\n    glEnable(GL_POINT_SPRITE);\n    glTexEnvi(GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE);\n    glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);\t\n    ```", "```cpp\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glVertexPointer(2, GL_FLOAT, 0, mPositions);\n    ```", "```cpp\n    mTexture.enableAndBind();\n    glDrawArrays( GL_POINTS, 0, mNumParticles );\n    mTexture.unbind();\n    ```", "```cpp\n    glDisableClientState(GL_VERTEX_ARRAY); \n    glDisableVertexAttribArrayARB(particleRadiusLocation);\n    mShader.unbind();\n    ```", "```cpp\n    glVertexPointer(2, GL_FLOAT, 0, mPositions);\n    ```", "```cpp\n    glVertexPointer(3, GL_FLOAT, 0, mPositions);\n    ```", "```cpp\n    attribute float particleRadius;\n\n    void main(void)\n    {\n      vec4eyeCoord = gl_ModelViewMatrix * gl_Vertex;\n      gl_Position = gl_ProjectionMatrix * eyeCoord;\n      float distance = sqrt(eyeCoord.x*eyeCoord.x + eyeCoord.y*eyeCoord.y + eyeCoord.z*eyeCoord.z);\n      float attenuation = 3000.0 / distance;\n      gl_PointSize = particleRadius * attenuation;\n      gl_FrontColor = gl_Color;\n    }\n    ```", "```cpp\n    int numParticle = 100;\n    ```", "```cpp\n    float radius = Rand::randFloat(2.f, 5.f);\n    float mass = radius*2.f;\n    ```", "```cpp\n    void Particle::draw(){\n     ci::gl::drawSolidCircle(position, radius);\n     ci::gl::drawStrokedCircle(position, radius+2.f);\n    }\n    ```", "```cpp\n    void ParticleSystem::draw(){\n     gl::enableAlphaBlending();\n     std::vector<Particle*>::iterator it;\n     for(it = particles.begin(); it != particles.end(); ++it){\n      std::vector<Particle*>::iterator it2;\n      for(it2=particles.begin(); it2!= particles.end(); ++it2){\n       float distance = (*it)->position.distance( \n        (*it2)->position ));\n       float per = 1.f - (distance / 100.f);\n       ci::gl::color( ci::ColorA(1.f,1.f,1.f, per*0.8f) );\n       ci::Vec2f conVec = (*it2)->position-(*it)->position;\n       conVec.normalize();\n       ci::gl::drawLine(\n        (*it)->position+conVec * ((*it)->radius+2.f),\n        (*it2)->position-conVec * ((*it2)->radius+2.f ));\n      }\n     }\n     ci::gl::color( ci::ColorA(1.f,1.f,1.f, 0.8f) );\n     std::vector<Particle*>::iterator it3;\n     for(it3 = particles.begin(); it3!= particles.end(); ++it3){\n      (*it3)->draw();\n     }\n    }\n    ```", "```cpp\n    #include \"cinder/BSpline.h\"\n    ```", "```cpp\n    ci::BSpline3f spline;\n    ```", "```cpp\n    void ParticleSystem::computeBspline(){ \n     std::vector<ci::Vec3f> splinePoints;\n     std::vector<Particle*>::iterator it;\n     for(it = particles.begin(); it != particles.end(); ++it ){\n      ++it;\n      splinePoints.push_back( ci::Vec3f( (*it)->position ) );\n     }\n     spline = ci::BSpline3f( splinePoints, 3, false, false );\n    }\n    ```", "```cpp\n    computeBSpline();\n    ```", "```cpp\n    void ParticleSystem::draw(){\n     ci::gl::color(ci::Color::black());\n     if(spline.isUniform()) {\n      glBegin(GL_LINES);\n      float step = 0.001f;\n      for( float t = step; t <1.0f; t += step ) {\n       ci::gl::vertex( spline.getPosition( t-step ) );\n       ci::gl::vertex( spline.getPosition( t ) );\n      } \n      glEnd();\n     }\n     ci::gl::color(ci::Color(0.0f,0.0f,1.0f));\n     std::vector<Particle*>::iterator it;\n     for(it = particles.begin(); it != particles.end(); ++it ){\n      (*it)->draw();\n     }\n    }\n    ```", "```cpp\n    #include \"cinder/app/AppBasic.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Rand.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/MayaCamUI.h\"\n    #include \"cinder/BSpline.h\"\n\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n\n    float repulsionFactor;\n    float maxAlignSpeed;\n\n    CameraPersp        mCam;\n    MayaCamUI mMayaCam;\n\n    Vec3f mRepPosition;\n\n    BSpline3f   spline;\n    ```", "```cpp\n    void MainApp::setup()\n    {\n    repulsionFactor = -1.0f;\n    maxAlignSpeed = 10.f;\n    mRepPosition = Vec3f::zero();\n\n    mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);\n    mCam.setEyePoint(Vec3f(7.f,7.f,7.f));\n    mCam.setCenterOfInterestPoint(Vec3f::zero());\n    mMayaCam.setCurrentCam(mCam);\n    vector<Vec3f> splinePoints;\n    float step = 0.5f;\n    float width = 20.f;\n    for (float t = 0.f; t < width; t += step) {\n     float mass = Rand::randFloat(20.f, 25.f);\n     float drag = 0.95f;\n     splinePoints.push_back( Vec3f(math<float>::cos(t),\n     math<float>::sin(t),\n     t - width*0.5f) );\n     Particle *particle;\n     particle = new Particle( \n      Vec3f( math<float>::cos(t)+Rand::randFloat(-0.8f,0.8f),\n       math<float>::sin(t)+Rand::randFloat(-0.8f,0.8f),\n       t - width*0.5f), \n      1.f, mass, drag );\n     mParticleSystem.addParticle( particle );\n    }\n    spline = BSpline3f( splinePoints, 3, false, false );\n    }\n    ```", "```cpp\n    void MainApp::resize( ResizeEvent event ){\n      mCam = mMayaCam.getCamera();\n      mCam.setAspectRatio(getWindowAspectRatio());\n      mMayaCam.setCurrentCam(mCam);\n    }\n\n    void MainApp::mouseDown(MouseEvent event){\n      mMayaCam.mouseDown( event.getPos() );\n    }\n\n    void MainApp::mouseDrag( MouseEvent event ){\n      mMayaCam.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );\n    }\n    ```", "```cpp\n    void MainApp::update() {\n     float pos=math<float>::abs(sin(getElapsedSeconds()*0.5f));\n     mRepPosition = spline.getPosition( pos );\n     std::vector<Particle*>::iterator it;\n     it = mParticleSystem.particles.begin();\n     for(; it != mParticleSystem.particles.end(); ++it ) {\n      Vec3f repulsionForce = (*it)->position - mRepPosition;\n      repulsionForce = repulsionForce.normalized() *\n       math<float>::max(0.f, 3.f-repulsionForce.length());\n      (*it)->forces += repulsionForce;\n      Vec3f alignForce = (*it)->anchor - (*it)->position;\n      alignForce.limit(maxAlignSpeed);\n      (*it)->forces += alignForce;\n     }\n     mParticleSystem.update();\n    }\n    ```", "```cpp\n    void MainApp::draw() {\n     gl::enableDepthRead();\n     gl::enableDepthWrite();\n     gl::clear( Color::white() );\n     gl::setViewport(getWindowBounds());\n     gl::setMatrices(mMayaCam.getCamera());\n     gl::color(Color(1.f,0.f,0.f));\n     gl::drawSphere(mRepPosition, 0.25f);\n     mParticleSystem.draw();\n    }\n    ```"]