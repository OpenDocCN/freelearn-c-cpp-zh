- en: Chapter 3. Implementing Client Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 实现客户端应用
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Implementing a synchronous TCP client
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现同步TCP客户端
- en: Implementing a synchronous UDP client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现同步UDP客户端
- en: Implementing an asynchronous TCP client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步TCP客户端
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A **client** is a part of a distributed application that communicates with another
    part of this application called a **server**, in order to consume services it
    provides. The server, on the other hand, is a part of distributed application
    that passively waits for requests arriving from clients. When a request arrives,
    the server performs the requested operation and sends a response—the result of
    the operation—back to the client.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**是分布式应用的一部分，它通过与其他应用部分（称为**服务器**）通信来消费它提供的服务。另一方面，服务器是分布式应用的一部分，它被动地等待来自客户端的请求。当请求到达时，服务器执行请求的操作，并将操作结果作为响应发送回客户端。'
- en: The key characteristic of a client is that it needs a service provided by the
    server and it initiates the communication session with that server in order to
    consume the service. The key characteristic of the server is that it serves the
    requests coming from the clients by providing a requested service.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的关键特征是它需要服务器提供的服务，并且它需要与该服务器建立通信会话以消费该服务。服务器的关键特征是它通过提供请求的服务来响应来自客户端的请求。
- en: We'll consider servers in the next chapter. In this chapter, we are going to
    focus on client applications and will consider several types of them in detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中考虑服务器。在这一章中，我们将专注于客户端应用，并将详细考虑几种类型。
- en: The classification of client applications
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端应用的分类
- en: Client applications can be classified by the transport layer protocol they use
    for communication with the server. If the client uses a UDP protocol, it is called
    a **UDP client**. If it uses a TCP protocol, it is called a **TCP client** correspondingly.
    Of course, there are many other transport layer protocols that client applications
    may use for communication. Moreover, there are multiprotocol clients that can
    communicate over several protocols. However, they are beyond the scope of this
    book. In this chapter, we are going to focus on pure UDP and TCP clients as such,
    which are the most popular and are the most often used in general purpose software
    today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用可以根据它们与服务器通信所使用的传输层协议进行分类。如果客户端使用UDP协议，则称为**UDP客户端**。如果它使用TCP协议，则相应地称为**TCP客户端**。当然，还有许多其他传输层协议，客户端应用可能用于通信。此外，还有多协议客户端，可以在多个协议上通信。然而，这些超出了本书的范围。在这一章中，我们将专注于纯UDP和TCP客户端，因为它们是最受欢迎的，并且在今天的通用软件中是最常用的。
- en: The decision as to which transport layer protocol to choose for communication
    between the parts of a distributed application should be made at the early stages
    of the application design based on the application specification. Because TCP
    and UDP protocols are conceptually different, it may be quite difficult to switch
    from one of them to another at the later stages of the application development
    process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在分布式应用的部分之间选择哪种传输层协议进行通信的决定，应在应用设计的早期阶段基于应用规范做出。因为TCP和UDP协议在概念上不同，所以在应用开发过程的后期阶段从其中一个切换到另一个可能会相当困难。
- en: Another way to classify client applications is according to whether the client
    is synchronous or asynchronous. A **synchronous client application** uses synchronous
    socket API calls that block the thread of execution until the requested operation
    is completed, or an error occurs. Thus, a typical synchronous TCP client would
    use the `asio::ip::tcp::socket::write_some()` method or the `asio::write()` free
    function to send a request to the sever and then use the `asio::ip::tcp::socket::read_some()`
    method or the `asio::read()` free function to receive a response. These methods
    and functions are blocking, which makes the client synchronous.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种根据客户端是同步还是异步来分类客户端应用的方法。**同步客户端应用**使用同步套接字API调用，这些调用会阻塞执行线程，直到请求的操作完成或发生错误。因此，一个典型的同步TCP客户端会使用`asio::ip::tcp::socket::write_some()`方法或`asio::write()`免费函数向服务器发送请求，然后使用`asio::ip::tcp::socket::read_some()`方法或`asio::read()`免费函数接收响应。这些方法和函数是阻塞的，这使得客户端是同步的。
- en: An **asynchronous client application** as opposed to a synchronous one uses
    asynchronous socket API calls. For example, an asynchronous TCP client may use
    the `asio::ip::tcp::socket::async_write_some()` method or the `asio::async_write()`
    free function to send a request to the server and then use the `asio::ip::tcp::socket::async_read_some()`
    method or the `asio::async_read()` free function to asynchronously receive a response.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步客户端应用相对的是，异步客户端应用使用异步套接字API调用。例如，异步TCP客户端可能使用`asio::ip::tcp::socket::async_write_some()`方法或`asio::async_write()`免费函数向服务器发送请求，然后使用`asio::ip::tcp::socket::async_read_some()`方法或`asio::async_read()`免费函数异步接收响应。
- en: Because the structure of a synchronous client significantly differs from that
    of an asynchronous one, the decision as to which approach to apply should be made
    early at the application design stage, and this decision should be based on the
    careful analysis of the application requirements. Besides, possible application
    evolution paths and new requirements that may appear in the future should be considered
    and taken into account.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同步客户端的结构与异步客户端的结构显著不同，因此关于应用哪种方法的决策应在应用设计阶段尽早做出，并且这个决策应基于对应用要求的仔细分析。此外，还应考虑可能的应用演变路径和未来可能出现的新要求。
- en: Synchronous versus asynchronous
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步与异步
- en: As usually, each approach has its advantages and disadvantages. When a synchronous
    approach gives better results in one situation, it may be absolutely unacceptable
    in another. In the latter case, an asynchronous approach should be used. Let's
    compare two approaches to better understand when it is more beneficial to use
    each of them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，每种方法都有其优缺点。当同步方法在某种情况下给出更好的结果时，在另一种情况下可能完全不可接受。在后一种情况下，应使用异步方法。让我们比较两种方法，以更好地理解在什么情况下使用每种方法更有利。
- en: The main advantage of a synchronous approach is its *simplicity*. A synchronous
    client is significantly easier to develop, debug, and support than a functionally
    equal asynchronous one. Asynchronous clients are more complex due to the fact
    that asynchronous operations that are used by them complete in other places in
    code (mainly in callbacks) than they are initiated. Usually, this requires allocating
    additional data structures in the free memory to keep the context of the request
    and callback functions, and also involves thread synchronization and other extras
    that may make the application structure quite complex and error-prone. Most of
    these extras are not required in synchronous clients. Besides, the asynchronous
    approach brings in additional computational and memory overhead, which makes it
    less efficient than a synchronous one in some conditions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同步方法的主要优势是其*简单性*。与功能上相等的异步客户端相比，同步客户端的开发、调试和支持要容易得多。由于异步客户端使用的异步操作在代码的其他地方（主要是在回调中）完成，而不是在它们开始的地方，因此异步客户端更复杂。通常，这需要在空闲内存中分配额外的数据结构来保持请求和回调函数的上下文，还涉及到线程同步和其他可能使应用程序结构相当复杂且容易出错的额外操作。大多数这些额外操作在同步客户端中都不是必需的。此外，异步方法引入了额外的计算和内存开销，在某些条件下使其不如同步方法高效。
- en: However, the synchronous approach has some functional limitations, which often
    make this approach unacceptable. These limitations consist of the inability to
    cancel a synchronous operation after it has started, or to assign it a timeout
    so that it gets interrupted if it is running longer than a certain amount of time.
    As opposed to synchronous operations, asynchronous ones can be canceled at any
    moment after operation initiation and before the moment it completes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同步方法有一些功能限制，这通常使得这种方法不可接受。这些限制包括在操作开始后无法取消同步操作，或无法为其设置超时，以便在运行时间超过一定时间后中断。与同步操作相反，异步操作可以在操作开始后的任何时刻取消，直到操作完成之前。
- en: Imagine a typical modern web browser. A request cancellation is a very important
    feature of a client application of this kind. After issuing a command to load
    a particular website, the user may change his or her mind and decide to cancel
    the command before the page gets loaded. From the user's perspective, it would
    be quite strange not to be able to cancel the command until the page gets fully
    loaded. Therefore, this is when a synchronous approach is not a good option.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个典型的现代网络浏览器。请求取消是一个客户端应用程序的重要功能。在发出加载特定网站的命令后，用户可能会改变主意并决定在页面加载完成之前取消命令。从用户的角度来看，如果不能在页面完全加载之前取消命令，将会非常奇怪。因此，在这种情况下，同步方法不是一个好的选择。
- en: Besides the difference in the complexity and functionality described above,
    the two approaches differ in efficiency when it comes to running several requests
    in parallel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述复杂性和功能上的差异之外，这两种方法在并行运行多个请求时的效率也有所不同。
- en: Imagine that we are developing a web crawler, an application that traverses
    the pages of websites and processes them in order to extract some interesting
    information. Given a file with a long list of websites (say several millions),
    the application should traverse all the pages of each of the sites listed in the
    file and then process each page. Naturally, one of the key requirements of the
    application is to perform the task as fast as possible. Provided with these requirements,
    which approach should we choose, synchronous or asynchronous?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们正在开发一个网络爬虫，这是一个遍历网站页面并处理它们以提取一些有趣信息的应用程序。给定一个包含大量网站（比如说几百万个）的文件，应用程序应该遍历文件中列出的每个网站的页面，然后处理每个页面。自然地，该应用程序的一个关键要求是尽可能快地完成任务。考虑到这些要求，我们应该选择哪种方法，同步还是异步？
- en: 'Before we answer this question, let''s consider the stages of a request life
    cycle and their timings from the client application''s perspective. Conceptually,
    the request life cycle consists of five stages as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回答这个问题之前，让我们从客户端应用程序的角度考虑请求生命周期的各个阶段及其时间。从概念上讲，请求生命周期由以下五个阶段组成：
- en: '**Preparing the request**: This stage involves any operations required to prepare
    a request message. The duration of this step depends on the particular problem
    the application solves. In our example, this could be reading the next website
    address from the input file and constructing a string representing a request in
    accordance with an HTTP protocol.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备请求**：此阶段涉及准备请求消息所需的任何操作。这一步骤的持续时间取决于应用程序解决的特定问题。在我们的例子中，这可能是从输入文件中读取下一个网站地址并构建一个符合HTTP协议的请求字符串。'
- en: '**Transmitting a request from the client to the server**: This stage assumes
    the transmission of the request data from the client to the server over the network.
    The duration of this step does not depend on a client application. It depends
    on the properties and the current state of the network.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从客户端向服务器发送请求**：此阶段假设请求数据通过网络从客户端传输到服务器。这一步骤的持续时间不依赖于客户端应用程序。它取决于网络的特性和当前状态。'
- en: '**Processing the request by the server**: The duration of this step depends
    on the server''s properties and its current load. In our example, the server application
    is a web server and the request processing lies in constructing a requested web
    page, which may involve I/O operations such as reading files and loading data
    from a database.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器处理请求**：这一步骤的持续时间取决于服务器的特性和其当前负载。在我们的例子中，服务器应用程序是一个网络服务器，请求处理包括构建请求的网页，这可能涉及I/O操作，如读取文件和从数据库加载数据。'
- en: '**Transmitting a response from the server to the client**: Like stage 2, this
    stage also assumes the transmission of the data over the network; however, this
    time it is in the opposite direction—from the server to the client. The duration
    of this stage does not depend on the client or the server. It only depends on
    the properties and the state of the network.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从服务器向客户端发送响应**：与第2阶段类似，此阶段也假设通过网络传输数据；然而，这次方向相反——从服务器到客户端。这一阶段的持续时间不依赖于客户端或服务器。它只取决于网络的特性和状态。'
- en: '**Processing the response by the client**: The duration of this stage depends
    on a particular task that the client application is intended to perform. In our
    example, this could be scanning the web page, extracting interesting information
    and storing it into a database.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端处理响应**：这一阶段的时间取决于客户端应用程序打算执行的具体任务。在我们的例子中，这可能是扫描网页，提取有趣的信息并将其存储到数据库中。'
- en: Note that, for the sake of simplicity, we omitted low-level substages such as
    connection establishment and connection shutdown, which are important when using
    TCP protocol but don't add a substantial value in our conceptual model of a request
    life cycle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了简化，我们省略了如连接建立和连接关闭等低级子阶段，这些在使用TCP协议时很重要，但对我们请求生命周期概念模型中的实质性价值不大。
- en: As we can see, only in stages 1 and 5 does the client perform some effective
    job related to the request. Having initiated the transmission of the request data
    at the end of stage 1, the client has to wait during the next three stages (2,
    3, and 4) of the request life cycle before it can receive the response and process
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，只有在第1和第5阶段，客户端才会执行与请求相关的有效工作。在第一阶段结束时启动了请求数据的传输后，客户端必须等待请求生命周期的下一个三个阶段（第2、第3和第4阶段）才能接收响应并处理它。
- en: Now, with the stages of the request life cycle in mind, let's see what happens
    when we apply synchronous and asynchronous approaches to implement our sample
    web crawler.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们带着请求生命周期的各个阶段在心中，看看当我们应用同步和异步方法来实现我们的示例网络爬虫时会发生什么。
- en: If we apply a synchronous approach, the thread of execution processing a single
    request synchronously will be sleeping during stages 2-4 of the request life cycle,
    and only during stages 1 and 5, will it perform an effective job (for simplicity,
    we assume that stages 1 and 5 don't include instructions that block the thread).
    This means that the resource of an operating system, namely a thread, is used
    inefficiently, because there are number of times when it is simply doing nothing
    while there is still a lot of work available—millions of other pages to request
    and process. In this situation, an asynchronous approach seems to be more efficient.
    With an asynchronous approach, instead of a thread being blocked during stages
    2-4 of a request life cycle, it can be effectively used to perform stages 1 or
    5 of another request.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用同步方法，处理单个请求的执行线程将在请求生命周期的第2-4阶段处于休眠状态，只有在第1和第5阶段，它才会执行有效的工作（为了简化，我们假设第1和第5阶段不包括会阻塞线程的指令）。这意味着操作系统的资源，即线程，被使用得不够高效，因为在很多情况下，它只是在无所事事，而此时还有很多工作要做——数百万个其他页面需要请求和处理。在这种情况下，异步方法似乎更有效率。采用异步方法，线程在请求生命周期的第2-4阶段不会阻塞，它可以有效地用于执行另一个请求的第1或第5阶段。
- en: Thus, we direct a single thread to process the different stages of different
    requests (this is called **overlapping**), which results in the more efficient
    usage of a thread and consequently increases the overall performance of the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们指导单个线程处理不同请求的不同阶段（这被称为**重叠**），这导致线程使用得更加高效，从而提高了应用程序的整体性能。
- en: However, an asynchronous approach is not always more efficient than a synchronous
    one. As it has been mentioned, asynchronous operations imply additional computational
    overheads, which means that the overall duration of an asynchronous operation
    (from initiation till completion) is somewhat bigger than the equivalent synchronous
    one. This means that, if the average total duration of stages 2-4 is less than
    the overhead of the timing asynchronous approach per single request, then a synchronous
    approach turns out to be more efficient, and therefore may be considered to be
    the right way to go.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步方法并不总是比同步方法更有效率。正如所提到的，异步操作意味着额外的计算开销，这意味着异步操作的整体持续时间（从开始到完成）略大于等效的同步操作。这意味着，如果第2-4阶段的平均总持续时间小于异步方法每个请求的时延开销，那么同步方法就变得更为高效，因此可能被认为是正确的选择。
- en: Assessing the total duration of stages 2-4 of the request life cycle and the
    overhead of the asynchronous approach is usually done experimentally. The duration
    may significantly vary, and it depends on the properties and the state of the
    network through which the requests and responses are transmitted and also on the
    properties and the load level of the server application that serves the request.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 评估请求生命周期阶段 2-4 的总持续时间以及异步方法的开销通常是通过实验来完成的。持续时间可能会有显著差异，这取决于请求和响应传输的网络属性和状态，以及服务请求的服务器应用程序的属性和负载级别。
- en: The sample protocol
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例协议
- en: 'In this chapter, we are going to consider three recipes, each of which demonstrates
    how to implement a particular type of a client application: the synchronous UDP
    client, synchronous TCP client, and asynchronous TCP client. In all the recipes,
    it is assumed that the client application communicates with the server application
    using the following simple application-level protocol.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑三个配方，每个配方都演示了如何实现特定类型的客户端应用程序：同步 UDP 客户端、同步 TCP 客户端和异步 TCP 客户端。在所有配方中，假设客户端应用程序使用以下简单的应用层协议与服务器应用程序通信。
- en: 'The server application accepts a request represented as an ASCII string. The
    string has the following format:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序接受一个表示为 ASCII 字符串的请求。该字符串具有以下格式：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where `[s]` is a positive integer value and `<LF>` is ASCII a new-line symbol.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `[s]` 是一个正整数值，`<LF>` 是 ASCII 换行符。
- en: 'The server interprets this string as a request to perform a dummy operation
    that lasts for `[s]` seconds. For example, a request string may look as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将此字符串解释为执行持续 `[s]` 秒的虚拟操作请求。例如，请求字符串可能如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that the client sending this request wants the server to perform
    the dummy operation for `10` seconds and then send a response to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着发送此请求的客户端希望服务器执行持续 `10` 秒的虚拟操作，然后向它发送响应。
- en: Like the request, the response returned by the server is represented by an ASCII
    string. It may either be `OK<LF>` if the operation completes successfully or `ERROR<LF>`
    if the operation fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求一样，服务器返回的响应由一个 ASCII 字符串表示。它可以是 `OK<LF>`，如果操作成功完成，或者 `ERROR<LF>`，如果操作失败。
- en: Implementing a synchronous TCP client
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现同步 TCP 客户端
- en: 'A synchronous TCP client is a part of a distributed application that complies
    with the following statements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同步 TCP 客户端是符合以下声明的分布式应用程序的一部分：
- en: Acts as a client in the client-server communication model
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端-服务器通信模型中充当客户端
- en: Communicates with the server application using a TCP protocol
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TCP 协议与服务器应用程序通信
- en: Uses I/O and control operations (at least those I/O operations that are related
    to communication with a server) that block the thread of execution until the corresponding
    operation completes, or an error occurs
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 I/O 和控制操作（至少是那些与服务器通信相关的 I/O 操作），这些操作会阻塞执行线程，直到相应的操作完成或发生错误
- en: 'A typical synchronous TCP client works according to the following algorithm:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的同步 TCP 客户端按照以下算法工作：
- en: Obtain the IP-address and the protocol port number of the server application.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器应用程序的 IP 地址和协议端口号。
- en: Allocate an active socket.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个活动套接字。
- en: Establish a connection with the server application.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与服务器应用程序建立连接。
- en: Exchange messages with the server.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与服务器交换消息。
- en: Shut down the connection.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭连接。
- en: Deallocate the socket.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放套接字。
- en: This recipe demonstrates how to implement a synchronous TCP client application
    with Boost.Asio.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方演示了如何使用 Boost.Asio 实现同步 TCP 客户端应用程序。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code sample demonstrates a possible implementation of a synchronous
    TCP client application with Boost.Asio. The client uses the application layer
    protocol described in the introduction section of this chapter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了使用 Boost.Asio 实现同步 TCP 客户端应用程序的可能实现。客户端使用本章引言部分中描述的应用层协议：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The sample client application consists of two main components—the `SyncTCPClient`
    class and the application entry point function `main()` in which the `SyncTCPClient`
    class is used to communicate with the server application. Let's consider each
    component separately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例客户端应用程序由两个主要组件组成——`SyncTCPClient` 类和应用程序入口点函数 `main()`，其中 `SyncTCPClient`
    类用于与服务器应用程序通信。让我们分别考虑每个组件。
- en: The SyncTCPClient class
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyncTCPClient 类
- en: The `SyncTCPClient` class is the key component in the sample. It implements
    and provides access to the communication functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncTCPClient`类是样本中的关键组件。它实现了并提供对通信功能的访问。'
- en: 'The class has three private members as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有三个私有成员如下：
- en: '`asio::io_service m_ios`: This is the object providing access to the operating
    system''s communication services, which are used by the socket object'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::io_service m_ios`: 这是提供对操作系统通信服务访问的对象，这些服务由套接字对象使用'
- en: '`asio::ip::tcp::endpoint m_ep`: This is an endpoint designating the server
    application'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::endpoint m_ep`: 这是一个指定服务器应用程序的端点'
- en: '`asio::ip::tcp::socket m_sock`: This is the socket used for communication'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::socket m_sock`: 这是用于通信的套接字'
- en: Each object of the class is intended to communicate with a single server application;
    therefore, the class's constructor accepts the server IP-address and the protocol
    port number as its arguments. These values are used to instantiate the `m_ep`
    object in the constructor's initialization list. The socket object `m_sock` is
    instantiated and opened in the constructor too.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的每个对象都旨在与单个服务器应用程序通信；因此，类的构造函数接受服务器IP地址和协议端口号作为其参数。这些值用于在构造函数的初始化列表中实例化`m_ep`对象。套接字对象`m_sock`也在构造函数中实例化和打开。
- en: The three public methods comprise the interface of the `SyncTCPClient` class.
    The first method named `connect()` is quite simple; it performs the connection
    of the socket to the server. The `close()` method shuts the connection down and
    closes the socket, which leads to the operating system's socket and other resources
    associated with it to be deallocated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 三个公共方法构成了`SyncTCPClient`类的接口。第一个名为`connect()`的方法相当简单；它执行套接字与服务器的连接。`close()`方法关闭连接并关闭套接字，这会导致操作系统中的套接字及其相关资源被释放。
- en: The third interface method is `emulateLongComputationOp(unsigned int duration_sec)`.
    This method is where the I/O operations are performed. It begins with preparing
    the request string according to the protocol. Then, the request is passed to the
    class's private method `sendRequest(const std::string& request)`, which sends
    it to the server. When the request is sent and the `sendRequest()` method returns,
    the `receiveResponse()` method is called to receive the response from the server.
    When the response is received, the `receiveResponse()` method returns the string
    containing the response. After this, the `emulateLongComputationOp()` method returns
    the response to its caller.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个接口方法是`emulateLongComputationOp(unsigned int duration_sec)`。该方法是在其中执行I/O操作的地方。它从根据协议准备请求字符串开始。然后，请求被传递到类的私有方法`sendRequest(const
    std::string& request)`，该方法将其发送到服务器。当请求发送并且`sendRequest()`方法返回时，调用`receiveResponse()`方法从服务器接收响应。当收到响应时，`receiveResponse()`方法返回包含响应的字符串。之后，`emulateLongComputationOp()`方法将响应返回给其调用者。
- en: Let's look at the `sendRequest()` and `receiveResponse()` methods in more detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`sendRequest()`和`receiveResponse()`方法。
- en: 'The `sendRequest()` method has the following prototype:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendRequest()`方法具有以下原型：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Its purpose is to send a string, passed to it as an argument, to the server.
    In order to send the data to the server, the `asio::write()` free synchronous
    function is used. The function returns when the request is sent. That's it about
    the `sendRequest()` method. Basically, all it does is, it fully delegates its
    job to the `asio::write()` free function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的是将作为参数传递给它的字符串发送到服务器。为了将数据发送到服务器，使用了`asio::write()`免费同步函数。函数在请求发送后返回。这就是`sendRequest()`方法的所有内容。基本上，它所做的只是，完全委托其工作给`asio::write()`免费函数。
- en: 'Having sent the request, now we want to receive the response from the server.
    This is the purpose of the `receiveResponse()` method of the `SyncTCPClient` class.
    To perform its job, method uses the `asio::read_until()` free function. According
    to the application layer protocol, the response message sent by the server may
    vary in length, but must end with the `\n` symbol; therefore, we specify this
    symbol as a delimiter when calling the function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求后，我们现在想从服务器接收响应。这是`SyncTCPClient`类的`receiveResponse()`方法的目的。为了执行其工作，该方法使用`asio::read_until()`免费函数。根据应用层协议，服务器发送的响应消息的长度可能不同，但必须以`\n`符号结束；因此，我们在调用函数时指定此符号作为分隔符：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function blocks the thread of execution until it encounters the `\n` symbol
    as a part of the message that arrived from the server. When the function returns,
    the stream buffer `buf` contains the response. The data is then copied from the
    `buf` buffer to the `response` string and the latter is returned to the caller.
    The `emulateLongComputationOp()` method in turn returns the response to its caller—the
    `main()` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数阻塞执行线程，直到遇到来自服务器的消息中的`\n`符号。当函数返回时，流缓冲区`buf`包含响应。然后将数据从`buf`缓冲区复制到`response`字符串，并将后者返回给调用者。`emulateLongComputationOp()`方法随后将响应返回给其调用者——`main()`函数。
- en: One thing to note with regard to the `SyncTCPClient` class is that it contains
    no error handling-related code. That's because the class uses only those overloads
    of Boost.Asio functions and objects' methods that throw exceptions in case of
    failure. It is assumed that the user of the class is responsible for catching
    and handling the exceptions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SyncTCPClient`类需要注意的一点是，它不包含与错误处理相关的代码。这是因为该类仅使用那些在失败时抛出异常的Boost.Asio函数和对象方法的重载。假设类的用户负责捕获和处理异常。
- en: The main() entry point function
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main()`入口点函数'
- en: This function acts as a user of the `SyncTCPClient` class. Having obtained the
    server IP-address and the protocol port number (this part is omitted from the
    sample), it instantiates and uses an object of the `SyncTCPClient` class to communicate
    with the server in order to consume its service, mainly to emulate an operation
    on the server that performs dummy calculations for 10 seconds. The code of this
    function is simple and self-explanatory and thus requires no additional comments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数作为`SyncTCPClient`类的用户。在获取服务器IP地址和协议端口号（这部分在示例中省略）后，它实例化并使用`SyncTCPClient`类的一个对象与服务器通信，以使用其服务，主要是模拟在服务器上执行10秒的虚拟计算操作。此函数的代码简单且易于理解，因此无需额外的注释。
- en: See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 2](ch02.html "Chapter 2. I/O Operations"), *I/O Operations*, includes
    recipes providing detailed discussions on how to perform synchronous I/O'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。I/O操作")，*I/O操作*，包括提供详细讨论如何执行同步I/O的配方'
- en: Implementing a synchronous UDP client
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现同步UDP客户端
- en: 'A synchronous UDP client is a part of a distributed application that complies
    with the following statements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同步UDP客户端是符合以下声明的分布式应用程序的一部分：
- en: Acts as a client in the client-server communication model
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端-服务器通信模型中充当客户端
- en: Communicates with the server application using UDP protocol
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UDP协议与服务器应用程序通信
- en: Uses I/O and control operations (at least those I/O operations that are related
    to communication with the server) that block the thread of execution until the
    corresponding operation completes, or an error occurs
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用I/O和控制操作（至少是那些与服务器通信相关的I/O操作）阻塞执行线程，直到相应的操作完成或发生错误
- en: 'A typical synchronous UDP client works according to the following algorithm:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的同步UDP客户端按照以下算法工作：
- en: Obtain an IP-address and a protocol port number of each server the client application
    is intended to communicate with.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取客户端应用程序打算与之通信的每个服务器的IP地址和协议端口号。
- en: Allocate a UDP socket.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个UDP套接字。
- en: Exchange messages with the servers.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与服务器交换消息。
- en: Deallocate the socket.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放套接字。
- en: This recipe demonstrates how to implement a synchronous UDP client application
    with Boost.Asio.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了如何使用Boost.Asio实现同步UDP客户端应用程序。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following code sample demonstrates a possible implementation of a synchronous
    UDP client application with Boost.Asio. It is assumed that the client uses UDP
    protocol with the underlying IPv4 protocol for communication:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了使用Boost.Asio实现同步UDP客户端应用程序的可能方法。假设客户端使用UDP协议，底层为IPv4协议进行通信：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The sample consists of two main components—the `SyncUDPClient` class and the
    application entry point function `main()` that uses the `SyncUDPClient` class
    to communicate with two server applications. Let's consider each component separately.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例由两个主要组件组成——`SyncUDPClient`类和应用程序入口点函数`main()`，后者使用`SyncUDPClient`类与两个服务器应用程序通信。让我们分别考虑每个组件。
- en: The SyncUDPClient class
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SyncUDPClient`类'
- en: The `SyncUDPClient` class is the key component in the sample. It implements
    the server communication functionality and provides access to it for the user.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncUDPClient`类是示例中的关键组件。它实现了服务器通信功能，并为用户提供访问。'
- en: 'The class has two private members as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有两个私有成员如下：
- en: '`asio::io_service m_ios`: This is the object providing access to the operating
    system''s communication services, which are used by the socket object'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::io_service m_ios`：这是提供对操作系统通信服务访问的对象，这些服务由套接字对象使用'
- en: '`asio::ip::udp::socket m_sock`: This is the UDP socket used for communication'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::udp::socket m_sock`：这是用于通信的UDP套接字'
- en: The socket object `m_sock` is instantiated and opened in the class's constructor.
    Because the client is intended to use IPv4 protocol, we pass the object returned
    by the `asio::ip::udp::v4()` static method to the socket's `open()` method to
    designate the socket to use IPv4 protocol.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_sock`套接字对象在类的构造函数中被实例化和打开。由于客户端打算使用IPv4协议，我们将`asio::ip::udp::v4()`静态方法返回的对象传递给套接字的`open()`方法，以指定套接字使用IPv4协议。'
- en: 'Because the `SyncUDPClient` class implements communication over UDP protocol,
    which is a connectionless protocol, a single object of this class can be used
    to communicate with multiple servers. The interface of the class consists of a
    single method—`emulateLongComputationOp()`. This method can be used to communicate
    with the server just after the object of the `SyncUDPClient` class is instantiated.
    The following is the prototype of the method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SyncUDPClient`类实现了基于UDP协议的通信，UDP是一种无连接协议，因此该类的一个单独对象可以用来与多个服务器通信。该类的接口由一个单一的方法组成——`emulateLongComputationOp()`。这个方法可以在`SyncUDPClient`类的对象实例化后立即用来与服务器通信。以下是这个方法的原型：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Besides the `duration_sec` argument that represents a request parameter, the
    method accepts the server IP-address and the protocol port number. This method
    may be called multiple times to communicate with different servers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示请求参数的`duration_sec`参数外，该方法还接受服务器IP地址和协议端口号。此方法可以多次调用以与不同的服务器通信。
- en: The method begins with preparing a request string according to the application
    layer protocol and creating an endpoint object designating the target server application.
    Then, the request string and the endpoint object are passed to the class's private
    method `sendRequest()`, which sends the request message to the specified server.
    When the request is sent and the `sendRequest()` method returns, the `receiveResponse()`
    method is called to receive a response from the server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先根据应用层协议准备一个请求字符串并创建一个指定目标服务器应用程序的端点对象。然后，请求字符串和端点对象被传递到类的私有方法`sendRequest()`，该方法将请求消息发送到指定的服务器。当请求发送并且`sendRequest()`方法返回时，调用`receiveResponse()`方法从服务器接收响应。
- en: 'When the response is received, the `receiveResponse()` method returns the string
    containing the response. In turn, the `emulateLongComputationOp()` method returns
    the response to its caller. The `sendRequest()` method uses the socket object''s
    `send_to()` method to send the request message to a particular server. Let''s
    have a look at the declaration of this method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '当收到响应时，`receiveResponse()`方法返回包含响应的字符串。然后，`emulateLongComputationOp()`方法将响应返回给其调用者。`sendRequest()`方法使用套接字对象的`send_to()`方法将请求消息发送到特定的服务器。让我们看看这个方法的声明： '
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method accepts a buffer containing the request and an endpoint designating
    the server to which the content of the buffer should be sent as arguments and
    blocks until the whole buffer is sent, or an error occurs. Note that, if the method
    returns without an error, it only means that the request has been sent and *does
    not* mean that the request has been received by the server. UDP protocol doesn't
    guarantee message delivery and it provides no means to check whether the datagram
    has been successfully received on the server-side or got lost somewhere on its
    way to the server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个包含请求的缓冲区和指定缓冲区内容应发送到的服务器端点的端点对象作为参数，并阻塞直到整个缓冲区发送完毕，或者发生错误。请注意，如果该方法在没有错误的情况下返回，这仅意味着请求已被发送，*并不*意味着服务器已收到请求。UDP协议不保证消息的传递，并且不提供检查数据报是否已成功在服务器端接收或在传输过程中丢失的方法。
- en: Having sent the request, now we want to receive the response from the server.
    This is the purpose of the `receiveResponse()` method of the `SyncUDPClient` class.
    This method begins with allocating a buffer that will hold the response message.
    We choose the size of the buffer such that it can fit the largest message that
    the server may send according to the application layer protocol. This message
    is an `ERROR\n` string that consists of six ASCII symbols, which is therefore
    6 bytes long; hence is the size of our buffer - 6 bytes. Because the buffer is
    small enough, we allocate it on the stack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求后，我们现在想要从服务器接收响应。这是`SyncUDPClient`类的`receiveResponse()`方法的目的。该方法首先分配一个将保存响应消息的缓冲区。我们选择缓冲区的大小，以便它可以容纳服务器根据应用层协议可能发送的最大消息；这条消息是一个由六个ASCII符号组成的`ERROR\n`字符串，因此长度为6个字节；因此，这是我们的缓冲区大小
    - 6个字节。因为缓冲区足够小，所以我们将其分配在栈上。
- en: 'To read the response data arriving from the server, we use the socket object''s
    `receive_from()` method. Here is the prototype of the method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取从服务器到达的响应数据，我们使用套接字对象的`receive_from()`方法。以下是该方法的原型：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method copies a datagram that came from the server designated by the `sender_endpoint`
    object to the buffer specified by the `buffers` argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将来自由`sender_endpoint`对象指定的服务器的数据报复制到由`buffers`参数指定的缓冲区。
- en: There are two things to note about socket object's `receive_from()` method.
    The first thing is that this method is synchronous and it blocks the thread of
    execution until the datagram arrives from the specified server. If the datagram
    never arrives (for example, gets lost somewhere on its way to the client), the
    method will never unblock and the whole application will hang. The second thing
    is that if the size of the datagram that arrives from the server is larger than
    the size of the supplied buffer, the method will fail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于套接字对象的`receive_from()`方法有两点需要注意。首先，这个方法是同步的，它会在数据报从指定的服务器到达之前阻塞执行线程。如果数据报永远不会到达（例如，在前往客户端的路上丢失），该方法将永远不会解除阻塞，整个应用程序将会挂起。其次，如果来自服务器的数据报的大小大于提供的缓冲区的大小，该方法将失败。
- en: After the response is received, the `std::string` object is created, initialized
    with a response string, and returned to the caller—the `emulateLongComputationOp()`
    method. This in turn returns the response to its caller—the `main()` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到响应后，创建一个`std::string`对象，用响应字符串初始化，并将其返回给调用者——`emulateLongComputationOp()`方法。然后，它将响应返回给其调用者——`main()`函数。
- en: The `SyncUDPClient` class does not contain error handling-related code. That's
    is because it uses only those overloads of Boost.Asio functions and objects' methods
    that throw exceptions in case of failure. It is assumed that the user of the class
    is responsible for catching and handling the exceptions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncUDPClient`类不包含错误处理相关的代码。这是因为它只使用那些在失败时抛出异常的Boost.Asio函数和对象方法的那些重载。假设类的用户负责捕获和处理异常。'
- en: The main() entry point function
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main()`入口点函数'
- en: In this function, we use the `SyncUDPClient` class in order to communicate with
    two server applications. Firstly, we obtain the IP-addresses and the port numbers
    of the target server applications. Then, we instantiate the object of the `SyncUDPClient`
    class and call the object's `emulateLongComputationOp()` method twice to synchronously
    consume the same service from two different servers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们使用`SyncUDPClient`类与两个服务器应用程序进行通信。首先，我们获取目标服务器应用程序的IP地址和端口号。然后，我们实例化`SyncUDPClient`类的对象，并调用对象的`emulateLongComputationOp()`方法两次，以同步地从两个不同的服务器消费相同的服务。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 2](ch02.html "Chapter 2. I/O Operations"), *I/O Operations*, includes
    recipes that provide detailed discussions on how to perform synchronous I/O'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。I/O操作")，*I/O操作*，包括提供详细讨论如何执行同步I/O的食谱。'
- en: Implementing an asynchronous TCP client
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步TCP客户端
- en: As it has already been mentioned in the introduction section of this chapter,
    the simplest asynchronous client is structurally more complex than equivalent
    synchronous one. When we add a feature such as request canceling to the asynchronous
    client, it becomes even more complex.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言部分所述，最简单的异步客户端在结构上比等效的同步客户端更复杂。当我们向异步客户端添加如请求取消等特性时，它变得更加复杂。
- en: 'In this recipe, we''ll consider an asynchronous TCP client application supporting
    the asynchronous execution of the requests and request canceling functionality.
    Here is the list of requirements the application will fulfill:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将考虑一个支持异步执行请求和请求取消功能的异步 TCP 客户端应用程序。以下是该应用程序将满足的要求列表：
- en: Input from the user should be processed in a separate thread—the user interface
    thread. This thread should never be blocked for a noticeable amount of time.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入应该在单独的线程中处理——用户界面线程。这个线程不应该被阻塞在明显的时间段内。
- en: The user should be able to issue multiple requests to different servers.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够向不同的服务器发出多个请求。
- en: The user should be able to issue a new request before the previously issued
    requests complete.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该在之前发出的请求完成之前能够发出新的请求。
- en: The user should be able to cancel the previously issued requests before they
    complete.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该在请求完成之前能够取消之前发出的请求。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As our application needs to support request canceling, we begin with specifying
    settings that enable request canceling on Windows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序需要支持请求取消，我们首先指定启用 Windows 上请求取消的设置：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we include the necessary headers and specify the `using` directive for
    our convenience:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们包含必要的头文件并指定方便的 `using` 指令：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We continue with defining a data type representing a pointer to a callback
    function. Because our client application is going to be asynchronous, we need
    a notion of callback as a request completion notification mechanism. Later, it
    will become clear as to why we need it and how it is used:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续定义一个表示回调函数指针的数据类型。因为我们的客户端应用程序将是异步的，我们需要一个作为请求完成通知机制的概念。稍后，我们将清楚地了解为什么需要它以及它是如何被使用的：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we define a data structure whose purpose is to keep the data related
    to a particular request while it is being executed. Let''s name it `Session`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个数据结构，其目的是在执行过程中保持与特定请求相关的数据。让我们称它为 `Session`：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The purpose of all the fields that the `Session` data structure contains will
    become clear later as we go.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Session` 数据结构包含的字段的目的将在我们继续前进时变得清晰。
- en: 'Next, we define a class that provides the asynchronous communication functionality.
    Let''s name it `AsyncTCPClient`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个提供异步通信功能的类。让我们称它为 `AsyncTCPClient`：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This class is the key component in our sample, providing most of the functionality
    of the application. This functionality is accessible to the user of the class
    through its public interface that contains three public methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是我们示例中的关键组件，提供了应用程序的大部分功能。这些功能通过类的公共接口提供给用户，该接口包含三个公共方法：
- en: '`void emulateLongComputationOp(unsigned int duration_sec, const std::string&
    raw_ip_address, unsigned short port_num, Callback callback, unsigned int request_id)`:
    This method initiates a request to the server'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void emulateLongComputationOp(unsigned int duration_sec, const std::string&
    raw_ip_address, unsigned short port_num, Callback callback, unsigned int request_id)`:
    这个方法向服务器发起请求'
- en: '`void cancelRequest(unsigned int request_id)`: This method cancels the previously
    initiated request designated by the `request_id` argument'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void cancelRequest(unsigned int request_id)`: 这个方法取消由 `request_id` 参数指定的先前启动的请求'
- en: '`void close()`: This method blocks the calling thread until all the currently
    running requests complete and deinitializes the client. When this method returns,
    the corresponding instance of the `AsyncTCPClient` class can''t be used anymore.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void close()`: 这个方法阻塞调用线程，直到所有当前正在运行的任务完成，并初始化客户端。当这个方法返回时，`AsyncTCPClient`
    类的相应实例不能再使用。'
- en: 'Now, we define a function that will serve as a callback, which we''ll pass
    to the `AsyncTCPClient::emulateLongComputationOp()` method. In our case, this
    function is quite simple. It outputs the result of the request execution and the
    response message to the standard output stream if the request is completed successfully:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个将作为回调函数使用的函数，我们将将其传递给 `AsyncTCPClient::emulateLongComputationOp()`
    方法。在我们的情况下，这个函数相当简单。如果请求成功完成，它将输出请求执行的结果和响应消息到标准输出流：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `handler()` function's signature corresponds to the function pointer type
    `Callback` defined earlier.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler()` 函数的签名对应于之前定义的函数指针类型 `Callback`。'
- en: 'Now that we have all the ingredients, we define an entry point of the application—the
    `main()` function—which demonstrates how to use the components defined above in
    order to communicate with the server. In our sample function, `main()` emulates
    the behavior of a human user by initiating three requests and canceling one of
    them:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的组件，我们定义了应用程序的入口点——`main()`函数，该函数展示了如何使用上面定义的组件与服务器进行通信。在我们的示例函数中，`main()`通过初始化三个请求并取消其中一个来模拟人类用户的行为：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Our sample client application uses two threads of execution. The first one—UI
    thread—is responsible for processing a user input and initiating requests. The
    responsibility of the second thread—I/O thread—is to run the event loop and call
    the asynchronous operation's callback routines. Such configuration allows us to
    make our application's user interface responsive.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例客户端应用程序使用两个执行线程。第一个线程——UI线程——负责处理用户输入和初始化请求。第二个线程——I/O线程——负责运行事件循环并调用异步操作的回调例程。这种配置使我们能够使我们的应用程序的用户界面保持响应。
- en: Starting the application – the main() entry point function
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动应用程序 – `main()`入口点函数
- en: The `main()` function is invoked in the context of the UI thread. This function
    emulates the behavior of the user who initiates and cancels requests. Firstly,
    it creates an instance of the `AsyncTCPClient` class and then calls its `emulateLongComputationOp()`
    method three times to initiate three asynchronous requests, each time specifying
    a different target server. The first request (the one assigned ID 1) is canceled
    by calling the `cancelRequest()`method several seconds after the request has been
    initiated.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数在UI线程的上下文中被调用。此函数模拟了发起和取消请求的用户的行为。首先，它创建`AsyncTCPClient`类的实例，然后调用其`emulateLongComputationOp()`方法三次以初始化三个异步请求，每次指定不同的目标服务器。第一个请求（分配ID为1的请求）在请求初始化几秒钟后通过调用`cancelRequest()`方法被取消。'
- en: Request completion – the handler() callback function
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求完成 – `handler()`回调函数
- en: 'For all three requests initiated in the `main()` function `handler()` is specified
    as a callback. This function is called when the request is finished regardless
    of the reason as to why it finished—be it a successful completion or an error.
    Also, this function is called when the request is canceled by the user. The function
    accepts three arguments as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中初始化的所有三个请求，`handler()`都被指定为回调函数。无论请求完成的原因是什么——无论是成功完成还是出现错误——该函数都会被调用。此外，当请求被用户取消时，该函数也会被调用。该函数接受以下三个参数：
- en: '`unsigned int request_id`: This contains the unique identifier of the request.
    This is the same identifier that was assigned to the request when it was initiated.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int request_id`：这包含请求的唯一标识符。这是在请求初始化时分配给请求的相同标识符。'
- en: '`std::string& response`: This contains the response data. This value is considered
    valid only if the request is completed successfully and is not canceled.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string& response`：这包含响应数据。此值仅在请求成功完成且未被取消时才被认为是有效的。'
- en: '`system::error_code& ec`: If an error occurs during a request life cycle, this
    object contains the error information. If the request was canceled, it contains
    the `asio::error::operation_aborted` value.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system::error_code& ec`：如果在请求的生命周期中发生错误，此对象包含错误信息。如果请求被取消，它包含`asio::error::operation_aborted`值。'
- en: The `handler()` function is quite simple in our sample. Based on the values
    of the parameters passed to it, it outputs information about the finished request.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`handler()`函数相当简单。根据传递给它的参数的值，它输出有关已完成请求的信息。
- en: The AsyncTCPClient class – initializing
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AsyncTCPClient类 – 初始化
- en: As it has already been mentioned, all the functionality related to communication
    with the server application is hidden in the `AsyncTCPClient` class. This class
    has a nonempty constructor that accepts no arguments and does two things. Firstly,
    it instantiates an object of the `asio::io_service::work` class passing an instance
    of the `asio::io_service` class named `m_ios` to its constructor. Then, it spawns
    a thread that calls the `run()` method of the `m_ios` object. The object of the
    `asio::io_service::work` class keeps threads running event loop from exiting this
    loop when there are no pending asynchronous operations. The spawned thread plays
    the role of I/O thread in our application; in the context of this thread, the
    callbacks assigned asynchronous operations will be invoked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经提到的，所有与服务器应用程序通信的功能都隐藏在`AsyncTCPClient`类中。这个类有一个不接受任何参数的非空构造函数，执行两个操作。首先，它通过将名为`m_ios`的`asio::io_service`类实例传递给其构造函数来实例化`asio::io_service::work`类的对象。然后，它启动一个线程，该线程调用`m_ios`对象的`run()`方法。`asio::io_service::work`类的对象保持线程运行的事件循环，在没有挂起的异步操作时防止事件循环退出。启动的线程在我们的应用程序中扮演I/O线程的角色；在这个线程的上下文中，分配给异步操作的回调将被调用。
- en: The AsyncTCPClient class – initiating a request
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`AsyncTCPClient`类 – 启动请求'
- en: The `emulateLongComputationOp()` method is intended to initiate an asynchronous
    request. It accepts five arguments. The first one named `duration_sec` represents
    the request parameter according to the application layer protocol. The `raw_ip_address`
    and `port_num` specify the server to which the request should be sent. The next
    argument is a pointer to a callback function, which will be called when the request
    is complete. We'll turn back to the discussion of the callback later in this section.
    The last argument `request_id` is the unique identifier of the request. This identifier
    is associated with the request and is used to refer to it later, for example,
    when there is a need to cancel it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`emulateLongComputationOp()`方法旨在启动一个异步请求。它接受五个参数。第一个参数名为`duration_sec`，表示根据应用层协议的请求参数。`raw_ip_address`和`port_num`指定了请求应该发送到的服务器。下一个参数是一个指向回调函数的指针，当请求完成时将被调用。我们将在本节稍后讨论回调。最后一个参数`request_id`是请求的唯一标识符。此标识符与请求相关联，并在以后引用它时使用，例如，当需要取消它时。'
- en: The `emulateLongComputationOp()` method begins with preparing a request string
    and allocating an instance of the `Session` structure that keeps the data associated
    with the request including a socket object that is used to communicate with the
    server.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`emulateLongComputationOp()`方法从准备请求字符串和分配一个`Session`结构实例开始，该实例保留与请求相关的数据，包括用于与服务器通信的套接字对象。'
- en: Then, the socket is opened and the pointer to the `Session` object is added
    to the `m_active_sessions` map. This map contains pointers to the `Session` objects
    associated with all active requests, that is, those requests that have been initiated
    but have not finished yet. When the request completes, before the corresponding
    callback is called, the pointer to the `Session` object associated with this request
    is removed from the map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开套接字并将指向`Session`对象的指针添加到`m_active_sessions`映射中。这个映射包含指向所有活动请求的`Session`对象的指针，即那些已经发起但尚未完成的请求。当请求完成时，在调用相应的回调之前，与该请求关联的`Session`对象的指针将从映射中移除。
- en: The `request_id` argument is used as a key of the corresponding `Session` object
    added to the map. We need to cache the `Session` objects in order to have access
    to them in case the user decides to cancel the previously initiated request. If
    we would not need to support canceling of a request, we could avoid using the
    `m_active_sessions` map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_id`参数用作添加到映射中的相应`Session`对象的键。我们需要缓存`Session`对象，以便在用户决定取消先前发起的请求时能够访问它们。如果我们不需要支持请求的取消，我们可以避免使用`m_active_sessions`映射。'
- en: We synchronize the access to the `m_active_sessions` map with a `m_active_session_guard`
    mutex. Synchronization is necessary because the map can be accessed from multiple
    threads. Items are added to it in UI thread, and removed in an I/O thread that
    calls a callback when the corresponding request is finished.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`m_active_session_guard`互斥锁来同步对`m_active_sessions`映射的访问。同步是必要的，因为映射可以从多个线程访问。项目在UI线程中添加，在调用回调的I/O线程中移除，当相应的请求完成时。
- en: 'Now, when the pointer to the corresponding `Session` object is cached, we need
    to connect the socket to the server, which we do by calling the socket''s `async_connect()`
    method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当相应的`Session`对象的指针被缓存时，我们需要通过调用socket的`async_connect()`方法将socket连接到服务器：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An endpoint object designating the server to which we want to connect and a
    callback function to be called when the connection is complete or an error occurs,
    are passed as arguments to this method. In our sample we use lambda function as
    a callback function. The call to the socket's `async_connect()` method is the
    last statement in the `emulateLongComputationOp()` method. When `async_connect()`
    returns, `emulateLongComputationOp()` returns too, which means that the request
    has been initiated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定我们想要连接的服务器的端点对象和当连接完成或发生错误时将被调用的回调函数作为参数传递给此方法。在我们的示例中，我们使用lambda函数作为回调函数。`emulateLongComputationOp()`方法中的最后一条语句是对socket的`async_connect()`方法的调用。当`async_connect()`返回时，`emulateLongComputationOp()`也会返回，这意味着请求已经被发起。
- en: 'Let''s have a closer look at the lambda function that we pass to `async_connect()`
    as a callback. Here is its code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们传递给`async_connect()`作为回调的lambda函数。以下是它的代码：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The callback begins with checking the error code passed to it as the `ec` argument,
    the value of which when different from zero means that the corresponding asynchronous
    operation has failed. In case of failure, we store the `ec` value in the corresponding
    `Session` object, call the class's `onRequestComplete()` private method passing
    the `Session` object to it as an argument, and then return.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数首先检查传递给它的`ec`参数的错误代码，其值如果不同于零，则表示相应的异步操作已失败。在失败的情况下，我们将`ec`值存储在相应的`Session`对象中，调用类的`onRequestComplete()`私有方法，并将`Session`对象作为参数传递给它，然后返回。
- en: If the `ec` object designates success, we lock the `m_cancel_guard` mutex (the
    member of the request descriptor object) and check whether the request has not
    been canceled yet. More details about the canceling request are provided later
    in this section, where the `cancelRequest()` method is considered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ec`对象指定成功，我们锁定`m_cancel_guard`互斥锁（请求描述符对象的成员）并检查请求是否尚未被取消。关于取消请求的更多详细信息将在本节后面的`cancelRequest()`方法中提供。
- en: 'If we see that the request has not been canceled, we initiate the next asynchronous
    operation calling the Boost.Asio free function `async_write()` to send the request
    data to the server. Again, we pass to it a lambda function as a callback. This
    callback is very similar to the one passed to the `anync_connect()` method when
    the asynchronous connection operation was initiated. We first check the error
    code and then if it indicates success, we check whether or not the request has
    been canceled. Also, if it has not, we initiate the next asynchronous operation—`async_read_until()`—in
    order to receive a response from the server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到请求尚未被取消，我们将通过调用Boost.Asio自由函数`async_write()`来发送请求数据到服务器，从而启动下一个异步操作。再次，我们传递给它一个lambda函数作为回调。这个回调与在异步连接操作启动时传递给`anync_connect()`方法的回调非常相似。我们首先检查错误代码，然后如果它指示成功，我们检查请求是否已被取消。如果没有，我们启动下一个异步操作`async_read_until()`，以便从服务器接收响应：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, we pass a lambda function as a callback argument to the `async_read_until()`
    free function. This callback function is quite simple:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将一个lambda函数作为回调参数传递给`async_read_until()`自由函数。这个回调函数相当简单：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It checks the error code and in the case of success, it stores the received
    response data in the corresponding `Session` object. Then, the `AsyncTCPClient`
    class's private method `onRequestComplete()` is called and the `Session` object
    is passed to it as an argument.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查错误代码，在成功的情况下，将接收到的响应数据存储在相应的`Session`对象中。然后，调用`AsyncTCPClient`类的私有方法`onRequestComplete()`，并将`Session`对象作为参数传递给它。
- en: The `onRequestComplete()` method is called whenever the request completes with
    any result. It is called when the request completes successfully, when the request
    fails at any stage of its life cycle, or when it is canceled by the user. The
    purpose of this method is to perform a cleanup and then to call a callback provided
    by the caller of the `emulateLongComputationOp()` method, when initiating this
    request.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRequestComplete()`方法在请求完成时被调用，无论结果如何。它在请求成功完成时被调用，在请求在其生命周期的任何阶段失败时被调用，或者当它被用户取消时被调用。此方法的目的是在执行清理操作后，调用`emulateLongComputationOp()`方法的调用者提供的回调。'
- en: The `onRequestComplete()` method begins with shutting down the socket. Note
    that here we use the overload of the socket's `shutdown()` method, which doesn't
    throw exceptions. We don't care if the shutting down of the connection fails as
    this is not a critical operation in our case. Then, we remove the corresponding
    entry from the `m_active_sessions` map as the request is finished and hence it
    is not active anymore. Also, as the last step, the user supplied callback is called.
    After the callback function returns, the request life cycle is finished.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRequestComplete()` 方法首先关闭套接字。请注意，在这里我们使用套接字的 `shutdown()` 方法的重载版本，它不会抛出异常。我们不在乎连接关闭失败，因为这在我们这个场景中不是一个关键操作。然后，我们从
    `m_active_sessions` 映射中删除相应的条目，因为请求已经完成，因此它不再活跃。最后一步，调用用户提供的回调函数。在回调函数返回后，请求生命周期结束。'
- en: The AsyncTCPClient class – canceling the request
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AsyncTCPClient 类 – 取消请求
- en: Now, let's take a look at the `cancelRequst()` method of the `AsyncTCPClient`
    class. This method accepts an identifier of the request to be canceled as an argument.
    It begins with looking for the `Session` object corresponding to the specified
    request in the `m_active_sessions` map. If one is found, it calls the `cancel()`
    method on the socket object stored in this `Session` object. This leads to the
    interruption of the currently running asynchronous operation associated with this
    socket object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `AsyncTCPClient` 类的 `cancelRequest()` 方法。这个方法接受要取消的请求的标识符作为参数。它首先在
    `m_active_sessions` 映射中查找与指定请求对应的 `Session` 对象。如果找到了，它就会在这个 `Session` 对象中存储的套接字对象上调用
    `cancel()` 方法。这会导致与该套接字对象关联的当前正在运行的非阻塞操作中断。
- en: However, there is a chance that the `cancelRequest()` method will be called
    at the moment when one asynchronous operation has already been completed and the
    next one has not been initiated yet. For example, imagine that the I/O thread
    is now running the callback of the `async_connect()` operation associated with
    a particular socket. At this moment, no asynchronous operation associated with
    this socket is in progress (because the next asynchronous operation `async_write()`
    has not been initiated yet); therefore, calling `cancel()` on this socket will
    have no effect. That's why we use an additional flag `Session::m_was_cancelled`
    designating, as its name suggests, whether the request has been canceled (or to
    be more precise, whether the `cancelRequest()` method has been called by the user).
    In the callback of the asynchronous operation, we look at the value of this flag
    before initiating the next asynchronous operation. If we see that the flag is
    set (which means that the request was canceled), we don't initiate the next asynchronous
    operation, but instead we interrupt the request execution and call the `onRequestComplete()`
    method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有可能在 `cancelRequest()` 方法被调用时，一个异步操作已经完成，而下一个操作尚未开始。例如，想象一下，I/O 线程现在正在运行与特定套接字关联的
    `async_connect()` 操作的回调。在这个时候，与该套接字关联的没有正在进行的异步操作（因为下一个异步操作 `async_write()` 尚未启动）；因此，对这个套接字调用
    `cancel()` 将没有效果。这就是为什么我们使用一个额外的标志 `Session::m_was_cancelled`，正如其名称所暗示的，它表示请求是否已被取消（或者更准确地说，是否由用户调用了
    `cancelRequest()` 方法）。在异步操作的回调中，我们在启动下一个异步操作之前查看这个标志的值。如果我们看到这个标志被设置（这意味着请求已被取消），我们不会启动下一个异步操作，而是中断请求执行并调用
    `onRequestComplete()` 方法。
- en: 'We use the `Session::m_cancel_guard` mutex in the `cancelRequest()` method
    and in the callbacks of the asynchronous operations such as `async_connect()`
    and `async_write()` to enforce the following order of operations: request can
    be canceled either before the value of the `Session::m_was_cancelled` flag is
    tested in the callback, or after the next asynchronous operation is initiated.
    This order guarantees the proper canceling of a request whenever a user calls
    the `cancelRequest()` method.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cancelRequest()` 方法和异步操作（如 `async_connect()` 和 `async_write()`）的回调中，我们使用
    `Session::m_cancel_guard` 互斥锁来强制执行以下操作顺序：请求可以在回调中测试 `Session::m_was_cancelled`
    标志值之前或之后被取消。这种顺序保证了当用户调用 `cancelRequest()` 方法时，请求能够被正确取消。
- en: The AsyncTCPClient class – closing the client
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AsyncTCPClient 类 – 关闭客户端
- en: After the client has been used and is not needed anymore, it should be properly
    closed. The `close()` method of the `AsyncTCPClient` class allows us to do that.
    Firstly, this method destroys the `m_work` object that allows the I/O thread to
    exit the event message loop when all the asynchronous operations are completed.
    Then, it joins the I/O thread to wait until it exits.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端被使用且不再需要后，应该适当地关闭它。`AsyncTCPClient` 类的 `close()` 方法允许我们这样做。首先，此方法销毁 `m_work`
    对象，允许 I/O 线程在所有异步操作完成后退出事件消息循环。然后，它连接 I/O 线程以等待其退出。
- en: After the `close()` method returns, the corresponding object of the `AsyncTCPClient`
    class cannot be used anymore.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `close()` 方法返回后，`AsyncTCPClient` 类的相应对象不能再使用。
- en: There's more…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `AsyncTCPClient` class in the presented sample implements an asynchronous
    **single-threaded** TCP client. It uses a single thread that runs the event loop
    and processes the requests. Usually, when the request rate is low, the size of
    the response is not large and the request handler does not perform the complex
    and time-consuming processing of the response (stage 5 of the request life cycle);
    one thread is enough.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在所提供的示例中，`AsyncTCPClient` 类实现了一个异步的 **单线程** TCP 客户端。它使用一个线程来运行事件循环并处理请求。通常，当请求速率较低时，响应的大小不会很大，请求处理器不会执行响应的复杂和耗时处理（请求生命周期的第
    5 阶段）；一个线程就足够了。
- en: However, when we want the client to make millions of requests and process them
    as fast as possible, we may want to turn our client into a **multithreaded** one,
    where multiple threads may run several requests truly simultaneously. Of course,
    it assumes that the computer running the client is a multicore or a multiprocessor
    computer. The application running more threads than the number of cores or processors
    installed in the computer may slow down the application due to the effect of the
    thread switching overhead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们希望客户端处理数百万个请求并尽可能快地处理它们时，我们可能希望将我们的客户端转换为 **多线程** 的，这样多个线程可以真正同时运行多个请求。当然，这假设运行客户端的计算机是多核或多处理器计算机。如果应用程序运行的线程数量超过计算机中安装的核心或处理器的数量，可能会因为线程切换开销的影响而减慢应用程序的速度。
- en: Implementing a multithreaded TCP client application
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现多线程 TCP 客户端应用程序
- en: 'In order to turn our single-treaded client application into a multithreaded
    one, we need to make several changes in it. Firstly, we need to replace the `m_thread`
    member of the `AnyncTCPClient` class that represents a single I/O thread, with
    a list of pointers to the `std::thread` objects, which will represent a collection
    of I/O threads:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的单线程客户端应用程序转换为多线程应用程序，我们需要对其进行一些更改。首先，我们需要将代表单个 I/O 线程的 `AnyncTCPClient`
    类的 `m_thread` 成员替换为指向 `std::thread` 对象的指针列表，这些对象将代表一组 I/O 线程：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to change the class''s constructor so that it accepts an argument
    representing the number of I/O threads to be created. Besides, the constructor
    should spawn the specified number of I/O threads and add them all to the pool
    of threads running the event loop:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改类的构造函数，使其接受一个表示要创建的 I/O 线程数量的参数。此外，构造函数应该启动指定的 I/O 线程数量，并将它们全部添加到运行事件循环的线程池中：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Like in a single-threaded version of the client, each thread calls the `run()`
    method of the `m_ios` object. As a result, all threads are added to the thread
    pool, controlled by the `m_ios` object. All threads from the pool will be used
    to call the corresponding asynchronous operation completion callbacks. This means
    that on a multicore or multiprocessor computer, several callbacks may be running
    truly simultaneously in different threads, each on a separate processor; whereas,
    in a single-threaded version of the client, they would be executed serially.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像客户端的单线程版本一样，每个线程都会调用 `m_ios` 对象的 `run()` 方法。结果，所有线程都被添加到由 `m_ios` 对象控制的线程池中。池中的所有线程都将用于调用相应的异步操作完成回调。这意味着在多核或多处理器计算机上，多个回调可以在不同的线程中真正同时运行，每个线程在不同的处理器上；而在客户端的单线程版本中，它们将按顺序执行。
- en: After each thread is created, the pointer to it is put to the `m_threads` list
    so that we have the access to the thread objects later.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建每个线程后，将其指针放入 `m_threads` 列表中，以便我们以后可以访问线程对象。
- en: 'Also, the last change is in the `close()` method. Here, we need to join each
    thread in the list. This is how the method looks after the change:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最后的更改是在 `close()` 方法中。在这里，我们需要连接列表中的每个线程。这是更改后的方法看起来像：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Having destroyed the `work` object, we iterate through the list of I/O threads
    and join each of them to make sure they all have exited.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁了`work`对象之后，我们遍历I/O线程列表，并加入每个线程以确保它们都已经退出。
- en: The multithreaded TCP client application is ready. Now, when we create an object
    of multithreaded `AsyncTCPClient` class, the number specifying how many threads
    should be used to process the requests should be passed to the constructor of
    the class. All other aspects of usage of the class are identical to those of a
    single-threaded one.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程TCP客户端应用程序已准备就绪。现在，当我们创建多线程`AsyncTCPClient`类的对象时，应该将指定用于处理请求的线程数量传递给类的构造函数。该类的所有其他使用方面与单线程版本相同。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 2](ch02.html "Chapter 2. I/O Operations"), *I/O Operations*, includes
    recipes that provide detailed discussions on how to perform asynchronous I/O with
    TCP socket and how to cancel asynchronous operations.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。I/O操作")，*I/O操作*，包括提供详细讨论如何使用TCP套接字执行异步I/O以及如何取消异步操作的配方。'
- en: The *Using timers* recipe from [Chapter 6](ch06.html "Chapter 6. Other Topics"),
    *Other Topics*, demonstrates how to use timers provided by Boost.Asio. Timers
    can be used to implement an asynchronous operation timeout mechanism.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第6章](ch06.html "第6章。其他主题")的*使用计时器*配方，*其他主题*，展示了如何使用Boost.Asio提供的计时器。计时器可以用来实现异步操作超时机制。
