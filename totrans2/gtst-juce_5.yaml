- en: Chapter 5. Helpful Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。有用的实用工具
- en: 'In addition to the essential classes introduced in the previous chapters, JUCE
    includes a range of classes for solving common problems in application development.
    In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章中介绍的基本类之外，JUCE 还包括一系列用于解决应用程序开发中常见问题的类。在本章中，我们将涵盖以下主题：
- en: Using the `Value`, `var`, and `ValueTree` classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Value`、`var` 和 `ValueTree` 类
- en: Implementing undo management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现撤销管理
- en: Adding XML support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 XML 支持
- en: Understanding how JUCE handles multiple threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JUCE 如何处理多线程
- en: Storing the application properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储应用程序属性
- en: Adding the menu bar controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加菜单栏控件
- en: By the end of this chapter, you will have an awareness of some of the additional
    helpful utilities offered by JUCE.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解 JUCE 提供的一些额外有用实用工具。
- en: Using the dynamically typed objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态类型对象
- en: 'The JUCE `Value`, `var`, and `ValueTree` classes are valuable tools for application
    data storage and handling. The `var` class (short for variant) is designed to
    store a range of primitive data types including integers, floating-point numbers,
    and strings (JUCE `String` objects). It may also be recursive in the sense that
    a `var` instance can hold an array of `var` instances (a JUCE `Array<var>` object).
    In this way, the `var` class is similar to the dynamic types supported by many
    scripting languages such as JavaScript. A `var` object may also hold a reference
    to any kind of `ReferenceCounterObject` object or chunks of binary data. All of
    the following are valid initializations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 的 `Value`、`var` 和 `ValueTree` 类是应用程序数据存储和处理的有价值工具。`var` 类（简称 variant）旨在存储一系列原始数据类型，包括整数、浮点数和字符串（JUCE
    `String` 对象）。它还可以递归，即一个 `var` 实例可以包含一个 `var` 实例的数组（一个 JUCE `Array<var>` 对象）。这样，`var`
    类类似于许多脚本语言（如 JavaScript）支持的动态类型。`var` 对象还可以持有任何类型的 `ReferenceCounterObject` 对象或二进制数据的块。以下都是有效的初始化方式：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the Value class
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Value` 类
- en: 'The `Value` class is designed to hold a shared instance of a `var` object (by
    storing the `var` in a reference-counted wrapper). A `Value` object may have listeners
    attached using a `Value::Listener` function and the same techniques covered in
    the [Chapter 2](ch02.html "Chapter 2. Building User Interfaces"), *Building User
    Interfaces* regarding the listener and broadcaster system employed by the GUI
    classes. In fact, `Value` objects are used by the various `Component` subclasses
    to store any value, such as the text in a `Label` object, the position of the
    thumb in a `Slider` object, and so on. As an example, the following code snippets
    illustrate ways of setting a `Label` object''s value and a `Slider` object''s
    value using its `Value` object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 类旨在持有 `var` 对象的共享实例（通过将 `var` 存储在引用计数包装器中）。`Value` 对象可以使用 `Value::Listener`
    函数和 [第 2 章](ch02.html "第 2 章。构建用户界面") 中关于 GUI 类使用的监听器和广播系统所涵盖的相同技术附加监听器。实际上，`Value`
    对象被各种 `Component` 子类用于存储任何值，例如 `Label` 对象中的文本、`Slider` 对象的位置等。例如，以下代码片段说明了使用 `Value`
    对象设置 `Label` 对象的值和 `Slider` 对象的值的方法：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Value` objects are also a way of sharing values, because they can be made
    to refer to the same underlying data. This can be useful where the same value
    is displayed in a GUI in different ways, especially in complex and detailed GUI
    displays. Create a new Introjucer project named `Chapter05_01` with a basic window,
    and replace the `MainComponent.h` file with the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 对象也是共享值的一种方式，因为它们可以指向相同的基本数据。这在同一值以不同方式在 GUI 中显示时非常有用，尤其是在复杂和详细的 GUI
    显示中。创建一个名为 `Chapter05_01` 的新 Introjucer 项目，包含一个基本窗口，并将 `MainComponent.h` 文件替换为以下内容：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we store the `Value`, `Slider`, and `Label` objects in our class. Replace
    the `MainComponent.cpp` file with the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `Value`、`Slider` 和 `Label` 对象存储在我们的类中。将 `MainComponent.cpp` 文件替换为以下内容：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we initialize our `Value` object to the value of one, then use the `Value::referTo()`
    function to configure both the `Slider` and the `Label` objects' values to refer
    to this same underlying `Value` object. Build and run the application noticing
    that both the slider and label keep updated with the same value regardless of
    which one is changed. This is all achieved without us needing to configure our
    own listeners since JUCE handles all of this internally.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的 `Value` 对象初始化为 1 的值，然后使用 `Value::referTo()` 函数配置 `Slider` 和 `Label`
    对象的值，使它们都引用这个相同的底层 `Value` 对象。构建并运行应用程序，注意无论更改哪一个，滑块和标签都会保持相同的值更新。这一切都无需我们配置自己的监听器，因为
    JUCE 内部处理所有这些。
- en: Structuring hierarchical data
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化分层数据
- en: Clearly, in most applications the data model is much more complex and commonly
    hierarchical. The `ValueTree` class is designed to reflect this using a relatively
    lightweight, yet powerful implementation. A `ValueTree` object holds a tree structure
    of named `var` objects as properties, meaning that nodes in the tree can be almost
    any data type. The following example illustrates how to store data in a `ValueTree`
    object, and some of the features that make the `ValueTree` class so invaluable
    to JUCE application development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在大多数应用程序中，数据模型要复杂得多，通常是分层的。`ValueTree` 类旨在通过相对轻量级且强大的实现来反映这一点。一个 `ValueTree`
    对象持有名为 `var` 的命名对象作为属性构成的树结构，这意味着树中的节点可以是几乎任何数据类型。以下示例说明了如何将数据存储在 `ValueTree`
    对象中，以及一些使 `ValueTree` 类对 JUCE 应用程序开发极具价值的特性。
- en: 'Create a new Introjucer project named `Chapter05_02` with a basic window. Add
    a GUI component named `EntryForm` in a similar way to previous chapters. First,
    navigate to the **Graphics** panel for the `EntryForm.cpp` file, and change the
    background color to gray. Now we will add a form-like page into which we can enter
    a person''s name, age, and address. Add six `Label` objects to the **Subcomponents**
    panel to act as labels for the data with the following contents: **First name**,
    **Last name**, **Age**, **Line 1**, **Line 2**, and **Line 3**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter05_02` 的新 Introjucer 项目，并包含一个基本窗口。以前类似的方式添加一个名为 `EntryForm` 的
    GUI 组件。首先，导航到 `EntryForm.cpp` 文件的 **Graphics** 面板，并将背景颜色更改为灰色。现在我们将添加一个表单样式的页面，我们可以在此页面中输入一个人的姓名、年龄和地址。在
    **Subcomponents** 面板中添加六个 `Label` 对象，作为以下内容的标签：**First name**、**Last name**、**Age**、**Line
    1**、**Line 2** 和 **Line 3**。
- en: 'Now add six `Label` objects with no contents (that is, empty text) adjacent
    to each of the labels added in the previous step. Set these to have a white, rather
    than transparent background, and set their **editing** property to **edit on single-click**.
    Give these the following **member name**, and **name** values as follows: `firstNameField`,
    `lastNameField`, `ageField`, `line1Field`, `line2Field`, and `line3Field`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加六个无内容（即空文本）的 `Label` 对象，并将它们放置在之前步骤中添加的每个标签旁边。将这些标签的背景设置为白色，而不是透明，并将它们的
    **编辑** 属性设置为 **单击编辑**。给这些标签以下 **成员名称** 和 **名称** 值：`firstNameField`、`lastNameField`、`ageField`、`line1Field`、`line2Field`
    和 `line3Field`。
- en: 'Finally, add a **Group Box** via the contextual menu accessed by right-clicking
    (on the Mac, press *control* and click) in the **Subcomponents** editor. Position
    this to surround the labels related to **Line 1**, **Line 2**, **Line 3,** and
    their entry fields. This should now look similar to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在 **Subcomponents** 编辑器中右键单击（在 Mac 上，按 *control* 并单击）访问上下文菜单，添加一个 **Group
    Box**。将此位置设置为围绕与 **Line 1**、**Line 2**、**Line 3** 及其输入字段相关的标签。现在它应该看起来类似于以下截图：
- en: '![Structuring hierarchical data](img/3316_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![结构化分层数据](img/3316_05_01.jpg)'
- en: 'Now save the project and open it in your IDE. Place an `EntryForm` object into
    the `MainContentComponent` object as before, by changing the `MainComponent.h`
    file to contain the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存项目并在您的 IDE 中打开它。像之前一样，将 `EntryForm` 对象放入 `MainContentComponent` 对象中，通过修改
    `MainComponent.h` 文件以包含以下内容：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the `MainComponent.cpp` file to contain the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MainComponent.cpp` 文件修改为包含以下内容：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now need to add some custom code to the `EntryForm` class to get it to store
    its data in a `ValueTree` object. First, add some variables to the class in the
    `EntryForm.h` file in the `[UserVariables]` section as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向 `EntryForm` 类添加一些自定义代码，以便使其将数据存储在 `ValueTree` 对象中。首先，在 `EntryForm.h`
    文件中的 `[UserVariables]` 部分添加一些变量，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we have one `ValueTree` object that will store the data and several static
    `Identifier` objects (which we will initialize in the `EntryForm` class in a moment)
    that serve as names for the `ValueTree` object structure and its properties. An
    `Identifier` object is effectively a special type of `String` object that holds
    only a limited set of characters, such that it will be valid in other contexts
    (for example, variable names, XML).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个 `ValueTree` 对象将存储数据，以及几个静态的 `Identifier` 对象（我们将在稍后的 `EntryForm` 类中初始化它们），它们作为
    `ValueTree` 对象结构和其属性的名称。`Identifier` 对象实际上是一种特殊的 `String` 对象类型，它只包含有限字符集，因此它将在其他上下文中有效（例如，变量名、XML）。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is more efficient to create these `Identifier` objects when the application
    starts rather than create them each time they are needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时创建这些 `Identifier` 对象比每次需要时创建它们更有效率。
- en: 'In the `EntryForm.cpp` file add the following code to initialize the `Identifier`
    objects to the `[MiscUserCode]` section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EntryForm.cpp` 文件中，将以下代码添加到 `[杂项用户代码]` 部分以初始化 `Identifier` 对象：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the constructor we need to initialize the `ValueTree` object, so add the
    following code to the `[Constructor]` section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们需要初始化 `ValueTree` 对象，因此将以下代码添加到 `[构造函数]` 部分：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we create the main `ValueTree` object with the named type `person`, and
    add three properties for the first name, last name, and age. (The graphic layout
    of our `EntryForm` component indicates the hierarchical relationship between the
    values in this top-level `personData` object.) The `nullptr` argument in each
    case indicates that we do not want undo management; we will look at this later
    in the chapter. We then create another `ValueTree` object with the named type
    `address`. Then, we add the three lines of the address as properties and add it
    as a **child node** to the main `ValueTree` object. It is in this way that we
    create tree structures with several `ValueTree` objects. The second argument of
    the call to the `ValueTree::addChild()` function indicates the index at which
    we want to add the child node. The `-1` parameter passed in this case indicates
    we just want to add it to the end of the list of nodes (but we have only one in
    any case; therefore, this value is of little importance).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `person` 的类型的主 `ValueTree` 对象，并为第一个名字、姓氏和年龄添加了三个属性。（我们的 `EntryForm`
    组件的图形布局显示了此顶级 `personData` 对象中值的层次关系。）每个情况下的 `nullptr` 参数表示我们不希望进行撤销管理；我们将在本章后面讨论这一点。然后，我们创建另一个名为
    `address` 的类型的 `ValueTree` 对象。然后，我们将地址的三个行作为属性添加，并将其作为 **子节点** 添加到主 `ValueTree`
    对象中。正是通过这种方式，我们使用多个 `ValueTree` 对象创建了树结构。调用 `ValueTree::addChild()` 函数的第二个参数表示我们想要添加子节点的索引。在这种情况下传入的
    `-1` 参数表示我们只想将其添加到节点列表的末尾（但无论如何我们只有一个；因此，这个值并不重要）。
- en: 'Finally, we need to update the `ValueTree` object when the labels change. Add
    the following code the appropriate sections:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在标签更改时更新 `ValueTree` 对象。在适当的部分添加以下代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Build and run the application and confirm that you can edit the contents of
    the entry form fields. You may also notice that JUCE automatically implements
    **focus ordering**, such that you can use the *Tab* key to move between fields.
    However, this isn't very useful yet since we don't do anything with the data.
    In the next section we will add undo management, which will start to show the
    power of the `ValueTree` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 构建、运行应用程序并确认您可以编辑表单字段的内 容。您可能还会注意到，JUCE 自动实现了 **焦点顺序**，这样您可以使用 *Tab* 键在字段之间移动。然而，这目前并不太有用，因为我们没有对数据进行任何操作。在下一节中，我们将添加撤销管理，这将开始展示
    `ValueTree` 类的强大功能。
- en: Employing undo management
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用撤销管理
- en: 'JUCE includes an `UndoManager` class to help manage undo and redo actions.
    This can be used independently, but works almost automatically if the application''s
    data is stored in a `ValueTree` object. To illustrate this we need to make a few
    changes to the project developed so far. First make some changes in the Introjucer
    project. Add a `TextButton` subcomponent labeled **Undo** and change its **name**
    and **member name** to `undoButton`. In the **Class** panel add the `ValueTree::Listener`
    class to the **Parent classes** property such that it reads:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 包含一个 `UndoManager` 类来帮助管理撤销和重做操作。这可以独立使用，但如果应用程序的数据存储在 `ValueTree` 对象中，则几乎可以自动工作。为了说明这一点，我们需要对迄今为止开发的项目进行一些修改。首先，在
    Introjucer 项目中进行一些更改。添加一个标签为 **撤销** 的 `TextButton` 子组件，并将其 **名称** 和 **成员名称** 更改为
    `undoButton`。在 **类** 面板中，将 `ValueTree::Listener` 类添加到 **父类** 属性中，使其读取：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save all the files and the project, and open it into your IDE. Add the following
    code for the `ValueTree::Listener` class to the `[UserMethods]` section of the
    `MainComponent.h` file. Notice that we add empty function braces except for the
    `valueTreePropertyChanged()` function here since we do not need to add code for
    the other functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件和项目，然后在你的集成开发环境（IDE）中打开它。将以下代码添加到`MainComponent.h`文件的`[UserMethods]`部分中，针对`ValueTree::Listener`类：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add an `UndoManager` object to the `[UserVariables]` section as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式将`UndoManager`对象添加到`[UserVariables]`部分：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `EntryForm.cpp` file add the following code for the `ValueTree::Listener`
    functions to the `[MiscUserCode]` section (notice that we need only one of these
    functions as we added empty functions to the preceding header file):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EntryForm.cpp`文件中，将以下代码添加到`[MiscUserCode]`部分，用于`ValueTree::Listener`函数（注意，我们只需要这些函数中的一个，因为我们已经在先前的头文件中添加了空函数）：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add our `EntryForm` object as a listener to the main value tree by adding the
    following code to the end of the `[Constructor]` section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下代码添加到`[Constructor]`部分的末尾，将我们的`EntryForm`对象作为监听器添加到主值树中：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each time we call the `ValueTree::setProperty()` function we need to pass a
    pointer to our `UndoManager` object. Find each line of code that uses `ValueTree::setProperty()`,
    and change the `nullptr` argument to `&undoManager`, for example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用`ValueTree::setProperty()`函数时，都需要传递我们的`UndoManager`对象的指针。找到使用`ValueTree::setProperty()`的每一行代码，并将`nullptr`参数更改为`&undoManager`，例如：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Do not use a simple find-and-replace since there are other uses of `nullptr`
    in the code that do not relate to the `ValueTree` object and `UndoManager` object
    code. In our application, when we make a change that we want to be undoable, we
    need to tell the `UndoManager` object what comprises a **transaction**. In some
    cases it might be appropriate to consider each minor change as a transaction.
    In other cases it might be more useful to the user to group small changes into
    a single transaction (for example, changes that occur within a certain time limit,
    or multiple changes to the same object). We will make each of the changes in the
    `EntryForm::labelTextChanged()` function a transaction, so add the following code
    to the `[UserlabelTextChanged_Pre]` section:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用简单的查找和替换，因为代码中还有其他与`ValueTree`对象和`UndoManager`对象代码无关的`nullptr`使用。在我们的应用程序中，当我们想要撤销更改时，我们需要告诉`UndoManager`对象一个**事务**包含什么。在某些情况下，将每个小更改视为一个事务可能是合适的。在其他情况下，将小更改组合成一个单一的事务可能对用户更有用（例如，在特定时间限制内发生的变化，或对同一对象的多次更改）。我们将把`EntryForm::labelTextChanged()`函数中的每个更改都作为一个事务，因此将以下代码添加到`[UserlabelTextChanged_Pre]`部分：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, execute the undo action in the `[UserButtonCode_undoButton]` section
    by adding the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`[UserButtonCode_undoButton]`部分执行撤销操作，添加以下代码：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This line tells the `UndoManager` object to undo the last transaction. Adding
    redo support is just as straightforward. Build and run the application, and notice
    that you can now undo changes to the data entry form using the **Undo** button.
    The `ValueTree` class also supports serialization and deserialization via binary
    or XML formats; this will be outlined in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉`UndoManager`对象撤销最后一个事务。添加重做支持同样简单。构建并运行应用程序，注意你现在可以使用**撤销**按钮撤销数据输入表单的更改。`ValueTree`类还支持通过二进制或XML格式进行序列化和反序列化；这将在下一节中概述。
- en: Adding XML support
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加XML支持
- en: 'JUCE includes a range of support for XML parsing and storage. You may have
    noticed that the Introjucer application uses the XML format to store metadata
    at the end of some of the autogenerated files (for example, in our `EntryForm.cpp`
    file). In particular, a `ValueTree` object can be serialized into XML, and this
    same XML can be deserialized back into a `ValueTree` object (although you can''t
    convert any arbitrary XML to a `ValueTree` object without doing some of your own
    parsing). To add opening and saving capabilities to our project, first we need
    to add an **Open…** and a **Save…** button in the Introjucer project. Give these
    the **name** and **member name** `openButton` and `saveButton` respectively. Then,
    in the code we need to perform the conversions to and from XML. In the `[UserButtonCode_saveButton]`
    section add the following code to present the user with a file chooser and save
    the `ValueTree` object''s data to an XML file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 包含了一系列对 XML 解析和存储的支持。你可能已经注意到，Introjucer 应用程序使用 XML 格式在自动生成的某些文件末尾存储元数据（例如，在我们的
    `EntryForm.cpp` 文件中）。特别是，一个 `ValueTree` 对象可以被序列化为 XML，并且相同的 XML 可以反序列化回一个 `ValueTree`
    对象（尽管在没有进行一些自己的解析的情况下，你不能将任何任意的 XML 转换为一个 `ValueTree` 对象）。为了给我们的项目添加打开和保存功能，首先我们需要在
    Introjucer 项目中添加一个 **Open…** 和一个 **Save…** 按钮。分别将这些按钮命名为 **name** 和 **member name**
    `openButton` 和 `saveButton`。然后，在代码中我们需要执行到和从 XML 的转换。在 `[UserButtonCode_saveButton]`
    部分添加以下代码，向用户展示文件选择器并将 `ValueTree` 对象的数据保存到 XML 文件中：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `[UserButtonCode_openButton]` section add the following code to read
    an XML file back in to the `ValueTree` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[UserButtonCode_openButton]` 部分添加以下代码，将 XML 文件读回到 `ValueTree` 对象中：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here we load the chosen file as an XML document, and access its document element.
    We perform two checks on the XML and report an error to the log if necessary:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将选定的文件作为 XML 文档加载，并访问其文档元素。我们对 XML 执行两次检查，并在必要时向日志报告错误：
- en: We check if the XML element was accessed successfully (that is, did not return
    `nullptr`). If this fails the file may not be a valid XML file.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查 XML 元素是否成功访问（即，没有返回 `nullptr`）。如果失败，文件可能不是一个有效的 XML 文件。
- en: We load the XML into a `ValueTree` object then check the type of this `ValueTree`
    object to ensure it is the `person` data that we expect.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 XML 加载到一个 `ValueTree` 对象中，然后检查这个 `ValueTree` 对象的类型，以确保它是我们预期的 `person` 数据。
- en: Once the loaded `ValueTree` object is checked successfully, we copy the properties
    to the stored `ValueTree` object as a single `UndoManager` object transaction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载的 `ValueTree` 对象成功检查，我们就将其属性复制到存储的 `ValueTree` 对象中，作为一个单独的 `UndoManager`
    对象事务。
- en: 'Build and run the application, and check that saving, opening, and all the
    undo behaviors work as expected. The following screenshot shows how the application
    window should appear:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，检查保存、打开以及所有撤销行为是否按预期工作。以下截图显示了应用程序窗口应该如何显示：
- en: '![Adding XML support](img/3316_05_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![添加 XML 支持](img/3316_05_02.jpg)'
- en: 'The XML file produced by this code for the data shown in this screenshot will
    look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码为截图中的数据生成的 XML 文件将类似于以下这样：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, in a real-world application we would have **Open**, **Save**, and
    **Undo** commands as menu bar items too (or instead), but we have used buttons
    here for simplicity. (Adding menu bar controls is covered at the end of this chapter.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实际应用中，我们还会在菜单栏中添加**打开**、**保存**和**撤销**等命令（或者用它们来代替），但在这里我们为了简单起见使用了按钮。（关于添加菜单栏控制的内容将在本章末尾介绍。）
- en: The `XmlDocument` and `XmlElement` classes shown here provide broad functionality
    for parsing and creating XML documents independent of `ValueTree` objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 `XmlDocument` 和 `XmlElement` 类提供了独立于 `ValueTree` 对象的广泛功能，用于解析和创建 XML 文档。
- en: Understanding how JUCE handles multiple threads
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JUCE 如何处理多线程
- en: 'JUCE includes a cross-platform interface to operating system threads using
    its `Thread` class. There are also classes that help with synchronizing inter-thread
    communication, notably the `CriticalSection` class, the `WaitableEvent` class,
    and the `Atomic` template classes (for example, `Atomic<int>`). Writing multithreaded
    applications is inherently challenging and it is beyond the scope of this book
    to serve as an introduction. However, JUCE does make the processes of writing
    multithreaded applications a little easier. One way in which this is achieved
    is through providing a consistent interface on all platforms. JUCE will also raise
    assertions if you do certain things that are likely to lead to some of the common
    problems (for example, deadlocks and race conditions). The following serves as
    a basic demonstration; we will create a simple thread that increments a counter
    and displays this counter in the GUI. Create a new Introjucer project called `Chapter05_03`
    with a basic window. Open the project in your IDE, and change the `MainComponent.h`
    file to contain the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE通过其`Thread`类提供了一个跨平台的操作系统线程接口。还有一些类可以帮助同步线程间的通信，特别是`CriticalSection`类、`WaitableEvent`类和`Atomic`模板类（例如，`Atomic<int>`）。编写多线程应用程序本质上具有挑战性，本书的范围超出了作为介绍的范围。然而，JUCE确实使编写多线程应用程序的过程变得容易一些。实现这一点的其中一种方式是提供所有平台上一致的接口。如果执行某些可能导致一些常见问题（例如死锁和竞态条件）的操作，JUCE也会引发断言。以下是一个基本演示；我们将创建一个简单的线程，该线程增加一个计数器并在GUI中显示这个计数器。创建一个新的名为`Chapter05_03`的Introjucer项目，包含一个基本窗口。在你的IDE中打开项目，并将`MainComponent.h`文件更改为包含以下内容：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that our class inherits from the `Thread` class that requires us to
    implement the `Thread::run()` pure virtual function (which serves as our thread''s
    entry point). Now replace the code in the `MainComponent.cpp` file with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的类继承自`Thread`类，这要求我们实现`Thread::run()`纯虚函数（它作为我们线程的入口点）。现在将`MainComponent.cpp`文件中的代码替换为以下内容：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The main thing to notice here is that we must provide a name for our thread
    by passing a `String` object to the `Thread` class constructor. In the `buttonClicked()`
    function we start and stop our thread using the **Start Thread** and **Stop Thread**
    buttons, respectively. The value of `3000` passed to the `Thread::stopThread()`
    function is a timeout in milliseconds, after which the thread will be forcibly
    killed (which is unlikely to happen unless these is an error). We also need to
    implement the `Thread::run()` function, which is where the thread undertakes its
    work. This is where many of the problems occur. In particular you can''t directly
    update GUI objects from anything other than the JUCE message thread. This message
    thread is the main thread on which your application''s `initialise()` and `shutdown()`
    functions are called (so most of the construction and destruction of your application),
    where your GUI listener callbacks are called, mouse events are reported, and so
    on. Effectively, it is the "main" thread (and probably is the executable''s main
    thread in many circumstances). This is why it has been safe to update GUI objects
    in response to user interactions with other GUI objects. Add the following code
    to the end of the `MainComponent.cpp` file. This should fail as soon as you click
    on the **Start Thread** button:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的主要事项是，我们必须通过将一个`String`对象传递给`Thread`类的构造函数来为我们的线程提供一个名称。在`buttonClicked()`函数中，我们分别使用**Start
    Thread**和**Stop Thread**按钮启动和停止我们的线程。传递给`Thread::stopThread()`函数的`3000`值是一个超时时间（以毫秒为单位），在此之后，线程将被强制终止（除非出现错误，否则这种情况很少发生）。我们还需要实现`Thread::run()`函数，这是线程执行其工作的地方。这正是许多问题发生的地方。特别是，你不能从除了JUCE消息线程之外的任何地方直接更新GUI对象。这个消息线程是主线程，你的应用程序的`initialise()`和`shutdown()`函数（以及你应用程序的大部分构建和销毁）都是在这个线程上被调用的，你的GUI监听器回调函数、鼠标事件等都是在该线程上报告的。实际上，它是“主”线程（在许多情况下，它可能是可执行文件的主线程）。这就是为什么在响应用户与其他GUI对象的交互时更新GUI对象是安全的。将以下代码添加到`MainComponent.cpp`文件的末尾。当你点击**Start
    Thread**按钮时，它应该立即失败：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a *debug* build, your code should stop on an assertion. Looking at the JUCE
    code where the assertion was raised, there will be a comment that will tell you
    that this action can''t be done unless you use a `MessageManagerLock` object.
    (In a *release* build, it may simply crash or cause the application to behave
    strangely.) To use a `MessageManagerLock` object correctly, change the `run()`
    function as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *调试* 构建中，你的代码应该在断言处停止。查看引发断言的 JUCE 代码，你会看到一个注释，告诉你除非使用 `MessageManagerLock`
    对象，否则无法执行此操作。（在 *发布* 构建中，它可能简单地崩溃或导致应用程序行为异常。）要正确使用 `MessageManagerLock` 对象，请按以下方式更改
    `run()` 函数：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we create a `MessageManagerLock` object, passing it a pointer to the current
    thread (that is, this thread). If the `MessageManagerLock::lockWasGained()` function
    returns `true`, it is safe to manipulate GUI objects. The thread releases the
    lock as the `MessageManagerLock` object goes out of scope (as we come round the
    `while()` loop again). This code also shows the typical structure of a `Thread::run()`
    function; that is, a `while()` loop that checks the result of calling the `Thread::threadShouldExit()`
    function and continues to loop unless the thread has been told to exit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个 `MessageManagerLock` 对象，传递给它当前线程的指针（即这个线程）。如果 `MessageManagerLock::lockWasGained()`
    函数返回 `true`，则可以安全地操作 GUI 对象。当 `MessageManagerLock` 对象超出作用域（当我们再次绕过 `while()` 循环时）时，线程会释放锁。此代码还显示了
    `Thread::run()` 函数的典型结构；即一个 `while()` 循环，该循环检查调用 `Thread::threadShouldExit()`
    函数的结果，并且除非线程被告知退出，否则会继续循环。
- en: Storing application properties
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储应用程序属性
- en: 'In this final example we will implement a simple application that stores its
    state in a properties file (that is, settings or preferences) in a standard location
    on the runtime platform. First create a new Introjucer project named `Chapter05_04`
    with a basic window. Change the `MainComponent.h` file to contain the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们将实现一个简单的应用程序，该应用程序将其状态存储在运行时平台的标准位置上的属性文件（即设置或首选项）中。首先创建一个名为 `Chapter05_04`
    的新 Introjucer 项目，包含一个基本窗口。将 `MainComponent.h` 文件更改为包含以下代码：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we have a label and a slider; these will represent our simple application
    properties. Clearly, in a fully developed application, the properties would be
    presented in a separate window or panel, but the principle is the same.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个标签和一个滑块；这些将代表我们的简单应用程序属性。显然，在一个完全开发的应用程序中，属性将在一个单独的窗口或面板中展示，但原理是相同的。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `ApplicationProperties` class is a helper class that manages the application
    properties, saving them to the appropriate location on the user's system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationProperties` 类是一个辅助类，用于管理应用程序属性，将它们保存到用户系统上的适当位置。'
- en: 'Change the contents of the `MainComponent.cpp` file to:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MainComponent.cpp` 文件的内容更改为：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we configure the `ApplicationProperties` object by passing it our desired
    application name and folder name (using the name that the Introjucer application
    will have generated in the `ProjectInfo::projectName` constant). We provide a
    filename suffix (for example, `settings`, `xml`). To support Mac OS X, it is recommended
    that you set the `PropertiesFile::Options::osxLibrarySubFolder` option since Apple
    changed their recommendation for the storage of application preferences. This
    was previously in `Library/Preferences`, but Apple now recommends that developers
    use `Library/Application Support`. This is provided for backwards compatibility;
    all new applications should set this to `Application Support`. This setting is
    harmless for other platforms. It is important to configure these options prior
    to using the `ApplicationProperties` object by passing the options via the `ApplicationProperties::setStorageParameters()`
    function. In fact, the `ApplicatonProperties` class maintains two sets of properties,
    one for all users and one for the current user. In this example we create only
    properties for the current user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过传递我们希望的应用程序名称和文件夹名称（使用 Introjucer 应用程序将在 `ProjectInfo::projectName`
    常量中生成的名称）来配置 `ApplicationProperties` 对象。我们提供一个文件后缀（例如，`settings`，`xml`）。为了支持 Mac
    OS X，建议您设置 `PropertiesFile::Options::osxLibrarySubFolder` 选项，因为苹果更改了他们关于存储应用程序首选项的建议。这之前在
    `Library/Preferences` 中，但现在苹果建议开发者使用 `Library/Application Support`。这是为了向后兼容；所有新的应用程序都应该将其设置为
    `Application Support`。对于其他平台，此设置无害。在通过 `ApplicationProperties::setStorageParameters()`
    函数传递选项之前配置这些选项是很重要的。实际上，`ApplicatonProperties` 类维护两组属性，一组用于所有用户，一组用于当前用户。在这个例子中，我们只为当前用户创建属性。
- en: 'When the application starts, it tries to access the value of the properties
    and set the label and slider appropriately. First, we access the user settings
    `PropertiesFile` object using the `ApplicationProperties::getUserSettings()` function.
    We store a pointer to the `PropertiesFile` object that this returns in a regular
    pointer, as it is owned by `ApplicationProperties` object, and we need it only
    temporarily. (Storing it in a `ScopedPointer` object in this case could cause
    a crash, since the `ScopedPointer` object would try eventually to delete an object
    that it should not really own, since it already has an owner.) Then we use the
    `PropertiesFile::getValue()` function to get the text value, and the `PropertiesFile::getDoubleValue()`
    function to get the double value (there are also the `PropertiesFile::getIntValue()`
    and `PropertiesFile::getBoolValue()` functions if needed). Of course, the first
    time the application starts, these properties will be empty. Each of these property
    accessors allows you to provide a default value, should the named property not
    exist. Here we provide `<empty>` as the default for the label contents and `0.0`
    as the default for the slider. When the application closes (in this case we know
    this is happening when the `MainContentComponent` destructor is called) we set
    the value of the properties to the current state of the label and the slider.
    This means that when we close the application and reopen it, the slider and the
    label should appear to retain their state between launches. Build and run the
    application and test this. The file generated by the `ApplicationProperties` object
    should look something as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它会尝试访问属性的值并适当地设置标签和滑块。首先，我们使用 `ApplicationProperties::getUserSettings()`
    函数访问用户设置的 `PropertiesFile` 对象。我们将返回的 `PropertiesFile` 对象的指针存储在一个普通指针中，因为它由 `ApplicationProperties`
    对象拥有，我们只需要临时使用它。（在这种情况下将其存储在 `ScopedPointer` 对象中可能会导致崩溃，因为 `ScopedPointer` 对象最终会尝试删除它实际上不应该拥有的对象，因为它已经有了一个所有者。）然后我们使用
    `PropertiesFile::getValue()` 函数获取文本值，以及 `PropertiesFile::getDoubleValue()` 函数获取双精度值（如果需要，还有
    `PropertiesFile::getIntValue()` 和 `PropertiesFile::getBoolValue()` 函数）。当然，应用程序第一次启动时，这些属性将是空的。每个属性访问器都允许你提供一个默认值，如果指定的属性不存在。在这里，我们将
    `<empty>` 作为标签内容的默认值，将 `0.0` 作为滑块的默认值。当应用程序关闭时（在这种情况下我们知道这是在调用 `MainContentComponent`
    析构函数时发生的）我们将属性的值设置为标签和滑块的当前状态。这意味着当我们关闭应用程序并重新打开它时，滑块和标签应该看起来在启动之间保持了它们的状态。构建并运行应用程序并测试这一点。由
    `ApplicationProperties` 对象生成的文件应该看起来如下：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On Mac OS X this should be in:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，这应该在以下位置：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**On Windows this should be in:**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Windows 上，这应该在以下位置：**'
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**where `USERNAME` is the name of the currently logged-in user.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**其中 `USERNAME` 是当前登录用户的名称。**'
- en: '**# Adding menu bar controls'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 添加菜单栏控件**'
- en: JUCE offers a means of creating menu bar user interface controls, as you will
    have seen, using the Introjucer application, and in the JUCE Demo application
    in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and the Introjucer Application"),
    *Installing JUCE and the Introjucer Application*. These menu bars may be within
    a window on all platforms using JUCE's own `MenuBarComponent` class, or as a native
    menu bar at the top of the screen on Mac OS X. To demonstrate this we will add
    some special commands to the `Chapter05_04` project to reset the label and slider
    in various ways.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，JUCE 提供了使用 Introjucer 应用程序和 JUCE 示例应用程序在 [第 1 章](ch01.html "第 1 章。安装 JUCE
    和 Introjucer 应用程序") 中安装 JUCE 和 Introjucer 应用程序的方法。这些菜单栏可以在所有平台上使用 JUCE 的 `MenuBarComponent`
    类在窗口内，或者在 Mac OS X 顶部作为原生菜单栏。为了演示这一点，我们将向 `Chapter05_04` 项目添加一些特殊命令来以各种方式重置标签和滑块。
- en: 'The first requirement for constructing menu bars in JUCE is to create a **menu
    bar model** by creating a subclass of the `MenuBarModel` class. First add the
    `MenuBarModel` class as a base class for the `MainContentComponent` class in the
    `MainComponent.h` file as highlighted in the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JUCE 中构建菜单栏的第一个要求是创建一个 **菜单栏模型**，通过创建 `MenuBarModel` 类的子类来实现。首先，在 `MainComponent.h`
    文件中将 `MenuBarModel` 类作为 `MainContentComponent` 类的基类添加，如下所示：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `MenuBarModel` class has three pure virtual functions that will be used
    to populate the menu bar. To add these, add the following three lines to the `public`
    section of the `MainComponent.h` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuBarModel` 类有三个纯虚函数，将用于填充菜单栏。要添加这些函数，请将以下三行添加到 `MainComponent.h` 文件的 `public`
    部分：'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `getMenuBarNames()` function should return an array of menu names that
    will appear along the menu bar. The `getMenuForIndex()` function is used to create
    the actual menu when the user clicks on one of the menu bar names. This should
    return a `PopupMenu` object for a given menu (which can be determined using the
    menu index or its name). Each menu item should be given a unique ID value that
    is used to identify the menu item when it is selected. This is described in a
    moment. The `menuItemSelected()` function will be called when a user selects a
    particular menu item from one of the menus. Here you are provided with the ID
    value of the menu item that was selected (and the index of the menu that this
    menu item was in, if you really need this information). For convenience we should
    add these IDs as enumerated constants. Add the following code to the end of the
    `public` section of the `MainComponent.h` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMenuBarNames()`函数应返回一个菜单名称数组，这些名称将出现在菜单栏上。`getMenuForIndex()`函数用于在用户点击菜单栏名称时创建实际菜单。这应该返回一个针对给定菜单的`PopupMenu`对象（可以使用菜单索引或其名称来确定）。每个菜单项都应该有一个唯一的ID值，用于在选中时识别菜单项。这将在稍后描述。当用户从菜单中选择特定的菜单项时，将调用`menuItemSelected()`函数。这里提供了所选菜单项的ID值（以及如果真的需要，该菜单项所在的菜单索引）。为了方便，我们应该将这些ID作为枚举常量添加。将以下代码添加到`MainComponent.h`文件`public`部分的末尾：'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that the first item is given a value of `1000`; this is because an ID
    value of `0` (which is otherwise the default) is not valid as an ID. We need to
    store the `MenuBarComponent` object too. Add the code as highlighted below:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个项目被赋予值为`1000`；这是因为ID值为`0`（否则是默认值）不是一个有效的ID。我们还需要存储`MenuBarComponent`对象。按照以下突出显示的代码添加代码：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `MainComponent.cpp` file, update the constructor for the `MainContentComponent`
    class as highlighted in the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainComponent.cpp`文件中，更新`MainContentComponent`类的构造函数，如下所示：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here we pass the `this` pointer to the `MenuBarComponent` object in the initializer
    list. This is to tell the `MenuBarComponent` object which `MenuBarModel` to use.
    Update the `resized()` function in the `MainComponent.cpp` file to position the
    components as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化列表中，我们将`this`指针传递给`MenuBarComponent`对象。这是为了告诉`MenuBarComponent`对象使用哪个`MenuBarModel`。更新`MainComponent.cpp`文件中的`resized()`函数，以如下方式定位组件：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This positions the menu bar at the top of the window, filling the whole width
    of the window. Now we will add the menu bar functionality by implementing the
    virtual functions from the `MenuBarModel` class. Add the following code to the
    `MainComponent.cpp` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将菜单栏放置在窗口顶部，填充整个窗口宽度。现在我们将通过实现`MenuBarModel`类的虚拟函数来添加菜单栏功能。将以下代码添加到`MainComponent.cpp`文件中：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates the top-level menu names by returning a `StringArray` object containing
    the names. Here we will have two menus, one to control the label, and the other
    to control the slider. Next, add the following code to the `MainComponent.cpp`
    file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过返回一个包含名称的`StringArray`对象来创建顶级菜单名称。这里我们将有两个菜单，一个用于控制标签，另一个用于控制滑块。接下来，将以下代码添加到`MainComponent.cpp`文件中：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This checks which menu should be populated by inspecting the menu name. The
    **Label** menu will be filled with a single item that will be used to clear the
    label contents. The **Slider** menu will be filled with two items: one to set
    the slider to its minimum value, and one to set the slider to its maximum value.
    Notice that this is one place where we use the enumerated constants created earlier.
    Finally, add the following code to the `MainComponent.cpp` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过检查菜单名称来确定应该填充哪个菜单。**标签**菜单将被填充一个单独的项目，用于清除标签内容。**滑块**菜单将被填充两个项目：一个用于将滑块设置为最小值，另一个用于将滑块设置为最大值。请注意，这是使用之前创建的枚举常量之一的地方。最后，将以下代码添加到`MainComponent.cpp`文件中：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we check which menu ID was selected by the user and act accordingly. Build
    and run the application to check this functionality. An additional example project
    `Chapter05_04b` is provided in the code bundle that illustrates how to modify
    this example to use the native menu bar on the Mac OS X platform. A more sophisticated
    technique for implementing menu bars is to use the JUCE `ApplicationCommandManager`
    class, which is used by the JUCE Demo application and the Introjucer application
    code to present its menus, issue commands from buttons, and so on. Refer to the
    JUCE documentation for this class for a complete guide.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查用户选择了哪个菜单ID，并相应地采取行动。构建并运行应用程序以检查此功能。代码包中提供了一个额外的示例项目`Chapter05_04b`，说明了如何修改此示例以在Mac
    OS X平台上使用原生菜单栏。实现菜单栏的更复杂技术是使用JUCE的`ApplicationCommandManager`类，该类被JUCE演示应用程序和Introjucer应用程序代码用于显示其菜单、从按钮发出命令等。有关此类的完整指南，请参阅JUCE文档。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced a range of additional useful utilities for application
    development in JUCE. This included using the `ValueTree` class and related classes
    for structuring and storing application data and properties, and adding undo management.
    This chapter also looked at multithreading support in JUCE, and introduced one
    final user interface component for adding menu bar controls to JUCE applications.
    These really are the tip of the iceberg. It is rare to find a JUCE class that
    is difficult to integrate into your own code. You are encouraged to explore the
    JUCE documentation to find further classes that will support your development.
    The JUCE code and classes introduced in this book should have given you an insight
    into the idioms of JUCE code. This should make discovering and using new JUCE
    classes relatively straightforward.**
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了JUCE应用开发中一系列额外的有用工具。这包括使用`ValueTree`类和相关类来结构化和存储应用程序数据和属性，以及添加撤销管理。本章还探讨了JUCE中的多线程支持，并介绍了一个用于向JUCE应用程序添加菜单栏控制的最终用户界面组件。这些只是冰山一角。很难找到一个难以集成到您自己的代码中的JUCE类。鼓励您探索JUCE文档，以找到更多支持您开发的类。本书中介绍的JUCE代码和类应该让您对JUCE代码的惯用法有了深入了解。这应该会使发现和使用新的JUCE类相对简单。**
