- en: Chapter 5. Helpful Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the essential classes introduced in the previous chapters, JUCE
    includes a range of classes for solving common problems in application development.
    In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Value`, `var`, and `ValueTree` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing undo management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding XML support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how JUCE handles multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the application properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the menu bar controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have an awareness of some of the additional
    helpful utilities offered by JUCE.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dynamically typed objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JUCE `Value`, `var`, and `ValueTree` classes are valuable tools for application
    data storage and handling. The `var` class (short for variant) is designed to
    store a range of primitive data types including integers, floating-point numbers,
    and strings (JUCE `String` objects). It may also be recursive in the sense that
    a `var` instance can hold an array of `var` instances (a JUCE `Array<var>` object).
    In this way, the `var` class is similar to the dynamic types supported by many
    scripting languages such as JavaScript. A `var` object may also hold a reference
    to any kind of `ReferenceCounterObject` object or chunks of binary data. All of
    the following are valid initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the Value class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Value` class is designed to hold a shared instance of a `var` object (by
    storing the `var` in a reference-counted wrapper). A `Value` object may have listeners
    attached using a `Value::Listener` function and the same techniques covered in
    the [Chapter 2](ch02.html "Chapter 2. Building User Interfaces"), *Building User
    Interfaces* regarding the listener and broadcaster system employed by the GUI
    classes. In fact, `Value` objects are used by the various `Component` subclasses
    to store any value, such as the text in a `Label` object, the position of the
    thumb in a `Slider` object, and so on. As an example, the following code snippets
    illustrate ways of setting a `Label` object''s value and a `Slider` object''s
    value using its `Value` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Value` objects are also a way of sharing values, because they can be made
    to refer to the same underlying data. This can be useful where the same value
    is displayed in a GUI in different ways, especially in complex and detailed GUI
    displays. Create a new Introjucer project named `Chapter05_01` with a basic window,
    and replace the `MainComponent.h` file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we store the `Value`, `Slider`, and `Label` objects in our class. Replace
    the `MainComponent.cpp` file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialize our `Value` object to the value of one, then use the `Value::referTo()`
    function to configure both the `Slider` and the `Label` objects' values to refer
    to this same underlying `Value` object. Build and run the application noticing
    that both the slider and label keep updated with the same value regardless of
    which one is changed. This is all achieved without us needing to configure our
    own listeners since JUCE handles all of this internally.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring hierarchical data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly, in most applications the data model is much more complex and commonly
    hierarchical. The `ValueTree` class is designed to reflect this using a relatively
    lightweight, yet powerful implementation. A `ValueTree` object holds a tree structure
    of named `var` objects as properties, meaning that nodes in the tree can be almost
    any data type. The following example illustrates how to store data in a `ValueTree`
    object, and some of the features that make the `ValueTree` class so invaluable
    to JUCE application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Introjucer project named `Chapter05_02` with a basic window. Add
    a GUI component named `EntryForm` in a similar way to previous chapters. First,
    navigate to the **Graphics** panel for the `EntryForm.cpp` file, and change the
    background color to gray. Now we will add a form-like page into which we can enter
    a person''s name, age, and address. Add six `Label` objects to the **Subcomponents**
    panel to act as labels for the data with the following contents: **First name**,
    **Last name**, **Age**, **Line 1**, **Line 2**, and **Line 3**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add six `Label` objects with no contents (that is, empty text) adjacent
    to each of the labels added in the previous step. Set these to have a white, rather
    than transparent background, and set their **editing** property to **edit on single-click**.
    Give these the following **member name**, and **name** values as follows: `firstNameField`,
    `lastNameField`, `ageField`, `line1Field`, `line2Field`, and `line3Field`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add a **Group Box** via the contextual menu accessed by right-clicking
    (on the Mac, press *control* and click) in the **Subcomponents** editor. Position
    this to surround the labels related to **Line 1**, **Line 2**, **Line 3,** and
    their entry fields. This should now look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring hierarchical data](img/3316_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now save the project and open it in your IDE. Place an `EntryForm` object into
    the `MainContentComponent` object as before, by changing the `MainComponent.h`
    file to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `MainComponent.cpp` file to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add some custom code to the `EntryForm` class to get it to store
    its data in a `ValueTree` object. First, add some variables to the class in the
    `EntryForm.h` file in the `[UserVariables]` section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we have one `ValueTree` object that will store the data and several static
    `Identifier` objects (which we will initialize in the `EntryForm` class in a moment)
    that serve as names for the `ValueTree` object structure and its properties. An
    `Identifier` object is effectively a special type of `String` object that holds
    only a limited set of characters, such that it will be valid in other contexts
    (for example, variable names, XML).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is more efficient to create these `Identifier` objects when the application
    starts rather than create them each time they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `EntryForm.cpp` file add the following code to initialize the `Identifier`
    objects to the `[MiscUserCode]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor we need to initialize the `ValueTree` object, so add the
    following code to the `[Constructor]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we create the main `ValueTree` object with the named type `person`, and
    add three properties for the first name, last name, and age. (The graphic layout
    of our `EntryForm` component indicates the hierarchical relationship between the
    values in this top-level `personData` object.) The `nullptr` argument in each
    case indicates that we do not want undo management; we will look at this later
    in the chapter. We then create another `ValueTree` object with the named type
    `address`. Then, we add the three lines of the address as properties and add it
    as a **child node** to the main `ValueTree` object. It is in this way that we
    create tree structures with several `ValueTree` objects. The second argument of
    the call to the `ValueTree::addChild()` function indicates the index at which
    we want to add the child node. The `-1` parameter passed in this case indicates
    we just want to add it to the end of the list of nodes (but we have only one in
    any case; therefore, this value is of little importance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update the `ValueTree` object when the labels change. Add
    the following code the appropriate sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application and confirm that you can edit the contents of
    the entry form fields. You may also notice that JUCE automatically implements
    **focus ordering**, such that you can use the *Tab* key to move between fields.
    However, this isn't very useful yet since we don't do anything with the data.
    In the next section we will add undo management, which will start to show the
    power of the `ValueTree` class.
  prefs: []
  type: TYPE_NORMAL
- en: Employing undo management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUCE includes an `UndoManager` class to help manage undo and redo actions.
    This can be used independently, but works almost automatically if the application''s
    data is stored in a `ValueTree` object. To illustrate this we need to make a few
    changes to the project developed so far. First make some changes in the Introjucer
    project. Add a `TextButton` subcomponent labeled **Undo** and change its **name**
    and **member name** to `undoButton`. In the **Class** panel add the `ValueTree::Listener`
    class to the **Parent classes** property such that it reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all the files and the project, and open it into your IDE. Add the following
    code for the `ValueTree::Listener` class to the `[UserMethods]` section of the
    `MainComponent.h` file. Notice that we add empty function braces except for the
    `valueTreePropertyChanged()` function here since we do not need to add code for
    the other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `UndoManager` object to the `[UserVariables]` section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `EntryForm.cpp` file add the following code for the `ValueTree::Listener`
    functions to the `[MiscUserCode]` section (notice that we need only one of these
    functions as we added empty functions to the preceding header file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add our `EntryForm` object as a listener to the main value tree by adding the
    following code to the end of the `[Constructor]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time we call the `ValueTree::setProperty()` function we need to pass a
    pointer to our `UndoManager` object. Find each line of code that uses `ValueTree::setProperty()`,
    and change the `nullptr` argument to `&undoManager`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not use a simple find-and-replace since there are other uses of `nullptr`
    in the code that do not relate to the `ValueTree` object and `UndoManager` object
    code. In our application, when we make a change that we want to be undoable, we
    need to tell the `UndoManager` object what comprises a **transaction**. In some
    cases it might be appropriate to consider each minor change as a transaction.
    In other cases it might be more useful to the user to group small changes into
    a single transaction (for example, changes that occur within a certain time limit,
    or multiple changes to the same object). We will make each of the changes in the
    `EntryForm::labelTextChanged()` function a transaction, so add the following code
    to the `[UserlabelTextChanged_Pre]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the undo action in the `[UserButtonCode_undoButton]` section
    by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This line tells the `UndoManager` object to undo the last transaction. Adding
    redo support is just as straightforward. Build and run the application, and notice
    that you can now undo changes to the data entry form using the **Undo** button.
    The `ValueTree` class also supports serialization and deserialization via binary
    or XML formats; this will be outlined in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding XML support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUCE includes a range of support for XML parsing and storage. You may have
    noticed that the Introjucer application uses the XML format to store metadata
    at the end of some of the autogenerated files (for example, in our `EntryForm.cpp`
    file). In particular, a `ValueTree` object can be serialized into XML, and this
    same XML can be deserialized back into a `ValueTree` object (although you can''t
    convert any arbitrary XML to a `ValueTree` object without doing some of your own
    parsing). To add opening and saving capabilities to our project, first we need
    to add an **Open…** and a **Save…** button in the Introjucer project. Give these
    the **name** and **member name** `openButton` and `saveButton` respectively. Then,
    in the code we need to perform the conversions to and from XML. In the `[UserButtonCode_saveButton]`
    section add the following code to present the user with a file chooser and save
    the `ValueTree` object''s data to an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `[UserButtonCode_openButton]` section add the following code to read
    an XML file back in to the `ValueTree` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we load the chosen file as an XML document, and access its document element.
    We perform two checks on the XML and report an error to the log if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: We check if the XML element was accessed successfully (that is, did not return
    `nullptr`). If this fails the file may not be a valid XML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We load the XML into a `ValueTree` object then check the type of this `ValueTree`
    object to ensure it is the `person` data that we expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the loaded `ValueTree` object is checked successfully, we copy the properties
    to the stored `ValueTree` object as a single `UndoManager` object transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the application, and check that saving, opening, and all the
    undo behaviors work as expected. The following screenshot shows how the application
    window should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding XML support](img/3316_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The XML file produced by this code for the data shown in this screenshot will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in a real-world application we would have **Open**, **Save**, and
    **Undo** commands as menu bar items too (or instead), but we have used buttons
    here for simplicity. (Adding menu bar controls is covered at the end of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: The `XmlDocument` and `XmlElement` classes shown here provide broad functionality
    for parsing and creating XML documents independent of `ValueTree` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how JUCE handles multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUCE includes a cross-platform interface to operating system threads using
    its `Thread` class. There are also classes that help with synchronizing inter-thread
    communication, notably the `CriticalSection` class, the `WaitableEvent` class,
    and the `Atomic` template classes (for example, `Atomic<int>`). Writing multithreaded
    applications is inherently challenging and it is beyond the scope of this book
    to serve as an introduction. However, JUCE does make the processes of writing
    multithreaded applications a little easier. One way in which this is achieved
    is through providing a consistent interface on all platforms. JUCE will also raise
    assertions if you do certain things that are likely to lead to some of the common
    problems (for example, deadlocks and race conditions). The following serves as
    a basic demonstration; we will create a simple thread that increments a counter
    and displays this counter in the GUI. Create a new Introjucer project called `Chapter05_03`
    with a basic window. Open the project in your IDE, and change the `MainComponent.h`
    file to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our class inherits from the `Thread` class that requires us to
    implement the `Thread::run()` pure virtual function (which serves as our thread''s
    entry point). Now replace the code in the `MainComponent.cpp` file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The main thing to notice here is that we must provide a name for our thread
    by passing a `String` object to the `Thread` class constructor. In the `buttonClicked()`
    function we start and stop our thread using the **Start Thread** and **Stop Thread**
    buttons, respectively. The value of `3000` passed to the `Thread::stopThread()`
    function is a timeout in milliseconds, after which the thread will be forcibly
    killed (which is unlikely to happen unless these is an error). We also need to
    implement the `Thread::run()` function, which is where the thread undertakes its
    work. This is where many of the problems occur. In particular you can''t directly
    update GUI objects from anything other than the JUCE message thread. This message
    thread is the main thread on which your application''s `initialise()` and `shutdown()`
    functions are called (so most of the construction and destruction of your application),
    where your GUI listener callbacks are called, mouse events are reported, and so
    on. Effectively, it is the "main" thread (and probably is the executable''s main
    thread in many circumstances). This is why it has been safe to update GUI objects
    in response to user interactions with other GUI objects. Add the following code
    to the end of the `MainComponent.cpp` file. This should fail as soon as you click
    on the **Start Thread** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a *debug* build, your code should stop on an assertion. Looking at the JUCE
    code where the assertion was raised, there will be a comment that will tell you
    that this action can''t be done unless you use a `MessageManagerLock` object.
    (In a *release* build, it may simply crash or cause the application to behave
    strangely.) To use a `MessageManagerLock` object correctly, change the `run()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a `MessageManagerLock` object, passing it a pointer to the current
    thread (that is, this thread). If the `MessageManagerLock::lockWasGained()` function
    returns `true`, it is safe to manipulate GUI objects. The thread releases the
    lock as the `MessageManagerLock` object goes out of scope (as we come round the
    `while()` loop again). This code also shows the typical structure of a `Thread::run()`
    function; that is, a `while()` loop that checks the result of calling the `Thread::threadShouldExit()`
    function and continues to loop unless the thread has been told to exit.
  prefs: []
  type: TYPE_NORMAL
- en: Storing application properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final example we will implement a simple application that stores its
    state in a properties file (that is, settings or preferences) in a standard location
    on the runtime platform. First create a new Introjucer project named `Chapter05_04`
    with a basic window. Change the `MainComponent.h` file to contain the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a label and a slider; these will represent our simple application
    properties. Clearly, in a fully developed application, the properties would be
    presented in a separate window or panel, but the principle is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ApplicationProperties` class is a helper class that manages the application
    properties, saving them to the appropriate location on the user's system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the contents of the `MainComponent.cpp` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we configure the `ApplicationProperties` object by passing it our desired
    application name and folder name (using the name that the Introjucer application
    will have generated in the `ProjectInfo::projectName` constant). We provide a
    filename suffix (for example, `settings`, `xml`). To support Mac OS X, it is recommended
    that you set the `PropertiesFile::Options::osxLibrarySubFolder` option since Apple
    changed their recommendation for the storage of application preferences. This
    was previously in `Library/Preferences`, but Apple now recommends that developers
    use `Library/Application Support`. This is provided for backwards compatibility;
    all new applications should set this to `Application Support`. This setting is
    harmless for other platforms. It is important to configure these options prior
    to using the `ApplicationProperties` object by passing the options via the `ApplicationProperties::setStorageParameters()`
    function. In fact, the `ApplicatonProperties` class maintains two sets of properties,
    one for all users and one for the current user. In this example we create only
    properties for the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application starts, it tries to access the value of the properties
    and set the label and slider appropriately. First, we access the user settings
    `PropertiesFile` object using the `ApplicationProperties::getUserSettings()` function.
    We store a pointer to the `PropertiesFile` object that this returns in a regular
    pointer, as it is owned by `ApplicationProperties` object, and we need it only
    temporarily. (Storing it in a `ScopedPointer` object in this case could cause
    a crash, since the `ScopedPointer` object would try eventually to delete an object
    that it should not really own, since it already has an owner.) Then we use the
    `PropertiesFile::getValue()` function to get the text value, and the `PropertiesFile::getDoubleValue()`
    function to get the double value (there are also the `PropertiesFile::getIntValue()`
    and `PropertiesFile::getBoolValue()` functions if needed). Of course, the first
    time the application starts, these properties will be empty. Each of these property
    accessors allows you to provide a default value, should the named property not
    exist. Here we provide `<empty>` as the default for the label contents and `0.0`
    as the default for the slider. When the application closes (in this case we know
    this is happening when the `MainContentComponent` destructor is called) we set
    the value of the properties to the current state of the label and the slider.
    This means that when we close the application and reopen it, the slider and the
    label should appear to retain their state between launches. Build and run the
    application and test this. The file generated by the `ApplicationProperties` object
    should look something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac OS X this should be in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**On Windows this should be in:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**where `USERNAME` is the name of the currently logged-in user.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# Adding menu bar controls'
  prefs: []
  type: TYPE_NORMAL
- en: JUCE offers a means of creating menu bar user interface controls, as you will
    have seen, using the Introjucer application, and in the JUCE Demo application
    in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and the Introjucer Application"),
    *Installing JUCE and the Introjucer Application*. These menu bars may be within
    a window on all platforms using JUCE's own `MenuBarComponent` class, or as a native
    menu bar at the top of the screen on Mac OS X. To demonstrate this we will add
    some special commands to the `Chapter05_04` project to reset the label and slider
    in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first requirement for constructing menu bars in JUCE is to create a **menu
    bar model** by creating a subclass of the `MenuBarModel` class. First add the
    `MenuBarModel` class as a base class for the `MainContentComponent` class in the
    `MainComponent.h` file as highlighted in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MenuBarModel` class has three pure virtual functions that will be used
    to populate the menu bar. To add these, add the following three lines to the `public`
    section of the `MainComponent.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getMenuBarNames()` function should return an array of menu names that
    will appear along the menu bar. The `getMenuForIndex()` function is used to create
    the actual menu when the user clicks on one of the menu bar names. This should
    return a `PopupMenu` object for a given menu (which can be determined using the
    menu index or its name). Each menu item should be given a unique ID value that
    is used to identify the menu item when it is selected. This is described in a
    moment. The `menuItemSelected()` function will be called when a user selects a
    particular menu item from one of the menus. Here you are provided with the ID
    value of the menu item that was selected (and the index of the menu that this
    menu item was in, if you really need this information). For convenience we should
    add these IDs as enumerated constants. Add the following code to the end of the
    `public` section of the `MainComponent.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the first item is given a value of `1000`; this is because an ID
    value of `0` (which is otherwise the default) is not valid as an ID. We need to
    store the `MenuBarComponent` object too. Add the code as highlighted below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainComponent.cpp` file, update the constructor for the `MainContentComponent`
    class as highlighted in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we pass the `this` pointer to the `MenuBarComponent` object in the initializer
    list. This is to tell the `MenuBarComponent` object which `MenuBarModel` to use.
    Update the `resized()` function in the `MainComponent.cpp` file to position the
    components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This positions the menu bar at the top of the window, filling the whole width
    of the window. Now we will add the menu bar functionality by implementing the
    virtual functions from the `MenuBarModel` class. Add the following code to the
    `MainComponent.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the top-level menu names by returning a `StringArray` object containing
    the names. Here we will have two menus, one to control the label, and the other
    to control the slider. Next, add the following code to the `MainComponent.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks which menu should be populated by inspecting the menu name. The
    **Label** menu will be filled with a single item that will be used to clear the
    label contents. The **Slider** menu will be filled with two items: one to set
    the slider to its minimum value, and one to set the slider to its maximum value.
    Notice that this is one place where we use the enumerated constants created earlier.
    Finally, add the following code to the `MainComponent.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here we check which menu ID was selected by the user and act accordingly. Build
    and run the application to check this functionality. An additional example project
    `Chapter05_04b` is provided in the code bundle that illustrates how to modify
    this example to use the native menu bar on the Mac OS X platform. A more sophisticated
    technique for implementing menu bars is to use the JUCE `ApplicationCommandManager`
    class, which is used by the JUCE Demo application and the Introjucer application
    code to present its menus, issue commands from buttons, and so on. Refer to the
    JUCE documentation for this class for a complete guide.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced a range of additional useful utilities for application
    development in JUCE. This included using the `ValueTree` class and related classes
    for structuring and storing application data and properties, and adding undo management.
    This chapter also looked at multithreading support in JUCE, and introduced one
    final user interface component for adding menu bar controls to JUCE applications.
    These really are the tip of the iceberg. It is rare to find a JUCE class that
    is difficult to integrate into your own code. You are encouraged to explore the
    JUCE documentation to find further classes that will support your development.
    The JUCE code and classes introduced in this book should have given you an insight
    into the idioms of JUCE code. This should make discovering and using new JUCE
    classes relatively straightforward.**
  prefs: []
  type: TYPE_NORMAL
