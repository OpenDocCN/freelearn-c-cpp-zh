- en: Understanding Graphics and Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形和动画简介
- en: Over the last 10 chapters, we have dived deeply into some of the most popular
    design patterns. The goal of each chapter was to understand and solve some common
    problems that everyone encounters when creating games. Along the way, we have
    created component-based game objects with flexible State-based, decision-making
    capabilities. We have created core engines such as the `StageManager` and `ObjectManager`
    using the Singleton pattern, so that communication between game objects, components,
    and engines is incredibly simple. We also looked at Object Pools and the Flyweight
    pattern, which allow our game to use memory more efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10章中，我们深入探讨了最流行的设计模式之一。每一章的目标都是理解和解决每个人在创建游戏时都会遇到的一些常见问题。在这个过程中，我们创建了具有灵活基于状态的决策能力的基于组件的游戏对象。我们使用单例模式创建了核心引擎，如`StageManager`和`ObjectManager`，以便游戏对象、组件和引擎之间的通信变得极其简单。我们还研究了对象池和享元模式，这些模式使我们的游戏能够更有效地使用内存。
- en: In this chapter, we will focus on graphics. However, we will not be focusing
    on how to implement a graphics engine. That would require more than a single chapter.
    Instead we will focus on concepts that need to be understood, regardless of which
    graphics **Application Programming Interface** (**API**) you use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于图形。然而，我们不会关注如何实现图形引擎。那需要不止一章。相反，我们将关注无论你使用哪个图形**应用程序编程接口（API**），都需要理解的概念。
- en: Graphics is a large part of any game engine and is very likely the performance
    bottleneck of the game. However, whether we are using DirectX, OpenGL, or some
    other graphics API, we must understand what is happening behind the scenes. We
    shouldn't fall into the trap of thinking that just because we didn't write the
    graphics API, there are no design decisions to be made.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图形是任何游戏引擎的重要组成部分，并且很可能成为游戏的性能瓶颈。然而，无论我们使用DirectX、OpenGL还是其他图形API，我们都必须了解幕后发生的事情。我们不应该陷入这样的陷阱，认为因为我们没有编写图形API，就没有设计决策要做。
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: This chapter is a little different than the ones before because it isn't focused
    on a design pattern. Instead we will focus on the low-level details of graphics
    so we can better understand how our code affects moving and animating our game
    objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与之前的不同，因为它不是专注于设计模式。相反，我们将关注图形的低级细节，以便更好地理解我们的代码如何影响移动和动画游戏对象。
- en: First, we will look at how a computer monitor works. We will dive into the details
    of pixels and screen resolutions. We will look at how pixels are drawn on screen
    as well as understand the concept of tearing, learn why we hear so much about
    **frames per second** (**fps**), and why games try to achieve 30 or 60 frames
    per second.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨计算机显示器的工作原理。我们将深入了解像素和屏幕分辨率。我们将查看像素如何在屏幕上绘制，以及理解撕裂的概念，了解为什么我们听到那么多关于**每秒帧数（fps**）的讨论，以及为什么游戏试图达到每秒30或60帧。
- en: Next, we will look at timing in games. We will learn why we want a consistent
    frame rate. We will also look at what happens when our frame rate isn't consistent
    and how we can ensure that our frame time stays consistent throughout the game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨游戏中的计时。我们将学习为什么我们希望有一个一致的帧率。我们还将查看当我们的帧率不一致时会发生什么，以及我们如何确保整个游戏中的帧时间保持一致。
- en: Your objectives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: Learn how computer monitors work and what a refresh rate is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习计算机显示器的工作原理以及刷新率是什么
- en: Learn about double buffering and why it is used for graphics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解双缓冲以及为什么它用于图形
- en: Learn about time-based movement and animation, and why we want a consistent
    frame rate
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解基于时间的移动和动画，以及为什么我们希望有一个一致的帧率
- en: Introduction to monitor refresh rates
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视器刷新率简介
- en: 'These days, flat screen **Liquid Crystal Display** (**LCD**) monitors are very
    common. However, to understand refresh rates and double buffering, we need to
    understand how older monitors display an image. Along the way, we will learn about
    common graphics terms, such as pixels and screen resolution:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，平面屏幕**液晶显示器（LCD**）非常常见。然而，为了理解刷新率和双缓冲，我们需要了解旧式显示器如何显示图像。在这个过程中，我们将学习一些常见的图形术语，如像素和屏幕分辨率：
- en: '![](img/00060.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: Figure 11.1 - Simplified cathode ray tube diagram
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 简化的阴极射线管图
- en: '**Cathode Ray Tube** (**CRT**) monitors contain screens with millions of tiny
    red, green, and blue phosphor dots. These dots glow for a short time when struck
    by an electron beam that travels across the screen to create an image. The *cathode*
    is a heated filament inside a vacuum sealed glass tube. The *ray* is a stream
    of electrons generated by an electron gun, which is directed by magnetic deflection
    plates. By adjusting the magnetic field of the plates, the electron beam can be
    moved around and adjusted to strike every part of the screen.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴极射线管**（**CRT**）显示器包含数百万个微小的红色、绿色和蓝色磷光点。这些点在电子束穿过屏幕以创建图像时短暂发光。**阴极**是真空密封玻璃管内的加热丝。**射线**是由电子枪产生的电子流，电子枪由磁偏转板控制。通过调整板的磁场，电子束可以移动并调整以击中屏幕的每个部分。'
- en: The screen is coated with phosphor, an organic material that glows for a short
    time when struck by the electrons. It contains many groups of red, green, and
    blue dots. By varying the intensity of the electron ray on each dot, different
    colors can be generated. For example, with red, green, and blue fired at maximum
    strength, the color white is produced.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕涂有磷光材料，这是一种有机材料，当被电子撞击时会短暂发光。它包含许多红色、绿色和蓝色的点组。通过改变每个点上的电子束强度，可以产生不同的颜色。例如，当红色、绿色和蓝色以最大强度发射时，产生白色。
- en: Since one color is produced by a group of red, green, and blue dots, the maximum
    number of these dot groups limits how many colors can be displayed horizontally
    or vertically. The diagonal distance between two dots of the same color is known
    as the dot pitch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一种颜色是由一组红色、绿色和蓝色的点产生的，因此这些点组的最大数量限制了水平或垂直方向上可以显示的颜色数量。相同颜色两点之间的对角距离称为点距。
- en: '![](img/00061.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: Figure 11.2 Close of view of the Pixel on the screen
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 屏幕上像素的近距离视图
- en: What is a pixel?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素是什么？
- en: A pixel, or *picture element*, is the basic unit of programmable color on a
    computer image or display. It is better to think about a pixel as a logical unit,
    rather than a physical unit. This is because the size of a pixel depends on the
    current resolution of the display screen. At the maximum resolution of the screen,
    one pixel maps exactly to one dot group. This means the size of a pixel at maximum
    resolution is equal to the dot pitch. Smaller resolutions will use more than one
    dot group to create a single color.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 像素，或称*图像元素*，是计算机图像或显示器上可编程颜色的基本单位。最好将像素视为一个逻辑单位，而不是物理单位。这是因为像素的大小取决于当前显示屏幕的分辨率。在屏幕的最大分辨率下，一个像素正好映射到一个点组。这意味着最大分辨率下像素的大小等于点距。较小的分辨率将使用多个点组来创建一个颜色。
- en: 'The resolution of the screen is the number of horizontal pixels multiplied
    by the number of vertical pixels, and is usually written as **width x height**.
    For example, a 640 x 480 resolution means that the screen is 640 pixels wide and
    480 pixels high for a total of 307,200 pixels. Of course, the color data for each
    pixel must be stored in computer memory, so a higher resolution uses more pixels
    and more memory. For example, if each pixel used one byte of memory, our 640 x
    480 display would need 300 kilobytes of memory. A 1280 x 1024 display would need
    1.25 megabytes. Let''s have a look at the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的分辨率是水平像素数乘以垂直像素数，通常写作**宽度 x 高度**。例如，640 x 480的分辨率意味着屏幕宽度为640像素，高度为480像素，总共307,200像素。当然，每个像素的颜色数据必须存储在计算机内存中，因此更高的分辨率使用更多的像素和更多的内存。例如，如果每个像素使用一个字节的内存，我们的640
    x 480显示器就需要300千字节的内存。1280 x 1024的显示器需要1.25兆字节。让我们看一下下面的屏幕截图：
- en: '![](img/00062.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: Figure 11.3 - An example of 800 x 600 screen resolution
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 800 x 600屏幕分辨率的示例
- en: The location in RAM that stores pixel color information is called the **framebuffer**.
    The framebuffer is written by a program and then transmitted to the monitor. The
    cathode ray interprets the pixel color and fires the electron ray at the proper
    intensity. The deflection plates direct the electron beam to the proper dot groups
    on the phosphor screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储像素颜色信息的RAM位置称为**帧缓冲区**。帧缓冲区由程序写入，然后传输到显示器。阴极射线管解释像素颜色并以适当的强度发射电子束。偏转板将电子束导向磷光屏上的适当点组。
- en: In the examples above, the size of each pixel was only 1 byte. However, a pixel
    can be, and usually is, more than 1 byte. As computers get faster and memory gets
    cheaper, we can use more bits per pixel. With 8-bit color, red and green each
    use 3 bits or a total of 8 levels of color each, while blue only uses 2 bits or
    4 levels. This totals 256 possible colors for each pixel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，每个像素的大小仅为1字节。然而，像素可以是，并且通常也是，超过1字节。随着计算机速度的提高和内存价格的降低，我们可以使用每像素更多的位。在8位色彩中，红色和绿色各自使用3位，总共8个色彩级别，而蓝色只使用2位，或4个级别。这为每个像素提供了256种可能的色彩。
- en: 16-bit color, or high color, offers a few different options. One possibility
    is 4 bits for each red, green, and blue. These 4 bits provide 16 levels for each
    color for a total of 4,096 (16 x 16 x 16) colors, with an optional 4 bits for
    transparency. Another possibility is 5 bits per color and 1 bit for transparency
    for a total of 32,768 colors. Finally, a total of 65,536 can be achieved with
    5 bits for both red and blue, and 6 bits for green.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 16位色彩，或称为高色彩，提供了一些不同的选项。一种可能性是每个红色、绿色和蓝色使用4位。这4位为每种颜色提供了16个级别，总共4,096种颜色（16
    x 16 x 16），还有一个可选的4位用于透明度。另一种可能性是每种颜色使用5位，透明度使用1位，总共32,768种颜色。最后，通过红色和蓝色各使用5位，绿色使用6位，总共可以达到65,536种颜色。
- en: True color is defined at 8 bits per color. This means that red, green, and blue
    all have 8 bits, or 256 possible color levels. If 24 bits are used, we get a total
    of 16,777,216 possible colors. These days, 32 bits per pixel are often used. The
    last 8 bits are for transparency. The transparency allows for different levels
    of blending with the background colors. This allows for a total of 4,294,967,295
    colors per pixel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 真实色彩是以每色8位来定义的。这意味着红色、绿色和蓝色各自都有8位，或者256种可能的色彩级别。如果使用24位，我们就能得到总共16,777,216种可能的色彩。如今，每像素32位的使用越来越普遍。最后的8位用于透明度。透明度允许与背景色彩进行不同级别的混合。这使得每个像素可以有总共4,294,967,295种色彩。
- en: The size of the framebuffer is calculated by multiplying the resolution and
    the numbers of bytes per pixels (color depth). For a game using a 1280 x 1024
    display, we need 1280 x 1024 x 4 bytes, or 5 megabytes for the framebuffer. This
    might not seem like much considering that modern computers often have 8 to 12
    gigabytes of RAM. However, it is worth remembering that if we are updating every
    pixel on screen, we are updating 1,310,720 pixels, or 5,242,880 bytes of data.
    This is assuming we only fill in each color one time and don't need to blend with
    overlapping colors.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区的大小是通过将分辨率乘以每像素字节数（色彩深度）来计算的。对于一个使用1280 x 1024分辨率的游戏，我们需要1280 x 1024 x 4字节，即5兆字节用于帧缓冲区。考虑到现代计算机通常有8到12GB的RAM，这可能看起来并不多。然而，值得记住的是，如果我们正在更新屏幕上的每个像素，我们正在更新1,310,720个像素，或者5,242,880字节的数据。这是假设我们只填充每种颜色一次，并且不需要与重叠颜色混合。
- en: The horizontal and vertical blank
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平和垂直空白
- en: The display is updated by reading data from the framebuffer and updating in
    sequence, starting from the left to right and top to bottom. We can think about
    this exactly as if we were iterating through a 2D array in C or C++. At the end
    of each scan line, the electron gun is adjusted to point at the start of the next
    scan line. Another adjustment must be made after the last pixel is lit so the
    beam can start again at the top.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显示器通过读取帧缓冲区中的数据并按顺序更新来刷新。我们可以将这个过程想象成在C或C++中迭代一个二维数组。在每一扫描行的末尾，电子枪会被调整以指向下一扫描行的起始位置。在最后一个像素被点亮之后，还需要进行一次调整，以便光束可以从顶部重新开始。
- en: 'The time it takes for the electron gun to move from the rightmost pixel of
    scan line *X* to the leftmost pixel of scan line *X + 1* is called the **Horizontal
    Blank Interval**. This is because the electron gun is blanked, meaning that it
    is outputting zero electrons during this interval. This is to prevent pixels from
    being lit up while traveling from scan line to scan line. Similarly, the time
    it takes for the electron gun to move from the end of the last scan line back
    up to the first scan line is called the **Vertical Blank Interval**. Again, the
    electron gun is blanked to prevent pixels from being lit up while traveling back
    to the top scan line. The Vertical Blank Interval is a short period where the
    entire display has been updated and the framebuffer is not currently being read
    by the display:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电子枪从扫描线X的最右侧像素移动到扫描线X + 1的最左侧像素所需的时间被称为**水平消隐间隔**。这是因为电子枪被消隐，意味着在此间隔内它输出零电子。这是为了防止像素在从扫描线到扫描线的移动过程中被点亮。同样，电子枪从最后一行扫描线的末端移动回第一行扫描线所需的时间被称为**垂直消隐间隔**。再次，电子枪被消隐以防止像素在返回顶部扫描线时被点亮。垂直消隐间隔是一个短暂的间隔，在此期间整个显示已经更新，并且帧缓冲区当前没有被显示器读取：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/00063.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00063.jpeg)'
- en: Figure 11.4-Showing the movement pattern of the electron gun including the Horizontal
    and Vertical Blank Intervals
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4-显示电子枪的运动模式，包括水平和垂直消隐间隔
- en: The phosphor dots on the screen are only lit up for a short period, so the electron
    gun must constantly relight them. The gun moves from left to right and top to
    bottom many times per second to refresh each pixel and display the correct image.
    If this process is too slow, the display will appear to flicker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的磷光点只会在短时间内被点亮，因此电子枪必须不断重新点亮它们。电子枪每秒从左到右和从上到下移动多次，以刷新每个像素并显示正确的图像。如果这个过程太慢，显示将看起来闪烁。
- en: Refresh rate
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新率
- en: The number of times per second a monitor refreshes the display is known as it's
    vertical refresh rate, or just refresh rate. The refresh rate of a monitor is
    measured in hertz (Hz). So, a monitor that can refresh the display 30 times per
    second has a refresh rate of 30 Hz. Many monitors refresh at 60 Hz, however, it
    is becoming common to see monitors with refresh rates of 120 Hz or even 240 Hz.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器每秒刷新显示的次数被称为其垂直刷新率，或者简称为刷新率。监视器的刷新率以赫兹（Hz）为单位进行测量。因此，每秒可以刷新显示30次的监视器具有30
    Hz的刷新率。许多监视器的刷新率为60 Hz，然而，具有120 Hz甚至240 Hz刷新率的监视器变得越来越常见。
- en: 'It is important to realize that the refresh rate of a monitor has nothing to
    do with the performance of a game or program. Having a monitor with a higher refresh
    rate will not improve the frame rate of a game, unless the game itself can support
    higher frame rates. The number of times a program updates the framebuffer is measured
    in frames per second or fps, and is completely independent from the number of
    times the monitor refreshes. When these two numbers are out-of-sync, the display
    will not look correct. Let''s look at the problem of when the frames per second
    is less than the refresh rate:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到监视器的刷新率与游戏或程序的性能无关。拥有更高刷新率的监视器不会提高游戏的帧率，除非游戏本身可以支持更高的帧率。程序更新帧缓冲区的次数以每秒帧数或fps来衡量，并且与监视器刷新的次数完全独立。当这两个数字不同步时，显示将不会正确。让我们看看当每秒帧数少于刷新率时的问题：
- en: '![](img/00064.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00064.jpeg)'
- en: Figure 11.5 Comparing FPS versus Refresh Rate
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 比较帧率与刷新率
- en: These days, TV shows and movies are often displayed at 24 frames per second
    while the TV sets and monitors have a typical refresh rate of 60 Hz. In *Figure
    11.5*, we have taken one second and split it into 60 red bars on the top to represent
    our refresh rate and 24 blue bars on the bottom to represent the frames of a movie.
    Each red bar represents the 1/60th of a second that the frame will be on screen.
    Each vertical dark red line represents when the monitor is refreshed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，电视节目和电影通常以每秒24帧的速度播放，而电视和监视器的典型刷新率为60 Hz。在*图11.5*中，我们将一秒分成60个顶部的红色条来表示我们的刷新率，以及24个底部的蓝色条来表示电影的帧。每个红色条代表帧将在屏幕上显示的1/60秒。每根垂直深红色线代表监视器刷新的时刻。
- en: 'As you can see, the refresh periods do not line up properly with the frames
    of the movie. In *Figure 11.5* we can clearly see that **Frame 1** is on screen
    for 3/60th (or 1/20th) of a second, while **Frame 2** is only on screen for 2/60th
    (or 1/30th) of a second. **Frame 1** is on screen longer than the original 1/24th
    of a second and **Frame 2** is on screen less. Since the frames are not on screen
    for an equal amount of time, the video seems jittery. While this may not seem
    like much of a difference, some people are sensitive enough to notice a slight
    speeding up and slowing down effect:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，刷新周期与电影的帧并不正确对齐。在*图11.5*中，我们可以清楚地看到**帧1**在屏幕上持续了3/60秒（或1/20秒），而**帧2**只在屏幕上持续了2/60秒（或1/30秒）。**帧1**在屏幕上的持续时间比原始的1/24秒长，而**帧2**则短。由于帧在屏幕上显示的时间不等，视频看起来会有抖动。虽然这可能看起来差别不大，但有些人足够敏感，能注意到轻微的加速和减速效果：
- en: '![](img/00065.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: Figure 11.6 - Example of refresh rate and frames per second Out-Of-Sync
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 刷新率和帧每秒不同步的示例
- en: TVs and movies have ways of adjusting for this problem, such as interpolating
    between frames. Since **Frame 1** and **Frame 2** are already known, it is easy
    to blend, interpolate, and generate intermediate frames before displaying them.
    However, that doesn't help us when our games are out-of-sync with the monitor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 电视和电影有调整这种问题的方法，比如在帧之间进行插值。由于**帧1**和**帧2**已经知道，混合、插值和生成显示前的中间帧很容易。然而，这并不能帮助我们当我们的游戏与显示器不同步时。
- en: Since games are interactive, the player's actions determine what will be displayed
    next on screen. The details of **Frame 2** are determined by player input in response
    to **Frame 1**. This means that the contents of the framebuffer must be generated
    each frame, it can't be known ahead of time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏是交互式的，玩家的动作决定了屏幕上接下来将显示的内容。**帧2**的细节由玩家对**帧1**的输入决定。这意味着帧缓冲区的内容必须每帧生成，不能提前知道。
- en: In the above example, we were simplifying a little by pretending that writing
    to the framebuffer was instantaneous. Of course, this isn't true. Even though
    the next frame of a movie is already known, it still takes time to write to the
    framebuffer. Unless we can copy to the framebuffer completely during the Vertical
    Blank Interval, we will need to write to the framebuffer while the display is
    being drawn on screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们通过假设写入帧缓冲区是瞬时的来简化问题。当然，这并不真实。即使电影的下一帧已经知道，写入帧缓冲区仍然需要时间。除非我们能在垂直空白间隔期间完全复制到帧缓冲区，否则我们将在屏幕上绘制显示时写入帧缓冲区。
- en: 'If we can time everything correctly, we can always write a pixel just after
    the electron gun has read it. However, if we are out-of-sync with the electron
    gun, eventually there will be a point when we haven''t written the pixel for the
    current frame and the electron gun reads the old value. Let''s look at this problem
    up close:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能正确地安排时间，我们总是可以在电子枪读取像素后立即写入像素。然而，如果我们与电子枪不同步，最终会有一个点我们没有为当前帧写入像素，而电子枪读取了旧值。让我们近距离看看这个问题：
- en: '![](img/00066.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: Figure 11.7 - Start position (Left) and End position (Right) in the framebuffer
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 帧缓冲区中的起始位置（左）和结束位置（右）
- en: '*Figure 11.7* shows what we would like to see on screen. The left image is
    the position of a game object in frame 1\. The right image is the ending position
    after the object has moved. These are two discrete points in time that we want
    to show. However, if the display is reading the pixels as we are writing them
    to the framebuffer, we can see a tearing effect if we haven''t finished writing
    the current frame:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.7*展示了我们希望在屏幕上看到的内容。左图是帧1中游戏对象的位置。右图是对象移动后的结束位置。这是我们想要展示的两个不同时间点。然而，如果显示在读取我们写入帧缓冲区的像素时，如果我们没有完成当前帧的写入，我们就会看到撕裂效果：'
- en: '![](img/00067.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: Figure 11.8 - Example of tearing in the framebuffer
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 帧缓冲区中的撕裂示例
- en: As we can see in *Figure 11.8*, the first image is correct. We are writing to
    a pixel after the display has read it. In the second image, the pixel being read
    has almost caught up to the pixel that is being written. At this point, the framebuffer
    contains half of each image. The third image shows that the display has overtaken
    the write pixel. The correct pixels have been written but they were written too
    late. The fourth image shows what the user would see on screen. Since the display
    read faster than the pixels could be written, the image looks as if it has been
    torn in half. This effect is known as tearing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图11.8*所示，第一幅图像是正确的。我们在显示读取像素之后写入像素。在第二幅图像中，正在读取的像素几乎赶上了正在写入的像素。在这个时候，帧缓冲区包含每幅图像的一半。第三幅图像显示显示已经超过了写入像素。正确的像素已经写入，但它们写入得太晚了。第四幅图像显示了用户会在屏幕上看到的内容。由于显示读取速度比像素写入速度快，图像看起来像被撕裂成两半。这种效果被称为撕裂。
- en: Tearing occurs when our frames per second and our refresh rate are out-of-sync.
    Unfortunately, it can be very difficult to get these two values perfectly aligned,
    and being a little off will cause some tearing. To solve this problem, we need
    to write out an entire frame of pixels before the display reads them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的每秒帧数和刷新率不同步时，就会发生撕裂。不幸的是，要使这两个值完全对齐可能非常困难，稍微偏离就会导致一些撕裂。为了解决这个问题，我们需要在显示读取之前输出整个帧的像素。
- en: Double buffering
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双缓冲
- en: The solution to our read/write problem is double buffering. Double buffering
    is exactly what it sounds like. Instead of using only one framebuffer, we will
    use two: one for reading and one for writing. Of course, since we now have two
    framebuffers, we need twice the memory. For a 1280 x 1024 display using 4 bytes
    per pixel, we need 5 megabytes per framebuffer for a total of 10 megabytes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们的读写问题的方法是双缓冲。双缓冲正是其名称所暗示的。我们不会只使用一个帧缓冲区，而是使用两个：一个用于读取，一个用于写入。当然，由于我们现在有两个帧缓冲区，我们需要两倍的内存。对于一个1280
    x 1024的显示器，每像素使用4字节，我们需要每个帧缓冲区5兆字节，总共10兆字节。
- en: Everything up to this point could have been implemented in software by using
    operating system commands. However, as displays started requiring more memory
    and more complex images, special hardware was created. Modern graphics cards can
    contain gigabytes of memory used for framebuffers, textures, 3D triangle meshes,
    and much more. They can also contain hundreds or even thousands of cores to transform
    3D points into pixel data simultaneously.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些都可以通过使用操作系统命令在软件中实现。然而，随着显示器对内存和更复杂图像的需求增加，专门硬件被创建出来。现代显卡可以包含用于帧缓冲区、纹理、3D三角形网格等的大量内存。它们还可以包含数百甚至数千个核心，以同时将3D点转换为像素数据。
- en: It is important to understand this because, as a programmer, you don't need
    to implement double buffering yourself. It is implemented at a hardware level
    and our games will be double buffered automatically by using a 3D graphics API
    such as DirectX or OpenGL. However, we still need to understand how this process
    works so we can understand the implications to our frame rate.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要，因为作为一个程序员，你不需要自己实现双缓冲。这是在硬件级别实现的，并且我们的游戏将通过使用DirectX或OpenGL等3D图形API自动实现双缓冲。
- en: The back buffer
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后缓冲区
- en: As we said, double buffering works by using two framebuffers so that we are
    never setting pixels on the same buffer that is being used for the display. The
    framebuffer that is currently being displayed is called the front buffer or primary
    buffer, and the framebuffer that we are drawing to is called the back buffer or
    secondary buffer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，双缓冲是通过使用两个帧缓冲区来实现的，这样我们永远不会在用于显示的同一缓冲区上设置像素。当前正在显示的帧缓冲区称为前缓冲区或主缓冲区，而我们正在绘制的帧缓冲区称为后缓冲区或辅助缓冲区。
- en: 'When drawing is completed on the back buffer, the buffers are swapped so that
    the back buffer is now the front buffer and the front buffer is now the back buffer.
    Of course, the buffers themselves are not swapped. Instead, pointers to the buffers
    are swapped. The monitor has a pointer to one buffer and is currently reading
    it. The graphics card has a pointer to another buffer that it uses for all draw
    operations. This pointer swap, or page flipping as it is sometimes called, is
    much faster than copying data from the back buffer to the front buffer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当后缓冲区上的绘图完成时，缓冲区会进行交换，使得后缓冲区现在成为前缓冲区，而前缓冲区现在成为后缓冲区。当然，缓冲区本身并没有交换。相反，缓冲区的指针进行了交换。显示器有一个指向一个缓冲区的指针，并且目前正在读取它。显卡有一个指向另一个缓冲区的指针，它用于所有的绘图操作。这种指针交换，或者称为页面翻转（有时也这么叫），比从后缓冲区复制数据到前缓冲区要快得多：
- en: '![](img/00068.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: Figure 11.9 - Example of double buffering
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 双缓冲示例
- en: 'As you can see in the next two images, the display can read the front buffer
    while the graphics processing unit or GPU draws to the back buffer. However, there
    is nothing about double buffering that has prevented tearing. We have prevented
    drawing to the same buffer that is being displayed but, if we swap buffers in
    the middle of a screen refresh, we will still have tearing. This is an important
    first step in solving the tearing problem. However, before we solve it, let''s
    talk about what happens when we are out-of-sync with the monitor refresh rate
    because we are generating too many frames per second:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在接下来的两张图片中可以看到，显示器可以在图形处理单元或GPU绘制到后缓冲区的同时读取前缓冲区。然而，双缓冲并没有阻止撕裂现象。我们已经防止了对正在显示的同一缓冲区进行绘图，但如果我们在屏幕刷新过程中交换缓冲区，我们仍然会有撕裂现象。这是解决撕裂问题的关键第一步。然而，在我们解决这个问题之前，让我们谈谈当我们与显示器刷新率不同步时会发生什么，因为我们每秒生成太多的帧：
- en: '![](img/00069.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: Figure 11.10 - Double buffering after the page flip
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 - 页面翻转后的双缓冲
- en: 'Imagine the situation in which our game is generating 90 frames per second.
    This is 30 frames more than we need to achieve 1 frame per refresh. This means
    we are wasting time creating frames that will never be seen. At 90 frames per
    second, one third of the frames will never be seen by the player. As you can see
    in *Figure 11.11*, every third frame, which is highlighted in green, will be skipped
    because it falls between two refresh intervals. Even more frames will be skipped
    if we are updating at 120 fps or more:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们的游戏每秒生成90帧的情况。这意味着比我们为了每刷新一次生成一帧所需的帧数多出30帧。这意味着我们在浪费时间创建永远不会被看到的帧。在每秒90帧的情况下，三分之一的帧永远不会被玩家看到。正如您在*图11.11*中可以看到的，每第三帧，用绿色突出显示，将被跳过，因为它位于两个刷新间隔之间。如果我们以每秒120帧或更快的速度更新，将跳过的帧数会更多：
- en: '![](img/00070.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: Figure 11.11 - Comparing 60 Hz refresh with 90 fps
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 - 比较60 Hz刷新率与90 fps
- en: At 90 frames per second, every frame takes 1/90th of a second to complete. From
    the player's perspective, the third frame that gets shown (which is really our
    fourth frame) has been updated for a total of 1/45th of a second, or double the
    amount of time. Just like with the movie at 24 fps, this can cause a jittery effect
    that some players may notice because all objects will appear to have moved twice
    as far.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在每秒90帧的情况下，每一帧需要1/90秒来完成。从玩家的角度来看，显示的第三帧（实际上是我们第四帧）已经更新了总共1/45秒，或者说是一倍的时间。就像24
    fps的电影一样，这可能会引起一些玩家注意到的颤动效果，因为所有物体看起来都移动了两次那么远。
- en: When updating this many times per second, these time slices are very small.
    It is possible that they are so small that they may go unnoticed by the player.
    The real problem with skipping frames is that our game is doing work that it just
    doesn't need to. Since the frame will never be seen by the player, there is no
    point in wasting game time generating it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当每秒更新这么多次时，这些时间片非常小。它们可能小到玩家可能注意不到。跳帧的真正问题是我们的游戏正在做它根本不需要做的工作。由于帧永远不会被玩家看到，因此没有必要浪费时间生成它。
- en: It is worth pointing out that only the graphics part of the update is wasted.
    It is perfectly fine to update input, AI, or physics faster than the monitor can
    refresh. In fact, physics will be more accurate if the time step is smaller. We
    just want to really emphasize that there is absolutely no reason to draw frames
    faster than the monitor's refresh rate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，只有更新图形的部分是浪费的。更新输入、AI或物理速度超过显示器刷新速度是完全正常的。事实上，如果时间步长更小，物理会更准确。我们只是想强调，绝对没有理由比显示器的刷新率更快地绘制帧。
- en: For most games this is never a problem. The usual solution to having a high
    frame rate is to do more work and make your game more interesting. If your game
    is too fast, draw more particles, have more enemies, calculate more accurate physics,
    or just do more physics effects. If you find that your game runs faster than 60
    fps, your game probably isn't the best it could be. Again, there is no reason
    to draw more frames per second than can appear on screen.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数游戏来说，这从来不是问题。提高帧率的通常解决方案是做更多的工作，使你的游戏更有趣。如果你的游戏运行速度超过60 fps，你的游戏可能不是最好的。再次强调，没有必要每秒绘制比屏幕上能显示的更多的帧。
- en: VSync
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VSync
- en: So now we have seen both situations where our frame count is out-of-sync with
    our refresh rate. In both cases we can have tearing, and in the case of a very
    high frame rate, we are wasting CPU/GPU cycles that could be used to improve our
    game. We want to avoid tearing. We want to be in-sync with the monitor refresh.
    How can we solve this problem?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经看到了两种情况，其中我们的帧计数与刷新率不同步。在这两种情况下，我们都可能遇到撕裂，在帧率非常高的情况下，我们浪费了CPU/GPU周期，这些周期本可以用来改进我们的游戏。我们想要避免撕裂。我们想要与显示器的刷新同步。我们如何解决这个问题？
- en: The solution is the Vertical Blank Interval. Remember that the Vertical Blank
    Interval is when the electron gun is repositioning itself from the last pixel
    on the display back to the first pixel. During this short period, the entire display
    has been drawn and the front buffer isn't being used. This period is too short
    to copy all the contents of the back buffer to the front buffer. However, it is
    long enough to swap the pointers, which is how the page flipping mechanism works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是垂直空白间隔。记住，垂直空白间隔是电子枪从显示器的最后一个像素重新定位到第一个像素的时候。在这段短暂的时间内，整个显示已经绘制完成，并且前缓冲区没有被使用。这个时间段太短，无法复制后缓冲区的内容到前缓冲区。然而，它足够长，可以交换指针，这就是页面翻转机制的工作原理。
- en: Modern computer monitors and TVs can send a signal back to the computer when
    the Vertical Blank, Interval, or V-Blank occurs. The graphics card waits until
    a V-Blank before swapping the buffers after the back buffer is completely drawn.
    This guarantees that there will never be tearing because parts of different frames
    can never be read in a single refresh.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机显示器和电视可以在垂直空白间隔或V-Blank发生时向计算机发送信号。显卡在完全绘制后缓冲区后，会等待V-Blank信号再交换缓冲区。这保证了永远不会出现撕裂，因为不同帧的部分永远不会在单个刷新中被读取。
- en: As we said, double buffering is implemented at the hardware level. This is also
    true of synchronizing with the Vertical Blank Interval. By using a 3D graphics
    API such as DirectX or OpenGL, you get this for free. This V-Blank syncing or
    VSync is an option that must be enabled when initializing graphics. Once VSync
    is turned on, we don't need to worry about tearing. Additionally, the game will
    never generate more than one frame per monitor refresh because the graphics card
    will always wait for the V-Blank signal before swapping the buffers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，双缓冲是在硬件级别实现的。与垂直空白间隔同步也是如此。通过使用DirectX或OpenGL等3D图形API，你可以免费获得这个功能。这种V-Blank同步或VSync是在初始化图形时必须启用的一个选项。一旦VSync开启，我们就不必担心撕裂现象。此外，游戏永远不会在每帧刷新时生成超过一个帧，因为显卡总是在交换缓冲区之前等待V-Blank信号。
- en: Syncing with the refresh rate of the monitor is a great way to prevent tearing.
    If a game can update 60 or more times a second, the back buffer and the front
    buffer will always be able to swap and we will have a smooth, tear-free game.
    However, we haven't talked about what happens if the back buffer isn't ready to
    be swapped because the frame is taking longer than 1/60^(th) of a second to complete.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与显示器刷新率同步是防止撕裂的好方法。如果一个游戏每秒可以更新60次或更多，后缓冲区和前缓冲区将始终能够交换，我们将有一个平滑、无撕裂的游戏。然而，我们还没有讨论如果后缓冲区没有准备好交换，因为帧完成所需时间超过1/60秒会发生什么。
- en: It is important to understand that the front and back buffers do not swap automatically
    every time the V-Blank signal arrives. Instead, the swap is performed at the request
    of the programmer. A function call is made to tell the graphics card that a new
    frame is prepared and the buffers should be swapped. This swap will happen immediately
    if VSync is turned off. However, if the VSync is turned on, the graphics card
    will wait for the V-Blank signal to arrive, no matter how long that is. If our
    update is just 1/100th slower, meaning a frame takes 1/59^(th) of a second to
    complete, we will miss the V-Blank and need to wait for the next one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，每次V-Blank信号到来时，前后缓冲区并不会自动交换。相反，交换是在程序员的请求下进行的。通过函数调用通知显卡已准备了一个新帧，并且应该交换缓冲区。如果关闭了VSync，这种交换将立即发生。然而，如果启用了VSync，显卡将等待V-Blank信号到来，无论这个时间有多长。如果我们的更新只是慢了1/100，意味着一个帧需要1/59秒来完成，我们将错过V-Blank并需要等待下一个。
- en: Since the current frame wasn't ready, the monitor displays the previous frame
    again. The same frame will be on screen for 1/30th of a second. Since the back
    buffer must wait to be swapped until the next V-Blank, our game can't start working
    on the next frame. Our game is idle while waiting for the V-Blank. This means
    that if our game is using VSync and it can't achieve 60 frames per second, our
    frame rate will drop down to 30 frames per second. If our game can't achieve 30
    frames per second, our frame rate will take 3/60th of a second, or 20 fps.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前帧尚未准备好，显示器再次显示上一帧。相同的帧将在屏幕上显示1/30秒。由于后缓冲区必须等待到下一个V-Blank才能交换，我们的游戏无法开始处理下一帧。我们的游戏在等待V-Blank时处于空闲状态。这意味着如果我们的游戏使用VSync并且无法达到每秒60帧，我们的帧率将下降到每秒30帧。如果我们的游戏无法达到每秒30帧，我们的帧率将降低到3/60秒，或20
    fps。
- en: For some programmers and some games, achieving 30 frames per second is perfectly
    fine. To implement more beautiful effects or more accurate physics, dropping to
    30 frames per second might be an important trade off. Everyone must decide for
    their own game what is right. However, many players simply do not like 30 frames
    per second. Players often say they can notice more jittery movement and more importantly,
    they notice input lag.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些程序员和一些游戏来说，达到每秒30帧是完全可行的。为了实现更美丽的效果或更精确的物理效果，降低到每秒30帧可能是一个重要的权衡。每个人必须决定他们自己的游戏什么才是正确的。然而，许多玩家根本不喜欢每秒30帧。玩家经常说他们可以注意到更多的抖动运动，更重要的是，他们注意到输入延迟。
- en: Remember, if we can't achieve our goal of 60 fps, the graphics card must wait
    for the next V-Blank before returning from the swap call. This means that our
    game can't process physics, AI, or even input. The player is seeing half as many
    frames on screen, which means objects are moving more each frame. Additionally,
    input is now being gathered from the player once every 1/30th of a second instead
    of once every 1/60th of a second. While this may not seem like much, for fast,
    twitch response games such as *First Person Shooters*, this can be too long.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我们无法达到60 fps的目标，显卡必须在返回交换调用之前等待下一个V-Blank。这意味着我们的游戏无法处理物理、AI甚至输入。玩家在屏幕上看到的帧数减半，这意味着物体在每一帧中移动得更多。此外，输入现在每1/30秒而不是每1/60秒从玩家那里收集一次。虽然这看起来可能不多，但对于像*第一人称射击*这样的快速反应游戏来说，这可能太长了。
- en: '*Figure 11.12* shows an example of the contents of both the front and back
    buffers in a VSync scenario where a game can''t update at the same rate as the
    monitor. The display refreshes every 1/60th of a second or every 0.0167 seconds.
    The game can update every 1/50th of a second or every 0.02 seconds. In the image
    below, the monitor refreshes are colored red or green. The red refreshes are when
    the game frame isn''t ready and so the previous frame is displayed. The green
    refreshes are when the game frame is ready and so the buffers are swapped.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.12* 展示了在VSync场景下前后缓冲区内容的一个示例，其中游戏无法以与显示器相同的速率更新。显示每1/60秒或每0.0167秒刷新一次。游戏可以每1/50秒或每0.02秒更新一次。在下面的图像中，显示器的刷新被涂成红色或绿色。红色刷新表示游戏帧尚未准备好，因此显示的是上一帧。绿色刷新表示游戏帧已准备好，因此缓冲区被交换。'
- en: 'The blue represents when the game frame is completed. This doesn''t mean that
    the new frame is instantly displayed. This is because the graphics card waits
    until the next refresh to swap buffers. It is important to understand that the
    game doesn''t update every 1/50th of a second for the same reason. Instead, each
    game update is 1/50th of a second after the last buffer swap:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色代表游戏帧完成的时间。这并不意味着新帧会立即显示。这是因为显卡会等待到下一次刷新来交换缓冲区。重要的是要理解，游戏不会每1/50秒更新一次，原因相同。相反，每个游戏更新都是在最后一次缓冲区交换后的1/50秒：
- en: '![](img/00071.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: Figure 11.12 - Showing contents of back buffer and front buffer when using VSync
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 - 使用VSync时显示后缓冲区和前缓冲区的内容
- en: Triple buffering
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三缓冲
- en: Turning on VSync in our games can improve the look of our graphics because we
    are guaranteed that tearing will never occur. Unfortunately, if our game frame
    isn't completed in time for the next refresh, the graphics card waits until the
    next V-Blank to swap buffers. This is true even if our game misses the refresh
    by only 1/100th of a second. If our frame is off by this short amount, our fps
    drops to 30\. This is because the content of the back buffer hasn't been swapped
    yet, so we can't start drawing the next frame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中开启VSync可以提高图形的外观，因为我们保证撕裂永远不会发生。不幸的是，如果我们的游戏帧没有及时完成下一次刷新，显卡会等待到下一个V-Blank来交换缓冲区。即使我们的游戏只错过了1/100秒的刷新，这也是正确的。如果我们的帧偏移了这么短的时间，我们的fps会降到30。这是因为后缓冲区的内容还没有被交换，所以我们不能开始绘制下一帧。
- en: It would be nice if we could start drawing the next frame while still waiting
    for the V-Blank signal. To do this, we would need an extra framebuffer to draw
    to while we are waiting. This is exactly how triple buffering works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在等待V-Blank信号的同时开始绘制下一帧，那将很理想。为了做到这一点，我们需要一个额外的帧缓冲区来在等待时绘制。这正是三缓冲的工作方式。
- en: For triple buffering we have a total of three framebuffers. For a 1280 x 1024
    display with 4 bytes per pixel we would need a total of 15 megabytes. However,
    by using this extra memory, we will always have a framebuffer to draw to, so we
    should always be able to hit our fps goal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三缓冲，我们总共有三个帧缓冲区。对于一个1280 x 1024的显示，每个像素4字节，我们需要总共15兆字节。然而，通过使用额外的内存，我们总是有一个缓冲区可以绘制，所以我们应该总是能够达到我们的fps目标。
- en: 'In triple buffering, we have our primary and secondary buffers just like before
    but now we have a tertiary buffer as well. We start out drawing to the back buffer.
    If we finish the current frame before the refresh, we can immediately move on
    to drawing on the tertiary buffer. If we don''t finish in time for the refresh
    we will need to wait for the next refresh, just as we did in the double buffer
    scenario. However, we only need to miss a refresh this one time. Once the back
    buffer is filled, we can immediately start working on the tertiary buffer. Either
    way, once the back buffer has been filled, we will be forever one frame ahead.
    The primary buffer will be used for display, the secondary buffer will be ready
    and waiting for the swap, and the graphics card will use the tertiary buffer for
    drawing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在三缓冲中，我们仍然有主缓冲区和辅助缓冲区，但现在我们还有一个三级缓冲区。我们首先开始绘制到后缓冲区。如果我们能在刷新之前完成当前帧，我们就可以立即开始绘制到三级缓冲区。如果我们没有及时完成，需要等待下一次刷新，就像在双缓冲场景中一样。然而，我们只需要错过一次刷新。一旦后缓冲区被填满，我们就可以立即开始处理三级缓冲区。无论如何，一旦后缓冲区被填满，我们就会永远领先一帧。主缓冲区将用于显示，辅助缓冲区将准备好并等待交换，而显卡将使用三级缓冲区进行绘制：
- en: '![](img/00072.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: Figure 11.13 - Drawing to the tertiary buffer before the V-Blank
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 - 在V-Blank之前绘制到三级缓冲区
- en: 'When the V-Blank occurs, all the buffers can swap if they are ready. The secondary
    buffer becomes the primary buffer for display. The tertiary buffer becomes the
    secondary buffer and waits to be displayed. Finally, the primary buffer becomes
    the new tertiary buffer used for drawing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生V-Blank时，如果所有缓冲区都准备好了，它们可以交换。辅助缓冲区成为主缓冲区用于显示。三级缓冲区成为辅助缓冲区并等待显示。最后，主缓冲区成为新的三级缓冲区，用于绘制：
- en: '![](img/00073.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: Figure 11.14 - Scenario 1 - Swapping all buffers after V-Blank
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 - 场景1 - 在V-Blank之后交换所有缓冲区
- en: 'If the tertiary buffer isn''t ready at the time of the V-Blank, it continues
    drawing until the frame is completed and can swap with the original primary buffer
    without waiting for the V-Blank:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在V-Blank时三级缓冲区没有准备好，它会继续绘制直到帧完成，并且可以与原始主缓冲区交换而不需要等待V-Blank：
- en: '![](img/00074.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: Figure 11 15 - Scenario 2A - Swap primary and secondary buffers after V-Blank
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 - 场景2A - 在V-Blank之后交换主缓冲区和次级缓冲区
- en: 'By using triple buffering, we solve the problem of suddenly dropping from 60
    fps to 30 fps when there are a few slow frames in our game. This also allows us
    to avoid the drop to 30 fps and (almost) consistently achieve 60 fps in cases
    which are just below 60, since we don''t need wait until a V-Blank before we can
    start the next frame:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用三缓冲，我们解决了游戏中有几个慢帧时突然从60帧每秒降到30帧每秒的问题。这也允许我们在情况略低于60帧每秒时避免降到30帧每秒，并且（几乎）持续达到60帧每秒，因为我们不需要等到V-Blank才能开始下一帧：
- en: '![](img/00075.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.jpeg)'
- en: Figure 11.16 - Scenario 2B - Swap secondary and tertiary buffers when drawing
    is complete
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 - 场景2B - 绘制完成后交换次级缓冲区和三级缓冲区
- en: 'However, as you can see in *Figure 11.17*, triple buffering still has the chance
    to miss a refresh. Using the same case as before where our game updates at 1/50th
    of a second and the monitor refreshes at 1/60th of a second, we still miss one
    out of every six refreshes. It should come as no surprise that the lower our frame
    rate, the more refreshes we will miss. If each of our frames takes 1/30th of a
    second or more to complete, we can''t expect to achieve 60 fps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如*图11.17*所示，三缓冲仍然有可能错过刷新。使用之前相同的案例，我们的游戏以每秒1/50秒的速度更新，而显示器以每秒1/60秒的速度刷新，我们仍然会错过每六个刷新中的一个。当帧率越低时，我们错过的刷新次数越多，这并不令人惊讶。如果我们每个帧需要1/30秒或更长时间才能完成，我们无法期望达到60帧每秒：
- en: '![](img/00076.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: Figure 11.17 - Example of missing the refresh when using triple buffering
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 - 使用三缓冲错过刷新的示例
- en: Even though triple buffering allows us to avoid tearing while maintaining 60
    fps, there is an important factor that you must consider before deciding to use
    it. There is a two-frame delay between what has just appeared on screen and the
    current frame being processed. Triple buffering allows us to process another frame
    in the tertiary buffer while the next frame in the secondary buffer is waiting
    to be displayed, all while the primary buffer is currently being displayed. This
    puts us one frame ahead so we can avoid frame rate drop, but lowers response time
    for the player.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管三缓冲可以让我们在保持60帧每秒的同时避免撕裂，但在决定使用它之前，你必须考虑一个重要的因素。屏幕上刚刚出现的内容和当前正在处理的帧之间存在两帧的延迟。三缓冲允许我们在次级缓冲区等待显示下一帧的同时，在三级缓冲区处理另一个帧，而此时主缓冲区正在显示。这使得我们领先一帧，从而可以避免帧率下降，但降低了玩家的响应时间。
- en: If the jump button is pressed, the player avatar won't appear to jump until
    the current frame and the next frame have been displayed. This is because the
    frame being processed, including game object responses to input, is being put
    into the tertiary buffer. If the primary and secondary buffers are on screen for
    1/60th of a second each, there will be an effective lag of 1/30th of a second
    for player input. The game will look like it is running at 60 fps (because it
    is), physics will behave like the game is running at 60 fps (because it is), but
    because of the input delay, the game will feel like it is running at 30 fps.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下跳跃按钮，玩家角色不会立即跳跃，直到当前帧和下一帧都已被显示。这是因为正在处理的帧，包括游戏对象对输入的响应，正被放入三级缓冲区。如果主缓冲区和次级缓冲区在屏幕上各显示1/60秒，那么玩家输入将会有1/30秒的有效延迟。游戏看起来就像是以60帧每秒的速度运行（因为它确实是），物理行为就像游戏是以60帧每秒的速度运行（因为它确实是），但由于输入延迟，游戏感觉就像是以30帧每秒的速度运行。
- en: It is up to you to decide what is best for your game. Many players may not even
    notice the input lag because the time slice is so small. However, for fast twitch
    games such as first person shooters, or games that require precision control for
    jumping or steering, this may be unacceptable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由你决定什么最适合你的游戏。许多玩家可能甚至不会注意到输入延迟，因为时间间隔非常小。然而，对于像第一人称射击游戏或需要精确控制跳跃或转向的游戏来说，这可能是不可以接受的。
- en: LCD monitors
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 液晶显示器
- en: We spent a lot of time talking about how Cathode Ray Tube monitors work. This
    was important so that we could understand the Vertical Blank interval and how
    it relates to double buffering. However, it seems a little outdated since LCD
    and LED monitors are much more common. We aren't going to discuss how these two
    types of monitors work, because it has no effect on our frame rate. What is important
    is that these monitors fake the V-Blank signal. Even though they don't need to
    refresh and have no electron gun, they still send a fake signal to the graphics
    card. This way, your program can still be locked with the *refresh* rate of the
    monitor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间讨论阴极射线管（CRT）显示器的工作原理。这是很重要的，这样我们才能理解垂直空白间隔以及它与双缓冲的关系。然而，由于液晶（LCD）和LED显示器更为常见，这似乎有点过时。我们不会讨论这两种类型显示器的工作原理，因为这对我们帧率没有影响。重要的是，这些显示器会模拟V-Blank信号。即使它们不需要刷新并且没有电子枪，它们仍然会向显卡发送一个模拟信号。这样，你的程序仍然可以与显示器的**刷新**率锁定。
- en: Time-based movement and animation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时间的移动和动画
- en: We have covered a lot so far in this chapter. We have been looking at the frame
    rate and refresh rate so we can understand how it relates to what is displayed
    on screen. However, the frame rate of a game has the chance to impact upon every
    engine of the game. It can even affect testing and debugging during development.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本章中涵盖了大量的内容。我们一直在研究帧率和刷新率，以便理解它们与屏幕上显示的内容之间的关系。然而，游戏的帧率可能会影响游戏的每个引擎。它甚至可能影响开发过程中的测试和调试。
- en: At the start of a game's development, the game logic isn't very complicated
    and the unit count is very low. For this reason, it is common to see thousands
    of frames per second. As development continues, this frame rate will slowly drop
    to hundreds and then (hopefully) settle around 60 frames per second. Imagine if
    there was some game logic to spawn an enemy once every 10 frames. Depending on
    where we are in the development cycle, we might be spawning six or sixty enemies
    every second. This makes the game very hard to test and debug because it is not
    consistent.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的初期，游戏逻辑并不复杂，单位数量也很低。因此，每秒数千帧是很常见的。随着开发的继续，这个帧率会逐渐下降到数百，然后（希望）稳定在每秒60帧左右。想象一下，如果有一些游戏逻辑每10帧生成一个敌人。根据我们处于开发周期的哪个阶段，我们可能每秒生成六个或六十个敌人。这使得游戏很难测试和调试，因为它并不一致。
- en: What makes this problem even more interesting is that, even within a single
    play session, nothing is guaranteed to be consistent. At the start of the game,
    there are no enemies, so the frame rate might be as high as 600 frames per second.
    This means we are spawning 60 enemies every second. After five seconds, there
    are 300 enemies on screen which makes both physics and graphics very slow. Suddenly
    our frame rate might drop to 30 frames per second, slowing down enemy creation.
    As the player kills more enemies, the frame rate will rise, causing enemies to
    spawn faster and dropping the frame rate again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个问题更加有趣的是，即使在单个游戏会话中，也没有任何东西是可以保证一致的。在游戏开始时，没有敌人，所以帧率可能高达每秒600帧。这意味着我们每秒生成60个敌人。五秒后，屏幕上有300个敌人，这使得物理和图形都非常缓慢。突然，我们的帧率可能会下降到每秒30帧，减慢敌人创建的速度。随着玩家消灭更多敌人，帧率会上升，导致敌人生成更快，然后帧率再次下降。
- en: This problem isn't just limited to affecting game logic. It is a problem that
    affects anything that changes between frames. In particular, it is going to affect
    animation of game objects. Here, animation refers to anything that changes within
    a game object. This includes changing a game object's texture over time, which
    is how we typically think of animation. However, it also includes moving, scaling,
    rotating, or changing the color and transparency of an object over time. To understand
    this problem more, let's look at how moving a unit every frame can adversely affect
    game development.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题不仅限于影响游戏逻辑。它是一个影响任何在帧之间发生变化的问题。特别是，它将影响游戏对象的动画。在这里，动画指的是游戏对象内部发生变化的任何东西。这包括随时间改变游戏对象的纹理，这是我们通常认为的动画方式。然而，它还包括随时间移动、缩放、旋转，或改变对象的颜色和透明度。为了更好地理解这个问题，让我们看看每帧移动一个单位如何对游戏开发产生不利影响。
- en: Frame-based movement
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于帧的移动
- en: 'When we want to move a game object, the simplest way to do it is to update
    the position at a constant rate. This can work fine for some games. However, for
    simulating cars, spaceships, or even gravity, it won''t look correct. For now,
    we will use this method as an example then look at physics-based movement a little
    later. Since we are just updating the object''s position, the code to move the
    player to the right will look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要移动一个游戏对象时，最简单的方法是以恒定的速率更新位置。这对于某些游戏来说可能效果很好。然而，对于模拟汽车、宇宙飞船，甚至是重力，这看起来不会正确。现在，我们将使用这种方法作为一个例子，然后稍后看看基于物理的运动。由于我们只是在更新对象的位置，将玩家向右移动的代码将看起来像这样：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is worth noting that the value 5 is not measured in inches or meters; it
    is in game units. Game units are completely arbitrary and are dependent on the
    size of objects in the game. 3D modeling programs will allow you to set up units
    of scale for your models. If the same units are used for every model, and the
    models are not scaled in the game world, it would be possible to think about the
    game world in terms of those units. However, it is more common to consider everything
    as arbitrary game units. The amount an object moves on the screen depends on the
    size of the object and how far it is from the camera. If everything looks and
    feels correct in relation to everything else, it is OK.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，数值5不是以英寸或米来衡量的；它是游戏单位。游戏单位是完全任意的，并且取决于游戏中的物体大小。3D建模程序将允许你为你的模型设置比例单位。如果每个模型都使用相同的单位，并且模型在游戏世界中没有缩放，那么就可以用这些单位来考虑游戏世界。然而，更常见的是将所有东西都视为任意的游戏单位。物体在屏幕上的移动量取决于物体的大小以及它距离相机的远近。如果一切看起来和感觉都与其他事物正确相关，那么就是可以的。
- en: 'In the preceding example, assuming the size and camera distance are fixed,
    the distance on screen that the player moves will be completely dependent on our
    frame rate. For example, if we are getting 1,000 frames per second, as we might
    early in the development, our player will move 5,000 game units in the `x` direction.
    Later in development, when we are getting 100 frames per second, our player will
    only be moving 500 units in the `x` direction. To get the same amount of movement,
    we would need to change the speed of the player:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，假设大小和相机距离是固定的，玩家在屏幕上移动的距离将完全取决于我们的帧率。例如，如果我们每秒得到1,000帧，就像我们在开发初期可能做到的那样，我们的玩家将在`x`方向上移动5,000个游戏单位。在开发后期，当我们每秒得到100帧时，我们的玩家在`x`方向上只会移动500个单位。为了获得相同数量的移动，我们需要改变玩家的速度：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we get closer to finishing the game, we might only be getting 60 frames per
    second. This would mean the speed of the player would need to be changed again.
    To get the same amount of movement, the player speed would need to be 83.333 fps.
    Unfortunately, even after the game is released, we still have the same problem.
    As graphics cards and CPUs become faster, our game's frame rate will increase,
    meaning the player will be moving too fast. The gameplay experience is completely
    dependent on the computer hardware.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近完成游戏时，我们可能只能得到每秒60帧。这意味着玩家的速度需要再次改变。为了获得相同数量的移动，玩家的速度需要是83.333 fps。不幸的是，即使在游戏发布后，我们仍然有同样的问题。随着显卡和CPU的变快，我们游戏的帧率将增加，这意味着玩家会移动得太快。游戏体验完全依赖于计算机硬件。
- en: This problem could be solved by enabling VSync. As we saw earlier, using VSync
    will effectively lock our frame rate to the refresh rate of the monitor. This
    would guarantee that our frame rate has a maximum value. However, the player will
    be very confused when they upgrade to a 120 Hz monitor and the player moves twice
    as fast. Additionally, if the game runs slow for a few frames, VSync causes our
    frame rate to drop down to 30 fps. Suddenly, the player is moving at half speed.
    Even when using VSync, our gameplay experience is completely dependent on the
    hardware.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用VSync可以解决这个问题。正如我们之前看到的，使用VSync将有效地将我们的帧率锁定到监视器的刷新率。这将保证我们的帧率有一个最大值。然而，当玩家升级到120
    Hz的显示器，玩家移动速度加倍时，玩家会非常困惑。此外，如果游戏在几帧内运行缓慢，VSync会导致我们的帧率下降到30 fps。突然之间，玩家的移动速度减半。即使使用VSync，我们的游戏体验也完全依赖于硬件。
- en: Obviously using frame-based movement is not the way to go. As our frame rate
    rises and falls, we must change the movement speed of the player. As we said,
    this same problem occurs in all animation. Rotational speed of spinning objects,
    scale, fade speed of particles, and the number of frames to display a texture
    before changing it all must be constantly modified during development, and still
    won't be consistent across different hardware.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用基于帧的移动并不是一个好的选择。随着帧率的上升和下降，我们必须改变玩家的移动速度。正如我们之前所说的，这个问题在所有动画中都会出现。旋转物体的旋转速度、缩放、粒子的淡入淡出速度以及显示纹理前需要显示的帧数都必须在开发过程中不断修改，而且在不同硬件上仍然不会保持一致。
- en: Time-based movement
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时间的移动
- en: Instead of using frame-based movement, it is much better to base our movement
    on time. Time is guaranteed to be consistent throughout development and on all
    hardware, now and in the future. Whether our game is updating at three frames
    per second or 3,000 frames per second, one second will always be equal to one
    second.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于帧的移动相比，基于时间来设定我们的移动方式要好得多。时间在整个开发过程中以及在所有硬件上都是一致的，无论是现在还是未来。无论我们的游戏是每秒更新3帧还是3,000帧，一秒始终等于一秒。
- en: Using time-based movement is great because it allows us to use equations that
    have existed for hundreds of years. We don't need to reinvent the wheel to simulate
    velocity and acceleration. As we said before, using a constant speed to move the
    player is OK for some games, but that isn't how real physics works. Cars and spaceships
    do not accelerate instantly. Gravity pulls you down faster and faster the longer
    you fall.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于时间的移动非常棒，因为它允许我们使用存在了数百年的方程。我们不需要重新发明轮子来模拟速度和加速度。正如我们之前所说的，对于某些游戏来说，使用恒定速度移动玩家是可以的，但这并不是真实物理的工作方式。汽车和宇宙飞船不会瞬间加速。重力会使你下落得越来越快。
- en: When you toss a ball to a ten year old child, they don't need to do complex
    calculations to catch the ball; they can just do it. Similarly, in a semi-realistic
    simulation, players will expect the physics to behave *normally*. To simulate
    realistic or semi-realistic physics in our game, we should understand how to incorporate
    velocity and physics into our movement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把球扔给一个十岁的孩子时，他们不需要进行复杂的计算就能接住球；他们可以轻松做到。同样，在半真实模拟中，玩家会期望物理表现得*正常*。为了在我们的游戏中模拟真实或半真实的物理，我们应该了解如何将速度和物理融入我们的移动中。
- en: 'We can calculate an object''s velocity by subtracting the initial position
    of an object from the final position of an object, and dividing that by how long
    the displacement took. Another way to say this is that velocity is equal to the
    change in the position divided by the change in time. We can use this to create
    an equation that we can put in our code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从物体的最终位置减去初始位置，然后除以位移所需的时间来计算物体的速度。另一种说法是，速度等于位置变化除以时间变化。我们可以利用这一点来创建一个方程，并将其放入我们的代码中：
- en: '![](img/00077.jpeg)![](img/00078.jpeg)![](img/00079.jpeg)![](img/00080.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片8](img/00077.jpeg)![图片9](img/00078.jpeg)![图片10](img/00079.jpeg)![图片11](img/00080.jpeg)'
- en: 'We can also calculate an object''s acceleration by subtracting the initial
    velocity from the final velocity and dividing by the change in time. Acceleration
    is change in velocity over change in time:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过从最终速度减去初始速度并除以时间变化来计算物体的加速度。加速度是速度变化除以时间变化：
- en: '![](img/00081.jpeg)![](img/00082.jpeg)![](img/00083.jpeg)![](img/00084.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00081.jpeg)![图片2](img/00082.jpeg)![图片3](img/00083.jpeg)![图片4](img/00084.jpeg)'
- en: 'We also know from Newton''s second law of motion that force equals mass times
    acceleration. This also means that acceleration is equal to force divided by mass:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，根据牛顿第二运动定律，力等于质量乘以加速度。这也意味着加速度等于力除以质量：
- en: '![](img/00085.jpeg)![](img/00086.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片12](img/00085.jpeg)![图片13](img/00086.jpeg)'
- en: 'What this means is that, if we know the current position, velocity, and the
    forces acting on an object, we can find the position and velocity at some point
    in the future. In our games, we can use these three equations to simulate motion:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们知道物体的当前位置、速度以及作用在物体上的力，我们就可以找到物体在未来的某个时刻的位置和速度。在我们的游戏中，我们可以使用这三个方程来模拟运动：
- en: '![](img/00087.jpeg)![](img/00088.jpeg)![](img/00089.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/00087.jpeg)![图片6](img/00088.jpeg)![图片7](img/00089.jpeg)'
- en: 'The first two of these three equations are called Euler (pronounced Oiler)
    Integration. Specifically, it is called explicit Euler. In code, it will look
    something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方程中的前两个被称为欧拉积分（发音为Oiler）。具体来说，它被称为显式欧拉。在代码中，它看起来可能像这样：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The inner loop of this code is a close example of how we will use this in a
    game. Every frame, we will update our position and velocity based on `dt` and
    the acceleration. The velocity calculated in this frame will be used to update
    the position of an object in the next frame. Outside of a loop, these equations
    make perfect sense. If we are traveling at 55 mph down the freeway, after one
    hour we expect to be 55 miles further down the road. Similarly, if we are accelerating
    at 8 miles per hour per second then after ten seconds we expect to have a velocity
    of 80 mph.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的内部循环是我们在游戏中如何使用它的一个很好的例子。每一帧，我们将根据`dt`和加速度更新我们的位置和速度。在这一帧计算出的速度将用于更新下一帧中物体的位置。在循环外部，这些方程是完美的。如果我们以每小时55英里的速度在高速公路上行驶，一小时后我们预计会多出55英里。同样，如果我们以每秒8英里的加速度加速，那么10秒后我们预计速度将达到80英里。
- en: However, inside of the loop we will have some errors. Euler Integration is only
    accurate if acceleration and velocity are held constant. In the preceding code
    example, velocity is changing every time through the loop, so it is inaccurate
    proportional to the square of the step size. That means that the larger the step,
    the more error it has.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在循环内部我们会有一些误差。欧拉积分只有在加速度和速度保持恒定时才是准确的。在先前的代码示例中，每次循环中速度都在变化，因此它的不准确性与步长的平方成正比。这意味着步长越大，误差就越大。
- en: 'Let''s compare Euler Integration with one of the Kinematics Equations of motion
    to see how this error effects our results. The Kinematics Equation that we will
    test with is:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较欧拉积分与运动学方程之一，看看这个误差如何影响我们的结果。我们将测试的运动学方程是：
- en: '![](img/00090.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00090.jpeg)'
- en: Where `p` is our new position, `p⁰` is our initial position, `v⁰` is our initial
    velocity, `a` is our acceleration and `t` is our time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`p`是我们新的位置，`p⁰`是我们初始位置，`v⁰`是我们初始速度，`a`是我们加速度，`t`是我们时间。
- en: 'Let''s assume that our starting position is 0 and our starting velocity is
    0\. Typically, in physics equations, acceleration is in units of seconds per second
    instead of hours per second. So, let''s say we are accelerating at 20 feet per
    second for 10 seconds. After 10 seconds, our car will have traveled 500 feet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的起始位置是0，我们的起始速度也是0。通常，在物理方程中，加速度的单位是每秒每秒，而不是每小时每秒。所以，让我们说我们在10秒内以每秒20英尺的加速度加速。10秒后，我们的车将行驶500英尺：
- en: '![](img/00091.jpeg)![](img/00092.jpeg)![](img/00093.jpeg)![](img/00094.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00091.jpeg)![图片3](img/00092.jpeg)![图片4](img/00093.jpeg)![图片5](img/00094.jpeg)'
- en: 'So, the Kinematics equations say we will be `1000` feet from where we started
    after `10` seconds. Using this same data, let plug it into our Euler Integration
    function. We will be integrating every second for 10 seconds:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运动学方程说我们在10秒后将从起点起1000英尺远。使用相同的数据，我们可以将其放入我们的欧拉积分函数中。我们将每秒积分10秒：
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Euler Integration says we will be 900 feet from where we started. The Kinematics
    Equation and Euler Integration are 100 feet off. This is after only 10 seconds.
    The longer we integrate for, the more the error. Of course, we already explained
    why we have this problem. The error is proportional to the time step. If we use
    a smaller time step, we will have a smaller error. Luckily our game will be updating
    more than one frame per second. Let''s integrate again, but let''s use some more
    realistic time steps. Let''s choose values for 30 fps, 60 fps, and 120 fps. These
    give us time steps of .0333, .0167, and .008 respectively:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉积分说我们将从起点起900英尺远。运动学方程和欧拉积分相差100英尺。这是在仅10秒后。我们积分的时间越长，误差就越大。当然，我们之前已经解释了为什么会有这个问题。误差与时间步长成正比。如果我们使用更小的时间步长，我们将有更小的误差。幸运的是，我们的游戏将每秒更新多个帧。让我们再次进行积分，但让我们使用一些更现实的时间步长。让我们选择30
    fps、60 fps和120 fps的值。这给我们提供了0.0333、0.0167和0.008的时间步长：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, by using a smaller time step, we come closer to the matching
    result. At 120 fps, we are pretty accurate but, even at 60 fps, we have calculated
    a few feet off. Unfortunately, even the Kinematics equations are not accurate
    unless acceleration is held constant.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用更小的时间步长，我们更接近匹配的结果。在120 fps时，我们相当准确，但在60 fps时，我们计算出的误差只有几英尺。不幸的是，即使加速度保持恒定，运动学方程也不准确。
- en: For many games, Euler Integration will be all you need. The errors are small
    enough that players may not notice. This of course depends on gameplay and the
    frame rate. Creating an extremely accurate physics integrator is beyond the scope
    of this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多游戏来说，欧拉积分可能就足够了。误差足够小，以至于玩家可能不会注意到。当然，这取决于游戏玩法和帧率。创建一个极其精确的物理积分器超出了本书的范围。
- en: 'If your game requires very accurate physics, check out Verlet Integration or
    RK4 Integration at:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏需要非常精确的物理效果，请查看以下链接中的Verlet积分或RK4积分：
- en: '[https://en.wikipedia.org/wiki/Verlet_integration](https://en.wikipedia.org/wiki/Verlet_integration),'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Verlet积分](https://zh.wikipedia.org/wiki/Verlet积分),'
- en: '[https://en.wikipedia.org/wiki/Runge-Kutta_methods](https://en.wikipedia.org/wiki/Runge-Kutta_methods)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Runge-Kutta方法](https://zh.wikipedia.org/wiki/Runge-Kutta方法)'
- en: Whichever integration method you choose, it will be better and more reliable
    than using frame-based movement. The important thing to remember is that anything
    that changes in the game must use time. This includes rotations, which can use
    similar rotational velocity and rotational acceleration if you want. It also includes
    scaling over time, animating a texture over time, and even changing color and
    transparency. This will give our game a very consistent look and feel, as well
    as making it easier to test and debug throughout development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种积分方法，它都将比使用基于帧的运动更好、更可靠。重要的是要记住，游戏中任何发生变化的部分都必须使用时间。这包括旋转，如果你愿意，可以使用类似的旋转速度和旋转加速度。它还包括随时间缩放、随时间动画纹理，甚至改变颜色和透明度。这将使我们的游戏具有非常一致的外观和感觉，同时使测试和调试在整个开发过程中变得更加容易。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have really covered a lot in this chapter. Now, you know more about how computer
    monitors work than you probably ever wanted. In this chapter, we dived into the
    nitty gritty details of framebuffers and how pixels are colored on screen. We
    saw that having a frame rate that was out-of-sync with the monitor can cause tearing.
    We also looked at how double buffering and using VSync can fix this problem. Unfortunately,
    we also saw that VSync can cause problems of its own. We also looked at triple
    buffering and saw the pros and cons there. In the end, there is no perfect answer.
    There will always be some trade-off. You must either accept tearing or the possibility
    of a drastic drop in frame rate due to VSync.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中确实涵盖了大量的内容。现在，你对计算机显示器的工作原理的了解可能比你原本想要的要多。在本章中，我们深入探讨了帧缓冲区以及屏幕上像素着色的细节。我们了解到，如果帧率与显示器不同步，可能会导致撕裂。我们还探讨了双缓冲和VSync的使用如何解决这个问题。不幸的是，我们也看到了VSync可能会引起它自己的问题。我们还探讨了三缓冲，并分析了其优缺点。最终，没有完美的答案。总会有一些权衡。你必须接受撕裂，或者由于VSync而导致的帧率急剧下降的可能性。
- en: Finally, we finished this chapter by looking at how our frame rate affects the
    rest of our gameplay code. Specifically, we looked at physics and animation, and
    learned that we must use time-based physics and animation for a more consistent
    look and feel in our game.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看帧率如何影响我们游戏的其他代码部分来结束本章。具体来说，我们研究了物理和动画，并了解到我们必须使用基于时间的物理和动画来使我们的游戏具有更一致的外观和感觉。
- en: In the next chapter, we are going to get away from the low-level details and
    look at the big picture of programming. This includes our coding philosophy and
    why we care about high quality code. We will look at a few tips and tricks that
    can help make developing a game less of a headache, as well as covering a few
    specific things in the Mach5 engine that aren't patterns but can still make your
    coding life much easier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从底层细节中解脱出来，看看编程的大图景。这包括我们的编码哲学以及我们为什么关心高质量代码。我们将探讨一些可以帮助使游戏开发不那么头痛的技巧和窍门，以及介绍Mach5引擎中的一些特定内容，虽然它们不是模式，但仍然可以使你的编码生活变得更加容易。
