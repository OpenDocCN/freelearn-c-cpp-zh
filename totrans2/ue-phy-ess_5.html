<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Physics Damping, Friction, and Physics Bodies</h1></div></div></div><p>In this chapter, we will take a deeper look at <strong>Physics Bodies</strong> in Unreal Engine 4 and analyze how the engine uses physics properties, such as <strong>Angular Damping</strong> and <strong>Linear Friction</strong> to simulate real-world physics in our game. To start with, we will examine what <strong>Physics Bodies</strong> are. We will also look at some of the detailed properties available to these assets. In addition, we will discuss the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Angular and linear friction</li><li class="listitem">Physical materials – an overview</li><li class="listitem">Physics damping</li></ul></div><p>For the purposes of this chapter, we will continue to work with Unreal Engine 4 and the <strong>Unreal_PhyProject</strong> that we created in <a class="link" title="Chapter 1. Math and Physics Primer" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <em>Math and Physics Primer</em> in Unreal Engine. Let's begin by discussing <strong>Physics Bodies</strong> in Unreal Engine 4.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Physics Bodies – an overview</h1></div></div></div><p>When it <a id="id281" class="indexterm"/>comes to creating <strong>Physics Bodies</strong>, there are multiple ways to go about it (most of which we have covered up to this point), so we will not go into much detail about the creation of <strong>Physics Bodies</strong>. We can have <strong>Static Meshes</strong> react as <strong>Physics Bodies</strong> by checking the <strong>Simulate Physics</strong> property of the asset when it is placed in our level:</p><div><img src="img/image00294.jpeg" alt="Physics Bodies – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>We can also create <strong>Physics Bodies</strong> by creating <strong>Physics Assets</strong> and <strong>Skeletal Meshes</strong>, which automatically have the properties of physics by default. Lastly, <strong>Shape Components</strong> in blueprints, such as spheres, boxes, and capsules will automatically gain the properties of a Physics Body if they are set for any sort of collision, overlap, or other physics simulation events. As always, remember to ensure that our asset has a collision applied to it before attempting to simulate physics or establish <strong>Physics Bodies</strong>, otherwise the simulation will not work.</p><p>When you work with <a id="id282" class="indexterm"/>the properties of <strong>Physics</strong> on <strong>Static Meshes</strong> or any other assets that we will attempt to simulate physics with, we will see a handful of different parameters that we can change in order to produce the desired effect under the <strong>Details</strong> panel.</p><div><img src="img/image00295.jpeg" alt="Physics Bodies – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>Let's break down these properties:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Simulate Physics</strong>: This parameter allows you to enable or simulate physics with the <a id="id283" class="indexterm"/>asset you have selected. When this option is unchecked, the asset will remain static, and once enabled, we can edit the <strong>Physics Body</strong> properties for additional customization.</li><li class="listitem"><strong>Auto Weld</strong>: When <a id="id284" class="indexterm"/>this property is set to <code class="literal">True</code>, and when the asset is attached to a parent object, such as in a blueprint, the two bodies are merged into a single rigid body. <strong>Physics</strong> settings, such as collision profiles and body settings, are determined by <strong>Root Component</strong>.</li><li class="listitem"><strong>Start Awake</strong>: This <a id="id285" class="indexterm"/>parameter determines whether the selected asset will <strong>Simulate Physics</strong> at the start once it is spawned or whether it will <strong>Simulate Physics</strong> at a later time. We can change this parameter with the level and actor blueprints.</li><li class="listitem"><strong>Override Mass</strong>: When <a id="id286" class="indexterm"/>this property is checked and set to <code class="literal">True</code>, we can then freely change the <strong>Mass</strong> of our asset using <strong>kilograms</strong> (<strong>kg</strong>). Otherwise, the <strong>Mass in Kg</strong> parameter will be set to a default value that is based on a computation between the physical material applied and the mass scale value.</li><li class="listitem"><strong>Mass in Kg</strong>: This <a id="id287" class="indexterm"/>parameter determines the <strong>Mass</strong> of the selected asset using kilograms. This is important when you work with different sized physics objects and want them to react to forces appropriately.</li><li class="listitem"><strong>Locked Axis</strong>: This <a id="id288" class="indexterm"/>parameter allows you to lock the physical movement of our object along a specified axis. We have the choice to lock the default axes as specified in <strong>Project Settings</strong>. We also have the choice to lock physical movement along the individual <em>X</em>, <em>Y</em>, and <em>Z</em> axes. We can have none of the axes either locked in translation or rotation, or we can customize each axis individually with the <strong>Custom</strong> option.</li><li class="listitem"><strong>Enable Gravity</strong>: This <a id="id289" class="indexterm"/>parameter determines whether the object should have the force of gravity applied to it. The force of gravity can be altered in the <strong>World Settings</strong> properties of the level or in the <strong>Physics</strong> section of the <strong>Engine</strong> properties in <strong>Project Settings</strong>.</li><li class="listitem"><strong>Use Async Scene</strong>: This <a id="id290" class="indexterm"/>property allows you to enable the use of <strong>Asynchronous Physics</strong> for the specified object. By default, we cannot edit this property. In order to do so, we must navigate to <strong>Project Settings</strong> and then to the <strong>Physics</strong> section. Under the advanced <strong>Simulation</strong> tab, we will find the <strong>Enable Async Scene</strong> parameter. In an asynchronous <a id="id291" class="indexterm"/>scene, objects (such as <strong>Destructible</strong> actors) are simulated, and a <strong>Synchronous</strong> scene is where classic physics tasks, such as a falling crate, take place.</li><li class="listitem"><strong>Override Walkable Slope on Instance</strong>: This parameter determines whether or not we <a id="id292" class="indexterm"/>can customize an object's walkable slope. In general, we would use this parameter for our player character, but this property enables the customization of how steep a slope is that an object can walk on. This can be controlled specifically by the <strong>Walkable Slope Angle</strong> parameter and the <strong>Walkable Slope Behavior</strong> parameter.</li><li class="listitem"><strong>Override Max Depenetration Velocity</strong>: This parameter allows you to customize <a id="id293" class="indexterm"/><strong>Max Depenetration Velocity</strong> of the selected physics body.</li><li class="listitem"><strong>Center of Mass Offset</strong>: This property allows you to specify a specific vector offset for the <a id="id294" class="indexterm"/>selected objects' center of mass from the calculated location. Being able to know and even modify the center of the mass for our objects can be very useful when you work with sensitive physics simulations (such as flight).</li><li class="listitem"><strong>Sleep Family</strong>: This <a id="id295" class="indexterm"/>parameter allows you to control the set of functions that the physics object uses when in a sleep mode or when the object is moving and slowly coming to a stop. The <strong>SF Sensitive</strong> option contains values with a lower sleep threshold. This is best used for objects that can move very slowly or for improved physics simulations (such as billiards). The <strong>SF Normal</strong> option contains values with a higher sleep threshold, and objects will come to a stop in a more abrupt manner once in motion as compared to the <strong>SF Sensitive</strong> option.</li><li class="listitem"><strong>Mass Scale</strong>: This <a id="id296" class="indexterm"/>parameter allows you to scale the mass of our object by multiplying a scalar value. The lower the number, the lower the mass of the object will become, whereas the larger the number, the larger the mass of the object will become. This property can be used in conjunction with the <strong>Mass in Kg</strong> parameter to add more customization to the mass of the object.</li><li class="listitem"><strong>Angular Damping</strong>: This property is a modifier of the drag force that is applied to the <a id="id297" class="indexterm"/>object in order to reduce angular movement, which means to reduce the rotation of the object. We will go into more detail regarding <strong>Angular Damping</strong> later in this chapter.</li><li class="listitem"><strong>Linear Damping</strong>: This property is used to simulate the different types of friction <a id="id298" class="indexterm"/>that can assist in the game world. This modifier adds a drag force to reduce linear movement, reducing the translation of the object. We will go into more detail regarding <strong>Linear Damping</strong> later in this chapter.</li><li class="listitem"><strong>Max Angular Velocity</strong>: This parameter limits <strong>Max Angular Velocity</strong> of the selected <a id="id299" class="indexterm"/>object in order to prevent the object from rotating at high rates. By increasing this value, the object will spin at very high speeds once it is impacted by an outside force that is strong enough to reach the <strong>Max Angular Velocity</strong> value. By decreasing this value, the object will not rotate as fast, and it will come to a halt much faster depending on the angular damping applied.</li><li class="listitem"><strong>Position Solver Iteration Count</strong>: This parameter reflects the physics body's solver <a id="id300" class="indexterm"/>iteration count for its position; the solver iteration count is responsible for periodically checking the physics body's position. Increasing this value will be more CPU intensive, but better stabilized.</li><li class="listitem"><strong>Velocity Solver Iteration Count</strong>: This parameter reflects the physics body's solver <a id="id301" class="indexterm"/>iteration count for its velocity; the solver iteration count is responsible for periodically checking the physics body's velocity. Increasing this value will be more CPU intensive, but better stabilized.</li></ul></div><p>Now that we have discussed all the different parameters available to <strong>Physics Bodies</strong> in Unreal Engine 4, feel free to play around with these values in order to obtain a stronger grasp of what each property controls and how it affects the physical properties of the object. As there are a handful of properties, we will not go into detailed examples of each, but the best way to learn more is to experiment with these values. However, we will work with how to create various examples of physics bodies in order to explore <strong>Physics Damping</strong> and <strong>Friction</strong> later in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Physics Bodies – a section review</h1></div></div></div><p>In this section, we <a id="id302" class="indexterm"/>discussed what <strong>Physics Bodies</strong> are and how to create them by using static meshes, skeletal meshes, shape components in blueprints, and physics assets. Additionally, you learned about all the different parameters that exist for <strong>Physics Bodies</strong> in Unreal Engine 4. We also looked at each property and how it affects the physics on the specified object. Now that we have a stronger grasp of what <strong>Physics Bodies</strong> are, let's move on and discuss <strong>Angular</strong> and <strong>Linear Damping</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Angular and Linear Damping</h1></div></div></div><p>In this <a id="id303" class="indexterm"/>section, we will discuss <strong>Angular</strong> and <strong>Linear Damping</strong> in more detail, focusing on the friction properties of physics bodies. Further more, we will discuss physics damping and how this can be used when setting up the constraints for our blueprints. Let's begin by briefly discussing <strong>Angular Damping</strong> and <strong>Angular Velocity/Momentum</strong>.</p><p>In the realm of physics, <strong>Angular Velocity</strong> is defined as the rate of change of angular displacement, also known as a vector quantity, which specifies the angular speed or the rotational speed of an object and the axis in which the object is rotating.</p><div><img src="img/image00296.jpeg" alt="Angular and Linear Damping"/></div><p style="clear:both; height: 1em;"> </p><p>In the preceding diagram, we can see that <strong>w,</strong> or the angular speed, is equal to the velocity divided by the radius of the object that is rotating.</p><p>
<strong>Linear Angular Momentum</strong> is proportional to <strong>Moment of Inertia</strong> (<em>I</em>) and <strong>Angular Speed</strong> (<em>w</em>), so the basic formula is <em>L = Iw</em>. We now know that <em>w</em> is equal to the velocity and radius of the object, so we can now write the expression as <em>L = I (v/r)</em>. Lastly, <strong>Moment of Inertia</strong> is equal to the radius of the object squared, multiplied by the object's mass, or <em>I = r^2 * (m)</em>. With this in mind, we can now rewrite the <strong>Linear Angular Momentum</strong> expression as <em>L = (r^2 * m) * (v/r)</em>, or more simply, we can write the expression as <em>L = rmv</em>, so the <strong>Linear Angular Momentum</strong> of an object is equal to the radius of the object multiplied by its mass and the velocity that is applied to it.</p><p>Now that we have a stronger understanding of <strong>Angular Velocity</strong> and <strong>Angular Momentum</strong>, let's apply this knowledge to the physics body with the <strong>Unreal_PhyProject</strong> game project that we created in the first chapter. By default, there are a bunch of physics body cubes placed throughout the <strong>FirstPersonExampleMap</strong> level that we can alter properties to in order to explore <strong>Angular Damping</strong> and <strong>Angular Velocity</strong>.</p><p>Let's start by selecting a random cube from <strong>FirstPersonExampleMap</strong> and viewing its <strong>Physics</strong> properties in <strong>Details</strong> panel, on the left-hand side. For the sake of an example, let's left-click on the down directional arrow in the <strong>Physics</strong> section to expand the advanced properties. The first property we will see is <strong>Enable Gravity</strong>, and by default, it is set to <code class="literal">True</code>; let's set this property to <code class="literal">False</code> so that the selected physics body doesn't have the force of gravity applied to it. With this change in place, we can now move the physics body upwards in the <em>Z</em> direction so that it floats in the level in mid-air. Now, if we play the game, the physics body will not move unless it is shot at by the player with the <strong>FirstPersonProjectile</strong> blueprint. Once shot, the physics body will start spinning and moving in the appropriate direction based on where it's shot and the impulse that is applied to it by the projectile blueprint.</p><p>Back in the <strong>Details</strong> panel of <strong>Physics Body</strong>, we can now explore the <strong>Angular Damping</strong> property, which is set to <code class="literal">0 </code>by default, meaning that the object has no additional drag force applied to it to reduce <a id="id304" class="indexterm"/>angular velocity. By increasing this value, we can see that when we shoot the object in the game, the angular velocity slows down in a stronger exponential value compared to how it behaved when the <strong>Angular Damping</strong> value was set to <code class="literal">0</code>. We can also set the limit on how fast the physics object can rotate when a force is applied to it by altering the value of the <strong>Max Angular Velocity</strong> parameter; the higher the value, the faster the object is able to rotate if enough force is applied to it.</p><p>For this example, let's set the <strong>Angular Damping</strong> value to <code class="literal">.01</code> and, the <strong>Max Angular Velocity</strong> parameter to <code class="literal">800</code>. We will override the <strong>Mass in Kg</strong> parameter and set a custom mass of <code class="literal">10.0</code>. We should now have the following properties in place for our physics body object:</p><div><img src="img/image00297.jpeg" alt="Angular and Linear Damping"/></div><p style="clear:both; height: 1em;"> </p><p>Now, if we play the game and shoot at our <strong>Physics Body</strong> object, we will see that the object can rotate at a very quick rate when shot at by the player. To find out what else can affect the <strong>Angular Velocity</strong> and <strong>Angular Damping</strong> of an object, we can increase or decrease the values for the <strong>Mass in Kg</strong>, <strong>Angular Damping</strong>, and <strong>Max Angular Velocity</strong> parameters. With the knowledge of <strong>Angular Damping</strong> and <strong>Angular Physics</strong> under our belt, let's now discuss <strong>Linear Damping</strong> and <strong>Linear Physics</strong> in Unreal Engine 4.</p><p>In physics, <strong>Linear Velocity</strong> is defined as the rate of the change of linear displacement of time, also known as a vector quantity, which specifies the linear speed of an object and the direction in which the object is moving in.</p><div><img src="img/image00298.jpeg" alt="Angular and Linear Damping"/></div><p style="clear:both; height: 1em;"> </p><p>The formula for basic <strong>Linear Velocity</strong> is <em>V = S/t</em>, or velocity equals the change in displacement of the object divided by the time the object takes to move this change in displacement. The <a id="id305" class="indexterm"/>concept of <strong>Linear Damping</strong> is the reduction of movement over time in order to have an object come to a complete stop once a force is applied to it that would cause displacement, also known as <strong>Friction</strong>. When it comes to <strong>Linear Momentum</strong>, the formula is <em>p = mv</em>, where <em>p</em> is the value of <strong>Momentum</strong>, <em>m</em> is the value of the object's mass, and <em>v</em> is the velocity of the object.</p><p>In Unreal Engine 4, we can damper the linear velocity of our physics body in two ways: by creating a <strong>Physical Material</strong> to apply to our physics body or by changing the <strong>Linear Damping</strong> property in the <strong>Physics</strong> section of the <strong>Details</strong> panel of our physics body. For the purposes of this section, we will only discuss how to change the <strong>Linear Damping</strong> property and we will go into more detail on how to create <strong>Physical Material</strong> later in this chapter. Working with <strong>FirstPersonExampleMap</strong> in <strong>Unreal_PhyProject</strong>, let's go ahead and create a working example of how to properly utilize the <strong>Linear Damping</strong> property for our physics bodies in order to recreate <strong>Friction</strong>. For this example, we can use the same physics body that we used to demonstrate angular velocity and angular damping, but we do want to make sure that we check the <strong>Enable Gravity</strong> parameter and set the rest of the parameters to their default values so that we can start this example from scratch.</p><p>By increasing the value of the <strong>Linear Damping</strong> property to a value such as <code class="literal">100</code> and playing the game, we will see that when we shoot the physics body, it does not translate as much as it would if the <strong>Linear Damping</strong> property was set to its default value of <code class="literal">.01</code>. With the value of <code class="literal">100</code>, the <strong>Linear Damping</strong> property causes the physics body to almost stay where it is, but the rotation of the object changes as normal because we did not change the properties <a id="id306" class="indexterm"/>involving angular damping. The use of <strong>Linear Damping</strong> is very straightforward, and there is not much customization passed (as discussed in the context of physics bodies in their <strong>Physics</strong> properties), but we can add additional properties using <strong>Physics Materials</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Angular and Linear Damping – a section review</h1></div></div></div><p>In this section, we discussed <a id="id307" class="indexterm"/>the concepts of <strong>Angular</strong> and <strong>Linear Damping</strong> and <strong>Angular</strong> and <strong>Linear Velocities</strong> in the context of real-world physics in detail. Once we were able to grasp these concepts, we then applied what you learned about using physics bodies in Unreal Engine 4 and the <strong>Physics</strong> properties of these objects in order to explore how they affect the physics bodies in the game. Now that we have examined angular and linear damping, we can move on to briefly discuss what <strong>Physics Materials</strong> are and how to apply them to our physics bodies.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Physical Materials – an overview</h1></div></div></div><p>
<strong>Physical </strong>
<a id="id308" class="indexterm"/>
<strong>Materials</strong> are assets that are used to define the response of a physics body when you dynamically interact with the game world. When you first create <strong>Physical Material</strong>, you are presented with a set of default values that are identical to the default <strong>Physical Material</strong> that is applied to all physics objects.</p><p>To create <strong>Physical Material</strong>, let's navigate to <strong>Content Browser</strong> and select the <strong>Content </strong>folder so that it is highlighted. From here, we can right-click on the <strong>Content</strong> folder and select the <strong>New Folder</strong> option to create a new folder for our <strong>Physical Material</strong>; name this new folder <code class="literal">PhysicalMaterials</code>. Now, in the <code class="literal">PhysicalMaterials</code> folder, right-click on the empty area of <strong>Content Browser</strong> and navigate to the <strong>Physics</strong> section and select <strong>Physical Material</strong>. Make sure to name this new asset <code class="literal">PM_Test</code>.</p><div><img src="img/image00299.jpeg" alt="Physical Materials – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>Double-click on the new <strong>Physical Material</strong> asset to open <strong>Generic Asset Editor</strong> and we should see the following values that we can edit in order to make our physics objects behave in certain ways:</p><div><img src="img/image00300.jpeg" alt="Physical Materials – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>Let's take a few minutes to break down each of these properties:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Friction</strong>: This <a id="id309" class="indexterm"/>parameter controls how easily objects can slide on this surface. The lower the friction value, the more slippery the surface. The higher the friction value, the less slippery the surface. For example, ice would have a <strong>Friction</strong> surface value of <code class="literal">.05</code>, whereas a <strong>Friction</strong> surface value of <code class="literal">1 </code>would cause the object not to slip as much once moved.</li><li class="listitem"><strong>Friction Combine Mode</strong>: This parameter controls how friction is computed for multiple <a id="id310" class="indexterm"/>materials. This property is important when it comes to interactions between multiple physical materials and how we want these calculations to be made. Our choices are <strong>Average</strong>, <strong>Minimum</strong>, <strong>Maximum</strong>, and <strong>Multiply</strong>.</li><li class="listitem"><strong>Override Friction Combine Mode</strong>: This parameter allows you to set the <strong>Friction </strong><a id="id311" class="indexterm"/><strong>Combine Mode</strong> parameter instead of using <strong>Friction Combine Mode</strong>, found in the <strong>Project Settings</strong> | <strong>Engine</strong> | <strong>Physics</strong> section.</li><li class="listitem"><strong>Restitution</strong>: This <a id="id312" class="indexterm"/>parameter controls how bouncy the surface is. The higher the value, the more bouncy the surface will become.</li><li class="listitem"><strong>Density</strong>: This <a id="id313" class="indexterm"/>parameter is used in conjunction with the shape of the object to calculate its mass properties. The higher the number, the heavier the object becomes (in grams per cubic centimeter).</li><li class="listitem"><strong>Raise Mass to Power</strong>: This parameter is used to adjust the way in which the mass increases <a id="id314" class="indexterm"/>as the object gets larger. This is applied to the mass that is calculated based on a solid object. In actuality, larger objects do not tend to be solid and become more like shells (such as a vehicle). The values are clamped to <code class="literal">1</code> or less.</li><li class="listitem"><strong>Destructible Damage Threshold Scale</strong>: This parameter is used to scale the damage <a id="id315" class="indexterm"/>threshold for the destructible objects that this physical material is applied to.</li><li class="listitem"><strong>Surface Type</strong>: This parameter is used to describe what type of real-world surface <a id="id316" class="indexterm"/>we are trying to imitate for our project. We can edit these values by navigating to the <strong>Project Settings</strong> | <strong>Physics</strong> | <strong>Physical Surface</strong> section.</li><li class="listitem"><strong>Tire Friction Scale</strong>: This parameter is used as the overall tire friction scalar for every <a id="id317" class="indexterm"/>type of tire and is multiplied by the parent values of the tire.</li><li class="listitem"><strong>Tire Friction Scales</strong>: This parameter is almost identical to the <strong>Tire Friction Scale</strong> <a id="id318" class="indexterm"/>parameter, but it looks for a <strong>Tire Type</strong> data asset to associate it to. <strong>Tire Types</strong> can be created through the use of <strong>Data Assets</strong> by right-clicking on the <strong>Content Browser</strong> | <strong>Miscellaneous</strong> | <strong>Data Asset</strong> | <strong>Tire Type</strong> section.</li></ul></div><p>Now that we have briefly discussed how to create <strong>Physical Materials</strong> and what their  properties are, let's take a look at how to apply <strong>Physical Materials</strong> to our physics bodies. In <strong>FirstPersonExampleMap</strong>, we can select any of the physics body cubes throughout the level and in the <strong>Details</strong> panel under <strong>Collision</strong>, we will find the <strong>Phys Material Override</strong> parameter. It is here that we can apply our <strong>Physical Material</strong> to the cube and view how it reacts to our game world.</p><p>For the sake of an example, let's return to the <strong>Physical Material</strong>, <code class="literal">PM_Test</code>, that we created earlier, change the <strong>Friction</strong> property from <code class="literal">0.7</code> to <code class="literal">0.2</code>, and save it. With this change in place, let's select a physics body cube in <strong>FirstPersonExampleMap</strong> and apply the <strong>Physical Material</strong>, <code class="literal">PM_Test</code>, to the <strong>Phys Material Override</strong> parameter of the object. Now, if we play the game, we will see that the cube we applied the <strong>Physical Material</strong>, <code class="literal">PM_Test</code>, to will start to slide more once shot by the player than it did when it had a <strong>Friction</strong> value of <code class="literal">0.7</code>. We can also apply this <strong>Physical Material</strong> to the floor mesh in <strong>FirstPersonExampleMap</strong> to see how it affects the other physics bodies in our game world. From here, feel free to play around with the <strong>Physical Material</strong> parameters to see how we can affect the physics bodies in our game world.</p><p>Lastly, let's briefly discuss how to apply <strong>Physical Materials</strong> to normal <strong>Materials</strong>, <strong>Material Instances</strong>, and <strong>Skeletal Meshes</strong>.</p><p>To apply <strong>Physical Material</strong> to a normal material, we first need to either create or open an already created material in <strong>Content Browser</strong>. To create a material, just right-click on an empty area of <strong>Content </strong>
<a id="id319" class="indexterm"/>
<strong>Browser</strong> and select <strong>Material</strong> from the drop-down menu.<code class="literal"> </code>Double-click on <strong>Material</strong> to open <strong>Material Editor</strong>, and we will see the parameter for <strong>Phys Material</strong> under the <strong>Physical Material</strong> section of <strong>Details</strong> panel in the bottom-left of <strong>Material Editor</strong>:</p><div><img src="img/image00301.jpeg" alt="Physical Materials – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>To apply <strong>Physical Material</strong> to <strong>Material Instance</strong>, we first need to create <strong>Material Instance</strong> by navigating to <strong>Content Browser</strong> and right-clicking on an empty area to bring up the context drop-down menu. Under the <strong>Materials &amp; Textures</strong> section, we will find an option for <strong>Material Instance</strong>. Double-click on this option to open <strong>Material Instance Editor</strong>. Under the <strong>Details</strong> panel in the top-left corner of this editor, we will find an option to apply <strong>Phys Material</strong> under the <strong>General</strong> section:</p><div><img src="img/image00302.jpeg" alt="Physical Materials – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>Lastly, to apply <a id="id320" class="indexterm"/>
<strong>Physical Material</strong> to <strong>Skeletal Mesh</strong>, we need to either create or open an already created <strong>Physics Asset</strong> that contains <strong>Skeletal Mesh</strong>. In the <strong>First Person Shooter Project</strong> template, we can find <strong>TutorialTPP_PhysicsAsset</strong> under the <strong>Engine Content</strong> folder. If the <strong>Engine Content</strong> folder is not visible by default in <strong>Content Browser</strong>, we need to simply navigate to <strong>View Options</strong> in the bottom-right corner of <strong>Content Browser</strong> and check the <strong>Show Engine Content</strong> parameter. Under the <strong>Engine Content</strong> folder, we can navigate to the <strong>Tutorial</strong> folder and then to the <strong>TutorialAssets</strong> folder to find the <strong>TutorialTPP_PhysicsAsset</strong> asset. Double-click on this asset to open <strong>Physical Asset Tool</strong>. Now, we can click on any of the body parts found on <strong>Skeletal Mesh</strong> to highlight it. Once this is highlighted, we can view the option for <strong>Simple Collision Physical Material</strong> in the <strong>Details</strong> panel under the <strong>Physics</strong> section. Here, we can apply any of our <strong>Physical Materials</strong> to this body part.</p><div><img src="img/image00303.jpeg" alt="Physical Materials – an overview"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Physical Materials – a section review</h1></div></div></div><p>In this section, we <a id="id321" class="indexterm"/>discussed in detail what <strong>Physical Materials</strong> are and what their parameters mean when applying them to a physics body. Additionally, we explored how to apply <strong>Physical Materials</strong> to physics bodies, <strong>Materials</strong>, <strong>Material Instances</strong>, and <strong>Skeletal Meshes</strong> in <strong>Physical Asset Tool</strong>. Now that we have a better understanding of <strong>Physical Materials</strong>, we can now conclude this chapter by working with <strong>Constraints</strong> in blueprints to better understand <strong>Physics Damping</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Physics Damping</h1></div></div></div><p>In order to gain a <a id="id322" class="indexterm"/>stronger grasp of <strong>Physics Damping</strong> in Unreal Engine 4, we will create a simple working example of <strong>Constraints</strong> with blueprints. To start with, let's continue our work in the <strong>Unreal_PhyProject</strong> project, navigate to <strong>Content Browser</strong> and then to the <strong>Blueprints</strong> folder, and right-click on it to create a new <strong>Actor </strong>blueprint. Let's name this blueprint <code class="literal">BP_Constraint</code> and double-click on it to open <strong>Blueprint Editor</strong>.</p><p>To begin this blueprint, let's navigate to the <strong>Viewport</strong> tab and then add <strong>Scene Component</strong> to the <strong>Components</strong> tab using the <strong>Add Component</strong> context sensitive drop-down menu. Name this component <code class="literal">ROOT</code>. Next, we will add two cube meshes from the <strong>Basic Shapes</strong> section to the <strong>Add Components</strong> menu. Name one <code class="literal">Stable Mesh</code> and the other <code class="literal">Constrained Mesh</code>. Lastly, let's add a <strong>Physics Constraint</strong> component from the <strong>Physics</strong> section and name it <code class="literal">Physics Constraint</code>. Now, we need to position these components in a manner that will better showcase how to use physics damping in Unreal Engine 4.</p><p>Set the position of our assets in the <strong>Viewport</strong> tab of our blueprint as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Stable Mesh</strong>: <code class="literal">X – 0.0</code>, <code class="literal">Y – 0.0</code>, and <code class="literal">Z – 350.0</code></li><li class="listitem"><strong>Constrained Mesh</strong>: <code class="literal">X – 120.0</code>, <code class="literal">Y – 0.0</code>, <code class="literal">Z – 0.0</code></li><li class="listitem"><strong>Physics Constraint</strong>: <code class="literal">X – 0.0</code>, <code class="literal">Y – 0.0</code>, <code class="literal">Z – 340.0</code></li></ul></div><p>Now, we will need to set the default parameters to our <strong>Physics Constraint</strong> asset so that it recognizes the mesh that is the anchor. The other mesh is the free-hanging pendulum attached to it. To accomplish this, let's select the <strong>Physics Constraint</strong> component. Then, in its <strong>Details</strong> panel, we will find the parameters for <strong>Component Name 1</strong> and <strong>Component Name 2</strong> under the <strong>Constraint</strong> section. For these parameters, we will need to apply the names of the two meshes that we will use for our constraint: <code class="literal">Stable Mesh</code> and <code class="literal">Constrained Mesh</code>. Set these parameters as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Component Name 1</strong>: <code class="literal">Stable Mesh</code></li><li class="listitem"><strong>Component Name 2</strong>: <code class="literal">Constrained Mesh</code><div><img src="img/image00304.jpeg" alt="Physics Damping"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>With these parameters in place, we can now place our <strong>BP_Constraint</strong> in <strong>FirstPersonExampleMap</strong> to see the constraint in action. First, make sure to compile and save the blueprint before placing this blueprint in our level. Once this is placed in our level, make sure to lift the blueprint well off the ground so that there won't be any collision or clipping <a id="id323" class="indexterm"/>between the constrained assets and our game world, and when we can play the game to see how the constraint works, we will see the following result:</p><div><img src="img/image00305.jpeg" alt="Physics Damping"/></div><p style="clear:both; height: 1em;"> </p><p>We will see that the swinging cube will continue to swing back and forth for eternity without any sign of damping or friction to slow it down. Let's change this. Then, navigate back to the <strong>BP_Constraint</strong> blueprint and select the <strong>Physics Constraint</strong> component. In the <strong>Details</strong> panel, we will see a handful of parameters that we can change to the constraint in order to affect its behavior. Let's briefly define each parameter found in the <strong>Details</strong> panel <a id="id324" class="indexterm"/>of the <strong>Physics Constraint component</strong>:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Component Name 1</strong>: This parameter requires the name of the first component property to constrain. If this is left empty, the name parameter will search <a id="id325" class="indexterm"/>in its <strong>Owner</strong> for a parameter name. If <strong>Owner</strong> returns null, this parameter will use the <strong>Root Component</strong> of <strong>Actor 1</strong>.</li><li class="listitem"><strong>Component Name 2</strong>: This parameter requires the name of the second component <a id="id326" class="indexterm"/>property to constrain. If this is left empty, the name parameter will search in its <strong>Owner</strong> for a parameter name. If <strong>Owner</strong> returns null, this parameter will use the <strong>Root Component</strong> of <strong>Actor 2</strong>.</li><li class="listitem"><strong>Joint Name</strong>: This <a id="id327" class="indexterm"/>parameter is used when you work with <strong>Skeletal Meshes</strong> and requires the name of <strong>Bone</strong> that <strong>Joint</strong> is attached to.</li><li class="listitem"><strong>Constraint Bone 1</strong>: This parameter requires the name of the first bone (body) that this <a id="id328" class="indexterm"/>constraint is connecting to and would be the child bone in <strong>Physics Asset</strong>.</li><li class="listitem"><strong>Constraint Bone 2</strong>: This parameter requires the name of the second bone (body) that <a id="id329" class="indexterm"/>this constraint is connecting to and would be the parent bone in <strong>Physics Asset</strong>.</li><li class="listitem"><strong>Disable Collision</strong>: This parameter disables the collision between the bodies joined <a id="id330" class="indexterm"/>by this constraint.</li><li class="listitem"><strong>Enable Projection</strong>: This <a id="id331" class="indexterm"/>parameter ensures that all the bodies are projected so that both these bodies still appear attached to each other if a high enough linear or angular velocity is applied to each element. For example, a tether ball spinning too fast would cause the elements to look detached, but this parameter stops this from happening. If the distance error between the two bodies exceeds 0.1 units, or if the rotation error exceeds 10 degrees, the projection will correct this.</li><li class="listitem"><strong>Projection Linear Tolerance</strong>: This parameter represents <strong>Linear Tolerance</strong> in world <a id="id332" class="indexterm"/>units, and if the distance error exceeds this tolerance limit, the body will be projected.</li><li class="listitem"><strong>Projection Angular Tolerance</strong>: This parameter represents <strong>Angular Tolerance</strong> <a id="id333" class="indexterm"/>in world units, and if the angular distance error exceeds this tolerance limit, the body will be projected.</li><li class="listitem"><strong>Linear X Motion</strong>: This parameter indicates whether or not the linear motion along the <a id="id334" class="indexterm"/><strong>X</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Linear Limit</strong> property will be used to determine whether a motion is allowed.</li><li class="listitem"><strong>Linear Y Motion</strong>: This parameter indicates whether or not the linear motion along the <a id="id335" class="indexterm"/><strong>Y</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Linear Limit</strong> property will be used to determine whether a motion is allowed.</li><li class="listitem"><strong>Linear Z Motion</strong>: This parameter indicates whether or not the linear motion along the <a id="id336" class="indexterm"/><strong>Z</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Linear Limit</strong> property will be used to determine whether a motion is allowed.</li><li class="listitem"><strong>Linear Breakable</strong>: This parameter defines whether or not the joint in the constraint <a id="id337" class="indexterm"/>is breakable based on the <strong>Linear Break Threshold</strong> property.</li><li class="listitem"><strong>Linear Break Threshold</strong>: This parameter defines the force threshold required <a id="id338" class="indexterm"/>to break this joint.</li><li class="listitem"><strong>Angular Swing 1 Motion</strong>: This parameter indicates whether or not the rotation <a id="id339" class="indexterm"/>around the <strong>Z</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Angular Limit</strong> property will be used to determine the range of motion.</li><li class="listitem"><strong>Angular Twist Motion</strong>: This parameter indicates whether or not the rotation around the <a id="id340" class="indexterm"/><strong>X</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Angular Limit</strong> property will be used to determine the range of motion.</li><li class="listitem"><strong>Angular Swing 2 Motion</strong>: This parameter indicates whether or not the rotation <a id="id341" class="indexterm"/>around the <strong>Y</strong> axis is allowed, blocked, or limited. If this is limited, the <strong>Angular Limit</strong> property will be used to determine the range of motion.</li><li class="listitem"><strong>Angular Breakable</strong>: This parameter determines whether or not it is possible to break <a id="id342" class="indexterm"/>the joint with angular force.</li><li class="listitem"><strong>Angular Break Threshold</strong>: This parameter dictates the angular force necessary <a id="id343" class="indexterm"/>to break the joint.</li><li class="listitem"><strong>Linear Position Drive</strong>: This parameter enables/disables the linear position drive. Here, we <a id="id344" class="indexterm"/>can set the <strong>Linear X</strong>, <strong>Y</strong>, and <strong>Z</strong> axes and <strong>Linear Position Target</strong>.</li><li class="listitem"><strong>Linear Velocity Drive</strong>: This parameter enables/disables the linear velocity drive, where <a id="id345" class="indexterm"/>we can set the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> linear velocity targets for the constraint.</li><li class="listitem"><strong>Linear </strong><a id="id346" class="indexterm"/><strong>Position Strength</strong>: This parameter dictates the spring force applied to the linear drive.</li><li class="listitem"><strong>Linear </strong><a id="id347" class="indexterm"/><strong>Velocity Strength</strong>: This parameter determines the damping force applied to the linear drive.</li><li class="listitem"><strong>Linear </strong><a id="id348" class="indexterm"/><strong>Drive Force Limit</strong>: This parameter limits the force that can be applied to the linear drive.</li><li class="listitem"><strong>Angular </strong><a id="id349" class="indexterm"/><strong>Orientation Drive</strong>: This parameter enables the angular drive towards a target orientation along the <strong>X</strong>, <strong>Y</strong>, or <strong>Z</strong> axes.</li><li class="listitem"><strong>Angular </strong><a id="id350" class="indexterm"/><strong>Velocity Drive</strong>: This parameter enables the angular drive towards a target velocity along the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> axes.</li><li class="listitem"><strong>Angular </strong><a id="id351" class="indexterm"/><strong>Drive Force Limit</strong>: This parameter limits the force that the angular drive can apply.</li><li class="listitem"><strong>Angular Position Strength</strong>: This parameter applies a spring force value to the <a id="id352" class="indexterm"/>angular drive.</li><li class="listitem"><strong>Angular </strong><a id="id353" class="indexterm"/><strong>Velocity Strength</strong>: This parameter applies a damping value to the angular drive.</li><li class="listitem"><strong>Angular Drive Mode</strong>: This parameter determines the way the angular paths are <a id="id354" class="indexterm"/>estimated; we can either select <strong>SLERP (Spherical Linear Interpolation)</strong> or decompose it into <strong>Twist and Swing</strong>.</li></ul></div><p>Now that we have briefly discussed the parameters available in the <strong>Physics Constraint</strong> component, let's apply angular damping to our constraint so that it can be slowed down and brought to a complete halt. In order to make this happen, we will need to apply <strong>Angular Velocity Drive</strong> and set <strong>Angular Velocity Strength</strong> to a value of <code class="literal">15.0</code>. Next, we will need to set <strong>Angular Drive Mode</strong> to <strong>Twist and Swing</strong>; the remaining parameters can be set to their default values. Once applied, let's compile, save, and jump back to <strong>FirstPersonExampleMap</strong>. We will see that over a short period of time, <strong>Constrained Mesh</strong> will slowly come to a halt. This is due to the high value of the <strong>Angular Velocity Strength</strong> parameter; the higher the value, the quicker <strong>Constrained Mesh</strong> will come to a halt. The lower the number, the longer it would take for <strong>Constrained Mesh</strong> to come to a halt all the way to the point where the mesh will not stop swinging.</p><p>What we can do now to <a id="id355" class="indexterm"/>conclude this chapter is set an angular force break so that if the constrained mesh moves with enough force, it will break from the constraint entirely and become its own unique physics body. To accomplish this, let's return to the <strong>BP_Constraint</strong> blueprint and select the <strong>Physics Constraint</strong> component from the <strong>Components</strong> tab. Now, in the <strong>Details</strong> panel under the <strong>Angular Limits</strong> section, we can set <strong>Angular Swing 1 Motion</strong>, <strong>Angular Twist Motion</strong>, and <strong>Angular Swing 2 Motion</strong> to <strong>Limited</strong> and leave their <strong>Angle</strong> values as their defaults. Lastly, make sure that the <strong>Angular Breakable</strong> parameter is checked and <strong>Angular Break Threshold</strong> is set to a value of <code class="literal">50</code>. If we compile and save the blueprint and jump back to the <strong>FirstPersonExampleMap</strong> level, we will see that when we shoot the constrained mesh enough times to cause its angular velocity to increase, once it reaches the threshold that we set, the mesh will separate entirely from the constraint. From here, we can interact with the separated mesh as its own physics body. This scenario is useful if you want to simulate physics for a tire swing, or for any type of a pendulum object that we wish to provide this behavior to. Feel free to experiment with the <strong>Physics Constraint</strong> values to see how else we can affect the behaviors of the constraint.</p><div><img src="img/image00306.jpeg" alt="Physics Damping"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Physics Damping – a section review</h1></div></div></div><p>In this section, we looked at <a id="id356" class="indexterm"/>how to explore <strong>Physics Damping</strong> using blueprints and the <strong>Physics Constraint</strong> component. By setting values in <strong>Physics Constraint</strong>, we are able to simulate a pendulum in our game world that would swing forever until we apply angular damping with the <strong>Angular Velocity Strength</strong> parameter. Lastly, we applied an angular threshold that would cause our constrained mesh to break from the joint and become its own separate physics body.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we discussed what <strong>Physics Bodies</strong> are and how they function in Unreal Engine 4. Moreover, we looked at the properties that are involved in <strong>Physics Bodies</strong> and how these properties can affect the behavior of these bodies in the game.</p><p>Next, we explored what <strong>Angular</strong> and <strong>Linear Damping</strong> are and how they can affect our <strong>Physics Bodies</strong>. We also discussed real-world physics when it comes to linear and angular momentum, apart from linear and angular velocities.</p><p>Additionally, we briefly discussed <strong>Physical Materials</strong>, how to create them, and what their properties entail when it comes to affecting its behavior in the game. We then reviewed how to apply <strong>Physical Materials</strong> to static meshes, materials, material instances, and skeletal meshes.</p><p>Lastly, we applied <strong>Physics Damping</strong> to <strong>Physics Constraint</strong> by creating a working blueprint example, where we constrained two cube meshes together and created a pendulum. Moreover, we applied angular damping and angular threshold breaks to slowly bring the constrained cube mesh to a halt. We also implemented the ability for the constrained mesh to break from the joint to become its own physics body.</p><p>Now that we have a stronger understanding of how <strong>Physics Bodies</strong> work in the context of angular and linear velocities, momentum, and the application of damping, we can move on and explore in detail how <strong>Physical Materials</strong> work and how they are implemented.</p></div></body></html>