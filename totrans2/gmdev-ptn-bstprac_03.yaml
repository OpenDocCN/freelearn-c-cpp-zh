- en: Creating Flexibility with the Component Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw how the Singleton pattern can help us solve the
    problem of creating and using the big core engines of our game. The engine code
    is designed to work with any game, meaning there is nothing gameplay-specific
    about it. So as the game design evolves, we don't need to worry about changes
    in game design breaking our engine. The goal when writing code for a graphics
    or physics engine is to make it as reusable or game-agnostic as possible. This
    means that when you are done making the current game, you should be able to use
    the code in the next game with very little or no change. The way to do this is
    to separate the engine code from anything related to the specific game.
  prefs: []
  type: TYPE_NORMAL
- en: Game objects, on the other hand, are completely specific to our game. If the
    game changes, all our object types will need to change as well. If we are making
    a platformer and suddenly change to making a Space Shooter, our graphics and physics
    engine code probably doesn't need to change. However, every single game object
    and behavior will change. While this may be the most extreme example, the fact
    is that our game objects are likely to change a lot. So let's look at how we can
    use patterns to solve this small, but very important, piece of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be focusing on creating a game object that is flexible
    enough to adapt as our game design changes. We will do this by first looking at
    the two most common ways that new programmers create a game object, and the problems
    that arise when we use these approaches. Then we will discuss two design patterns
    that can help us solve our problem. Finally, we will arrive at our solution of
    creating a reusable, flexible game object. Since we know our game design and game
    objects are likely to change, the questions we are going to answer are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to write game objects in a reusable way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we decouple our game objects from our core engine code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a reusable game object, how can we make it flexible enough to use
    in different games or account for changes in our game design while the game is
    being developed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we will discuss a few important design principles that will come
    up again and again in this book that will help you write clean and solid code.
  prefs: []
  type: TYPE_NORMAL
- en: Your objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will be focusing on a lot of important
    concepts and diving deep into some interesting code. Some of these concepts are
    about ways not to implement a game object. Learning the wrong way is often just
    as important as learning the right way. Here is an outline of the topics we will
    cover and your tasks for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why a monolithic game object is a bad design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why inheritance hierarchies are inflexible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning and implementing the Strategy pattern and the Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning and implementing the Component Object Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why a monolithic game object is a bad design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you break it down to the simplest terms, programming is about solving problems
    with code. Someone has an idea for a game or an app, and the problem that needs
    to be solved is how to describe that idea logically and correctly to the computer.
    Day to day, these problems usually come in the form of integrating code you wrote
    today with code written earlier by you or another programmer. When solving these
    problems, there is a constant struggle between doing things the *easy way* or
    doing them the *right way*.
  prefs: []
  type: TYPE_NORMAL
- en: The *easy way* to solve a problem means solving the immediate problem in the
    fastest way possible. Examples of this might be hardcoding a number or string
    literal instead of using a named constant, copying code instead of writing a function
    or refactoring code into a base class, or just writing code without thinking about
    how it can impact the rest of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, solving a problem the *right way* means thinking about how
    the new code will interact with the old code. It also means thinking about how
    the new code will interact with future code if the design changes. The *right
    way* doesn't mean that there is only one correct solution to the problem. There
    are often many possible ways to reach the same result. The creativity involved
    in programming is one of the reasons programming is so much fun.
  prefs: []
  type: TYPE_NORMAL
- en: Veteran programmers know that in the long run, the *easy way* often turns out
    to be more difficult. This is often because a quick fix solves an immediate problem
    but doesn't consider the changes that will occur as the project evolves.
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic game object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *easy way* to do a game object is to have a single `struct` that contains
    all of the data a game object will need. This seems correct because everything
    in the game has the same basic data. For example, we know players and enemies
    all have a position, scale, and rotation. So our struct will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This game object works well in theory, but it is too basic. It is true that
    everything in our game probably needs a position, scale, and rotation. Even an
    invisible trigger region needs these properties. However, as it stands, we can''t
    draw our object: we have no health, and no way to do damage. So, let''s add a
    few things to make the game object a little more real:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have added a few more basic elements to our game object. Most of our
    game object types will have health and damage, and we have added a texture ID
    so we can draw our game object, and some texture coordinates so we can use a sprite
    sheet for animation. Finally, we added a color so we can reuse the same texture
    and color it differently for different enemies (think about the different ghosts
    in Namco's *Pacman*).
  prefs: []
  type: TYPE_NORMAL
- en: This is not that bad yet but, unfortunately, this is just the beginning. Once
    we start making a real game instead of just brainstorming about a basic game object,
    our struct member count starts to explode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are making a Space Shooter. There are lots of things we will want
    to add:'
  prefs: []
  type: TYPE_NORMAL
- en: The player will have multiple types of weapons that all do different amounts
    of damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player might have access to bombs and missiles that each have an ammo count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The missile needs a target to seek
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bomb needs an explosion radius
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two super enemies that each have a special ability with a cool-down
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player and one super enemy both have the ability to use a shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI buttons have some actions associated with clicking them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have power-ups that add health and add lives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to add a lives count to all objects to account for the power up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should add velocity to objects and do time-based movement instead of just
    setting the position directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to add an enumeration for the type of the game object so we can update
    it properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what our game object looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this basic method of creating a game object doesn't scale very
    well. We already have more than 25 members in our struct and we haven't even talked
    about adding space stations that can spawn or repair units. We have only two boss
    types, we can make a few enemy types by allowing different enemies to use different
    player weapons such as the laser or missiles, but we are still limited.
  prefs: []
  type: TYPE_NORMAL
- en: The major problem with this approach is that, as the game gets bigger, our game
    object must also get very big. Some types, such as the player, will use many of
    these members, but other types, such as a UI button, will only use a small amount.
    This means if we have lots of game objects, we are very likely wasting a lot of
    memory per object.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with object behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only considered what members the game object has. We haven''t
    considered how each object will have its behavior updated. Right now, the game
    object is just data. Since it has no functions, it can''t update itself. We could
    easily add an `Update` function for the game object but, in order to update each
    type of object correctly, we would need a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, this approach doesn't scale well. As we add more object types, we need
    to add even more cases to our `switch` statement. Since we only have one `struct`
    type, we need to have a `switch` statement, whenever we need to do something object-type-specific.
  prefs: []
  type: TYPE_NORMAL
- en: If we are adding behaviors, we will also face the decision of adding data to
    our object or hardcoding a value into the `switch` statement. For example, if
    our bomb grows in size, how does it grow? We could hard code `scale.x *= 1.1f`
    into our `switch` statement or we can add member data float `bombScaleFactor`
    to our struct.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, this approach just isn't that flexible. Changing our design is very
    difficult because there are `switch` statements and public members throughout
    our code. If we were to make a game like this, then our code base would be a complete
    mess after only a few months. The worst part would be that once the game was completed,
    we wouldn't be able to reuse any code. The game object and all behaviors would
    be so gameplay-specific that unless we make a sequel, we would need to remake
    a brand new game object.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of the monolithic game object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is worth noting that even if you choose this approach, you can still have
    your core engines decoupled from the game object. When writing the graphics engine,
    for example, instead of passing in a game object as a parameter to a `Draw` function,
    we could pass in the members that the graphics engine needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another argument for creating objects like this is that we know exactly what
    is in our game object. Compared with other approaches, we never need to cast our
    object or search for properties within the object. These operations make the code
    more complicated and have a slight performance cost. By using a simple `struct`,
    we have direct access to the variables and the code is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The only time we might use this approach is if we know 100% that the number
    of object types won't be large, for example, if you are making a puzzle game and
    the only game objects are sheep and walls. Puzzle games are often very simple
    and use the same mechanics over and over. In this case, this is a good approach
    because it is easy and doesn't require any time building a complicated system.
  prefs: []
  type: TYPE_NORMAL
- en: Why inheritance hierarchies are inflexible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea that **Players**, **Enemies**, **Missiles**, and **Medics** should
    all derive from one base object is very common to programmers new to object-oriented
    programming. It makes a lot of sense on paper that if you have a Raider and a
    SuperRaider, one should inherit from the other. I believe this comes from how
    inheritance is taught. When you are first learning about inheritance, you will
    almost always see a picture similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 - A typical inheritance diagram when learning to program
  prefs: []
  type: TYPE_NORMAL
- en: Many introductory programming courses are so focused on the mechanics of inheritance
    that they forget to tell you how to use it properly. A picture like the one above
    makes it easy to understand that ITWorker is an Employee, which is a Person. However,
    once you go beyond the mechanics, it is time to learn how to use inheritance correctly.
    This is why books on design patterns exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance is a powerful tool that lets us extend classes by adding members
    and methods that are specific to the derived classes. It allows us to start with
    general code and create more specialized classes. This solves one of the original
    problems that we had with the extremely bloated object struct in the first section.
    Inheritance lets us take an existing class, such as a Raider, and add more members
    to create a SuperRaider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 - An example of Space Shooter inheritance hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchy makes a lot of sense when first designing a space shooter. It
    allows us to separate the details of a `Raider` class or a `Bomber` class away
    from the `Player` class. Adding a game object is easy because we can extend a
    class to create what we need. Removing a game object is easy because all the code
    is contained within each derived class. In fact, now that we have separate classes,
    each one can be responsible for itself via class methods. This means we no longer
    need `switch` statements all over our code.
  prefs: []
  type: TYPE_NORMAL
- en: Best of all, we can use the power of virtual functions to decouple our derived
    classes from the core engines of our game. By using an array of base class pointers
    to the derived class instances, our core engines such as graphics or physics are
    only coupled to the object interface instead of derived classes, such as `Planet`
    or `SpawnerStation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without inheritance hierarchy, the code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With inheritance and polymorphism, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Organizing the code by what it does, not what it is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the Raider and the Bomber, really? How are a
    Raider and a SuperRaider different? Maybe they have a different speed, a different
    texture, and a different damage value? Do these changes in data really require
    a new class? Those are really just different values, not different behaviors.
    The problem is that we are creating extra classes because the concept of a Raider
    and SuperRaider is different, but there aren't differences in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class hierarchy actually violates three principles I teach, two of which
    I learned from the Gang of Four book:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Keep your inheritance trees shallow"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Favor object composition over class inheritance" - Gang of Four, p20'
  prefs: []
  type: TYPE_NORMAL
- en: '"Consider what should be variable in your design. This approach is the opposite
    of focusing on the cause of redesign. Instead of considering what might force
    a change to a design, consider what you want to be able to change without redesign.
    The focus here is on encapsulating the concept that varies, a theme of many design
    patterns" - Gang of Four, p29'
  prefs: []
  type: TYPE_NORMAL
- en: 'A different way to state the third principle is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Find what varies and encapsulate it"'
  prefs: []
  type: TYPE_NORMAL
- en: These principles exist to eliminate, or completely avoid, the problems that
    can and will arise when using inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with our current design is that if we create a new class for every
    object type, we will end up with a lot of little classes that are mostly the same.
    Raider, SuperRaider, Bomber, and SuperBomber are mostly the same with just a few
    minor differences, some of which are only differences in `float` and `int` values.
    While this approach may seem like an improvement over the *easy way*, it becomes
    a problem because we will end up writing the same behavior code over and over
    again in many classes. If we have a lot of enemies, we might end up writing the
    same basic `ChasePlayerAI` code in every `Update` function. The only solution
    is moving the `ChasePlayerAI` up to a base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at our Space Shooter hierarchy but this time, let''s
    add in some different behaviors to our classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 - After adding behavior to our objects (refer graphic bundle)
  prefs: []
  type: TYPE_NORMAL
- en: We have decided that our base `object` class will at least be drawable to make
    things simple. If an object such as a trigger region needs to be invisible, we
    can simply support disabling rendering by putting a `bool` in the drawable behavior
    so it won't get drawn. However, with this game object approach, I still have some
    duplicated code. Both the `Raider` class and the `AttackStation` class have some
    AI that targets and shoots bullets at the Player. We have only duplicated our
    code once so maybe it isn't a big deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, all game designs will change. What happens when our designer
    wants to add asteroids to our game? Technically, they are structures so they need
    some of the data inherited from that class, but they also move. Our designer also
    really liked the `SpawnerStation` class and wants to add that ability to a new
    `SpawnerPlanet` class, and to a new `BossSpawner` class. Should we rewrite the
    code two more times, or refactor the code into the base class? Our designer also
    wants to give the `Station` the ability to slowly patrol an area. This means the
    `Station` class needs the Patrol AI ability as well. Let''s take a look at our
    hierarchy now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3 4 - After refactoring duplicate code to our base class (refer graphic
    bundle)
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, this approach isn't as flexible as it originally seemed. In
    order for our design to be really flexible, almost all of the behaviors need to
    be factored up into the base class. In the end, we aren't much better off than
    when we wrote our game object the *easy way*. And it is still possible that our
    designer will want to create the `RepairHelper` that chases the Player, meaning
    that everything will be in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound like a contrived example but remember that games take years
    to develop and are likely to change. DMA Design's *Grand Theft Auto* was originally
    titled *Race'n'Chase*, but it was changed because a bug caused the police to try
    and run the Player off the road instead of pull them over. This ended up being
    way more fun. Another example is Blizzard's first-person shooter *Overwatch*,
    which was originally in development for 7 years as a massively multiplayer online
    game.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of object-oriented programming is to recognize that designs will
    change and to write code with that change in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with our inheritance approach is that it isn't very easy to
    add or remove abilities at runtime. Let's say our game has a special power-up
    item that will let the Player use a shield for 1 minute. The shield will absorb
    50% of the damage done to the Player for 1 minute then remove itself. We now have
    the problem of making sure that when a bullet collides with the shield, it will
    transfer some of the damage to the Player. The shield isn't just responsible for
    itself; it is responsible for the Player object too.
  prefs: []
  type: TYPE_NORMAL
- en: This same situation exists for all things that will affect another game object
    for some duration of time. Imagine if we want our Raider to be able to do acid
    damage to the Player over 5 seconds instead. We need a way to attach this acid
    damage to the Player, and to remember to remove it after 5 seconds. We could add
    new variables such as `bool` `hasAcid` and `float` `acidTime` in the `Player`
    class that we can use to know whether we should do acid damage in this frame.
    However, this still isn't a flexible solution, because each new type of damage
    caused over time will need new variables like this.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there is no way to stack the acid damage effect if three enemies
    are attacking the Player with acid damage. If we like this ability and want the
    Player to use it, we also need to give all game objects these extra time-based
    damage variables and behavior code. What we would really like to do is attach
    acid behavior (or any effect) onto a game object at runtime and have it automatically
    detach itself when the effect is over. We are going to talk about how to do that
    later in this chapter, but first we need to talk about one more problem related
    to inherence hierarchies in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the Diamond of Death
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final problem with our inheritance approach involves the situation where
    we take code reuse to the extreme. In our hierarchy, we have SuperRaider, which
    is very fast, weak, and shoots little bullets. We also have SuperBomber, which
    is slow, strong, and shoots big bombs. Someday, a clever designer will want to
    create SuperBomberRaider that is very fast, strong, and shoots both little bullets
    and big bombs. Here is our partial tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 - Example of the Diamond of Death
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is the **Diamond of Death** (or **Dreaded Diamond of Death**),
    so named because the inheritance tree forms a diamond. The problem is that our
    `SuperBomberRaider` inherits from both the `SuperBomber` and `SuperRaider`. Those
    two classes each inherit from the `Enemy`, `Unit`, and `object`. That means `SuperBomberRaider`
    will have two copies of `m_pos`, `m_scale`, `m_rotation`, and every other member
    of `object`, `Unit`, and `Enemy`.
  prefs: []
  type: TYPE_NORMAL
- en: There will also be two copies of any functions that are contained in the `Object`,
    `Unit`, and `Enemy`. This means we need to specify which version of the functions
    we wish to use. This might sound good, since we get behavior from both classes,
    but remember that the individual base class function will only modify their version
    of variables. After calling `SuperRaider::Update` and `SuperBomber::Update`, we
    now need to figure out what version of `m_pos` (and `m_scale` and `m_rotation`)
    we want to use when we draw our object.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has ways of solving this problem, but most programmers agree that the solution
    makes things more complicated to understand and more difficult to use. The rule
    of thumb is that we should just avoid using multiple inheritance. We have seen
    some of the problems that it can cause and we haven't even talked about bugs related
    to using `new` and `delete` in a situation like this.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern and the Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that in trying to be more flexible with our game object, a lot of behavior
    was factored into the base class. We also said that it would be nice to attach
    a behavior at runtime and have it detach itself when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually two design patterns that have the potential to help our design,
    the Strategy pattern and the Decorator pattern. The Strategy pattern is all about
    encapsulating sets of behaviors instead of inheriting. The Decorator pattern is
    all about dynamically adding responsibilities as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Strategy pattern is about encapsulating a set of behaviors and having the
    client control the behavior through an interface, instead of hardcoding the behavior
    into the client function itself. What this means is that we want the game object
    to be completely independent of the behavior it uses. Imagine that we want to
    give each enemy a different attack and flight AI. We could use the Strategy pattern
    instead of creating an inheritance tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our client is the `Enemy` class and the interfaces that the client
    controls are the `AttackAI` and `FlightAI`. This is a much better solution than
    inheriting from the `Enemy` because we are only encapsulating what varies: the
    behavior. This pattern allows us to create as many `FlightAI` derived classes
    as we need and to reuse them to create different kinds of game object types, without
    needing to expand our inheritance tree. Since we can mix different strategy combinations,
    we can get a large number of different overall behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to share the same strategies for both units and structures, so
    we should actually remove our inheritance tree altogether and just use the `Object`
    as our client. This way, the `Object` class becomes a collection of strategies,
    and our design is simpler. Plus, we are following some great programming principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Programing to an interface means that our client depends on behavior in an abstract
    class instead putting behavior in the client itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our interfaces are opened for extension so we can easily add as many behaviors
    as we need. The interface is simple so it won't need to be changed, which might
    break code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our inheritance trees are shallow so we don't need to worry about the Diamond
    of Death.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 - Example of our Object using the Strategy pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern allows our game object to be very flexible without the
    need for an inheritance tree. With these six small classes shown in the preceding
    diagram, we can have a total of nine different game object behaviors. If we add
    a new **FlightAI**, we have 12 possible game object behaviors. Creating brand
    new strategies allows for an amazing amount of mixed behaviors. However, if we
    only extend just the two strategies, we don't need to modify the **Object** at
    all. This works for the Player as well, if we make an **AttackAI** and **FlightAI**
    that have access to input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Staying with only two strategies is unlikely, which means that whenever we
    add a new strategy, we will need to change the **Object** by adding a new member
    and modifying the `Update` function. This means that while the pattern is flexible
    enough to let us change strategies at runtime, we can''t add behaviors dynamically.
    If we need to add acid damage as a debuff in our game, we would need a `Damage`
    base class, and to give a `Damage` base class pointer to the `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't seem like a great solution because most damage will be instantaneous
    and, most of the time, the player isn't even taking damage. That means this will
    be either null or an empty strategy class, such as using a `NoDamage` derived
    class, that will be updated every frame but will do nothing. This is also no way
    to stack corrosive effects or to have two types of damage affecting the Player,
    such as corrosive damage and ice damage, which might cause the Player to move
    slower for 10 seconds. We really need a way to dynamically add and remove these
    abilities. Luckily, there is a pattern for that.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the Decorator pattern is to dynamically add responsibilities
    to an object at runtime. The goal is to be a flexible alternative to creating
    derived classes while still allowing for extended behavior. What this means is
    that we can take our `object` and add decorations or, in our case, behaviors at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern requires that the `Decorator` and our `object` are derived from
    a common base class so they share the same interface. Each `Decorator` will then
    layer itself on top of an `object` or another `Decorator` to create more interesting
    object types and effects. When a function gets called on a `Decorator`, it will
    call the corresponding function on the next layer down, eventually calling the
    function of the `object`. It is similar in concept to the *Russian Matryoshka*
    dolls, the dolls that contain smaller and smaller versions inside of themselves.
    The final, most nested object is always the object with the core functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 - The layering effects of the Decorator pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simplified version in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 - The Decorator pattern using our Object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Decorator` classes layer our concrete `object` class and add more information
    on top of the `object`. However, right now, all we are doing is adding superficial
    decorations. Since the `Decorator` class doesn't know whether it has a pointer
    to the `object` class or another `Decorator`, it can't modify the `object`. A
    good analogy is that the Strategy pattern changes the guts of the object, while
    the Decorator pattern changes the skin. This can be useful but doesn't help us
    with our buff/debuff problem. To solve this problem, we would need to add a method
    to find the `object` down the chain, or give a pointer to the `object` in the
    constructor of a `Decorator`.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that this pattern was designed to add a `Decorator` dynamically,
    but doesn't allow us to remove one. In the case of using a corrosive damage `Decorator`,
    we would only want it to exist for a set time, and then automatically detach itself.
    This can't be done, since a `Decorator` doesn't have a pointer to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: The final problem for games is that our `Decorators` can't live in a vacuum.
    Sometimes, different gameplay behaviors may need to interact with each other.
    For example, the corrosive damage `Decorator` may affect the health of an `object`;
    however, it may first need to check whether the `object` has a shield `Decorator`
    and remove health from the shield.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, neither the Decorator nor the Strategy pattern will work perfectly
    for us. What we really need is a new pattern that is a combination of the Strategy
    and Decorator patterns that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulates specific behavior into components so we avoid `Object` inheritance
    trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows for a flexible number of components so we don't need to modify the `Object`
    each time we create a new component type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets us add and remove components at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gives components direct access to the `Object` so it can be modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows components to be searchable by other components so they can interact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Component Object Model explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The alternative can be found by many names, though none are definitive yet.
    In this book, we will call it the **Component Object Model**, but others have
    called the **Entity Component System** or just **Component System**. No matter
    what you call it, the concept is surprisingly simple to learn and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The Component Object Model inverts the concept of the Decorator pattern, where
    each `Decorator` added a new layer on top of the game object. Instead of layering
    our `object`, which we have already seen problems with, we will put the decorations
    inside of it. Since we don't know how many we will need, our `object` will hold
    a container of decorations, as opposed to a single pointer. In the simplest form,
    our `object` is nothing more than a container for these components.
  prefs: []
  type: TYPE_NORMAL
- en: If you search for Component Object Model (or Component Based object Model) on
    the Internet, you will get results that are similar to what we saw in the Strategy
    pattern. The object contains hardcoded pointers to each possible strategy. While
    using this approach alone is much better than a monolithic object or an inheritance-based
    object, we are stuck checking for null pointers or constantly modifying what strategies
    exists in our `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this alternative method, every strategy type will derive from a common interface.
    This way, our `object` can contain an array, or in our case an STL vector of base
    class `Component` pointers. This is like the `Decorator`, except our `object`
    is a separate class; it doesn''t derive from the `Component` interface. Instead,
    a `Component` will have a pointer to its parent `object` class. This solves the
    problem in which a `Decorator` didn''t know whether it held a pointer to another
    `Decorator`, or to the actual `object`. Here we avoid that problem by always giving
    our `Component` a pointer to the `object` it controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 - The Component Object Model
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to be very flexible because our **object** is nothing
    more than components. There is nothing in it that is specific to any type. There
    is no code that is strictly for the Player or SuperRaider. We are free to add,
    change, or remove anything at runtime. This is important because in the early
    stages of development, the game design and game objects will change a lot. If
    we were to hardcode pointers to different base class `Strategies`, we would spend
    a lot of time changing those pointer types in the game object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Component Object Model makes our code almost completely reusable as
    well. The game object itself is just an empty container of Components, and they
    are often so simple that most of them, such as a **CircleCollider**, can be used
    in any game. This means that a behavior component, originally meant only for the
    Player or SpawnerStation, can be easily used for any game object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Component Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen a basic version in code as well as a diagram, let''s
    look at exactly how the Mach5 Engine implements this system. As you will see,
    the `M5object`, as it is called, contains a position, rotation, scale, and velocity.
    Of course, these elements could be contained in a transform component; however,
    these are so common that most other components will need access to this information.
    This is different to data such as texture coordinates or a circle collider''s
    radius, which might not need to be shared at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you will notice is that there are two enumerations in this code,
    `M5ArcheTypes` and `M5ComponentTypes`. These will become more useful later when
    we talk about creating Factories. However, for now, it is enough to understand
    that these will allow us to search through a collection of `M5objects` and get
    the components we need. For example, if we have a collection of `M5objects` but
    we need to find the Player, the `M5ArcheTypes` enum will allow us to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you will notice is the `M5object` is more than just a container
    of components. It has some public and private data. The public data is unlikely
    to need validating or protecting. We could create getters and setters but they
    would really just simply get and set the data, so it isn''t 100% necessary. Since
    they are public, we are locked into keeping them public forever. If you wish to
    make them `private` and create `accessor` methods, that is fine. There are some
    very important variables that we want to be private. The ID and the type are set
    once and can''t be changed, and the array of components is accessed through functions
    to add, remove, and clear all components. Let''s discuss the purpose of the public
    variables first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pos`: The position of the `M5Object`. This is the rotational center, or pivot
    point, of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: The height and width of the `M5Object`, before rotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vel`: The velocity of the `M5Object`. This is used to do time-based movement
    instead of simply setting the position to plus or minus some value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation`: The rotation in radians. Positive rotations are counterclockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotationalVel`: The rotational velocity of the `M5Object`, used to do time-based
    rotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isDead`: This allows the `M5Object` to mark itself for deletion. Other objects
    or components are free to call one of the `DestroyObject` functions found in the
    `M5ObjectManager`; however, it isn''t a good idea for an object to delete itself
    in the middle of its own `Update` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are keeping these as part of the `M5object` because they are so common that
    all or almost all components will need access to them. We are marking these as
    public because there is no validation or protecting that we need to do on the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private section starts with two type `defs`. They let us create shorter
    names for templated types. This is simply a style choice. Another style choice
    is to have an `m_` in front of all of the private member variable names. This
    or something similar is a common practice for class members. We didn''t do this
    with our public members because we are treating them more like properties. Now
    let''s look at the rest of the private data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`m_components`: This is the array of `M5Component` pointers. Each component
    in the vector will get updated in the `Update` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_type`: The type of object. It will get set in the constructor and never
    change. It allows the user to use the `M5ObjectManager` to search or remove objects
    based on type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_id`: This is a unique ID among `M5Objects`. It can be useful in cases such
    as a missile needing to target a specific instance of an object. If the missile
    contains a pointer to the target object, it can''t know whether the object has
    been destroyed. If we instead know the ID, we can search to see whether the target
    still exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_objectIDCounter`: This is the shared ID counter for all `M5Objects`. This
    guarantees that each object will get a unique value because they are all using
    the same shared variable. Notice that this is marked with an `s_` to indicate
    that it is static.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is all of the data in the `object`. Now, let's look at the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`M5object` is the constructor for the class. It sets starting values for the
    variables as well as setting the type and giving a unique ID. Notice that we reserve
    an amount of starting space for the vector. A game object can have as many components
    as it needs, but in an actual game, we don''t expect them to have more than a
    few on average. By pre-allocating, we may avoid any additional calls to new (we
    will be a doing a lot anyway):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`~M5object` is the destructor for our game object. Here we want to make sure
    that we delete all of the components in our game object, so we make use of one
    of our public functions to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`AddComponent` adds the given component pointer to this object vector. You
    will notice that before the component is added, you will need to first check to
    make sure the same pointer isn''t already in the list. While this isn''t very
    likely to happen, it could be a hard bug to find later so it is worth the check.
    It is also important when given a component to use the `SetParent` method of `M5Component`
    to make sure this object will be controlled by the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Update` is the most used function in the `M5object`. This will get called
    automatically by the `M5ObjectManager` every frame. It is used to update every
    component as well as update position and rotation based on their velocities. The
    other important role of the `Update` function is that it deletes any dead components.
    Except for the `RemoveAllComponents` function, this is the only place where components
    are deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`RemoveComponent` is used for cases such as when you have buffs or debuffs
    on an object and you want the stage, or some other object, to delete it. For example,
    the Player may be using a shield but, after being hit with ion damage, the physics
    collider finds the shield and immediately removes it. Instead of using this method,
    it would also be fine to simply mark the component as dead and it will be cleaned
    up in the next update loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code follows a similar pattern to the `AddComponent` function. First,
    we test to make sure the component exists. If it does exist, we swap places with
    the last item in the vector and pop back the vector. After that, we use the `SetParent`
    method to remove this object as the parent pointer before deleting it. This is
    a small precaution as, in case another pointer to this component exists, the program
    will crash instead of causing an undefined error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`RemoveAllComponents` is the helper function used in the destructor. It deletes
    all components in the object. Except for the destructor, there probably isn''t
    much use for it. However, it was made public for those rare occasions where this
    is the behavior you need. This function simply loops through the vector and deletes
    every component, then finally clears the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second version of `RemoveAllComponents` removes all components of a specific
    type. This is another situation where external code, such as a stage, object,
    or even another component needs to remove a group of the same component type.
    This could be used to remove all corrosive damage effects on the Player, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we are searching for the correct type, so we cannot use the `std::vector::find`
    method. Instead, we use a `for` loop and check the type of each component. If
    we find the correct type, we delete the current one, swap with the end and pop
    back. Since we are doing a swap, but continue searching, we must make sure to
    check the current index again to see whether it matches as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`GetComponent` and `GetAllComponents` are helper functions to find and cast
    specific component types in an `M5object`, if they exist. As I said before, sometimes
    it is necessary that components interact. In that case, we need a way to search
    for a specific component and to convert it to the correct type. These two functions
    are almost the same. The first one finds the first instance of the correct component
    type and assigns it to the pointer parameter. If one doesn''t exist, we make sure
    to set the parameter to `0`. The second one finds all components of the correct
    type and saves them in the vector parameter. These are template functions so the
    component can be cast to the correct type supplied by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `GetID` and `GetType` functions just return the private class data. The
    `Clone` method is more interesting but we will go into more detail about it when
    we discuss the Prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen the `M5object`, let's take a look at how the Mach5 Engine
    creates and uses the component hierarchy. Since this is an abstract class, there
    is no way to create an instance of an `M5Component`. It is only an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see, the base component contains some of the same members as the
    `M5object`. Since we will have a lot of components, it is important to give each
    one a type, so they can be searchable. It is important to give each a unique ID.
    Since these components can be deleted at any time, it is important to save an
    ID instead of a pointer, which can become invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The data section doesn''t contain as much as the `M5object`, but now it is
    split into three sections which are `public`, `private`, and `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isDead`: This is the only public data and it serves a similar function to
    the member in the game object. This allows the component to mark itself for deletion.
    It isn''t a good idea for a component to call `RemoveComponent` on itself during
    its own `Update` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_pObj`: This is a pointer to the `M5Object` that owns this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_id`: The unique ID of this component. This allows users to get access to
    this specific component again, without the risk of saving a pointer which may
    become invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_type`: The type of this component. This allows users to search for a specific
    component within a game object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_compIDCounter`: This is used to create a unique ID for each component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions of the `M5Component` are not that interesting because they are
    mostly virtual. However, it is worth going over their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '`M5Component` is the non-default constructor for the component. This takes
    an argument of type `M5ComponentTypes` so that the private data `m_type` is guaranteed
    to be set by a derived type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`~M5Component` is the destructor for the class. Since this is meant to be a
    base class, it is important that a virtual destructor exists so that the correct
    method will be called when using polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Update` is where the component does the action. This method will be called
    every frame and its intended purpose is to add a behavior and/or data to the `M5object`.
    It is marked as pure virtual (`= 0`) so that the base class is forced to override
    it. That also means there is no body to the base class version.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FromFile` is a virtual function that allows the component to read data from
    a preloaded INI file. It is not marked as pure virtual, meaning that a component
    doesn''t need to override this function. This might be the case if the derived
    component has no data to be loaded from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `SetParent` method is simply a setter for `m_pObj`. Recall the `AddComponent`
    function of `M5object`. When a component is added to an object, the object uses
    this function so the component knows which object to control.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetType` and `GetID` functions are similar to the functions in `M5object`.
    They allow the component to be searchable and saved without needing to use pointers
    that may become invalid. The `M5Component` also has a pure virtual `Clone` method.
    There is no function body in the base class. We will discuss the `Clone` method
    of both `M5Component` and `M5object` when we discuss the Prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To add a behavior to an object, we must derive from the `M5Component` base class,
    overload the necessary methods, add a value to the `M5ComponentTypes` enumeration,
    then finally register the class and the associated builder with the object manager.
    Of course, these steps are prone to error and doing them repeatedly would be very
    tedious.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the Mach5 engine has included a batch file to do these steps
    automatically. By adding components to the `Source` folder within the file hierarchy,
    the batch file will find all files named `*Component.h`, where the asterisk is
    a wildcard character that includes any valid C++ identifier.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a component named `LazerComponent` is located within a file
    named `LazerComponent.h`, an enumeration value named `CT_LazerComponent` will
    be automatically created along with the correct class builder, and both will be
    registered with the `M5ObjectManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing objects and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use the Component Object Model, first create a game object, then
    add some components, then finally add it to the `M5ObjectManager` which calls
    an update on the game object every frame. Let's look at some code for creating
    objects and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create a `Player` object to fly around on screen, but stay
    within the bounds of the screen, we could do this inside the `Init` method of
    a stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works fine, but there are a few problems. First, we didn''t specify
    what texture we want. However, we could easily add a `textureID` or filename as
    a parameter to the `GfxComponent` constructor. The larger problem is that this
    code was tedious to write and we don''t want to write it again and again. If we
    are creating a Player in another stage, it will likely contain the exact same
    code. So a better approach is to factor this code into the `M5ObjectManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our stage `Init` function, we can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is pretty hardcoded. This explicitly creates all of the components
    that a Player (and every type) needs, which means that our `M5ObjectManager` now
    contains game-specific code. The benefit of using the Component Object Model is
    that it is flexible, but we have lost some of that flexibility by having a hardcoded
    `switch` statement. We really want our designers, not programmers, to choose what
    goes into a Player, Raider, or SuperRaider. That means loading our object types
    from a file. In our case, we will use INI files because they are simple to use
    and simple to understand. They consist of global or labeled sections of key/value
    pairs. Here is an example Player archetype found in `Player.ini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first (global) section of the INI file contains all data found
    in the `M5object`. Since we know that those variables always exist in the object,
    they are placed at the top. This includes a list of components that this archetype
    will use. Here we have `GfxComponent`, `PlayerInputComponent`, and `ClampComponent`.
    The next sections are data associated with each component, for example, with the
    `GfxComponent` we can specify our texture to load. The `ClampComponent` doesn't
    need any data loaded so we didn't need to add a section for it.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the Component Object Model with the monolithic object or the inheritance
    tree, we can see that the component-based approach is vastly more flexible and
    reusable. With this method, we can write as many different components as we want
    and let the designer choose what behaviors each object uses. The best part is
    that everything but the most game-specific components can be reused in another
    game.
  prefs: []
  type: TYPE_NORMAL
- en: That means that the `PlayerInputComponent` probably can't be reused in another
    game, but the `ClampComponent` and `GfxComponent` can be used whether we are making
    another Space Shooter, Platformer, or Racer.
  prefs: []
  type: TYPE_NORMAL
- en: 'One note about components used for graphics and physics, such as `GfxComponent`
    and `CircleColliderComponent`: these are special in the sense that they need to
    interact with core engines in a way that other components may not need to. For
    example, the Graphics engine might want to organize these components based on
    whether they are world space objects or screen space objects (referred to as HUD
    space, since these would be things such as buttons and health bars). The Physics
    engine might want to use a special partition data structure to minimize the number
    of collision tests that need to be performed. For this reason, these components
    are automatically registered to their respective core engines when created through
    the object Manager and they automatically unregister when they are deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of benefits to using the Component Object Model. These days,
    many engines use this approach because of the flexibility it provides. However,
    that flexibility comes at a cost to performance. The biggest performance costs
    are calls to new/delete, cache coherency, and virtual methods.
  prefs: []
  type: TYPE_NORMAL
- en: Our `M5ObjectManager` uses pointers to `M5objects` which uses an STL vector
    of pointers to components. This means that as we create `Bullets`, `Asteroids`,
    `Raiders`, and `Planets`, we are constantly calling new and delete. These are
    slow functions and have the chance to fragment our memory. In a later chapter,
    we will see how object pools can help us solve both of these problems.
  prefs: []
  type: TYPE_NORMAL
- en: However, even with object pools, we still have problems with cache misses. The
    fact is that iterating over an array of contiguous data is much faster than iterating
    over an array of pointers to data. When using the Component object Model, the
    CPU will be spending a lot more time chasing pointers and loading that data into
    the cache than if we just used arrays. Unfortunately, this is the price we pay
    for flexibility. Depending on the game, this may or may not cause a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual methods are also a source of potential performance problems because
    the function to call must always be looked up at runtime and they cannot be inlined
    by the compiler. Again, this is the price we pay for flexibility. We have an approach
    that allows our designer to load a behavior from a file and change that behavior
    at runtime. In my opinion, that outweighs the performance issues, at least at
    the beginning of the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard *premature optimization is the root of all evil*. It is more
    important to focus on making a fun game and to solve the performance problems
    later. You always have the option of hardcoding specific behaviors or data in
    the game object much later in the development cycle. If possible, you might merge
    two or more components that always get used together once you are in the polish
    stage. However, by limiting your flexibility early on, you may never discover
    a fun feature that comes from mixing two components in a way that wasn't originally
    planned.
  prefs: []
  type: TYPE_NORMAL
- en: My advice is to focus first on algorithmic optimizations, then macro optimizations,
    then finally micro optimizations. What I mean is that it is better to worry about
    the time complexity of your physics engine and how many draw calls or collision
    tests you are performing, before worrying about what is in the CPU cache or the
    performance cost of virtual functions. While they can be a problem, these things
    fall under the category of micro optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: However, before starting the long process of creating a game using an unfamiliar
    game engine, it can be a good idea to do some simple prototype tests to make sure
    the engine can meet the needs of the game. For example, a programmer could approximate
    the number of objects, and components, and test for performance to see whether
    the engine will work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored many different ways to create a game object.
    We have seen the problems with using monolithic objects or large inheritance trees.
    We now know that neither of those approaches scale when creating a large game.
    They both suffer from the problem of giant bloated classes and dependencies in
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen the flexibility that using the Component Object Model can
    bring to our games. It lets programmers focus on writing new code, while allowing
    designers to use that code to create new object types, even at runtime. Since
    we can now define objects completely in a file, we can create a tool that will
    let our designer, or even players, make completely new objects, or possibly a
    new game.
  prefs: []
  type: TYPE_NORMAL
- en: We also briefly touched on the performance issues related to using the Component
    Object Model. While these can be a problem, it is much better to focus on algorithmic
    optimizations then very low-level CPU instruction optimizations. We will revisit
    these problems in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's move on to a design pattern that can help us implement one of
    the big core engines of our game, as well as a small but important type of component.
    In the next chapter, we will discover how the State pattern can help decouple
    our code and can give us a great way to implement artificial intelligence in our
    game.
  prefs: []
  type: TYPE_NORMAL
