["```cpp\nposX   = 0 \nposY   = 0 \nvelX   = 0 \nvelY   = 0 \nscaleX = 2.5 \nscaleY = 2.5 \nrot    = 0 \nrotVel = 0 \ncomponents =  GfxComponent ParticleComponent \n\n[GfxComponent] \ntexture = particle.tga \ndrawSpace = world \n\n```", "```cpp\n//! AutoGenerated enum based on archetype ini file names   \nenum M5ArcheTypes {   \nAT_Bullet,  \nAT_Particle,  \nAT_Player,  \nAT_Raider,  \nAT_Splash,  \nAT_INVALID  \n}; \n\n```", "```cpp\n/******************************************************************************/ \n/*! \n\\file   ParticleComponent.h \n\\author John Doran \n\\par    email: john@johnpdoran.com \n\\par    Mach5 Game Engine \n\\date   2016/12/06 \n\nUsed to display a single particle on the screen. \n*/ \n/******************************************************************************/ \n#ifndef PARTICLE_COMPONENT_H \n#define PARTICLE_COMPONENT_H \n\n#include \"Core\\M5Component.h\" \n#include \"Core\\M5Vec2.h\" \n\nclass ParticleComponent : public M5Component \n{ \npublic: \n  ParticleComponent(); \n  virtual void Update(float dt); \n  virtual M5Component* Clone(void); \n  virtual void FromFile(M5IniFile& iniFile); \n  bool activated; \n  float lifeTime; \n  float endScale; \nprivate: \n  M5Vec2 startScale; \n  float lifeLeft; \n  float Lerp(float start, float end, float fraction); \n}; \n\n#endif // !PARTICLE_COMPONENT_H \n\n```", "```cpp\n/******************************************************************************/ \n/*! \n\\file   ParticleComponent.cpp \n\\author John Doran \n\\par    email: john@johnpdoran.com \n\\par    Mach5 Game Engine \n\\date   2016/12/06 \n\nParticle system component. Allows you to draw many particles on the screen. \n*/ \n/******************************************************************************/ \n#include \"ParticleComponent.h\" \n#include \"Core\\M5Gfx.h\" \n#include \"Core\\M5Math.h\" \n#include \"Core\\M5Object.h\" \n#include \"EngineTest\\M5ObjectPool.h\" \n#include \"Core\\GfxComponent.h\" \n#include \"Core\\M5IniFile.h\" \n\n/******************************************************************************/ \n/*! \nConstrutor for ParticleSystem component.  Sets default values \n*/ \n/******************************************************************************/ \nParticleComponent::ParticleComponent() : \n  M5Component(CT_ParticleComponent) \n{ \n} \n\n/******************************************************************************/ \n/*! \nTakes care of the particle system, decrease lifetime and adjust scaling. \nWill mark for destruction if needed. \n\n\\param [in] dt \nThe time in seconds since the last frame. \n*/ \n/******************************************************************************/ \nvoid ParticleComponent::Update(float dt) \n{ \n  // Decrease our life by the change in time this frame  \n    // (dt stands for delta time) \n  lifeLeft -= dt; \n\n  // Change our size based on where we want it to be \n  float currentPercentage = 1 - (lifeLeft / lifeTime); \n  m_pObj->scale.x = Lerp(startScale.x, \n     startScale.x * endScale, currentPercentage); \n\n  m_pObj->scale.y = Lerp(startScale.y, \n     startScale.y * endScale, currentPercentage); \n\n  // If there is no life left, destroy our object \n  if (lifeLeft <= 0) \n  { \n    m_pObj->isDead = true; \n  } \n\n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nWill give you the percentage of the fraction from start to end \n\n\\param [in] start \nWhat value to start from \n\n\\param [in] end \nWhat value to end from \n\n\\param [in] fraction \nWhat percentage of the way are we are from start to finish \n\n*/ \n/******************************************************************************/ \nfloat ParticleComponent::Lerp(float start, float end, float fraction) \n{ \n  return start + fraction * (end - start); \n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nClones the current component and updates it with the correct information. \n\n\\return \nA new component that is a clone of this one \n*/ \n/******************************************************************************/ \nM5Component * ParticleComponent::Clone(void) \n{ \n  ParticleComponent * pNew = new ParticleComponent; \n  pNew->m_pObj = m_pObj; \n  pNew->startScale = m_pObj->scale; \n  pNew->lifeTime = lifeTime; \n  pNew->lifeLeft = lifeTime; \n  pNew->endScale = endScale; \n  return pNew; \n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nReads in data from a preloaded ini file. \n\n\\param [in] iniFile \nThe preloaded inifile to read from. \n*/ \n/******************************************************************************/ \nvoid ParticleComponent::FromFile(M5IniFile& iniFile) \n{ \n  // Get our life time value \n  std::string lifeTimeText; \n  iniFile.SetToSection(\"ParticleComponent\"); \n  iniFile.GetValue(\"lifeTime\", lifeTimeText); \n\n  // Convert the string into a float \n  lifeTime = std::stof(lifeTimeText); \n  lifeLeft = lifeTime; \n\n  // Then do the same for endScale \n  std::string endScaleText; \n  iniFile.GetValue(\"endScale\", endScaleText); \n  endScale = std::stof(endScaleText); \n\n} \n\n```", "```cpp\nM5Object* particle = M5ObjectManager::CreateObject(AT_Particle); \n\nparticle->pos = m_pObj->pos; \n\n```", "```cpp\n// Abstract class for us to derive from \nclass ParticleSystem \n{ \npublic: \n  float lifeTime; \n  M5Vec2 startScale; \n  float endScale; \n\n  // Pure virtual functions \n  virtual void Init(M5Object * object) = 0; \n  virtual void Update(M5Object * object, float dt, float lifeLeft) = 0; \n\n  float Lerp(float start, float end, float fraction); \n\n}; \n\n```", "```cpp\nenum ParticleType \n{ \n  PS_Static, \n  PS_Moving \n}; \n\n```", "```cpp\nclass ParticleComponent : public M5Component \n{ \npublic: \n  ParticleComponent(); \n  virtual void Update(float dt); \n  virtual M5Component* Clone(void); \n  virtual void FromFile(M5IniFile& iniFile); \n  bool activated; \n  float lifeLeft; \n\nprivate: \n  ParticleType particleType; \n}; \n\n```", "```cpp\nclass StaticParticleSystem : public ParticleSystem \n{ \n  void Init(M5Object * obj);     \n\n  void Update(M5Object *, float, float); \n\n}; \n\nclass MovingParticleSystem : public ParticleSystem \n{ \n  void Init(M5Object * obj); \n\n  void Update(M5Object *, float, float); \n\n}; \n\n```", "```cpp\nclass ParticleFactory \n{ \npublic: \n  static int objectCount; \n  static std::map<ParticleType, ParticleSystem *> particleSystems; \n\n  // Getting our Flyweight \n  static ParticleSystem & GetParticleSystem(ParticleType type); \n  ~ParticleFactory(); \n}; \n\n```", "```cpp\n#include <map> \n\n// Define our static variables \nint ParticleFactory::objectCount = 0; \nstd::map<ParticleType, ParticleSystem *> ParticleFactory::particleSystems; \n\n```", "```cpp\nposX   = 0 \nposY   = 0 \nvelX   = 0 \nvelY   = 0 \nscaleX = 2.5 \nscaleY = 2.5 \nrot    = 0 \nrotVel = 0 \ncomponents =  GfxComponent ParticleComponent \n\n[GfxComponent] \ntexture = particle.tga \ndrawSpace = world \n\n[ParticleComponent] \ntype = Moving \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nConstrutor for ParticleSystem component.  Sets default values \n*/ \n/******************************************************************************/ \nParticleComponent::ParticleComponent() : \n  M5Component(CT_ParticleComponent) \n{ \n} \n\n/******************************************************************************/ \n/*! \nTakes care of the particle system, decrease lifetime and adjust scaling. \nWill mark for destruction if needed. \n\n\\param [in] dt \nThe time in seconds since the last frame. \n*/ \n/******************************************************************************/ \nvoid ParticleComponent::Update(float dt) \n{ \n  // Decrease our life by the change in time this frame (delta time, dt) \n  lifeLeft -= dt; \n\n  ParticleFactory::GetParticleSystem(particleType).Update(m_pObj, dt, lifeLeft); \n\n  // If there is no life left, destroy our object \n  if (lifeLeft <= 0) \n  { \n    m_pObj->isDead = true; \n  } \n\n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nClones the current component and updates it with the correct information. \n\n\\return \nA new component that is a clone of this one \n*/ \n/******************************************************************************/ \nM5Component * ParticleComponent::Clone(void) \n{ \n  ParticleComponent * pNew = new ParticleComponent; \n  pNew->m_pObj = m_pObj; \n  pNew->particleType = particleType; \n\n  ParticleSystem & system = \n     ParticleFactory::GetParticleSystem(particleType); \n  system.Init(pNew->m_pObj); \n  pNew->lifeLeft = system.lifeTime; \n  return pNew; \n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nReads in data from a preloaded ini file. \n\n\\param [in] iniFile \nThe preloaded inifile to read from. \n*/ \n/******************************************************************************/ \nvoid ParticleComponent::FromFile(M5IniFile& iniFile) \n{ \n  // Get our initial particle type \n  std::string particleTypeText; \n  iniFile.SetToSection(\"ParticleComponent\"); \n  iniFile.GetValue(\"type\", particleTypeText); \n\n  if (particleTypeText == \"Static\") \n  { \n    particleType = PS_Static; \n  } \n  else if(particleTypeText == \"Moving\") \n  { \n    particleType = PS_Moving; \n  } \n\n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nUsed to get our Flyweight object and access the shared properties of the  \nparticles. \n\n\\param type \nWhat kind of particle we want to get access to \n\n*/ \n/******************************************************************************/ \nParticleSystem & ParticleFactory::GetParticleSystem(ParticleType type) \n{ \n  // If our object exists, return it \n  if (particleSystems.find(type) != particleSystems.end()) \n  { \n    return  *particleSystems[type]; \n  } \n\n  ParticleSystem * newSystem = nullptr; \n\n  // Otherwise, let's create one \n  switch (type) \n  { \n  case PS_Static: \n    newSystem = new StaticParticleSystem(); \n    newSystem->endScale = 0; \n    newSystem->lifeTime = 1.5; \n    newSystem->startScale = M5Vec2(2.5, 2.5); \n\n    particleSystems[PS_Static] = newSystem; \n\n    objectCount++; \n    break; \n\n  case PS_Moving: \n    newSystem = new MovingParticleSystem(); \n    newSystem->endScale = 0; \n    newSystem->lifeTime = 1.5; \n    newSystem->startScale = M5Vec2(2.5, 2.5); \n    particleSystems[PS_Moving] = newSystem; \n    objectCount++; \n    break; \n  } \n\n  return *newSystem; \n\n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nDeconstructor for the ParticleFactory. Removes all of the elements in ourparticleSystems map \n\n*/ \n/******************************************************************************/ \nParticleFactory::~ParticleFactory() \n{ \n  for (auto iterator = particleSystems.begin();  \n     iterator != particleSystems.end();  \n     iterator++)  \n  { \n    // iterator->first = key \n    // iterator->second = value \n    delete iterator->second; \n  } \n\n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nWill give you the percentage of the fraction from start to end \n\n\\param start \nWhat value to start from \n\n\\param end \nWhat value to end from \n\n\\param fraction \nWhat percentage of the way we are from start to finish \n\n*/ \n/******************************************************************************/ \nfloat ParticleSystem::Lerp(float start, float end, float fraction) \n{ \n  return start + fraction * (end - start); \n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nUsed to initialize the particle system and set any parameters needed \n\n\\param obj \nA reference to the object \n\n*/ \n/******************************************************************************/ \nvoid StaticParticleSystem::Init(M5Object * obj) \n{ \n  obj->vel = M5Vec2(0, 0); \n} \n\n/******************************************************************************/ \n/*! \nUsed to update the particle system. Called once per frame \n\n\\param m_pObj \nA reference to the object \n\n\\param dt \nAmount of time that has passed since the previous frame \n\n\\param lifeLeft \nThe amount of lifetime the object has left \n\n*/ \n/******************************************************************************/ \nvoid StaticParticleSystem::Update(M5Object * m_pObj, \n   float /*dt*/, float lifeLeft) \n{ \n  // Change our size based on where we want it to be \n  float currentPercentage = 1 - (lifeLeft / lifeTime); \n  m_pObj->scale.x = Lerp(startScale.x, \n     startScale.x * endScale, currentPercentage); \n  m_pObj->scale.y = Lerp(startScale.y, \n     startScale.y * endScale, currentPercentage); \n} \n\n```", "```cpp\n/******************************************************************************/ \n/*! \nUsed to initialize the particle system and set any parameters needed \n\n\\param obj \nA reference to the object \n\n*/ \n/******************************************************************************/ \nvoid MovingParticleSystem::Init(M5Object * obj) \n{ \n  obj->vel = M5Vec2(M5Random::GetFloat(-1, 1), \n     M5Random::GetFloat(-1, 1)) * 10; \n} \n\n/******************************************************************************/ \n/*! \nUsed to update the particle system. Called once per frame \n\n\\param m_pObj \nA reference to the object \n\n\\param dt \nAmount of time that has passed since the previous frame \n\n\\param lifeLeft \nThe amount of lifetime the object has left \n\n*/ \n/******************************************************************************/ \nvoid MovingParticleSystem::Update(M5Object * m_pObj, float /*dt*/, float lifeLeft) \n{ \n  // Change our size based on where we want it to be \n  float currentPercentage = 1 - (lifeLeft / lifeTime); \n  m_pObj->scale.x = Lerp(startScale.x, \n     startScale.x * endScale, currentPercentage); \n  m_pObj->scale.y = Lerp(startScale.y, \n     startScale.y * endScale, currentPercentage); \n} \n\n```"]