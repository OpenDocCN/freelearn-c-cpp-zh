["```cpp\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n    ```", "```cpp\n    float mContrast,mContrastOld;\n    float mBrightness,mBrightnessOld;\n    Surface32f  mImage, mImageOutput;\n    ```", "```cpp\n    mImage = loadImage( loadAsset(\"image.png\") );\n    mImageOutput = Surface32f(mImage.getWidth(), \n            mImage.getHeight(), false);\n    ```", "```cpp\n    setWindowSize(1025, 512);\n    mContrast = 0.f;\n    mContrastOld = -1.f;\n    mBrightness = 0.f;\n    mBrightnessOld = -1.f;\n    ```", "```cpp\n    mParams.addParam(\"Contrast\", &mContrast, \n    \"min=-0.5 max=1.0 step=0.01\");\n    mParams.addParam(\"Brightness\", &mBrightness, \n          \"min=-0.5 max=0.5 step=0.01\");\n    ```", "```cpp\n    if(mContrastOld != mContrast || mBrightnessOld != mBrightness) {\n    float c = 1.f + mContrast;\n        Surface32f::IterpixelIter = mImage.getIter();\n        Surface32f::IterpixelOutIter = mImageOutput.getIter();\n\n        while( pixelIter.line() ) {\n        pixelOutIter.line();\n        while( pixelIter.pixel() ) {\n        pixelOutIter.pixel();\n\n        // contrast transformation\n        pixelOutIter.r() = (pixelIter.r() - 0.5f) * c + 0.5f;\n        pixelOutIter.g() = (pixelIter.g() - 0.5f) * c + 0.5f;\n        pixelOutIter.b() = (pixelIter.b() - 0.5f) * c + 0.5f;\n\n        // brightness transformation\n        pixelOutIter.r() += mBrightness;\n        pixelOutIter.g() += mBrightness;\n        pixelOutIter.b() += mBrightness;\n\n            }\n        }\n\n    mContrastOld = mContrast;\n    mBrightnessOld = mBrightness;\n    }\n    ```", "```cpp\n    gl::draw(mImage);\n    gl::draw(mImageOutput, Vec2f(512.f+1.f, 0.f));\n    ```", "```cpp\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_imgproc.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_core.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_objdetect.a\n    ```", "```cpp\n    $(CINDER_PATH)/blocks/opencv/include\n    ```", "```cpp\n    #include \"CinderOpenCV.h\"\n    ```", "```cpp\nSurface mImage, mImageOutput;\nmImage = loadImage( loadAsset(\"image.png\") );\ncv::Mat ocvImage(toOcv(mImage));\ncv::cvtColor(ocvImage, ocvImage, CV_BGR2GRAY ); \nmImageOutput = Surface(fromOcv(ocvImage));\n```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n\n    #include \"cinder/ip/EdgeDetect.h\"\n    #include \"cinder/ip/Grayscale.h\"\n    ```", "```cpp\n    Surface8u mImageOutput;\n    ```", "```cpp\n    mImage = loadImage( loadAsset(\"image.png\") );\n    mImageOutput = Surface8u(mImage.getWidth(), mImage.getHeight(), false);\n    ```", "```cpp\n    ip::grayscale(mImage, &mImage);\n    ip::edgeDetectSobel(mImage, &mImageOutput);\n    ```", "```cpp\n    gl::draw(mImage);\n    gl::draw(mImageOutput, Vec2f(512.f+1.f, 0.f));\n    ```", "```cpp\nvector<vector<cv::Point> > contours; \ncv::Mat inputMat( toOcv( frame ) );\n// blur\ncv::cvtColor( inputMat, inputMat, CV_BGR2GRAY );\ncv::Mat blurMat;\ncv::medianBlur(inputMat, blurMat, 11);\n\n// threshold\ncv::Mat thresholdMat;\ncv::threshold(blurMat, thresholdMat, 50, 255, CV_8U );\n\n// erode\ncv::Mat erodeMat;\ncv::erode(thresholdMat, erodeMat, 11);\n\n// Detect edges\ncv::Mat cannyMat;\nint thresh = 100;\ncv::Canny(erodeMat, cannyMat, thresh, thresh*2, 3 );\n\n// Find contours\ncv::findContours(cannyMat, contours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);\n```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n    ```", "```cpp\n    Surface8u mImage;\n    cv::CascadeClassifier  mFaceCC;\n    std::vector<Rectf>  mFaces;\n    ```", "```cpp\n    mImage = loadImage( loadAsset(\"image.png\") );\n    mFaceCC.load( getAssetPath( \"haarcascade_frontalface_alt.xml\" ).string() );\n    ```", "```cpp\n    cv::Mat cvImage( toOcv( mImage, CV_8UC1 ) );\n    std::vector<cv::Rect> faces;\n    mFaceCC.detectMultiScale( cvImage, faces );\n    std::vector<cv::Rect>::const_iterator faceIter;\n    for(faceIter = faces.begin(); faceIter != faces.end(); ++faceIter ) {\n      Rectf faceRect( fromOcv( *faceIter ) );\n      mFaces.push_back( faceRect );\n    }\n    ```", "```cpp\n    gl::color( Color::white() );\n    gl::draw(mImage);\n    gl::color( ColorA( 1.f, 0.f, 0.f, 0.45f ) );\n    std::vector<Rectf>::const_iterator faceIter;\n    for(faceIter = mFaces.begin(); faceIter != mFaces.end(); ++faceIter ) {\n      gl::drawStrokedRect( *faceIter );\n    }\n    ```", "```cpp\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_imgproc.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_core.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_objdetect.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_features2d.a\n    $(CINDER_PATH)/blocks/opencv/lib/macosx/libopencv_flann.a\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n    ```", "```cpp\n    int matchImages(Surface8u img1, Surface8u img2);\n\n    Surface8u   mImage, mImage2;\n    gl::Texture mMatchesImage;\n    ```", "```cpp\n    mImage = loadImage( loadAsset(\"image.png\") );\n    mImage2 = loadImage( loadAsset(\"image2.png\") );\n\n    int numberOfmatches = matchImages(mImage, mImage2);\n    ```", "```cpp\n    int MainApp::matchImages(Surface8u img1, Surface8u img2)\n    {\n      cv::Mat image1(toOcv(img1));\n      cv::cvtColor( image1, image1, CV_BGR2GRAY );\n\n      cv::Mat image2(toOcv(img2));\n      cv::cvtColor( image2, image2, CV_BGR2GRAY );\n\n      // Detect the keypoints using SURF Detector\n      std::vector<cv::KeyPoint> keypoints1, keypoints2;\n\n      cv::SurfFeatureDetector detector;\n      detector.detect( image1, keypoints1 );\n      detector.detect( image2, keypoints2 );\n\n      // Calculate descriptors (feature vectors)\n      cv::SurfDescriptorExtractor extractor;\n      cv::Mat descriptors1, descriptors2;\n\n      extractor.compute( image1, keypoints1, descriptors1 );\n      extractor.compute( image2, keypoints2, descriptors2 );\n\n      // Matching\n      cv::FlannBasedMatcher matcher;\n      std::vector<cv::DMatch> matches;\n      matcher.match( descriptors1, descriptors2, matches );\n\n      double max_dist = 0; \n      double min_dist = 100;\n\n      for( int i = 0; i< descriptors1.rows; i++ )\n        {\n      double dist = matches[i].distance;\n      if( dist<min_dist ) min_dist = dist;\n      if( dist>max_dist ) max_dist = dist;\n          }\n\n      std::vector<cv::DMatch> good_matches;\n\n      for( int i = 0; i< descriptors1.rows; i++ )\n          {\n      if( matches[i].distance<2*min_dist )\n      good_matches.push_back( matches[i]);\n          }\n\n      // Draw matches\n      cv::Matimg_matches;\n      cv::drawMatches(image1, keypoints1, image2, keypoints2,\n      good_matches, img_matches, cv::Scalar::all(-1),cv::Scalar::all(-1),\n      std::vector<char>(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );\n\n      mMatchesImage = gl::Texture(fromOcv(img_matches));\n\n      return good_matches.size();\n        }\n    ```", "```cpp\n    gl::draw(mMatchesImage);\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n    #include \"cinder/cairo/Cairo.h\"\n    ```", "```cpp\n    void renderDrawing( cairo::Context&ctx );\n\n    Surface mImage, mIPImage;\n    std::vector<std::vector<cv::Point> >mContours, mContoursApprox;\n    double mApproxEps;\n    int mCannyThresh;\n    ```", "```cpp\n    mImage = loadImage( loadAsset(\"drawing.jpg\") );\n\n    mApproxEps = 1.0;\n    mCannyThresh = 200;\n    ```", "```cpp\n    cv::Mat inputMat( toOcv( mImage ) );\n\n    cv::Mat bgr, gray, outputFrame;\n    cv::cvtColor(inputMat, bgr, CV_BGRA2BGR);\n    double sp = 50.0;\n    double sr = 55.0;\n    cv::pyrMeanShiftFiltering(bgr.clone(), bgr, sp, sr);\n\n    cv::cvtColor(bgr, gray, CV_BGR2GRAY);\n    cv::cvtColor(bgr, outputFrame, CV_BGR2BGRA);\n    mIPImage = Surface(fromOcv(outputFrame));\n    cv::medianBlur(gray, gray, 7);\n\n    // Detect edges using\n    cv::MatcannyMat;\n    cv::Canny(gray, cannyMat, mCannyThresh, mCannyThresh*2.f, 3 );\n    mIPImage = Surface(fromOcv(cannyMat));\n\n    // Find contours\n    cv::findContours(cannyMat, mContours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);\n\n    // prepare outline\n    for( int i = 0; i<mContours.size(); i++ )\n    {\n    std::vector<cv::Point> approxCurve;\n    cv::approxPolyDP(mContours[i], approxCurve, mApproxEps, true);\n    mContoursApprox.push_back(approxCurve);\n    }\n    ```", "```cpp\n    void MainApp::renderDrawing( cairo::Context&ctx )\n    {\n      ctx.setSource( ColorA( 0, 0, 0, 1 ) );\n      ctx.paint();\n\n      ctx.setSource( ColorA( 1, 1, 1, 1 ) );\n      for( int i = 0; i<mContoursApprox.size(); i++ )\n        {\n      ctx.newSubPath();\n      ctx.moveTo(mContoursApprox[i][0].x, mContoursApprox[i][0].y);\n      for( int j = 1; j <mContoursApprox[i].size(); j++ )\n            {\n    ctx.lineTo(mContoursApprox[i][j].x, mContoursApprox[i][j].y);\n            }\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.setSource(Color( 1, 0, 0 ));\n    for( int j = 1; j <mContoursApprox[i].size(); j++ )\n            {\n    ctx.circle(mContoursApprox[i][j].x, mContoursApprox[i][j].y, 2.f);\n            }\n    ctx.fill();\n        }\n    }\n    ```", "```cpp\n      gl::clear( Color( 0.1f, 0.1f, 0.1f ) );\n\n      gl::color(Color::white());\n\n      gl::pushMatrices();\n      gl::scale(Vec3f(0.5f,0.5f,0.5f));\n      gl::draw(mImage);\n      gl::draw(mIPImage, Vec2i(0, mImage.getHeight()+1));\n      gl::popMatrices();\n\n      gl::pushMatrices();\n      gl::translate(Vec2f(mImage.getWidth()*0.5f+1.f, 0.f));\n      gl::color( Color::white() );\n\n      cairo::SurfaceImage vecSurface( mImage.getWidth(), mImage.getHeight() );\n      cairo::Context ctx( vecSurface );\n      renderDrawing(ctx);\n      gl::draw(vecSurface.getSurface());\n\n      gl::popMatrices();\n    ```", "```cpp\n    if( event.getChar() == 's' ) {\n    cairo::Context ctx( cairo::SurfaceSvg( getAppPath() / fs::path(\"..\") / \"output.svg\",mImage.getWidth(), mImage.getHeight() ) );\n    renderDrawing( ctx );\n    }\n    ```"]