- en: Chapter 12. Spell Book
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 咒语书
- en: The player does not yet have a means to defend himself. We will equip the player
    with a very useful and interesting way, of doing so called magic spells. Magic
    spells will be used by the player to affect monsters nearby.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家目前还没有防御自己的手段。我们将为玩家配备一种非常实用且有趣的方法，即所谓的魔法咒语。玩家将使用魔法咒语来影响附近的怪物。
- en: Practically, spells will be a combination of a particle system with an area
    of effect represented by a bounding volume. The bounding volume is checked for
    contained actors in each frame. When an actor is within the bounding volume of
    a spell, then that actor is affected by that spell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，咒语将是粒子系统与表示作用范围的边界体积的组合。在每一帧中，都会检查包含在边界体积内的演员。当一个演员位于咒语的边界体积内时，该演员将受到该咒语的影响。
- en: 'The following is a screenshot of the blizzard and force field spells, with
    their bounding volumes highlighted in orange:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了暴风咒和力场咒，它们的边界体积用橙色突出显示：
- en: '![Spell Book](img/00219.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![咒语书](img/00219.jpeg)'
- en: 'Visualization of the blizzard spell can be seen at the right, with a long,
    box-shaped bounding volume. Visualization of the force field spell, with a spherical
    bounding volume, for pushing monsters away, is shown in the following screenshot:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 暴风咒的视觉效果可以在右侧看到，有一个长方形的边界体积。推动怪物远离的力场咒的视觉效果，具有球形的边界体积，如图所示：
- en: '![Spell Book](img/00220.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![咒语书](img/00220.jpeg)'
- en: 'In each frame, the bounding volume is checked for contained actors. Any actor
    contained in the spell''s bounding volume is going to be affected by that spell
    for that frame only. If the actor moves outside the spell''s bounding volume,
    the actor will no longer be affected by that spell. Remember, the spell''s particle
    system is a visualization only; the particles themselves are not what will affect
    game actors. The `PickupItem` class we created in [Chapter 8](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 8. Actors and Pawns"), *Actors and Pawns* can be used to allow the player
    to pick up items representing the spells. We will extend the `PickupItem` class
    and attach the blueprint of a spell to cast each `PickupItem`. Clicking on a spell''s
    widget from the HUD will cast it. The interface will look something like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，都会检查包含在边界体积内的演员。任何在咒语边界体积内的演员在这一帧内都将受到该咒语的影响。如果演员移动到咒语边界体积之外，该演员将不再受到该咒语的影响。记住，咒语的粒子系统仅用于可视化；粒子本身不会影响游戏演员。《第8章》（part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "第8章。演员和代理"）中我们创建的`PickupItem`类，*演员和代理*可以用来允许玩家捡起代表咒语的物品。我们将扩展`PickupItem`类，并将咒语的蓝图附加到每个`PickupItem`上。点击HUD上的咒语小部件将施展它。界面看起来可能像这样：
- en: '![Spell Book](img/00221.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![咒语书](img/00221.jpeg)'
- en: Items the player has picked up, including four different spells
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家捡到的物品，包括四种不同的咒语
- en: We'll begin the chapter by describing how to create our own particle systems.
    We'll then move on to wrap up the particle emitter into a `Spell` class, and write
    a `CastSpell()` function for the avatar to be able to actually cast spells.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述如何创建我们自己的粒子系统。然后，我们将继续将粒子发射器封装成一个`Spell`类，并为角色编写一个`CastSpell()`函数，以便角色能够真正地施展咒语。
- en: The particle systems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: 'First, we need a place to put all our snazzy effects. In your **Content Browser**
    tab, right-click on the **Game** root and create a new folder called **ParticleSystems**.
    Right-click on that new folder, and select **New Asset** | **Particle System**,
    as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个地方来放置所有我们的华丽效果。在你的**内容浏览器**标签页中，右键单击**游戏**根目录，创建一个名为**ParticleSystems**的新文件夹。右键单击该新文件夹，然后选择**新建资产**
    | **粒子系统**，如图所示：
- en: '![The particle systems](img/00222.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/00222.jpeg)'
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'See this Unreal Engine 4 Particle Systems guide for information on how unreal
    particle emitters work: [https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个虚幻引擎4粒子系统指南，了解虚幻粒子发射器的工作原理：[https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)。
- en: 'Double-click on the **NewParticleSystem** icon that appears, as shown in the
    following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 双击出现的**NewParticleSystem**图标，如图所示：
- en: '![The particle systems](img/00223.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/00223.jpeg)'
- en: 'You will be in Cascade, the particle editor. A description of the environment
    is shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将进入级联，粒子编辑器。以下截图显示了环境的描述：
- en: '![The particle systems](img/00224.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/00224.jpeg)'
- en: 'There are several different panes here, each of which shows different information.
    They are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个不同的面板，每个面板都显示不同的信息。它们如下所示：
- en: At the top left is the **Viewport** pane. This shows you an animation of the
    current emitter as its currently working.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左上角是**视口**面板。这显示了当前发射器的动画，正如它当前正在工作一样。
- en: At the right is the **Emitters** pane. Inside it, you can see a single object
    called **Particle Emitter** (you can have more than one emitter in your particle
    system, but we don't want that now). The listing of modules of **Particle Emitter**
    appears listed under it. From the preceding screenshot, we have the **Required**,
    **Spawn**, **Lifetime**, **Initial Size**, **Initial Velocity**, and **Color Over
    Life** modules.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧是**发射器**面板。在其内部，你可以看到一个名为**粒子发射器**的单个对象（你可以在你的粒子系统中拥有多个发射器，但现在我们不想那样做）。**粒子发射器**的模块列表出现在其下方。从前面的截图，我们有**必需的**、**生成**、**生命周期**、**初始大小**、**初始速度**和**颜色随生命周期变化**模块。
- en: Changing particle properties
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改粒子属性
- en: 'The default particle emitter emits crosshair-like shapes. We want to change
    that to something more interesting. Click on the yellow **Required** box under
    **Emitters** panel, then under **Material** in the **Details** panel, type `particles`.
    A list of all the available particle materials will pop up. Choose **m_flare_01**
    option to create our first particle system, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的粒子发射器发射类似十字准线的形状。我们想将其更改为更有趣的东西。点击**发射器**面板下的黄色**必需**框，然后在**详细信息**面板的**材质**下输入`particles`。将弹出一个包含所有可用粒子材质的列表。选择**m_flare_01**选项来创建我们的第一个粒子系统，如下面的截图所示：
- en: '![Changing particle properties](img/00225.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![更改粒子属性](img/00225.jpeg)'
- en: 'Now, let''s change the behavior of the particle system. Click on the **Color
    Over Life** entry under the **Emitters** pane. The **Details** pane at the bottom
    shows the information about the different parameters, as shown in the following
    screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变粒子系统的行为。点击**发射器**面板下的**颜色随生命周期变化**条目。底部的**详细信息**面板显示了不同参数的信息，如下面的截图所示：
- en: '![Changing particle properties](img/00226.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![更改粒子属性](img/00226.jpeg)'
- en: In the **Details** pane of **Color Over Life** entry, I increased **X**, but
    not **Y** and not **Z**. This gives the particle system a reddish glow. (**X**
    is red, **Y** is green, and **Z** is blue).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在**颜色随生命周期变化**条目的**详细信息**面板中，我增加了**X**，但没有增加**Y**和没有增加**Z**。这给粒子系统带来了一种红色光泽。（**X**是红色，**Y**是绿色，**Z**是蓝色）。
- en: 'Instead of editing the raw numbers, however, you can actually change the particle
    color more visually. If you click on the greenish zigzag button beside the **Color
    Over Life** entry, you will see the graph for **Color Over Life** displayed in
    the **Curve Editor** tab, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你实际上可以通过更直观的方式来更改粒子颜色。如果你点击**颜色随生命周期变化**条目旁边的绿色波形按钮，你将看到**颜色随生命周期变化**的图表在**曲线编辑器**选项卡中显示，如下面的截图所示：
- en: '![Changing particle properties](img/00227.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![更改粒子属性](img/00227.jpeg)'
- en: 'We can now change the **Color Over Life** parameters. The graph in the **Curve
    Editor** tab displays the emitted color versus the amount of time the particle
    has been alive. You can adjust the values by dragging the points around. Pressing
    *Ctrl* + left mouse button adds a new point to a line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更改**颜色随生命周期变化**参数。**曲线编辑器**选项卡中的图表显示了发射颜色与粒子存活时间的对比。你可以通过拖动点来调整值。按下*Ctrl*
    + 左键鼠标按钮向线条添加一个新点：
- en: '![Changing particle properties](img/00228.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![更改粒子属性](img/00228.jpeg)'
- en: Ctrl + click adds points to lines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ctrl + 点击为线条添加点。
- en: You can play around with the particle emitter settings to create your own spell
    visualizations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以玩弄粒子发射器的设置来创建你自己的法术可视化。
- en: Settings for the blizzard spell
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 雪崩法术的设置
- en: At this point, we should rename our particle system, from **NewParticle System**
    to something more descriptive. Let's rename it **P_Blizzard**. You can rename
    your particle system by simply clicking on it and pressing *F2*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该将我们的粒子系统重命名为**NewParticle System**，改为更具描述性的名称。让我们将其重命名为**P_Blizzard**。你可以通过简单地点击它并按下*F2*来重命名你的粒子系统。
- en: '![Settings for the blizzard spell](img/00229.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![雪崩法术的设置](img/00229.jpeg)'
- en: Press *F2* on an object in the Content Browser to rename it
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容浏览器中的对象上按下 *F2* 来重命名它
- en: '![Settings for the blizzard spell](img/00230.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![暴风雪法术设置](img/00230.jpeg)'
- en: 'We will tweak some of the settings to get a blizzard particle effect spell.
    Perform the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整一些设置以获得暴风雪粒子效果法术。执行以下步骤：
- en: Under the **Emitters** tab, click on the **Required** box. In the **Details**
    pane, change the **Emitter** material to **m_flare_01** as shown:![Settings for
    the blizzard spell](img/00231.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射器**标签页下，点击**必需**框。在**详细信息**面板中，将**发射器**材质更改为**m_flare_01**，如下所示：![暴风雪法术设置](img/00231.jpeg)
- en: Under the **Spawn** module, change the spawn rate to 200\. This increases the
    density of the visualization, as shown:![Settings for the blizzard spell](img/00232.jpeg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**生成**模块下，将生成速率更改为200。这将增加可视化的密度，如下所示：![暴风雪法术设置](img/00232.jpeg)
- en: Under the **Lifetime** module, increase the **Max** property from 1.0 to 2.0\.
    This introduces some variation to the length of time a particle will live, with
    some of the emitted particles living longer than others.![Settings for the blizzard
    spell](img/00233.jpeg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**生命周期**模块下，将**最大**属性从1.0增加到2.0。这会给粒子存活时间的长度带来一些变化，其中一些发射的粒子比其他粒子存活时间更长。![暴风雪法术设置](img/00233.jpeg)
- en: Under the **Initial Size** module, change the **Min** property size to 12.5
    in **X**, **Y**, and **Z**:![Settings for the blizzard spell](img/00234.jpeg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**初始大小**模块下，将**最小**属性大小在**X**、**Y**和**Z**方向上更改为12.5：![暴风雪法术设置](img/00234.jpeg)
- en: Under the **Initial Velocity** module, change the **Min**/**Max** values to
    the values shown:![Settings for the blizzard spell](img/00235.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**初始速度**模块下，将**最小**/**最大**值更改为显示的值：![暴风雪法术设置](img/00235.jpeg)
- en: The reason we're having the blizzard blow in +X is because the player's forward
    direction starts out in +X. Since the spell will come from the player's hands,
    we want the spell to point in the same direction as the player.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们让暴风雪向+X方向吹的原因是因为玩家的前方方向最初在+X。由于法术将从玩家的手中发出，我们希望法术指向与玩家相同的方向。
- en: Under the **Color Over Life** menu, change the blue (**Z**) value to 100.0\.
    You will see an instant change to a blue glow:![Settings for the blizzard spell](img/00236.jpeg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**颜色随生命周期变化**菜单下，将蓝色（**Z**）值更改为100.0。您将看到立即变为蓝色光芒的变化：![暴风雪法术设置](img/00236.jpeg)
- en: Now it's starting to look magical!
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在它开始看起来像魔法一样了！
- en: Right-click on the blackish area below the **Color Over Life** module. Choose
    **Location** | **Initial Location**:![Settings for the blizzard spell](img/00237.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**颜色随生命周期变化**模块下方的深色区域。选择**位置** | **初始位置**：![暴风雪法术设置](img/00237.jpeg)
- en: Enter values under **Start Location** | **Distribution** as shown below:![Settings
    for the blizzard spell](img/00238.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下所示在**起始位置** | **分布**下输入值：![暴风雪法术设置](img/00238.jpeg)
- en: You should have a blizzard that looks like this:![Settings for the blizzard
    spell](img/00239.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该得到一个看起来像这样的暴风雪：![暴风雪法术设置](img/00239.jpeg)
- en: Move the camera to a position you like, then click on the **Thumbnail** option
    in the top menu bar. This will generate a thumbnail icon for your particle system
    in the **Content Browser** tab.![Settings for the blizzard spell](img/00240.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将摄像机移动到您喜欢的位置，然后在顶部菜单栏中点击**缩略图**选项。这将在**内容浏览器**标签页中为您粒子系统生成一个缩略图图标。![暴风雪法术设置](img/00240.jpeg)
- en: Clicking Thumbnail at the top menu bar will generate a mini icon for your particle
    system
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在顶部菜单栏中点击缩略图将生成您粒子系统的迷你图标
- en: Spell class actor
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Spell`类演员'
- en: The `Spell` class will ultimately do damage to all the monsters. Towards that
    end, we need to contain both a particle system and a bounding box inside the `Spell`
    class actor. When a `Spell` class is cast by the avatar, the `Spell` object will
    be instantiated into the level and start `Tick()` functioning. On every `Tick()`
    of the `Spell` object, any monster contained inside the spell's bounding volume
    will be affected by that `Spell`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spell`类最终会对所有怪物造成伤害。为此，我们需要在`Spell`类演员内部包含一个粒子系统和边界框。当化身施放`Spell`类时，`Spell`对象将被实例化到关卡中并开始`Tick()`功能。在`Spell`对象的每个`Tick()`上，任何位于法术边界体积内的怪物都将受到该`Spell`的影响。'
- en: 'The `Spell` class should look something like the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spell`类应该看起来像以下代码：'
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are only three functions we need to worry about implementing, namely the
    `ASpell::ASpell()` constructor, the `ASpell::SetCaster()` function, and the `ASpell::Tick()`
    function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要关注实现三个函数，即`ASpell::ASpell()`构造函数、`ASpell::SetCaster()`函数和`ASpell::Tick()`函数。
- en: 'Open the `Spell.cpp` file. Add a line to include the `Monster.h` file, so we
    can access the definition of `Monster` objects inside the `Spell.cpp` file, as
    shown in the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Spell.cpp` 文件。添加一行以包含 `Monster.h` 文件，这样我们就可以在 `Spell.cpp` 文件中访问 `Monster`
    对象的定义，如下面的代码行所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, the constructor, which sets up the spell and initializes all components
    is shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是构造函数，它设置了咒语并初始化所有组件，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of particular importance is the last line here, `PrimaryActorTick.bCanEverTick
    = true`. If you don't set that, your `Spell` objects won't ever have `Tick()`
    called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是这里的最后一行，`PrimaryActorTick.bCanEverTick = true`。如果您不设置它，您的 `Spell` 对象将永远不会调用
    `Tick()`。
- en: 'Next, we have the `SetCaster()` method. This is called so that the person who
    casts the spell is known to the `Spell` object. We can ensure that the caster
    can''t hurt himself with his own spells by using the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `SetCaster()` 方法。这个方法被调用是为了让施法者被 `Spell` 对象所知晓。我们可以通过以下代码确保施法者不会用他的咒语伤害到自己：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we have the `ASpell::Tick()` method, which actually deals damage to
    all contained actors, as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `ASpell::Tick()` 方法，它实际上会对所有包含的演员造成伤害，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ASpell::Tick()` function does a number of things, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASpell::Tick()` 函数执行多项操作，具体如下：'
- en: Gets all actors overlapping `ProxBox`. Any actor that is not the caster gets
    damaged if the component overlapped is the root component of that object. The
    reason we have to check for overlapping with the root component is because if
    we don't, the spell might overlap the monster's `SightSphere`, which means we
    will get hits from very far away, which we don't want.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有重叠 `ProxBox` 的演员。如果与重叠的组件是那个对象的根组件，则任何不是施法者的演员都会受到伤害。我们必须检查与根组件重叠的原因是因为如果我们不这样做，咒语可能会重叠怪物的
    `SightSphere`，这意味着我们会从非常远的地方受到攻击，这是我们不想看到的。
- en: Notices that if we had another class of thing that should get damaged, we would
    have to attempt a cast to each object type specifically. Each class type might
    have a different type of bounding volume that should be collided with, other types
    might not even have `CapsuleComponent` (they might have `ProxBox` or `ProxSphere`).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，如果我们有另一种应该受到伤害的东西，我们就必须尝试对每个对象类型进行施法。每个类类型可能有不同类型的边界体积需要与之碰撞，其他类型甚至可能没有 `CapsuleComponent`（它们可能有
    `ProxBox` 或 `ProxSphere`）。
- en: Increases the amount of time the spell has been alive for. If the spell exceeds
    the duration it is allotted to be cast for, it is removed from the level.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加咒语存活的时间量。如果咒语超过了分配给它的施法持续时间，它将被从关卡中移除。
- en: Now, let's focus on how the player can acquire spells, by creating an individual
    `PickupItem` for each spell object that the player can pick up.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注玩家如何获得咒语，通过为玩家可以拾取的每个咒语对象创建一个单独的 `PickupItem`。
- en: Blueprinting our spells
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计我们的咒语
- en: 'Compile and run your C++ project with the `Spell` class that we just added.
    We need to create blueprints for each of the spells we want to be able to cast.
    In the **Class Viewer** tab, start to type `Spell`, and you should see your `Spell`
    class appear. Right-click on **Spell**, and create a blueprint called **BP_Spell_Blizzard**,
    and then double-click to open it, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行您添加了 `Spell` 类的 C++ 项目。我们需要为想要能够施法的每个咒语创建蓝图。在 **类查看器** 选项卡中，开始键入 `Spell`，你应该能看到你的
    `Spell` 类出现。右键单击 **Spell**，创建一个名为 **BP_Spell_Blizzard** 的蓝图，然后双击打开它，如下面的屏幕截图所示：
- en: '![Blueprinting our spells](img/00241.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的咒语](img/00241.jpeg)'
- en: 'Inside the spell''s properties, choose the **P_Blizzard** spell for the particle
    emitter, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在咒语的属性中，选择 **P_Blizzard** 咒语作为粒子发射器，如下面的屏幕截图所示：
- en: '![Blueprinting our spells](img/00242.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的咒语](img/00242.jpeg)'
- en: Scroll down until you reach the **Spell** category, and update the **Damage
    Per Second** and **Duration** parameters to values you like. Here, the blizzard
    spell will last 3.0 seconds, and do 16.0 damage total per second. After three
    seconds, the blizzard will disappear.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动直到到达 **Spell** 类别，并将 **每秒伤害** 和 **持续时间** 参数更新为您喜欢的值。在这里，暴风咒语将持续 3.0 秒，并且每秒造成
    16.0 的总伤害。三秒后，暴风咒语将消失。
- en: '![Blueprinting our spells](img/00243.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的咒语](img/00243.jpeg)'
- en: After you have configured the **Default** properties, switch over to the **Components**
    tab to make some further modifications. Click on and change the shape of `ProxBox`
    so that its shape makes sense. The box should wrap the most intense part of the
    particle system, but don't get carried away in expanding its size. The `ProxBox`
    object shouldn't be too big, because then your blizzard spell would affect things
    that aren't even being touched by the blizzard. As shown in the following screenshot,
    a couple of outliers are ok.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置完 **默认** 属性后，切换到 **组件** 选项卡以进行一些进一步的修改。点击并更改 `ProxBox` 的形状，使其形状合理。箱子应该包裹粒子系统的最强烈部分，但不要过分扩大其尺寸。`ProxBox`
    对象不应该太大，因为这样你的暴风雪法术就会影响到连暴风雪都没有触及的东西。如下截图所示，几个异常值是可以接受的。
- en: '![Blueprinting our spells](img/00244.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![为我们的法术创建蓝图](img/00244.jpeg)'
- en: Your blizzard spell is now blueprinted and ready to be used by the player.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你的暴风雪法术现在已创建蓝图并准备好供玩家使用。
- en: Picking up spells
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拾取法术
- en: Recall that we previously programmed our inventory to display the number of
    pickup items the player has when the user presses *I*. We want to do more than
    that, however.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们之前编程我们的库存，当用户按下 *I* 时显示玩家拥有的拾取物品数量。然而，我们想做的不仅仅是这样。
- en: '![Picking up spells](img/00245.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![拾取法术](img/00245.jpeg)'
- en: Items displayed when the user presses *I*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下 *I* 时显示的物品
- en: 'To allow the player to pick up spells, we''ll modify the `PickupItem` class
    to include a slot for a blueprint of the spell the player casts by using the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许玩家拾取法术，我们将修改 `PickupItem` 类以包含一个用于玩家施法的法术蓝图的槽位，使用以下代码：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you've added the `UClass* Spell` property to the `APickupItem` class, recompile
    and rerun your C++ project. Now, you can proceed to make blueprints of `PickupItem`
    instances for your `Spell` objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `UClass* Spell` 属性添加到 `APickupItem` 类中，重新编译并重新运行你的 C++ 项目。现在，你可以继续为你的 `Spell`
    对象创建 `PickupItem` 实例的蓝图。
- en: Creating blueprints for PickupItems that cast spells
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为施法拾取物品创建蓝图
- en: 'Create a **PickupItem** blueprint called **BP_Pickup_Spell_Blizzard**. Double-click
    on it to edit its properties, as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 **BP_Pickup_Spell_Blizzard** 的 **PickupItem** 蓝图。双击它以编辑其属性，如下截图所示：
- en: '![Creating blueprints for PickupItems that cast spells](img/00246.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![为施法拾取物品创建蓝图](img/00246.jpeg)'
- en: 'I set the blizzard item''s pickup properties as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我将暴风雪物品的拾取属性设置为以下内容：
- en: 'The name of the item is **Blizzard Spell**, and five are in each package. I
    took a screenshot of the blizzard particle system and imported it to the project,
    so the **Icon** is selected as that image. Under spell, I selected **BP_Spell_Blizzard**
    as the name of the spell to be cast (not **BP_Pickup_Spell_Blizzard**), as shown
    in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 物品的名称是 **Blizzard Spell**，每个包装袋中有五个。我截取了暴风雪粒子系统的截图并将其导入到项目中，因此 **图标** 被选为该图像。在法术下，我选择了
    **BP_Spell_Blizzard** 作为要施法的法术名称（不是 **BP_Pickup_Spell_Blizzard**），如下截图所示：
- en: '![Creating blueprints for PickupItems that cast spells](img/00247.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![为施法拾取物品创建蓝图](img/00247.jpeg)'
- en: I selected a blue sphere for the `Mesh` class of the `PickupItem` class. For
    **Icon**, I took a screenshot of the blizzard spell in the particle viewer preview,
    saved it to disk, and imported that image to the project (see the images folder
    in the **Content Browser** tab of the sample project).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 `PickupItem` 类的 `Mesh` 类选择了蓝色球体。对于 **图标**，我在粒子查看器预览中截取了暴风雪法术的截图，将其保存到磁盘，并将该图像导入到项目中（请参阅示例项目的
    **内容浏览器** 选项卡中的图像文件夹）。
- en: '![Creating blueprints for PickupItems that cast spells](img/00248.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![为施法拾取物品创建蓝图](img/00248.jpeg)'
- en: Place a few of these `PickupItem` in your level. If we pick them up, we will
    have some blizzard spells in our inventory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的关卡中放置几个这样的 `PickupItem`。如果我们拾取它们，我们将在我们的库存中获得一些暴风雪法术。
- en: '![Creating blueprints for PickupItems that cast spells](img/00249.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![为施法拾取物品创建蓝图](img/00249.jpeg)'
- en: 'Left: Blizzard spell pickup items in game world. Right: Blizzard spell pickup
    item in inventory.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 左：游戏世界中的暴风雪法术拾取物品。右：库存中的暴风雪法术拾取物品。
- en: Now we need to activate the blizzard. Since we already attached the left mouse
    click in [Chapter 10](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 10. Inventory System and Pickup Items"), *Inventory System and Pickup
    Items* to dragging the icons around, let's attach the right mouse click to casting
    the spell.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要激活暴风雪。由于我们已经在 [第10章](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "第10章。库存系统和拾取物品") 中将左键点击附加到拖动图标，让我们将右键点击附加到施法法术。
- en: Attaching right mouse click to cast spell
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将右键点击附加到施法法术
- en: 'The right mouse click will have to go through quite a few function calls before
    calling the avatar''s `CastSpell` method. The call graph would look something
    like the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击必须经过相当多的函数调用，才能调用角色的 `CastSpell` 方法。调用图可能看起来像以下截图：
- en: '![Attaching right mouse click to cast spell](img/00250.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![将右键点击附加到施法法术](img/00250.jpeg)'
- en: 'A few things happen between right click and spell cast. They are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在右键点击和施法之间发生了一些事情。具体如下：
- en: As we saw before, all user mouse and keyboard interactions are routed through
    the `Avatar` object. When the `Avatar` object detects a right-click, it will pass
    the click event to `HUD` through `AAvatar::MouseRightClicked()`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们之前所看到的，所有用户鼠标和键盘交互都通过 `Avatar` 对象路由。当 `Avatar` 对象检测到右键点击时，它将通过 `AAvatar::MouseRightClicked()`
    将点击事件传递给 `HUD`。
- en: 'Recall from [Chapter 10](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 10. Inventory System and Pickup Items"), *Inventory System and Pickup
    Items* where we used a `struct Widget` class to keep track of the items the player
    had picked up. `struct Widget` only had three members:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下 [第10章](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "第10章。库存系统和拾取物品")，*库存系统和拾取物品*，在那里我们使用 `struct Widget` 类来跟踪玩家拾取的物品。`struct Widget`
    只有三个成员：
- en: '[PRE6]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will need to add an extra property for `struct Widget` class to remember
    the spell it casts.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要为 `struct Widget` 类添加一个额外的属性来记住它所施的法术。
- en: The `HUD` will determine if the click event was inside `Widget` in `AMyHUD::MouseRightClicked()`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HUD` 将确定点击事件是否发生在 `AMyHUD::MouseRightClicked()` 中的 `Widget` 内。'
- en: If the click was on the `Widget` that casts a spell, the `HUD` then calls the
    avatar back with the request to cast that spell, by calling `AAvatar::CastSpell()`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击的是施法 `Widget`，则 `HUD` 会通过调用 `AAvatar::CastSpell()` 将请求施法该法术的请求传回角色。
- en: Writing the avatar's CastSpell function
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写角色的 CastSpell 函数
- en: 'We will implement the preceding call graph in reverse. We will start by writing
    the function that actually casts spells in the game, `AAvatar::CastSpell()`, as
    shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逆向实现前面的调用图。首先，我们将编写实际在游戏中施法的函数，即 `AAvatar::CastSpell()`，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might find that actually calling a spell is remarkably simple. There are
    two basic steps to casting the spell:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现实际调用法术非常简单。施法有两个基本步骤：
- en: Instantiate the spell object using the world object's `SpawnActor` function
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用世界对象的 `SpawnActor` 函数实例化施法对象
- en: Attach it to the avatar
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其附加到角色上
- en: Once the `Spell` object is instantiated, its `Tick()` function will run each
    frame when that spell is in the level. On each `Tick()`, the `Spell` object will
    automatically feel out monsters within the level and damage them. A lot happens
    with each line of code mentioned previously, so let's discuss each line separately.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Spell` 对象被实例化，其 `Tick()` 函数将在该法术在关卡中的每一帧运行。在每次 `Tick()` 中，`Spell` 对象将自动感知关卡内的怪物并对其造成伤害。之前提到的每一行代码都涉及很多操作，所以让我们分别讨论每一行。
- en: Instantiating the spell – GetWorld()->SpawnActor()
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例化施法对象 – GetWorld()->SpawnActor()
- en: To create the `Spell` object from the blueprint, we need to call the `SpawnActor()`
    function from the `World` object. The `SpawnActor()` function can take any blueprint
    and instantiate it within the level. Fortunately, the `Avatar` object (and indeed
    any `Actor` object) can get a handle to the `World` object at any time by simply
    calling the `GetWorld()` member function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要从蓝图创建 `Spell` 对象，我们需要从 `World` 对象调用 `SpawnActor()` 函数。`SpawnActor()` 函数可以接受任何蓝图并在关卡内实例化它。幸运的是，`Avatar`
    对象（以及任何 `Actor` 对象）可以通过简单地调用 `GetWorld()` 成员函数在任何时候获取到 `World` 对象的句柄。
- en: 'The line of code that brings the `Spell` object into the level is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Spell` 对象引入关卡的那行代码如下：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a couple of things to note about the preceding line of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面一行代码，有几个需要注意的点：
- en: '`bpSpell` must be the blueprint of a `Spell` object to create. The `<ASpell>`
    object in angle brackets indicates that expectation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpSpell` 必须是要创建的 `Spell` 对象的蓝图。尖括号中的 `<ASpell>` 对象表示这种期望。'
- en: The new `Spell` object starts out at the origin (0, 0, 0), and with no additional
    rotation applied to it. This is because we will attach the `Spell` object to the
    `Avatar` object, which will supply translation and direction components for the
    `Spell` object.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `Spell` 对象最初位于原点（0, 0, 0），并且没有对其应用额外的旋转。这是因为我们将 `Spell` 对象附加到 `Avatar` 对象上，该对象将为
    `Spell` 对象提供平移和方向组件。
- en: if(spell)
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if(spell)
- en: We always test if the call to `SpawnActor<ASpell>()` succeeds by checking `if(
    spell )`. If the blueprint passed to the `CastSpell` object is not actually a
    blueprint based on the `ASpell` class, then the `SpawnActor()` function returns
    a `NULL` pointer instead of a `Spell` object. If that happens, we print an error
    message to the screen indicating that something went wrong during spell casting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是通过检查 `if( spell )` 来测试 `SpawnActor<ASpell>()` 调用是否成功。如果传递给 `CastSpell` 对象的蓝图实际上不是基于
    `ASpell` 类的蓝图，那么 `SpawnActor()` 函数将返回一个 `NULL` 指针而不是 `Spell` 对象。如果发生这种情况，我们将在屏幕上打印一条错误消息，表明施法过程中出了问题。
- en: spell->SetCaster(this)
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: spell->SetCaster(this)
- en: When instantiating, if the spell does succeed, we attach the spell to the `Avatar`
    object by calling `spell->SetCaster( this )`. Remember, in the context of programming
    within the `Avatar` class, the `this` method is a reference to the `Avatar` object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，如果施法成功，我们将通过调用 `spell->SetCaster(this)` 将施法附加到 `Avatar` 对象上。记住，在 `Avatar`
    类的编程上下文中，`this` 方法是对 `Avatar` 对象的引用。
- en: Now, how do we actually connect spell casting from UI inputs, to call `AAvatar::CastSpell()`
    function in the first place? We need to do some `HUD` programming again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上如何将 UI 输入的施法连接起来，首先调用 `AAvatar::CastSpell()` 函数呢？我们需要再次进行一些 `HUD` 编程。
- en: Writing AMyHUD::MouseRightClicked()
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 AMyHUD::MouseRightClicked()
- en: The spell cast commands will ultimately come from the HUD. We need to write
    a C++ function that will walk through all the HUD widgets and test to see if a
    click is on any one of them. If the click is on a `widget` object, then that `widget`
    object should respond by casting its spell, if it has one assigned.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 施法命令最终将来自用户界面（HUD）。我们需要编写一个 C++ 函数，该函数将遍历所有 HUD 小部件并测试是否点击了其中任何一个。如果点击的是 `widget`
    对象，那么该 `widget` 对象应该通过施法其分配的施法来响应。
- en: 'We have to extend our `Widget` object to have a variable to hold the blueprint
    of the spell to cast. Add a member to your `struct Widget` object by using the
    following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须扩展我们的 `Widget` 对象，使其具有一个变量来保存要施放的施法蓝图。通过以下代码在您的 `struct Widget` 对象中添加一个成员：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, recall that our `PickupItem` had the blueprint of the spell it casts attached
    to it previously. However, when the `PickupItem` class is picked up from the level
    by the player, then the `PickupItem` class is destroyed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下，我们的 `PickupItem` 之前已经附加了它所施法的施法蓝图。然而，当玩家从关卡中拾取 `PickupItem` 类时，`PickupItem`
    类就会被销毁。
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we need to retain the information of what spell each `PickupItem` casts.
    We can do that when that `PickupItem` is first picked up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要保留每个 `PickupItem` 施法的施法信息。我们可以在 `PickupItem` 首次被拾取时做到这一点。
- en: 'Inside the `AAvatar` class, add an extra map to remember the blueprint of the
    spell that an item casts, by item name:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AAvatar` 类内部，添加一个额外的映射来记住物品名称对应的施法蓝图：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now in `AAvatar::Pickup()`, remember the class of spell the `PickupItem` class
    instantiates with the following line of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `AAvatar::Pickup()` 中，记住 `PickupItem` 类使用以下代码行实例化的施法类：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, in `AAvatar::ToggleInventory()`, we can have the `Widget` object that displays
    on the screen. Remember what spell it is supposed to cast by looking up the `Spells`
    map.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `AAvatar::ToggleInventory()` 中，我们可以拥有显示在屏幕上的 `Widget` 对象。通过查找 `Spells`
    映射来记住它应该施放哪个施法。
- en: 'Find the line where we create the widget, and just under it, add assignment
    of the `bpSpell` objects that the `Widget` casts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 找到创建小部件的行，并在其下方添加分配 `Widget` 施法的 `bpSpell` 对象：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following function to `AMyHUD`, which we will set to run whenever the
    right mouse button is clicked on the icon:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到 `AMyHUD` 中，我们将将其设置为在右鼠标按钮点击图标时运行：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is very similar to our left mouse click function. We simply check the click
    position against all the widgets. If any `Widget` was hit by the right-click,
    and that `Widget` has a `Spell` object associated with it, then a spell will be
    cast by calling the avatar's `CastSpell()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的左键点击功能非常相似。我们只是将点击位置与所有小部件进行比较。如果任何`Widget`被右键点击，并且该`Widget`与一个`Spell`对象相关联，那么将通过调用角色的`CastSpell()`方法施放一个法术。
- en: Activating right mouse button clicks
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活右键点击
- en: 'To connect this HUD function to run, we need to attach an event handler to
    the mouse right-click. We can do so by going to **Settings** | **Project Settings**,
    and from the dialog that pops up, adding an **Input** option for **Right Mouse
    Button**, as shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此HUD函数连接到运行，我们需要将事件处理程序附加到鼠标右键。我们可以通过转到**设置** | **项目设置**，然后从弹出的对话框中添加一个**输入**选项，用于**右键按钮**，如下面的截图所示：
- en: '![Activating right mouse button clicks](img/00251.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![激活右键点击](img/00251.jpeg)'
- en: 'Declare a function in `Avatar.h`/`Avatar.cpp` called `MouseRightClicked()`
    with the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Avatar.h`/`Avatar.cpp`中声明一个名为`MouseRightClicked()`的函数，代码如下：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, in `AAvatar::SetupPlayerInputComponent()`, we should attach `MouseClickedRMB`
    event to that `MouseRightClicked()` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`AAvatar::SetupPlayerInputComponent()`中，我们应该将`MouseClickedRMB`事件附加到`MouseRightClicked()`函数：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have finally hooked up spell casting. Try it out, the gameplay is pretty
    cool, as shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于连接了施法。试试看，游戏玩法相当酷，如下面的截图所示：
- en: '![Activating right mouse button clicks](img/00252.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![激活右键点击](img/00252.jpeg)'
- en: Creating other spells
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建其他法术
- en: By playing around with particle systems, you can create a variety of different
    spells that do different effects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过玩弄粒子系统，你可以创建各种不同的法术，产生不同的效果。
- en: The fire spell
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 火焰法术
- en: 'You can easily create a fire variant of our blizzard spell by changing the
    color of the particle system to red:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地通过将粒子系统的颜色改为红色来创建我们暴风雪法术的火焰变体：
- en: '![The fire spell](img/00253.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![火焰法术](img/00253.jpeg)'
- en: The out val of the color changed to red
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色值变为红色
- en: Exercises
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try the following exercises:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: '**Lightning spell**: Create a lightning spell by using the beam particle. Follow
    Zak''s tutorial for an example of how beams are created and shot in a direction,
    at [https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7](https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7).'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**闪电法术**：通过使用光束粒子创建闪电法术。遵循Zak的教程，了解如何创建和向某个方向发射光束的示例，请参阅[https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7](https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7)。'
- en: '**Forcefield spell**: A forcefield will deflect attacks. It is essential for
    any player. Suggested implementation: Derive a subclass of `ASpell` called `ASpellForceField`.
    Add a bounding sphere to the class, and use that in the `ASpellForceField::Tick()`
    function to push the monsters out.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**护盾法术**：护盾会反弹攻击。这对任何玩家都是必不可少的。建议实现：从`ASpell`派生一个子类，称为`ASpellForceField`。向该类添加一个边界球体，并在`ASpellForceField::Tick()`函数中使用它将怪物推出。'
- en: 'What''s next? I would highly recommend that you expand on our little game here.
    Here are some ideas for expansion:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？我强烈建议你扩展我们的小游戏。以下是一些扩展的想法：
- en: Create more environments, expand the terrain, add in more houses and buildings
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更多环境，扩展地形，添加更多房屋和建筑
- en: Add quests that come from NPCs
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加来自NPC的任务
- en: Define more melee weapons such as, swords
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义更多近战武器，例如，剑
- en: Define armor for the player, such as shields
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家定义盔甲，例如，盾牌
- en: Add shops that sell weapons to the player
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家添加出售武器的商店
- en: Add more monster types
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多怪物类型
- en: Implement loot drops for monsters
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现怪物掉落物品
- en: You have literally thousands of hours of work ahead of you. If you happen to
    be a solo programmer, form working relationships with other souls. You cannot
    survive in the game marketplace on your own.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你面前的工作时间实际上有成千上万个小时。如果你碰巧是一个独立程序员，与其他程序员建立工作关系。你无法独自在游戏市场中生存。
- en: It's dangerous to go alone—Take a friend.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 独自一人去是危险的——带上一个朋友。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes this chapter. You have come a long way. From not knowing anything
    about C++ programming at all, to hopefully being able to string together a basic
    game program in UE4.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这一章。你已经走了很长的路。从对C++编程一无所知，到希望能够在UE4中编写一个基本的游戏程序。
