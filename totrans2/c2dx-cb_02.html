<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating Sprites</h1></div></div></div><p>In this chapter we're going to create sprites, animations, and actions. The following topics will be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating sprites</li><li class="listitem" style="list-style-type: disc">Getting the sprite's position and size</li><li class="listitem" style="list-style-type: disc">Manipulating sprites</li><li class="listitem" style="list-style-type: disc">Creating animations</li><li class="listitem" style="list-style-type: disc">Creating actions</li><li class="listitem" style="list-style-type: disc">Controlling actions</li><li class="listitem" style="list-style-type: disc">Calling functions with actions</li><li class="listitem" style="list-style-type: disc">Easing actions</li><li class="listitem" style="list-style-type: disc">Using a texture atlas</li><li class="listitem" style="list-style-type: disc">Using a batch node</li><li class="listitem" style="list-style-type: disc">Using 3D models</li><li class="listitem" style="list-style-type: disc">Detecting collisions</li><li class="listitem" style="list-style-type: disc">Drawing a shape</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Introduction</h1></div></div></div><p>Sprites<a id="id61" class="indexterm"/> are a 2D image. We can animate and transform them by changing their properties. Sprites are basically, items and your game is not complete without them. Sprites are not only displayed, but also transformed or moved. In this chapter, you will learn how to create sprites using 3D models in Cocos2d-x, and then, we will go through the advantages of sprites.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Creating sprites</h1></div></div></div><p>Sprites are<a id="id62" class="indexterm"/> the most important things in games. They are images that are displayed on the screen. In this recipe, you will learn how to create a sprite and display it.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Getting ready</h2></div></div></div><p>You can add the image that you made in the previous chapter into your project, by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the image into the <code class="literal">Resource</code> folder <code class="literal">MyGame/Resources/res</code>.</li><li class="listitem">Open your project in Xcode.</li><li class="listitem">Go to <strong>Product</strong> | <strong>Clean</strong> from the Xcode menu.</li></ol></div><p>You have to clean and build when you add new images into the <code class="literal">resource</code> folder. If you did not clean after adding new images, then Xcode will not recognize them. Finally, after you add the <code class="literal">run_01.png</code> to your project, your project will be seen looking like the following screenshot:</p><div><img src="img/B00561_02_01.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>How to do it...</h2></div></div></div><p>We begin<a id="id63" class="indexterm"/> with modifying the <code class="literal">HelloWorld::init</code> method in the following code:</p><div><pre class="programlisting">bool HelloWorld::init()
{
    if ( !Layer::init() )
    {
        return false;
    }
    Size size = Director::getInstance()-&gt;getWinSize();
    auto sprite = Sprite::create("res/run_01.png");
   sprite-&gt;setPosition(Vec2(size.width/2, size.height/2));
    this-&gt;addChild(sprite);
    return true;
}</pre></div><p>And then, after we build &amp; run the project, we can see the following:</p><div><img src="img/B00561_02_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>How it works...</h2></div></div></div><p>You can get <a id="id64" class="indexterm"/>the screen size from the <code class="literal">Director::getWinSize</code> method. The <code class="literal">Director</code> class is a singleton class. You can get the instance using the <code class="literal">getInstance</code> method. So you can get the screen size by <code class="literal">Director::getInstance-&gt;getWinSize()</code>.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Please note that you can get an instance of a singleton class in Cocos2d-x using the <code class="literal">getInstance</code> method.</p></div></div><p>Sprites are made from images. You can create a sprite by specifying the image. In this case, you create the sprite by <code class="literal">run_01.png</code> in the <code class="literal">res</code> folder.</p><p>Next, you need to specify the coordinates of the sprite. In this case, you set the sprite in the center of the screen. The <code class="literal">Size</code> class has the width and height property. You can specify the location of the sprite using the <code class="literal">setPosition</code> method. The argument of the <code class="literal">setPosition</code> method is <code class="literal">Vec2</code>. <code class="literal">Vec2</code> has two properties as floating point vector, <code class="literal">x</code> axis coordinate and <code class="literal">y</code> axis coordinate.</p><p>The last step is to add the sprite on the layer. A layer is like a transparent sheet on the screen. You will learn about layers in <a class="link" href="ch04.html" title="Chapter 4. Building Scenes and Layers">Chapter 4</a>, <em>Building Scenes and Layers</em>.</p><p>All objects that are displayed on the screen are <strong>node</strong>. Sprite and Layer are types of node. If you haven't added it in the other nodes, the node does not appear on the screen. You can add a node in the other nodes by the <code class="literal">addChild</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>There's more...</h2></div></div></div><p>You can set the<a id="id65" class="indexterm"/> sprite using the static coordinate. In the following<a id="id66" class="indexterm"/> case we see that the Sprite position is <code class="literal">(100, 200)</code>.</p><div><pre class="programlisting">
<strong>sprite-&gt;setPosition(Vec2(100, 200));</strong>
</pre></div><p>Also, you can set the sprite in the center of the screen using C++ operator overloading.</p><div><pre class="programlisting">
<strong>sprite-&gt;setPosition(size/2);</strong>
</pre></div><p>If you want to remove the sprite from the layer, you can remove it by the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;removeFromParent();</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>See also</h2></div></div></div><p>The <code class="literal">Sprite</code> class has a lot of properties. You can manipulate them and change the sprite's appearance. You will also learn more about layer and the scene, which will be explained in <a class="link" href="ch04.html" title="Chapter 4. Building Scenes and Layers">Chapter 4</a>, <em>Building Scenes and Layers</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Getting the sprite's position and size</h1></div></div></div><p>There is a <a id="id67" class="indexterm"/>certain size and position of the sprite. In this recipe, we<a id="id68" class="indexterm"/> explain how to view the size and position of the sprite.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>How to do it...</h2></div></div></div><p>To get the sprite<a id="id69" class="indexterm"/> position, use <a id="id70" class="indexterm"/>the following code:</p><div><pre class="programlisting">
<strong>Vec2 point = sprite-&gt;getPosition();</strong>
<strong>float x = point.x;</strong>
<strong>float y = point.y;</strong>
</pre></div><p>To get the sprite size, use the following code:</p><div><pre class="programlisting">
<strong>Size size = sprite-&gt;getContentSize();</strong>
<strong>float width = size.width;</strong>
<strong>float height = size.height;</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How it works...</h2></div></div></div><p>By default, the sprite position is (<code class="literal">0,0</code>). You can change the sprite position using the <code class="literal">setPosition</code> method and get it using the <code class="literal">getPosition</code> method. You can get the sprite size using the <code class="literal">getContentSize</code> method. However, you cannot change the sprite size by the <code class="literal">setContentSize</code> method. The <code class="literal">contentsize</code> is a constant value. If you want to change the sprite size, you have to change the scale of the sprite. You will learn about the scale in the next recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>There's more...</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Setting anchor points</h3></div></div></div><p>
<strong>Anchor point</strong> is a<a id="id71" class="indexterm"/> point that you set as a way to specify what part of the sprite will be used when setting its position. The anchor point uses a bottom-left coordinate system. By default, the anchor point of all Node objects is <code class="literal">(0.5, 0.5)</code>. This means that the default anchor point is the center.</p><p>To get the anchor point at the center of the sprite, we use the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;setAnchorPoint(Vec2(0.5, 0.5));</strong>
</pre></div><p>To get the anchor point at the bottom-left of the sprite, we use the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;setAnchorPoint(Vec2(0.0, 0.0));</strong>
</pre></div><p>To get the anchor point at the top-left of the sprite, we use the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;setAnchorPoint(Vec2(1.0, 0.0));</strong>
</pre></div><p>To get the anchor point at the bottom-right of the sprite, we use the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;setAnchorPoint(Vec2(0.0, 1.0));</strong>
</pre></div><p>To get the anchor point at the top-right of the sprite, we use the following code:</p><div><pre class="programlisting">
<strong>sprite-&gt;setAnchorPoint(Vec2(1.0, 1.0));</strong>
</pre></div><p>The following<a id="id72" class="indexterm"/> image shows the various positions of the anchor point:</p><div><img src="img/B00561_02_03.jpg" alt="Setting anchor points"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Rectangle</h3></div></div></div><p>To get the<a id="id73" class="indexterm"/> sprite rectangle, use the following code:</p><div><pre class="programlisting">
<strong>Rect rect = sprite-&gt;getBoundingBox();</strong>
<strong>Size size = rect.size;</strong>
<strong>Vec2 point = rect.origin;</strong>
</pre></div><p>
<code class="literal">Rect</code> is the sprite rectangle that has properties such as <code class="literal">Size</code> and <code class="literal">Vec2</code>. If the scale is not equal to one, then <code class="literal">Size</code> in <code class="literal">Rect</code> will not be equal to the <code class="literal">size</code>, using <code class="literal">getContentSize</code> method. <code class="literal">Size</code> of <code class="literal">getContentSize</code> is the original image size. On the other side, <code class="literal">Size</code> in <code class="literal">Rect</code> using <code class="literal">getBoundingBox</code> is the size of appearance. For example, when you set the sprite to half scale, the <code class="literal">Size</code> in <code class="literal">Rect</code> using <code class="literal">getBoundingBox</code> is half the size, and the <code class="literal">Size</code> using <code class="literal">getContentSize</code> is the original size. The position and size of a sprite is a very important point when you need to specify the sprites on the screen.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Detecting collisions</em> recipe, where you can detect collision using <code class="literal">rect</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Manipulating sprites</h1></div></div></div><p>A Sprite is a 2D image that can <a id="id74" class="indexterm"/>be animated or transformed by changing its properties, including its rotation, position, scale, color, and so on. After creating a sprite you can obtain access to the variety of properties it has, which can be manipulated.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How to do it...</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Rotate</h3></div></div></div><p>You can change the <a id="id75" class="indexterm"/>sprite's rotation to positive or negative degrees.</p><div><pre class="programlisting">
<strong>sprite-&gt;setRotation(30.0f);</strong>
</pre></div><p>You can get the rotation value using <code class="literal">getRotation</code> method.</p><div><pre class="programlisting">
<strong>float rotation = sprite-&gt;getRotation();</strong>
</pre></div><p>The positive value rotates it clockwise, and the negative value rotates it counter clockwise. The default value is zero. The preceding code rotates the sprite 30 degrees clockwise, as shown in the following screenshot:</p><div><img src="img/B00561_02_04.jpg" alt="Rotate"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Scale</h3></div></div></div><p>You can change the<a id="id76" class="indexterm"/> sprite's scale. The default value is <code class="literal">1.0f</code>, the original size. The following code will scale to half size.</p><div><pre class="programlisting">
<strong>sprite-&gt;setScale(0.5f);</strong>
</pre></div><p>You can also change the width and height separately. The following code will scale to half the width only.</p><div><pre class="programlisting">
<strong>sprite-&gt;setScaleX(0.5f);</strong>
</pre></div><p>The following will scale to half the height only.</p><div><pre class="programlisting">
<strong>sprite-&gt;setScaleY(0.5f);</strong>
</pre></div><p>The following code will scale that width to double and the height to half.</p><div><pre class="programlisting">
<strong>sprite-&gt;setScale(2.0f, 0.5f);</strong>
</pre></div><div><img src="img/B00561_02_05.jpg" alt="Scale"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Skew</h3></div></div></div><p>You can <a id="id77" class="indexterm"/>change the sprite's skew, either by <code class="literal">X</code>, <code class="literal">Y</code> or uniformly for both <code class="literal">X</code> and <code class="literal">Y</code>. The default value is zero for both <code class="literal">X</code> and <code class="literal">Y</code>.</p><p>The following code adjusts the <code class="literal">X</code> skew by <code class="literal">20.0</code>:</p><div><pre class="programlisting">
<strong>sprite-&gt;setSkewX(20.0f);</strong>
</pre></div><p>The following code adjusts the <code class="literal">Y</code> skew by <code class="literal">20.0</code>:</p><div><pre class="programlisting">
<strong>sprite-&gt;setSkewY(20.0f);</strong>
</pre></div><div><img src="img/B00561_02_06.jpg" alt="Skew"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Color</h3></div></div></div><p>You can change the<a id="id78" class="indexterm"/> sprite's color by passing in a <code class="literal">Color3B</code> object. <code class="literal">Color3B</code> has an RGB value.</p><div><pre class="programlisting">
<strong>sprite-&gt;setColor(Color3b(255, 0, 0));</strong>
</pre></div><div><img src="img/B00561_02_07.jpg" alt="Color"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Opacity</h3></div></div></div><p>You can change the<a id="id79" class="indexterm"/> sprite's opacity. The opacity property is set between a value from 0 to 255.</p><div><pre class="programlisting">
<strong>sprite-&gt;setOpacity(100);</strong>
</pre></div><p>The sprite is fully opaque when it is set to 255, and fully transparent when it is set to zero. The default value is always 255.</p><div><img src="img/B00561_02_08.jpg" alt="Opacity"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Visibility</h3></div></div></div><p>You can change the<a id="id80" class="indexterm"/> sprite's visibility by passing in a Boolean value. If it is <code class="literal">false</code>, then the sprite is invisible; if it is <code class="literal">true</code>, then the sprite is visible. The default value is always <code class="literal">true</code>.</p><div><pre class="programlisting">
<strong>sprite-&gt;setVisible(false);</strong>
</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>If you want to check the sprite's visibility, use the <code class="literal">isVisible</code> method rather than the <code class="literal">getVisible</code> method. The sprite class does not have the <code class="literal">getVisible</code> method.</p><div><pre class="programlisting">if (sprite-&gt;isVisible()) {
    // visible
} else {
    // invisible
}</pre></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How it works...</h2></div></div></div><p>A Sprite has a lot of properties. You can manipulate a sprite using the <code class="literal">setter</code> and <code class="literal">getter</code> methods.</p><p>RGB color is a 3 byte value from zero to 255. Cocos2d-x provides predefined colors.</p><div><pre class="programlisting">Color3B::WHITE
Color3B::YELLOW
Color3B::BLUE
Color3B::GREEN
Color3B::RED
Color3B::MAGENTA
Color3B::BLACK
Color3B::ORANGE
Color3B::GRAY</pre></div><p>You can find them by <a id="id81" class="indexterm"/>looking at the <code class="literal">ccType.h</code> file in Cocos2d-x.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Creating animations</h1></div></div></div><p>When the characters in a<a id="id82" class="indexterm"/> game start to move, the game will come alive. There are many ways to make animated characters. In this recipe, we will animate a character by using multiple images.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>You can create an animation from a series of the following image files:</p><div><img src="img/B00561_02_09.jpg" alt="Getting ready"/></div><p>You need to add the running girl's animation image files to your project and clean your project.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Please check the recipe <em>Creating sprites</em>, which is the first recipe in this chapter, on how to add images to your project.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it...</h2></div></div></div><p>You can create an animation using a series of images. The following code creates the running girl's animation.</p><div><pre class="programlisting">auto animation = Animation::create();
for (int i=1; i&lt;=8; i++) {  // from run_01.png to run_08.png
    std::string name = StringUtils::format("res/run_%02d.png", i);
    animation-&gt;addSpriteFrameWithFile(name.c_str());
}
animation-&gt;setDelayPerUnit(0.1f);
animation-&gt;setRestoreOriginalFrame(true);
animation-&gt;setLoops(10);
auto action = Animate::create(animation);
sprite-&gt;runAction(action);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works...</h2></div></div></div><p>You can create an animation using the <code class="literal">Animation</code> class and the <code class="literal">Animate</code> class. They change multiple images at regular intervals. The names of the series image files have the serial number, we have added a file name to the <code class="literal">Animation</code> class in the for loop. We can create the formatted<a id="id83" class="indexterm"/> string using the <code class="literal">StringUtils</code> class in Cocos2d-x.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>
<code class="literal">StringUtils</code> is a very useful class. The <code class="literal">StringUtils::toString</code> method can generate the <code class="literal">std::string</code> value from a variety of values.</p><div><pre class="programlisting">int i = 100;
std::string int_string = StringUtils::toString(i);
CCLOG("%s ", int_string.c_str());
float j = 123.4f;
std::string float_string = StringUtils::toString(j);
CCLOG("%s", float_string.c_str());</pre></div><p>
<code class="literal">StringUtils::format</code> method can generate the <code class="literal">std::string</code> value using the <code class="literal">printf</code> format.</p><p>You can view the log by using CCLOG macro. CCLOG is very useful. You can check the value of the variable in the log during the execution of your game. CCLOG has the same parameters as a <code class="literal">sprintf</code> function.</p></div></div><p>We will add the file name into the <code class="literal">Animation</code> instance using the <code class="literal">addSpriteFrameWithFile</code> method. It sets the units of time which the frame takes using <code class="literal">setDelayPerunit</code> method. It is set to restore the original frame when the animation finishes using the <code class="literal">setRestoreOriginalFrame</code> method. True value is to restore the original frame. It is set to the number of times the animation is going to loop. Then, create the <code class="literal">Animate</code> instance by passing it with the <code class="literal">Animation</code> instance that you created earlier. Finally, run the <code class="literal">runAction</code> method by passing in the <code class="literal">Animate</code> instance.</p><p>If you want to run the animation forever, set <code class="literal">-1</code> using the <code class="literal">setLoops</code> method.</p><div><pre class="programlisting">
<strong>animation-&gt;setLoops(-1);</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>There's more...</h2></div></div></div><p>In the preceding code, you <a id="id84" class="indexterm"/>cannot control each animation frame. In such cases, you can use the <code class="literal">AnimationFrame</code> class. This class can control each animation frame. You can set the units of time the frame takes using the second argument of the <code class="literal">AnimationFrame::create</code> method.</p><div><pre class="programlisting">auto rect = Rect::ZERO;
rect.size = sprite-&gt;getContentSize();
Vector&lt;AnimationFrame*&gt; frames;
for (int i=1; i&lt;=8; i++) {
    std::string name = StringUtils::format("res/run_%02d.png", i);
    auto frame = SpriteFrame::create(name.c_str(), rect);
    ValueMap info;
    auto animationFrame = AnimationFrame::create(frame, i, info);
    frames.pushBack(animationFrame);
}
auto animation = Animation::create(frames, 0.1f);
animation-&gt;setDelayPerUnit(0.1f);
animation-&gt;setRestoreOriginalFrame(true);
animation-&gt;setLoops(-1);
auto action = Animate::create(animation);
sprite-&gt;runAction(action);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using a texture atlas</em> recipe to create an animation using texture atlas</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating actions</h1></div></div></div><p>Cocos2d-x has a lot of<a id="id85" class="indexterm"/> actions, for example, move, jump, rotate, and so on. We often use these actions in our games. This is similar to an animation, when the characters in a game start their action, the game will come alive. In this recipe you will learn how to use a lot of actions.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How to do it...</h2></div></div></div><p>Actions are very important effects in a game. Cocos2d-x allows you to use various actions.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Move</h3></div></div></div><p>To move a sprite<a id="id86" class="indexterm"/> by a specified point over two seconds, you can use the following command:</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 100));
sprite-&gt;runAction(move);</pre></div><p>To move a <a id="id87" class="indexterm"/>sprite to a specified point over two seconds, you can use the following command:</p><div><pre class="programlisting">auto move = MoveTo::create(2.0f, Vec2(100, 100));
sprite-&gt;runAction(move);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Scale</h3></div></div></div><p>To uniformly scale a <a id="id88" class="indexterm"/>sprite by 3x over two seconds, use the following command:</p><div><pre class="programlisting">auto scale = ScaleBy::create(2.0f, 3.0f);
sprite-&gt;runAction(scale);</pre></div><p>To scale the <code class="literal">X</code> axis by 5x, and <code class="literal">Y</code> axis by 3x over two seconds, use the following command:</p><div><pre class="programlisting">auto scale = ScaleBy::create(2.0f, 5.0f, 3.0f);
sprite-&gt;runAction(scale);</pre></div><p>To uniformly scale a sprite to 3x over two seconds, use the following command:</p><div><pre class="programlisting">auto scale = ScaleTo::create(2.0f, 3.0f);
sprite-&gt;runAction(scale);</pre></div><p>To scale <code class="literal">X</code> axis to 5x, and <code class="literal">Y</code> axis to 3x over two seconds, use the following command:</p><div><pre class="programlisting">auto scale = ScaleTo::create(2.0f, 5.0f, 3.0f);
sprite-&gt;runAction(scale);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Jump</h3></div></div></div><p>To make a sprite<a id="id89" class="indexterm"/> jump by a specified point three times over two seconds, use the following command:</p><div><pre class="programlisting">auto jump = JumpBy::create(2.0f, Vec2(20, 20), 20.0f, 3);
sprite-&gt;runAction(jump);</pre></div><p>To make a sprite jump to a specified point three times over two seconds, use the following command:</p><div><pre class="programlisting">auto jump = JumpTo::create(2.0f, Vec2(20, 20), 20.0f, 3);
sprite-&gt;runAction(jump);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Rotate</h3></div></div></div><p>To rotate a sprite <a id="id90" class="indexterm"/>clockwise by 40 degrees over two seconds, use the following command:</p><div><pre class="programlisting">auto rotate = RotateBy::create(2.0f, 40.0f);
sprite-&gt;runAction(rotate);</pre></div><p>To rotate a <a id="id91" class="indexterm"/>sprite counterclockwise by 40 degrees over two seconds, use the following command:</p><div><pre class="programlisting">auto rotate = RotateTo::create(2.0f, -40.0f);
sprite-&gt;runAction(rotate);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Blink</h3></div></div></div><p>To make <a id="id92" class="indexterm"/>a sprite blink five times in two seconds, use the following command:</p><div><pre class="programlisting">auto blink = RotateTo::create(2.0f, -40.0f);
sprite-&gt;runAction(blink);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Fade</h3></div></div></div><p>To fade in a <a id="id93" class="indexterm"/>sprite in two seconds, use the following command:</p><div><pre class="programlisting">auto fadein = FadeIn::create(2.0f);
sprite-&gt;runAction(fadein);</pre></div><p>To fade out a sprite in two seconds, use the following command:</p><div><pre class="programlisting">auto fadeout = FadeOut::create(2.0f);
sprite-&gt;runAction(fadeout);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Skew</h3></div></div></div><p>The following code<a id="id94" class="indexterm"/> skews a sprite's <code class="literal">X</code> axis by 45 degrees and <code class="literal">Y</code> axis by 30 degrees over two seconds:</p><div><pre class="programlisting">auto skew = SkewBy::create(2.0f, 45.0f, 30.0f);
sprite-&gt;runAction(skew);</pre></div><p>The following code skews a sprite's <code class="literal">X</code> axis to 45 degrees and <code class="literal">Y</code> axis to 30 degrees over two seconds.</p><div><pre class="programlisting">auto skew = SkewTo::create(2.0f, 45.0f, 30.0f);
sprite-&gt;runAction(skew);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Tint</h3></div></div></div><p>The following code tints<a id="id95" class="indexterm"/> a sprite by the specified RGB values:</p><div><pre class="programlisting">auto tint = TintBy::create(2.0f, 100.0f, 100.0f, 100.0f);
sprite-&gt;runAction(tint);</pre></div><p>The following code tints a sprite to the specified RGB values:</p><div><pre class="programlisting">auto tint = TintTo:: create(2.0f, 100.0f, 100.0f, 100.0f);
sprite-&gt;runAction(tint);</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>How it works...</h2></div></div></div><p>
<code class="literal">Action</code> objects make <a id="id96" class="indexterm"/>a sprite perform a change to its properties. <code class="literal">MoveTo</code>, <code class="literal">MoveBy</code>, <code class="literal">ScaleTo</code>, <code class="literal">ScaleBy</code> and others, are <code class="literal">Action</code> objects. You can move a sprite from one position to another position using <code class="literal">MoveTo</code> or <code class="literal">MoveBy</code>.</p><p>You will notice that each <code class="literal">Action</code> has a <code class="literal">By</code> and <code class="literal">To</code> suffix. That's why they have different behaviors. The method with the <code class="literal">By</code> suffix is relative to the current state of sprites. The method with the <code class="literal">To</code> suffix is absolute to the current state of sprites. You know that all actions in Cocos2d-x have <code class="literal">By</code> and <code class="literal">To</code> suffix, and all actions have the same rule as its suffix.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>There's more...</h2></div></div></div><p>When you want to execute a sprite action, you make an action and execute the <code class="literal">runAction</code> method by passing in the <code class="literal">action</code> instance. If you want to stop the action while sprites are running actions, execute the <code class="literal">stopAllActions</code> method or <code class="literal">stopAction</code> by passing in the <code class="literal">action</code> instance that you got as the return value of the <code class="literal">runAction</code> method.</p><div><pre class="programlisting">auto moveTo = MoveTo::create(2.0f, Vec2(100, 100));
auto action = sprite-&gt;runAction(moveTo);
sprite-&gt;stopAction(action);</pre></div><p>If you run <code class="literal">stopAllActions</code>, all of the actions that sprite is running will be stopped. If you run <code class="literal">stopAction</code> by passing the <code class="literal">action</code> instance, that specific action will be stopped.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Controlling actions</h1></div></div></div><p>In the previous recipe, you <a id="id97" class="indexterm"/>learned some of the basic actions. However, you may want to use more complex actions; for example, rotating a character while moving, or moving a character after jumping. In this recipe, you will learn how to control actions.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How to do it...</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Sequencing actions</h3></div></div></div><p>
<code class="literal">Sequence</code> is a series of actions<a id="id98" class="indexterm"/> to be executed sequentially. This can be any number of actions.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f);
auto action = Sequence::create(move, rotate, nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding command will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds</li><li class="listitem" style="list-style-type: disc">Rotate a sprite clockwise by 360 degree over two seconds</li></ul></div><p>It takes a total of four<a id="id99" class="indexterm"/> seconds to execute these commands.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Spawning actions</h3></div></div></div><p>
<code class="literal">Spawn</code> is very<a id="id100" class="indexterm"/> similar to <code class="literal">Sequence</code>, except that all actions will run at the same time. You can specify any number of actions at the same time.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f);
auto action = Spawn::create(move, rotate, nullptr);
sprite-&gt;runAction(action);</pre></div><p>It will execute the following actions at the same time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moved a sprite 100px to the right over two seconds</li><li class="listitem" style="list-style-type: disc">Rotated a sprite clockwise by 360 degree over two seconds</li></ul></div><p>It takes a total of two seconds to execute them.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Repeating actions</h3></div></div></div><p>
<code class="literal">Repeat</code> object is to <a id="id101" class="indexterm"/>repeat an action the number of specified times.</p><div><pre class="programlisting">auto rotate = RotateBy::create(2.0f, 360.0f);
auto action = Repeat::create(rotate, 5);
sprite-&gt;runAction(action);</pre></div><p>The preceding command will execute a <code class="literal">rotate</code> action five times.</p><p>If you want to repeat forever, you can use the <code class="literal">RepeatForever</code> action.</p><div><pre class="programlisting">auto rotate = RotateBy::create(2.0f, 360.0f);
auto action = RepeatForever::create(rotate);
sprite-&gt;runAction(action);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Reversing actions</h3></div></div></div><p>If you generate<a id="id102" class="indexterm"/> an <code class="literal">action</code> instance, you can call a <code class="literal">reverse</code> method to run it in the <code class="literal">reverse</code> action.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto action = Sequence::create(move, move-&gt;reverse(), nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding code will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds.</li><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the left over two seconds.</li></ul></div><p>In addition, if you <a id="id103" class="indexterm"/>generate a sequence action, you can call a <code class="literal">reverse</code> method to run it in the opposite order.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f);
auto sequence = Sequence::create(move, rotate, nullptr);
auto action = Sequence::create(sequence, sequence-&gt;reverse(), nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding code will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds.</li><li class="listitem" style="list-style-type: disc">Rotate a sprite clockwise by 360 degree over two seconds</li><li class="listitem" style="list-style-type: disc">Rotate a sprite counterclockwise by 360 degree over two seconds</li><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the left over two seconds.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec21"/>DelayTime</h3></div></div></div><p>
<code class="literal">DelayTime</code> is a delayed <a id="id104" class="indexterm"/>action within the specified number of seconds.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto delay = DelayTime::create(2.0f);
auto rotate = RotateBy::create(2.0f, 360.0f);
auto action = Sequence::create(move, delay, rotate, nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding command will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds</li><li class="listitem" style="list-style-type: disc">Delay the next action by two seconds</li><li class="listitem" style="list-style-type: disc">Rotate a sprite clockwise by 360 degree over two seconds</li></ul></div><p>It takes a total of six seconds to execute it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How it works...</h2></div></div></div><p>
<code class="literal">Sequence</code> action<a id="id105" class="indexterm"/> runs actions sequentially. You can generate a <code class="literal">Sequence</code> instance with actions sequentially. Also, you need to specify <code class="literal">nullptr</code> last. If you did not specify <code class="literal">nullptr</code>, your game will crash.</p><div><img src="img/B00561_02_10.jpg" alt="How it works..."/></div><p>
<code class="literal">Spawn</code> action<a id="id106" class="indexterm"/> runs actions at the same time. You can generate a <code class="literal">Spawn</code> instance with actions and <code class="literal">nullptr</code> like <code class="literal">Sequence</code> action.</p><div><img src="img/B00561_02_11.jpg" alt="How it works..."/></div><p>
<code class="literal">Repeat</code>  and <code class="literal">RepeatForever</code> actions can <a id="id107" class="indexterm"/>run, repeating the same action. <code class="literal">Repeat</code> action has two <a id="id108" class="indexterm"/>parameters, the repeating action and the number of repeating actions. <code class="literal">RepeatForever</code> action has one parameter, the repeating action, which is why it will run forever.</p><p>Most actions, including <code class="literal">Sequence</code>, <code class="literal">Spawn</code> and <code class="literal">Repeat,</code> have the <code class="literal">reverse</code> method. But like the <code class="literal">MoveTo</code> method that has the suffix <code class="literal">To</code>, it does not have the <code class="literal">reverse</code> method; that's why it cannot run the reverse action. <code class="literal">Reverse</code> method generates its reverse action. The following code uses the <code class="literal">MoveBy::reverse</code> method.</p><div><pre class="programlisting">MoveBy* MoveBy::reverse() const
{
    return MoveBy::create(_duration, -_positionDelta);
}</pre></div><p>
<code class="literal">DelayTime</code> action can<a id="id109" class="indexterm"/> delay an action after this. The benefit of the <code class="literal">DelayTime</code> action is that you can put it in the <code class="literal">Sequence</code> action. Combining <code class="literal">DelayTime</code> and <code class="literal">Sequence</code> is a very powerful feature.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>There's more...</h2></div></div></div><p>
<code class="literal">Spawn</code> produces the same results as running multiple consecutive <code class="literal">runAction</code> statements.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f); 
sprite-&gt;runAction(move);
sprite-&gt;runAction(rotate);</pre></div><p>However, the benefit of <code class="literal">Spawn</code> is that you can put it in the <code class="literal">Sequence</code> action. Combining <code class="literal">Spawn</code> and <code class="literal">Sequence</code> is a very powerful feature.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f); 
auto fadeout = FadeOut::create(2.0f);
auto spawn = Spawn::create(rotate, fadeout, nullptr);
auto fadein = FadeIn::create(2.0f);
auto action = Sequence::create(move, spawn, fadein, nullptr);
sprite-&gt;runAction(action);</pre></div><div><img src="img/B00561_02_12.jpg" alt="There's more..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Calling functions with actions</h1></div></div></div><p>You may want to call <a id="id110" class="indexterm"/>a function by triggering some actions. For example, you <a id="id111" class="indexterm"/>are controlling the sequence action, jump, and move, and you want to use a sound for the jumping action. In this case, you can call a function by triggering this jump action. In this recipe, you will learn how to call a function with actions.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How to do it...</h2></div></div></div><p>Cocos2d-x has the <code class="literal">CallFunc</code> object that allows you to create a function and pass it to be run in your <code class="literal">Sequence</code>. This allows you to add your own functionality to your <code class="literal">Sequence</code> action.</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0));
auto rotate = RotateBy::create(2.0f, 360.0f);
auto func = CallFunc::create([](){
    CCLOG("finished actions");
});
auto action = Sequence::create(move, rotate, func, nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding command will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds</li><li class="listitem" style="list-style-type: disc">Rotate a sprite clockwise by 360 degrees over two seconds</li><li class="listitem" style="list-style-type: disc">Execute CCLOG</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How it works...</h2></div></div></div><p>The <code class="literal">CallFunc</code> action is usually used as a callback function. For example, if you want to perform a different process after finishing the <code class="literal">move</code> action. Using <code class="literal">CallFunc</code>, you can call the method at any time. You can use a lambda expression as a callback function.</p><p>If you get a callback with parameters, its code is the following:</p><div><pre class="programlisting">auto func = CallFuncN::create([](Ref* sender){
    CCLOG("callback");
    Sprite* sprite = dynamic_cast&lt;Sprite*&gt;(sender);
});</pre></div><p>The instance of this parameter is the sprite that is running the action. You can get the sprite instance by casting to <code class="literal">Sprite</code> class.</p><p>Then, you can also specify a callback method. <code class="literal">CallFunc</code> has <code class="literal">CC_CALLBACK_0</code> macro as an argument. <code class="literal">CC_CALLBACK_0</code> is a macro for calling a method without parameters. If you want to call a method with one parameter, you need to use the <code class="literal">CallFuncN</code> action and <code class="literal">CC_CALLBACK_1</code> macro. <code class="literal">CC_CALLBACK_1</code> is a macro for calling a method with one argument. A parameter of a method that is called by <code class="literal">CallFuncN</code> is the <code class="literal">Ref</code> class.</p><p>You can call a method using the following code:</p><div><pre class="programlisting">bool HelloWorld::init() {
    …
    auto func = 
CallFunc::create(CC_CALLBACK_0(HelloWorld::finishedAction, this));
    …
}

void HelloWorld::finishedAction()
{
    CCLOG("finished action");
}</pre></div><p>To call a method with an <a id="id112" class="indexterm"/>argument, you<a id="id113" class="indexterm"/> can use the following code:</p><div><pre class="programlisting">bool HelloWorld::init() {
    …
    auto func = CallFuncN::create(CC_CALLBACK_1(HelloWorld::callback, this));
    …
}

void HelloWorld::callback(Ref* sender)
{
    CCLOG("callback");
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec58"/>There's more...</h2></div></div></div><p>To combine the <code class="literal">CallFuncN</code> and the <code class="literal">Reverse</code> action, use the following code:</p><div><pre class="programlisting">auto move = MoveBy::create(2.0f, Vec2(100, 0)); 
auto rotate = RotateBy::create(2.0f, 360.0f); 
auto func = CallFuncN::create([=](Ref* sender){
    Sprite* sprite = dynamic_cast&lt;Sprite*&gt;(sender);
    sprite-&gt;runAction(move-&gt;reverse());
});
auto action = Sequence::create(move, rotate, func, nullptr);
sprite-&gt;runAction(action);</pre></div><p>The preceding command will execute the following actions sequentially:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the right over two seconds</li><li class="listitem" style="list-style-type: disc">Rotate a sprite clockwise by 360 degree over two seconds</li><li class="listitem" style="list-style-type: disc">Move a sprite 100px to the left over two seconds</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Easing actions</h1></div></div></div><p>
<strong>Easing</strong> is<a id="id114" class="indexterm"/> animating with a <a id="id115" class="indexterm"/>specified acceleration to make the animations smooth. Ease actions are a good way to fake physics in your game. If you use easing actions with your animations, your game looks more natural with smoother animations.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How to do it...</h2></div></div></div><p>Let's move a <code class="literal">Sprite</code> object from <code class="literal">(200,200)</code> to <code class="literal">(500,200)</code> with acceleration and deceleration.</p><div><pre class="programlisting">auto sprite = Sprite::create("res/run_01.png");
sprite-&gt;setPosition(Vec2(200, 200));
this-&gt;addChild(sprite);

auto move = MoveTo::create(3.0f, Vec2(500, 200));
auto ease = EaseInOut::create(move, 2.0f);
sprite-&gt;runAction(ease);</pre></div><p>Next, let's drop a <code class="literal">Sprite</code> object from the top of the screen and make it bounce.</p><div><pre class="programlisting">auto sprite = Sprite::create("res/run_01.png");
sprite-&gt;setPosition(Vec2(size.width/2, size.height));
sprite-&gt;setAnchorPoint(Vec2(0.5f, 0.0f));
this-&gt;addChild(sprite);

auto drop = MoveTo::create(3.0f, Vec2(size.width/2, 0));
auto ease = EaseBounceOut::create(drop);
sprite-&gt;runAction(ease);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How it works...</h2></div></div></div><p>The animation's duration time is the same time regardless of whether you use easing. <code class="literal">EaseIn</code>, <code class="literal">EaseOut</code> and <code class="literal">EaseInOut</code> have two parameters—the first parameter is the action by easing, the second parameter is rate of easing. If you specified this parameter to <code class="literal">1.0f</code>, this easing action is the same without easing. Anything over <code class="literal">1.0f</code>, means easing is fast, under <code class="literal">1.0f</code>, and easing will be slow.</p><p>The following table are typical easing types.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Class Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves <a id="id116" class="indexterm"/>while accelerating.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseOut</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves<a id="id117" class="indexterm"/> while decelerating.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseInOut</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Start <a id="id118" class="indexterm"/>moving while accelerating, stop while decelerating.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseExponentialIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>It's similar to <code class="literal">EaseIn</code>, but meant to accelerate at a rate of exponential <a id="id119" class="indexterm"/>curve. It is also used with <code class="literal">Out</code> and <code class="literal">InOut</code> like <code class="literal">EaseIn</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseSineIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>It's similar<a id="id120" class="indexterm"/> to <code class="literal">EaseIn</code>, but meant to accelerate at a rate of sin curve. It is also used with <code class="literal">Out</code> and <code class="literal">InOut</code> like <code class="literal">EaseIn</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseElasticIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves <a id="id121" class="indexterm"/>after shaking slowly, little by little. It is also used with <code class="literal">Out</code> and <code class="literal">InOut</code> like <code class="literal">EaseIn</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseBounceIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves<a id="id122" class="indexterm"/> after bouncing. It is also used with <code class="literal">Out</code> and <code class="literal">InOut</code> like <code class="literal">EaseIn</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EaseBackIn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves <a id="id123" class="indexterm"/>after moving in the opposite direction. It is also used with <code class="literal">Out</code> and <code class="literal">InOut</code> like <code class="literal">EaseIn</code>
</p>
</td></tr></tbody></table></div><p>This is a graph that displays typical easing functions:</p><div><img src="img/B00561_02_13.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Using a texture atlas</h1></div></div></div><p>A <strong>texture atlas</strong> is a<a id="id124" class="indexterm"/> large image containing a collection of each sprite. We often use a texture atlas rather than individual images. In this recipe, you will learn how to use a texture atlas.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>You have to add the texture atlas files into your project and clean your project.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">running.plist</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">running.png</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it...</h2></div></div></div><p>Let's try to read the texture altas file and make a sprite from it.</p><div><pre class="programlisting">auto cache = SpriteFrameCache::getInstance();
cache-&gt;addSpriteFramesWithFile("res/running.plist");
auto sprite = Sprite::createWithSpriteFrameName("run_01.png");
sprite-&gt;setPosition(size/2);
this-&gt;addChild(sprite);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works...</h2></div></div></div><p>Firstly, we loaded the texture atlas file, when the <code class="literal">SpritFrameCache</code> class cached all the images that are included in it. Secondly, you generated a sprite. Do not use the <code class="literal">Sprite::create</code> method to generate it, use the <code class="literal">Sprite::createWithSpriteFrameName</code> method instead. Then, you can handle the sprite as a normal sprite.</p><p>A texture atlas is a large image containing a collection of images. It is composed of a <code class="literal">plist</code> file and a <code class="literal">texture</code> file. You can create a texture atlas by using tools. You will learn how to make a texture atlas using tools in <a class="link" href="ch10.html" title="Chapter 10. Improving Games with Extra Features">Chapter 10</a>, <em>Improving Games with Extra Features</em>. A <code class="literal">plist</code> file is defined as the original file name of the image and it is located within the <code class="literal">texture</code> file. It also defines the image that will be used by the texture atlas. The <code class="literal">plist</code> file for the texture atlas is xml format as follows.</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;frames&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;run_01.png&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;frame&lt;/key&gt;
                &lt;string&gt;{{2,2},{356,474}}&lt;/string&gt;
                &lt;key&gt;offset&lt;/key&gt;
                &lt;string&gt;{-62,-26}&lt;/string&gt;
                &lt;key&gt;rotated&lt;/key&gt;
                &lt;false/&gt;
                &lt;key&gt;sourceColorRect&lt;/key&gt;
                &lt;string&gt;{{60,89},{356,474}}&lt;/string&gt;
                &lt;key&gt;sourceSize&lt;/key&gt;
                &lt;string&gt;{600,600}&lt;/string&gt;
            &lt;/dict&gt;
            &lt;key&gt;run_02.png&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;frame&lt;/key&gt;
                &lt;string&gt;{{360,2},{272,466}}&lt;/string&gt;
                &lt;key&gt;offset&lt;/key&gt;
                &lt;string&gt;{-30,-33}&lt;/string&gt;
                &lt;key&gt;rotated&lt;/key&gt;
                &lt;false/&gt;
                &lt;key&gt;sourceColorRect&lt;/key&gt;
                &lt;string&gt;{{134,100},{272,466}}&lt;/string&gt;
                &lt;key&gt;sourceSize&lt;/key&gt;
                &lt;string&gt;{600,600}&lt;/string&gt;
            &lt;/dict&gt;

      omit

        &lt;/dict&gt;
        &lt;key&gt;metadata&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;format&lt;/key&gt;
            &lt;integer&gt;2&lt;/integer&gt;
            &lt;key&gt;realTextureFileName&lt;/key&gt;
            &lt;string&gt;running.png&lt;/string&gt;
            &lt;key&gt;size&lt;/key&gt;
            &lt;string&gt;{2048,1024}&lt;/string&gt;
            &lt;key&gt;smartupdate&lt;/key&gt;
            &lt;string&gt;$TexturePacker:SmartUpdate :e4468ff02abe538ce50e3e1448059f78:1/1$&lt;/string&gt;
            &lt;key&gt;textureFileName&lt;/key&gt;
            &lt;string&gt;running.png&lt;/string&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/plist&gt;</pre></div><div><img src="img/B00561_02_14.jpg" alt="How it works..."/></div><p>Why would we use the texture atlas? Because using the memory efficiently is good. Double the memory size is required when the computer <a id="id125" class="indexterm"/>loads the image into the memory. For example, there are ten images that are 100x100 size. We will use nine images, but one image requires memories for 128x128 size. On the other hand, texture atlas is one image containing a collection of nine images, where the image size is 1000x1000. It requires a memory size of 1024x1024. This is why texture atlas is used to save wasting unnecessary memory usage.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec64"/>There's more...</h2></div></div></div><p>The size of the texture altas can vary in usage depending on the devices. You can check the maximum texture size of the device in the following codes:</p><div><pre class="programlisting">
<strong>int max;</strong>
<strong>glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;max);</strong>
<strong>CCLOG("texture size = %d", max);</strong>
</pre></div><p>You can generate an animation using a texture atlas and a <code class="literal">plist</code> file. Firstly, you have to add <code class="literal">run_animation.plist</code> file into your project. The file is shown in the following screenshot:</p><div><img src="img/B00561_02_15.jpg" alt="There's more..."/></div><p>This <code class="literal">plist</code> defines a frame animation. In this case, we defined an animation called <code class="literal">run</code> using images from <code class="literal">run_01.png</code> to <code class="literal">run_08.png</code>. And the animation will loop forever if you specify <code class="literal">-1</code> to <code class="literal">loop</code> key's value. The texture atlas was specified <code class="literal">running.plist</code>.</p><p>Secondly, you need to generate an animation using the <code class="literal">plist</code> file.</p><div><pre class="programlisting">
<strong>auto cache = AnimationCache::getInstance(); cache-&gt;addAnimationsWithFile("res/run_animation.plist"); auto animation = cache-&gt;getAnimation("run"); auto action = Animate::create(animation); sprite-&gt;runAction(action);</strong>
</pre></div><p>You also need to cache<a id="id126" class="indexterm"/> animation data using the <code class="literal">AnimationCache::addAnimationWithFile</code> method with the animation <code class="literal">plist</code>. Next, you will generate an <code class="literal">Animation</code> instance by specifying <code class="literal">run</code> that was defined as an animation name in the <code class="literal">plist</code>. And then, you generate an action from the animation. After that, you can animate using <code class="literal">runAction</code> method with the action instance.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec65"/>See also</h2></div></div></div><p>It is very difficult to create a texture atlas manually. You had better use a tool such as the <code class="literal">TexturePacker</code>, which you will learn about in <a class="link" href="ch11.html" title="Chapter 11. Taking Advantages">Chapter 11</a>, <em>Taking Advantages</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Using a batch node</h1></div></div></div><p>Renderer speed will <a id="id127" class="indexterm"/>be slow if there are a lot of sprites on the screen. However, a shooting game needs a lot of images such as bullets, and so on. In this time, if renderer speed is slow, the game earns a bad review. In this chapter, you will learn how to control a lot of sprites.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How to do it...</h2></div></div></div><p>Let's try to display a lot of sprites using <code class="literal">SpriteBatchNode</code>.</p><div><pre class="programlisting">
<strong>auto batchNode = SpriteBatchNode::create("res/run_01.png");</strong>
<strong>this-&gt;addChild(batchNode);</strong>
<strong>for (int i=0; i&lt;300; i++) {</strong>
<strong>    auto sprite = Sprite::createWithTexture(batchNode-&gt;getTexture());</strong>
<strong>    float x = CCRANDOM_0_1() * size.width;</strong>
<strong>    float y = CCRANDOM_0_1() * size.height;</strong>
<strong>    sprite-&gt;setPosition(Vec2(x,y));</strong>
<strong>    batchNode-&gt;addChild(sprite);</strong>
<strong>}</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How it works...</h2></div></div></div><p>The <code class="literal">SpriteBatchNode</code> instance can be used to do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generate a <code class="literal">SpriteBatchNode</code> instance using a texture</li><li class="listitem" style="list-style-type: disc">Add the instance on the layer</li><li class="listitem" style="list-style-type: disc">Generate sprites using the texture in the <code class="literal">SpriteBatchNode</code> instance</li><li class="listitem" style="list-style-type: disc">Add these sprites on the <code class="literal">SpriteBatchNode</code> instance</li></ul></div><p>
<code class="literal">SpriteBatchNode</code> can reference only one texture (one image file or one texture atlas). Only the sprites<a id="id128" class="indexterm"/> that are contained in that texture can be added to the <code class="literal">SpriteBatchNode</code>. All sprites added to a <code class="literal">SpriteBatchNode</code> are drawn in one OpenGL ES draw call. If the sprites are not added to a <code class="literal">SpriteBatchNode</code> then an OpenGL ES draw call will be needed for each one, which is less efficient.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec68"/>There's more...</h2></div></div></div><p>The following screenshot is an executing screen image. You can see three lines of information for Cocos2d-x on the left bottom corner. The top line is the number of polygon vertices. The middle line is the number of OpenGL ES draw call. You understand that a lot of sprites are drawn by one OpenGL ES draw call. The bottom line is FPS and seconds per frame.</p><div><img src="img/B00561_02_16.jpg" alt="There's more..."/></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If you want to hide this debug information, you should set a <code class="literal">false</code> value to the <code class="literal">Director::setDisplayStats</code> method. You will find it in the <code class="literal">AppDelegate.cpp</code> in your project.</p><div><pre class="programlisting">director-&gt;setDisplayStats(false);</pre></div></div></div><p>Since <a id="id129" class="indexterm"/>Cocos2d-x version 3, the <code class="literal">auto batch</code> function of draw calls has been added, Cocos2d-x can draw a lot of sprites with one OpenGL ES draw call, without <code class="literal">SpriteBatchNode</code>. However, it has the following conditions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Same texture</li><li class="listitem" style="list-style-type: disc">Same <code class="literal">BlendFunc</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Using 3D modals</h1></div></div></div><p>Cocos2d-x version 3 supports an<a id="id130" class="indexterm"/> exciting new function called <strong>3D modals</strong>. We can use and display 3D modals in Cocos2d-x. In this recipe, you will learn how to use 3D modals.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec69"/>Getting ready</h2></div></div></div><p>You have to add the 3D object data into your project and clean your project. The resource files present in the <code class="literal">COCOS_ROOT/test/cpp-tests/Resources/Sprite3DTest</code> folder are—<code class="literal">body.png</code> and <code class="literal">girl.c3b</code>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How to do it...</h2></div></div></div><p>Let's try to display<a id="id131" class="indexterm"/> a 3D model and move it.</p><div><pre class="programlisting">
<strong>auto size = Director::getInstance()-&gt;getWinSize();</strong>

<strong>// create 3D modal</strong>
<strong>auto sprite3d = Sprite3D::create("res/girl.c3b");</strong>
<strong>sprite3d-&gt;setPosition(Vec2(size.width/2, 100));</strong>
<strong>this-&gt;addChild(sprite3d);</strong>

<strong>// action 3D modal</strong>
<strong>auto animation3d = Animation3D::create("res/girl.c3b");</strong>
<strong>auto animate3d = Animate3D::create(animation3d);</strong>
<strong>auto repeat = RepeatForever::create(animate3d);</strong>
<strong>sprite3d-&gt;runAction(repeat);</strong>
</pre></div><div><img src="img/B00561_02_17.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How it works...</h2></div></div></div><p>You can create the <a id="id132" class="indexterm"/>3D sprite from a 3D model in the same way as we made a 2D sprite and displayed it. The <code class="literal">Placement</code> method and the <code class="literal">action</code> method is exactly the same as seen in a 2D sprite. You can create the <code class="literal">Animation3D</code> instance from the animation data that is defined in the 3D model.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec72"/>There's more...</h2></div></div></div><p>Finally you will try to move the 3D sprite to the left or right. You will notice that 3D sprites differ in appearance depending on their position on the screen when you run the following code:</p><div><pre class="programlisting">
<strong>Sprite3d-&gt;setPositionX(size.width);</strong>
<strong>// move fro right to left</strong>
<strong>auto move1 = MoveBy::create(5.0f, Vec2(-size.width, 0));</strong>
<strong>auto move2 = MoveBy::create(5.0f, Vec2(size.width, 0));</strong>
<strong>auto seq = Sequence::create(move1, move2, NULL);</strong>
<strong>auto loop = RepeatForever::create(seq);</strong>
<strong>sprite3d-&gt;runAction(loop);</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec73"/>See also</h2></div></div></div><p>You can use 3D data formats such as obj, c3b, and c3t. “c3t” stands for Cocos 3d binary. You can get this formatted data by converting <code class="literal">fbx</code> files.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Detecting collisions</h1></div></div></div><p>In an action game, a very important technique is to detect collisions between each sprite. However, it is pretty complicated to detect collisions between <code class="literal">rect</code> and <code class="literal">rect</code> or <code class="literal">rect</code> and <code class="literal">point</code>. In this recipe, you will learn how to detect collisions easily.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How to do it...</h2></div></div></div><p>There are two ways to detect collisions. The first method checks whether a point is contained within the rectangle of the sprite.</p><div><pre class="programlisting">
<strong>Rect rect = sprite-&gt;getBoundingBox();</strong>
<strong>if (rect.containsPoint(Vec2())) {</strong>
<strong>    CCLOG("the point bumped rectangle");</strong>
<strong>}</strong>
</pre></div><p>The second method checks whether two sprite's rectangles have overlapped.</p><div><pre class="programlisting">
<strong>if (rect.intersectsRect(Rect(0, 0, 100, 100))) {</strong>
<strong>    CCLOG("two rectangles bumped");}</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec75"/>How it works...</h2></div></div></div><p>The <code class="literal">Rect</code> class has two properties—<code class="literal">size</code> and <code class="literal">origin</code>. The <code class="literal">size</code> property is the sprite's size. The origin property is<a id="id133" class="indexterm"/> the sprite's left-bottom coordinate. Firstly, you get the sprite's <code class="literal">rect</code> using the <code class="literal">getBoundingBox</code> method.</p><div><img src="img/B00561_02_18.jpg" alt="How it works..."/></div><p>Using the <code class="literal">Rect::containsPoint</code> method by specifying the coordinate, it is possible to detect whether it contains the rectangle. If it contains it, the method returns <code class="literal">true</code>. Using <code class="literal">Rect::intersectsRect</code> method by specifying another rectangle, it is possible to detect whether they overlap. If they overlap, the method returns <code class="literal">true</code>.</p><p>The following image shows a collision between <code class="literal">rect</code> and <code class="literal">point</code> or <code class="literal">rect</code> and <code class="literal">rect</code>:</p><div><img src="img/B00561_02_19.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec76"/>There's more...</h2></div></div></div><p>The <code class="literal">Rect</code> class has more <a id="id134" class="indexterm"/>methods including <code class="literal">getMinX</code>, <code class="literal">getMidX</code>, <code class="literal">getMaxX</code>, <code class="literal">getMinY</code>, <code class="literal">getMidY</code>, <code class="literal">getMaxY</code> and <code class="literal">unionWithRect</code>. You can obtain the value in the following figure using each of these methods.</p><div><img src="img/B00561_02_20.jpg" alt="There's more..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec77"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you used the physics engine, you can detect collision in a different way. Take a look at <a class="link" href="ch09.html" title="Chapter 9. Controlling Physics">Chapter 9</a>, <em>Controlling Physics</em>.</li><li class="listitem" style="list-style-type: disc">If you want to detect collision with consideration of the transparent parts of an image, take a look at <a class="link" href="ch11.html" title="Chapter 11. Taking Advantages">Chapter 11</a>, <em>Taking Advantages</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Drawing a shape</h1></div></div></div><p>Drawing a shape in <a id="id135" class="indexterm"/>Cocos2d-x can be easy using the <code class="literal">DrawNode</code> class. If you can draw various shapes using <code class="literal">DrawNode</code>, you will to need to prepare textures for such shapes. In this section, you will learn how to draw shapes without textures.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec78"/>How to do it...</h2></div></div></div><p>Firstly, you made a <code class="literal">DrawNode</code> instance as shown in the following codes. You got a window size as well.</p><div><pre class="programlisting">
<strong>auto size = Director::getInstance()-&gt;getWinSize();</strong>
<strong>auto draw = DrawNode::create();</strong>
<strong>this-&gt;addChild(draw);</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Drawing a dot</h3></div></div></div><p>You can draw a dot by specifying <a id="id136" class="indexterm"/>the point, the radius and the color.</p><div><pre class="programlisting">
<strong>draw-&gt;drawDot(Vec2(size/2), 10.0f, Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_21.jpg" alt="Drawing a dot"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Drawing lines</h3></div></div></div><p>You can draw lines by specifying<a id="id137" class="indexterm"/> the starting point, the destination point, and the color. A <code class="literal">1px</code> thick line will be drawn when you use the <code class="literal">drawLine</code> method. If you want to draw thicker lines, use the <code class="literal">drawSegment</code> method with a given radius.</p><div><pre class="programlisting">
<strong>draw-&gt;drawLine(Vec2(300, 200), Vec2(600, 200), Color4F::WHITE);</strong>
<strong>draw-&gt;drawSegment(Vec2(300, 100), Vec2(600, 100), 10.0f,</strong>
<strong>Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_22.jpg" alt="Drawing lines"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec24"/>Drawing circles</h3></div></div></div><p>You can draw<a id="id138" class="indexterm"/> circles as shown in the following codes. The specification of the arguments is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">center position</li><li class="listitem" style="list-style-type: disc">radius</li><li class="listitem" style="list-style-type: disc">angle</li><li class="listitem" style="list-style-type: disc">segments</li><li class="listitem" style="list-style-type: disc">draw a line to center or not</li><li class="listitem" style="list-style-type: disc">scale x axis</li><li class="listitem" style="list-style-type: disc">scale y axis</li><li class="listitem" style="list-style-type: disc">color</li></ul></div><div><pre class="programlisting">
<strong>draw-&gt;drawCircle(Vec2(300, size.height/2), 50.0f, 1.0f, 10, true,</strong>
<strong>1.0f, 1.0f, Color4F::WHITE);</strong>
<strong>draw-&gt;drawCircle(Vec2(450, size.height/2), 50.0f, 1.0f, 100, false,</strong>
<strong>1.0f, 1.0f, Color4F::WHITE);</strong>
<strong>draw-&gt;drawSolidCircle(Vec2(600, size.height/2), 50.0f, 1.0f, 100,</strong>
<strong>1.0f, 1.0f, Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_23.jpg" alt="Drawing circles"/></div><p>Segment is the number of vertices of the polygon. As you know, the circle is a polygon that has a lot of vertices. Increasing the number of vertices is close to a smooth circle, but the process load<a id="id139" class="indexterm"/> goes up. Incidentally, you should use <code class="literal">drawSolidCircle</code> method if you want to get a solid circle.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec25"/>Drawing a triangle</h3></div></div></div><p>You can draw a<a id="id140" class="indexterm"/> triangle as in the following code with three vertices and the color.</p><div><pre class="programlisting">
<strong>draw-&gt;drawTriangle(Vec2(380,100), Vec2(480, 200), Vec2(580, 100),</strong>
<strong>Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_24.jpg" alt="Drawing a triangle"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec26"/>Drawing rectangles</h3></div></div></div><p>You can draw<a id="id141" class="indexterm"/> rectangles using the following code with the left-bottom point, the right-top point, and the color. You can draw fill color if you use the <code class="literal">drawSolidRect</code> method.</p><div><pre class="programlisting">
<strong>draw-&gt;drawRect(Vec2(240, 100), Vec2(340,200), Color4F::WHITE);</strong>
<strong>draw-&gt;drawSolidRect(Vec2(480, 100), Vec2(580, 200), Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_25.jpg" alt="Drawing rectangles"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec27"/>Drawing a polygon</h3></div></div></div><p>You can draw a <a id="id142" class="indexterm"/>polygon using the following code with the given vertices, the number of vertices, filling color, border's width, and border's color.</p><div><pre class="programlisting">
<strong>std::vector&lt;Vec2&gt;verts;</strong>
<strong>verts.push_back(Vec2(380,100));</strong>
<strong>verts.push_back(Vec2(380,200));</strong>
<strong>verts.push_back(Vec2(480,250));</strong>
<strong>verts.push_back(Vec2(580,200));</strong>
<strong>verts.push_back(Vec2(580,100));</strong>
<strong>verts.push_back(Vec2(480,50));</strong>
<strong>draw-&gt;drawPolygon(&amp;verts[0], verts.size(), Color4F::RED, 5.0f,</strong>
<strong>Color4F::GREEN);</strong>
</pre></div><div><img src="img/B00561_02_26.jpg" alt="Drawing a polygon"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec28"/>Drawing a Bezier curve</h3></div></div></div><p>You can draw a<a id="id143" class="indexterm"/> Bezier curve as shown in the following code. Using <code class="literal">drawQuadBezier</code> method, you can draw a quadratic Bezier curve, and using <code class="literal">drawCubicBezier</code> method you can draw a cubic Bezier curve. The third argument of the <code class="literal">drawQuadBezier</code> method and the fourth argument of the <code class="literal">drawCubicBezier</code> method is the number of vertices in the same way as the circle.</p><div><pre class="programlisting">
<strong>draw-&gt;drawQuadBezier(Vec2(240, 200), Vec2(480, 320), Vec2(720, 200), 24, Color4F::WHITE); draw-&gt;drawCubicBezier(Vec2(240, 100), Vec2(240, 200), Vec2(720, 200), Vec2(720, 100), 24, Color4F::WHITE);</strong>
</pre></div><div><img src="img/B00561_02_27.jpg" alt="Drawing a Bezier curve"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How it works...</h2></div></div></div><p>
<code class="literal">DrawNode</code> is like <a id="id144" class="indexterm"/>a mechanism that enables Cocos2d-x to process at a high speed, by making drawing shapes all at once and not separately, or one by one. When you draw multiple shapes, you should use one <code class="literal">DrawNode</code> instance, instead of multiple <code class="literal">DrawNode</code> instances and then add multiple shapes in it. Also <code class="literal">DrawNode</code> does not have the concept of depth. Cocos2d-x will draw to the order of the added shapes in <code class="literal">DrawNode</code>.</p></div></div></body></html>