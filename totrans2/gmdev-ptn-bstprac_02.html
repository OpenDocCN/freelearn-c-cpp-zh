<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">One Instance to Rule Them All - Singletons</h1>
            

            
                
<p class="calibre2">Now that we've learned what a design pattern is, as well as why we'd want to use them, let's first talk about a design pattern that most people learn, the Singleton pattern.</p>
<p class="calibre2">The Singleton pattern is probably the most well-known pattern and it is also the one out there that is most often misused. It definitely has the most controversy surrounding it, so when discussing this pattern it is as important (or even more important) to know when not to apply it.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, we will explain about the pattern and many arguments for and against it. We will describe how and why core systems within the Mach5 engine such as the Graphics Engine and Object Manager are utilized as Singletons. Finally, we will explain a number of different ways to implement this in C++, along with the pros and cons of each choice.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objective</h1>
            

            
                
<p class="calibre2">This chapter will be split into a number of topics. It will contain a simple step-by-step process from beginning to end. Here is the outline of our tasks:</p>
<ul class="calibre17">
<li class="calibre18">An overview of class access specifiers</li>
<li class="calibre18">Pros and cons of global access</li>
<li class="calibre18">Understanding the <kbd class="calibre14">static</kbd> keyword</li>
<li class="calibre18">What is a Singleton?</li>
<li class="calibre18">Learning about templates</li>
<li class="calibre18">Templatizing Singletons</li>
<li class="calibre18">The advantages and disadvantages of only one instance</li>
<li class="calibre18">The Singleton in action: the <kbd class="calibre14">Application</kbd> class</li>
<li class="calibre18">Design decisions</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">An overview on class access specifiers</h1>
            

            
                
<p class="calibre2">When using an object-oriented programming language, one of the most important features included is the ability to hide data, preventing classes from accessing properties and functions of another class type by default. By using access specifiers such as <kbd class="calibre14">public</kbd>, <kbd class="calibre14">private</kbd>, and <kbd class="calibre14">protected</kbd>, we can dictate specifically how the data and/or functions can be accessed from other classes:</p>
<pre class="calibre23">
class ModifierExamples <br class="title-page-name"/>{ <br class="title-page-name"/>  public int publicInteger; <br class="title-page-name"/>  private void PrivateMethod() {} <br class="title-page-name"/>  protected float protectedNumber; <br class="title-page-name"/>};
</pre>
<p class="calibre2">A class can have unlimited variables or functions that are <kbd class="calibre14">public</kbd>, <kbd class="calibre14">private</kbd>, or <kbd class="calibre14">protected</kbd> and can even control access to entire sections of the class:</p>
<pre class="calibre23">
class MoreModifierExamples <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    // until we reach another tag, all variables and functions  <br class="title-page-name"/>    // will be public <br class="title-page-name"/>    int publicIntegar; <br class="title-page-name"/>    int anotherExample; <br class="title-page-name"/> <br class="title-page-name"/>  private: <br class="title-page-name"/>    // Now, they'll be private <br class="title-page-name"/>    void PrivateFunction() {} <br class="title-page-name"/>    double safeValue; <br class="title-page-name"/> <br class="title-page-name"/>  protected: <br class="title-page-name"/>    // And now... protected <br class="title-page-name"/>    float protectedNumber; <br class="title-page-name"/>    int AlsoProtected() { return 0; } <br class="title-page-name"/>};
</pre>
<p class="calibre2">When you place a labelled section with an access modifier's name and a <kbd class="calibre14">:</kbd> next to it, until there is another section label, all of the parts of the class that are listed will use that specific one.</p>
<p class="calibre2">When we use the <kbd class="calibre14">public</kbd> access modifier, we are saying that this variable or function can be used or accessed from anywhere within our program, even outside of the class we've created. Declaring a variable outside of a function or class, or marking a variable as <kbd class="calibre14">public</kbd> and <kbd class="calibre14">static</kbd>, is often referred to as being a global variable. We will be talking about global variables in the next section, but for right now, let's go over the other access specifiers as well.</p>
<p class="calibre2">When <kbd class="calibre14">private</kbd> is used, we are restricting the usage of our variable or function to being allowed only inside of the class, or from <kbd class="calibre14">friend</kbd> functions. By default, all of the variables and functions in a class are <kbd class="calibre14">private</kbd>.</p>
<p>For more information on friend functions, check out <a href="http://en.cppreference.com/w/cpp/language/friend" target="_blank" class="calibre24">http://en.cppreference.com/w/cpp/language/friend</a>.</p>
<p class="calibre2">The third type, <kbd class="calibre14">protected</kbd>, is the same as a <kbd class="calibre14">private</kbd> type except that it can still be accessed by child (or derived) classes. This can be quite useful when using inheritance so you can still access those variables and/or functions.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The static keyword</h1>
            

            
                
<p class="calibre2">Another thing that is important to know before diving into the Singleton pattern is what the <kbd class="calibre14">static</kbd> keyword means, as it's something that we will be using the functionality of when building this pattern. When we use the <kbd class="calibre14">static</kbd> keyword, there are three main contexts that it'll be used in:</p>
<ul class="calibre17">
<li class="calibre18">Inside a function</li>
<li class="calibre18">Inside a class definition</li>
<li class="calibre18">In front of a global variable in a program with multiple files</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Static keyword inside a function</h1>
            

            
                
<p class="calibre2">The first one, being used inside of a function, basically means that once the variable has been initialized, it will stay in the computer's memory until the end of the program, keeping the value that it has through multiple runs of the function. A simple example would be something like this:</p>
<pre class="calibre23">
#include &lt;string&gt; <br class="title-page-name"/> <br class="title-page-name"/>class StaticExamples <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  void InFunction() <br class="title-page-name"/>  { <br class="title-page-name"/>    static int enemyCount = 0; <br class="title-page-name"/> <br class="title-page-name"/>    // Increase the value of enemyCount <br class="title-page-name"/>    enemyCount += 10; <br class="title-page-name"/> <br class="title-page-name"/>    std::string toDisplay = "\n Value of enemyCount:  " +  <br class="title-page-name"/>                std::to_string(enemyCount); <br class="title-page-name"/> <br class="title-page-name"/>    printf(toDisplay.c_str()); <br class="title-page-name"/>  } <br class="title-page-name"/>};
</pre>
<p class="calibre2">Now if we were to call this, it would look something like the following:</p>
<pre class="calibre23">
  StaticExamples se; <br class="title-page-name"/> <br class="title-page-name"/>  se.InFunction(); <br class="title-page-name"/>  se.InFunction();
</pre>
<p class="calibre2">And when we call it, the following would be displayed:</p>
<div><img class="image-border8" src="img/00019.jpeg"/></div>
<p class="calibre2">As you can see, the value continues to exist, and we can access and/or modify its contents as we see fit in the function. This could be used for a number of things, such as maybe needing to know what happened the last time that you called this function, or to store any kind of data between any calls. It's also worth noting that static variables are shared by all instances of the class, and due to that, if we had two variables of type <kbd class="calibre14">StaticExamples</kbd>, they would both display the same <kbd class="calibre14">enemyCount</kbd>. We will utilize the fact that, if an object is created this way, it will always be available later on in this chapter.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Static keyword in class definitions</h1>
            

            
                
<p class="calibre2">The second way is by having a variable or function in a class being defined as <kbd class="calibre14">static</kbd>. Normally, when you create an instance of a class, the compiler has to set aside additional memory for each variable that is contained inside of the class in consecutive blocks of memory. When we declare something as <kbd class="calibre14">static</kbd>, instead of creating a new variable to hold data, a single variable is shared by all of the instances of the class. In addition, since it's shared by all of the copies, you don't need to have an instance of the class to call it. Take a look at the following bolded code to create our variable:</p>
<pre class="calibre23">
class StaticExamples <br class="title-page-name"/> <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/><strong class="calibre1">  static float classVariable;<br class="title-page-name"/></strong><strong class="calibre1">  static void StaticFunction()</strong> <br class="title-page-name"/>  { <br class="title-page-name"/>    // Note, can only use static variables and functions within <br class="title-page-name"/>    // static function <br class="title-page-name"/><strong class="calibre1">    std::string toDisplay = "\n I can be called anywhere!<br class="title-page-name"/></strong><strong class="calibre1">    classVariable value: " + std::to_string(classVariable);</strong> <br class="title-page-name"/> <br class="title-page-name"/>    printf(toDisplay.c_str()); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  void InFunction() <br class="title-page-name"/>  { <br class="title-page-name"/>    static int enemyCount = 0; <br class="title-page-name"/> <br class="title-page-name"/>    // Increase the value of enemyCount <br class="title-page-name"/>    enemyCount += 10; <br class="title-page-name"/> <br class="title-page-name"/>    std::string toDisplay = "\n Value of enemyCount:  " +  <br class="title-page-name"/>                std::to_string(enemyCount); <br class="title-page-name"/> <br class="title-page-name"/>    printf(toDisplay.c_str()); <br class="title-page-name"/>  } <br class="title-page-name"/>};
</pre>
<p class="calibre2">Now, in the preceding code we define a variable and a function, but this isn't all the prep work we need to do. When creating a static variable, you cannot initialize it from within the class, and instead need to do it in a <kbd class="calibre14">.cpp</kbd> file instead of the <kbd class="calibre14">.h</kbd> file we could use for the class definition. You'll get errors if you do not initialize it, so it's a good idea to do that. In our case, it'd look like the following:</p>
<pre class="calibre23">
// StaticExamples.cpp <br class="title-page-name"/>float StaticExamples::classVariable = 2.5f;
</pre>
<p class="calibre2">Note that, when we initialize, we also need to include the type, but we use the <kbd class="calibre14">ClassName::variableName</kbd> template similar to how you define functions in <kbd class="calibre14">.cpp</kbd> files. Now that everything's set up, let's see how we can access them inside our normal code:</p>
<pre class="calibre23">
StaticExamples::StaticFunction(); <br class="title-page-name"/>StaticExamples::classVariable = 5; <br class="title-page-name"/>StaticExamples::StaticFunction();
</pre>
<p class="calibre2">Note that instead of accessing it via creating a variable, we can instead just use the class name followed by the scope operator (<kbd class="calibre14">::</kbd>) and then select which static variable or function we'd like to use. When we run it, it'll look like this:</p>
<div><img class="image-border9" src="img/00020.jpeg"/></div>
<p class="calibre2">As you can see, it works perfectly!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Static as a file global variable</h1>
            

            
                
<p class="calibre2">As you may be aware, C++ is a programming language closely related to the C programming language. C++ was designed to have most of the same functionality that C had and then added more things to it. C was not object-oriented, and so, when it created the <kbd class="calibre14">static</kbd> keyword, it was used to indicate that source code in other files that are part of your project cannot access the variable, and that only code inside of your file can use it. This was designed to create class-like behavior in C. Since we have classes in C++ we don't typically use it, but I felt I should mention it for completeness.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Pros and cons of global variables</h1>
            

            
                
<p class="calibre2">To reiterate, a global variable is a variable that is declared outside of a function or class. Doing this makes our variable accessible in every function, hence us calling it global. When being taught programming in school, we were often told that global variables are a bad thing or at least, that modifying global variables in a function is considered to be poor programming practice.</p>
<p class="calibre2">There are numerous reasons why using global variables is a bad idea:</p>
<ul class="calibre17">
<li class="calibre18">Source code is the easiest to understand when the scope of the elements used is limited. Adding in global variables that can be read or modified anywhere in the program makes it much harder to keep track of where things are being done, as well as making it harder to comprehend when bringing on new developers.</li>
<li class="calibre18">Since a global variable can be modified anywhere, we lose any control over being able to confirm that the data contained in the variable is valid. For instance, you may only want to support up to a certain number, but as a global variable this is impossible to stop. Generally, we advise using <kbd class="calibre14">getter</kbd>/<kbd class="calibre14">setter</kbd> functions instead for this reason.</li>
<li class="calibre18">Using global variables tightens how coupled our programs are, making it difficult to reuse aspects of our projects as we need to grab from a lot of different places to make things work. Grouping things that are connected to each other tends to improve projects.</li>
<li class="calibre18">When working with the linker, if your global variable names are common, you'll often have issues when compiling your project. Thankfully, you'll get an error and have to fix the issue in this case. Unfortunately, you may also have an issue where you are trying to use a locally scoped variable in a project but  end up selecting the global version due to mistyping the name or relying too heavily on intelligence and selecting the first thing you see, which I see students doing on multiple occasions.</li>
<li class="calibre18">As the size of projects grow, it becomes much harder to do maintenance and/or make changes to/on global variables, as you may need to modify many parts of your code to have it adjust correctly.</li>
</ul>
<p class="calibre2">This isn't to say that global access is entirely bad. There are some reasons why one would consider using it in their projects:</p>
<ul class="calibre17">
<li class="calibre18">Not knowing what a local variable is</li>
<li class="calibre18">Not understanding how to create classes</li>
<li class="calibre18">Wanting to save keystrokes</li>
<li class="calibre18">Not wanting to pass around variables all the time to functions</li>
<li class="calibre18">Not knowing where to declare a variable, so making it global means anyone can get it</li>
<li class="calibre18">To simplify our project for components that need to be accessible anywhere within the project</li>
</ul>
<p class="calibre2">Aside from the last point, those issues are really bad reasons for wanting to use global variables, as they may save you some time up front, but as your projects get larger and larger it'll be a lot more difficult to read your code. In addition, once you make something global it's going to be a lot more difficult to convert it to not be global down the road. Think that, instead of using global variables, you could instead pass parameters to different functions as needed, making it easier to understand what each function does and what it needs to work with to facilitate its functionality.</p>
<p class="calibre2">That's not to say that there isn't any time when using a global variable is a reasonable or even a good idea. When global variables represent components that truly need to be available throughout your project, the use of global variables simplifies the code of your project, which is similar to what we are aiming to accomplish.</p>
<div><em class="calibre25">Norm Matloff</em> also has an article explaining times that he feels like global variables are necessary when writing code. If you want to hear an alternative take, check out <a href="http://heather.cs.ucdavis.edu/~matloff/globals.html" target="_blank" class="calibre24">http://heather.cs.ucdavis.edu/~matloff/globals.html</a>.</div>
<p class="calibre2">Basically, always limit your variables to the minimal scope needed for the project and not any more. This especially comes to mind when you only ever need one of something, but plan to use that one object with many different things. That's the general idea of the Singleton design pattern and is the reason why it's important that we understand the general usage before moving onwards.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">What is a Singleton?</h1>
            

            
                
<p class="calibre2">The Singleton pattern in a nutshell is where you have a class that you can access anywhere within your project, due to the fact that only one object (instance) of that class is created (instantiated). The pattern provides a way for programmers to give access to a class's information globally by creating a single instance of an object in your game.</p>
<p class="calibre2">Whereas there are quite a few issues with using global variables, you can think of a Singleton as an <em class="calibre12">improved</em> global variable due to the fact that you cannot create more than one. With this in mind, the Singleton pattern is an attractive choice for classes that only have a unique instance in your game project, such as your graphics pipeline and input libraries, as having more than one of these in your projects doesn't make sense.</p>
<p class="calibre2">This single object uses a static variable and static functions to be able to access the object without having to pass it through all of our code.</p>
<p class="calibre2">In the Mach5 engine, Singletons are used for the application's, input, graphics, and physics engines. They are also used for the resource manager, object manager, and the game state manager. We will be taking a much closer look at one of the more foundational ones in the engine, the <kbd class="calibre14">Application</kbd> class, later on in this chapter. But before we get to it, let's dive into how we can actually create one of our very own.</p>
<p class="calibre2">There are multiple ways to implement the Singleton pattern or to get Singleton-like behavior. We'll go over some of the commonly seen versions and their pros and cons before moving to our final version, which is how the Mach5 engine uses it.</p>
<p class="calibre2">One very common way of implementing the functionality of the Singleton pattern would look something like the following:</p>
<div><img class="alignnone6" src="img/00021.gif"/></div>
<p class="calibre2">Through code, it will look a little something like this:</p>
<pre class="calibre23">
class Singleton <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    static Singleton * GetInstance() <br class="title-page-name"/>    { <br class="title-page-name"/>      // If the instance does not exist, create one <br class="title-page-name"/>      if (!instance) <br class="title-page-name"/>      { <br class="title-page-name"/>        instance = new Singleton; <br class="title-page-name"/>      } <br class="title-page-name"/>       <br class="title-page-name"/>      return instance; <br class="title-page-name"/>    } <br class="title-page-name"/> <br class="title-page-name"/>  private: <br class="title-page-name"/>    static Singleton * instance;  <br class="title-page-name"/>};
</pre>
<p class="calibre2">In this class, we have a function called <kbd class="calibre14">GetInstance</kbd> and a single property called <kbd class="calibre14">instance</kbd>. Note that we are using pointers in this instance, and only allocating memory to create our Singleton if we are actually using it. The instance property represents the one and only version of our class, hence it being made <kbd class="calibre14">static.</kbd> As it is private though, there is no way for others to access its data unless we give them access to it. In order to give this access, we created the <kbd class="calibre14">GetInstance</kbd> function. This function will first check whether instance exists and if it doesn't yet, it will dynamically allocate the memory to create one, set instance to it, and then return the object.</p>
<p>This will only work if instance is properly set to <kbd class="calibre26">0</kbd> or <kbd class="calibre26">nullptr</kbd> when initialized, which thankfully is the default behavior of static pointers in C++.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Keeping the single in Singleton</h1>
            

            
                
<p class="calibre2">As we've mentioned previously, one of the most important parts of the Singleton pattern is the fact that there is only one of those objects. That causes some issues with the original code that we've written, namely that with some simple usage of C++ it is quite easy to have more than one of these classes created by other programmers on your team. First and most obviously, they can just create a <kbd class="calibre14">Singleton</kbd> variable (a variable of type <kbd class="calibre14">Singleton</kbd>) like the following:</p>
<pre class="calibre23">
Singleton singleton;
</pre>
<p class="calibre2">In addition, as a higher-level programming language, C++ will try to do some things automatically for you when creating classes to eliminate some of the busy work that would be involved otherwise. One of these things is automatically creating some functionality between classes to enable you to create or copy objects of a custom class that we refer to as a constructor and copy constructor. In our case, you can also create a copy of your current object in the following way:</p>
<pre class="calibre23">
Singleton instanceCopy(*(Singleton::GetInstance()));
</pre>
<p class="calibre2">The compiler will also create a default destructor and an assignment operator, moving the data from one object to the other.</p>
<p class="calibre2">Thankfully, that's a simple enough thing to fix. If we create these functions ourselves (declaring an explicit version), C++ notes that we want to do something special, so it will not create the defaults. So to fix our problem, we will just need to add an assignment operator and some constructors that are private, which you can see in the bold code that we've changed:</p>
<pre class="calibre23">
class Singleton <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  static Singleton * GetInstance() <br class="title-page-name"/>  { <br class="title-page-name"/>    // If the instance does not exist, create one <br class="title-page-name"/>    if (!instance) <br class="title-page-name"/>    { <br class="title-page-name"/>      instance = new Singleton; <br class="title-page-name"/>    } <br class="title-page-name"/>       <br class="title-page-name"/>    return instance; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  static Singleton * instance;  <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  // Disable usability of silently generated functions<br class="title-page-name"/></strong><strong class="calibre1">  Singleton();<br class="title-page-name"/></strong><strong class="calibre1">  ~Singleton();<br class="title-page-name"/></strong><strong class="calibre1">  Singleton(const Singleton &amp;);<br class="title-page-name"/></strong><strong class="calibre1">  Singleton&amp; operator=(const Singleton&amp;);</strong> <br class="title-page-name"/>   <br class="title-page-name"/>};
</pre>
<p>If you are using C++ 11 or above, it is also possible for us to instead mark the functions we don't want to use as deleted, which would look like this:<br class="calibre27"/>
<kbd class="calibre26">Singleton() = delete;</kbd><br class="calibre27"/>
<kbd class="calibre26">~Singleton() = delete;</kbd><br class="calibre27"/>
<kbd class="calibre26">Singleton(const Singleton &amp;) = delete;</kbd><br class="calibre27"/>
<kbd class="calibre26">Singleton&amp; operator=(const Singleton&amp;) = delete;</kbd><br class="calibre27"/>
For more information on the delete keyword, check out <a href="http://www.stroustrup.com/C++11FAQ.html#default" target="_blank" class="calibre24">http://www.stroustrup.com/C++11FAQ.html#default</a>.</p>
<p class="calibre2">Another thing that may possibly be an issue is that instance is a pointer. This is because, as a pointer, our users have the ability to call delete on it and we want to make sure that the object will always be available for our users to access. To minimize this issue, we could change our pointer to be a reference, instead, by changing the function to the following (note the return type and that we use <kbd class="calibre14">*instance</kbd> now on the last line):</p>
<pre class="calibre23">
static Singleton&amp; GetInstance() <br class="title-page-name"/>{ <br class="title-page-name"/>  // If the instance does not exist, create one <br class="title-page-name"/>  if (!instance) <br class="title-page-name"/>  { <br class="title-page-name"/>    instance = new Singleton; <br class="title-page-name"/>  } <br class="title-page-name"/>       <br class="title-page-name"/>  return *instance; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Programmers are used to working with references as aliases for objects that exist somewhere else in our project. People would be surprised if they ever saw something like:</p>
<pre class="calibre23">
Singleton&amp; singleton = Singleton::GetInstance(); <br class="title-page-name"/>delete &amp;singleton;
</pre>
<p class="calibre2">While technically doable, programmers won't expect to ever use delete on the address of a reference. The nice thing about using references is that, when you need them in code, you know that they exist because they're managed somewhere else in the code--and you don't need to worry about how they are used.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Deleting our object correctly</h1>
            

            
                
<p class="calibre2">People also are used to looking for memory leaks with pointers and not references, so that perhaps leaves us with an issue as, in our current code, we allocate memory but don't actually delete it.</p>
<p class="calibre2">Now, technically, we haven't created a memory leak. Memory leaks appear when you allocate data and lose all of your references to it. Also, modern operating systems take care of deallocating a process's memory when our project is quit.</p>
<p class="calibre2">That's not to say that it's a good thing though. Depending on what information the Singleton class uses, we could have references to things that no longer exist at some point.</p>
<p class="calibre2">To have our object delete itself correctly, we need to destroy the Singleton when our game shuts down. The only issue is we need to make sure that we do it only when we are sure no one will be using the Singleton afterwards.</p>
<p class="calibre2">However, as we want to talk about best practices, it's much better for us to actually solve this issue by removing resource leaks whenever we see them. A solution to this very problem was created by <em class="calibre12">Scott Meyers</em> in his book <em class="calibre12">More Effective C++</em>, which uses some of the features of the compiler, namely that a static variable located in a function will exist throughout our program's running time. For instance, let's take the following function:</p>
<pre class="calibre23">
void SpawnEnemy() <br class="title-page-name"/>{ <br class="title-page-name"/>  static int numberOfEnemies = 0; <br class="title-page-name"/>  ++numberOfEnemies; <br class="title-page-name"/> <br class="title-page-name"/>  // Spawn the enemy <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">numberOfEnemies</kbd> variable is created and has been initialized before any code in the project has been executed, most likely when the game was being loaded. Then, once <kbd class="calibre14">SpawnEnemy</kbd> is called for the first time, it will have already been set to <kbd class="calibre14">0</kbd> (or <kbd class="calibre14">nullptr</kbd>). Conveniently, as the object is not allocated dynamically, the compiler will also create code so that, when the game exists, it will call the deconstructor for our object automatically.</p>
<p class="calibre2">With that in mind, we can modify our Singleton class to the following:</p>
<pre class="calibre23">
class Singleton <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>    static Singleton &amp; GetInstance() <br class="title-page-name"/>    { <br class="title-page-name"/>      static Singleton instance; <br class="title-page-name"/>      return instance; <br class="title-page-name"/>    } <br class="title-page-name"/> <br class="title-page-name"/>  private: <br class="title-page-name"/>    // Disable usability of silently generated functions <br class="title-page-name"/>    Singleton(); <br class="title-page-name"/>    ~Singleton(); <br class="title-page-name"/>    Singleton(const Singleton &amp;); <br class="title-page-name"/>    Singleton&amp; operator=(const Singleton&amp;); <br class="title-page-name"/>   <br class="title-page-name"/>};
</pre>
<p class="calibre2">Specifically note the changes we've made to the <kbd class="calibre14">GetInstance</kbd> function and the removal of our class instance variable. This method provides the simplest way to destroy the <kbd class="calibre14">Singleton</kbd> class automatically and it works fine for most purposes.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Learning about templates</h1>
            

            
                
<p class="calibre2">Another technique to add to your toolbox of programming concepts that we will use in the next section is the idea of templates. <strong class="calibre1">Templates</strong> are a way for you to be able to create generic classes that can be extended to have the same functionality for different datatypes. It's another form of abstraction, letting you define a base set of behavior for a class without knowing what type of data will be used on it. If you've used the STL before, you've already been using templates, perhaps without knowing it. That's why the list class can contain any kind of object.</p>
<p class="calibre2">Here's an example of a simple templated class:</p>
<pre class="calibre23">
#include &lt;iostream&gt; // std::cout <br class="title-page-name"/> <br class="title-page-name"/>template &lt;class T&gt; <br class="title-page-name"/>class TemplateExample <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  // Constructor <br class="title-page-name"/>  TemplateExample(); <br class="title-page-name"/>  // Destructor <br class="title-page-name"/>  ~TemplateExample(); <br class="title-page-name"/>  // Function <br class="title-page-name"/>  T TemplatedFunction(T); <br class="title-page-name"/>};
</pre>
<p class="calibre2">In this case, we created our <kbd class="calibre14">TemplateExample</kbd> class and it has three functions. The constructor and deconstructor look normal, but then I have this <kbd class="calibre14">TemplateFunction</kbd> function which takes in an object of type <kbd class="calibre14">T</kbd>, and returns an object of type <kbd class="calibre14">T</kbd>. This <kbd class="calibre14">T</kbd> comes from the first line of our example code with the template <kbd class="calibre14">&lt;class T&gt;</kbd> section of our code. Anywhere that there is a <kbd class="calibre14">T</kbd> it will be replaced with whatever class we want to use this template with.</p>
<p class="calibre2">Now, unlike regular functions, we have to define templated functions within our <kbd class="calibre14">.h</kbd> file, so that, when we need to create an object using this template, it will know what the functions will do. In addition to this, the syntax is also a bit different:</p>
<pre class="calibre23">
template &lt;class T&gt; TemplateExample&lt;T&gt;::TemplateExample() <br class="title-page-name"/>{ <br class="title-page-name"/>  printf("\nConstructor!"); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>template &lt;class T&gt; TemplateExample&lt;T&gt;::~TemplateExample() <br class="title-page-name"/>{ <br class="title-page-name"/>  printf("\nDeconstructor!"); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>template &lt;class T&gt; T TemplateExample&lt;T&gt;::TemplatedFunction(T obj) <br class="title-page-name"/>{ <br class="title-page-name"/>  std::cout &lt;&lt; "\nValue: " &lt;&lt; obj; <br class="title-page-name"/>  return obj; <br class="title-page-name"/>}
</pre>
<p class="calibre2">In this example, I'm just printing out text to display when a certain functionality is called, but I also want to point out the usage of <kbd class="calibre14">std::cout</kbd> and that using it will require you to add <kbd class="calibre14">#include &lt;iostream&gt;</kbd> to the top of your file.</p>
<p class="calibre2">We are using the standard library's <kbd class="calibre14">cout</kbd> function in this instance, instead of the <kbd class="calibre14">printf</kbd> that we have been using, because <kbd class="calibre14">cout</kbd> allows us to feed in <kbd class="calibre14">obj</kbd>--no matter what its type is--to display something, which isn't possible with <kbd class="calibre14">printf</kbd> by default.</p>
<p class="calibre2">Once that's finished, we can go ahead and use this inside of our project:</p>
<pre class="calibre23">
  TemplateExample&lt;int&gt; teInt; <br class="title-page-name"/>  teInt.TemplatedFunction(5); <br class="title-page-name"/> <br class="title-page-name"/>   <br class="title-page-name"/>  TemplateExample&lt;float&gt; teFloat; <br class="title-page-name"/>  teFloat.TemplatedFunction(2.5); <br class="title-page-name"/>   <br class="title-page-name"/>  TemplateExample&lt;std::string&gt; teString; <br class="title-page-name"/>  teString.TemplatedFunction("Testing");
</pre>
<p class="calibre2">As you can see, this will create three different kinds of <kbd class="calibre14">TemplateExample</kbd> class objects using different types. When we call the <kbd class="calibre14">TemplatedFunction</kbd> function, it will print out exactly the way we were hoping:</p>
<div><img class="image-border8" src="img/00022.jpeg"/></div>
<p class="calibre2">Later on, when we learn about abstract types, we can use templates with them to handle any kind of data. In our case right now, we are going to use this functionality to allow us to make as many Singletons as we'd like!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Templatizing Singletons</h1>
            

            
                
<p class="calibre2">Now, assuming we get our Singleton working just the way that we want it to, you may wish to create more Singletons in the future. You could create them all from scratch, but a better thing to do is instead create a consistent approach, creating templates and inheritance to create a single implementation that you can use for any class. At the same time, we can also learn about an alternative way of creating a <kbd class="calibre14">Singleton</kbd> class, which will look something like the following:</p>
<pre class="calibre23">
template &lt;typename T&gt; <br class="title-page-name"/>class Singleton <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  Singleton() <br class="title-page-name"/>  { <br class="title-page-name"/>    // Set our instance variable when we are created <br class="title-page-name"/>    if (instance == nullptr) <br class="title-page-name"/>    { <br class="title-page-name"/>      instance = static_cast&lt;T*&gt;(this); <br class="title-page-name"/>    } <br class="title-page-name"/>    else <br class="title-page-name"/>    { <br class="title-page-name"/>      // If instance already exists, we have a problem <br class="title-page-name"/>      printf("\nError: Trying to create more than one Singleton"); <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Once destroyed, remove access to instance <br class="title-page-name"/>  virtual ~Singleton() <br class="title-page-name"/>  { <br class="title-page-name"/>    instance = nullptr; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Get a reference to our instance <br class="title-page-name"/>  static T &amp; GetInstance() <br class="title-page-name"/>  { <br class="title-page-name"/>    return *instance; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Creates an instance of our instance <br class="title-page-name"/>  static void CreateInstance() <br class="title-page-name"/>  {   <br class="title-page-name"/>    new T(); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Deletes the instance, needs to be called or resource leak <br class="title-page-name"/>  static void RemoveInstance() <br class="title-page-name"/>  { <br class="title-page-name"/>    delete instance; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  // Note, needs to be a declaration <br class="title-page-name"/>  static T * instance; <br class="title-page-name"/> <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>template &lt;typename T&gt; T * Singleton&lt;T&gt;::instance = nullptr;
</pre>
<p class="calibre2">You'll notice that most of the differences have to do with the class itself. The very first line in our code above uses the <kbd class="calibre14">template</kbd> keyword which tells the compiler that we are creating a template, and <kbd class="calibre14">typename T</kbd> tells the compiler that, when we create a new object using this, the type <kbd class="calibre14">T</kbd> will be replaced with whatever the class we want it to be based on is.</p>
<p class="calibre2">I also want to point out the use of a static cast to convert our Singleton pointer to a <kbd class="calibre14">T</kbd>. <kbd class="calibre14">static_cast</kbd> is used in code generally when you want to reverse an implicit conversion. It's important to note that <kbd class="calibre14">static_cast</kbd> performs no runtime checks for if it's correct or not. This should be used if you know that you refer to an object of a specific type, and thus a check would be unnecessary. In our case, it is safe because we will be casting from a Singleton object to the type that we've derived from it (<kbd class="calibre14">T</kbd>).</p>
<p class="calibre2">Of course, it may be useful to see an example of this being used, so let's create an example of a class that we could use as a Singleton, perhaps something to manage the high scores for our game:</p>
<pre class="calibre23">
class HighScoreManager : public Singleton&lt;HighScoreManager&gt; <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  void CheckHighScore(int score); <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  int highScore; <br class="title-page-name"/>};
</pre>
<p class="calibre2">Notice here that, when we declare our <kbd class="calibre14">HighScoreManager</kbd> class, we say that it's derived from the <kbd class="calibre14">Singleton</kbd> class and, in turn, we pass the <kbd class="calibre14">HighScoreManager</kbd> class to the <kbd class="calibre14">Singleton</kbd> template. This pattern is known as the curiously recurring template pattern.</p>
<p>For more information on the curiously recurring template pattern, check out <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" class="calibre24">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a>.</p>
<p class="calibre2">After defining the class, let's go ahead and add in an example implementation for the function we've created for this class:</p>
<pre class="calibre23">
void HighScoreManager::CheckHighScore(int score) <br class="title-page-name"/>{ <br class="title-page-name"/>  std::string toDisplay; <br class="title-page-name"/> <br class="title-page-name"/>  if (highScore &lt; score) <br class="title-page-name"/>  { <br class="title-page-name"/>    highScore = score; <br class="title-page-name"/>    toDisplay = "\nNew High Score: " + std::to_string(score); <br class="title-page-name"/>    printf(toDisplay.c_str()); <br class="title-page-name"/>  } <br class="title-page-name"/>  else <br class="title-page-name"/>  { <br class="title-page-name"/>    toDisplay = "\nCurrent High Score: " + std::to_string(highScore); <br class="title-page-name"/>    printf(toDisplay.c_str()); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">By using the templatized version of our class, we don't need to create the same materials as in the preceding class. We can just focus on the stuff that is particular to what this class needs to do. In this case, it's checking our current high score, and setting it to whatever we pass in if we happen to beat it.</p>
<p class="calibre2">Of course, it's great to see our code in action, and in this case I used the <kbd class="calibre14">SplashStage</kbd> class, which is located in the Mach5 <kbd class="calibre14">EngineTest</kbd> project, under <kbd class="calibre14">SpaceShooter/Stages/SplashStage.cpp</kbd>. To do so, I added the following bolded lines to the <kbd class="calibre14">Init</kbd> function:</p>
<pre class="calibre23">
void SplashStage::Init(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  //This code will only show in the console if it is active and you  <br class="title-page-name"/>  //are in debug mode. <br class="title-page-name"/>  M5DEBUG_PRINT("This is a demo of the different things you can do\n"); <br class="title-page-name"/>  M5DEBUG_PRINT("in the Mach 5 Engine.  Play with the demo but you must\n"); <br class="title-page-name"/>  M5DEBUG_PRINT("also inspect the code and comments.\n\n"); <br class="title-page-name"/>  M5DEBUG_PRINT("If you find errors, report to lazersquad@gmail.com"); <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  HighScoreManager::CreateInstance();</strong><strong class="calibre1">    <br class="title-page-name"/>  HighScoreManager::GetInstance().CheckHighScore(10);</strong><strong class="calibre1">    <br class="title-page-name"/>  HighScoreManager::GetInstance().CheckHighScore(100);</strong><strong class="calibre1">    <br class="title-page-name"/>  HighScoreManager::GetInstance().CheckHighScore(50);</strong> <br class="title-page-name"/> <br class="title-page-name"/>  //Create ini reader and starting vars <br class="title-page-name"/>  M5IniFile iniFile; <br class="title-page-name"/> <br class="title-page-name"/>  // etc. etc.
</pre>
<p class="calibre2">In this case, our instance has been created by us creating a new <kbd class="calibre14">HighScoreManager</kbd>. If that is not done, then our project could potentially crash when calling <kbd class="calibre14">GetInstance</kbd>, so it's very important to call it. Then call our <kbd class="calibre14">CheckHighScore</kbd> functions a number of times to verify that the functionality works correctly. Then, in the <kbd class="calibre14">Shutdown</kbd> function, add the following bolded line to make sure the Singleton is removed correctly:</p>
<pre class="calibre23">
void SplashStage::Shutdown(void) <br class="title-page-name"/>{ <br class="title-page-name"/><strong class="calibre1">  HighScoreManager::RemoveInstance();</strong> <br class="title-page-name"/> <br class="title-page-name"/>  M5ObjectManager::DestroyAllObjects(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">With all of that gone, go ahead, save the file, and run the game. The output will be as follows:</p>
<div><img class="image-border10" src="img/00023.jpeg"/></div>
<p class="calibre2">As you can see, our code works correctly!</p>
<p class="calibre2">Note that this has the same disadvantages we discussed with our initial version of the script, with the fact that we have to manually create the object and remove it; but it takes away a lot of the busy work when creating a number of Singletons in your project. If you're going to be creating a number of them in your project, this could be a good method to look into.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Advantages/disadvantages of using only one instance</h1>
            

            
                
<p class="calibre2">There is the possibility that as you continue your project, something that looks at the time to be a thing that you'll only need one of will suddenly turn into something you need more of down the road. In games, one of the easiest examples would be that of a player. When starting the game, you may think you're only going to have one player, but maybe later you decide to add co-op. Depending on what you did before, that can be a small or huge change to the project.</p>
<p class="calibre2">Finally, one of the more common mistakes we see once programmers learn about Singletons, is to create managers for everything, and then make the managers all Singletons.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Singleton in action - the Application class</h1>
            

            
                
<p class="calibre2">The Singleton pattern achieves its ability to be accessible anywhere easily by having a special function that we use to get the <kbd class="calibre14">Singleton</kbd> object. When this function is called, we will check whether that object has been created yet. If it has, then we will simple return a reference to the object. If not, we will create it, and then return a reference to the newly created object.</p>
<p class="calibre2">Now, in addition to having this way to access it, we also want to block off our user from being able to create them, so we will need to define our class constructors to be private.</p>
<p class="calibre2">Now that we have an understanding of some implementations of the Singleton, we have one other version, which is what we actually used within the Mach5 engine.</p>
<p class="calibre2">In Mach5, the only Singletons that are included are aspects of the engine code. The engine code is designed to work with any game, meaning there is nothing gameplay-specific about it, which means that it doesn't need to have instances since they're just instructions. Building the engine in this way makes it much easier in the future to bring this to other games, since it's been removed from anything that's game-specific.</p>
<p class="calibre2">In this case, let's open up the <kbd class="calibre14">M5App.h</kbd> file which is in the <kbd class="calibre14">EngineTest</kbd> project under <kbd class="calibre14">Core/Singletons/App</kbd> and take a look at the class itself:</p>
<pre class="calibre23">
//! Singleton class to Control the Window <br class="title-page-name"/>class M5App <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  friend class M5StageManager; <br class="title-page-name"/> <br class="title-page-name"/>  /*Call These in Main*/ <br class="title-page-name"/> <br class="title-page-name"/>  /*This must be called first, before the game is started*/ <br class="title-page-name"/>  static void Init(const M5InitData&amp; initStruct); <br class="title-page-name"/>  /*Call this after you add your stages to start the game*/ <br class="title-page-name"/>  static void Update(void); <br class="title-page-name"/>  /*Call this after Update is finished*/ <br class="title-page-name"/>  static void Shutdown(void); <br class="title-page-name"/> <br class="title-page-name"/>  /*Call these to control or get info about the application*/ <br class="title-page-name"/> <br class="title-page-name"/>  /*Use this to change to fullscreen and back*/ <br class="title-page-name"/>  static void SetFullScreen(bool fullScreen); <br class="title-page-name"/>  /*Use this to show and hide the window*/ <br class="title-page-name"/>  static void ShowWindow(bool show); <br class="title-page-name"/>  /*Use this to show and hide the default window cursor*/ <br class="title-page-name"/>  static void ShowCursor(bool showCursor); <br class="title-page-name"/>  /*Use this to change the resolution of the game*/ <br class="title-page-name"/>  static void SetResolution(int width, int height); <br class="title-page-name"/>  /*Returns the width and height of the window (client area)*/ <br class="title-page-name"/>  static M5Vec2 GetResolution(void); <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  static LRESULT CALLBACK M5WinProc(HWND win, UINT msg, WPARAM wp, LPARAM lp); <br class="title-page-name"/>  static void ProcessMessages(void); <br class="title-page-name"/> <br class="title-page-name"/>};//end M5APP
</pre>
<p class="calibre2">Now, the Mach5 engine follows the Singleton pattern. However, it is done in a different way from the others that we've looked at so far. You may notice in the class definition that every single function and variable that was created was made static.</p>
<p class="calibre2">This provides us with some unique benefits, namely that we don't need to worry about the user creating multiple versions of the class, because they'll only be restricted to using static properties and variables that are shared by everything. This means we don't need to worry about all of those fringe cases we mentioned in the previous examples that we've seen. This is possibly due to the fact that the Mach5 engine classes have no need to have child classes; there's no need for us to create a pointer or even call a <kbd class="calibre14">GetInstance</kbd> function.</p>
<p class="calibre2">You'll also notice the <kbd class="calibre14">Init</kbd>, <kbd class="calibre14">Update</kbd>, and <kbd class="calibre14">Shutdown</kbd> functions mentioned previously. We mentioned before that it was a disadvantage to manually have to create and destroy our <kbd class="calibre14">singleton</kbd> classes, but there are some distinct benefits to having this control. In the previous examples we had, the order in which classes were created was up to the compiler as we couldn't control the order. However, with our game engine it makes sense to create our Application (<kbd class="calibre14">M5App</kbd>) before we start up the graphics library (<kbd class="calibre14">M5Gfx</kbd>) and the only way we can make sure that happens is by telling our engine to do so, which you can look at if you open up the <kbd class="calibre14">Main.cpp</kbd> file and look at the <kbd class="calibre14">WinMain</kbd> function, which is what opens first when we create our project. I've gone ahead and bolded the uses of <kbd class="calibre14">M5App</kbd>:</p>
<pre class="calibre23">
int WINAPI WinMain(HINSTANCE instance, <br class="title-page-name"/>                   HINSTANCE /*prev*/,  <br class="title-page-name"/>                   LPSTR /*commandLine*/,  <br class="title-page-name"/>                   int /*show*/) <br class="title-page-name"/>{ <br class="title-page-name"/>  /*This should appear at the top of winmain to have windows find memory leaks*/ <br class="title-page-name"/>  M5DEBUG_LEAK_CHECKS(-1); <br class="title-page-name"/> <br class="title-page-name"/>  M5InitData initData;          /*Declare my InitStruct*/ <br class="title-page-name"/>  M5GameData gameData = { 0 };  /*Create my game data initial values*/ <br class="title-page-name"/>  M5IniFile iniFile;            /*To load my init data from file*/ <br class="title-page-name"/> <br class="title-page-name"/>  iniFile.ReadFile("GameData/InitData.ini"); <br class="title-page-name"/>  iniFile.SetToSection("InitData"); <br class="title-page-name"/> <br class="title-page-name"/>  /*Set up my InitStruct*/ <br class="title-page-name"/>  iniFile.GetValue("width", initData.width); <br class="title-page-name"/>  iniFile.GetValue("height", initData.height); <br class="title-page-name"/>  iniFile.GetValue("framesPerSecond", initData.fps); <br class="title-page-name"/>  iniFile.GetValue("fullScreen", initData.fullScreen); <br class="title-page-name"/>   <br class="title-page-name"/>  initData.title        = "AstroShot"; <br class="title-page-name"/>  initData.instance     = instance; <br class="title-page-name"/>  /*Information about your specific gamedata */ <br class="title-page-name"/>  initData.pGData       = &amp;gameData; <br class="title-page-name"/>  initData.gameDataSize = sizeof(M5GameData); <br class="title-page-name"/> <br class="title-page-name"/>  /*Pass InitStruct to Function.  This function must be called first!!!*/ <br class="title-page-name"/><strong class="calibre1">  M5App::Init(initData);</strong> <br class="title-page-name"/>   <br class="title-page-name"/>  /*Make sure to add what stage we will start in*/ <br class="title-page-name"/>  M5StageManager::SetStartStage(ST_SplashStage); <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  /*Start running the game*/<br class="title-page-name"/></strong><strong class="calibre1">  M5App::Update();<br class="title-page-name"/></strong><strong class="calibre1">  /*This function must be called after the window has closed!!!*/<br class="title-page-name"/></strong><strong class="calibre1">  M5App::Shutdown();</strong> <br class="title-page-name"/>   <br class="title-page-name"/>  return 0; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Afterwards, we can look at the <kbd class="calibre14">Init</kbd> function of <kbd class="calibre14">M5App</kbd> and see that it will initialize the other Singletons in our project:</p>
<pre class="calibre23">
void M5App::Init(const M5InitData&amp; initData) <br class="title-page-name"/>{ <br class="title-page-name"/>  // ... <br class="title-page-name"/>    // Other init code above... <br class="title-page-name"/>   <br class="title-page-name"/><strong class="calibre1">  M5StageManager::Init(initData.pGData, initData.gameDataSize, initData.fps);<br class="title-page-name"/></strong><strong class="calibre1">  M5ObjectManager::Init();</strong><strong class="calibre1">  <br class="title-page-name"/>  M5Input::Init();</strong> <br class="title-page-name"/>}
</pre>
<p class="calibre2">By having this control, our users have a much better idea as to the flow and order that things will be created. But, of course, with that great power comes great responsibility.</p>
<p>The Singleton pattern is used only for single-threaded applications. Should you be developing a multithreaded game, you'll want to use the Double-Checked Locking pattern instead, which was created by <em class="calibre25">Doug Schmidt</em> and <em class="calibre25">Tim Harrison</em>. If you're interested in learning more about it, check out <a href="https://en.wikipedia.org/wiki/Double-checked_locking" target="_blank" class="calibre24">https://en.wikipedia.org/wiki/Double-checked_locking</a>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we have demystified a lot of programming concepts in a quick refresher. We also started learning about our first design pattern, the Singleton, which is intended to allow us to always have access to a class's functions and variables due to the fact that there will only ever be one of these objects.</p>
<p class="calibre2">We discussed some of the typical downfalls of using the Singleton pattern, such as the possibility that objects could have multiple copies of them in the future, even if this is unlikely.</p>
<p class="calibre2">We learned about three different kinds of method for creating Singletons, starting off with the <em class="calibre12">Singleton</em>, then extending it and templating parts of it to create the curiously reoccurring template pattern, and then we saw a final all-static version of getting the same effect with minimal hassle.</p>
<p class="calibre2">Each of these methods has their own pros and cons, and we hope that you use them effectively, where they are relevant. Now that we've touched on the design pattern everyone is familiar with, we can move towards our next challenge: learning about how to deal with logic that is specific to each of our individual games.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>