<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Working with Game Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Game Objects</h1></div></div></div><p>All games have objects, for example, players, enemies, <span class="strong"><strong>non-player character</strong></span> (<span class="strong"><strong>NPC</strong></span>), traps, bullets, and doors. Keeping track of all these objects and how they<a class="indexterm" id="id154"/> interact with each other is a big task and one that we would like to make as simple as possible. Our game could become unwieldy and difficult to update if we do not have a solid implementation. So what can we do to make our task easier? We can start by really trying to leverage the power of <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>). We will cover the following in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using inheritance</li><li class="listitem" style="list-style-type: disc">Implementing polymorphism</li><li class="listitem" style="list-style-type: disc">Using abstract base classes</li><li class="listitem" style="list-style-type: disc">Effective inheritance design</li></ul></div><div class="section" title="Using inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec23"/>Using inheritance</h1></div></div></div><p>The first powerful feature of OOP we will look at is inheritance. This feature can help us enormously when developing our reusable framework. Through the use of inheritance, we can share common functionality between similar classes and also create subtypes from existing types. We will <a class="indexterm" id="id155"/>not go into too much detail about inheritance itself but instead we will start to think about how we will apply it to our framework.</p><p>As mentioned earlier, all games have objects of various types. In most cases, these objects will have a lot of the same data and require a lot of the same basic functions. Let's look at some examples of this<a class="indexterm" id="id156"/> common functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Almost all of our objects will be drawn to the screen, thus requiring a <code class="literal">draw</code> function</li><li class="listitem" style="list-style-type: disc">If our objects are to be drawn, they will need a location to draw to, that is, x and y position variables</li><li class="listitem" style="list-style-type: disc">We don't want static objects all the time, so we will need an <code class="literal">update</code> function</li><li class="listitem" style="list-style-type: disc">Objects will be responsible for cleaning up after themselves; a function that deals with this will be important</li></ul></div><p>This is a good starting <a class="indexterm" id="id157"/>point for our first game object class, so let's go ahead and create it. Add a new class to the project called <code class="literal">GameObject</code> and we can begin:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  void draw() { std::cout &lt;&lt; "draw game object"; }
  void update() { std::cout &lt;&lt; "update game object"; }
  void clean() { std::cout &lt;&lt; "clean game object"; }

protected:

  int m_x;
  int m_y;
};</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>The public, protected, and private keywords are very important. Public functions and data are accessible from anywhere. Protected status restricts access to only those classes derived from it. Private members are only available to that class, not even its derived classes.</p></div></div><p>So, there we have our first game object class. Now let's inherit from it and create a class called <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">class Player : public GameObject // inherit from GameObject
{
public:

  void draw()
  {
    GameObject::draw();
    std::cout &lt;&lt; "draw player";
  }
  void update()
  {
    std::cout &lt;&lt; "update player";
    m_x = 10;
    m_y = 20;
  }
  void clean()
  {
    GameObject::clean();
    std::cout &lt;&lt; "clean player";
  }
};</pre></div><p>What we have achieved is the ability to reuse the code and data that we originally had in <code class="literal">GameObject</code> and apply<a class="indexterm" id="id158"/> it to our new <code class="literal">Player</code> class. As you can see, a derived class can override the functionality of a parent class:</p><div class="informalexample"><pre class="programlisting">void update()
{
  std::cout &lt;&lt; "update player";
  m_x = 10;
  m_y = 20;
}</pre></div><p>Or it can even use the functionality of the parent class, while also having its own additional functionality on top:</p><div class="informalexample"><pre class="programlisting">void draw()
{
  GameObject::draw();
  std::cout &lt;&lt; "draw player";
}</pre></div><p>Here we call the <code class="literal">draw</code> function from <code class="literal">GameObject</code> and then define some player-specific functionality.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">::</code> operator is called the scope resolution operator and it is used to identify the specific place that some data or function resides.</p></div></div><p>Okay, so far our classes do not do much, so let's add some of our SDL functionality. We will add some drawing code to the <a class="indexterm" id="id159"/>
<code class="literal">GameObject</code> class and then reuse it within our <code class="literal">Player</code> class. First we will update our <code class="literal">GameObject</code> header file with some new values and functions to allow us to use our existing SDL code:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();

protected:

  std::string m_textureID;

  int m_currentFrame;
  int m_currentRow;

  int m_x;
  int m_y;

  int m_width;
  int m_height;
};</pre></div><p>We now have some new<a class="indexterm" id="id160"/> member variables that will be set in the new <code class="literal">load</code> function. We are also passing in the <code class="literal">SDL_Renderer</code> object we want to use in our <code class="literal">draw</code> function. Let's define these functions in an implementation file and create <code class="literal">GameObject.cpp</code>:</p><p>First define our new <code class="literal">load</code> function:</p><div class="informalexample"><pre class="programlisting">void GameObject::load(int x, int y, int width, int height, std::string textureID)
{
  m_x = x;
  m_y = y;
  m_width = width;
  m_height = height;
  m_textureID = textureID;

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div><p>Here we are setting all of the values we declared in the header file. We will just use a start value of <code class="literal">1</code> for our <code class="literal">m_currentRow</code> and <code class="literal">m_currentFrame</code> values. Now we can create our <code class="literal">draw</code> function that will make use of these values:</p><div class="informalexample"><pre class="programlisting">void GameObject::draw(SDL_Renderer* pRenderer)
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, m_x, m_y, 
  m_width, m_height, m_currentRow, m_currentFrame, pRenderer);
}</pre></div><p>We grab the texture <a class="indexterm" id="id161"/>we want from <code class="literal">TextureManager</code> using <code class="literal">m_textureID</code> and draw it according to our set values. Finally we can just put something in our <code class="literal">update</code> function that we can override in the <code class="literal">Player</code> class:</p><div class="informalexample"><pre class="programlisting">void GameObject::update()
{
  m_x += 1;
}</pre></div><p>Our <code class="literal">GameObject</code> class is complete for now. We can now alter the <code class="literal">Player</code> header file to reflect our changes:</p><div class="informalexample"><pre class="programlisting">#include "GameObject.h"

class Player : public GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();
};</pre></div><p>We can now move on to defining these functions in an implementation file. Create <code class="literal">Player.cpp</code> and we'll walk through the functions. First we will start with the <code class="literal">load</code> function:</p><div class="informalexample"><pre class="programlisting">void Player::load(int x, int y, int width, int height, string textureID)
{
  GameObject::load(x, y, width, height, textureID);
}</pre></div><p>Here we can use our <code class="literal">GameObject::load</code> function. And the same applies to our <code class="literal">draw</code> function:</p><div class="informalexample"><pre class="programlisting">void Player::draw(SDL_Renderer* pRenderer)
{
  GameObject::draw(pRenderer);
}</pre></div><p>And let's<a class="indexterm" id="id162"/> override the <code class="literal">update</code> function with something different; let's animate this one and move it in the opposite direction:</p><div class="informalexample"><pre class="programlisting">void Player::update()
{
  m_x -= 1;
}</pre></div><p>We are all set; we can create these objects in the <code class="literal">Game</code> header file:</p><div class="informalexample"><pre class="programlisting">GameObject m_go;
Player m_player;</pre></div><p>Then load them in the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">m_go.load(100, 100, 128, 82, "animate");
m_player.load(300, 300, 128, 82, "animate");</pre></div><p>They will then need to be added to the <code class="literal">render</code> and <code class="literal">update</code> functions:</p><div class="informalexample"><pre class="programlisting">void Game::render()
{

  SDL_RenderClear(m_pRenderer); // clear to the draw colour

  m_go.draw(m_pRenderer);
  m_player.draw(m_pRenderer);

  SDL_RenderPresent(m_pRenderer); // draw to the screen

}

void Game::update()
{
  m_go.update();
  m_player.update();
}</pre></div><p>We have one more thing to add to make this run correctly. We need to cap our frame rate slightly; if we do not, then our objects will move far too fast. We will go into more detail about this in a later<a class="indexterm" id="id163"/> chapter, but for now we can just put a delay in our main loop. So, back in <code class="literal">main.cpp</code>, we can add this line:</p><div class="informalexample"><pre class="programlisting">while(g_game-&gt;running())
{
  g_game-&gt;handleEvents();
  g_game-&gt;update();
  g_game-&gt;render();

  SDL_Delay(10); // add the delay
}</pre></div><p>Now build and run to see our two separate objects:</p><div class="mediaobject"><img alt="Using inheritance" src="graphics/6821OT_03_01.jpg"/></div><p>Our <code class="literal">Player</code> class was extremely easy to write, as we had already written some of the code in our <code class="literal">GameObject</code> class, along with the needed variables. You may have noticed, however, that we were copying code into a lot of places in the <code class="literal">Game</code> class. It requires a lot of steps to create and add a new object to the game. This is not ideal, as it would be easy to miss a step and also it will get extremely hard to manage and maintain when a game goes beyond having two or three different objects.</p><p>What we really <a class="indexterm" id="id164"/>want is for our <code class="literal">Game</code> class not to need to care about different types; then we could loop through all of our game objects in one go, with separate loops for each of their functions.</p></div></div>
<div class="section" title="Implementing polymorphism"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec24"/>Implementing polymorphism</h1></div></div></div><p>This leads us to our next OOP feature, polymorphism. What polymorphism allows us to do is to refer to an object through a pointer to its parent or base class. This may not seem powerful at first, but <a class="indexterm" id="id165"/>what this will allow us to do is essentially have our <code class="literal">Game</code> class need only to store a list of pointers to one type and any derived types can also be added to <a class="indexterm" id="id166"/>this list. </p><p>Let us take our <code class="literal">GameObject</code> and <code class="literal">Player</code> classes as examples, with an added derived class, <code class="literal">Enemy</code>. In our <code class="literal">Game</code> class we have an array of <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>We then declare four new objects, all of which are <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">GameObject* m_player;
GameObject* m_enemy1;
GameObject* m_enemy2;
GameObject* m_enemy3;</pre></div><p>In our <code class="literal">Game::init</code> function we can then create instances of the objects using their individual types:</p><div class="informalexample"><pre class="programlisting">m_player = new Player();
m_enemy1 = new Enemy();
m_enemy2 = new Enemy();
m_enemy3 = new Enemy();</pre></div><p>Now they can be pushed into the array of <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">m_gameObjects.push_back(m_player);
m_gameObjects.push_back(m_enemy1);
m_gameObjects.push_back(m_enemy2);
m_gameObjects.push_back(m_enemy3);</pre></div><p>The <code class="literal">Game::draw</code> function can now look something like this:</p><div class="informalexample"><pre class="programlisting">void Game::draw()
{
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++) 
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);
  }
}</pre></div><p>Notice that we are looping through all of our objects and calling the <code class="literal">draw</code> function. The loop does not care that some of our objects are actually <code class="literal">Player</code> or <code class="literal">Enemy</code>; it handles them in the same manner.<a class="indexterm" id="id167"/> We are accessing them through a pointer to their base class. So, to add a new type, it simply needs to be derived from <code class="literal">GameObject</code>, and the <code class="literal">Game</code> class can handle it.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">So let's implement this for real in our framework. First we need a base class; we will stick with <code class="literal">GameObject</code>. We will have to make some changes to the class so that we can use it as a base class:<div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  virtual void load(int x, int y, int width, int height, 
  std::string textureID);
  virtual void draw(SDL_Renderer* pRenderer);
  virtual void update();
  virtual void clean();

protected:

  std::string m_textureID;

  int m_currentFrame;
  int m_currentRow;

  int m_x;
  int m_y;

  int m_width;
  int m_height;
};</pre></div></li></ul></div><p>Notice that we have now prefixed our functions with the virtual keyword. The virtual keyword means that when calling this function through a pointer, it uses the definition from the type of the object itself, not the type of its pointer:</p><div class="informalexample"><pre class="programlisting">void Game::draw()
{
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++) 
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);  
  }
}</pre></div><p>In other words, this<a class="indexterm" id="id168"/> function would always call the <code class="literal">draw</code> function contained in <code class="literal">GameObject</code>, neither <code class="literal">Player</code> nor <code class="literal">Enemy</code>. We would never have the overridden behavior that we want. The virtual keyword would ensure that the <code class="literal">Player</code> and <code class="literal">Enemy</code> draw functions are called.</p><p>Now we have a base class, so let's go ahead and try it out in our <code class="literal">Game</code> class. We will start by declaring the objects in the <code class="literal">Game</code> header file:</p><div class="informalexample"><pre class="programlisting">GameObject* m_go;
GameObject* m_player;</pre></div><p>Now declare along with our <code class="literal">GameObject*</code> array:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>Now create and load the objects in the <code class="literal">init</code> function, then push them into the array:</p><div class="informalexample"><pre class="programlisting">m_go = new GameObject();
m_player = new Player();

m_go-&gt;load(100, 100, 128, 82, "animate");
m_player-&gt;load(300, 300, 128, 82, "animate");

m_gameObjects.push_back(m_go);
m_gameObjects.push_back(m_player);</pre></div><p>So far, so good; we can now create a loop that will draw our objects and another that will update them. Now let's look at the <code class="literal">render</code> and <code class="literal">update</code> functions:</p><div class="informalexample"><pre class="programlisting">void Game::render()
{

  SDL_RenderClear(m_pRenderer); // clear to the draw colour

  // loop through our objects and draw them
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);
  }

  SDL_RenderPresent(m_pRenderer); // draw to the screen

}

void Game::update()
{
  // loop through and update our objects
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}</pre></div><p>As you can see,<a class="indexterm" id="id169"/> this is a lot tidier and also much easier to manage. Let us derive one more class from <code class="literal">GameObject</code> just so that we nail this concept down. Create a new class called <code class="literal">Enemy</code>:</p><div class="informalexample"><pre class="programlisting">class Enemy : public GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();
};</pre></div><p>We will define the functions of this class the same as <code class="literal">Player</code> with only the <code class="literal">update</code> function as an exception:</p><div class="informalexample"><pre class="programlisting">void Enemy::update()
{
  m_y += 1;
  m_x += 1;
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));
}</pre></div><p>Now let's add it to the game. First, we declare it as follows:</p><div class="informalexample"><pre class="programlisting">GameObject* m_enemy;</pre></div><p>Then create, load, and add to the array:</p><div class="informalexample"><pre class="programlisting">m_enemy = new Enemy();
m_enemy-&gt;load(0, 0, 128, 82, "animate");
m_gameObjects.push_back(m_enemy);</pre></div><p>We have just <a class="indexterm" id="id170"/>added a new type and it was extremely quick and simple. Run the game to see our three objects, each with their own different behavior.</p><div class="mediaobject"><img alt="Implementing polymorphism" src="graphics/6821OT_03_02.jpg"/></div><p>We have covered a lot here and have a really nice system for handling our game objects, yet we still have an issue. <a class="indexterm" id="id171"/>There is nothing stopping us from deriving a class without the <code class="literal">update</code> or <code class="literal">draw</code> functions that we are using here, or even declaring a different function and putting the <code class="literal">update</code> code in there. It is unlikely that we, as the developers, would make this mistake, but others using the framework may. What we would like is the ability to force our derived classes to have their own implementation of a function we decide upon, creating something of a blueprint that we want all<a class="indexterm" id="id172"/> of our game objects to follow. We can achieve this through the use of an abstract base class.</p></div>
<div class="section" title="Using abstract base classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec25"/>Using abstract base classes</h1></div></div></div><p>If we are to implement our design correctly, then we have to be certain that all of our derived classes have a declaration and definition for each of the functions we want to access through the base class pointer. We can ensure this by making <code class="literal">GameObject</code> an abstract base class. An <a class="indexterm" id="id173"/>abstract base class cannot be initialized itself; its purpose is to dictate the design of derived classes. This gives us reusability as we know that any object we derive from <code class="literal">GameObject</code> will immediately work in the overall scheme of the game.</p><p>An abstract base class is a class that contains at least one pure virtual function. A pure virtual function is a function that has no definition and must be implemented in any derived classes. We can make a function pure virtual by suffixing it with <code class="literal">=0</code>.</p></div>
<div class="section" title="Should we always use inheritance?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec26"/>Should we always use inheritance?</h1></div></div></div><p>Inheritance and polymorphism are both very useful and really show off the power of object-oriented programming. However, in some circumstances, inheritance can cause more problems than it<a class="indexterm" id="id174"/> solves, and therefore, we should bear in mind a few rules of thumb when deciding whether or not to use it.</p><div class="section" title="Could the same thing be achieved with a simpler solution?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec03"/>Could the same thing be achieved with a simpler solution?</h2></div></div></div><p>Let's say we want to make a more powerful <code class="literal">Enemy</code> object; it will have the same behavior a regular <code class="literal">Enemy</code> object <a class="indexterm" id="id175"/>will have but with more health. One possible solution would be to derive a new class <code class="literal">PowerEnemy</code> from <code class="literal">Enemy</code> and give it double health. In this solution the new class will seem extremely sparse; it will use the functionality from <code class="literal">Enemy</code> but with one different value. An easier solution would be to have a way to set the health of an <code class="literal">Enemy</code> class, whether through an accessor or in the constructor. Inheritance isn't needed at all.</p></div><div class="section" title="Derived classes should model the &quot;is a&quot; relationship"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec04"/>Derived classes should model the "is a" relationship</h2></div></div></div><p>When deriving a class, it is <a class="indexterm" id="id176"/>a good idea for it to model the "is a" relationship. This means that the derived class should also be of the same type as the parent class. For example, deriving a <code class="literal">Player2</code> class from <code class="literal">Player</code> would fit the model, as <code class="literal">Player2</code> "is a" <code class="literal">Player</code>. But let's say, for example, we have a <code class="literal">Jetpack</code> class and we derive <code class="literal">Player</code> from this class to give it access to all the functionality that a <code class="literal">Jetpack</code> class has. This would not model the "is a" relationship, as a <code class="literal">Player</code> class is not a <code class="literal">Jetpack</code> class. It makes a lot more sense to say a <code class="literal">Player</code> class has a <code class="literal">Jetpack</code> class, and therefore, a <code class="literal">Player</code> class<a class="indexterm" id="id177"/> should have a member variable of type <code class="literal">Jetpack</code> with no inheritance; this is known as containment.</p></div><div class="section" title="Possible performance penalties"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec05"/>Possible performance penalties</h2></div></div></div><p>On platforms such as PC and Mac, the performance penalties of using inheritance and virtual functions are negligible. <a class="indexterm" id="id178"/>However, if you are developing for less powerful devices such as handheld consoles, phones, or embedded systems, this is something that you should take into account. If your core loop involves calling a virtual function many times per second, the performance penalties can add up.</p></div></div>
<div class="section" title="Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec27"/>Putting it all together</h1></div></div></div><p>We can now put all of this knowledge together and implement as much as we can into our framework, with<a class="indexterm" id="id179"/> reusability in mind. We have quite a bit of work to do, so let's start with our abstract base class, <code class="literal">GameObject</code>. We are going to strip out anything SDL-specific so that we can reuse this class in other SDL projects if needed. Here is our stripped down <code class="literal">GameObject</code> abstract base class:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  virtual void draw()=0;
  virtual void update()=0;
  virtual void clean()=0;

protected:

  GameObject(const LoaderParams* pParams) {}
  virtual ~GameObject() {}
};</pre></div><p>The pure virtual functions have been created, forcing any derived classes to also declare and implement them. There is also now no <code class="literal">load</code> function; the reason for this is that we don't want to have to create a new <code class="literal">load</code> function for each new project. We can be pretty sure that we will need different values when loading our objects for different games. The approach we will take here is to create a new class called <code class="literal">LoaderParams</code> and pass that into the constructor of our objects.</p><p>
<code class="literal">LoaderParams</code> is simply a class that takes values into its constructor and sets them as member variables that can then<a class="indexterm" id="id180"/> be accessed to set the initial values of an object. While it may just seem that we are moving the parameters from the <code class="literal">load</code> function to somewhere else, it is a lot easier to just create a new <code class="literal">LoaderParams</code> class than to track down and alter the <code class="literal">load</code> function of all of our objects. </p><p>So here is our <code class="literal">LoaderParams</code> class:</p><div class="informalexample"><pre class="programlisting">class LoaderParams
{
public:

  LoaderParams(int x, int y, int width, int height, std::string 
  textureID) : m_x(x), m_y(y), m_width(width), m_height(height), 
  m_textureID(textureID)
  {

  }

  int getX() const { return m_x; }
  int getY() const { return m_y; }
  int getWidth() const { return m_width; }
  int getHeight() const { return m_height; }
  std::string getTextureID() const { return m_textureID; }

private:

  int m_x;
  int m_y;

  int m_width;
  int m_height;

  std::string m_textureID;
};</pre></div><p>This class holds any values we need when creating our object exactly the same way as our <code class="literal">load</code> function used to do.</p><p>We have also removed the <code class="literal">SDL_Renderer</code> parameter from the <code class="literal">draw</code> function. We will instead make our <code class="literal">Game</code> class a <a class="indexterm" id="id181"/>singleton, such as <code class="literal">TextureManager</code>. So, we can add the following to our <code class="literal">Game</code> class:</p><div class="informalexample"><pre class="programlisting">// create the public instance function
static Game* Instance()
{
  if(s_pInstance == 0)
  {
    s_pInstance = new Game();
    return s_pInstance;
  }

  return s_pInstance;
}
// make the constructor private
private:

  Game();
// create the s_pInstance member variable
  static Game* s_pInstance;

// create the typedef
  typedef Game TheGame;</pre></div><p>In the <code class="literal">Game.cpp</code>, we have to define our static instance:</p><div class="informalexample"><pre class="programlisting">Game* Game::s_pInstance = 0;</pre></div><p>Let's also create a function in the header file that will return our <code class="literal">SDL_Renderer</code> object:</p><div class="informalexample"><pre class="programlisting">SDL_Renderer* getRenderer() const { return m_pRenderer; }</pre></div><p>Now that <code class="literal">Game</code> is a singleton, we are going to use it differently in our <code class="literal">main.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  std::cout &lt;&lt; "game init attempt...\n";
  if(TheGame::Instance()-&gt;init("Chapter 1", 100, 100, 640, 480, 
  false))
  {
    std::cout &lt;&lt; "game init success!\n";
    while(TheGame::Instance()-&gt;running())
    {
      TheGame::Instance()-&gt;handleEvents();
      TheGame::Instance()-&gt;update();
      TheGame::Instance()-&gt;render();

      SDL_Delay(10);
    }
  }
  else
  {
    std::cout &lt;&lt; "game init failure - " &lt;&lt; SDL_GetError() &lt;&lt; "\n";
    return -1;
  }

  std::cout &lt;&lt; "game closing...\n";
  TheGame::Instance()-&gt;clean();

  return 0;
}</pre></div><p>Now when we want to access the <code class="literal">m_pRenderer</code> value from <code class="literal">Game</code>, we can use the <a class="indexterm" id="id182"/>
<code class="literal">getRenderer</code> function.<a class="indexterm" id="id183"/> Now that <code class="literal">GameObject</code> is essentially empty, how do we achieve the code-sharing we originally had? We are going to derive a new generic class from <code class="literal">GameObject</code> and call it <code class="literal">SDLGameObject</code>:</p><div class="informalexample"><pre class="programlisting">class SDLGameObject : public GameObject
{
public:

  SDLGameObject(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();

protected:

  int m_x;
  int m_y;

  int m_width;
  int m_height;

  int m_currentRow;
  int m_currentFrame;

  std::string m_textureID;
};</pre></div><p>With this class we can create our reusable SDL code. First, we can use our new <code class="literal">LoaderParams</code> class to set <a class="indexterm" id="id184"/>our member variables:</p><div class="informalexample"><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : 
GameObject(pParams)
{
  m_x = pParams-&gt;getX();
  m_y = pParams-&gt;getY();
  m_width = pParams-&gt;getWidth();
  m_height = pParams-&gt;getHeight();
  m_textureID = pParams-&gt;getTextureID();

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div><p>We can also use the same <a class="indexterm" id="id185"/>
<code class="literal">draw</code> function as before, making use of our singleton <code class="literal">Game</code> class to get the renderer we want:</p><div class="informalexample"><pre class="programlisting">void SDLGameObject::draw()
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, m_x, m_y, 
  m_width, m_height, m_currentRow, m_currentFrame, 
  TheGame::Instance()-&gt;getRenderer());
}</pre></div><p>
<code class="literal">Player</code> and <code class="literal">Enemy</code> can now inherit from <code class="literal">SDLGameObject</code>:</p><div class="informalexample"><pre class="programlisting">class Player : public SDLGameObject
{
public:

  Player(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};
// Enemy class
class Enemy : public SDLGameObject
{
public:

  Enemy(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};</pre></div><p>The <code class="literal">Player</code> class<a class="indexterm" id="id186"/> can be defined like so (the <code class="literal">Enemy</code> class is very similar):</p><div class="informalexample"><pre class="programlisting">Player::Player(const LoaderParams* pParams) : 
SDLGameObject(pParams)
{

}

void Player::draw()
{
  SDLGameObject::draw(); // we now use SDLGameObject
}

void Player::update()
{
  m_x -= 1;
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));
}

void Player::clean()
{
}</pre></div><p>Now that everything is in place, we can go ahead and create the objects in our <code class="literal">Game</code> class and see everything in action. We won't add the objects to the header file this time; we will use a shortcut and build our objects in one line in the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">m_gameObjects.push_back(new Player(new LoaderParams(100, 100, 128, 82, "animate")));

m_gameObjects.push_back(new Enemy(new LoaderParams(300, 300, 128, 82, "animate")));</pre></div><p>Build the project. We<a class="indexterm" id="id187"/> now have everything in place to allow us to easily reuse our <code class="literal">Game</code> and <code class="literal">GameObject</code> classes.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Summary</h1></div></div></div><p>We have covered a lot of complex subjects in this chapter, and the concepts and ideas will take some time to sink in. We have covered the ability to easily create classes without having to rewrite a lot of similar functionality and the use of inheritance and how it allows us to share code between similar classes. We looked at polymorphism and how it can make object management a lot cleaner and reusable while abstract base classes took our inheritance knowledge up a notch by creating the blueprint we want all of our objects to follow. Finally, we put all our new knowledge into the context of our framework.</p></div></body></html>