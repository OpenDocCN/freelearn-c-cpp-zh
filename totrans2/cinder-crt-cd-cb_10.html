<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Interacting with the User</h1></div></div></div><p>In this chapter we will learn how to receive and respond to input from the user. The following recipes will be covered in the chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating<a id="id614" class="indexterm"/> an interactive object that responds to the mouse</li><li class="listitem" style="list-style-type: disc">Adding mouse events to our interactive object</li><li class="listitem" style="list-style-type: disc">Creating a slider</li><li class="listitem" style="list-style-type: disc">Creating a responsive text box</li><li class="listitem" style="list-style-type: disc">Dragging, scaling, and rotating objects using multi-touch</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Introduction</h1></div></div></div><p>In this chapter we will create graphical objects that react to the user using both mouse and touch interaction. We will learn how to create simple graphical interfaces that have their own events for greater flexibility.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Creating an interactive object that responds to the mouse</h1></div></div></div><p>In this recipe, <a id="id615" class="indexterm"/>we will create an <code class="literal">InteractiveObject</code> class for making graphical objects that interact with the mouse cursor and executes the following actions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Action</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Pressed</p>
</td><td style="text-align: left" valign="top">
<p>The user pressed the mouse button while over the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pressed outside</p>
</td><td style="text-align: left" valign="top">
<p>The user pressed the mouse button while outside the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Released</p>
</td><td style="text-align: left" valign="top">
<p>The mouse button is released after being pressed over the object and is still over the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Released outside</p>
</td><td style="text-align: left" valign="top">
<p>The mouse button is released outside the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Rolled over</p>
</td><td style="text-align: left" valign="top">
<p>The cursor moves over the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Rolled out</p>
</td><td style="text-align: left" valign="top">
<p>The cursor moves out of the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Dragged</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id616" class="indexterm"/>cursor is dragged while being over the object and after having pressed the object.</p>
</td></tr></tbody></table></div><p>For each of the previous actions, a virtual method will be called, and it would change the color of the object been drawn.</p><p>This object can be used as a base class to create interactive objects with more interesting graphics, such as textures.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec272"/>Getting ready</h2></div></div></div><p>Create and add the following files to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveObject.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveObject.cpp</code></li></ul></div><p>In the source file with your application class, include the <code class="literal">InteractiveObject.h</code> file and add the following <code class="literal">using</code> statements:</p><div><pre class="programlisting">#include "InteractiveObject.h"
using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec273"/>How to do it…</h2></div></div></div><p>We will create an <code class="literal">InteractiveObject</code> class and make it responsive to mouse events.</p><div><ol class="orderedlist arabic"><li class="listitem">Move to the file <code class="literal">InteractiveObject.h</code> and add the <code class="literal">#pragma once</code> directive and include the following files:<div><pre class="programlisting">#pragma once

#include "cinder/Rect.h"
#include "cinder/Color.h"
#include "cinder/app/MouseEvent.h"
#include "cinder/gl/gl.h"
#include "cinder/app/App.h"</pre></div></li><li class="listitem">Declare the <a id="id617" class="indexterm"/>class <code class="literal">InteractiveObject</code>:<div><pre class="programlisting">class InteractiveObject{
public:
InteractiveObject( const ci::Rectf&amp; rect );
virtual ~InteractiveObject();
virtual void draw();
virtual void pressed();
virtual void pressedOutside();
virtual void released();
virtual void releasedOutside();
virtual void rolledOver();
virtual void rolledOut();
virtual void dragged();
void mouseDown( ci::app::MouseEvent&amp; event );
void mouseUp( ci::app::MouseEvent&amp; event );
void mouseDrag( ci::app::MouseEvent&amp; event );
void mouseMove( ci::app::MouseEvent&amp; event );

ci::Rectf rect;
ci::Color pressedColor, idleColor, overColor, strokeColor;

protected:
bool mPressed, mOver;
};</pre></div></li><li class="listitem">Move on to the <code class="literal">InteractiveObject.cpp</code> file, and let's begin by including the <code class="literal">InteractiveObject.h</code> file and adding the following <code class="literal">using</code> statements:<div><pre class="programlisting">#include "InteractiveObject.h"

using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></li><li class="listitem">Let's begin by implementing <code class="literal">constructor</code> and <code class="literal">destructor</code>.<div><pre class="programlisting">InteractiveObject::InteractiveObject( const Rectf&amp; rect ){
  this-&gt;rect = rect;
  pressedColor = Color( 1.0f, 0.0f, 0.0f );
  idleColor = Color( 0.7f, 0.7f, 0.7f );
  overColor = Color( 1.0f, 1.0f, 1.0f );
  strokeColor = Color( 0.0f, 0.0f, 0.0f );
  mPressed = false;
  mOver = false;
}

InteractiveObject::~InteractiveObject(){    
}</pre></div></li><li class="listitem">In the<a id="id618" class="indexterm"/> <code class="literal">InteractiveObject::draw</code> method we will draw the rectangle using the appropriate colors:<div><pre class="programlisting">void InteractiveObject::draw(){
 if( mPressed ){
  gl::color( pressedColor );
 } else if( mOver ){
  gl::color( overColor );
 } else {
  gl::color( idleColor );
 }
 gl::drawSolidRect( rect );
 gl::color( strokeColor );
 gl::drawStrokedRect( rect );
}</pre></div></li><li class="listitem">In the <code class="literal">pressed</code>, <code class="literal">released</code>, <code class="literal">rolledOver</code>, <code class="literal">rolledOut</code>, and <code class="literal">dragged</code> methods we will simply output to the console on which the action just happened:<div><pre class="programlisting">void InteractiveObject::pressed(){
  console() &lt;&lt; "pressed" &lt;&lt; endl;
}

void InteractiveObject::pressedOutside(){
  console() &lt;&lt; "pressed outside" &lt;&lt; endl;
}

void InteractiveObject::released(){
  console() &lt;&lt; "released" &lt;&lt; endl;
}

void InteractiveObject::releasedOutside(){
  console() &lt;&lt; "released outside" &lt;&lt; endl;
}

void InteractiveObject::rolledOver(){
  console() &lt;&lt; "rolled over" &lt;&lt; endl;
}

void InteractiveObject::rolledOut(){
  console() &lt;&lt; "rolled out" &lt;&lt; endl;
}

void InteractiveObject::dragged(){
  console() &lt;&lt; "dragged" &lt;&lt; endl;
}</pre></div></li><li class="listitem">In the mouse <a id="id619" class="indexterm"/>event handlers we will check if the cursor is inside the object and update the <code class="literal">mPressed</code> and <code class="literal">mOver</code> variables accordingly. Every time the action is detected, we will also call the correspondent method.<div><pre class="programlisting">void InteractiveObject::mouseDown( MouseEvent&amp; event ){
  if( rect.contains( event.getPos() ) ){
    mPressed = true;
    mOver = false;
    pressed();
  }else{
      pressedOutside();
  }
}

void InteractiveObject::mouseUp( MouseEvent&amp; event ){
 if( rect.contains( event.getPos() ) ){
  if( mPressed ){
   mPressed = false;
   mOver = true;
   released();
  }
 } else {
  mPressed = false;
  mOver = false;
  releasedOutside();
 } 
}

void InteractiveObject::mouseDrag( MouseEvent&amp; event ){
 if( mPressed &amp;&amp; rect.contains( event.getPos() ) ){
  mPressed = true;
  mOver = false;
  dragged();
 } 
}

void InteractiveObject::mouseMove( MouseEvent&amp; event ){
 if( rect.contains( event.getPos() ) ){
  if( mOver == false ){
   mPressed = false;
   mOver = true;
   rolledOver();
  }
 } else {
  if( mOver ){
   mPressed = false;
   mOver = false;
   rolledOut();
  } 
 }</pre></div></li><li class="listitem">With <a id="id620" class="indexterm"/>our <code class="literal">InteractiveObject</code> class ready, let's move to our application's class source file. Let's begin by declaring an <code class="literal">InteractiveObject</code> object.<div><pre class="programlisting">
shared_ptr&lt;InteractiveObject&gt; mObject;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we will initialize <code class="literal">mObject</code>.<div><pre class="programlisting">Rectf rect( 100.0f, 100.0f, 300.0f, 300.0f );
mObject = shared_ptr&lt;InteractiveObject&gt;( new InteractiveObject( rect ) );</pre></div></li><li class="listitem">We will need to declare the mouse event handlers.<div><pre class="programlisting">void mouseDown( MouseEvent event );	
void mouseUp( MouseEvent event );
void mouseDrag( MouseEvent event );
void mouseMove( MouseEvent event );</pre></div></li><li class="listitem">In the implementation of the previous methods we will simply call the corresponding method of <code class="literal">mObject</code>.<div><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mObject-&gt;mouseDown( event );
}

void MyApp::mouseUp( MouseEvent event ){
  mObject-&gt;mouseUp( event );
}

void MyApp::mouseDrag( MouseEvent event ){
  mObject-&gt;mouseDrag( event );
}

void MyApp::mouseMove( MouseEvent event ){
  mObject-&gt;mouseMove( event );
}</pre></div></li><li class="listitem">In the implementation of the <code class="literal">draw</code> method, we will clear the background <a id="id621" class="indexterm"/>with black and call the <code class="literal">draw</code> method of <code class="literal">mObject</code>.<div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
mObject-&gt;draw();</pre></div></li><li class="listitem">Now build and run the application. Use the mouse to interact with the object. Whenever you press, release, or roll over or out of the object, a message will be sent to the console indicating the behavior.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec274"/>How it works…</h2></div></div></div><p>The <code class="literal">InteractiveObject</code> class is to be used as a base class for interactive objects. The methods <code class="literal">pressed</code>, <code class="literal">released</code>, <code class="literal">rolledOver</code>, <code class="literal">rolledOut</code>, and <code class="literal">dragged</code> are specifically designed to be overridden.</p><p>The mouse handlers of <code class="literal">InteractiveObject</code> call the previous methods whenever an action is detected. By overriding the methods, it is possible to implement specific behavior.</p><p>The virtual <code class="literal">destructor</code> is declared so that extending classes can have their own <code class="literal">destructor</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Adding mouse events to our interactive object</h1></div></div></div><p>In this recipe, we will <a id="id622" class="indexterm"/>continue with the previous recipe, <em>Creating an interactive object that responds to the mouse</em> and add the mouse events to our <code class="literal">InteractiveObject</code> class so that other<a id="id623" class="indexterm"/> objects can register and receive notifications whenever a mouse event occurs.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec275"/>Getting ready</h2></div></div></div><p>Grab the code from the recipe <em>Creating an interactive object that responds to the mouse</em> and add it to your project, as we will continue on from what was made earlier.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec276"/>How to do it…</h2></div></div></div><p>We will make <a id="id624" class="indexterm"/>our <code class="literal">InteractiveObject</code> class and send its own events <a id="id625" class="indexterm"/>whenever it interacts with the cursor.</p><div><ol class="orderedlist arabic"><li class="listitem">Let's create a class to use as an argument when sending events. Add the following code in the file <code class="literal">InteractiveObject.h</code> right before the <code class="literal">InteractiveObject</code> class declaration:<div><pre class="programlisting">class InteractiveObject;
class InteractiveObjectEvent: public ci::app::Event{
public:
enum EventType{ Pressed, PressedOutside, Released,
 ReleasedOutside, RolledOut, RolledOver, Dragged };
InteractiveObjectEvent( InteractiveObject *sender, 
 EventType type ){
 this-&gt;sender = sender;
 this-&gt;type = type;
}

InteractiveObject *sender;
EventType type;
};</pre></div></li><li class="listitem">In the <code class="literal">InteractiveObject</code> class, we will need to declare a member to manage the registered objects using the <code class="literal">ci::CallbakcMgr</code> class. Declare the following code as a protected member:<div><pre class="programlisting">ci::CallbackMgr&lt; void(InteractiveObjectEvent) &gt; mEvents;</pre></div></li><li class="listitem">Now we will need to add a method so that other objects can register to receive events. Since the method will use a template, we will declare and implement it in the <code class="literal">InteraciveObject.h</code> file. Add the following member method:<div><pre class="programlisting">template&lt; class T &gt;
ci::CallbackId addListener( T* listener, 
 void (T::*callback)(InteractiveObjectEvent) ){
 return mEvents.registerCb( std::bind1st( 
  std::mem_fun( callback ), listener ) );
}</pre></div></li><li class="listitem">Let's also create a method so that objects can unregister from receiving further events. Declare the following method:<div><pre class="programlisting">void removeListener( ci::CallbackId callId );</pre></div></li><li class="listitem">Let's implement the <code class="literal">removeListener</code> method. Add the following code in the <code class="literal">InteractiveObject.cpp</code> file:<div><pre class="programlisting">void InteractiveObject::removeListener( CallbackId callbackId ){
  mEvents.unregisterCb( callbackId );
}</pre></div></li><li class="listitem">Modify the<a id="id626" class="indexterm"/> methods <code class="literal">mouseDown</code>, <code class="literal">mouseUp</code>, <code class="literal">mouseDrag</code>, and <code class="literal">mouseMove</code> so that <code class="literal">mEvents</code> gets called whenever an event occurs.<a id="id627" class="indexterm"/> The implementation of these methods should be as follows:<div><pre class="programlisting">void InteractiveObject::mouseDown( MouseEvent&amp; event ){
 if( rect.contains( event.getPos() ) ){
  mPressed = true;
  mOver = false;
  pressed();
  mEvents.call( InteractiveObjectEvent( this,
   InteractiveObjectEvent::Pressed ) );
 } else {
  pressedOutside();
  mEvents.call( InteractiveObjectEvent( this, 
   InteractiveObjectEvent::PressedOutside ) );
 } 
}

void InteractiveObject::mouseUp( MouseEvent&amp; event ){
 if( rect.contains( event.getPos() ) ){
  if( mPressed ){
   mPressed = false;
   mOver = true;
   released();
   mEvents.call( InteractiveObjectEvent( this, 
    InteractiveObjectEvent::Released ) );
  }
 } else {
  mPressed = false;
  mOver = false;
  releasedOutside();
  mEvents.call( InteractiveObjectEvent( this, 
   InteractiveObjectEvent::ReleasedOutside ) );
 } 
}

void InteractiveObject::mouseDrag( MouseEvent&amp; event ){
 if( mPressed &amp;&amp; rect.contains( event.getPos() ) ){
  mPressed = true;
  mOver = false;

  dragged();
  mEvents.call( InteractiveObjectEvent( this,
  InteractiveObjectEvent::Dragged ) );
 }
}

void InteractiveObject::mouseMove( MouseEvent&amp; event ){
 if( rect.contains( event.getPos() ) ){
  if( mOver == false ){
   mPressed = false;
   mOver = true;
   rolledOver();
   mEvents.call( InteractiveObjectEvent( this, 
    InteractiveObjectEvent::RolledOver ) );
  }
 } else {
  if( mOver ){
   mPressed = false;
   mOver = false;
   rolledOut();
   mEvents.call( InteractiveObjectEvent( this, 
    InteractiveObjectEvent::RolledOut ) );
  }
 }
}</pre></div></li><li class="listitem">With our <code class="literal">InteractiveObject</code> class ready, we need to register our application class<a id="id628" class="indexterm"/> to receive its <a id="id629" class="indexterm"/>events. In your application class declaration add the following method:<div><pre class="programlisting">void receivedEvent( InteractiveObjectEvent event );</pre></div></li><li class="listitem">Let's implement the<a id="id630" class="indexterm"/> <code class="literal">receivedEvent</code> method. We will check what type of event has been received and print a message to the console.<div><pre class="programlisting">void MyApp::receivedEvent( InteractiveObjectEvent event ){
string text;
switch( event.type ){
case InteractiveObjectEvent::Pressed:
text = "Pressed event";
break;
case InteractiveObjectEvent::PressedOutside:
text = "Pressed outside event";
break;
case InteractiveObjectEvent::Released:
text = "Released event";
break;
case InteractiveObjectEvent::ReleasedOutside:
text = "Released outside event";
break;
case InteractiveObjectEvent::RolledOver:
text = "RolledOver event";
break;
case InteractiveObjectEvent::RolledOut:
text = "RolledOut event";
break;
case InteractiveObjectEvent::Dragged:
text = "Dragged event";
break;
default:
text = "Unknown event";      
    }
console() &lt;&lt; "Received " + text &lt;&lt; endl;
}</pre></div></li><li class="listitem">All that <a id="id631" class="indexterm"/>is left is to register for the events.<a id="id632" class="indexterm"/> In the <code class="literal">setup</code> method add the following code after <code class="literal">mObject</code> has been initialized:<div><pre class="programlisting">mObject-&gt;addListener( this, &amp;InteractiveObjectApp::receivedEvent );</pre></div></li><li class="listitem">Now build and run the application and use the mouse to interact with the rectangle on the window. Whenever a mouse event occurs on <code class="literal">mObject</code>, our method, <code class="literal">receivedEvent</code>, will be called.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec277"/>How it works…</h2></div></div></div><p>We are using the template class <code class="literal">ci::CallbakMgr</code> to manage our event listeners. This class takes a template with the signature of the methods that can be registered. In our previous code, we declared <code class="literal">mEvents</code> to be of type <code class="literal">ci::CallbakcMgr&lt;void(InteractiveObjectEvent)&gt;;</code> it means that only methods that return <code class="literal">void</code> and receive <code class="literal">InteractiveObejctEvent</code> as a parameter can be registered.</p><p>The template method <code class="literal">registerEvent</code> will take an object pointer and method pointer. These are bound to <code class="literal">std::function</code> using <code class="literal">std::bind1st</code> and added to <code class="literal">mEvents</code>. The method will return <code class="literal">ci::CallbackId</code> with the identification of the listener. The <code class="literal">ci::CallbackId</code> can be used to unregister listeners.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec278"/>There's more…</h2></div></div></div><p>The <code class="literal">InteractiveObject</code> class<a id="id633" class="indexterm"/> is very useful for creating user<a id="id634" class="indexterm"/> interfaces. If we want to create a <code class="literal">Button</code> class using three textures (for displaying when pressed, over, and idle), we can do so as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the <code class="literal">InteractiveObject.h</code> and <code class="literal">cinder/gl/texture.h</code> files:<div><pre class="programlisting">#include "InteractiveObject.h"
#include "cinder/gl/Texture.h"</pre></div></li><li class="listitem">Declare the following class:<div><pre class="programlisting">class Button: public InteractiveObject{
public:
Button( const ci::Rectf&amp; rect, ci::gl::Texture idleTex, 
 ci::gl::Texture overTex, ci::gl::Texture pressTex)
:InteractiveObject( rect )
{
 mIdleTex = idleTex;
 mOverTex = overTex;
 mPressTex = pressTex;
}

virtual void draw(){
 if( mPressed ){
  ci::gl::draw( mPressTex, rect );
 } else if( mOver ){
  ci::gl::draw( mOverTex, rect );
 } else {
  ci::gl::draw( mPressTex, rect );
 }
}

protected:
ci::gl::Texture mIdleTex, mOverTex, mPressTex;
};</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Creating a slider</h1></div></div></div><p>In this recipe we<a id="id635" class="indexterm"/> will learn how to create a slider UI element by extending the <code class="literal">InteractiveObject</code> class mentioned in the <em>Creating an interactive object that responds to the mouse</em> recipe of this chapter.</p><div><img src="img/8703OS_10_01.jpg" alt="Creating a slider"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec279"/>Getting ready</h2></div></div></div><p>Please refer to the <em>Creating an interactive object that responds to the mouse</em> recipe to find the <code class="literal">InteractiveObject</code> class headers and source code.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec280"/>How to do it…</h2></div></div></div><p>We will <a id="id636" class="indexterm"/>create a <code class="literal">Slider</code> class and show you how to use it.</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new header file named <code class="literal">Slider.h</code> to your project:<div><pre class="programlisting">#pragma once

#include "cinder/gl/gl.h"
#include "cinder/Color.h"

#include "InteractiveObject.h"

using namespace std;
using namespace ci;
using namespace ci::app;

class Slider : publicInteractiveObject {
public:
Slider( ) : InteractiveObject( Rectf(0,0, 100,10) ) {
 mValue = 0.f;
}
Vec2f   getPosition() { return rect.getUpperLeft(); }
void    setPosition(Vec2f position) { rect.offset(position); }
void    setPosition(float x, float y) { setPosition(Vec2f(x,y)); }
float   getWidth() { return getSize().x; }
float   getHeight() { return getSize().y; }
Vec2f   getSize() { return rect.getSize(); }
void    setSize(Vec2f size) { 
 rect.x2 = rect.x1+size.x; rect.y2 = rect.y1+size.y; 
}
void    setSize(float width, float height) { 
 setSize(Vec2f(width,height)); 
}
virtual float getValue() { return mValue; }
virtual void setValue(float value) {
 mValue = ci::math&lt;float&gt;::clamp(value);
}

virtual void pressed() {
 InteractiveObject::pressed();
 dragged();
}

virtual void dragged() {
 InteractiveObject::dragged();
 Vec2i mousePos = AppNative::get()-&gt;getMousePos();
 setValue( (mousePos.x - rect.x1) / rect.getWidth() );
}

virtual void draw() {
 gl::color(Color::gray(0.7f));
 gl::drawSolidRect(rect);
 gl::color(Color::black());
 Rectf fillRect = Rectf(rect);
 fillRect.x2 = fillRect.x1 + fillRect.getWidth() * mValue;
 gl::drawSolidRect( fillRect );
}

protected:
float mValue;
};</pre></div></li><li class="listitem">Inside<a id="id637" class="indexterm"/> the source file of your main application class, include the previously created header file:<div><pre class="programlisting">#include "Slider.h"</pre></div></li><li class="listitem">Add the new properties to your main class:<div><pre class="programlisting">shared_ptr&lt;Slider&gt; mSlider1;
shared_ptr&lt;Slider&gt; mSlider2;
shared_ptr&lt;Slider&gt; mSlider3;</pre></div></li><li class="listitem">Inside<a id="id638" class="indexterm"/> the <code class="literal">setup</code> method do the initialization of the <code class="literal">slider</code> objects:<div><pre class="programlisting">mSlider1 = shared_ptr&lt;Slider&gt;( new Slider() );
mSlider1-&gt;setPosition(70.f, 20.f);
mSlider1-&gt;setSize(200.f, 10.f);
mSlider1-&gt;setValue(0.75f);

mSlider2 = shared_ptr&lt;Slider&gt;( new Slider() );
mSlider2-&gt;setPosition(70.f, 35.f);
mSlider2-&gt;setValue(0.25f);

mSlider3 = shared_ptr&lt;Slider&gt;( new Slider() );
mSlider3-&gt;setPosition(70.f, 50.f);
mSlider3-&gt;setValue(0.5f);</pre></div></li><li class="listitem">Add the following code for drawing sliders inside your <code class="literal">draw</code> method:<div><pre class="programlisting">gl::enableAlphaBlending();
gl::clear( Color::white() );
gl::setViewport(getWindowBounds());
gl::setMatricesWindow(getWindowSize());

mSlider1-&gt;draw();
gl::drawStringRight("Value 1:", mSlider1-&gt;getPosition()+Vec2f(-5.f, 3.f), Color::black());
gl::drawString(toString(mSlider1-&gt;getValue()), mSlider1-&gt;getPosition()+Vec2f(mSlider1-&gt;getWidth()+5.f, 3.f), Color::black());

mSlider2-&gt;draw();
gl::drawStringRight("Value 2:", mSlider2-&gt;getPosition()+Vec2f(-5.f, 3.f), Color::black());
gl::drawString(toString(mSlider2-&gt;getValue()), mSlider2-&gt;getPosition()+Vec2f(mSlider2-&gt;getWidth()+5.f, 3.f), Color::black());

mSlider3-&gt;draw();
gl::drawStringRight("Value 3:", mSlider3-&gt;getPosition()+Vec2f(-5.f, 3.f), Color::black());
gl::drawString(toString(mSlider3-&gt;getValue()), mSlider3-&gt;getPosition()+Vec2f(mSlider3-&gt;getWidth()+5.f, 3.f), Color::black());</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec281"/>How it works…</h2></div></div></div><p>We created the <code class="literal">Slider</code> class by inheriting and overriding the <code class="literal">InteractiveObject</code> methods and<a id="id639" class="indexterm"/> properties. In step 1, we extended it with methods for controlling the position and dimensions of the <code class="literal">slider</code> object. The methods <code class="literal">getValue</code> and <code class="literal">setValue</code> can be used to retrieve or set the actual state of <code class="literal">slider</code>, which can vary from <code class="literal">0</code> to <code class="literal">1</code>.</p><p>In step 4, you can find the initialization of example sliders by setting the initial position, size, and value just after creating the <code class="literal">Slider</code> object. We are drawing example sliders along with captions and information about current state.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec282"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The recipe <em>Creating interactive object that responds to the mouse.</em></li><li class="listitem" style="list-style-type: disc">The recipe <em>Dragging scaling, and rotating objects using multi-touch</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Creating a responsive text box</h1></div></div></div><p>In this recipe we<a id="id640" class="indexterm"/> will learn how to create a text box that responds to the user's keystrokes. It will be active when pressed over by the mouse and inactive when the mouse is released outside the box.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec283"/>Getting ready</h2></div></div></div><p>Grab the following <a id="id641" class="indexterm"/>files from the recipe <em>Creating an interactive object that responds to the mouse </em>and add them to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveObject.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveObject.cpp</code></li></ul></div><p>Create and add the following files to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveTextBox.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">InteractiveTextBox.cpp</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec284"/>How to do it…</h2></div></div></div><p>We will create an <code class="literal">InteractiveTextBox</code> class that inherits from <code class="literal">InteractiveObject</code> and adds text functionality.</p><div><ol class="orderedlist arabic"><li class="listitem">Go to the file <code class="literal">InteractiveTextBox.h</code> and add the <code class="literal">#pragma once</code> macro and include the necessary files.<div><pre class="programlisting">#pragma once

#include "InteractiveObject.h"
#include "cinder/Text.h"
#include "cinder/gl/Texture.h"
#include "cinder/app/KeyEvent.h"
#include "cinder/app/AppBasic.h"</pre></div></li><li class="listitem">Now declare <a id="id642" class="indexterm"/>the <code class="literal">InteractiveTextBox</code> class, making it a subclass of <code class="literal">InteractiveObject</code> with the following members and methods:<div><pre class="programlisting">class InteractiveTextBox: public InteractiveObject{
public:
    InteractiveTextBox( const ci::Rectf&amp; rect );

    virtual void draw();
    virtual void pressed();
    virtual void releasedOutside();

    void keyDown( ci::app::KeyEvent&amp; event );
    protected:
        ci::TextBox mTextBox;
    std::string mText;
    bool mActive;
    bool mFirstText;
};</pre></div></li><li class="listitem">Now go to <code class="literal">InteractiveTextBox.cpp</code> and include the <code class="literal">InteractiveTextBox.h</code> file and add the following <code class="literal">using</code> statements:<div><pre class="programlisting">#include "InteractiveTextBox.h"

using namespace std;
using namespace ci;
using namespace ci::app;</pre></div></li><li class="listitem">Now let's implement the constructor by initializing the parent class and setting up the internal <code class="literal">ci::TextBox</code>.<div><pre class="programlisting">InteractiveTextBox::InteractiveTextBox( const Rectf&amp; rect ):
InteractiveObject( rect )
{
  mActive = false;
  mText = "Write some text";
  mTextBox.setText( mText );
  mTextBox.setFont( Font( "Arial", 24 ) );
  mTextBox.setPremultiplied( true );
  mTextBox.setSize( Vec2i( rect.getWidth(), rect.getHeight() ) );
  mTextBox.setBackgroundColor( Color::white() );
  mTextBox.setColor( Color::black() );
  mFirstText = true;
}</pre></div></li><li class="listitem">In the <a id="id643" class="indexterm"/><code class="literal">InteractiveTextBox::draw</code> method we will set the background color of <code class="literal">mTextBox</code> depending if it is active or not. We will also render <code class="literal">mTextBox</code> into <code class="literal">ci::gl::Texture</code> and draw it.<div><pre class="programlisting">void InteractiveTextBox::draw(){
 if( mActive ){
  mTextBox.setBackgroundColor( Color( 0.7f, 0.7f, 1.0f ) );
 } else {
  mTextBox.setBackgroundColor( Color::white() );
 }
 gl::color( Color::white() );
 gl::Texture texture = mTextBox.render();
 gl::draw( texture, rect );
}</pre></div></li><li class="listitem">Now let's implement the overridden methods <code class="literal">pressed</code> and <code class="literal">releasedOutside</code> to define the value of <code class="literal">mActive</code>.<div><pre class="programlisting">void InteractiveTextBox::pressed(){
  mActive = true;
}

void InteractiveTextBox::releasedOutside(){
  mActive = false;
}</pre></div></li><li class="listitem">Finally, we need to implement the<a id="id644" class="indexterm"/> <code class="literal">keyPressed</code> method.<p>If <code class="literal">mActive</code> is false this method will simply return. Otherwise, we will remove the last letter of <code class="literal">mText</code> if the key released was the <em>Backspace</em> key, or, add the corresponding letter if any other key was pressed.</p><div><pre class="programlisting">void InteractiveTextBox::keyDown( KeyEvent&amp; event ){
 if( mActive == false ) return;
 if( mFirstText ){
  mText = "";
  mFirstText = false;</pre></div><div><pre class="programlisting"> }
 if( event.getCode() == KeyEvent::KEY_BACKSPACE ){
  if( mText.size() &gt; 0 ){
   mText = mText.substr( 0, mText.size()-1 );
  }
 } else {
  const char character = event.getChar();
  mText += string( &amp;character, 1 );
 }
 mTextBox.setText( mText );
}</pre></div></li><li class="listitem">Now move to your application class source file and include the following file and the <code class="literal">using</code> statements:<div><pre class="programlisting">#include "InteractiveTextBox.h"

using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></li><li class="listitem">In your <a id="id645" class="indexterm"/>application class declare the following member:<div><pre class="programlisting">shared_ptr&lt;InteractiveTextBox&gt; mTextBox;</pre></div></li><li class="listitem">Let's initialize <code class="literal">mTextBox</code> in the <code class="literal">setup</code> method:<div><pre class="programlisting">Rectf rect( 100.0f, 100.0f, 300.0f, 200.0f );
mTextBox = shared_ptr&lt;InteractiveTextBox&gt;( new InteractiveTextBox( rect ) );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method we will clear the background with black, enable <code class="literal">AlphaBlending</code>, and draw our <code class="literal">mTextBox</code>:<div><pre class="programlisting">  gl::enableAlphaBlending();
  gl::clear( Color( 0, 0, 0 ) );
  mTextBox-&gt;draw();</pre></div></li><li class="listitem">We now need to declare the following mouse event handlers:<div><pre class="programlisting">void mouseDown( MouseEvent event );
void mouseUp( MouseEvent event );
void mouseDrag( MouseEvent event );
void mouseMove( MouseEvent event );</pre></div></li><li class="listitem">And implement them by calling the respective mouse event handler of <code class="literal">mTextBox</code>:<div><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mTextBox-&gt;mouseDown( event );
}

void MyApp::mouseUp( MouseEvent event ){
  mTextBox-&gt;mouseUp( event );
}

void MyApp::mouseDrag( MouseEvent event ){
  mTextBox-&gt;mouseDrag( event );
}

void MyApp::mouseMove( MouseEvent event ){
  mTextBox-&gt;mouseMove( event );
}</pre></div></li><li class="listitem">Now<a id="id646" class="indexterm"/> we just need to do the same with the key released event handler. Start by declaring it:<div><pre class="programlisting">void keyDown( KeyEvent event );</pre></div></li><li class="listitem">And in it's implementation we will call the <code class="literal">keyUp</code> method of <code class="literal">mTextBox</code>.<div><pre class="programlisting">void InteractiveObjectApp::keyDown( KeyEvent event ){
  mTextBox-&gt;keyDown( event );
}</pre></div></li><li class="listitem">Now build and run the application. You will see a white textbox with the phrase <strong>Write some text</strong>. Press the text box and write some text. Click outside the text box to set the textbox as inactive.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec285"/>How it works…</h2></div></div></div><p>Internally, <a id="id647" class="indexterm"/>our <code class="literal">InteractiveTextBox</code> uses a <code class="literal">ci::TextBox</code> object. This class manages the text inside a box with a specified width and height. We take advantage of that and update the text according to the keys that the user presses.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Dragging, scaling, and rotating objects using multi-touch</h1></div></div></div><p>In this recipe, we<a id="id648" class="indexterm"/> will learn how to create objects responsible to <a id="id649" class="indexterm"/>multi-touch gestures, such as dragging, scaling, or rotating by extending the <code class="literal">InteractiveObject</code> class mentioned in the <em>Creating an interactive object that responds to the mouse</em> recipe of this chapter.<a id="id650" class="indexterm"/> We are going to build an iOS application that uses iOS device multi-touch capabilities.</p><div><img src="img/8703OS_10_02.jpg" alt="Dragging, scaling, and rotating objects using multi-touch"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec286"/>Getting ready</h2></div></div></div><p>Please<a id="id651" class="indexterm"/> refer to the <em>Creating an interactive object that responds to the mouse</em> recipe to find the <code class="literal">InteractiveObject</code> <a id="id652" class="indexterm"/>class headers and source code and <em>Creating a project for an iOS touch application recipe from</em> <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec287"/>How to do it…</h2></div></div></div><p>We will create<a id="id653" class="indexterm"/> an iPhone application with sample objects that can be dragged, scaled, or rotated.</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new header file named <code class="literal">TouchInteractiveObject.h</code> to your project:<div><pre class="programlisting">#pragma once

#include "cinder/app/AppNative.h"
#include "cinder/gl/gl.h"
#include "cinder/Color.h"

#include "InteractiveObject.h"

using namespace std;
using namespace ci;
using namespace ci::app;

class TouchInteractiveObject : public InteractiveObject {
public:
TouchInteractiveObject( const Vec2f&amp; position, 
 const Vec2f&amp; size );
bool    touchesBegan(TouchEvent event);
bool    touchesMoved(TouchEvent event);
bool    touchesEnded(TouchEvent event);
Vec2f   getPosition() { return position; }
void    setPosition(Vec2f position) { this-&gt;position = position; }
void    setPosition(float x, float y) { setPosition(Vec2f(x,y)); }
float   getWidth() { return getSize().x; }
float   getHeight() { return getSize().y; }
Vec2f   getSize() { return rect.getSize(); }
void    setSize(Vec2f size) { 
 size.x = max(30.f,size.x); 
 size.y = max(30.f,size.y); 
 rect = Rectf(getPosition()-size*0.5f,getPosition()+size*0.5f);
}
void    setSize(float width, float height) {
 setSize(Vec2f(width,height)); 
}
float   getRotation() { return rotation; }
void    setRotation( float rotation ) { 
 this-&gt;rotation = rotation;
}
virtual void draw();

protected:
Vec2f   position;
float   rotation;
bool    scaling;

unsigned int    dragTouchId;
unsigned int    scaleTouchId;
};</pre></div></li><li class="listitem">Add <a id="id654" class="indexterm"/>a new source file<a id="id655" class="indexterm"/> named <code class="literal">TouchInteractiveObject.cpp</code> to your project and include the previously created header file by adding the following code line:<div><pre class="programlisting">#include "TouchInteractiveObject.h"</pre></div></li><li class="listitem">Implement <a id="id656" class="indexterm"/>the constructor of <code class="literal">TouchInteractiveObject</code>:<div><pre class="programlisting">TouchInteractiveObject::TouchInteractiveObject( 
 const Vec2f&amp; position, const Vec2f&amp; size )
  : InteractiveObject( Rectf() )
{
 scaling = false;
 rotation = 0.f;
 setPosition(position);
 setSize(size);
 AppNative::get()-&gt;registerTouchesBegan(this, 
  &amp;TouchInteractiveObject::touchesBegan);
 AppNative::get()-&gt;registerTouchesMoved(this, 
  &amp;TouchInteractiveObject::touchesMoved);
 AppNative::get()-&gt;registerTouchesEnded(this, 
  &amp;TouchInteractiveObject::touchesEnded);
}</pre></div></li><li class="listitem">Implement the handlers <a id="id657" class="indexterm"/>for touch events:<div><pre class="programlisting">bool TouchInteractiveObject::touchesBegan(TouchEvent event)</pre></div><div><pre class="programlisting">{
 Vec2f bVec1 = getSize()*0.5f;
 Vec2f bVec2 = Vec2f(getWidth()*0.5f, -getHeight()*0.5f);
 bVec1.rotate((rotation) * (M_PI/180.f));
 bVec2.rotate((rotation) * (M_PI/180.f));
 Vec2f bVec;
 bVec.x = math&lt;float&gt;::max( abs(bVec1.x), abs(bVec2.x));
 bVec.y = math&lt;float&gt;::max( abs(bVec1.y), abs(bVec2.y));
 Area activeArea = Area(position-bVec, position+bVec);
 for (vector&lt;TouchEvent::Touch&gt;::const_iterator it 
   = event.getTouches().begin(); 
   it != event.getTouches().end(); ++it) {
  if(activeArea.contains( it-&gt;getPos() )) {
   if(mPressed) {
    scaling = true;
    scaleTouchId = it-&gt;getId();
   } else {
    mPressed = true;
    dragTouchId = it-&gt;getId();
   }
  } 
 }
 return false;
}

bool TouchInteractiveObject::touchesMoved(TouchEvent event)
{
 if(!mPressed) return false;
 const TouchEvent::Touch* dragTouch;
 const TouchEvent::Touch* scaleTouch;
 for (vector&lt;TouchEvent::Touch&gt;::const_iterator it 
   = event.getTouches().begin(); 
   it != event.getTouches().end(); ++it) {
  if (scaling &amp;&amp; scaleTouchId == it-&gt;getId()) {
   scaleTouch = &amp;(*it);
  }
  if(dragTouchId == it-&gt;getId()) {
   dragTouch = &amp;(*it);
  }
 }
 if(scaling) {
  Vec2f prevPos = (dragTouch-&gt;getPrevPos() 
   + scaleTouch-&gt;getPrevPos()) * 0.5f;
  Vec2f curPos = (dragTouch-&gt;getPos() 
   + scaleTouch-&gt;getPos())*0.5f;
  setPosition(getPosition() + curPos - prevPos);
  Vec2f prevVec = dragTouch-&gt;getPrevPos() 
   - scaleTouch-&gt;getPrevPos();
  Vec2f curVec = dragTouch-&gt;getPos() - scaleTouch-&gt;getPos();

  float scaleFactor = (curVec.length() - prevVec.length()) 
   / prevVec.length();
  float sizeFactor = prevVec.length() / getSize().length();
  setSize(getSize() + getSize() * sizeFactor * scaleFactor);

  float angleDif = atan2(curVec.x, curVec.y) 
   - atan2(prevVec.x, prevVec.y);
  rotation += -angleDif * (180.f/M_PI);
 } else {
  setPosition(getPosition() + dragTouch-&gt;getPos() 
   - dragTouch-&gt;getPrevPos() );
 }
 return false;
}

bool TouchInteractiveObject::touchesEnded(TouchEvent event)
{
 if(!mPressed) return false;
 for (vector&lt;TouchEvent::Touch&gt;::const_iterator it 
   = event.getTouches().begin(); 
   it != event.getTouches().end(); ++it) {
  if(dragTouchId == it-&gt;getId()) {
   mPressed = false;
   scaling = false;
  }
  if(scaleTouchId == it-&gt;getId()) {
   scaling = false;
  } 
 }
 return false;
}</pre></div></li><li class="listitem">Now, <a id="id658" class="indexterm"/>implement the basic <code class="literal">draw</code> method for <code class="literal">TouchInteractiveObjects</code>:<div><pre class="programlisting">void TouchInteractiveObject::draw() {
 Rectf locRect = Rectf(Vec2f::zero(), getSize());
 gl::pushMatrices();
 gl::translate(getPosition());
 gl::rotate(getRotation());
 gl::pushMatrices();
 gl::translate(-getSize()*0.5f);
 gl::color(Color::gray( mPressed ? 0.6f : 0.9f ));
 gl::drawSolidRect(locRect);
 gl::color(Color::black());
 gl::drawStrokedRect(locRect);
 gl::popMatrices();
 gl::popMatrices();
}</pre></div></li><li class="listitem">Here is the<a id="id659" class="indexterm"/> class, which inherits all the features of <code class="literal">TouchInteractiveObject</code>, but overrides the <code class="literal">draw</code> method and, in this case,<a id="id660" class="indexterm"/> we want our interactive object to be a circle. Add the following class definition to your main source file:<div><pre class="programlisting">class Circle : publicTouchInteractiveObject {
public:
 Circle(const Vec2f&amp; position, const Vec2f&amp; size)
   : TouchInteractiv eObject(position, size) {}
 
 virtual void draw() {
  gl::color(Color::gray( mPressed ? 0.6f : 0.9f ));
  gl::drawSolidEllipse(getPosition(), 
   getSize().x*0.5f, getSize().y*0.5f);
  gl::color(Color::black());
  gl::drawStrokedEllipse(getPosition(), 
   getSize().x*0.5f, getSize().y*0.5f);
 } 
};</pre></div></li><li class="listitem">Now take a<a id="id661" class="indexterm"/> look at your main application class file. Include the necessary header files:<div><pre class="programlisting">#include "cinder/app/AppNative.h"
#include "cinder/Camera.h"
#include "cinder/Rand.h"

#include "TouchInteractiveObject.h"</pre></div></li><li class="listitem">Add the <code class="literal">typedef</code> declaration:<div><pre class="programlisting">typedef shared_ptr&lt;TouchInteractiveObject&gt; tio_ptr;</pre></div></li><li class="listitem">Add <a id="id662" class="indexterm"/>members to your application class to handle the objects:<div><pre class="programlisting">tio_ptr mObj1;
tio_ptr mCircle;</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method initialize the objects:<div><pre class="programlisting">mObj1 = tio_ptr( new TouchInteractiveObject(getRandPos(), Vec2f(100.f,100.f)) );
mCircle = tio_ptr( new Circle(getRandPos(), Vec2f(100.f,100.f)) );</pre></div></li><li class="listitem">The <code class="literal">draw</code> method is simple and looks as follows:<div><pre class="programlisting">gl::setMatricesWindow(getWindowSize());
gl::clear( Color::white() );
mObj1-&gt;draw();
mCircle-&gt;draw();</pre></div></li><li class="listitem">As you can see in the <code class="literal">setup</code> method we are using the function <code class="literal">getRandPos</code>, which returns a random position in screen boundaries with some margin:<div><pre class="programlisting">Vec2f MainApp::getRandPos()
{
  return Vec2f( randFloat(30.f, getWindowWidth()-30.f),  randFloat(30.f, getWindowHeight()-30.f));
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec288"/>How it works…</h2></div></div></div><p>We created the <a id="id663" class="indexterm"/>
<code class="literal">TouchInteractiveObject</code> class by inheriting and overriding the <code class="literal">InteractiveObject</code> methods and properties. We also extended it with methods for controlling position and dimensions.</p><p>In step 3, we are initializing properties and registering callbacks for touch events. The next step is to<a id="id664" class="indexterm"/> implement these callbacks. On the <a id="id665" class="indexterm"/>
<code class="literal">touchesBegan</code> event, we are checking if the object is touched by any of the new touches, but all the calculations of movements and gestures happen during <code class="literal">touchesMoved</code> event.</p><p>In step 6, you can see how simple it is to change the appearance and keep all the interactive capabilities of<a id="id666" class="indexterm"/> <code class="literal">TouchInteractiveObject</code> by overriding the <code class="literal">draw</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec289"/>There is more…</h2></div></div></div><p>You can notice <a id="id667" class="indexterm"/>an issue that you are dragging multiple objects while they are overlapping. To solve that problem, we will add a simple object activation manager.</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new class definition to your Cinder application:<div><pre class="programlisting">class ObjectsManager {
public:
    ObjectsManager() { }
    
    void addObject( tio_ptr obj) {
        objects.push_front(obj);
    }
    
    void update() {
        bool rel = false;
        deque&lt;tio_ptr&gt;::const_iterator it;
        for(it = objects.begin(); it != objects.end(); ++it) {
            if( rel ) 
                (*it)-&gt;release();
            else if( (*it)-&gt;isActive() )
                rel = true;
        }
    }
    
protected:
    deque&lt;tio_ptr&gt; objects;
};</pre></div></li><li class="listitem">Add a new member to your application's main class:<div><pre class="programlisting">shared_ptr&lt;ObjectsManager&gt; mObjMgr;</pre></div></li><li class="listitem">At the end of the <a id="id668" class="indexterm"/><code class="literal">setup</code> method initialize <code class="literal">mObjMgr</code>, which is the object's manager, and add <a id="id669" class="indexterm"/>the previously initialized interactive objects:<div><pre class="programlisting">mObjMgr = shared_ptr&lt;ObjectsManager&gt;( new ObjectsManager() );
mObjMgr-&gt;addObject( mObj1 );
mObjMgr-&gt;addObject( mCircle );</pre></div></li><li class="listitem">Add the <code class="literal">update</code> <a id="id670" class="indexterm"/>method to your main class as follows:<div><pre class="programlisting">void MainApp::update()
{
    mObjMgr-&gt;update();
}</pre></div></li><li class="listitem">Add two<a id="id671" class="indexterm"/> new methods to the <code class="literal">TouchInteractiveObject</code> class:<div><pre class="programlisting">bool    isActive() { return mPressed; }
void    release() { mPressed = false; }</pre></div></li></ol></div></div></div></body></html>