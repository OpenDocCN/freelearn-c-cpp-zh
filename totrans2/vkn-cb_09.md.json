["```cpp\nvkCmdClearColorImage( command_buffer, image, image_layout, &clear_color, static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data() );\n\n```", "```cpp\nvkCmdClearDepthStencilImage( command_buffer, image, image_layout, &clear_value, static_cast<uint32_t>(image_subresource_ranges.size()), image_subresource_ranges.data() );\n\n```", "```cpp\nvkCmdClearAttachments( command_buffer, static_cast<uint32_t>(attachments.size()), attachments.data(), static_cast<uint32_t>(rects.size()), rects.data() );\n\n```", "```cpp\nstruct VertexBufferParameters { \n  VkBuffer      Buffer; \n  VkDeviceSize  MemoryOffset; \n};\n\n```", "```cpp\nstd::vector<VkBuffer>     buffers; \nstd::vector<VkDeviceSize> offsets; \nfor( auto & buffer_parameters : buffers_parameters ) { \n  buffers.push_back( buffer_parameters.Buffer ); \n  offsets.push_back( buffer_parameters.MemoryOffset ); \n} \nvkCmdBindVertexBuffers( command_buffer, first_binding, static_cast<uint32_t>(buffers_parameters.size()), buffers.data(), offsets.data() );\n\n```", "```cpp\nvkCmdBindIndexBuffer( command_buffer, buffer, memory_offset, index_type );\n\n```", "```cpp\n      vkCmdPushConstants( command_buffer, pipeline_layout, \n      pipeline_stages, offset, size, data )\n\n```", "```cpp\nstd::array<float, 4> color = { 0.0f, 0.7f, 0.4f, 0.1f }; \nProvideDataToShadersThroughPushConstants( CommandBuffer, *PipelineLayout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, static_cast<uint32_t>(sizeof( color[0] ) * color.size()), &color[0] );\n\n```", "```cpp\nvkCmdPushConstants( command_buffer, pipeline_layout, pipeline_stages, offset, size, data );\n\n```", "```cpp\nvkCmdSetViewport( command_buffer, first_viewport, static_cast<uint32_t>(viewports.size()), viewports.data() );\n\n```", "```cpp\nvkCmdSetScissor( command_buffer, first_scissor, static_cast<uint32_t>(scissors.size()), scissors.data() );\n\n```", "```cpp\nvkCmdSetLineWidth( command_buffer, line_width );\n\n```", "```cpp\nvkCmdSetDepthBias( command_buffer, constant_factor, clamp, slope_factor );\n\n```", "```cpp\nvkCmdSetBlendConstants( command_buffer, blend_constants.data() );\n\n```", "```cpp\nvkCmdDraw( command_buffer, vertex_count, instance_count, first_vertex, first_instance );\n\n```", "```cpp\nvkCmdDrawIndexed( command_buffer, index_count, instance_count, first_index, vertex_offset, first_instance );\n\n```", "```cpp\nvkCmdDispatch( command_buffer, x_size, y_size, z_size );\n\n```", "```cpp\nvkCmdExecuteCommands( command_buffer, static_cast<uint32_t>(secondary_command_buffers.size()), secondary_command_buffers.data() );\n\n```", "```cpp\nstruct Mesh { \n  std::vector<float>    Data; \n  std::vector<uint32_t> VertexOffset; \n  std::vector<uint32_t> VertexCount; \n};\n\n```", "```cpp\nif( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { \n  return false; \n}\n\n```", "```cpp\nif( present_queue_family_index != graphics_queue_family_index ) { \n  ImageTransition image_transition_before_drawing = { \n    swapchain_image, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    present_queue_family_index, \n    graphics_queue_family_index, \n    VK_IMAGE_ASPECT_COLOR_BIT \n  }; \n  SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, { image_transition_before_drawing } ); \n}\n\n```", "```cpp\nBeginRenderPass( command_buffer, render_pass, framebuffer, { { 0, 0 }, framebuffer_size }, clear_values, VK_SUBPASS_CONTENTS_INLINE ); \n\nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphics_pipeline );\n\n```", "```cpp\nVkViewport viewport = { \n  0.0f, \n  0.0f, \n  static_cast<float>(framebuffer_size.width), \n  static_cast<float>(framebuffer_size.height), \n  0.0f, \n  1.0f, \n}; \nSetViewportStateDynamically( command_buffer, 0, { viewport } ); \n\nVkRect2D scissor = { \n  { \n    0, \n    0 \n  }, \n  { \n    framebuffer_size.width, \n    framebuffer_size.height \n  } \n}; \nSetScissorStateDynamically( command_buffer, 0, { scissor } ); \n\nBindVertexBuffers( command_buffer, first_vertex_buffer_binding, vertex_buffers_parameters );\n\n```", "```cpp\nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, index_for_first_descriptor_set, descriptor_sets, {} );\n\n```", "```cpp\nfor( size_t i = 0; i < geometry.Parts.size(); ++i ) { \n  DrawGeometry( command_buffer, geometry.Parts[i].VertexCount,   instance_count, geometry.Parts[i].VertexOffset, first_instance ); \n}\n\n```", "```cpp\nEndRenderPass( command_buffer ); \n\nif( present_queue_family_index != graphics_queue_family_index ) { \n  ImageTransition image_transition_before_present = { \n    swapchain_image, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    graphics_queue_family_index, \n    present_queue_family_index, \n    VK_IMAGE_ASPECT_COLOR_BIT \n  }; \n  SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, { image_transition_before_present } ); \n} \n\nif( !EndCommandBufferRecordingOperation( command_buffer ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct CommandBufferRecordingThreadParameters { \nVkCommandBuffer                         CommandBuffer; \n\n  std::function<bool( VkCommandBuffer )>  RecordingFunction; \n\n};\n\n```", "```cpp\nstd::vector<std::thread> threads( threads_parameters.size() ); \nfor( size_t i = 0; i < threads_parameters.size(); ++i ) { \n  threads[i] = std::thread::thread( threads_parameters[i].RecordingFunction, threads_parameters[i].CommandBuffer ); \n}\n\n```", "```cpp\nstd::vector<VkCommandBuffer> command_buffers( threads_parameters.size() ); \nfor( size_t i = 0; i < threads_parameters.size(); ++i ) { \n  threads[i].join(); \n  command_buffers[i] = threads_parameters[i].CommandBuffer; \n} \n\nif( !SubmitCommandBuffersToQueue( queue, wait_semaphore_infos, command_buffers, signal_semaphores, fence ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nuint32_t image_index; \nif( !AcquireSwapchainImage( logical_device, swapchain, image_acquired_semaphore, VK_NULL_HANDLE, image_index ) ) { \n  return false; \n} \n\nstd::vector<VkImageView> attachments = { swapchain_image_views[image_index] }; \nif( VK_NULL_HANDLE != depth_attachment ) { \n  attachments.push_back( depth_attachment ); \n} \nif( !CreateFramebuffer( logical_device, render_pass, attachments, swapchain_size.width, swapchain_size.height, 1, *framebuffer ) ) { \n  return false; \n} \n\nif( !record_command_buffer( command_buffer, image_index, *framebuffer ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<WaitSemaphoreInfo> wait_semaphore_infos = wait_infos; \nwait_semaphore_infos.push_back( { \n  image_acquired_semaphore, \n  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT \n} ); \nif( !SubmitCommandBuffersToQueue( graphics_queue, wait_semaphore_infos, { command_buffer }, { ready_to_present_semaphore }, finished_drawing_fence ) ) { \n  return false; \n} \n\nPresentInfo present_info = { \n  swapchain, \n  image_index \n}; \nif( !PresentImage( present_queue, { ready_to_present_semaphore }, { present_info } ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct FrameResources { \n  VkCommandBuffer             CommandBuffer; \n  VkDestroyer<VkSemaphore>    ImageAcquiredSemaphore; \n  VkDestroyer<VkSemaphore>    ReadyToPresentSemaphore; \n  VkDestroyer<VkFence>        DrawingFinishedFence; \n  VkDestroyer<VkImageView>    DepthAttachment; \n  VkDestroyer<VkFramebuffer>  Framebuffer; \n};\n\n```", "```cpp\nstatic uint32_t frame_index = 0; \nFrameResources & current_frame = frame_resources[frame_index]; \n\nif( !WaitForFences( logical_device, { *current_frame.DrawingFinishedFence }, false, 2000000000 ) ) { \n  return false; \n} \nif( !ResetFences( logical_device, { *current_frame.DrawingFinishedFence } ) ) { \n  return false; \n}\n\n```", "```cpp\nInitVkDestroyer( logical_device, current_frame.Framebuffer ); \n\nif( !PrepareSingleFrameOfAnimation( logical_device, graphics_queue, present_queue, swapchain, swapchain_size, swapchain_image_views, \n*current_frame.DepthAttachment, wait_infos, *current_frame.ImageAcquiredSemaphore, *current_frame.ReadyToPresentSemaphore, \n*current_frame.DrawingFinishedFence, record_command_buffer, current_frame.CommandBuffer, render_pass, current_frame.Framebuffer ) ) { \n  return false; \n} \n\nframe_index = (frame_index + 1) % frame_resources.size(); \nreturn true;\n\n```", "```cpp\nframe_index = (frame_index + 1) % frame_resources.size(); \nreturn true;\n\n```"]