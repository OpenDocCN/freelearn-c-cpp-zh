- en: Chapter 10. Some Advanced Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn different techniques that can be used
    either together or independently. Each technique developed here is a new tool
    for your future or current projects. We are going to use EEPROMs to provide Arduino
    boards with a small memory system that is readable and writable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to test communications between the Arduino boards themselves,
    use GPS modules, make our boards autonomous, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Data storage with EEPROMs
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we learned and used the Arduino boards as totally electricity dependent
    devices. Indeed, they need current in order to execute tasks compiled in our firmware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: As we noticed, when we switch them off, every living variable and data is lost.
    Fortunately, the firmware isn't.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Three native pools of memory on the Arduino boards
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino boards based on the ATmega168 chipset own three different pools
    of memory:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SRAM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EEPROM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flash memory is also named program space. This is the place where our firmware
    is stored.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The **SRAM** stands for **Static** **Random** **Access** **Memory** and is the
    place where the running firmware stores, reads, and manipulates variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The **EEPROM** stands for **Electrically** **Erasable** **Programmable** **Read-Only**
    **Memory**. It is the place where we, programmers, can store things for long-term
    purposes. This is the place where our firmware sits, and anything in the EEPROM
    isn't erased should the board be switched off.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'ATmega168 has:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 16000 bytes of Flash (2000 bytes are used for the bootloader)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1024 bytes of SRAM
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 512 bytes of EEPROM
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we won't discuss the fact that we have to take care of the memory while
    programming; we will do that in the last chapter of this book [Chapter 13](ch13.html
    "Chapter 13. Improving your C Programming and Creating Libraries"), *Improving
    your C Programming and Creating Libraries*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part here is the EEPROM space. It allows us to store data on
    the Arduino and we didn't even know that until now. Let's test the EEPROM native
    library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Writing and reading with EEPROM core library
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Basically, this example doesn''t require any wiring. We are going to use the
    internal EEPROM of 512 bytes. Here is some code that reads all the bytes of the
    EEPROM and prints it to the computer''s Serial Monitor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is in the public domain and provided as an example for the EEPROM
    library. You can find it in your `examples` folder in the **File** menu of the
    Arduino IDE, under the folder **Examples** | **EEPROM**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: At first, we include the library itself. Then we define a variable for storing
    the current read address. We initialize it at 0, the beginning of the memory register.
    We also define a variable as a byte type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup()` function, we initialize the serial communication. In `loop()`,
    we read the byte at the current address and store it in the variable `value`.
    Then we print the result to the serial port. Notice the `\t` value in the second
    `Serial.print()` statement. This stands for tabulation (as in the *Tab* key on
    a computer keyboard). This writes tabulation to the serial port between the current
    address printed and the value itself in order to make things more readable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We advance to the next address. We check if the address equals 512, if that
    is the case, we restart the address counter to 0 and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We add a small delay. We can write bytes in the same way using `EEPROM.write(addr,
    val);` where `addr` is the address where you want to write the value `val`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, these are bytes (8 bits = 256 possible values). Read and write operations
    are quite easy on the internal EEPROM, so let's see how it goes with external
    EEPROMs wired by an I2C connection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: External EEPROM wiring
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of cheap EEPROM components available in electronics markets.
    We are going to use the classic 24LC256, an EEPROM implementing I2C for read/write
    operations and providing 256 kilobits (32 kilobytes) of memory space.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it at Sparkfun: [https://www.sparkfun.com/products/525](https://www.sparkfun.com/products/525).
    Here is how we can wire its bigger cousin 24LC1025 (1024k bytes) using I2C:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![External EEPROM wiring](img/7584_10_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: A 24LC256 EEPROM wired to the Arduino via I2C communication
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding diagram is the one shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![External EEPROM wiring](img/7584_10_002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: A 24LC256 EEPROM wired to the Arduino via I2C communication
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe the EEPROM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**A0**, **A1**, and **A2** are chip address inputs. **+V** and **0V** are **5V**
    and ground. WP is the write protect pin. If it is wired to ground, we can write
    to the EEPROM. If it is wired to 5V, we cannot.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'SCL and SDA are the two wires involved in the I2C communication and are wired
    to **SDA** / **SCL**. **SDA** stands for **Serial** **Data** **Line** and **SCL**
    stands for **Serial** **Clock** **Line**. Be careful about the SDA/SCL pins. The
    following depends on your board:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino UNO before R3 and Ethernet's I2C pins are A4 (SDA) and A5 (SCL)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mega2560, pins 20 (SDA) and 21 (SCL)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leonardo, pin 2 (SDA) and pin 3 (SCL)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due Pins, pins 20 (SDA) and 21 (SCL) and also another one SDA1 and SCL1
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to the EEPROM
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The underlying library that we can use for I2C purposes is `Wire`. You can find
    it directly in the Arduino core. This library takes care of the raw bits, but
    we have to look at it more closely.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Wire` library takes care of many things for us. Let''s check the code
    in the folder `Chapter10/readWriteI2C`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We include the `Wire` library at first. Then we define 2 functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`eepromWrite()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eepromRead()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions write and read bytes to and from the external EEPROM using the
    `Wire` library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The `Setup()` function instantiates the `Wire` and the `Serial` communication.
    Then using a `for` loop, we write data to a specific address. This data is basically
    a character 'a' plus a number. This structure writes characters from a to a +
    9 which means 'j'. This is an example to show how we can store things quickly,
    but of course we could have written more meaningful data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We then print a message to the Serial Monitor in order to tell the user that
    Arduino has finished writing to the EEPROM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In the `loop()` function, we then read the EEPROM. It is quite similar to the
    EEPROM library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we still haven''t spoken about addresses. Here is an I2C message
    format:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading and writing to the EEPROM](img/7584_10_003.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: An I2C message
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`Wire` library takes care of **Start** **Bit** and **Acknowledge** **Bit**.
    The control code is fixed and you can change the **Chip** **Select** **Bits**
    by wiring **A0**, **A1**, and **A2** pins to ground or +V. That means there are
    8 possibilities of addresses from 0 to 7.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 1010000 1010001… until 1010111\. 1010000 binary means 0x50 in hexadecimal, and
    1010111 means 0x57.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we wired **A0**, **A1**, and **A2** to ground, then the EEPROM
    address on the I2C bus is 0x50\. We could use more than one on the I2C bus, but
    only if we need more storage capacity. Indeed, we would have to address the different
    devices inside our firmware.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: We could now imagine storing many things on that EEPROM space, from samples
    for playing PCM audio to, eventually, huge lookup tables or whatever requiring
    more memory than available on Arduino itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Using GPS modules
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GPS** stands for **Global** **Positioning** **System**. This system is based
    on satellite constellations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a receiver that receives signals from at least 4 satellites embedded
    with a special atomic clock can, by calculating propagation time of these signals
    between them and itself, calculate precisely its tri-dimensional position. That
    sounds magical; it is just trigonometric.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t get into the details of this process; instead focus on the parsing
    of data coming from the GPS modules. You can get more information from Wikipedia:
    [http://en.wikipedia.org/wiki/Global_Positioning_System](http://en.wikipedia.org/wiki/Global_Positioning_System).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Parallax GPS receiver module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Parallax GPS Receiver is based on the PMB-248 specification and provides
    a very easy way to add position detection to the Arduino with its small footprint
    and low cost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the Parallax GPS receiver module](img/7584_10_004.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'The Parallax GPS Receiver: small footprint and accurate'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: It provides standard raw NMEA01823 strings or even specific user-requested data
    via the serial command interface. It can track 12 satellites and even WAAS (system
    only available in USA and Hawaii for helping the GPS Signal calculation).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'NMEA0183 is a combined hardware and logic specification for communication between
    marine electronic devices such as sonars, anemometers, and many others including
    GPS. A great description of this protocol can be found here: [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The module provides current time, date, latitude, longitude, altitude speed,
    and travel direction/heading, among other data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write data to the GPS modules in order to request specific strings.
    However, if we pull the **/RAW** pin low, some strings are automatically transmitted
    by the modules. These strings are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '$GPGGA: Global Positioning System Fix Data'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '$GPGSV: GPS satellites in view'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '$GPGSA: GPS DOP and active satellites'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '$GPRMC: Recommended minimum specific GPS/Transit data'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This data has to be grabbed by the Arduino and eventually used. Let''s check
    the wiring first:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the Parallax GPS receiver module](img/7584_10_005.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: The Parallax GPS Receiver wired to the Arduino in automatic mode by pulling
    low the /RAW pin
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The wiring is quite easy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, the Parallax GPS Receiver only consumes one data pin: digital pin 0\.
    Let''s stop here for two seconds. Didn''t we talk about the fact that we cannot
    use the USB port for serial monitoring and pins 0 and 1 for other serial feature
    at the same time on Arduino?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: With serial communication using Rx/Tx 2 wires, serial software implementation
    can be full duplex.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the GPS device sends data to the Arduino Rx pin. This pin (digital
    pin 0) is wired to the USB Rx pin. At the same time, the Arduino sends data to
    the computer using the USB Tx pin that is wired to digital pin 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Is there a problem in our case here? No. We just have to take care of interferences.
    We must not send data from the computer via USB to the Arduino because it already
    receives data on its serial pin 0 from the GPS device. This is the only thing
    we have to be careful of.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `Serial.write()` function will write to digital pin 1, and the USB Tx digital
    pin 1 isn't wired to anything. Therefore, no problem, data will be sent to the
    USB. The `Serial.read()` function reads from digital pin 0 and USB and we don't
    send anything from the computer to USB, so it can read digital pin 0 without any
    problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We pull the /RAW pin to low. In this mode, the device pops data out to the Arduino
    automatically; I mean, without having to request it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Parsing GPS location data
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before building any firmware that will be able to use GPS data, we have to know
    a bit more about what the device is able to transmit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the datasheet of the GPS device at: [http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf](http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of data that can be transmitted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`$GPRMC,220516,A,5133.82,N,00042.24,W,173.8,231.8,130694,004.2,W*70`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`$GPRMC` defines the type of information sequence sent. The comma is a separator
    that separates each data field.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the meaning of each field:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: UTC time of fix
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data status (`A` means valid position and `V` means warning)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Latitude of the fix
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: North or South latitude
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Longitude of the fix
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: East or West longitude
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Speed over ground (in knots)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track made good in degrees
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UTC date of fix
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magnetic variation in degrees
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: East or West magnetic variation
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checksum
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As soon as we know what data is sent, we can code a parser in our firmware.
    Here is a possible firmware. You can find it in folder `Chapter10/locateMe`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s explain the code a bit. At first, I''m defining several variables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`rxPin` is the digital input where the GPS device is wired'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byteGPS` is the latest byte read from the GPS using serial communication'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line` is a buffer array'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commandGPR` is a string related to messages we want to parse'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counter` is the index of the index array'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`correctness` stores the validity of the message'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lineCounter` is a counter keeping track of the buffer position of the data'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` stores the position of each of the separators in the GPS data string
    (",")'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `setup()` function, we first define digital pin 0 as an input, and then
    start the serial communication with a rate of 4800 baud as required by serial
    interface of the Parallax GPS Receiver (remember to always check your date sheets).
    Then, we are clearing our `line` array buffer by filling it with a space character.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In the `loop()` function, we begin by reading byte from serial input, the digital
    pin being 0\. If the port isn't empty, we enter it in the second part of the `if`
    conditional test defined by the `else` block. If it is empty, we just wait for
    100 ms then try to read it again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, the parsing begins by putting the data read in the line buffer at
    this particular index of the array: `lineCounter`. Then, we increment the latter
    in order to store the data received.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We then print the data read as a raw line to the USB port. It is at this moment
    that the Serial Monitor can receive and display it as the raw data row we quoted
    before as an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Then, we test the data itself, comparing it to 13\. If it equals 13, it means
    data communication is finished and we can begin to parse.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We reset the `counter` and `correctness` variables and check if the first 6
    characters in the buffer equals `$GPRMC`. For each match, we increment the `correctness`
    variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This is a classic pattern. Indeed, if all the tests are true, it means `correctness`
    equals `6` at the end. Then we just have to check if `correctness` equals `6`
    to see if all the tests have been true, and if the first 6 characters equals `$GPRMC`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case, we can be sure we have a correct NMEA raw sequence of the
    type `$GPRMC`, and we can start to actually parse the payload part of the data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: At first, we split our raw string by storing the position in the string of each
    comma separator. We then do the same with the last part separator, the "*" character.
    At this point, we are able to distinguish which character belongs to which part
    of the string, I mean, which part of the raw message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: It is a loop between each value of the raw message, and we test each value using
    a switch/case structure in order to display the correct sentence introducing each
    value of the GPS Data message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The most tricky part, finally, is the last `for()` loop. We don't start as usual.
    Indeed, we start the `j` index in the loop using the array `index` at the specific
    position `i`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small schematic showing indexes around the raw message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing GPS location data](img/7584_10_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Progressively parsing each part of the message according to each separator
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We increment progressively according to each separator''s position, and we
    display each value. This is one way of parsing and using location data using a
    GPS module. This data can be used in many ways, depending on your purpose. I like
    data visualization, and I made small projects for students with a GPS module grabbing
    location every 30s while walking in the street and writing it on an EEPROM. Then,
    I used this data to make some graphs. One I liked a lot is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing GPS location data](img/7584_10_007.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Data visualization designed with Processing from a data set provided by a GPS
    Arduino module
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Each line is a timestamp. The size of the line represents the time we spent
    between two measures of my Arduino-based GPS module. The longer the line is, the
    more time I spent at this step of the travel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Your question could be: How did you supply power to your Arduino + GPS module
    walking in the street?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check how we can make the Arduino autonomous using batteries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Arduino, battery, and autonomy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Arduino boards can supply power in two ways:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: A USB wire from a computer
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An external power supply
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already used USB for supplying power to the Arduino since the beginning of
    the section. This is a pretty nice way to begin (and even to make a great project).
    This is easy and works for many purposes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We can also use an external power supply when we need more autonomy and mobility
    with our Arduino devices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In any case, we have to keep in mind that both our Arduino and our circuits
    wired to it need power. Usually, the Arduino consumption is no more than 50mA.
    Add some LEDs and you'll see the consumption increase.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Let's check some cases of real use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Classic cases of USB power supplying
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why and when would we use a USB power supply?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if we need our computer connected to our Arduino for data communication
    purposes, we can naturally supply power to the Arduino through the USB.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: This is the main reason for using a USB power supply.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: There are also some cases where we cannot have a lot of power sockets. Sometimes,
    there are many constraints in installation design projects and we don't have a
    lot of power sockets. This is also one case of supplying power using the USB.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the first thing to bear in mind before using power supplied by the
    USB port is the global consumption amount of our circuit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, as we have already learned, the maximum current a USB port can provide
    is around 500mA. Be sure you don't exceed this value. Above this limit of consumption,
    things become totally unpredictable and some computers can even reboot while some
    others can disable all USB ports. We have to keep that in mind.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Supplying external power
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two different ways to supply power to an Arduino-based system. We
    can state the two main power supplies as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Batteries
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power adapters
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supplying with batteries
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we remember correctly, the Arduino Uno and Mega for instance can operate
    on an external power supply of 6 V to 20 V. For stable use, the recommended range
    is 7 V to 12 V. 9 V is an ideal voltage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set the board to external power supply, you have to take care of
    the power jumper. We have to put it on the external power supply side, named EXT.
    This setup is for the Arduino Diecimilla and older the Arduino boards:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplying with batteries](img/7584_10_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: The power supply jumper put on the EXT side, meaning set up to external power
    supply
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the basic wiring with a 9 V battery:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplying with batteries](img/7584_10_009.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: A 9V battery wired to an Arduino board UNO R3
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: This simple wiring provides a way to supply power to the Arduino board. If you
    plug some other circuits to the Arduino, the battery through the Arduino will
    feed them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some other types of batteries that we can use. Coin cell batteries
    are a nice way to save space while supplying power externally:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplying with batteries](img/7584_10_010.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: A classic coin cell battery
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many type of coin cell holders to use this type of battery in our
    circuits. Usually, coin cell batteries provide 3.6 V at 110 mAh. If this cannot
    supply power to the Arduino Uno, it can easily supply the Arduino Pro Mini working
    at a voltage of 3.3 V:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplying with batteries](img/7584_10_011.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Arduino Pro Mono
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino Pro Mini board is really interesting as it can be embedded in many
    circuits that need to be discrete and sometimes hidden in walls for digital art
    installations or put into a small plastic box that can be carried in a pocket
    when they are used as a mobile tool.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We can also use polymer lithium-ion batteries. I used them a couple of times
    for an autonomous device project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: However, we can have some projects that require more power.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Power adapter for Arduino supply
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For projects requiring more power, we have to use an external power supply.
    The setup of the Arduino stays the same as with batteries. The off-the-shelf Arduino
    adapter has to meet some requirements:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: DC adapter (No AC adapter here!)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output voltage between 9V and 12V DC
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to output a minimum current of 250mA but aim at 500mA at least or preferably
    1A
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must have a centre positive 2.1mm power plug
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are the patterns you have to look for on your adapter before plugging in
    the Arduino.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the center of the connector has to be the positive part; check out the
    following diagram. You should see that on an Arduino-compatible adapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Power adapter for Arduino supply](img/7584_10_012.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: The symbol showing the center positive plug
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the voltage and current characteristics. This has to show something like:
    OUTPUT: 12 VDC 1 A. This is an example; 12 VDC and 5 A is also fine. Don''t forget
    that current is only driven by what''s there in your circuit. A power adapter
    that puts out a higher current will not harm your circuit, because a circuit will
    only draw what it needs.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: A lot of adapters are available in the market and can be used with our Arduino
    boards.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: How to calculate current consumption
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to calculate current in your circuit, you have to use Ohm's law as
    described in the first chapter of this book.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When you check the datasheet of a component, like an LED, you can see that the
    current passed through it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the RGB LED Common Cathode with this datasheet: [https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf](https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a forward current of 20 mA and a peak forward current of 30 mA.
    If we have five LEDs like that switched on at the maximum brightness (that is
    red, blue, and green lighted up), we have: 5 x (20 + 20 + 20) = 300 mA needed
    for normal use and even peaks would consume 5 x (30 + 30 + 30) = 450 mA.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This is in the case where all LEDs are fully switched on at the same time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: You must have understood the strategy we already used in power supply cycling,
    switching on each LED one after the other in quick succession. This provides a
    way to reduce the power consumption and also allow some projects to use a lot
    of LEDs without requiring an external power adapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: I won't describe the calculations for each case here, but you'd have to refer
    to electricity rules to precisely calculate the consumption.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: By experience, there is nothing better than your voltmeter and Ampere meter,
    the former measuring voltage between two points and the latter measuring current
    at some points along the circuit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d suggest that you make some calculations to be sure to:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Not override the Arduino capacity per pins
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not override USB 450mA limit, in case you use a USB power supply
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, after that, begin to wire and measure at the same time with voltmeter
    and Ampere meter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, a classic reference for most of the Arduino boards is available at
    this page: [http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations](http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We can find the limitations for current consumption for each part of the Arduino.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on gLCDs
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing is always fun. Drawing and handling LCD displays instead of LEDs matrices
    is really interesting too, because we have devices with high-density points we
    can switch on and off easily.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: LCDs exist in many types. The two main types are the character and graphical
    type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: We are talking about the graphical type here, especially those based on the
    KS0108 graphics-only controller used in many regular gLCD devices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a nice library that is available on Google. It has code
    by Michael Margolis and Bill Perry, and it is named `glcd-arduino`. This library
    is licensed under the GNU Lesser GPL.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s download it here: [http://code.google.com/p/glcd-arduino/downloads/list](http://code.google.com/p/glcd-arduino/downloads/list).
    Download the most recent version.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Unzip it, put it in the place where all your libraries are, and restart or start
    your Arduino IDE.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a lot of examples related to the gLCD library.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t check all the nice features and functions provided by this library
    here, but you can check this page on the Arduino website: [http://playground.arduino.cc/Code/GLCDks0108](http://playground.arduino.cc/Code/GLCDks0108).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the device
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to check the wiring of a KS0108 based gLCD type Panel B:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the device](img/7584_10_013.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: A lot of wires wiring the gLCD to Arduino and the potentiometer to adjust LCD
    contrast
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding electrical diagram is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring the device](img/7584_10_014.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: KS0108 based gLCD type Panel B wired to an Arduino Uno R3
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: These are a lot of wires. Of course, we can multiply things. We can also use
    an Arduino MEGA and keep using the other digital pin available for other purposes,
    but that is not the point here. Let's check some of the functions of this powerful
    library.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Demoing the library
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take the example named `GLCDdemo`. It shows you almost all the functions available
    in the library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'There is very good PDF documentation provided with the library. It explains
    each available method. You can find it in the `library` folder in the `doc` subfolder:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Demoing the library](img/7584_10_015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: The documentation of gLCD-Arduino showing the screen coordinates system
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: At first, we have to include `glcd.h` in order to use the library. Then, we
    have to include some other headers, in this example, fonts and bitmap in order
    to use the font typographic methods and the bitmap objects too.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Some useful method's families
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I''d suggest ordering learning methods into three parts:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Global GLCD methods
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing methods
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text methods
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global GLCD methods
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first is the `init()` function. This one initializes the library and has
    to be called before any other gLCD methods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The `SetDisplayMode()` function is useful because it sets up the use of the
    LCD as normal (writing in black over white background) or inverted. White just
    means not black. The real color depends on the backlight color, of course.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The `ClearScreen()` function erases the screen, filling it with white background
    in normal mode, or black in inverted mode.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The `ReadData()` and `WriteData()` functions are really raw methods that get
    and set the byte of data at particular coordinates.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Drawing methods
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are a set of functions dedicated to drawing on the screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of constants are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`GLCD.Width` is the display width in pixels'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLCD.Height` is the display height in pixels'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLCD.Right` is the last pixel column at the right (equals GLCD.Width – 1)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLCD.Bottom` is the last pixel row at the bottom (equals GLCD. Height – 1)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLCD.CenterX` and `GLCD.CenterY` are the coordinates of the pixel in the middle'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, you can draw by moving the graphics cursor and by drawing primitive
    shapes:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `GotoXY()` | Moves the cursor to specific coordinates |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `DrawVLine()` | Draws a vertical line from a point to another point in the
    same pixel column but above or below the initial point |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `DrawHLine()` | Works the same as `DrawVLine()` but on the same pixel row
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `DrawLine()` | Draws a line between two coordinates |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: 'Some other, more complex shapes can be drawn too:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Descriptions |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `DrawRect()` | Draws a rectangle from a point when provided with a width
    and height. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `FillRect()` | Works the same as `DrawRect()`, but by filling the rectangle
    shape with black (or white) pixels. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `DrawRoundRect()` | Draws a nice rectangle with rounded corners. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `DrawCircle()` and `FillCircle()` | Draws a circle from coordinates and a
    radius, and a circle filled with black (or white) pixels. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `DrawBitmap()` | Draws a whole bitmap at a particular position on the screen.
    It uses a pointer to that bitmap in memory. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: With this set of functions, you can basically draw anything you want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Text methods
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are a set of functions dedicated to typography on the screen:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Descriptions |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| `SelectFont()` | At first, this chooses the font to be used in the next functions
    calls. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| `SetFontColor()` | Chooses the color. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| `SetTextMode()` | Chooses a scrolling direction. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `CursorTo()` | Moves the cursor to a specific column and row. The column
    calculation uses the width of the widest character. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `CursorToXY()` | Moves the cursor to particular pixel coordinate. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: One important feature to know about, is the fact that Arduino's print functions
    can be used with gLCD library; `GLCD.print()` works fine, for instance. There
    are also a couple of other functions available that can be found on the official
    website.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: At last, I'd suggest you to test the example named `life`. This is based on
    the John Conway's Game of Life. This is a nice example of what you can do and
    implement some nice and useful logic.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on gLCD is nice, but we could also use a small module handling VGA.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Using VGA with the Gameduino Shield
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gameduino is an Arduino Shield. This is the first one we are using here in this
    book. Basically, a shield is a PCB (printed circuit board) that can be plugged
    to another PCB, here our Arduino.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Shields are pre-made circuits including components and sometimes processors
    too. They add features to our Arduino board by handling some specific tasks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Here, the Gameduino will add VGA drawing abilities to our Arduino that can't
    be done on its own.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The Gameduino adds a VGA port, a mini-jack for the sound, and also includes
    an FPGA Xilling Spartan3A. FPGA Xilling Spartan3A can process graphical data faster
    than the Arduino itself. Arduino can control this graphical hardware driver by
    SPI interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Using VGA with the Gameduino Shield](img/7584_10_016.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: The Gameduino controller Arduino Shield
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Arduino Shields can be plugged in Arduino boards directly. Check the following
    screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Using VGA with the Gameduino Shield](img/7584_10_017.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: The Gameduino plugged in the Arduino board
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some characteristics of the Gameduino:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Video output is 400 x 300 pixels in 512 colors
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All color processed internally at 15 bit precision
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible with any standard VGA monitor (800 x 600 @ 72 Hz)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background graphics (512 x 512 pixel character, 256 characters)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground graphics (sprite 16 x 16 abilities, transparency, rotate/flip, and
    sprite collision detection)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio output as stereo; 12-bit frequency synthesizer
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64 independent voices at 10 to 8000 hz
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample playback channel
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The underlying concept is to plug it in the Arduino and to control it using
    our Arduino firmware with the library taking care of all SPI communication between
    the Arduino and Gameduino.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot describe all the examples right here in this book, but I want to
    point you in the right direction. At first, the official website: [http://excamera.com/sphinx/gameduino/](http://excamera.com/sphinx/gameduino/).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the library here: [http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip](http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check and use the quick reference poster here: [http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf](http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: For your information, I'm currently designing a piece on digital art installation
    based on this shield. I intend to describe it on my own website [http://julienbayle.net](http://julienbayle.net)
    and the whole schematics will be provided too.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first, advanced chapter, we learned a bit more about how to deal with
    new concrete concepts such as storing data on non-volatile memories (internal
    and external EEPROM), use GPS module receivers, draw on graphical LCD, and use
    a nice Arduino Shield named Gameduino to add new features and power to our Arduino.
    This allowed it to display a VGA signal and also to produce audio. We also learned
    the use of Arduino as a very portable and mobile device, autonomous from the power
    supply point of view.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个、高级章节中，我们了解了一些关于如何处理新具体概念的方法，例如在非易失性存储器（内部和外部EEPROM）上存储数据，使用GPS模块接收器，在图形LCD上绘图，以及使用一个名为Gameduino的Arduino
    Shield来添加新功能和增强我们的Arduino。这使得它能够显示VGA信号，并且还能产生音频。我们还学习了Arduino作为一个非常便携和移动设备的用途，从电源供应的角度来看是自给自足的。
- en: In the next chapter, we are going to talk about networking concepts. Creating
    and using networks are usual ways of communication today. We will describe wired
    and wireless network use with our Arduino projects in the next chapter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论网络概念。创建和使用网络是当今常见的通信方式。在下一章中，我们将描述使用Arduino项目进行有线和无线网络的使用。
