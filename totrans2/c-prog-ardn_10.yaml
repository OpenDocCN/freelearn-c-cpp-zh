- en: Chapter 10. Some Advanced Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。一些高级技术
- en: In this chapter, we are going to learn different techniques that can be used
    either together or independently. Each technique developed here is a new tool
    for your future or current projects. We are going to use EEPROMs to provide Arduino
    boards with a small memory system that is readable and writable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习可以一起使用或独立使用的技术。在这里开发的每个技术都是你未来或当前项目的新工具。我们将使用EEPROM为Arduino板提供一个可读可写的内存系统。
- en: We are also going to test communications between the Arduino boards themselves,
    use GPS modules, make our boards autonomous, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试Arduino板之间的通信，使用GPS模块，使我们的板子实现自主化，以及更多。
- en: Data storage with EEPROMs
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EEPROM进行数据存储
- en: Until now, we learned and used the Arduino boards as totally electricity dependent
    devices. Indeed, they need current in order to execute tasks compiled in our firmware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习和使用Arduino板作为完全依赖电力的设备。确实，它们需要电流来执行我们固件中编译的任务。
- en: As we noticed, when we switch them off, every living variable and data is lost.
    Fortunately, the firmware isn't.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所注意到的，当我们关闭它们时，每个活着的变量和数据都会丢失。幸运的是，固件不会。
- en: Three native pools of memory on the Arduino boards
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino板上的三个原生内存池
- en: 'The Arduino boards based on the ATmega168 chipset own three different pools
    of memory:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基于ATmega168芯片组的Arduino板拥有三个不同的内存池：
- en: Flash memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪存内存
- en: SRAM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRAM
- en: EEPROM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEPROM
- en: The flash memory is also named program space. This is the place where our firmware
    is stored.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存也被称为程序空间。这是我们的固件存储的地方。
- en: The **SRAM** stands for **Static** **Random** **Access** **Memory** and is the
    place where the running firmware stores, reads, and manipulates variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRAM**代表**静态随机存取存储器**，是运行中的固件存储、读取和操作变量的地方。'
- en: The **EEPROM** stands for **Electrically** **Erasable** **Programmable** **Read-Only**
    **Memory**. It is the place where we, programmers, can store things for long-term
    purposes. This is the place where our firmware sits, and anything in the EEPROM
    isn't erased should the board be switched off.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**EEPROM**代表**电擦除可编程只读存储器**。这是程序员可以存储长期数据的地方。这是我们的固件所在的地方，如果板子关闭，EEPROM中的任何内容都不会被擦除。'
- en: 'ATmega168 has:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ATmega168具有：
- en: 16000 bytes of Flash (2000 bytes are used for the bootloader)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16000字节的闪存（其中2000字节用于引导加载程序）
- en: 1024 bytes of SRAM
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1024字节的SRAM
- en: 512 bytes of EEPROM
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 512字节的EEPROM
- en: Here we won't discuss the fact that we have to take care of the memory while
    programming; we will do that in the last chapter of this book [Chapter 13](ch13.html
    "Chapter 13. Improving your C Programming and Creating Libraries"), *Improving
    your C Programming and Creating Libraries*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会讨论在编程时必须注意内存的事实；我们将在本书的最后一章[第13章](ch13.html "第13章. 提高你的C编程和创建库")中这样做，*提高你的C编程和创建库*。
- en: The interesting part here is the EEPROM space. It allows us to store data on
    the Arduino and we didn't even know that until now. Let's test the EEPROM native
    library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是EEPROM空间。它允许我们在Arduino上存储数据，而我们直到现在甚至都不知道这一点。让我们测试EEPROM原生库。
- en: Writing and reading with EEPROM core library
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EEPROM核心库进行读写
- en: 'Basically, this example doesn''t require any wiring. We are going to use the
    internal EEPROM of 512 bytes. Here is some code that reads all the bytes of the
    EEPROM and prints it to the computer''s Serial Monitor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个示例不需要任何接线。我们将使用512字节的内部EEPROM。以下是一些读取EEPROM所有字节并将其打印到计算机串行监视器的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is in the public domain and provided as an example for the EEPROM
    library. You can find it in your `examples` folder in the **File** menu of the
    Arduino IDE, under the folder **Examples** | **EEPROM**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码属于公共领域，并作为EEPROM库的示例提供。你可以在Arduino IDE的**文件**菜单下的**示例**文件夹中找到它，在**示例** |
    **EEPROM**文件夹中。
- en: At first, we include the library itself. Then we define a variable for storing
    the current read address. We initialize it at 0, the beginning of the memory register.
    We also define a variable as a byte type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含库本身。然后我们定义一个用于存储当前读取地址的变量。我们将其初始化为0，即内存寄存器的开始。我们还定义了一个字节类型的变量。
- en: In the `setup()` function, we initialize the serial communication. In `loop()`,
    we read the byte at the current address and store it in the variable `value`.
    Then we print the result to the serial port. Notice the `\t` value in the second
    `Serial.print()` statement. This stands for tabulation (as in the *Tab* key on
    a computer keyboard). This writes tabulation to the serial port between the current
    address printed and the value itself in order to make things more readable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们初始化串行通信。在`loop()`中，我们读取当前地址的字节并将其存储在变量`value`中。然后我们将结果打印到串行端口。注意第二个`Serial.print()`语句中的`\t`值。这代表制表符（就像电脑键盘上的*Tab*键）。这将在打印的当前地址和值本身之间写入制表符，以便使内容更易读。
- en: We advance to the next address. We check if the address equals 512, if that
    is the case, we restart the address counter to 0 and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前进到下一个地址。我们检查地址是否等于512，如果是，我们将地址计数器重置为0，依此类推。
- en: We add a small delay. We can write bytes in the same way using `EEPROM.write(addr,
    val);` where `addr` is the address where you want to write the value `val`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个小的延迟。我们可以使用`EEPROM.write(addr, val);`以相同的方式写入字节，其中`addr`是你想写入值`val`的地址。
- en: Be careful, these are bytes (8 bits = 256 possible values). Read and write operations
    are quite easy on the internal EEPROM, so let's see how it goes with external
    EEPROMs wired by an I2C connection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，这些都是字节（8比特=256个可能值）。在内部EEPROM上读写操作相当简单，所以让我们看看通过I2C连接的外部EEPROM会怎样。
- en: External EEPROM wiring
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部EEPROM布线
- en: There are a lot of cheap EEPROM components available in electronics markets.
    We are going to use the classic 24LC256, an EEPROM implementing I2C for read/write
    operations and providing 256 kilobits (32 kilobytes) of memory space.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 电子市场上有很多廉价的EEPROM组件。我们将使用经典的24LC256，这是一个实现I2C读写操作并提供256千比特（32千字节）内存空间的EEPROM。
- en: 'You can find it at Sparkfun: [https://www.sparkfun.com/products/525](https://www.sparkfun.com/products/525).
    Here is how we can wire its bigger cousin 24LC1025 (1024k bytes) using I2C:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Sparkfun找到它：[https://www.sparkfun.com/products/525](https://www.sparkfun.com/products/525)。以下是使用I2C布线其更大的兄弟24LC1025（1024k字节）的方法：
- en: '![External EEPROM wiring](img/7584_10_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![外部EEPROM布线](img/7584_10_001.jpg)'
- en: A 24LC256 EEPROM wired to the Arduino via I2C communication
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过I2C通信连接到Arduino的24LC256 EEPROM
- en: 'The corresponding diagram is the one shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的图如下所示：
- en: '![External EEPROM wiring](img/7584_10_002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![外部EEPROM布线](img/7584_10_002.jpg)'
- en: A 24LC256 EEPROM wired to the Arduino via I2C communication
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过I2C通信连接到Arduino的24LC256 EEPROM
- en: Let's describe the EEPROM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下EEPROM。
- en: '**A0**, **A1**, and **A2** are chip address inputs. **+V** and **0V** are **5V**
    and ground. WP is the write protect pin. If it is wired to ground, we can write
    to the EEPROM. If it is wired to 5V, we cannot.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**A0**、**A1**和**A2**是芯片地址输入。**+V**和**0V**是**5V**和地。WP是写保护引脚。如果它连接到地，我们可以写入EEPROM。如果它连接到5V，则不能。'
- en: 'SCL and SDA are the two wires involved in the I2C communication and are wired
    to **SDA** / **SCL**. **SDA** stands for **Serial** **Data** **Line** and **SCL**
    stands for **Serial** **Clock** **Line**. Be careful about the SDA/SCL pins. The
    following depends on your board:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SCL和SDA是参与I2C通信的两个引脚，并连接到**SDA** / **SCL**。**SDA**代表**串行** **数据** **线**，**SCL**代表**串行**
    **时钟** **线**。注意SDA/SCL引脚。以下取决于你的板：
- en: The Arduino UNO before R3 and Ethernet's I2C pins are A4 (SDA) and A5 (SCL)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino UNO R3之前的I2C引脚是A4（SDA）和A5（SCL）
- en: Mega2560, pins 20 (SDA) and 21 (SCL)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mega2560，20号引脚（SDA）和21号引脚（SCL）
- en: Leonardo, pin 2 (SDA) and pin 3 (SCL)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Leonardo，2号引脚（SDA）和3号引脚（SCL）
- en: Due Pins, pins 20 (SDA) and 21 (SCL) and also another one SDA1 and SCL1
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Due引脚，20号引脚（SDA）和21号引脚（SCL），还有一个SDA1和SCL1
- en: Reading and writing to the EEPROM
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读写EEPROM
- en: The underlying library that we can use for I2C purposes is `Wire`. You can find
    it directly in the Arduino core. This library takes care of the raw bits, but
    we have to look at it more closely.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用于I2C目的的底层库是`Wire`。你可以在Arduino核心库中直接找到它。这个库负责处理原始比特，但我们需要更仔细地查看它。
- en: 'The `Wire` library takes care of many things for us. Let''s check the code
    in the folder `Chapter10/readWriteI2C`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire`库为我们处理了很多事情。让我们检查文件夹`Chapter10/readWriteI2C`中的代码：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We include the `Wire` library at first. Then we define 2 functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含`Wire`库。然后我们定义2个函数：
- en: '`eepromWrite()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eepromWrite()`'
- en: '`eepromRead()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eepromRead()`'
- en: These functions write and read bytes to and from the external EEPROM using the
    `Wire` library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用`Wire`库将字节写入和读取到外部EEPROM。
- en: The `Setup()` function instantiates the `Wire` and the `Serial` communication.
    Then using a `for` loop, we write data to a specific address. This data is basically
    a character 'a' plus a number. This structure writes characters from a to a +
    9 which means 'j'. This is an example to show how we can store things quickly,
    but of course we could have written more meaningful data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Setup()` 函数实例化了 `Wire` 和 `Serial` 通信。然后使用 `for` 循环，我们将数据写入特定的地址。这些数据基本上是一个字符
    ''a'' 加上一个数字。这种结构从 ''a'' 写到 ''a'' + 9，即 ''j''。这是一个展示我们如何快速存储东西的例子，但当然我们可以写入更有意义的数据。'
- en: We then print a message to the Serial Monitor in order to tell the user that
    Arduino has finished writing to the EEPROM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向串行监视器打印一条消息，以告知用户 Arduino 已完成对 EEPROM 的写入。
- en: In the `loop()` function, we then read the EEPROM. It is quite similar to the
    EEPROM library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们读取 EEPROM。它与 EEPROM 库非常相似。
- en: 'Obviously, we still haven''t spoken about addresses. Here is an I2C message
    format:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们还没有讨论地址。以下是一个 I2C 消息格式：
- en: '![Reading and writing to the EEPROM](img/7584_10_003.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![读取和写入 EEPROM](img/7584_10_003.jpg)'
- en: An I2C message
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 I2C 消息
- en: '`Wire` library takes care of **Start** **Bit** and **Acknowledge** **Bit**.
    The control code is fixed and you can change the **Chip** **Select** **Bits**
    by wiring **A0**, **A1**, and **A2** pins to ground or +V. That means there are
    8 possibilities of addresses from 0 to 7.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire` 库负责**起始位**和**确认位**。控制码是固定的，你可以通过将**芯片选择位**（A0、A1 和 A2 引脚）连接到地或 +V 来更改。这意味着有
    8 种地址的可能性，从 0 到 7。'
- en: 1010000 1010001… until 1010111\. 1010000 binary means 0x50 in hexadecimal, and
    1010111 means 0x57.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 1010000 1010001… 直到 1010111。1010000 二进制表示十六进制的 0x50，而 1010111 表示 0x57。
- en: In our case, we wired **A0**, **A1**, and **A2** to ground, then the EEPROM
    address on the I2C bus is 0x50\. We could use more than one on the I2C bus, but
    only if we need more storage capacity. Indeed, we would have to address the different
    devices inside our firmware.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将 **A0**、**A1** 和 **A2** 连接到地，然后 EEPROM 在 I2C 总线上的地址是 0x50。我们可以在 I2C
    总线上使用多个地址，但只有当我们需要更多的存储容量时。实际上，我们可能需要在固件中为不同的设备分配地址。
- en: We could now imagine storing many things on that EEPROM space, from samples
    for playing PCM audio to, eventually, huge lookup tables or whatever requiring
    more memory than available on Arduino itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以想象在 EEPROM 空间中存储很多东西，从播放 PCM 音频的样本到，最终，巨大的查找表或任何需要比 Arduino 本身更多内存的东西。
- en: Using GPS modules
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPS 模块
- en: '**GPS** stands for **Global** **Positioning** **System**. This system is based
    on satellite constellations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**GPS** 代表 **全球定位系统**。该系统基于卫星星座。'
- en: Basically, a receiver that receives signals from at least 4 satellites embedded
    with a special atomic clock can, by calculating propagation time of these signals
    between them and itself, calculate precisely its tri-dimensional position. That
    sounds magical; it is just trigonometric.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个至少接收来自 4 颗嵌入特殊原子钟的卫星的接收器，通过计算这些信号之间的传播时间以及与自身的传播时间，可以精确地计算出其三维位置。这听起来很神奇；其实只是三角学的应用。
- en: 'We won''t get into the details of this process; instead focus on the parsing
    of data coming from the GPS modules. You can get more information from Wikipedia:
    [http://en.wikipedia.org/wiki/Global_Positioning_System](http://en.wikipedia.org/wiki/Global_Positioning_System).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这个过程的细节；相反，我们关注来自 GPS 模块的数据解析。你可以在维基百科上获取更多信息：[http://en.wikipedia.org/wiki/Global_Positioning_System](http://en.wikipedia.org/wiki/Global_Positioning_System)。
- en: Wiring the Parallax GPS receiver module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 Parallax GPS 接收器模块
- en: The Parallax GPS Receiver is based on the PMB-248 specification and provides
    a very easy way to add position detection to the Arduino with its small footprint
    and low cost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Parallax GPS 接收器基于 PMB-248 规范，以其小巧的尺寸和低廉的成本，为 Arduino 添加位置检测提供了非常简单的方法。
- en: '![Wiring the Parallax GPS receiver module](img/7584_10_004.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![连接 Parallax GPS 接收器模块](img/7584_10_004.jpg)'
- en: 'The Parallax GPS Receiver: small footprint and accurate'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Parallax GPS 接收器：小巧尺寸和精确
- en: It provides standard raw NMEA01823 strings or even specific user-requested data
    via the serial command interface. It can track 12 satellites and even WAAS (system
    only available in USA and Hawaii for helping the GPS Signal calculation).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供标准的原始 NMEA01823 字符串，甚至可以通过串行命令接口提供特定用户请求的数据。它可以跟踪 12 颗卫星，甚至 WAAS（仅在 USA 和
    Hawaii 可用的系统，用于帮助 GPS 信号计算）。
- en: 'NMEA0183 is a combined hardware and logic specification for communication between
    marine electronic devices such as sonars, anemometers, and many others including
    GPS. A great description of this protocol can be found here: [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NMEA0183 是一种结合了硬件和逻辑规范，用于海洋电子设备（如声纳、风速计等）之间的通信，包括 GPS。关于此协议的详细描述可以在这里找到：[http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)。
- en: The module provides current time, date, latitude, longitude, altitude speed,
    and travel direction/heading, among other data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块提供当前时间、日期、纬度、经度、海拔、速度以及航向/航向，以及其他数据。
- en: 'We can write data to the GPS modules in order to request specific strings.
    However, if we pull the **/RAW** pin low, some strings are automatically transmitted
    by the modules. These strings are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 GPS 模块写入数据以请求特定的字符串。然而，如果我们将 **/RAW** 引脚拉低，模块会自动传输一些字符串。这些字符串是：
- en: '$GPGGA: Global Positioning System Fix Data'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '$GPGGA: 全球定位系统定位数据'
- en: '$GPGSV: GPS satellites in view'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '$GPGSV: 视野中的 GPS 卫星'
- en: '$GPGSA: GPS DOP and active satellites'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '$GPGSA: GPS DOP 和活动卫星'
- en: '$GPRMC: Recommended minimum specific GPS/Transit data'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '$GPRMC: 推荐的最小特定 GPS/Transit 数据'
- en: 'This data has to be grabbed by the Arduino and eventually used. Let''s check
    the wiring first:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据必须由 Arduino 捕获并最终使用。让我们先检查一下接线：
- en: '![Wiring the Parallax GPS receiver module](img/7584_10_005.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![接线 Parallax GPS 接收器模块](img/7584_10_005.jpg)'
- en: The Parallax GPS Receiver wired to the Arduino in automatic mode by pulling
    low the /RAW pin
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 /RAW 引脚拉低，自动模式下连接到 Arduino 的 Parallax GPS 接收器
- en: The wiring is quite easy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接线相当简单。
- en: 'Yes, the Parallax GPS Receiver only consumes one data pin: digital pin 0\.
    Let''s stop here for two seconds. Didn''t we talk about the fact that we cannot
    use the USB port for serial monitoring and pins 0 and 1 for other serial feature
    at the same time on Arduino?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Parallax GPS 接收器只消耗一个数据引脚：数字引脚 0。让我们在这里停顿两秒钟。我们不是讨论过在 Arduino 上我们不能同时使用 USB
    端口进行串行监控，以及引脚 0 和 1 用于其他串行功能吗？
- en: With serial communication using Rx/Tx 2 wires, serial software implementation
    can be full duplex.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rx/Tx 2 根线进行串行通信，串行软件实现可以是全双工的。
- en: In our case, the GPS device sends data to the Arduino Rx pin. This pin (digital
    pin 0) is wired to the USB Rx pin. At the same time, the Arduino sends data to
    the computer using the USB Tx pin that is wired to digital pin 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，GPS 设备将数据发送到 Arduino 的 Rx 引脚。这个引脚（数字引脚 0）连接到 USB Rx 引脚。同时，Arduino 使用连接到数字引脚
    1 的 USB Tx 引脚将数据发送到计算机。
- en: Is there a problem in our case here? No. We just have to take care of interferences.
    We must not send data from the computer via USB to the Arduino because it already
    receives data on its serial pin 0 from the GPS device. This is the only thing
    we have to be careful of.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下这里有问题吗？没有。我们只需要注意干扰。我们绝对不能通过 USB 从计算机发送数据到 Arduino，因为它已经从 GPS 设备接收了串行引脚
    0 的数据。这是我们唯一需要注意的事情。
- en: The `Serial.write()` function will write to digital pin 1, and the USB Tx digital
    pin 1 isn't wired to anything. Therefore, no problem, data will be sent to the
    USB. The `Serial.read()` function reads from digital pin 0 and USB and we don't
    send anything from the computer to USB, so it can read digital pin 0 without any
    problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serial.write()` 函数将写入数字引脚 1，而 USB Tx 数字引脚 1 没有连接到任何东西。因此，没有问题，数据将被发送到 USB。`Serial.read()`
    函数从数字引脚 0 和 USB 读取，我们没有从计算机发送任何数据到 USB，所以它可以无任何问题地读取数字引脚 0。'
- en: We pull the /RAW pin to low. In this mode, the device pops data out to the Arduino
    automatically; I mean, without having to request it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 /RAW 引脚拉低。在这种模式下，设备会自动将数据推送到 Arduino；我的意思是，不需要请求它。
- en: Parsing GPS location data
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 GPS 位置数据
- en: Before building any firmware that will be able to use GPS data, we have to know
    a bit more about what the device is able to transmit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何能够使用 GPS 数据的固件之前，我们必须更多地了解设备能够传输的内容。
- en: 'We can read the datasheet of the GPS device at: [http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf](http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下位置查看 GPS 设备的数据表：[http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf](http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf)。
- en: 'Here is an example of data that can be transmitted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可传输数据的一个示例：
- en: '`$GPRMC,220516,A,5133.82,N,00042.24,W,173.8,231.8,130694,004.2,W*70`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GPRMC,220516,A,5133.82,N,00042.24,W,173.8,231.8,130694,004.2,W*70`'
- en: '`$GPRMC` defines the type of information sequence sent. The comma is a separator
    that separates each data field.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GPRMC` 定义了发送的信息序列的类型。逗号是一个分隔符，用于分隔每个数据字段。'
- en: 'Here is the meaning of each field:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个字段的含义：
- en: UTC time of fix
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位的 UTC 时间
- en: Data status (`A` means valid position and `V` means warning)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据状态（`A` 表示有效位置，`V` 表示警告）
- en: Latitude of the fix
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位的纬度
- en: North or South latitude
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 北或南纬度
- en: Longitude of the fix
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位的经度
- en: East or West longitude
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 东或西经度
- en: Speed over ground (in knots)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面速度（以节为单位）
- en: Track made good in degrees
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 航迹向度（以度为单位）
- en: UTC date of fix
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位的 UTC 日期
- en: Magnetic variation in degrees
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁差（以度为单位）
- en: East or West magnetic variation
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 东或西磁差
- en: Checksum
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 校验和
- en: 'As soon as we know what data is sent, we can code a parser in our firmware.
    Here is a possible firmware. You can find it in folder `Chapter10/locateMe`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道发送了什么数据，我们就可以在我们的固件中编写一个解析器。以下是一个可能的固件示例。您可以在文件夹 `Chapter10/locateMe`
    中找到它：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s explain the code a bit. At first, I''m defining several variables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码。首先，我定义了几个变量：
- en: '`rxPin` is the digital input where the GPS device is wired'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxPin` 是 GPS 设备连接的数字输入'
- en: '`byteGPS` is the latest byte read from the GPS using serial communication'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byteGPS` 是通过串行通信从 GPS 读取的最新字节'
- en: '`line` is a buffer array'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line` 是一个缓冲区数组'
- en: '`commandGPR` is a string related to messages we want to parse'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commandGPR` 是与我们要解析的消息相关的字符串'
- en: '`counter` is the index of the index array'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter` 是索引数组的索引'
- en: '`correctness` stores the validity of the message'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`correctness` 存储消息的有效性'
- en: '`lineCounter` is a counter keeping track of the buffer position of the data'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineCounter` 是跟踪数据缓冲区位置的计数器'
- en: '`index` stores the position of each of the separators in the GPS data string
    (",")'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index` 存储GPS数据字符串中每个分隔符的位置（","）'
- en: In the `setup()` function, we first define digital pin 0 as an input, and then
    start the serial communication with a rate of 4800 baud as required by serial
    interface of the Parallax GPS Receiver (remember to always check your date sheets).
    Then, we are clearing our `line` array buffer by filling it with a space character.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 函数中，我们首先将数字引脚0定义为输入，然后以串行接口所需的4800波特率开始串行通信（请记住始终检查您的数据表）。然后，我们通过填充空格字符来清除我们的
    `line` 数组缓冲区。
- en: In the `loop()` function, we begin by reading byte from serial input, the digital
    pin being 0\. If the port isn't empty, we enter it in the second part of the `if`
    conditional test defined by the `else` block. If it is empty, we just wait for
    100 ms then try to read it again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们首先从串行输入读取字节，数字引脚为0。如果端口不为空，我们进入由 `else` 块定义的 `if` 条件测试的第二部分。如果它是空的，我们只需等待100毫秒然后再次尝试读取。
- en: 'At first, the parsing begins by putting the data read in the line buffer at
    this particular index of the array: `lineCounter`. Then, we increment the latter
    in order to store the data received.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解析开始于将读取的数据放入行缓冲区中数组的特定索引：`lineCounter`。然后，我们增加后者以便存储接收到的数据。
- en: We then print the data read as a raw line to the USB port. It is at this moment
    that the Serial Monitor can receive and display it as the raw data row we quoted
    before as an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将读取的数据作为原始行打印到USB端口。就在这个时候，串行监视器可以接收并显示我们之前引用的示例中的原始数据行。
- en: Then, we test the data itself, comparing it to 13\. If it equals 13, it means
    data communication is finished and we can begin to parse.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们测试数据本身，将其与 13 进行比较。如果它等于 13，这意味着数据通信已完成，我们可以开始解析。
- en: We reset the `counter` and `correctness` variables and check if the first 6
    characters in the buffer equals `$GPRMC`. For each match, we increment the `correctness`
    variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重置 `counter` 和 `correctness` 变量，并检查缓冲区中的前6个字符是否等于 `$GPRMC`。对于每个匹配项，我们增加 `correctness`
    变量。
- en: This is a classic pattern. Indeed, if all the tests are true, it means `correctness`
    equals `6` at the end. Then we just have to check if `correctness` equals `6`
    to see if all the tests have been true, and if the first 6 characters equals `$GPRMC`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的模式。实际上，如果所有测试都为真，那么最终 `correctness` 等于 `6`。然后我们只需检查 `correctness` 是否等于
    `6`，以查看是否所有测试都为真，以及前6个字符是否等于 `$GPRMC`。
- en: If this is the case, we can be sure we have a correct NMEA raw sequence of the
    type `$GPRMC`, and we can start to actually parse the payload part of the data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们可以确信我们有一个正确的 NMEA 原始序列类型 `$GPRMC`，然后我们可以开始实际解析数据的负载部分。
- en: At first, we split our raw string by storing the position in the string of each
    comma separator. We then do the same with the last part separator, the "*" character.
    At this point, we are able to distinguish which character belongs to which part
    of the string, I mean, which part of the raw message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过存储字符串中每个逗号分隔符的位置来分割我们的原始字符串。然后，我们用最后一个部分分隔符，即"*"字符，做同样的事情。在这个时候，我们能够区分哪个字符属于字符串的哪个部分，我的意思是，哪个部分属于原始消息。
- en: It is a loop between each value of the raw message, and we test each value using
    a switch/case structure in order to display the correct sentence introducing each
    value of the GPS Data message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在原始消息的每个值之间的循环，我们使用switch/case结构测试每个值，以便显示介绍GPS数据消息每个值的正确句子。
- en: The most tricky part, finally, is the last `for()` loop. We don't start as usual.
    Indeed, we start the `j` index in the loop using the array `index` at the specific
    position `i`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最棘手的部分是最后的`for()`循环。我们并不像通常那样开始。实际上，我们在循环中使用数组`index`在特定位置`i`来开始`j`索引。
- en: 'Here is a small schematic showing indexes around the raw message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示原始消息周围索引的小型电路图：
- en: '![Parsing GPS location data](img/7584_10_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![解析GPS位置数据](img/7584_10_006.jpg)'
- en: Progressively parsing each part of the message according to each separator
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个分隔符逐步解析消息的每一部分
- en: 'We increment progressively according to each separator''s position, and we
    display each value. This is one way of parsing and using location data using a
    GPS module. This data can be used in many ways, depending on your purpose. I like
    data visualization, and I made small projects for students with a GPS module grabbing
    location every 30s while walking in the street and writing it on an EEPROM. Then,
    I used this data to make some graphs. One I liked a lot is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据每个分隔符的位置逐步增加，并显示每个值。这是使用GPS模块解析和使用位置数据的一种方法。这些数据可以根据你的目的以多种方式使用。我喜欢数据可视化，我为学生制作了小项目，使用GPS模块每隔30秒在街上抓取位置并写入EEPROM。然后，我使用这些数据制作了一些图表。我最喜欢的一个是以下这个：
- en: '![Parsing GPS location data](img/7584_10_007.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![解析GPS位置数据](img/7584_10_007.jpg)'
- en: Data visualization designed with Processing from a data set provided by a GPS
    Arduino module
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用由GPS Arduino模块提供的数据集设计的Processing数据可视化
- en: Each line is a timestamp. The size of the line represents the time we spent
    between two measures of my Arduino-based GPS module. The longer the line is, the
    more time I spent at this step of the travel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是一个时间戳。行的长度代表我在Arduino GPS模块两次测量之间花费的时间。行越长，我在这个旅行步骤上花费的时间就越长。
- en: 'Your question could be: How did you supply power to your Arduino + GPS module
    walking in the street?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你的问题可能是：你在街上行走时是如何给你的Arduino + GPS模块供电的？
- en: Now, let's check how we can make the Arduino autonomous using batteries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用电池使Arduino实现自主性。
- en: Arduino, battery, and autonomy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino、电池和自主性
- en: 'The Arduino boards can supply power in two ways:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino板可以通过两种方式供电：
- en: A USB wire from a computer
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自电脑的USB线
- en: An external power supply
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部电源
- en: We already used USB for supplying power to the Arduino since the beginning of
    the section. This is a pretty nice way to begin (and even to make a great project).
    This is easy and works for many purposes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们就已经使用USB为Arduino供电。这是一种相当好的开始方式（甚至可以做出一个很棒的项目）。这很简单，适用于许多用途。
- en: We can also use an external power supply when we need more autonomy and mobility
    with our Arduino devices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更多的自主性和移动性时，我们也可以使用外部电源为Arduino设备供电。
- en: In any case, we have to keep in mind that both our Arduino and our circuits
    wired to it need power. Usually, the Arduino consumption is no more than 50mA.
    Add some LEDs and you'll see the consumption increase.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们都要记住，我们的Arduino及其连接的电路都需要供电。通常，Arduino的功耗不超过50mA。添加一些LED，你会发现功耗增加。
- en: Let's check some cases of real use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一些实际应用的案例。
- en: Classic cases of USB power supplying
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典的USB供电案例
- en: Why and when would we use a USB power supply?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么和什么时候会使用USB电源？
- en: Obviously, if we need our computer connected to our Arduino for data communication
    purposes, we can naturally supply power to the Arduino through the USB.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们需要我们的电脑连接到Arduino进行数据通信，我们可以自然地通过USB为Arduino供电。
- en: This is the main reason for using a USB power supply.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用USB电源的主要原因。
- en: There are also some cases where we cannot have a lot of power sockets. Sometimes,
    there are many constraints in installation design projects and we don't have a
    lot of power sockets. This is also one case of supplying power using the USB.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些情况，我们无法拥有很多电源插座。有时，在安装设计项目中存在许多限制，我们没有很多电源插座。这也是使用USB供电的一个例子。
- en: Basically, the first thing to bear in mind before using power supplied by the
    USB port is the global consumption amount of our circuit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在使用USB端口供电之前，首先要考虑的是我们电路的全球功耗。
- en: Indeed, as we have already learned, the maximum current a USB port can provide
    is around 500mA. Be sure you don't exceed this value. Above this limit of consumption,
    things become totally unpredictable and some computers can even reboot while some
    others can disable all USB ports. We have to keep that in mind.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，正如我们已经学到的，USB端口可以提供的最大电流大约是500mA。确保不要超过这个值。超过这个功耗限制，事情变得完全不可预测，有些电脑甚至可能重新启动，而有些电脑可能禁用所有USB端口。我们必须记住这一点。
- en: Supplying external power
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部电源供电
- en: 'There are two different ways to supply power to an Arduino-based system. We
    can state the two main power supplies as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方式为基于Arduino的系统供电。我们可以将两种主要的电源供应方式表述为：
- en: Batteries
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池
- en: Power adapters
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源适配器
- en: Supplying with batteries
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用电池供电
- en: If we remember correctly, the Arduino Uno and Mega for instance can operate
    on an external power supply of 6 V to 20 V. For stable use, the recommended range
    is 7 V to 12 V. 9 V is an ideal voltage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得正确的话，Arduino Uno和Mega等实例可以在6 V到20 V的外部电源下运行。为了稳定使用，建议的范围是7 V到12 V。9 V是一个理想的电压。
- en: 'In order to set the board to external power supply, you have to take care of
    the power jumper. We have to put it on the external power supply side, named EXT.
    This setup is for the Arduino Diecimilla and older the Arduino boards:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将板设置为外部电源供电，你必须注意电源跳线。我们必须将其放在外部电源侧，称为EXT。这种设置适用于Arduino Diecimilla和较老的Arduino板：
- en: '![Supplying with batteries](img/7584_10_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用电池供电](img/7584_10_008.jpg)'
- en: The power supply jumper put on the EXT side, meaning set up to external power
    supply
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将电源跳线放在EXT侧，意味着设置为外部电源
- en: 'Let''s check the basic wiring with a 9 V battery:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用9 V电池检查基本接线：
- en: '![Supplying with batteries](img/7584_10_009.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用电池供电](img/7584_10_009.jpg)'
- en: A 9V battery wired to an Arduino board UNO R3
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接到Arduino板UNO R3的9V电池
- en: This simple wiring provides a way to supply power to the Arduino board. If you
    plug some other circuits to the Arduino, the battery through the Arduino will
    feed them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的接线提供了一种为Arduino板供电的方法。如果你将其他电路连接到Arduino上，通过Arduino的电池将为它们供电。
- en: 'There are also some other types of batteries that we can use. Coin cell batteries
    are a nice way to save space while supplying power externally:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他类型的电池。纽扣电池是一种在外部供电时节省空间的好方法：
- en: '![Supplying with batteries](img/7584_10_010.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用电池供电](img/7584_10_010.jpg)'
- en: A classic coin cell battery
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的纽扣电池
- en: 'There are many type of coin cell holders to use this type of battery in our
    circuits. Usually, coin cell batteries provide 3.6 V at 110 mAh. If this cannot
    supply power to the Arduino Uno, it can easily supply the Arduino Pro Mini working
    at a voltage of 3.3 V:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的纽扣电池座，可以在我们的电路中使用这种电池。通常，纽扣电池提供3.6 V，110 mAh。如果这不能为Arduino Uno供电，它可以轻松地为工作在3.3
    V电压下的Arduino Pro Mini供电：
- en: '![Supplying with batteries](img/7584_10_011.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用电池供电](img/7584_10_011.jpg)'
- en: Arduino Pro Mono
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Pro Mono
- en: The Arduino Pro Mini board is really interesting as it can be embedded in many
    circuits that need to be discrete and sometimes hidden in walls for digital art
    installations or put into a small plastic box that can be carried in a pocket
    when they are used as a mobile tool.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Pro Mini板非常有趣，因为它可以嵌入许多需要离散和有时隐藏在墙内的电路中，用于数字艺术安装，或者当它们作为移动工具使用时，可以放入可以放入口袋的小塑料盒中。
- en: We can also use polymer lithium-ion batteries. I used them a couple of times
    for an autonomous device project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用聚合物锂离子电池。我曾在几个自主设备项目中使用过它们。
- en: However, we can have some projects that require more power.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能会有一些需要更多电力的项目。
- en: Power adapter for Arduino supply
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino电源适配器
- en: 'For projects requiring more power, we have to use an external power supply.
    The setup of the Arduino stays the same as with batteries. The off-the-shelf Arduino
    adapter has to meet some requirements:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要更多电力的项目，我们必须使用外部电源。Arduino的设置与使用电池时相同。现成的Arduino适配器必须满足一些要求：
- en: DC adapter (No AC adapter here!)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直流适配器（这里没有交流适配器！）
- en: Output voltage between 9V and 12V DC
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出电压为9V至12V直流电
- en: Able to output a minimum current of 250mA but aim at 500mA at least or preferably
    1A
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少能输出250mA的最低电流，但目标是500mA或更佳，最好是1A
- en: Must have a centre positive 2.1mm power plug
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个中心正极2.1mm电源插头
- en: Here are the patterns you have to look for on your adapter before plugging in
    the Arduino.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入Arduino之前，你必须在适配器上寻找以下图案。
- en: 'First, the center of the connector has to be the positive part; check out the
    following diagram. You should see that on an Arduino-compatible adapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，连接器的中心必须是正极部分；查看以下图解。你应该能看到在Arduino兼容适配器上：
- en: '![Power adapter for Arduino supply](img/7584_10_012.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino电源适配器](img/7584_10_012.jpg)'
- en: The symbol showing the center positive plug
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表示中心正极插头的符号
- en: 'Then, the voltage and current characteristics. This has to show something like:
    OUTPUT: 12 VDC 1 A. This is an example; 12 VDC and 5 A is also fine. Don''t forget
    that current is only driven by what''s there in your circuit. A power adapter
    that puts out a higher current will not harm your circuit, because a circuit will
    only draw what it needs.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，电压和电流特性。这必须显示类似以下内容：输出：12 VDC 1 A。这是一个例子；12 VDC和5 A也是可以的。别忘了电流只由电路中的内容驱动。输出更高电流的电源适配器不会损害你的电路，因为电路只会吸取它需要的。
- en: A lot of adapters are available in the market and can be used with our Arduino
    boards.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有很多适配器可供使用，并且可以与我们的Arduino板一起使用。
- en: How to calculate current consumption
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何计算电流消耗
- en: In order to calculate current in your circuit, you have to use Ohm's law as
    described in the first chapter of this book.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算电路中的电流，你必须使用本书第一章中描述的欧姆定律。
- en: When you check the datasheet of a component, like an LED, you can see that the
    current passed through it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查一个组件的数据表，比如LED，你可以看到通过它的电流。
- en: 'Let''s check the RGB LED Common Cathode with this datasheet: [https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf](https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这份数据表检查RGB共阴极LED：[https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf](https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf)
- en: 'We can see a forward current of 20 mA and a peak forward current of 30 mA.
    If we have five LEDs like that switched on at the maximum brightness (that is
    red, blue, and green lighted up), we have: 5 x (20 + 20 + 20) = 300 mA needed
    for normal use and even peaks would consume 5 x (30 + 30 + 30) = 450 mA.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到正向电流为20 mA，峰值正向电流为30 mA。如果我们有五个这样的LED以最大亮度开启（即红色、蓝色和绿色点亮），我们就有：5 x (20
    + 20 + 20) = 300 mA的正常使用电流，甚至峰值也会消耗5 x (30 + 30 + 30) = 450 mA。
- en: This is in the case where all LEDs are fully switched on at the same time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有LED都同时完全开启。
- en: You must have understood the strategy we already used in power supply cycling,
    switching on each LED one after the other in quick succession. This provides a
    way to reduce the power consumption and also allow some projects to use a lot
    of LEDs without requiring an external power adapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须已经理解了我们已经在电源循环中使用的策略，即依次快速开启每个LED。这提供了一种减少功耗的方法，同时也允许一些项目使用大量LED而不需要外部电源适配器。
- en: I won't describe the calculations for each case here, but you'd have to refer
    to electricity rules to precisely calculate the consumption.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里描述每种情况的计算，但你必须参考电学规则来精确计算消耗。
- en: By experience, there is nothing better than your voltmeter and Ampere meter,
    the former measuring voltage between two points and the latter measuring current
    at some points along the circuit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，没有比你的电压表和安培表更好的工具了，前者测量两点之间的电压，后者测量电路中某些点的电流。
- en: 'I''d suggest that you make some calculations to be sure to:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你做一些计算以确保：
- en: Not override the Arduino capacity per pins
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要超过Arduino每引脚的容量
- en: Not override USB 450mA limit, in case you use a USB power supply
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要超过USB 450mA的限制，以防你使用USB电源
- en: Then, after that, begin to wire and measure at the same time with voltmeter
    and Ampere meter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，之后，同时使用电压表和安培表进行布线和测量。
- en: 'At last, a classic reference for most of the Arduino boards is available at
    this page: [http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations](http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，大多数Arduino板的一个经典参考可以在本页找到：[http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations](http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations)。
- en: We can find the limitations for current consumption for each part of the Arduino.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到Arduino每个部分的电流消耗限制。
- en: Drawing on gLCDs
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在gLCD上绘图
- en: Drawing is always fun. Drawing and handling LCD displays instead of LEDs matrices
    is really interesting too, because we have devices with high-density points we
    can switch on and off easily.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图总是很有趣。与LED矩阵相比，绘制和处理LCD显示也很有趣，因为我们有可以轻松开关的高密度点设备。
- en: LCDs exist in many types. The two main types are the character and graphical
    type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: LCD存在许多类型。两种主要类型是字符和图形类型。
- en: We are talking about the graphical type here, especially those based on the
    KS0108 graphics-only controller used in many regular gLCD devices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的是图形类型，特别是基于在许多常规gLCD设备中使用的KS0108图形控制器。
- en: We are going to use a nice library that is available on Google. It has code
    by Michael Margolis and Bill Perry, and it is named `glcd-arduino`. This library
    is licensed under the GNU Lesser GPL.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个在Google上可用的优秀库。它包含Michael Margolis和Bill Perry的代码，命名为`glcd-arduino`。此库根据GNU
    Lesser GPL许可。
- en: 'Let''s download it here: [http://code.google.com/p/glcd-arduino/downloads/list](http://code.google.com/p/glcd-arduino/downloads/list).
    Download the most recent version.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里下载它：[http://code.google.com/p/glcd-arduino/downloads/list](http://code.google.com/p/glcd-arduino/downloads/list)。下载最新版本。
- en: Unzip it, put it in the place where all your libraries are, and restart or start
    your Arduino IDE.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 解压它，将其放在所有库所在的目录中，然后重新启动或启动你的Arduino IDE。
- en: You should now see a lot of examples related to the gLCD library.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到很多与gLCD库相关的示例。
- en: 'We won''t check all the nice features and functions provided by this library
    here, but you can check this page on the Arduino website: [http://playground.arduino.cc/Code/GLCDks0108](http://playground.arduino.cc/Code/GLCDks0108).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会检查这个库提供的所有优秀功能和功能，但您可以在Arduino网站上查看这个页面：[http://playground.arduino.cc/Code/GLCDks0108](http://playground.arduino.cc/Code/GLCDks0108)。
- en: Wiring the device
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接设备
- en: 'We are going to check the wiring of a KS0108 based gLCD type Panel B:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查基于KS0108的gLCD类型面板B的连接：
- en: '![Wiring the device](img/7584_10_013.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![连接设备](img/7584_10_013.jpg)'
- en: A lot of wires wiring the gLCD to Arduino and the potentiometer to adjust LCD
    contrast
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将许多线连接到Arduino和电位器以调整LCD对比度
- en: 'The corresponding electrical diagram is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电气图如下：
- en: '![Wiring the device](img/7584_10_014.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![连接设备](img/7584_10_014.jpg)'
- en: KS0108 based gLCD type Panel B wired to an Arduino Uno R3
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 基于KS0108的gLCD类型面板B连接到Arduino Uno R3
- en: These are a lot of wires. Of course, we can multiply things. We can also use
    an Arduino MEGA and keep using the other digital pin available for other purposes,
    but that is not the point here. Let's check some of the functions of this powerful
    library.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多线。当然，我们可以乘以东西。我们还可以使用Arduino MEGA并继续使用其他数字引脚用于其他目的，但这不是重点。让我们检查这个强大库的一些功能。
- en: Demoing the library
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示库
- en: Take the example named `GLCDdemo`. It shows you almost all the functions available
    in the library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 查看名为`GLCDdemo`的示例。它展示了库中几乎所有的功能。
- en: 'There is very good PDF documentation provided with the library. It explains
    each available method. You can find it in the `library` folder in the `doc` subfolder:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 库中提供了非常好的PDF文档。它解释了每个可用的方法。您可以在`library`文件夹中的`doc`子文件夹中找到它：
- en: '![Demoing the library](img/7584_10_015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![演示库](img/7584_10_015.jpg)'
- en: The documentation of gLCD-Arduino showing the screen coordinates system
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: gLCD-Arduino文档显示屏幕坐标系系统
- en: At first, we have to include `glcd.h` in order to use the library. Then, we
    have to include some other headers, in this example, fonts and bitmap in order
    to use the font typographic methods and the bitmap objects too.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须包含`glcd.h`以使用库。然后，我们必须包含一些其他头文件，在这个例子中，字体和位图，以便使用字体排版方法和位图对象。
- en: Some useful method's families
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些有用的方法家族
- en: 'I''d suggest ordering learning methods into three parts:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议将学习方法分为三个部分：
- en: Global GLCD methods
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局GLCD方法
- en: Drawing methods
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图方法
- en: Text methods
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本方法
- en: Global GLCD methods
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局GLCD方法
- en: The first is the `init()` function. This one initializes the library and has
    to be called before any other gLCD methods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是`init()`函数。这个函数初始化库，必须在调用任何其他gLCD方法之前调用。
- en: The `SetDisplayMode()` function is useful because it sets up the use of the
    LCD as normal (writing in black over white background) or inverted. White just
    means not black. The real color depends on the backlight color, of course.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDisplayMode()` 函数很有用，因为它设置LCD的使用为正常（在白色背景上用黑色书写）或反转。白色只是意味着不是黑色。真正的颜色当然取决于背光颜色。'
- en: The `ClearScreen()` function erases the screen, filling it with white background
    in normal mode, or black in inverted mode.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearScreen()` 函数擦除屏幕，在正常模式下填充白色背景，或在反转模式下填充黑色。'
- en: The `ReadData()` and `WriteData()` functions are really raw methods that get
    and set the byte of data at particular coordinates.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadData()` 和 `WriteData()` 函数是真正原始的方法，它们获取和设置特定坐标处的字节数据。'
- en: Drawing methods
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘图方法
- en: These are a set of functions dedicated to drawing on the screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一组专门用于在屏幕上绘制的函数。
- en: 'The set of constants are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 常量集合如下：
- en: '`GLCD.Width` is the display width in pixels'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLCD.Width` 是显示宽度（以像素为单位）'
- en: '`GLCD.Height` is the display height in pixels'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLCD.Height` 是显示高度（以像素为单位）'
- en: '`GLCD.Right` is the last pixel column at the right (equals GLCD.Width – 1)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLCD.Right` 是最右侧的最后一行像素（等于 GLCD.Width – 1）'
- en: '`GLCD.Bottom` is the last pixel row at the bottom (equals GLCD. Height – 1)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLCD.Bottom` 是底部最后一行像素（等于 GLCD.Height – 1）'
- en: '`GLCD.CenterX` and `GLCD.CenterY` are the coordinates of the pixel in the middle'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLCD.CenterX` 和 `GLCD.CenterY` 是像素中心的坐标'
- en: 'Basically, you can draw by moving the graphics cursor and by drawing primitive
    shapes:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你可以通过移动图形光标和绘制原始形状来绘图：
- en: '| Function | Description |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GotoXY()` | Moves the cursor to specific coordinates |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `GotoXY()` | 将光标移动到特定坐标 |'
- en: '| `DrawVLine()` | Draws a vertical line from a point to another point in the
    same pixel column but above or below the initial point |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `DrawVLine()` | 在同一像素列中从一点绘制到另一点，但位于初始点的上方或下方|'
- en: '| `DrawHLine()` | Works the same as `DrawVLine()` but on the same pixel row
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `DrawHLine()` | 与 `DrawVLine()` 工作方式相同，但在同一像素行上 |'
- en: '| `DrawLine()` | Draws a line between two coordinates |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `DrawLine()` | 在两个坐标之间绘制线条|'
- en: 'Some other, more complex shapes can be drawn too:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以绘制一些更复杂的形状：
- en: '| Functions | Descriptions |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DrawRect()` | Draws a rectangle from a point when provided with a width
    and height. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRect()` | 当提供宽度和高度时，从一点绘制矩形。|'
- en: '| `FillRect()` | Works the same as `DrawRect()`, but by filling the rectangle
    shape with black (or white) pixels. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `FillRect()` | 与 `DrawRect()` 工作方式相同，但通过用黑色（或白色）像素填充矩形形状。|'
- en: '| `DrawRoundRect()` | Draws a nice rectangle with rounded corners. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRoundRect()` | 绘制具有圆角的矩形。|'
- en: '| `DrawCircle()` and `FillCircle()` | Draws a circle from coordinates and a
    radius, and a circle filled with black (or white) pixels. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `DrawCircle()` 和 `FillCircle()` | 从坐标和半径绘制圆，以及用黑色（或白色）像素填充的圆。|'
- en: '| `DrawBitmap()` | Draws a whole bitmap at a particular position on the screen.
    It uses a pointer to that bitmap in memory. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `DrawBitmap()` | 在屏幕上的特定位置绘制整个位图。它使用指向该位图的内存中的指针。|'
- en: With this set of functions, you can basically draw anything you want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这组函数，你可以基本上绘制任何你想要的东西。
- en: Text methods
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本方法
- en: 'These are a set of functions dedicated to typography on the screen:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一组专门用于屏幕排版的函数：
- en: '| Functions | Descriptions |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SelectFont()` | At first, this chooses the font to be used in the next functions
    calls. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `SelectFont()` | 首先，这选择在后续函数调用中使用的字体。|'
- en: '| `SetFontColor()` | Chooses the color. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `SetFontColor()` | 选择颜色。|'
- en: '| `SetTextMode()` | Chooses a scrolling direction. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `SetTextMode()` | 选择滚动方向。|'
- en: '| `CursorTo()` | Moves the cursor to a specific column and row. The column
    calculation uses the width of the widest character. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `CursorTo()` | 将光标移动到特定的列和行。列的计算使用最宽字符的宽度。|'
- en: '| `CursorToXY()` | Moves the cursor to particular pixel coordinate. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `CursorToXY()` | 将光标移动到特定的像素坐标。|'
- en: One important feature to know about, is the fact that Arduino's print functions
    can be used with gLCD library; `GLCD.print()` works fine, for instance. There
    are also a couple of other functions available that can be found on the official
    website.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的特性需要了解，那就是Arduino的打印函数可以与gLCD库一起使用；例如，`GLCD.print()` 可以正常工作。官方网站上还有其他一些函数可供使用。
- en: At last, I'd suggest you to test the example named `life`. This is based on
    the John Conway's Game of Life. This is a nice example of what you can do and
    implement some nice and useful logic.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我建议您测试名为 `life` 的示例。这是基于约翰·康威的生命游戏。这是一个很好的例子，展示了您可以做什么，并实现一些不错且有用的逻辑。
- en: Drawing on gLCD is nice, but we could also use a small module handling VGA.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 gLCD 上绘图很棒，但我们也可以使用一个小型处理 VGA 的模块。
- en: Using VGA with the Gameduino Shield
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gameduino 扩展板通过 VGA 输出
- en: Gameduino is an Arduino Shield. This is the first one we are using here in this
    book. Basically, a shield is a PCB (printed circuit board) that can be plugged
    to another PCB, here our Arduino.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Gameduino 是一个 Arduino 扩展板。这是我们在这本书中首次使用的一个。基本上，扩展板是一个可以插入到另一个 PCB（印刷电路板）上的 PCB，这里指的是我们的
    Arduino。
- en: Arduino Shields are pre-made circuits including components and sometimes processors
    too. They add features to our Arduino board by handling some specific tasks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 扩展板是预制的电路，包括组件，有时还包括处理器。它们通过处理一些特定任务来为我们的 Arduino 板添加功能。
- en: Here, the Gameduino will add VGA drawing abilities to our Arduino that can't
    be done on its own.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Gameduino 将为我们的 Arduino 添加无法自行完成的 VGA 绘图功能。
- en: The Gameduino adds a VGA port, a mini-jack for the sound, and also includes
    an FPGA Xilling Spartan3A. FPGA Xilling Spartan3A can process graphical data faster
    than the Arduino itself. Arduino can control this graphical hardware driver by
    SPI interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Gameduino 添加了一个 VGA 端口、一个用于声音的迷你插孔，并且还包含了一个 FPGA Xilling Spartan3A。FPGA Xilling
    Spartan3A 可以比 Arduino 本身更快地处理图形数据。Arduino 可以通过 SPI 接口控制这个图形硬件驱动程序。
- en: 'Let''s see how it works:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '![Using VGA with the Gameduino Shield](img/7584_10_016.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Gameduino 扩展板通过 VGA 输出](img/7584_10_016.jpg)'
- en: The Gameduino controller Arduino Shield
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Gameduino 控制器 Arduino 扩展板
- en: 'Arduino Shields can be plugged in Arduino boards directly. Check the following
    screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 扩展板可以直接插入 Arduino 板。请查看以下截图：
- en: '![Using VGA with the Gameduino Shield](img/7584_10_017.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Gameduino 扩展板通过 VGA 输出](img/7584_10_017.jpg)'
- en: The Gameduino plugged in the Arduino board
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Gameduino 插入 Arduino 板
- en: 'Here are some characteristics of the Gameduino:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Gameduino 的一些特点：
- en: Video output is 400 x 300 pixels in 512 colors
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频输出为 400 x 300 像素，512 种颜色
- en: All color processed internally at 15 bit precision
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有颜色都以内置 15 位精度处理
- en: Compatible with any standard VGA monitor (800 x 600 @ 72 Hz)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容任何标准 VGA 显示器（800 x 600 @ 72 Hz）
- en: Background graphics (512 x 512 pixel character, 256 characters)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景图形（512 x 512 像素字符，256 个字符）
- en: Foreground graphics (sprite 16 x 16 abilities, transparency, rotate/flip, and
    sprite collision detection)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前景图形（16 x 16 像素精灵能力，透明度，旋转/翻转，精灵碰撞检测）
- en: Audio output as stereo; 12-bit frequency synthesizer
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频输出为立体声；12 位频率合成器
- en: 64 independent voices at 10 to 8000 hz
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64 个独立的 10 到 8000 Hz 语音
- en: Sample playback channel
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本回放通道
- en: The underlying concept is to plug it in the Arduino and to control it using
    our Arduino firmware with the library taking care of all SPI communication between
    the Arduino and Gameduino.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念是将它插入 Arduino，并使用我们的 Arduino 固件来控制它，库负责处理 Arduino 和 Gameduino 之间的所有 SPI
    通信。
- en: 'We cannot describe all the examples right here in this book, but I want to
    point you in the right direction. At first, the official website: [http://excamera.com/sphinx/gameduino/](http://excamera.com/sphinx/gameduino/).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里描述所有示例，但我希望您能找到正确的方向。首先，官方网站：[http://excamera.com/sphinx/gameduino/](http://excamera.com/sphinx/gameduino/)。
- en: 'You can find the library here: [http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip](http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到库：[http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip](http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip)。
- en: 'You can also check and use the quick reference poster here: [http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf](http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处查看和使用快速参考海报：[http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf](http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf)。
- en: For your information, I'm currently designing a piece on digital art installation
    based on this shield. I intend to describe it on my own website [http://julienbayle.net](http://julienbayle.net)
    and the whole schematics will be provided too.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的信息，我目前正在设计一个基于这个扩展板的数字艺术装置。我打算在我的个人网站上[http://julienbayle.net](http://julienbayle.net)描述它，并且还会提供整个电路图。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first, advanced chapter, we learned a bit more about how to deal with
    new concrete concepts such as storing data on non-volatile memories (internal
    and external EEPROM), use GPS module receivers, draw on graphical LCD, and use
    a nice Arduino Shield named Gameduino to add new features and power to our Arduino.
    This allowed it to display a VGA signal and also to produce audio. We also learned
    the use of Arduino as a very portable and mobile device, autonomous from the power
    supply point of view.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个、高级章节中，我们了解了一些关于如何处理新具体概念的方法，例如在非易失性存储器（内部和外部EEPROM）上存储数据，使用GPS模块接收器，在图形LCD上绘图，以及使用一个名为Gameduino的Arduino
    Shield来添加新功能和增强我们的Arduino。这使得它能够显示VGA信号，并且还能产生音频。我们还学习了Arduino作为一个非常便携和移动设备的用途，从电源供应的角度来看是自给自足的。
- en: In the next chapter, we are going to talk about networking concepts. Creating
    and using networks are usual ways of communication today. We will describe wired
    and wireless network use with our Arduino projects in the next chapter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论网络概念。创建和使用网络是当今常见的通信方式。在下一章中，我们将描述使用Arduino项目进行有线和无线网络的使用。
