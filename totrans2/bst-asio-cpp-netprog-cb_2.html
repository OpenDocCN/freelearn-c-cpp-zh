<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. I/O Operations</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using fixed length I/O buffers</li><li class="listitem" style="list-style-type: disc">Using extensible stream-oriented I/O buffers</li><li class="listitem" style="list-style-type: disc">Writing to a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">Reading from a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">Writing to a TCP socket asynchronously</li><li class="listitem" style="list-style-type: disc">Reading from a TCP socket asynchronously</li><li class="listitem" style="list-style-type: disc">Canceling asynchronous operations</li><li class="listitem" style="list-style-type: disc">Shutting down and closing a socket</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Introduction</h1></div></div></div><p>I/O operations <a id="id59" class="indexterm"/>are the key operations in the networking infrastructure of any distributed application. They are directly involved in the process of data exchange. Input operations are used to receive data from remote applications, whereas output operations allow sending data to them.</p><p>In this chapter, we will see several recipes that show how to perform I/O operations and other operations related to them. In addition to this, we'll see how to use some classes provided by Boost.Asio, which are used in conjunction with I/O operations.</p><p>The following is the short summary and introduction to the topics discussed in this chapter.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>I/O buffers</h2></div></div></div><p>Network <a id="id60" class="indexterm"/>programming is all about organizing inter-process communication over a computer network. <strong>Communication</strong> <a id="id61" class="indexterm"/>in this context implies exchanging data between two or more processes. From the perspective of a process that participates in such communication, the process performs I/O operations, sending data to and receiving it from other participating processes.</p><p>Like any <a id="id62" class="indexterm"/>other type of I/O, the network I/O involves using memory buffers, which are contiguous blocks of memory allocated in the process's address space used to store the data. When doing any sort of input operation (for example, reading some data from a file, a pipe, or a remote computer over the network), the data arrives at the process and must be stored somewhere in its address space so that it is available for further processing. That is, when the buffer comes in handy. Before performing an input operation, the buffer is allocated and then used as a data destination point during the operation. When the input operation is completed, the buffer contains input data, which can be processed by the application. Likewise, before performing the output operation, the data must be prepared and put into an output buffer, which is then used in the output operation, where it plays the role of the data source.</p><p>Apparently, the buffers are essential ingredients of any application that performs any type of I/O, including the network I/O. That's why it is critical for the developer who develops a distributed application to know how to allocate and prepare the I/O buffers to use them in the I/O operations.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Synchronous and asynchronous I/O operations</h2></div></div></div><p>Boost.Asio supports <a id="id63" class="indexterm"/>two types of I/O operations: synchronous and asynchronous. Synchronous operations block the thread of execution invoking them and unblock only when the operation is finished. Hence, the name of this type of operation: synchronous.</p><p>The second type is an asynchronous operation. When an <a id="id64" class="indexterm"/>asynchronous operation is initiated, it is associated with a callback function or functor, which is invoked by the Boost.Asio library when the operation is finished. These types of I/O operations provide great flexibility, but may significantly complicate the code. The initiation of the operation is simple and doesn't block the thread of execution, which allows us to use the thread to run other tasks, while the asynchronous operation is being run in the background.</p><p>The Boost.Asio library is implemented as a framework, which exploits an <a id="id65" class="indexterm"/>
<strong>inversion of control</strong> approach. After one or more asynchronous operations are initiated, the application hands over one of its threads of execution to the library, and the latter uses this thread to run the event loop and invoke the callbacks provided by the application to notify it about the completion of the previously initiated asynchronous operation. The results of asynchronous operations are passed to the callback as arguments.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Additional operations</h2></div></div></div><p>In addition<a id="id66" class="indexterm"/> to this, we are going to consider such operations as canceling asynchronous operations, shutting down, and closing a socket.</p><p>The ability to cancel a previously initiated asynchronous operation is very important. It allows the application to state that the previously initiated operation is not relevant anymore, which may save the application's resources (both CPU and memory), that otherwise (in case, the operation would continue its execution even after it was known that nobody is interested in it anymore) would be unavoidably wasted.</p><p>Shutting down the socket is useful if there is a need for one part of the distributed application to inform the other part that the whole message has been sent, when the application layer protocol does not provide us with other means to indicate the message boundary.</p><p>As with any other operating system resource, a socket should be returned back to the operating system when it is not needed anymore by the application. A closing operation allows us to do so.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using fixed length I/O buffers</h1></div></div></div><p>Fixed length I/O buffers <a id="id67" class="indexterm"/>are usually used with I/O operations and play the role of either a data source or destination when the size of the message to be sent or received is known. For example, this can be a constant array of chars allocated on a stack, which contain a string that represents the request to be sent to the server. Or, this can be a writable buffer allocated in the free memory, which is used as a data destination point, when reading data from a socket.</p><p>In this recipe, we'll see how to represent fixed length buffers so that they can be used with Boost.Asio I/O operations.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How to do it…</h2></div></div></div><p>In Boost.Asio, a fixed length buffer is represented by one of the two classes: <code class="literal">asio::mutable_buffer</code> or <code class="literal">asio::const_buffer</code>. Both these classes represent a contiguous block of memory that is specified by the address of the first byte of the block and its size in bytes. As the names of these classes suggest, <code class="literal">asio::mutable_buffer</code> represents a writable buffer, whereas <code class="literal">asio::const_buffer</code> represents a read-only one.</p><p>However, neither the <code class="literal">asio::mutable_buffer</code> nor <code class="literal">asio::const_buffer</code> classes are used in Boost.Asio I/O functions and methods directly. Instead, the <code class="literal">MutableBufferSequence</code> and <code class="literal">ConstBufferSequence</code> concepts are introduced.</p><p>The<code class="literal"> MutableBufferSequence</code> concept specifies an object that represents a collection of the <code class="literal">asio::mutable_buffer</code> objects. Correspondingly, the <code class="literal">ConstBufferSequence</code> concept specifies an <a id="id68" class="indexterm"/>object that represents a collection of the <code class="literal">asio::const_buffer</code> objects. Boost.Asio functions and methods that perform I/O operations accept objects that satisfy the requirements of either the <code class="literal">MutableBufferSequence</code> or <code class="literal">ConstBufferSequence</code> concept as their arguments that represent buffers.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>A complete specification of the <code class="literal">MutableBufferSequence</code> and <code class="literal">ConstBufferSequence</code> concepts are available in the Boost.Asio documentation section, which can be found at the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html</a> for <code class="literal">MutableBufferSequence</code></li><li class="listitem" style="list-style-type: disc">Refer to <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html</a> for <code class="literal">ConstBufferSequence</code></li></ul></div></div></div><p>Although in most use cases, a single buffer is involved in a single I/O operation, in some specific circumstances (for example, in a memory-constrained environment), a developer may want to use a composite buffer that comprises multiple smaller simple buffers distributed over the process's address space. Boost.Asio I/O functions and methods are designed to work with composite buffers that are represented as a collection of buffers that fulfill the requirements of either the <code class="literal">MutableBufferSequence</code> or <code class="literal">ConstBufferSequence</code> concept.</p><p>For instance, an object of the <code class="literal">std::vector&lt;asio::mutable_buffer&gt;</code> class satisfies the requirements of the <code class="literal">MutableBufferSequence</code> concept, and therefore, it can be used to represent a composite buffer in I/O-related functions and methods.</p><p>So, now we know that if we have a buffer that is represented as an object of the <code class="literal">asio::mutable_buffer</code> or <code class="literal">asio::const_buffer</code> class, we still can't use it with I/O-related functions or methods provided by Boost.Asio. The buffer must be represented as an object, satisfying the requirements of either the <code class="literal">MutableBufferSequence</code> or <code class="literal">ConstBufferSequence</code> concept, respectively. To do this, we for example could create a collection of buffer objects consisting of a single buffer by instantiating an object of the <code class="literal">std::vector&lt;asio::mutable_buffer&gt;</code> class and placing our buffer object into it. Now that the buffer is part of the collection, satisfying the <code class="literal">MutableBufferSequence</code> requirements can be used in I/O operations.</p><p>However, although this method is fine to create composite buffers consisting of two or more simple buffers, it looks overly complex when it comes to such simple tasks as representing a single simple buffer so that it can be used with Boost.Asio I/O functions or methods. Fortunately, Boost.Asio provides us with a way to simplify the usage of single buffers with I/O-related functions and methods.</p><p>The <code class="literal">asio::buffer()</code> free <a id="id69" class="indexterm"/>function has 28 overloads that accept a variety of representations of a buffer and return an object of either the <code class="literal">asio::mutable_buffers_1</code> or <code class="literal">asio::const_buffers_1</code> classes. If the buffer argument passed to the <code class="literal">asio::buffer()</code> function is a read-only type, the function returns an object of the <code class="literal">asio::const_buffers_1</code> class; otherwise, an object of the <code class="literal">asio::mutable_buffers_1</code> class is returned.</p><p>The <code class="literal">asio::mutable_buffers_1</code> and <code class="literal">asio::const_buffers_1</code> classes are <em>adapters</em> of the <code class="literal">asio::mutable_buffer</code> and <code class="literal">asio::const_buffer</code> classes, respectively. They provide an interface and behavior that satisfy the requirements of the <code class="literal">MutableBufferSequence</code> and <code class="literal">ConstBufferSequence</code> concepts, which allows us to pass these adapters as arguments to Boost.Asio I/O functions and methods.</p><p>Let's consider two algorithms and corresponding code samples that describe how to prepare a memory buffer that can be used with Boost.Asio I/O operations. The first algorithm deals with buffers intended to be used for an output operation and the second one is used for an input operation.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Preparing a buffer for an output operation</h3></div></div></div><p>The<a id="id70" class="indexterm"/> following algorithm and corresponding code sample describes how to prepare a buffer that can be used with the Boost.Asio socket's method that performs an output operation such as <code class="literal">asio::ip::tcp::socket::send()</code> or the <code class="literal">asio::write()</code>free function:</p><div><ol class="orderedlist arabic"><li class="listitem">Allocate a buffer. Note that this step does not involve any functionality or data types from Boost.Asio.</li><li class="listitem">Fill the buffer with the data that is to be used as the output.</li><li class="listitem">Represent the buffer as an object that satisfies the <code class="literal">ConstBufferSequence</code> concept's requirements.</li><li class="listitem">The buffer is ready to be used with Boost.Asio output methods and functions.</li></ol></div><p>Let's say we want to send a string <code class="literal">Hello</code> to the remote application. Before we send the data using Boost.Asio, we need to properly represent the buffer. This is how we do this in the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

int main()
{
  std::string buf; // 'buf' is the raw buffer. 
  buf = "Hello";   // Step 1 and 2 in single line.

  // Step 3. Creating buffer representation that satisfies 
  // ConstBufferSequence concept requirements.
  asio::const_buffers_1 output_buf = asio::buffer(buf);

  // Step 4. 'output_buf' is the representation of the
  // buffer 'buf' that can be used in Boost.Asio output
  // operations.

  return 0;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Preparing a buffer for an input operation</h3></div></div></div><p>The<a id="id71" class="indexterm"/> following algorithm and corresponding code sample describes how to prepare the buffer that can be used with the Boost.Asios socket's method that performs an input operation such as <code class="literal">asio::ip::tcp::socket::receive()</code> or the <code class="literal">asio::read()</code>free function:</p><div><ol class="orderedlist arabic"><li class="listitem">Allocate a buffer. The size of the buffer must be big enough to fit the block of data to be received. Note that this step does not involve any functionalities or data types from Boost.Asio.</li><li class="listitem">Represent the buffer using an object that satisfies the <code class="literal">MutableBufferSequence</code> concept's requirements.</li><li class="listitem">The buffer is ready to be used with Boost.Asio input methods and functions.</li></ol></div><p>Let's say we want to receive a block of data from the server. To do this, we first need to prepare a buffer where the data will be stored. This is how we do this in the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt; // For std::unique_ptr&lt;&gt;

using namespace boost;

int main()
{
  // We expect to receive a block of data no more than 20 bytes 
  // long. 
  const size_t BUF_SIZE_BYTES = 20;

  // Step 1. Allocating the buffer. 
  std::unique_ptr&lt;char[]&gt; buf(new char[BUF_SIZE_BYTES]);

  // Step 2. Creating buffer representation that satisfies 
  // MutableBufferSequence concept requirements.
  asio::mutable_buffers_1 input_buf =
    asio::buffer(static_cast&lt;void*&gt;(buf.get()),
     BUF_SIZE_BYTES);

  // Step 3. 'input_buf' is the representation of the buffer
  // 'buf' that can be used in Boost.Asio input operations.
  
  return 0;
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How it works…</h2></div></div></div><p>Both the samples <a id="id72" class="indexterm"/>look quite simple and straightforward; however, they contain some subtleties, which are important to understand so that we can properly use buffers with Boost.Asio. In this section, we'll see how each sample works in detail.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Preparing a buffer for an output operation</h3></div></div></div><p>Let's <a id="id73" class="indexterm"/>consider the first code sample that demonstrates how to prepare a buffer that can be used with Boost.Asio output methods and functions. The <code class="literal">main()</code>entry point function starts with instantiating the object of the <code class="literal">std::string</code> class. Because we want to send a string of text, <code class="literal">std::string</code> is a good candidate to store this kind of data. In the next line, the string object is assigned a value of <code class="literal">Hello</code>. This is where the buffer is allocated and filled with data. This line implements steps 1 and 2 of the algorithm.</p><p>Next, before the buffer can be used with Boost.Asio I/O methods and functions, it must be properly represented. To better understand why this is needed, let's take a look at one of the Boost.Asio output functions. Here is the declaration of the <code class="literal">send()</code>method of the Boost.Asio class that represents a TCP socket:</p><div><pre class="programlisting">template&lt;typename ConstBufferSequence&gt;
std::size_t send(const ConstBufferSequence &amp; buffers);</pre></div><p>As we can see, this is a template method, and it accepts an object that satisfies the requirements of the <code class="literal">ConstBufferSeqenece</code> concept as its argument that represents the buffer. A suitable <a id="id74" class="indexterm"/>object is a composite object that represents a collection of objects of the <code class="literal">asio::const_buffer</code> class and provides a typical collection interface that supports an iteration over its elements. For example, an object of the <code class="literal">std::vector&lt;asio::const_buffer&gt;</code> class is suitable for being used as the argument of the <code class="literal">send()</code> method, but objects of the <code class="literal">std::string</code> or <code class="literal">asio::const_bufer</code> class are not.</p><p>In order to use our <code class="literal">std::string</code> object with the <code class="literal">send()</code>method of the class that represents a TCP socket, we can do something like this:</p><div><pre class="programlisting">asio::const_buffer asio_buf(buf.c_str(), buf.length());
std::vector&lt;asio::const_buffer&gt; buffers_sequence;
buffers_sequence.push_back(asio_buf);</pre></div><p>The object named <code class="literal">buffer_sequence</code> in the preceding snippet satisfies the <code class="literal">ConstBufferSequence</code> concept's requirements, and therefore, it can be used as an argument for the <code class="literal">send()</code> method of the socket object. However, this approach is very complex. Instead, we use the <code class="literal">asio::buffer()</code>function provided by Boost.Asio to obtain <em>adaptor</em> objects, which we can directly use in I/O operations:</p><div><pre class="programlisting">asio::const_buffers_1 output_buf = asio::buffer(buf);</pre></div><p>After the adaptor object is instantiated, it can be used with Boost.Asio output operations to represent the output buffer.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Preparing a buffer for an input operation</h3></div></div></div><p>The second code <a id="id75" class="indexterm"/>sample is very similar to the first one. The main difference is that the buffer is allocated but is not filled with data because its purpose is different. This time, the buffer is intended to receive the data from a remote application during the input operation.</p><p>With an output buffer, an input buffer must be properly represented so that it can be used with Boost.Asio I/O methods and functions. However, in this case, the buffer must be represented as an object that meets the requirements of the <code class="literal">MutableBufferSequence</code> concept. Contrary to <code class="literal">ConstBufferSequence</code>, this concept represents the collection of <em>mutable</em> buffers, that is, those that can be written to. Here, we use the <code class="literal">buffer()</code> function, which helps us create the required representation of the buffer. The object of the <code class="literal">mutable_buffers_1</code> adaptor class represents a single mutable buffer and meets the <code class="literal">MutableBufferSequence</code> concept's requirements.</p><p>In the first step, the buffer is allocated. In this case, the buffer is an array of chars allocated in the free memory. In the next step, the adaptor object is instantiated that can be used with both the input and output operations.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>
<strong>Buffer ownership</strong>
</p><p>It's important to note that neither the classes that represent the buffers nor the adaptor classes provided by Boost.Asio that we've considered (namely, <code class="literal">asio::mutable_buffer</code>, <code class="literal">asio::const_buffer</code>, <code class="literal">asio::mutable_buffers_1</code>, and <code class="literal">asio::const_buffers_1</code>) take ownership of the underlying raw buffer. These classes only provide the interface to the buffer and don't control its lifetime.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Writing to a TCP socket synchronously</em> recipe demonstrates how to write data to the socket from a fixed-length buffer</li><li class="listitem" style="list-style-type: disc">The <em>Reading from a TCP socket synchronously</em> recipe demonstrates how to read data from the socket to a fixed-length buffer</li><li class="listitem" style="list-style-type: disc">The <em>Using composite buffers for scatter/gather operations</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Other Topics">Chapter 6</a>, <em>Other Topics</em>, provides more information on composite buffers and demonstrates how to use them</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Using extensible stream-oriented I/O buffers</h1></div></div></div><p>Extensible buffers <a id="id76" class="indexterm"/>are those buffers that dynamically increase their size when new data is written to them. They are usually used to read data from sockets when the size of the incoming message is unknown.</p><p>Some application layer protocols do not define the exact size of the message. Instead, the boundary of the message is represented by a specific sequence of symbols at the end of the message itself or by a transport protocol service message <strong>end of file</strong> (<strong>EOF</strong>) issued by the sender after it finishes sending the message.</p><p>For example, according to the HTTP protocol, the header section of the request and response messages don't have a fixed length and its boundary is represented by a sequence of four ASCII symbols, <code class="literal">&lt;CR&gt;&lt;LF&gt;&lt;CR&gt;&lt;LF&gt;</code>, which is part of the message. In such cases, dynamically extensible buffers and functions that can work with them, which are provided by the Boost.Asio library, are very useful.</p><p>In this recipe, we will see how to instantiate extensible buffers and how to read and write data to and from them. To see how these buffers can be used with I/O-related methods and functions provided by Boost.Asio, refer to the corresponding recipes dedicated to I/O operations listed in the <em>See also</em> section.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>How to do it…</h2></div></div></div><p>Extensible stream-oriented buffers are represented in Boost.Asio with the <code class="literal">asio::streambuf</code> class, which is a <code class="literal">typedef</code> for <code class="literal">asio::basic_streambuf</code>:</p><div><pre class="programlisting">typedef basic_streambuf&lt;&gt; streambuf;</pre></div><p>The <code class="literal">asio::basic_streambuf&lt;&gt;</code> class is inherited from <code class="literal">std::streambuf</code>, which means that it <a id="id77" class="indexterm"/>can be used as a stream buffer for STL stream classes. In addition to this, several I/O functions provided by Boost.Asio deal with buffers that are represented as objects of this class.</p><p>We can work with an object of the <code class="literal">asio::streambuf</code> class just like we would work with any stream buffer class that is inherited from the <code class="literal">std::streambuf</code> class. For example, we can assign this object to a stream (for example, <code class="literal">std::istream</code>, <code class="literal">std::ostream</code>, or <code class="literal">std::iostream</code>, depending on our needs), and then, use stream's <code class="literal">operator&lt;&lt;()</code> and <code class="literal">operator&gt;&gt;()</code> operators to write and read data to and from the stream.</p><p>Let's consider a sample application in which an object of <code class="literal">asio::streambuf</code> is instantiated, some data is written to it, and then the data is read back from the buffer to an object of the <code class="literal">std::string</code> class:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

int main()
{
  asio::streambuf buf;

  std::ostream output(&amp;buf);

  // Writing the message to the stream-based buffer.
  output &lt;&lt; "Message1\nMessage2";

  // Now we want to read all data from a streambuf
  // until '\n' delimiter.
  // Instantiate an input stream which uses our 
  // stream buffer.
  std::istream input(&amp;buf);
  
  // We'll read data into this string.
  std::string message1;

  std::getline(input, message1);

  // Now message1 string contains 'Message1'.

  return 0;
} </pre></div><p>Note that this sample does <a id="id78" class="indexterm"/>not contain any network I/O operations because it focuses on the <code class="literal">asio::streambuf</code> class itself and its operations rather than on how to use this class with I/O operations.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How it works…</h2></div></div></div><p>The <code class="literal">main()</code> application<a id="id79" class="indexterm"/> entry point function begins with instantiating an object of the <code class="literal">asio::streambuf</code> class named <code class="literal">buf</code>. Next, the output stream object of the <code class="literal">std::ostream</code> class is instantiated. The <code class="literal">buf</code> object is used as a <em>stream buffer</em> for the output stream.</p><p>In the next line, the <code class="literal">Message1\nMessage2</code> sample data string is written to the output stream object, which in turn redirects the data to the <code class="literal">buf</code> stream buffer.</p><p>Usually, in a typical client or server application, the data will be written to the <code class="literal">buf</code> stream buffer by the Boost.Asio input function such as <code class="literal">asio::read()</code>, which accepts a stream buffer object as an argument and reads data from the socket to that buffer.</p><p>Now, we want to read the data back from the stream buffer. To do this, we allocate an input stream and pass the <code class="literal">buf</code> object as a stream buffer argument to its constructor. After this, we allocate a string object named <code class="literal">message1</code>, and then, use the <code class="literal">std::getline</code> function to read part of the string currently stored in the <code class="literal">buf</code> stream buffer until the delimiter symbol, <code class="literal">\n</code>.</p><p>As a result, the <code class="literal">string1</code> object contains the <code class="literal">Message1</code> string and the <code class="literal">buf</code> stream buffer contains the rest of the initial string after the delimiter symbol, that is, <code class="literal">Message2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Reading from a TCP socket asynchronously</em> recipe demonstrates how to read data from the socket to an extensible stream-oriented buffer</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Writing to a TCP socket synchronously</h1></div></div></div><p>Writing <a id="id80" class="indexterm"/>to a TCP socket is an output operation that is used to send data to the remote application connected to this socket. Synchronous writing is the simplest way to send the data using a socket provided by Boost.Asio. The methods and functions that perform synchronous writing to the socket block the thread of execution and do not return until the data (at least some amount of data) is written to the socket or an error occurs.</p><p>In this recipe, we will see how to write data to a TCP socket synchronously.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How to do it…</h2></div></div></div><p>The most basic<a id="id81" class="indexterm"/> way to write to the socket provided by the Boost.Asio library is to use the <code class="literal">write_some()</code> method of the <code class="literal">asio::ip::tcp::socket</code> class. Here is the declaration of one of the method's overloads:</p><div><pre class="programlisting">template&lt;
typename ConstBufferSequence&gt;
std::size_t write_some(
const ConstBufferSequence &amp; buffers);</pre></div><p>This method accepts an object that represents a composite buffer as an argument, and as its name suggests, writes <em>some</em> amount of data from the buffer to the socket. If the method succeeds, the return value indicates the number of bytes written. The point to emphasize here is that the method may <em>not</em> send all the data provided to it through the <code class="literal">buffers</code> argument. The method only guarantees that at least one byte will be written if an error does not occur. This means that, in a general case, in order to write all the data from the buffer to the socket, we may need to call this method several times.</p><p>The following algorithm describes the steps required to synchronously write data to a TCP socket in a distributed application:</p><div><ol class="orderedlist arabic"><li class="listitem">In a client application, allocate, open, and connect an active TCP socket. In a server application, obtain a connected active TCP socket by accepting a connection request using an acceptor socket.</li><li class="listitem">Allocate the buffer and fill it with data that is to be written to the socket.</li><li class="listitem">In a loop, call the socket's <code class="literal">write_some()</code> method as many times as it is needed to send all the data available in the buffer.</li></ol></div><p>The following code sample demonstrates a client application, which operates according to the algorithm:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

void writeToSocket(asio::ip::tcp::socket&amp; sock) {
  // Step 2. Allocating and filling the buffer.
  std::string buf = "Hello";

  std::size_t total_bytes_written = 0;

  // Step 3. Run the loop until all data is written
  // to the socket.
  while (total_bytes_written != buf.length()) {
    total_bytes_written += sock.write_some(
      asio::buffer(buf.c_str() +
      total_bytes_written,
      buf.length() - total_bytes_written));
  }
}

int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

// Step 1. Allocating and opening the socket.
    asio::ip::tcp::socket sock(ios, ep.protocol());

    sock.connect(ep);

    writeToSocket(sock);
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div><p>Although in the presented code sample, writing to the socket is performed in the context of an application that<a id="id82" class="indexterm"/> acts as a client, the same approach can be used to write to the socket in a server application.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How it works…</h2></div></div></div><p>The <code class="literal">main()</code>application entry point function is quite simple. It allocates a socket, opens, and synchronously connects it to a remote application. Then, the <code class="literal">writeToSocket()</code> function is called and the socket object is passed to it as an argument. In addition to this, the <code class="literal">main()</code>function contains a <code class="literal">try-catch</code> block intended to catch and handle exceptions that may be thrown by Boost.Asio methods and functions.</p><p>The interesting part in the sample is the <code class="literal">writeToSocket()</code>function that performs synchronous writing to the socket. It accepts a reference to the socket object as an argument. Its precondition is that the socket passed to it is already connected; otherwise, the function fails.</p><p>The function begins with allocating and filling the buffer. In this sample, we use an ASCII string as data that is to be written to the socket, and, therefore, we allocate an object of the <code class="literal">std::string</code> class and assign it a value of <code class="literal">Hello</code>, which we will use as a dummy message that will be written to the socket.</p><p>Then, the variable named <code class="literal">total_bytes_written</code> is defined and its value is set to <code class="literal">0</code>. This variable is used as a counter that stores the count of bytes already written to the socket.</p><p>Next, the loop is run in which the socket's <code class="literal">write_some()</code> method is called. Except for the degenerate case when the buffer is empty (that is, the <code class="literal">buf.length()</code> method returns a value of <code class="literal">0</code>), at least one iteration of the loop is executed and the <code class="literal">write_some()</code> method is called at least once. Let's take a closer look at the loop:</p><div><pre class="programlisting">  while (total_bytes_written != buf.length()) {
    total_bytes_written += sock.write_some(
      asio::buffer(buf.c_str() +
      total_bytes_written,
      buf.length() - total_bytes_written));
  }</pre></div><p>The termination condition evaluates to <code class="literal">true</code> when the value of the <code class="literal">total_bytes_written</code> variable is equal to the size of the buffer, that is, when all the bytes available in the buffer have been written to the socket. In each iteration of the loop, the value of the <code class="literal">total_bytes_written</code> variable is increased by the value returned by the <code class="literal">write_some()</code> method, which is equal to the number of bytes written during this method call.</p><p>Each time the <code class="literal">write_some()</code> method is called, the argument passed to it is adjusted. The start byte of the buffer is shifted by the value of <code class="literal">total_bytes_written</code> as compared to the original buffer (because the previous bytes have already been sent by preceding calls to the <code class="literal">write_some()</code> method) and the size of the buffer is decreased by the same value, correspondingly.</p><p>After the loop terminates, all <a id="id83" class="indexterm"/>the data from the buffer is written to the socket and the <code class="literal">writeToSocket()</code> function returns.</p><p>It's worth noting that the amount of bytes written to the socket during a single call to the <code class="literal">write_some()</code> method depends on several factors. In the general case, it is not known to the developer; and therefore, it should not be accounted for. A demonstrated solution is independent of this value and calls the <code class="literal">write_some()</code> method as many times as needed to write all the data available in the buffer to the socket.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Alternative – the send() method</h3></div></div></div><p>The<code class="literal"> asio::ip::tcp::socket</code> class<a id="id84" class="indexterm"/> contains another method to synchronously write data to the socket named <code class="literal">send()</code>. There are three overloads of this method. One of them is equivalent to the <code class="literal">write_some()</code> method, as described earlier. It has exactly the same signature and provides exactly the same functionality. These methods are synonyms in a sense.</p><p>The second overload accepts one additional argument as compared to the <code class="literal">write_some()</code> method. Let's take a look at it:</p><div><pre class="programlisting">template&lt;
typename ConstBufferSequence&gt;
std::size_t send(
    const ConstBufferSequence &amp; buffers,
    socket_base::message_flags flags);</pre></div><p>This additional argument is named <code class="literal">flags</code>. It can be used to specify a bit mask, representing flags that control the operation. Because these flags are used quite rarely, we won't consider them in this book. Refer to the Boost.Asio documentation to find out more information on this topic.</p><p>The third overload is equivalent to the second one, but it doesn't throw exceptions in case of a failure. Instead, the error information is returned by means of an additional method's output argument of the <code class="literal">boost::system::error_code</code> type.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>There's more...</h2></div></div></div><p>Writing to a socket using the socket's <code class="literal">write_some()</code> method seems very complex for such a simple operation. Even if we want to send a small message that consists of several bytes, we must use a loop, a variable to keep track of how many bytes have already been written, and properly construct a buffer for each iteration of the loop. This approach is error-prone and makes the code more difficult to understand.</p><p>Fortunately, Boost.Asio provides <a id="id85" class="indexterm"/>a free function, which simplifies writing to a socket. This function is called <code class="literal">asio::write()</code>. Let's take a look at one of its overloads:</p><div><pre class="programlisting">template&lt;
    typename SyncWriteStream,
    typename ConstBufferSequence&gt;
std::size_t write(
    SyncWriteStream &amp; s,
    const ConstBufferSequence &amp; buffers);</pre></div><p>This function accepts two arguments. The first of them named <code class="literal">s</code> is a reference to an object that satisfies the requirements of the <code class="literal">SyncWriteStream</code> concept. For a complete list of the requirements, refer to the corresponding Boost.Asio documentation section at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html</a>. The object of the <code class="literal">asio::ip::tcp::socket</code> class that represents a TCP socket satisfies these requirements and, therefore, can be used as the first argument of the function. The second argument named <code class="literal">buffers </code>represents the buffer (simple or composite) and contains data that is to be written to the socket.</p><p>In contrast to the socket object's <code class="literal">write_some()</code> method, which writes <em>some</em> amount of data from the buffer to the socket, the <code class="literal">asio::write()</code> function writes all the data available in the buffer. This simplifies writing to the socket and makes the code shorter and cleaner.</p><p>This is how our <code class="literal">writeToSocket()</code> function from a previous sample would look like if we used the <code class="literal">asio::write()</code> function instead of the socket object's <code class="literal">write_some()</code> method to write data to the socket:</p><div><pre class="programlisting">void writeToSocketEnhanced(asio::ip::tcp::socket&amp; sock) {
  // Allocating and filling the buffer.
  std::string buf = "Hello";

  // Write whole buffer to the socket.
  asio::write(sock, asio::buffer(buf));
}</pre></div><p>The <code class="literal">asio::write()</code> function is implemented in a similar way as the original <code class="literal">writeToSocket()</code> function is implemented by means of several calls to the socket object's <code class="literal">write_some()</code> method in a loop.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Note that the <code class="literal">asio::write()</code> function has seven more overloads on the top of the one we just considered. Some of them may be very useful in specific cases. Refer to the Boost.Asio documentation to find out more about this function at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing a synchronous TCP client</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, demonstrates how to implement a synchronous TCP client that performs synchronous writing to send request messages to the server</li><li class="listitem" style="list-style-type: disc">The <em>Implementing a synchronous iterative TCP server</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, demonstrates how to implement a synchronous TCP server that performs synchronous writing to send response messages to the client</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Reading from a TCP socket synchronously</h1></div></div></div><p>Reading from a <a id="id86" class="indexterm"/>TCP socket is an input operation that is used to receive data sent by the remote application connected to this socket. Synchronous reading is the simplest way to receive the data using a socket provided by Boost.Asio. The methods and functions that perform synchronous reading from the socket blocks the thread of execution and doesn't return until the data (at least some amount of data) is read from the socket or an error occurs.</p><p>In this recipe, we will see how to read data from a TCP socket synchronously.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it…</h2></div></div></div><p>The most basic way to read data from the socket provided by the Boost.Asio library is the <code class="literal">read_some()</code> method of the <code class="literal">asio::ip::tcp::socket</code> class. Let's take a look at one of the method's overloads:</p><div><pre class="programlisting">template&lt;
typename MutableBufferSequence&gt;
std::size_t read_some(
    const MutableBufferSequence &amp; buffers);</pre></div><p>This method accepts an object that represents a writable buffer (single or composite) as an argument, and as its name suggests, reads <em>some</em> amount of data from the socket to the buffer. If the method succeeds, the return value indicates the number of bytes read. It's important to note that there is no way to control how many bytes the method will read. The method only guarantees that at least one byte will be read if an error does not occur. This means that, in a general case, in order to read a certain amount of data from the socket, we may need to call the method several times.</p><p>The following<a id="id87" class="indexterm"/> algorithm describes the steps required to synchronously read data from a TCP socket in a distributed application:</p><div><ol class="orderedlist arabic"><li class="listitem">In a client application, allocate, open, and connect an active TCP socket. In a server application, obtain a connected active TCP socket by accepting a connection request using an acceptor socket.</li><li class="listitem">Allocate the buffer of a sufficient size to fit in the expected message to be read.</li><li class="listitem">In a loop, call the socket's <code class="literal">read_some()</code> method as many times as it is needed to read the message.</li></ol></div><p>The following code sample demonstrates a client application, which operates according to the algorithm:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

std::string readFromSocket(asio::ip::tcp::socket&amp; sock) {
  const unsigned char MESSAGE_SIZE = 7;
  char buf[MESSAGE_SIZE];
  std::size_t total_bytes_read = 0;

  while (total_bytes_read != MESSAGE_SIZE) {
    total_bytes_read += sock.read_some(
      asio::buffer(buf + total_bytes_read,
      MESSAGE_SIZE - total_bytes_read));
  }

  return std::string(buf, total_bytes_read);
}

int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

    asio::ip::tcp::socket sock(ios, ep.protocol());

    sock.connect(ep);

    readFromSocket(sock);
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div><p>Although in<a id="id88" class="indexterm"/> the presented code sample, reading from a socket is performed in the context of an application that acts as a client, the same approach can be used to read data from the socket in a server application.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works…</h2></div></div></div><p>The <code class="literal">main()</code>application entry point function is quite simple. First, it allocates a TCP socket, opens, and synchronously connects it to a remote application. Then, the <code class="literal">readFromSocket()</code> function is called and the socket object is passed to it as an argument. In addition to this, the <code class="literal">main()</code> function contains a <code class="literal">try-catch</code> block intended to catch and handle exceptions that may be thrown by Boost.Asio methods and functions.</p><p>The interesting part in the sample is the <code class="literal">readFromSocket()</code> function that performs synchronous reading from the socket. It accepts a reference to the socket object as an input argument. Its precondition is that the socket passed to it as an argument must be connected; otherwise, the function fails.</p><p>The function begins with allocating a buffer named <code class="literal">buf</code>. The size of the buffer is chosen to be 7 bytes. This is because in our sample, we expect to receive exactly a 7 bytes long message from a remote application.</p><p>Then, a variable named <code class="literal">total_bytes_read</code> is defined and its value is set to <code class="literal">0</code>. This variable is used as a counter that keeps the count of the total number of bytes read from the socket.</p><p>Next, the loop is run in which the socket's <code class="literal">read_some()</code> method is called. Let's take a closer look at the loop:</p><div><pre class="programlisting">  while (total_bytes_read != MESSAGE_SIZE) {
    total_bytes_read += sock.read_some(
      asio::buffer(buf + total_bytes_read,
      MESSAGE_SIZE - total_bytes_read));
  }</pre></div><p>The termination <a id="id89" class="indexterm"/>condition evaluates to <code class="literal">true</code> when the value of the <code class="literal">total_bytes_read</code> variable is equal to the size of the expected message, that is, when the whole message has been read from the socket. In each iteration of the loop, the value of the <code class="literal">total_bytes_read</code> variable is increased by the value returned by the <code class="literal">read_some()</code> method, which is equal to the number of bytes read during this method call.</p><p>Each time the <code class="literal">read_some()</code> method is called, the input buffer passed to it is adjusted. The start byte of the buffer is shifted by the value of <code class="literal">total_bytes_read</code> as compared to the original buffer (because the preceding part of the buffer has already been filled with data read from the socket during preceding calls to the <code class="literal">read_some()</code> method) and the size of the buffer is decreased by the same value, correspondingly.</p><p>After the loop terminates, all the data expected to be read from the socket is now in the buffer.</p><p>The <code class="literal">readFromSocket()</code> function ends with instantiating an object of the <code class="literal">std::string</code> class from the received buffer and returning it to the caller.</p><p>It's worth noting that the amount of bytes read from the socket during a single call to the <code class="literal">read_some()</code> method depends on several factors. In a general case, it is not known to the developer; and, therefore, it should not be accounted for. The proposed solution is independent of this value and calls the <code class="literal">read_some()</code> method as many times as needed to read all the data from the socket.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Alternative – the receive() method</h3></div></div></div><p>The <code class="literal">asio::ip::tcp::socket</code> class contains another method to read data from the socket <a id="id90" class="indexterm"/>synchronously called <code class="literal">receive()</code>. There are three overloads of this method. One of them is equivalent to the <code class="literal">read_some()</code> method, as described earlier. It has exactly the same signature and provides exactly the same functionality. These methods are synonyms in a sense.</p><p>The second overload accepts one additional argument as compared to the <code class="literal">read_some()</code> method. Let's take a look at it:</p><div><pre class="programlisting">template&lt;
    typename MutableBufferSequence&gt;
std::size_t receive(
    const MutableBufferSequence &amp; buffers,
    socket_base::message_flags flags);</pre></div><p>This additional <a id="id91" class="indexterm"/>argument is named <code class="literal">flags</code>. It can be used to specify a bit mask, representing flags that control the operation. Because these flags are rarely used, we won't consider them in this book. Refer to the Boost.Asio documentation to find out more about this topic.</p><p>The third overload is equivalent to the second one, but it doesn't throw exceptions in case of a failure. Instead, the error information is returned by means of an additional output argument of the <code class="literal">boost::system::error_code</code> type.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more...</h2></div></div></div><p>Reading from a socket using the socket's <code class="literal">read_some()</code> method seems very complex for such a simple operation. This approach requires us to use a loop, a variable to keep track of how many bytes have already been read, and properly construct a buffer for each iteration of the loop. This approach is error-prone and makes the code more difficult to understand and maintain.</p><p>Fortunately, Boost.Asio provides a family of free functions that simplify synchronous reading of data from a socket in different contexts. There are three such functions, each having several overloads, that provide a rich functionality that facilitates reading data from a socket.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>The asio::read() function</h3></div></div></div><p>The <code class="literal">asio::read()</code> function <a id="id92" class="indexterm"/>is the simplest one out of the three. Let's take a look at the declaration of one of its overloads:</p><div><pre class="programlisting">template&lt;
    typename SyncReadStream,
    typename MutableBufferSequence&gt;
std::size_t read(
    SyncReadStream &amp; s,
    const MutableBufferSequence &amp; buffers);</pre></div><p>This function accepts two arguments. The first of them named <code class="literal">s</code> is a reference to an object that satisfies the requirements of the <code class="literal">SyncReadStream</code> concept. For a complete list of the requirements, refer to the corresponding Boost.Asio documentation section available at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html</a>. The object of the <code class="literal">asio::ip::tcp::socket</code> class that represents a TCP socket satisfies these requirements and, therefore, can be used as the first argument of the function. The second argument named <code class="literal">buffers </code>represents a buffer (simple or composite) to which the data will be read from the socket.</p><p>In contrast to the <a id="id93" class="indexterm"/>socket's <code class="literal">read_some()</code> method, which reads <em>some</em> amount of data from the socket to the buffer, the <code class="literal">asio::read()</code> function, during a single call, reads data from the socket until the buffer passed to it as an argument is filled or an error occurs. This simplifies reading from the socket and makes the code shorter and cleaner.</p><p>This is how our <code class="literal">readFromSocket()</code> function from the previous sample would look like if we used the <code class="literal">asio::read()</code> function instead of the socket object's <code class="literal">read_some()</code> method to read data from the socket:</p><div><pre class="programlisting">std::string readFromSocketEnhanced(asio::ip::tcp::socket&amp; sock) {
  const unsigned char MESSAGE_SIZE = 7;
  char buf[MESSAGE_SIZE];

  asio::read(sock, asio::buffer(buf, MESSAGE_SIZE));

  return std::string(buf, MESSAGE_SIZE);
}</pre></div><p>In the preceding sample, a call to the <code class="literal">asio::read()</code> function will block the thread of execution until exactly 7 bytes are read or an error occurs. The benefits of this approach over the socket's <code class="literal">read_some()</code> method are obvious.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The <code class="literal">asio::read()</code> function has several overloads, which provide flexibility in specific contexts. Refer to the corresponding section of the Boost.Asio documentation to find out more about this function at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>The asio::read_until() function</h3></div></div></div><p>The <code class="literal">asio::read_until()</code> function <a id="id94" class="indexterm"/>provides a way to read data from a socket until a specified pattern is encountered in the data. There are eight overloads of this function. Let's consider one of them:</p><div><pre class="programlisting">template&lt;
    typename SyncReadStream,
    typename Allocator&gt;
std::size_t read_until(
    SyncReadStream &amp; s,
    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
    char delim);</pre></div><p>This function accepts three arguments. The first of them named <code class="literal">s</code> is a reference to an object that satisfies the requirements of the <code class="literal">SyncReadStream</code> concept. For a complete list of the requirements, refer to the corresponding Boost.Asio documentation section at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html</a>. The object of the <code class="literal">asio::ip::tcp::socket</code> class that represents a TCP socket satisfies these requirements and, therefore, can be used as the first argument of the function.</p><p>The second <a id="id95" class="indexterm"/>argument named <code class="literal">b</code> represents a stream-oriented extensible buffer in which the data will be read. The last argument named <code class="literal">delim </code>specifies a delimiter character.</p><p>The <code class="literal">asio::read_until()</code> function will read data from the <code class="literal">s</code> socket to the buffer <code class="literal">b</code> until it encounters a character specified by the <code class="literal">delim</code> argument in the read portion of the data. When the specified character is encountered, the function returns.</p><p>It's important to note that the <code class="literal">asio::read_until()</code> function is implemented so that it reads the data from the socket by blocks of variable sizes (internally it uses the socket's <code class="literal">read_some()</code> method to read the data). When the function returns, the buffer <code class="literal">b</code> may contain some symbols after the delimiter symbol. This may happen if the remote application sends some more data after the delimiter symbol (for example, it may send two messages in a row, each having a delimiter symbol in the end). In other words, when the <code class="literal">asio::read_until()</code> function returns successfully, it is guaranteed that the buffer <code class="literal">b </code>contains at least one delimiter symbol but may contain more. It is the developer's responsibility to parse the data in the buffer and handle the situation when it contains data after the delimiter symbol.</p><p>This is how we will implement our <code class="literal">readFromSocket()</code> function if we want to read all the data from a socket until a specific symbol is encountered. Let's assume the message delimiter to be a new line ASCII symbol, <code class="literal">\n</code>:</p><div><pre class="programlisting">std::string readFromSocketDelim(asio::ip::tcp::socket&amp; sock) {
  asio::streambuf buf;

  // Synchronously read data from the socket until
  // '\n' symbol is encountered.  
  asio::read_until(sock, buf, '\n');

  std::string message;

  // Because buffer 'buf' may contain some other data
  // after '\n' symbol, we have to parse the buffer and
  // extract only symbols before the delimiter. 
  
  std::istream input_stream(&amp;buf);
  std::getline(input_stream, message);
  return message;
}</pre></div><p>This example is <a id="id96" class="indexterm"/>quite simple and straightforward. Because <code class="literal">buf</code> may contain more symbols after the delimiter symbol, we use the <code class="literal">std::getline()</code> function to extract the messages of interest before the delimiter symbol and put them into the <code class="literal">message</code> string object, which is then returned to the caller.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The <code class="literal">read_until()</code> function has several overloads, which provide more sophisticated ways to specify termination conditions, such as string delimiters, regular expressions, or functors. Refer to the corresponding Boost.Asio documentation section to find out more about this topic at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>The asio::read_at() function</h3></div></div></div><p>The <code class="literal">asio::read_at()</code> function <a id="id97" class="indexterm"/>provides a way to read data from a socket, starting at a particular offset. Because this function is rarely used, it is beyond the scope of this book. Refer to the corresponding Boost.Asio documentation section for more details about this function and its overloads at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html</a>.</p><p>The <code class="literal">asio::read()</code>, <code class="literal">asio::read_until()</code>, and <code class="literal">asio::read_at()</code> functions are implemented in a similar way to how the original <code class="literal">readFromSocket()</code> function in our sample is implemented by means of several calls to the socket object's <code class="literal">read_some()</code> method in a loop until the termination condition is satisfied or an error occurs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using extensible stream-oriented I/O buffers</em> recipe demonstrates how to write and read data to and from the <code class="literal">asio::streambuf</code> buffer</li><li class="listitem" style="list-style-type: disc">The <em>Implementing a synchronous TCP client</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, demonstrates how to implement a synchronous TCP client that performs synchronous reading from a socket to receive response messages sent by the server</li><li class="listitem" style="list-style-type: disc">The <em>Implementing a synchronous iterative TCP server</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, demonstrates how to implement a synchronous TCP server that performs synchronous reading to receive request messages from the client</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Writing to a TCP socket asynchronously</h1></div></div></div><p>Asynchronous writing<a id="id98" class="indexterm"/> is a flexible and efficient way to send data to a remote application. In this recipe, we will see how to write data to a TCP socket asynchronously.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How to do it…</h2></div></div></div><p>The most basic tool used to asynchronously write data to the socket provided by the Boost.Asio library is the <code class="literal">async_write_some()</code> method of the <code class="literal">asio::ip::tcp::socket</code> class. Let's take a look at one of the method's overloads:</p><div><pre class="programlisting">template&lt;
    typename ConstBufferSequence,
    typename WriteHandler&gt;
void async_write_some(
    const ConstBufferSequence &amp; buffers,
    WriteHandler handler);</pre></div><p>This method initiates the write operation and returns immediately. It accepts an object that represents a buffer that contains the data to be written to the socket as its first argument. The second argument is a callback, which will be called by Boost.Asio when an initiated operation is completed. This argument can be a function pointer, functor, or any other object that satisfies the requirements of the <code class="literal">WriteHandler</code> concept. The complete list of the requirements can be found in the corresponding section of the Boost.Asio documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html</a>.</p><p>The callback should have the following signature:</p><div><pre class="programlisting">void write_handler(
    const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred);</pre></div><p>Here, <code class="literal">ec</code> is an argument that indicates an error code if one occurs, and the <code class="literal">bytes_transferred</code> argument indicates how many bytes have been written to the socket during the corresponding asynchronous operation.</p><p>As the <code class="literal">async_write_some()</code> method's name suggests, it initiates an operation that is intended to write <em>some</em> amount of data from the buffer to the socket. This method guarantees that at least one byte will be written during the corresponding asynchronous operation if an error does not occur. This means that, in a general case, in order to write all the data available in the buffer to the socket, we may need to perform this asynchronous operation several times.</p><p>Now that we know how the key method works, let's see how to implement an application that performs asynchronous writing to the socket.</p><p>The following<a id="id99" class="indexterm"/> algorithm describes the steps required to perform and implement an application, which writes data to a TCP socket asynchronously. Note that this algorithm provides a <em>possible</em> way to implement such an application. Boost.Asio is quite flexible and allows us to organize and structure the application by writing data to a socket asynchronously in many different ways:</p><div><ol class="orderedlist arabic"><li class="listitem">Define a data structure that contains a pointer to a socket object, a buffer, and a variable used as a counter of bytes written.</li><li class="listitem">Define a callback function that will be called when the asynchronous writing operation is completed.</li><li class="listitem">In a client application, allocate and open an active TCP socket and connect it to a remote application. In a server application, obtain a connected active TCP socket by accepting a connection request.</li><li class="listitem">Allocate a buffer and fill it with data that is to be written to the socket.</li><li class="listitem">Initiate an asynchronous writing operation by calling the socket's <code class="literal">async_write_some()</code> method. Specify a function defined in step 2 as a callback.</li><li class="listitem">Call the <code class="literal">run()</code> method on an object of the <code class="literal">asio::io_service</code> class.</li><li class="listitem">In a callback, increase the counter of bytes written. If the number of bytes written is less than the total amount of bytes to be written, initiate a new asynchronous writing operation to write the next portion of the data.</li></ol></div><p>Let's implement a sample client application that performs asynchronous writing in accordance with the preceding algorithm.</p><p>We begin with adding the <code class="literal">include</code> and <code class="literal">using</code> directives:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, according to step 1 of the algorithm, we define a data structure that contains a pointer to the socket object, a buffer that contains data to be written, and a counter variable that contains the number of bytes already written:</p><div><pre class="programlisting">// Keeps objects we need in a callback to
// identify whether all data has been written
// to the socket and to initiate next async
// writing operation if needed.
struct Session {
  std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;
  std::string buf;
  std::size_t total_bytes_written;
};</pre></div><p>In step 2, we <a id="id100" class="indexterm"/>define a callback function, which will be called when the asynchronous operation is completed:</p><div><pre class="programlisting">// Function used as a callback for 
// asynchronous writing operation.
// Checks if all data from the buffer has
// been written to the socket and initiates
// new asynchronous writing operation if needed.
void callback(const boost::system::error_code&amp; ec,
        std::size_t bytes_transferred,
        std::shared_ptr&lt;Session&gt; s) 
{
  if (ec != 0) {
    std::cout &lt;&lt; "Error occured! Error code = " 
    &lt;&lt; ec.value()
    &lt;&lt; ". Message: " &lt;&lt; ec.message();

    return;
  }

  s-&gt;total_bytes_written += bytes_transferred;

  if (s-&gt;total_bytes_written == s-&gt;buf.length()) {
    return;
  }

  s-&gt;sock-&gt;async_write_some(
  asio::buffer(
  s-&gt;buf.c_str() + 
  s-&gt;total_bytes_written, 
  s-&gt;buf.length() - 
  s-&gt;total_bytes_written),
  std::bind(callback, std::placeholders::_1,
  std::placeholders::_2, s));
}</pre></div><p>Let's skip <a id="id101" class="indexterm"/>step 3 for now and implement steps 4 and 5 in a separate function. Let's call this function <code class="literal">writeToSocket()</code>:</p><div><pre class="programlisting">void writeToSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock) {

  std::shared_ptr&lt;Session&gt; s(new Session);

  // Step 4. Allocating and filling the buffer.
  s-&gt;buf = std::string("Hello");
  s-&gt;total_bytes_written = 0;
  s-&gt;sock = sock;

  // Step 5. Initiating asynchronous write operation.
  s-&gt;sock-&gt;async_write_some(
  asio::buffer(s-&gt;buf),
  std::bind(callback, 
  std::placeholders::_1,
  std::placeholders::_2, 
  s));
}</pre></div><p>Now, we come back to step 3 and implement it in the <code class="literal">main()</code>application entry point function:</p><div><pre class="programlisting">int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

    // Step 3. Allocating, opening and connecting a socket.
    std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock(
    new asio::ip::tcp::socket(ios, ep.protocol()));

    sock-&gt;connect(ep);

    writeToSocket(sock);

    // Step 6.
    ios.run();
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How it works…</h2></div></div></div><p>Now, let's track<a id="id102" class="indexterm"/> the application's execution path to better understand how it works.</p><p>The application is run by a single thread, in the context of which the application's <code class="literal">main()</code> entry point function is called. Note that Boost.Asio may create additional threads for some internal operations, but it guarantees that no application code is executed in the context of those threads.</p><p>The <code class="literal">main()</code> function allocates, opens, and synchronously connects a socket to a remote application and then calls the <code class="literal">writeToSocket()</code> function by passing a pointer to the socket object. This function initiates an asynchronous write operation and returns. We'll consider this function in a moment. The <code class="literal">main()</code> function continues with calling the <code class="literal">run()</code> method on the object of the <code class="literal">asio::io_service</code> class, where Boost.Asio <em>captures</em> the thread of execution and uses it to call the callback functions associated with asynchronous operations when they get completed.</p><p>The <code class="literal">asio::os_service::run()</code> method blocks, as long as, at least one pending asynchronous operation. When the last callback of the last pending asynchronous operation is completed, this method returns.</p><p>Now, let's come back to the <code class="literal">writeToSocket()</code> function and analyze its behavior. It begins with allocating an instance of the <code class="literal">Session</code> data structure in the free memory. Then, it allocates and fills the buffer with the data to be written to the socket. After this, a pointer to the socket object and the buffer are stored in the <code class="literal">Session</code> object. Because the socket's <code class="literal">async_write_some()</code> method may not write all the data to the socket in one go, we may need to initiate another asynchronous write operation in a callback function. That's why we need the <code class="literal">Session</code> object and we allocate it in the free memory and not on the stack; it must <em>live</em> until the callback function is called.</p><p>Finally, we initiate the asynchronous operation, calling the socket object's <code class="literal">async_write_some()</code> method. The invocation of this method is somewhat complex, and, therefore, let's consider this in more detail:</p><div><pre class="programlisting">s-&gt;sock-&gt;async_write_some(
  asio::buffer(s-&gt;buf),
  std::bind(callback,
     std::placeholders::_1,
std::placeholders::_2, 
s));</pre></div><p>The first <a id="id103" class="indexterm"/>argument is a buffer that contains data to be written to the socket. Because the operation is asynchronous, this buffer may be accessed by Boost.Asio at any moment between operation initiation and when the callback is called. This means that the buffer must stay intact and must be available until the callback is called. We guarantee this by storing the buffer in a <code class="literal">Session</code> object, which in turn is stored in the free memory.</p><p>The second argument is a callback that is to be invoked when the asynchronous operation is completed. Boost.Asio defines a callback as a <em>concept</em>, which can be a function or a functor, that accepts two arguments. The first argument of the callback specifies an error that occurs while the operation is being executed, if any. The second argument specifies the number of bytes written by the operation.</p><p>Because we want to pass an additional argument to our callback function, a pointer to the corresponding <code class="literal">Session</code> object, which acts as a context for the operation, we use the <code class="literal">std::bind()</code> function to construct a function object to which we attach a pointer to the <code class="literal">Session</code> object as the third argument. The function object is then passed as a callback argument to the socket object's <code class="literal">async_write_some()</code> method.</p><p>Because it is asynchronous, the <code class="literal">async_write_some()</code> method doesn't block the thread of execution. It initiates the writing operation and returns.</p><p>The actual writing operation is executed behind the scenes by the Boost.Asio library and underlying operating system, and when the operation is complete or an error occurs, the callback is invoked.</p><p>When invoked, the callback function named, literally, <code class="literal">callback</code> in our sample application begins with checking whether the operation succeeded or an error occurred. In the latter case, the error information is output to the standard output stream and the function returns. Otherwise, the counter of the total written bytes is increased by the number of bytes written as a result of an operation. Then, we check whether the total number of bytes written to the socket is equal to the size of the buffer. If these values are equal, this means that all the data has been written to the socket and there is no more work to do. The callback function returns. However, if there is still data in the buffer that is to be written, a new asynchronous write operation is initiated:</p><div><pre class="programlisting">s-&gt;sock-&gt;async_write_some(
asio::buffer(
s-&gt;buf.c_str() + 
s-&gt;total_bytes_written, 
s-&gt;buf.length() – 
s-&gt;total_bytes_written),
std::bind(callback, std::placeholders::_1,
std::placeholders::_2, s));</pre></div><p>Note how the <a id="id104" class="indexterm"/>beginning of the buffer is shifted by the number of bytes already written, and how the size of the buffer is decreased by the same value, correspondingly.</p><p>As a callback, we specify the same <code class="literal">callback()</code> function using the <code class="literal">std::bind()</code> function to attach an additional argument—the <code class="literal">Session</code> object, just like we did when we initiated the first asynchronous operation.</p><p>The cycles of initiation of an asynchronous writing operation and consequent callback invocation repeat until all the data from the buffer is written to the socket or an error occurs.</p><p>When the <code class="literal">callback</code> function returns without initiating a new asynchronous operation, the <code class="literal">asio::io_service::run()</code> method, called in the <code class="literal">main()</code> function, unblocks the thread of execution and returns. The <code class="literal">main()</code> function returns as well. This is when the application exits.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec58"/>There's more...</h2></div></div></div><p>Although the <code class="literal">async_write_some()</code> method described in the previous sample allows asynchronously writing data to the socket, the solution based on it is somewhat complex and error-prone. Fortunately, Boost.Asio provides a more convenient way to asynchronously write data to a socket using the free function <code class="literal">asio::async_write()</code>. Let's consider one of its overloads:</p><div><pre class="programlisting">template&lt;
    typename AsyncWriteStream,
    typename ConstBufferSequence,
    typename WriteHandler&gt;
void async_write(
    AsyncWriteStream &amp; s,
    const ConstBufferSequence &amp; buffers,
    WriteHandler handler);</pre></div><p>This function is very similar to the socket's <code class="literal">async_write_some()</code> method. Its first argument is an object that satisfies the requirements of the <code class="literal">AsyncWriteStream</code> concept. For the complete<a id="id105" class="indexterm"/> list of the requirements, refer to the corresponding Boost.Asio documentation section at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html</a>. The object of the <code class="literal">asio::ip::tcp::socket</code> class satisfies these requirements and, therefore, can be used with this function.</p><p>The second and the third arguments of the <code class="literal">asio::async_write()</code> function are similar to the first and second arguments of the <code class="literal">async_write_some()</code> method of a TCP socket object described in the previous sample. These arguments are buffers that contain data that is to be written and functions or objects that represent a callback, which will be called when the operation is completed.</p><p>In contrast to the socket's <code class="literal">async_write_some()</code> method, which initiates the operation that writes <em>some</em> amount of data from the buffer to the socket, the <code class="literal">asio::async_write()</code> function initiates the operation, which writes all the data available in the buffer. In this case, the callback is called only when all the data available in the buffer is written to the socket or when an error occurs. This simplifies writing to the socket and makes the code shorter and cleaner.</p><p>If we change our previous sample so that it uses the <code class="literal">asio::async_write()</code> function instead of the socket object's <code class="literal">async_write_some()</code> method to write data to the socket asynchronously, our application becomes significantly simpler.</p><p>Firstly, we don't need to keep track of the number of bytes written to the socket, so therefore, the <code class="literal">Session</code> structure becomes smaller:</p><div><pre class="programlisting">struct Session {
  std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;
  std::string buf;
}; </pre></div><p>Secondly, we know that when the callback function is invoked, it means that either all the data from the buffer has been written to the socket or an error has occurred. This makes the callback function much simpler:</p><div><pre class="programlisting">void callback(const boost::system::error_code&amp; ec,
  std::size_t bytes_transferred,
  std::shared_ptr&lt;Session&gt; s)
{
  if (ec != 0) {
    std::cout &lt;&lt; "Error occured! Error code = "
      &lt;&lt; ec.value()
      &lt;&lt; ". Message: " &lt;&lt; ec.message();

    return;
  }

  // Here we know that all the data has
  // been written to the socket.
}</pre></div><p>The <code class="literal">asio::async_write()</code> function is <a id="id106" class="indexterm"/>implemented by means of zero or more calls to the socket object's <code class="literal">async_write_some()</code> method. This is similar to how the <code class="literal">writeToSocket()</code> function in our initial sample is implemented.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Note that the <code class="literal">asio::async_write()</code> function has three more overloads, providing additional functionalities. Some of them may be very useful in specific circumstances. Refer to the Boost.Asio documentation to find out more about this function at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec59"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Writing to a TCP socket synchronously</em> recipe describes how to write data to a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP client</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, demonstrates how to implement an asynchronous TCP client that performs asynchronous writing to a TCP socket to send request messages to the server</li><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP server</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, demonstrates how to implement an asynchronous TCP server that performs asynchronous writing to a TCP socket to send response messages to the client</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Reading from a TCP socket asynchronously</h1></div></div></div><p>Asynchronous reading<a id="id107" class="indexterm"/> is a flexible and efficient way to receive data from a remote application. In this recipe, we will see how to read data from a TCP socket asynchronously.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How to do it…</h2></div></div></div><p>The most basic tool used to asynchronously read data from a TCP socket provided by the Boost.Asio library is the <code class="literal">async_read_some()</code> method of the <code class="literal">asio::ip::tcp::socket</code> class. Here is one of the method's overloads:</p><div><pre class="programlisting">template&lt;
    typename MutableBufferSequence,
    typename ReadHandler&gt;
void async_read_some(
    const MutableBufferSequence &amp; buffers,
    ReadHandler handler);</pre></div><p>This <a id="id108" class="indexterm"/>method initiates an asynchronous read operation and returns immediately. It accepts an object that represents a mutable buffer as its first argument to which the data will be read from the socket. The second argument is a callback that is called by Boost.Asio when the operation is completed. This argument can be a function pointer, a functor, or any other object that satisfies the requirements of the <code class="literal">ReadHandler</code> concept. The complete list of the requirements can be found in the corresponding section of the Boost.Asio documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html</a>.</p><p>The callback should have the following signature:</p><div><pre class="programlisting">void read_handler(
    const boost::system::error_code&amp; ec,
    std::size_t bytes_transferred);</pre></div><p>Here, <code class="literal">ec</code> is an argument that notifies an error code if one occurs, and the <code class="literal">bytes_transferred</code> argument indicates how many bytes have been read from the socket during the corresponding asynchronous operation.</p><p>As the <code class="literal">async_read_some()</code> method's name suggests, it initiates an operation that is intended to read <em>some</em> amount of data from the socket to the buffer. This method guarantees that at least one byte will be read during the corresponding asynchronous operation if an error does not occur. This means that, in a general case, in order to read all the data from the socket, we may need to perform this asynchronous operation several times.</p><p>Now that we know how the key method works, let's see how to implement an application that performs asynchronous reading from the socket.</p><p>The following algorithm describes the steps required to implement an application, which reads data from a socket asynchronously. Note that this algorithm provides a <em>possible</em> way to implement such an application. Boost.Asio is quite flexible and allows us to organize and structure the application by reading data from a socket asynchronously in different ways:</p><div><ol class="orderedlist arabic"><li class="listitem">Define a data structure that contains a pointer to a socket object, a buffer, a variable that defines the size of the buffer, and a variable used as a counter of bytes read.</li><li class="listitem">Define a callback function that will be called when an asynchronous reading operation is completed.</li><li class="listitem">In a client application, allocate and open an active TCP socket, and then, connect it to a remote application. In a server application, obtain a connected active TCP socket by accepting a connection request.</li><li class="listitem">Allocate a buffer big enough for the expected message to fit in.</li><li class="listitem">Initiate an asynchronous reading operation by calling the socket's <code class="literal">async_read_some()</code> method, specifying a function defined in step 2 as a callback.</li><li class="listitem">Call the <code class="literal">run()</code> method on an object of the <code class="literal">asio::io_service</code> class.</li><li class="listitem">In a callback, increase the counter of bytes read. If the number of bytes read is less than the total amount of bytes to be read (that is, the size of an expected message), initiate a new asynchronous reading operation to read the next portion of data.</li></ol></div><p>Let's implement <a id="id109" class="indexterm"/>a sample client application which will perform asynchronous reading in accordance with the preceding algorithm.</p><p>We begin with adding the <code class="literal">include</code> and <code class="literal">using</code> directives:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, according to step 1, we define a data structure that contains a pointer to the socket object named <code class="literal">sock</code>, a pointer to the buffer named <code class="literal">buf</code>, a variable named <code class="literal">buf_size</code> that contains the size of the buffer, and a <code class="literal">total_bytes_read</code> variable that contains the number of bytes already read:</p><div><pre class="programlisting">// Keeps objects we need in a callback to
// identify whether all data has been read
// from the socket and to initiate next async
// reading operation if needed.
struct Session {
  std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;
  std::unique_ptr&lt;char[]&gt; buf;
  std::size_t total_bytes_read;
  unsigned int buf_size;
};</pre></div><p>In step 2, we<a id="id110" class="indexterm"/> define a callback function, which will be called when asynchronous operation is completed:</p><div><pre class="programlisting">// Function used as a callback for 
// asynchronous reading operation.
// Checks if all data has been read
// from the socket and initiates
// new reading operation if needed.
void callback(const boost::system::error_code&amp; ec,
  std::size_t bytes_transferred,
  std::shared_ptr&lt;Session&gt; s)
{
  if (ec != 0) {
    std::cout &lt;&lt; "Error occured! Error code = "
      &lt;&lt; ec.value()
      &lt;&lt; ". Message: " &lt;&lt; ec.message();

    return;
  }

  s-&gt;total_bytes_read += bytes_transferred;

  if (s-&gt;total_bytes_read == s-&gt;buf_size) {
    return;
  }

  s-&gt;sock-&gt;async_read_some(
    asio::buffer(
    s-&gt;buf.get() +
      s-&gt;total_bytes_read,
    s-&gt;buf_size -
      s-&gt;total_bytes_read),
    std::bind(callback, std::placeholders::_1,
    std::placeholders::_2, s));
} </pre></div><p>Let's skip step 3 for now and implement steps 4 and 5 in a separate function. Let's name this function <code class="literal">readFromSocket()</code>:</p><div><pre class="programlisting">void readFromSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock) {  
  std::shared_ptr&lt;Session&gt; s(new Session);

  // Step 4. Allocating the buffer.
  const unsigned int MESSAGE_SIZE = 7;

  s-&gt;buf.reset(new char[MESSAGE_SIZE]);
  s-&gt;total_bytes_read = 0;
  s-&gt;sock = sock;
  s-&gt;buf_size = MESSAGE_SIZE;

  // Step 5. Initiating asynchronous reading operation.
  s-&gt;sock-&gt;async_read_some(
    asio::buffer(s-&gt;buf.get(), s-&gt;buf_size),
    std::bind(callback,
      std::placeholders::_1,
      std::placeholders::_2,
      s));
}</pre></div><p>Now, we come <a id="id111" class="indexterm"/>back to step 3 and implement it in the application's <code class="literal">main()</code> entry point function:</p><div><pre class="programlisting">int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

    // Step 3. Allocating, opening and connecting a socket.
    std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock(
      new asio::ip::tcp::socket(ios, ep.protocol()));

    sock-&gt;connect(ep);

    readFromSocket(sock);

    // Step 6.
    ios.run();
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
} </pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec61"/>How it works…</h2></div></div></div><p>Now, let's track <a id="id112" class="indexterm"/>the application's execution path to better understand how it works.</p><p>The application is run by a single thread; in the context of which the application's <code class="literal">main()</code> entry point function is called. Note that Boost.Asio may create additional threads for some internal operations, but it guarantees that no application code is called in the context of those threads.</p><p>The <code class="literal">main()</code> function begins with allocating, opening, and connecting a socket to a remote application. Then, it calls the <code class="literal">readFromSocket()</code> function and passes a pointer to the socket object as an argument. The <code class="literal">readFromSocket()</code> function initiates an asynchronous reading operation and returns. We'll consider this function in a moment. The <code class="literal">main()</code> function continues with calling the <code class="literal">run()</code> method on the object of the <code class="literal">asio::io_service</code> class, where Boost.Asio <em>captures</em> the thread of execution and uses it to call the callback functions associated with asynchronous operations when they get completed.</p><p>The <code class="literal">asio::io_service::run()</code> method blocks as long as there is at least one pending asynchronous operation. When the last callback of the last pending operation is completed, this method returns.</p><p>Now, let's come back to the <code class="literal">readFromSocket()</code> function and analyze its behavior. It begins with allocating an instance of the <code class="literal">Session</code> data structure in the free memory. Then, it allocates a buffer and stores a pointer to it in a previously allocated instance of the <code class="literal">Session</code> data structure. A pointer to the socket object and the size of the buffer are stored in the <code class="literal">Session</code> data structure as well. Because the socket's <code class="literal">async_read_some()</code> method may not read all the data in one go, we may need to initiate another asynchronous reading operation in the callback function. This is why we need the <code class="literal">Session</code> data structure and why we allocate it in the free memory and not on a stack. This structure and all the objects that reside in it must <em>live</em> at least until the callback is invoked.</p><p>Finally, we initiate the asynchronous operation, calling the socket object's <code class="literal">async_read_some()</code> method. The invocation of this method is somewhat complex; therefore, let's take a look at it in more detail:</p><div><pre class="programlisting">s-&gt;sock-&gt;async_read_some(
  asio::buffer(s-&gt;buf.get(), s-&gt;buf_size),
  std::bind(callback,
    std::placeholders::_1,
    std::placeholders::_2,
    s));</pre></div><p>The first argument<a id="id113" class="indexterm"/> is the buffer to which the data will be read. Because the operation is asynchronous, this buffer may be accessed by Boost.Asio at any moment between the operation initiation and when the callback is invoked. This means that the buffer must stay intact and be available until the callback is invoked. We guarantee this by allocating the buffer in the free memory and storing it in the <code class="literal">Session</code> data structure, which in turn is allocated in the free memory as well.</p><p>The second argument is a callback that is to be invoked when the asynchronous operation is completed. Boost.Asio defines a callback as a concept, which can be a function or a functor, that accepts two arguments. The first argument of the callback specifies an error that occurs while the operation is being executed, if any. The second argument specifies the number of bytes read by the operation.</p><p>Because we want to pass an additional argument to our callback function, a pointer to the corresponding <code class="literal">Session</code> object, which serves as a context for the operation—we use the <code class="literal">std::bind()</code> function to construct a function object to which we attach a pointer to the <code class="literal">Session</code> object as the third argument. The function object is then passed as a callback argument to the socket object's <code class="literal">async_write_some()</code> method.</p><p>Because it is asynchronous, the <code class="literal">async_write_some()</code> method doesn't block the thread of execution. It initiates the reading operation and returns.</p><p>The actual reading operation is executed behind the scenes by the Boost.Asio library and underlying operating system, and when the operation is completed or an error occurs, the callback is invoked.</p><p>When invoked, the callback function named, literally, <code class="literal">callback</code> in our sample application begins with checking whether the operation succeeded or an error occurred. In the latter case, the error information is output to the standard output stream and the function returns. Otherwise, the counter of the total read bytes is increased by the number of bytes read as a result of the operation. Then, we check whether the total number of bytes read from the socket is equal to the size of the buffer. If these values are equal, it means that the buffer is full and there is no more work to do. The callback function returns. However, if there is still some space in the buffer, we need to continue with reading; therefore, we initiate a new asynchronous reading operation:</p><div><pre class="programlisting">s-&gt;sock-&gt;async_read_some(
    asio::buffer(s-&gt;buf.get(), s-&gt;buf_size),
    std::bind(callback,
      std::placeholders::_1,
      std::placeholders::_2,
      s));</pre></div><p>Note that the beginning of the buffer is shifted by the number of bytes already read and the size of the buffer is decreased by the same value, respectively.</p><p>As a callback, we specify the same <code class="literal">callback</code> function using the <code class="literal">std::bind()</code> function to attach an additional argument—the <code class="literal">Session</code> object.</p><p>The cycles <a id="id114" class="indexterm"/>of initiation of an asynchronous reading operation and consequent callback invocation repeat until the buffer is full or an error occurs.</p><p>When the <code class="literal">callback</code> function returns without initiating a new asynchronous operation, the <code class="literal">asio::io_service::run()</code> method, called in the <code class="literal">main()</code> function, unblocks the thread of execution and returns. The <code class="literal">main()</code> function returns as well. This is when the application exits.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec62"/>There's more...</h2></div></div></div><p>Although the <code class="literal">async_read_some()</code> method, as described in the previous sample, allows asynchronously reading data from the socket, the solution based on it is somewhat complex and error-prone. Fortunately, Boost.Asio provides a more convenient way to asynchronously read data from a socket: the free function <code class="literal">asio::async_read()</code>. Let's consider one of its overloads:</p><div><pre class="programlisting">template&lt;
    typename AsyncReadStream,
    typename MutableBufferSequence,
    typename ReadHandler&gt;
void async_read(
    AsyncReadStream &amp; s,
    const MutableBufferSequence &amp; buffers,
    ReadHandler handler);</pre></div><p>This function is very similar to the socket's <code class="literal">async_read_some()</code> method. Its first argument is an object that satisfies the requirements of the <code class="literal">AsyncReadStream</code> concept. For the complete list of the requirements, refer to the corresponding Boost.Asio documentation section at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html</a>. The object of the <code class="literal">asio::ip::tcp::socket</code> class satisfies these requirements and, therefore, can be used with this function.</p><p>The second and third arguments of the <code class="literal">asio::async_read()</code> function are similar to the first and second arguments of the <code class="literal">async_read_some()</code> method of a TCP socket object described in the previous sample. These arguments are buffers used as data destination points and functions or objects that represent a callback, which will be called when the operation is completed.</p><p>In contrast to the socket's <code class="literal">async_read_some()</code> method, which initiates the operation, that reads <em>some</em> amount of data from the socket to the buffer, the <code class="literal">asio::async_read()</code> function initiates the operation that reads the data from the socket until the buffer passed to it as an argument is full. In this case, the callback is called when the amount of data read is equal to the size of the provided buffer or when an error occurs. This simplifies reading from the socket and makes the code shorter and cleaner.</p><p>If we change<a id="id115" class="indexterm"/> our previous sample so that it uses the <code class="literal">asio::async_read()</code> function instead of the socket object's <code class="literal">async_read_some()</code> method to read data from the socket asynchronously, our application becomes significantly simpler.</p><p>Firstly, we don't need to keep track of the number of bytes read from the socket; therefore, the <code class="literal">Session</code> structure becomes smaller:</p><div><pre class="programlisting">struct Session {
  std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;
  std::unique_ptr&lt;char[]&gt; buf;
  unsigned int buf_size;
}; </pre></div><p>Secondly, we know that when the callback function is invoked, it means that either an expected amount of data has been read from the socket or an error has occurred. This makes the callback function much simpler:</p><div><pre class="programlisting">void callback(const boost::system::error_code&amp; ec,
  std::size_t bytes_transferred,
  std::shared_ptr&lt;Session&gt; s)
{
  if (ec != 0) {
    std::cout &lt;&lt; "Error occured! Error code = "
      &lt;&lt; ec.value()
      &lt;&lt; ". Message: " &lt;&lt; ec.message();

    return;
  }

  // Here we know that the reading has completed
  // successfully and the buffer is full with
  // data read from the socket.
}</pre></div><p>The <code class="literal">asio::async_read()</code> function is implemented by means of zero or more calls to the socket object's <code class="literal">async_read_some()</code> method. This is similar to how the <code class="literal">readFromSocket()</code> function<a id="id116" class="indexterm"/> in our initial sample is implemented.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Note that the <code class="literal">asio::async_read()</code> function has three more overloads, providing additional functionalities. Some of them may be very useful in specific circumstances. Refer to the Boost.Asio documentation to find out about this at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec63"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Reading from a TCP socket synchronously</em> recipe describes how to read data from a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP client</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, demonstrates how to implement an asynchronous TCP client that performs asynchronous reading from a TCP socket to receive response messages sent by the server</li><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP server</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Implementing Server Applications">Chapter 4</a>, <em>Implementing Server Applications</em>, demonstrates how to implement an asynchronous TCP server that performs asynchronous reading from a TCP socket to receive request messages from the client</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Canceling asynchronous operations</h1></div></div></div><p>Sometimes, after<a id="id117" class="indexterm"/> an asynchronous operation has been initiated and has not yet completed, the conditions in the application may change so that the initiated operation becomes irrelevant or outdated and nobody is interested in the completion of the operation.</p><p>In addition to this, if an initiated asynchronous operation is a reaction to a user command, the user may change their mind while the operation is being executed. The user may want to discard the previous issued command and may want to issue a different one or decide to exit from the application.</p><p>Consider a situation where a user types a website address in a typical web browser's address bar and hits the <em>Enter</em> key. The browser immediately initiates a DNS name resolution operation. When the DNS name is resolved and the corresponding IP address is obtained, it initiates the connection operation to connect to the corresponding web server. When a connection is established, the browser initiates an asynchronous write operation to send a request to the server. Finally, when the request is sent, the browser starts waiting for the response message. Depending on the responsiveness of the server application, the volume of the data transmitted over the network, the state of the network, and other factors, all these operations may take a substantial amount of time. And the user while waiting for the requested web page to be loaded, may change their mind, and before the page gets loaded, the user may type another website address in the address bar and hit <em>Enter</em>.</p><p>Another (extreme) situation<a id="id118" class="indexterm"/> is where a client application sends a request to the server application and starts waiting for the response message, but the server application while processing the client's request, gets into a deadlock due to bugs in it. In this case, the user would have to wait forever for the response message and would never get it.</p><p>In both the cases, the user of the client application would benefit from having the ability to cancel the operation they initiated before it completes. In general, it is a good practice to provide the user with the ability to cancel an operation that may take a noticeable amount of time. Because the network communication operations fall into a class of operations that may last for unpredictably long periods of time, it is important to support the cancelation of operations in distributed applications that communicate over the network.</p><p>One of the benefits of asynchronous operations provided by the Boost.Asio library is that they can be canceled at any moment after the initiation. In this recipe, we'll see how to cancel asynchronous operations.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How to do it…</h2></div></div></div><p>The following algorithm provides the steps required to initiate and cancel asynchronous operations with Boost.Asio:</p><div><ol class="orderedlist arabic"><li class="listitem">If the application is intended to run on Windows XP or Windows Server 2003, define flags that enable asynchronous operation canceling on these versions of Windows.</li><li class="listitem">Allocate and open a TCP or UDP socket. It may be an active or passive (acceptor) socket in the client or server application.</li><li class="listitem">Define a callback function or functor for an asynchronous operation. If needed, in this callback, implement a branch of code that handles the situation when the operation has been canceled.</li><li class="listitem">Initiate one or more asynchronous operations and specify a function or an object defined in step 4 as a callback.</li><li class="listitem">Spawn an additional thread and use it to run the Boost.Asio event loop.</li><li class="listitem">Call the <code class="literal">cancel()</code> method on the socket object to cancel all the outstanding asynchronous operations associated with this socket.</li></ol></div><p>Let's consider <a id="id119" class="indexterm"/>the implementation of the client application designed in accordance with the presented algorithm in which an asynchronous <em>connection</em> operation is first initiated and then canceled.</p><p>According to step 1, to compile and run our code on Windows XP or Windows Server 2003, we need to define some flags that control the behavior of the Boost.Asio library with regard to which mechanisms of the underlying OS to exploit.</p><p>By default, when it is compiled for Windows, Boost.Asio uses the I/O completion port framework to run operations asynchronously. On Windows XP and Windows Server 2003, this framework has some issues and limitations with regard to the cancelation of an operation. Therefore, Boost.Asio requires developers to explicitly notify that they want to enable the asynchronous operation canceling functionality despite of the known issues, when targeting the application in versions of Windows in question. To do this, the <code class="literal">BOOST_ASIO_ENABLE_CANCELIO</code> macro must be defined before Boost.Asio headers are included. Otherwise, if this macro is not defined, while the source code of the application contains calls to asynchronous operations, cancelation methods and functions, the compilation will always fail.</p><p>In other words, it is mandatory to define the <code class="literal">BOOST_ASIO_ENABLE_CANCELIO</code> macro, when targeting Windows XP or Windows Server 2003, and the application needs to cancel asynchronous operations.</p><p>To get rid of issues and limitations imposed by the usage of the I/O completion port framework on Windows XP and Windows Server 2003, we can prevent Boost.Asio from using this framework by defining another macro named <code class="literal">BOOST_ASIO_DISABLE_IOCP</code> before including Boost.Asio headers. With this macro defined, Boost.Asio doesn't use the I/O completion port framework on Windows; and therefore, problems related to asynchronous operations canceling disappear. However, the benefits of scalability and efficiency of the I/O completion ports framework disappear too.</p><p>Note that the mentioned issues and limitations related to asynchronous operation canceling do not exist on Windows Vista and Windows Server 2008 and later. Therefore, when targeting these versions of Windows, canceling works fine, and there is no need to disable the I/O completion port framework usage unless there is another reason to do so. Refer to the <code class="literal">asio::ip::tcp::cancel()</code> method's documentation section for more details on this issue at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html</a>.</p><p>In our sample, we will consider how to construct a cross-platform application that, when targeted at Windows during compilation, can be run on any Windows version, starting from Windows XP or Windows Server 2003. Therefore, we define both the <code class="literal">BOOST_ASIO_DISABLE_IOCP</code> and <code class="literal">BOOST_ASIO_ENABLE_CANCELIO</code> macros.</p><p>To determine<a id="id120" class="indexterm"/> the target operating system at compile time, we use the <code class="literal">Boost.Predef</code> library. This library provides us with macro definitions that allow us to identify parameters of the environment in which the code is compiled as the target operating system family and its version, processor architecture, compiler, and many others. Refer to the Boost.Asio documentation section for more details on this library at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html">http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html</a>.</p><p>To use the <code class="literal">Boost.Predef</code> library, we include the following header file:</p><div><pre class="programlisting">#include &lt;boost/predef.h&gt; // Tools to identify the OS.</pre></div><p>Then, we check whether the code is being compiled for Windows XP or Windows Server 2003, and if it is, we define the <code class="literal">BOOST_ASIO_DISABLE_IOCP</code> and <code class="literal">BOOST_ASIO_ENABLE_CANCELIO</code> macros:</p><div><pre class="programlisting">#ifdef BOOST_OS_WINDOWS
#define _WIN32_WINNT 0x0501

#if _WIN32_WINNT &lt;= 0x0502 // Windows Server 2003 or earlier.
#define BOOST_ASIO_DISABLE_IOCP
#define BOOST_ASIO_ENABLE_CANCELIO  
#endif
#endif</pre></div><p>Next, we include the common Boost.Asio header and standard library <code class="literal">&lt;thread&gt;</code> header. We will need the latter because we'll spawn additional threads in our application. In addition to this, we specify a <code class="literal">using</code> directive to make the names of Boost.Asio classes and functions shorter and more convenient to use:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace boost;</pre></div><p>Then, we define the application's <code class="literal">main()</code> entry point function, which contains all the functionalities of the application:</p><div><pre class="programlisting">int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

    std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock(
      new asio::ip::tcp::socket(ios, ep.protocol()));

    sock-&gt;async_connect(ep,
      [sock](const boost::system::error_code&amp; ec)
    {
      // If asynchronous operation has been
      // cancelled or an error occured during
      // execution, ec contains corresponding
      // error code.
      if (ec != 0) {
        if (ec == asio::error::operation_aborted) {
          std::cout &lt;&lt; "Operation cancelled!";
        }
        else {
          std::cout &lt;&lt; "Error occured!"
            &lt;&lt; " Error code = "
            &lt;&lt; ec.value()
            &lt;&lt; ". Message: "
            &lt;&lt; ec.message();
        }

        return;
      }
      // At this point the socket is connected and
      // can be used for communication with 
      // remote application.
    });

    // Starting a thread, which will be used
    // to call the callback when asynchronous 
    // operation completes.
    std::thread worker_thread([&amp;ios](){
      try {
        ios.run();
      }
      catch (system::system_error &amp;e) {
        std::cout &lt;&lt; "Error occured!"
        &lt;&lt; " Error code = " &lt;&lt; e.code()
        &lt;&lt; ". Message: " &lt;&lt; e.what();
      }
    });

    // Emulating delay.
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Cancelling the initiated operation.
    sock-&gt;cancel();

    // Waiting for the worker thread to complete.
    worker_thread.join();
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec65"/>How it works…</h2></div></div></div><p>Now, let's analyze how the application works.</p><p>Our sample client <a id="id121" class="indexterm"/>application consists of a single function, which is the application's <code class="literal">main()</code> entry point function. This function begins with allocating and opening a TCP socket according to step 2 of the algorithm.</p><p>Next, the asynchronous connection operation is initiated on the socket. The callback provided to the method is implemented as a lambda function. This corresponds to steps 3 and 4 of the algorithm. Note how the fact that the operation was canceled is determined in the callback function. When an asynchronous operation is canceled, the callback is invoked and its argument that specifies the error code contains an OS dependent error code defined in Boost.Asio as <code class="literal">asio::error::operation_aborted</code>.</p><p>Then, we spawn a thread named <code class="literal">worker_thread</code>, which will be used to run the Boost.Asio event loop. In the context of this thread, the callback function will be invoked by the library. The entry point function of the <code class="literal">worker_thread</code> thread is quite simple. It contains a <code class="literal">try-catch</code> block and a call to the <code class="literal">asio::io_service</code> object's <code class="literal">run()</code> method. This corresponds to step 5 of the algorithm.</p><p>After the worker <a id="id122" class="indexterm"/>thread is spawned, the main thread is put to sleep for 2 seconds. This is to allow the connection operation to progress a bit and emulate what could be a delay between the two commands issued by the user in the real application; for example, a web browser.</p><p>According to the last step 6 of the algorithm, we call the socket object's <code class="literal">cancel()</code> method to cancel the initiated connection operation. At this point, if the operation has not yet finished, it will be canceled and the corresponding callback will be invoked with an argument that specifies the error code containing the <code class="literal">asio::error::operation_aborted</code> value to notify that the operation was canceled. However, if the operation has already finished, calling the <code class="literal">cancel()</code> method has no effect.</p><p>When the callback function returns, the worker thread exits the event loop because there are no more outstanding asynchronous operations to be executed. As a result, the thread exits its entry point function. This leads to the main thread running to its completion as well. Eventually, the application exits.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec66"/>There's more...</h2></div></div></div><p>In the previous sample, we considered the canceling of an asynchronous connection operation associated with an active TCP socket. However, any operation associated with both the TCP and UDP sockets can be canceled in a similar way. The <code class="literal">cancel()</code> method should be called on the corresponding socket object after the operation has been initiated.</p><p>In addition to this, the <code class="literal">async_resolve()</code> method of the <code class="literal">asio::ip::tcp::resolver</code> or <code class="literal">asio::ip::udp::resolver</code> class used to asynchronously resolve a DNS name can be canceled by calling the resolver object's <code class="literal">cancel()</code> method.</p><p>All asynchronous operations initiated by the corresponding free functions provided by Boost.Asio can be canceled as well by calling the <code class="literal">cancel()</code> method on an object that was passed to the free function as the first argument. This object can represent either a socket (active or passive) or a resolver.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec67"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Implementing an asynchronous TCP client</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Implementing Client Applications">Chapter 3</a>, <em>Implementing Client Applications</em>, demonstrates how to construct a more complex client application that supports the asynchronous operation cancelation functionality</li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch01.html" title="Chapter 1. The Basics">Chapter 1</a>, <em>The Basics</em>, contains recipes that demonstrate how to synchronously connect a socket and resolve a DNS name</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Shutting down and closing a socket</h1></div></div></div><p>In some<a id="id123" class="indexterm"/> distributed applications that communicate over the TCP protocol, there is a need to transfer messages that do not have a fixed size and specific byte sequence, marking its boundary. This means that the receiving side, while reading the message from the socket, cannot determine where the message ends by analyzing the message itself with either its size or its content.</p><p>One approach to solve this problem is to structure each message in such a way that it consists of a logical header section and a logical body section. The header section has a fixed size and structure and specifies the size of the body section. This allows the receiving side to first read and parse the header, find out the size of the message body, and then properly read the rest of the message.</p><p>This approach is quite simple and is widely used. However, it brings some redundancy and additional computation overhead, which may be unacceptable in some circumstances.</p><p>Another approach can <a id="id124" class="indexterm"/>be applied when an application uses a separate socket for each message sent to its peer, which is a quite popular practice. The idea of this approach is to <strong>shut down</strong> the send part of the socket by the message sender after the message is written to the socket. This results in a special service message being sent to the receiver, informing the receiver that the message is over and the sender will not send anything else using the current connection.</p><p>The second approach provides many more benefits than the first one and, because it is part of the TCP protocol software, it is readily available to the developer for usage.</p><p>Another operation on a socket, that is, <strong>closing</strong> may seem similar to shutting down, but it is actually very different from it. Closing a socket assumes returning the socket and all the other resources associated with it back to the operating system. Just like memory, a process or a thread, a file handle or a mutex, a socket is a resource of an operating system. And like any other resource, a socket should be returned back to the operating system after it has been allocated, used, and is not needed by the application anymore. Otherwise, a resource leak may occur, which may eventually lead to the exhaustion of the resource and to the application's fault or instability of the whole operating system.</p><p>Serious issues that may occur when sockets are not closed make closing a very important operation.</p><p>The main difference between shutting down and closing a TCP socket is that closing interrupts the connection if one is established and, eventually, deallocates the socket and returns it back to the operating system, while shutting down only disables writing, reading, or both the operations on the socket and sends a service message to the peer application notifying about this <a id="id125" class="indexterm"/>fact. Shutting down a socket never results in deallocating the socket.</p><p>In this recipe, we'll <a id="id126" class="indexterm"/>see how to shut down and close a TCP socket.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec68"/>How to do it…</h2></div></div></div><p>Here, we'll consider a distributed application that consists of two parts: a client and a server to better understand how a socket shut down operation can be used to make an application layer protocol more efficient and clear when the communication between parts of distributed applications is based on binary messages of random sizes.</p><p>For simplicity, all operations in both the client and server applications are synchronous.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>The client application</h3></div></div></div><p>The <a id="id127" class="indexterm"/>purpose of the client application is to allocate the socket and connect it to the server application. After the connection is established, the application should prepare and send a request message notifying its boundary by shutting down the socket after writing the message to it.</p><p>After the request is sent, the client application should read the response. The size of the response is unknown; therefore, the reading should be performed until the server closes its socket to notify the response boundary.</p><p>We begin the client application by specifying the <code class="literal">include</code> and <code class="literal">using</code> directives:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, we define a function that accepts a reference to the socket object connected to the server and performs the communication with the server using this socket. Let's name this function <code class="literal">communicate()</code>:</p><div><pre class="programlisting">void communicate(asio::ip::tcp::socket&amp; sock) {
  // Allocating and filling the buffer with
  // binary data.
  const char request_buf[] = {0x48, 0x65, 0x0, 0x6c, 0x6c,
 0x6f};

  // Sending the request data.
  asio::write(sock, asio::buffer(request_buf));

  // Shutting down the socket to let the
  // server know that we've sent the whole
  // request.
  sock.shutdown(asio::socket_base::shutdown_send);

  // We use extensible buffer for response
  // because we don't know the size of the
  // response message.
  asio::streambuf response_buf;

  system::error_code ec;
  asio::read(sock, response_buf, ec);

  if (ec == asio::error::eof) {
    // Whole response message has been received.
    // Here we can handle it.
  }
  else {
    throw system::system_error(ec);
  }
}</pre></div><p>Finally, we define <a id="id128" class="indexterm"/>an application's <code class="literal">main()</code> entry point function. This function allocates and connects the socket, and then calls the <code class="literal">communicate()</code> function defined in the previous step:</p><div><pre class="programlisting">int main()
{
  std::string raw_ip_address = "127.0.0.1";
  unsigned short port_num = 3333;

  try {
    asio::ip::tcp::endpoint
      ep(asio::ip::address::from_string(raw_ip_address),
      port_num);

    asio::io_service ios;

    asio::ip::tcp::socket sock(ios, ep.protocol());

    sock.connect(ep);

    communicate(sock);
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>The server application</h3></div></div></div><p>The <a id="id129" class="indexterm"/>server application is intended to allocate an acceptor socket and passively wait for a connection request. When the connection request arrives, it should accept it and read the data from the socket connected to the client until the client application shuts down the socket on its side. Having received the request message, the server application should send the response message notifying its boundary by shutting down the socket.</p><p>We begin the client application by specifying <code class="literal">include</code> and <code class="literal">using</code> directives:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, we define a function that accepts a reference to the socket object connected to the client application and performs the communication with the client using this socket. Let's name this function <code class="literal">processRequest()</code>:</p><div><pre class="programlisting">void processRequest(asio::ip::tcp::socket&amp; sock) {
  // We use extensible buffer because we don't
  // know the size of the request message.
  asio::streambuf request_buf;

  system::error_code ec;

  // Receiving the request.
  asio::read(sock, request_buf, ec);

  if (ec != asio::error::eof)
    throw system::system_error(ec);

  // Request received. Sending response.
  // Allocating and filling the buffer with
  // binary data.
  const char response_buf[] = { 0x48, 0x69, 0x21 };

  // Sending the request data.
  asio::write(sock, asio::buffer(response_buf));

  // Shutting down the socket to let the
  // client know that we've sent the whole
  // response.
  sock.shutdown(asio::socket_base::shutdown_send);
}</pre></div><p>Finally, we <a id="id130" class="indexterm"/>define the application's <code class="literal">main()</code> entry point function. This function allocates an acceptor socket and waits for the incoming connection requests. When the connection request arrives, it obtains an active socket that is connected to the client application and calls the <code class="literal">processRequest()</code> function defined in the previous step by passing a connected socket object to it:</p><div><pre class="programlisting">int main()
{
  unsigned short port_num = 3333;
  
  try {
    asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(),
      port_num);

    asio::io_service ios;

    asio::ip::tcp::acceptor acceptor(ios, ep);

    asio::ip::tcp::socket sock(ios);

    acceptor.accept(sock);

    processRequest(sock);
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Closing a socket</h3></div></div></div><p>In<a id="id131" class="indexterm"/> order to close an allocated socket, the <code class="literal">close()</code> method should be called on the corresponding object of the <code class="literal">asio::ip::tcp::socket</code> class. However, usually, there is no need to do it explicitly because the destructor of the socket object closes the socket if one was not closed explicitly.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How it works…</h2></div></div></div><p>The server application is first started. In its <code class="literal">main()</code> entry point function, an acceptor socket is allocated, opened, bound to port <code class="literal">3333</code>, and starts waiting for the incoming connection request from the client.</p><p>Then, the client application is started. In its <code class="literal">main()</code> entry point function, an active socket is allocated, opened, and connected to the server. After the connection is established, the <code class="literal">communicate()</code> function is called. In this function, all the interesting things take place.</p><p>The client application writes a request message to the socket and then calls the socket's <code class="literal">shutdown()</code> method, passing an <code class="literal">asio::socket_base::shutdown_send</code> constant as an argument. This call shuts down the send part of the socket. At this point, writing to the socket is disabled, and there is no way to restore the socket state to make it writable again:</p><div><pre class="programlisting">sock.shutdown(asio::socket_base::shutdown_send);</pre></div><p>Shutting down the socket in the client application is seen in the server application as a protocol service message that arrives to the server, notifying the fact that the peer application has shut down the socket. Boost.Asio delivers this message to the application code by means of an error code returned by the <code class="literal">asio::read()</code> function. The Boost.Asio library defines this code as <code class="literal">asio::error::eof</code>. The server application uses this error code to find out when the client finishes sending the request message.</p><p>When the server application receives a full request message, the server and client exchange their roles. Now, the server writes the data, namely, the response message to the socket on its side, and the client application reads this message on its side. When the server finishes writing the response message to the socket, it shuts down the send part of its socket to imply that the whole message has been sent to its peer.</p><p>Meanwhile, the client application is blocked in the <code class="literal">asio::read()</code> function and reads the response sent by the server until the function returns with the error code equal to <code class="literal">asio::error::eof</code>, which implies that the server has finished sending the response message. When the <code class="literal">asio::read()</code> function returns with this error code, the client <em>knows</em> that it has read the whole response message, and it can then start processing it:</p><div><pre class="programlisting">system::error_code ec;
asio::read(sock, response_buf, ec);

if (ec == asio::error::eof) {
  // Whole response message has been received.
  // Here we can handle it.
}</pre></div><p>Note that after the client has shut down its socket's send part, it can still read data from the socket because the receive part of the socket stays open independently from the send part.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec70"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Writing to a TCP socket synchronously</em> recipe demonstrates how to write data to a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">The <em>Reading from a TCP socket synchronously</em> recipe demonstrates how to read data from a TCP socket synchronously</li><li class="listitem" style="list-style-type: disc">The <em>Implementing the HTTP client application</em> and <em>Implementing the HTTP server application</em> recipes in <a class="link" href="ch05.html" title="Chapter 5. HTTP and SSL/TLS">Chapter 5</a>, <em>HTTP and SSL/TLS</em>, demonstrate how a socket shut down is used in the implementation of the HTTP protocol</li></ul></div></div></div></body></html>