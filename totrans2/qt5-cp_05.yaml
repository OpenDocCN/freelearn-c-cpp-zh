- en: Chapter 5. Extending Paint Applications with Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins enable you to make your application extendable and friendly for other
    developers. Therefore, in this chapter, we''ll guide you in how to write plugins
    for Qt applications. A paint application demonstrates the recipe for Qt/C++. A
    simple demonstration shows you how to write a C++ plugin for QML. The topics we
    will cover in this chapter are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing via `QPainter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing static plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing dynamic plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging plugin and main program projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C++ plugins for QML applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing via QPainter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, let me introduce the `QPainter` class to you. This class
    performs low-level painting on widgets and other paint devices. In fact, everything
    drawn on the screen in a Qt application is the result of `QPainter`. It can draw
    almost anything, including simple lines and aligned text. Thanks to the high-level
    APIs that Qt has provided, it's extremely easy to use these rich features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt''s paint system consists of `QPainter`, `QPaintDevice`, and `QPaintEngine`.
    In this chapter, we won''t need to deal with the latter two. The relations diagram
    is sketched as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing via QPainter](img/4615OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`QPainter` is used to perform drawing operations, while `QPaintDevice` is an
    abstraction of a two-dimensional space that can be painted on by using `QPainter`.
    `QPaintEngine` provides the interface that the painter uses to draw onto different
    types of devices. Note that the `QPaintEngine` class is used internally by `QPainter`
    and `QPaintDevice`. It''s also designed to be hidden from programmers unless they
    create their own device type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, what we need to concentrate on is `QPainter`. Let''s create a
    new project and do some exercises in it. The new `painter_demo` project is a Qt
    Widget application. Quickly create it and add a new C++ `Canvas` class that inherits
    from `QWidget`. `Canvas` is our customized widget whose header file is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `QVector` class is a template class that provides a fast and dynamic array.
    It's fast because the items are stored in adjacent memory locations, which means
    that the indexing time is constant. Here, we store the `QPointF` elements in `m_points`,
    where `QPointF` is a class that defines a point using a floating point precision.
  prefs: []
  type: TYPE_NORMAL
- en: In a `protected` scope, there are four event functions. We're familiar with
    these mouse events. The leading one, which is also the new one, is the `paintEvent`
    function. Since we're painting on the widget, `QPainter` should only be used inside
    the `paintEvent` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definitions of the functions in `canvas.cpp` are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s check what''s inside the `paintEvent` function. The first clause
    is to initialize a `QPainter` object, which uses this as `QPaintDevice`. Well,
    there is an alternate way to initialize a `QPainter` class, which is demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you use the method shown in the preceding code, remember to call the `end()`
    function to destroy `painter`. By contrast, if you initialize `QPainter` by its
    constructor, the destructor will automatically call the `end()` function. However,
    the constructor won't return a value indicating whether it was initialized successfully
    or not. Thus, it'd be better to choose the latter method when dealing with an
    external `QPaintDevice` such as a printer.
  prefs: []
  type: TYPE_NORMAL
- en: After the initialization, we use `QStyleOption`, which contains all the information
    that the `QStyle` functions need to draw a graphical element and make our customized
    widget style-aware. We simply use the `initFrom` function to get the style information.
    Then, we get the `QStyle` function of our widget and draw `QStyle::PE_Widget`
    with `painter` using the style options specified by `opt`. If we don't write these
    three lines, we can't change the widget display style, such as the background
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we let the painter use a black pen to draw an anti-aliasing polyline on
    the widget. Here, an overloaded `setPen` function is used. The `painter.setPen(QColor(Qt::black))`
    function will set a solid-line style pen with a width of `1` and the color in
    black. The `painter.setRenderHint(QPainter::Antialiasing)` function will make
    the drawing smooth.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A second argument, `bool`, controls the render hint. It's `true` by default,
    which means that you need to turn on the render hint. You can turn off a render
    hint by passing a `false` value, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of the available render hints are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also two obsolete hints: `QPainter::HighQualityAntialiasing` and
    `QPainter::NonCosmeticDefaultPen`. The first one is replaced by `QPainter::Antialiasing`
    and the second is useless because `QPen` is non-cosmetic by default now.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `drawPolyline` function will draw a polyline, which is made from
    the mouse movements, on the `Canvas` widget. The first argument is the pointer
    to a `QPointF` or `QPoint` array, while the second one is the number of items
    inside that array.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of mouse movements, three mouse event functions are used to track the
    mouse. In fact, they're pretty self-explanatory. When a mouse press event occurs,
    purge the points array because it's obviously a new polyline now, and then add
    the mouse position by invoking a `localPos()` function. The `localPos()` function
    will return the position of the mouse relative to the widget or item that received
    the event. Although you can get a global position by the `screenPos()` and `globalPos()`
    function, in most cases, we only need a local position. At the end of these event
    functions, call `update()` to repaint the widget to show the mouse moving path
    as a polyline.
  prefs: []
  type: TYPE_NORMAL
- en: Now, edit `mainwindow.ui` in the **Design** mode. Remove the status bar since
    we won't use it in this chapter, but keep the menu bar. Drag **Widget** to `centralWidget`
    and rename it as `canvas`. Right-click on `canvas` and select **Promote to …**,
    and then fill in `Canvas` in **Promoted class name**. Now, click on **Add**, and
    then on **Promote**. You shouldn't check the **Global include** box because the
    `canvas.h` header file is in our project directory instead of the global include
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside **Property**, edit `styleSheet`, input `background-color: rgb(255, 255,
    255);` so that the canvas has a white background. Then, change the `MainWindow`
    class'' layout to **Lay Out Horizontally** or **Lay Out Vertically** so that the
    `canvas` widget can fill the whole frame. Give your application a run now; you
    should expect a simple white painter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing via QPainter](img/4615OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This painter is too simple to hold the old lines. While Qt doesn't provide an
    API to paint on the old scene, `QImage` can get us out of this dilemma. In other
    words, when the mouse moves, we paint a stroke on a `QImage` object, and then
    paint this `QImage` object onto `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new header file, `canvas.h`, is as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences include the declaration of a `QImage` object, `image`; private
    member function, `updateImage()`; and a reimplemented function, `resizeEvent(QResizeEvent
    *)`. The `paintEvent(QPaintEvent *)` function is also changed to draw the `image`
    object instead, whereas there are more modifications in the `canvas.cpp` source
    file than the header file, whose content is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's look into the mouse event handlers; after the operation on `m_points`,
    the `updateImage()`function is called instead of `update()`. Inside the `updateImage()`
    function, we create a `QPainter` object using the `QImage` object image as `QPaintDevice`
    while the rest of them are just the same as in `paintEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a new member function, though, called `resizeEvent`, which is reimplemented
    from `QWidget`. As you can imagine, we change the underlying `QImage` object once
    the widget size changes, which could be as a result of window resizing. Therefore,
    we simply paint the old image onto the new one. This may cause the loss of a part
    of the image if the new size is smaller than the previous one. You may wish to
    add `Scroll Area` to `MainWindow` and make `Canvas` the child widget of `Scroll
    Area`. You already know how to do that in QML, while it's similar in Qt/C++. Therefore,
    just take it as an exercise and implement `Scroll Area` for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing static plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of plugins: static and dynamic. Static plugins are statically
    linked to the executables, while the dynamic plugins are loaded at runtime. Dynamic
    plugins exist as the `.dll` or `.so` files, depending on the platform. Although
    the static plugins will be built as the `.lib` or `.a` files, they''ll be integrated
    into an executable file when the main program gets compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this topic, we''ll get to know how to write a static plugin to extend the
    application. Serving as an external plugin, it gains the flexibility to change
    its internal code while it''s only required to keep the interface compatible.
    It''s up to you to decide whether the interface should be maintained in the main
    program or in different plugins. In this example, we''ll put the `interface.h`
    file in the main program, `painter_demo`. The content of `interface.h` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we declare a pure virtual class, `InsertInterface`. In order
    to avoid errors, you have to declare a virtual destructor. Otherwise, the compiler
    may complain and abort the compilation. The `QPainterPath` class provides a container
    for common 2D painting operations, including `ellipse` and `text`. Hence, the
    return type of `getObject` is `QPainterPath` ,which can be used directly where
    the argument, `QWidget`, could be useful if there is a newly created dialog to
    get any input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this file, we declare `InsertInterface` as an interface by the
    `Q_DECLARE_INTERFACE` macro, where `InsertInterface_iid` is the identifier for
    the `InsertInterface` class. Note that the identifier must be unique, so it's
    recommended that you use a Java-style naming rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a new project. Navigate to **Libraries** | **C++ Library**.
    Then, as shown in the following screenshot, select **Qt Plugin** for **Type**
    and keep this project inside the main program project folder for the sake of convenience
    or any concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing static plugins](img/4615OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Next** and choose the same Qt kits as the `painter_demo` project.
    In this example, the `build` directory is set in the same directory as the `painter_demo`
    project, which is `D:\Projects\build`. Therefore, the `build` directory of `TextPlugin`
    is `D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Debug` and `D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Release`
    for `Debug` and `Release`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Furthermore, you can change **Default build directory** in **Tools** | **Options**
    | **Build & Run** | **General**. In this book, we use `D:/Projects/build/%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}`
    so that all the builds are organized in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, fill in `TextPlugin` in the `Class name` field, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing static plugins](img/4615OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to apply some modifications to the `TextPlugin.pro` project file, as
    displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding widgets, we can use some useful classes such as `QMessageBox`. We
    also need to add `static` to `CONFIG` to declare this a static plugin project.
    Then, change the `DESTDIR` variable to `../plugins` so that the plugin is installed
    to the `plugins` directory outside the `build` folder. Lastly, we add the upper
    directory `../` to `INCLUDEPATH` so that we can include the `interface.h` header
    file in this subproject. The `textplugin.h` file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Q_PLUGIN_METADATA` macro to specify the unique `IID`, which is
    the same as the one we declared in `interface.h`, where `FILE "TextPlugin.json"`
    can be used to contain the metadata for this plugin. In this case, we just keep
    the `TextPlugin.json` file intact. Then, the `Q_INTERFACES` macro tells the compiler
    that this is a plugin for `InsertInterface`. In the `public` scope, there are
    just two reimplemented functions. Their definitions are located in the `textplugin.cpp`
    source file, whose content is pasted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `name()` function simply returns the name of this plugin, which is `Text`
    in this case. As for `getObject`, it constructs a `QPainterPath` class that contains
    the text given by the user via a pop-up dialog, and then returns the `QPainterPath`
    object to the main program. The `addText` function will draw the text as a set
    of closed subpaths created from the font, while the first two arguments define
    the left end of the baseline for this text.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is it for the plugin project. Now, just build it and you should expect
    a `libTextPlugin.a` file to be located under the `plugins` directory, while the
    `plugins` directory itself should be located in the parent directory of your project''s
    `build` folders, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing static plugins](img/4615OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It doesn't matter much if you put the files under other directories, although
    this means that you need to do some path modifications relevantly afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the main program''s project, which is `painter_demo`
    in this example. Edit its `painter_demo.pro` project file and add the following
    line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The working directory during compilation is the `build` directory instead of
    the project source code directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, edit `mainwindow.ui` in the **Design** mode; add a menu named `Plugins`
    to the menu bar, whose object name is `menuPlugins`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among all the changes made in the main program, the modifications for the `MainWindow`
    class are maximum. Here is the code of the new `mainwindow.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Still no clue about it? Well, its `mainwindow.cpp` source file is pasted here
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may have figured out that the `Q_IMPORT_PLUGIN` macro is used to import
    the plugin. Yes, it is, but only for static plugins. In the `loadPlugins()` function,
    we walked through all the static plugin instances and added them to the menu by
    invoking the `generatePluginMenu` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plugins are treated as plain `QOjbect` objects at first, and then you can use
    `qobject_cast` to convert them to their own classes. The `qobject_cast` class
    will return a `NULL` pointer if it failed. Inside the `if` statement, there is
    a trick to use the plugin successfully later. Instead of calling a simplified
    and overloaded `addAction` function, we can construct `QAction` and add it to
    the menu, because `QAction` will have the plugin as its `QObject` parent. Therefore,
    you can see that we convert its parent to the relevant plugin class in the `onInsertInterface`
    function. Inside this function, we call the `insertPainterPath` function to paint
    the `QPainterPath` class returned by the plugin on `canvas`. Of course, we need
    to declare and define this function in the `Canvas` class. Add this statement
    to the `public` domain of the `canvas.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code''s definition in `canvas.cpp` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statements should be familiar to you and they're also self-explanatory.
    Now, build and run this application again; don't forget to change the current
    active project back to `painter_demo` by right-clicking on the `painter_demo`
    project and selecting **Set "painter_demo" as Active Project**. When it runs,
    click on **Plugins**, select **Text**, input `Plugin!!` in the pop-up dialog,
    and confirm. Then, you'll see the text, **Plugin!!**, painted on the canvas as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing static plugins](img/4615OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The executable's size grows as well because we statically linked our `TextPlugin`
    project file to it. In addition to this, you have to rebuild the main program
    if you changed the plugin. Otherwise, the newly generated plugin won't be linked
    to the executable as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Writing dynamic plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static plugins provide a convenient way to distribute your applications. However,
    this always requires a rebuild of the main program. By contrast, dynamic plugins
    are much more flexible since they're linked dynamically. This means the main project,
    which is `painter_demo` in this example, doesn't need to be built with dynamic
    plugins nor is it required to release its source code. Instead, it only needs
    to provide an interface and the header file of that interface, and then scan those
    dynamic plugins at runtime so that they can be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic plugins are commonly seen in complex applications, especially in commercial
    software such as Adobe Illustrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the static plugin we just wrote, we need to create a new Qt Plugin
    project and we''ll call it `EllipsePlugin` this time. Although you can write a
    new interface along with this plugin, here we will just focus on plugin-related
    topics. So, we just reuse the `InsertInterface` class while the `ellipseplugin.pro`
    project file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to change the `DESTDIR` and `INCLUDEPATH` variables in the `ellipseplugin.pro`
    file though, they're basically the same as the previous `TextPlugin` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignoring the source files, forms, and so on, it''s basically the same thing
    with only the removal of `static` in `CONFIG`. The `ellipseplugin.h` header file
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we declare that this is a plugin using
    `InsertInterface` as the same in `TextPlugin`, whereas the difference is the declaration
    of an `onDialogAccepted` slot function and several `private` variables. Accordingly,
    the `ellipseplugin.cpp` file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special about the `name()` function. By contrast, we use the
    `EllipseDialog` custom dialog to get some inputs from the user. Remember to connect
    all the signals and slots associated with the dialog before executing the `exec()`
    function; otherwise, the slots simply won't be connected. Also, note that the
    `exec()` function will block the event loop and return only after the dialog closes,
    which is pretty handy for our purposes because we can use the accepted values,
    such as `m_x` and `m_y`, to add an ellipse to `QPainterPath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `EllipseDialog` custom dialog itself, it was created by adding a
    new Qt Designer Form Class via Qt Creator. Since it''s used to provide an interface
    for the user to specify some parameters, we use **Form Layout** in this dialog.
    Add `QLabel` and `QDoubleSpinBox`, as suggested in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing dynamic plugins](img/4615OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accordingly, their `objectName` values are `tlXLabel`, `tlXDoubleSpinBox`, `tlYLabel`,
    `tlYDoubleSpinBox`, `widthLabel`, `widthDoubleSpinBox`, `heightLabel`, and `heightDoubleSpinBox`.
    You should also change the `maximum` value to `9999.99` or something big enough
    in the **Property** panel of `QDoubleSpinBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, also note that there is a removal of the default signal
    and slot in **Signals & Slots Editor**. Simply delete the `accepted()` signal
    pair of `buttonBox` because we need a more advanced handler. In this form class
    header file, `ellipsedialog.h`, we declare a new signal and a new slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accepted(qreal, qreal, qreal, qreal)` signal here passes these values
    back to the plugin, while the `onAccepted()` slot handles the `accepted()` signal
    emitted from `buttonBox`. They are defined in the `ellipsedialog.cpp` source file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Inside the constructor, connect the `accepted()` signal of `buttonBox` to the
    `onAccepted()` advanced handler slot. In this slot, we emit the `accepted` signal,
    which contains the values that the user has entered. Then, call the `accept()`
    function to close this dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '`EllipsePlugin` is finished at this point. Click on the **Build** button in
    the panel to build this project. You should expect the output, `EllipsePlugin.dll`
    on Windows, to be located in the same `plugins` directory as the previous `TextPlugin`
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this dynamic plugin, we need a final step, which is to make
    the main program load the dynamic plugin(s). What we have to change here is the
    `loadPlugins()` function in `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the `QDir` class, you may also need to include this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `QDir` class will provide access to directory structures and their contents,
    which we use to locate our dynamic plugins. The `qApp` macro is a global pointer,
    referring to this very application instance. It's equivalent to the `QCoreApplication::instance()`
    function and `QApplication::instance()` for non-GUI and GUI applications, respectively.
    On Windows platforms, our `plugins` directory is located in the second upper folder
    of the `build` path.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we just test each file in the `plugins` directory, load it, and generate
    a proper menu entry if it's a loadable plugin. Run this application again; you'll
    have an **Ellipse** entry inside the **Plugins** menu. It works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing dynamic plugins](img/4615OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Merging plugins and main program projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a tedious thing that opens several projects and builds them in order.
    This is not a big deal given that we have just two plugins and a main program.
    However, it'll become a serious inefficiency issue once the number of plugins
    increase. Therefore, it is a better practice to merge the plugins into the main
    project and get them built in a specified order every time we click on the **Build**
    button. It's totally feasible and is commonly seen in Qt projects.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we move all the files in the `painter_demo` directory, except for the
    `EllipsePlugin` and `TextPlugin` folders, into a newly created `main` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, rename the `painter_demo.pro` to `main.pro` in the `main` folder while
    creating a new `painter_demo.pro` project file outside in the `painter_demo` directory.
    This new `painter_demo.pro` project file needs to have contents as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `subdirs` project is a special template, which means that this project file
    won't generate an application or a library. Instead, it tells `qmake` to build
    subdirectories. By adding `ordered` to `CONFIG`, we can ensure that the compiling
    process follows the exact order according to `SUBDIRS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we need to modify the project files in the two plugins
    directories. Change the `INCLUDEPATH` variable to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This change is obvious because we moved all the source code into the `main`
    directory. If we don't change `INCLUDEPATH`, the compiler will complain that it
    can't find the `interface.h` header file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C++ plugin for QML applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not too difficult to write a plugin for Qt/C++ applications, whereas it's
    somewhat more complex to create a plugin for the QML applications. The idea is
    the same, and here we will use a very basic example to demonstrate this topic.
    Basically, this application will encode the text input as `Base64` and display
    it. The `Base64` encoding part is implemented in the C++ plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we''re going to create the plugin project first, and then complete
    the QML part. Creating a plugin project for a QML application shares the same
    procedure. Navigate to **Libraries** | **C++ Library**, and then select **Qt Plugin**
    with the name as `Base64Plugin`. Its project file, `Base64Plugin.pro`, is pasted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We set `DESTDIR` to `../imports/Base64` for the sake of convenience. You can
    change this to some other path, but you may need to make some relevant changes
    later to be able to import this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project consists of two C++ classes. The `Base64` class will later be
    exported to QML, whereas `Base64Plugin` registers the `Base64` class. The former
    class'' `base64.h` header file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `base.cpp` counterpart defines the `get` function, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The tricky part is in the `Base64Plugin` class, which is not identical to the
    previous plugin class. Its `base64plugin.h` header file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `QQmlExtensionPlugin` subclass, we''re able to write our own QML plugin.
    In fact, this class is used to declare the `Base64` class for QML. Also note that
    since `IID` in `Q_PLUGIN_METADATA` is fixed, you probably don''t want to change
    it. As a subclass, it has to reimplement the `registerTypes` function, which simply
    registers the class(es). The detailed definition is located in the `baseplugin.cpp`
    file whose contents are as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `Q_ASSERT` macro will ensure that the plugin is located inside the `Base64`
    directory. If not, it'll print a warning message containing the source code, filename,
    and line number. Note that `uri`, which is expected to be `Base64` in this case,
    is the module name for QML. Below this line, `qmlRegisterType` is a template function
    where you need to put the class name, `Base64`, inside brackets. These arguments
    will register the class with `Base64` as the QML name with Version 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'A last piece is needed to declare a loadable plugin, which is the `qmldir`
    file. Note that it has no extension name. This file defines the module name and
    relevant files in the directory. Here is the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We need to put this file in the `../imports/Base64` directory, which is the
    `DESTDIR` of `Base64Plugin`. Along with a few lines in the QML application project's
    `main.cpp` file, QML can then import a plugin as it imports any other Qt Quick
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create a new Qt Quick application project now. The project name
    is simply `QML_Plugin` and we move the `Base64Plugin` class into the `QML_Plugin`
    directory, which enables the Qt Creator syntax to highlight the `Base64Plugin`
    class. Here is the content of `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember to state `import Base64 1.0` at the very beginning of the code so that
    our plugin can be loaded. Then, `Base64` is just like other QML types we have
    used before. In the `onEditingFinished` handler of `input TextField`, we use the
    `get` function, which is in the `Base64` class, to set `bt.text` to the corresponding
    `Base64` class-encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder how a QML `string` type is converted to a `QString` object. Well,
    it's implicitly converted between QML and Qt/C++. There are plenty of these conversions
    for commonly-seen QML data types and Qt data classes. For details, you can look
    at the Qt documentation to see the full list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing is that we need to change `main.cpp`, as mentioned before. Similar
    to the Qt/C++ case, we use the `QDir` class to get an application directory and
    change it to `../imports`. Be aware that you should use `addImportPath` instead
    of `addPluginPath` to add `../imports` to the QML engine''s module search path.
    This is because we use `Base64` as a module, which should be located in the `imports`
    path. Meanwhile, the plugin path is for native plugins of imported modules, which
    are stated in `qmldir`. The content of the `main.cpp` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build `Base64Plugin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `qmldir` file into the `../imports/Base64` directory (the `imports`
    folder should be located in the same place as `plugins`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the `QML_Plugin` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can test this application by inputting any string in the first input field
    and just pressing *Enter*. One scenario for this application is to encode your
    e-mail address to avoid a web spider, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a C++ plugin for QML applications](img/4615OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the module isn't well located, the application won't show up and it'll complain
    that `Base64` is not installed. If that happens, make sure you add the correct
    path in `main.cpp` and there is a `qmldir` file inside the `Base64` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is somewhat difficult to get started on writing plugins. However, after some
    basic practice, you'll find that it's actually easier than it looks. For Qt Widgets
    applications, plugins simply extend the application in a flexible way. Meanwhile,
    they enable developers to devise new forms for QML applications. We also covered
    using the `subdirs` project to manage multiple subprojects. Even if you don't
    plan to write plugins, this chapter covered painting-related stuff that is crucial
    for GUI application development, including `QPainter`, `paintEvent`, and `resizeEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to talk about network programming and multithreading
    in Qt.
  prefs: []
  type: TYPE_NORMAL
