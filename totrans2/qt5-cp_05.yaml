- en: Chapter 5. Extending Paint Applications with Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：使用插件扩展绘图应用程序
- en: 'Plugins enable you to make your application extendable and friendly for other
    developers. Therefore, in this chapter, we''ll guide you in how to write plugins
    for Qt applications. A paint application demonstrates the recipe for Qt/C++. A
    simple demonstration shows you how to write a C++ plugin for QML. The topics we
    will cover in this chapter are listed as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 插件使您能够使您的应用程序可扩展且对其他开发者友好。因此，在本章中，我们将指导您如何为Qt应用程序编写插件。一个绘图应用程序展示了Qt/C++的配方。一个简单的演示向您展示了如何编写一个C++插件用于QML。本章我们将涵盖的主题如下所示：
- en: Drawing via `QPainter`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`QPainter`绘图
- en: Writing static plugins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写静态插件
- en: Writing dynamic plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动态插件
- en: Merging plugin and main program projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并插件和主程序项目
- en: Creating a C++ plugins for QML applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为QML应用程序创建C++插件
- en: Drawing via QPainter
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过QPainter绘图
- en: Before we get started, let me introduce the `QPainter` class to you. This class
    performs low-level painting on widgets and other paint devices. In fact, everything
    drawn on the screen in a Qt application is the result of `QPainter`. It can draw
    almost anything, including simple lines and aligned text. Thanks to the high-level
    APIs that Qt has provided, it's extremely easy to use these rich features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我向您介绍`QPainter`类。这个类在窗口和其他绘图设备上执行低级绘图。实际上，在Qt应用程序中屏幕上绘制的所有内容都是`QPainter`的结果。它可以绘制几乎任何东西，包括简单的线条和对齐文本。多亏了Qt提供的高级API，使用这些丰富的功能变得极其简单。
- en: 'Qt''s paint system consists of `QPainter`, `QPaintDevice`, and `QPaintEngine`.
    In this chapter, we won''t need to deal with the latter two. The relations diagram
    is sketched as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的绘图系统由`QPainter`、`QPaintDevice`和`QPaintEngine`组成。在本章中，我们不需要处理后两者。关系图如下所示：
- en: '![Drawing via QPainter](img/4615OS_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![通过QPainter绘图](img/4615OS_05_01.jpg)'
- en: '`QPainter` is used to perform drawing operations, while `QPaintDevice` is an
    abstraction of a two-dimensional space that can be painted on by using `QPainter`.
    `QPaintEngine` provides the interface that the painter uses to draw onto different
    types of devices. Note that the `QPaintEngine` class is used internally by `QPainter`
    and `QPaintDevice`. It''s also designed to be hidden from programmers unless they
    create their own device type.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`用于执行绘图操作，而`QPaintDevice`是一个可以由`QPainter`绘制的二维空间抽象。`QPaintEngine`提供了画家用于在不同类型的设备上绘图的接口。请注意，`QPaintEngine`类是`QPainter`和`QPaintDevice`内部使用的。它也被设计成对程序员隐藏，除非他们创建自己的设备类型。'
- en: 'So basically, what we need to concentrate on is `QPainter`. Let''s create a
    new project and do some exercises in it. The new `painter_demo` project is a Qt
    Widget application. Quickly create it and add a new C++ `Canvas` class that inherits
    from `QWidget`. `Canvas` is our customized widget whose header file is shown as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上需要关注的是`QPainter`。让我们创建一个新的项目并在其中做一些练习。新的`painter_demo`项目是一个Qt小部件应用程序。快速创建它并添加一个新的从`QWidget`继承的C++
    `Canvas`类。`Canvas`是我们自定义的小部件，其头文件如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `QVector` class is a template class that provides a fast and dynamic array.
    It's fast because the items are stored in adjacent memory locations, which means
    that the indexing time is constant. Here, we store the `QPointF` elements in `m_points`,
    where `QPointF` is a class that defines a point using a floating point precision.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector`类是一个模板类，它提供了一个快速且动态的数组。它之所以快速，是因为元素存储在相邻的内存位置，这意味着索引时间保持恒定。在这里，我们将`QPointF`元素存储在`m_points`中，其中`QPointF`是一个使用浮点精度定义点的类。'
- en: In a `protected` scope, there are four event functions. We're familiar with
    these mouse events. The leading one, which is also the new one, is the `paintEvent`
    function. Since we're painting on the widget, `QPainter` should only be used inside
    the `paintEvent` function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protected`作用域中，有四个事件函数。我们熟悉这些鼠标事件。最前面的是新的事件，即`paintEvent`函数。由于我们在小部件上绘图，`QPainter`应该只在使用`paintEvent`函数时使用。
- en: 'The definitions of the functions in `canvas.cpp` are shown as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.cpp`中函数的定义如下所示：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, let''s check what''s inside the `paintEvent` function. The first clause
    is to initialize a `QPainter` object, which uses this as `QPaintDevice`. Well,
    there is an alternate way to initialize a `QPainter` class, which is demonstrated
    here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查`paintEvent`函数内部的内容。第一条是初始化一个`QPainter`对象，它使用此作为`QPaintDevice`。嗯，还有另一种初始化`QPainter`类的方法，这里将演示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you use the method shown in the preceding code, remember to call the `end()`
    function to destroy `painter`. By contrast, if you initialize `QPainter` by its
    constructor, the destructor will automatically call the `end()` function. However,
    the constructor won't return a value indicating whether it was initialized successfully
    or not. Thus, it'd be better to choose the latter method when dealing with an
    external `QPaintDevice` such as a printer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用前面代码中所示的方法，请记住调用`end()`函数来销毁`painter`。相比之下，如果你通过构造函数初始化`QPainter`，析构函数将自动调用`end()`函数。然而，构造函数不会返回一个指示是否成功初始化的值。因此，当处理外部`QPaintDevice`（如打印机）时，选择后者方法会更好。
- en: After the initialization, we use `QStyleOption`, which contains all the information
    that the `QStyle` functions need to draw a graphical element and make our customized
    widget style-aware. We simply use the `initFrom` function to get the style information.
    Then, we get the `QStyle` function of our widget and draw `QStyle::PE_Widget`
    with `painter` using the style options specified by `opt`. If we don't write these
    three lines, we can't change the widget display style, such as the background
    color.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化之后，我们使用`QStyleOption`，它包含了`QStyle`函数绘制图形元素和使我们的自定义小部件样式感知所需的所有信息。我们简单地使用`initFrom`函数来获取样式信息。然后，我们获取我们小部件的`QStyle`函数，并使用`painter`和由`opt`指定的样式选项来绘制`QStyle::PE_Widget`。如果我们不写这三行代码，我们就无法更改小部件的显示样式，例如背景颜色。
- en: Then, we let the painter use a black pen to draw an anti-aliasing polyline on
    the widget. Here, an overloaded `setPen` function is used. The `painter.setPen(QColor(Qt::black))`
    function will set a solid-line style pen with a width of `1` and the color in
    black. The `painter.setRenderHint(QPainter::Antialiasing)` function will make
    the drawing smooth.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们让画家使用一支黑色笔在部件上绘制一个抗锯齿多段线。在这里，使用了重载的`setPen`函数。`painter.setPen(QColor(Qt::black))`函数将设置一个宽度为`1`的实线样式笔，颜色为黑色。`painter.setRenderHint(QPainter::Antialiasing)`函数将使绘图平滑。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A second argument, `bool`, controls the render hint. It's `true` by default,
    which means that you need to turn on the render hint. You can turn off a render
    hint by passing a `false` value, though.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`bool`控制渲染提示。默认值为`true`，这意味着你需要打开渲染提示。虽然你可以通过传递`false`值来关闭渲染提示。
- en: 'A list of the available render hints are shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，列出了可用的渲染提示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are also two obsolete hints: `QPainter::HighQualityAntialiasing` and
    `QPainter::NonCosmeticDefaultPen`. The first one is replaced by `QPainter::Antialiasing`
    and the second is useless because `QPen` is non-cosmetic by default now.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个已废弃的提示：`QPainter::HighQualityAntialiasing`和`QPainter::NonCosmeticDefaultPen`。第一个被`QPainter::Antialiasing`所取代，而第二个现在是无用的，因为`QPen`默认是非装饰性的。
- en: Finally, the `drawPolyline` function will draw a polyline, which is made from
    the mouse movements, on the `Canvas` widget. The first argument is the pointer
    to a `QPointF` or `QPoint` array, while the second one is the number of items
    inside that array.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`drawPolyline`函数将在`Canvas`小部件上绘制一个多段线，该多段线由鼠标移动生成。第一个参数是指向`QPointF`或`QPoint`数组的指针，而第二个参数是数组中项的数量。
- en: Speaking of mouse movements, three mouse event functions are used to track the
    mouse. In fact, they're pretty self-explanatory. When a mouse press event occurs,
    purge the points array because it's obviously a new polyline now, and then add
    the mouse position by invoking a `localPos()` function. The `localPos()` function
    will return the position of the mouse relative to the widget or item that received
    the event. Although you can get a global position by the `screenPos()` and `globalPos()`
    function, in most cases, we only need a local position. At the end of these event
    functions, call `update()` to repaint the widget to show the mouse moving path
    as a polyline.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 说到鼠标移动，使用了三个鼠标事件函数来跟踪鼠标。实际上，它们相当直观。当鼠标按下事件发生时，清除点数组，因为很明显现在是一个新的多段线，然后通过调用`localPos()`函数添加鼠标位置。`localPos()`函数将返回鼠标相对于接收事件的部件或项的位置。虽然你可以通过`screenPos()`和`globalPos()`函数获取全局位置，但在大多数情况下，我们只需要本地位置。在这些事件函数的末尾，调用`update()`来重新绘制小部件，以显示鼠标移动路径作为多段线。
- en: Now, edit `mainwindow.ui` in the **Design** mode. Remove the status bar since
    we won't use it in this chapter, but keep the menu bar. Drag **Widget** to `centralWidget`
    and rename it as `canvas`. Right-click on `canvas` and select **Promote to …**,
    and then fill in `Canvas` in **Promoted class name**. Now, click on **Add**, and
    then on **Promote**. You shouldn't check the **Global include** box because the
    `canvas.h` header file is in our project directory instead of the global include
    directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**设计**模式下编辑`mainwindow.ui`。删除状态栏，因为我们在这个章节中不会使用它，但保留菜单栏。将**Widget**拖到`centralWidget`上，并将其重命名为`canvas`。右键单击`canvas`并选择**提升到…**，然后在**提升的类名**中填写`Canvas`。现在，点击**添加**，然后点击**提升**。你不应该勾选**全局包含**框，因为`canvas.h`头文件在我们的项目目录中，而不是全局包含目录中。
- en: 'Inside **Property**, edit `styleSheet`, input `background-color: rgb(255, 255,
    255);` so that the canvas has a white background. Then, change the `MainWindow`
    class'' layout to **Lay Out Horizontally** or **Lay Out Vertically** so that the
    `canvas` widget can fill the whole frame. Give your application a run now; you
    should expect a simple white painter as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '在**属性**中，编辑`styleSheet`，输入`background-color: rgb(255, 255, 255);`以便画布具有白色背景。然后，将`MainWindow`类的布局更改为**水平布局**或**垂直布局**，以便`canvas`小部件可以填充整个框架。现在运行你的应用程序；你应该期望看到一个简单的白色画笔，如下所示：'
- en: '![Drawing via QPainter](img/4615OS_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![通过QPainter绘图](img/4615OS_05_02.jpg)'
- en: This painter is too simple to hold the old lines. While Qt doesn't provide an
    API to paint on the old scene, `QImage` can get us out of this dilemma. In other
    words, when the mouse moves, we paint a stroke on a `QImage` object, and then
    paint this `QImage` object onto `Canvas`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个画笔太简单，无法保留旧线条。虽然Qt没有提供在旧场景上绘制的API，但`QImage`可以帮助我们摆脱这个困境。换句话说，当鼠标移动时，我们在`QImage`对象上绘制一个笔触，然后将这个`QImage`对象绘制到`Canvas`上。
- en: 'The new header file, `canvas.h`, is as shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 新的头文件`canvas.h`如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The differences include the declaration of a `QImage` object, `image`; private
    member function, `updateImage()`; and a reimplemented function, `resizeEvent(QResizeEvent
    *)`. The `paintEvent(QPaintEvent *)` function is also changed to draw the `image`
    object instead, whereas there are more modifications in the `canvas.cpp` source
    file than the header file, whose content is shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 差异包括`QImage`对象的声明，`image`；私有成员函数，`updateImage()`；以及重写的函数，`resizeEvent(QResizeEvent
    *)`。`paintEvent(QPaintEvent *)`函数也被修改为绘制`image`对象，而在`canvas.cpp`源文件中的修改比头文件要多，其内容如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's look into the mouse event handlers; after the operation on `m_points`,
    the `updateImage()`function is called instead of `update()`. Inside the `updateImage()`
    function, we create a `QPainter` object using the `QImage` object image as `QPaintDevice`
    while the rest of them are just the same as in `paintEvent`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看鼠标事件处理器；在`m_points`操作之后，调用的是`updateImage()`函数而不是`update()`函数。在`updateImage()`函数内部，我们使用`QImage`对象作为`QPaintDevice`来创建一个`QPainter`对象，而其余的与`paintEvent`中的相同。
- en: There is a new member function, though, called `resizeEvent`, which is reimplemented
    from `QWidget`. As you can imagine, we change the underlying `QImage` object once
    the widget size changes, which could be as a result of window resizing. Therefore,
    we simply paint the old image onto the new one. This may cause the loss of a part
    of the image if the new size is smaller than the previous one. You may wish to
    add `Scroll Area` to `MainWindow` and make `Canvas` the child widget of `Scroll
    Area`. You already know how to do that in QML, while it's similar in Qt/C++. Therefore,
    just take it as an exercise and implement `Scroll Area` for this application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个新的成员函数，名为`resizeEvent`，它是从`QWidget`重写的。正如你所想象的那样，我们在小部件大小改变时更改了底层的`QImage`对象，这可能是由于窗口大小调整的结果。因此，我们只需将旧图像绘制到新图像上。如果新的大小小于之前的大小，这可能会导致图像的一部分丢失。你可能希望向`MainWindow`添加`Scroll
    Area`，并将`Canvas`作为`Scroll Area`的子小部件。你已经在QML中知道了如何做，而在Qt/C++中也是类似的。因此，只需将其视为练习，并为这个应用程序实现`Scroll
    Area`。
- en: Writing static plugins
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写静态插件
- en: 'There are two types of plugins: static and dynamic. Static plugins are statically
    linked to the executables, while the dynamic plugins are loaded at runtime. Dynamic
    plugins exist as the `.dll` or `.so` files, depending on the platform. Although
    the static plugins will be built as the `.lib` or `.a` files, they''ll be integrated
    into an executable file when the main program gets compiled.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 插件有两种类型：静态和动态。静态插件与可执行文件静态链接，而动态插件在运行时加载。动态插件以`.dll`或`.so`文件的形式存在，具体取决于平台。尽管静态插件将被构建为`.lib`或`.a`文件，但它们将在主程序编译时集成到可执行文件中。
- en: 'In this topic, we''ll get to know how to write a static plugin to extend the
    application. Serving as an external plugin, it gains the flexibility to change
    its internal code while it''s only required to keep the interface compatible.
    It''s up to you to decide whether the interface should be maintained in the main
    program or in different plugins. In this example, we''ll put the `interface.h`
    file in the main program, `painter_demo`. The content of `interface.h` is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将了解如何编写一个静态插件以扩展应用程序。作为外部插件，它获得了在保持接口兼容性的同时更改其内部代码的灵活性。是否在主程序或不同的插件中维护接口取决于您。在这个例子中，我们将`interface.h`文件放在主程序`painter_demo`中。`interface.h`的内容如下：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we declare a pure virtual class, `InsertInterface`. In order
    to avoid errors, you have to declare a virtual destructor. Otherwise, the compiler
    may complain and abort the compilation. The `QPainterPath` class provides a container
    for common 2D painting operations, including `ellipse` and `text`. Hence, the
    return type of `getObject` is `QPainterPath` ,which can be used directly where
    the argument, `QWidget`, could be useful if there is a newly created dialog to
    get any input from the user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们声明了一个纯虚类`InsertInterface`。为了避免错误，您必须声明一个虚析构函数。否则，编译器可能会抱怨并终止编译。`QPainterPath`类提供了一个用于常见2D绘图操作的容器，包括`ellipse`和`text`。因此，`getObject`的返回类型是`QPainterPath`，如果有一个新创建的对话框从用户那里获取任何输入，`QWidget`参数可以直接使用。
- en: At the end of this file, we declare `InsertInterface` as an interface by the
    `Q_DECLARE_INTERFACE` macro, where `InsertInterface_iid` is the identifier for
    the `InsertInterface` class. Note that the identifier must be unique, so it's
    recommended that you use a Java-style naming rule.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件的末尾，我们通过`Q_DECLARE_INTERFACE`宏将`InsertInterface`声明为一个接口，其中`InsertInterface_iid`是`InsertInterface`类的标识符。请注意，标识符必须是唯一的，因此建议您使用Java风格的命名规则。
- en: 'Now, we need to create a new project. Navigate to **Libraries** | **C++ Library**.
    Then, as shown in the following screenshot, select **Qt Plugin** for **Type**
    and keep this project inside the main program project folder for the sake of convenience
    or any concerns:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的项目。导航到**库** | **C++库**。然后，如以下截图所示，选择**Qt插件**作为**类型**，并为了方便或任何顾虑，将此项目放在主程序项目文件夹内：
- en: '![Writing static plugins](img/4615OS_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![编写静态插件](img/4615OS_05_03.jpg)'
- en: Click on **Next** and choose the same Qt kits as the `painter_demo` project.
    In this example, the `build` directory is set in the same directory as the `painter_demo`
    project, which is `D:\Projects\build`. Therefore, the `build` directory of `TextPlugin`
    is `D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Debug` and `D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Release`
    for `Debug` and `Release`, respectively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**并选择与`painter_demo`项目相同的Qt工具包。在这个例子中，`build`目录设置在与`painter_demo`项目相同的目录中，即`D:\Projects\build`。因此，`TextPlugin`的`build`目录为`D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Debug`和`D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Release`，分别对应`Debug`和`Release`。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Furthermore, you can change **Default build directory** in **Tools** | **Options**
    | **Build & Run** | **General**. In this book, we use `D:/Projects/build/%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}`
    so that all the builds are organized in one place.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在**工具** | **选项** | **构建和运行** | **常规**中更改**默认构建目录**。在这本书中，我们使用`D:/Projects/build/%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}`，以便将所有构建组织在一个地方。
- en: 'Then, fill in `TextPlugin` in the `Class name` field, as shown in the following
    screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`类名`字段中填写`TextPlugin`，如下面的截图所示：
- en: '![Writing static plugins](img/4615OS_05_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![编写静态插件](img/4615OS_05_04.jpg)'
- en: 'We need to apply some modifications to the `TextPlugin.pro` project file, as
    displayed here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`TextPlugin.pro`项目文件进行一些修改，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By adding widgets, we can use some useful classes such as `QMessageBox`. We
    also need to add `static` to `CONFIG` to declare this a static plugin project.
    Then, change the `DESTDIR` variable to `../plugins` so that the plugin is installed
    to the `plugins` directory outside the `build` folder. Lastly, we add the upper
    directory `../` to `INCLUDEPATH` so that we can include the `interface.h` header
    file in this subproject. The `textplugin.h` file is shown as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加小部件，我们可以使用一些有用的类，例如 `QMessageBox`。我们还需要将 `static` 添加到 `CONFIG` 中，以声明这是一个静态插件项目。然后，将
    `DESTDIR` 变量更改为 `../plugins`，以便插件安装到 `build` 文件夹外的 `plugins` 目录。最后，我们将上级目录 `../`
    添加到 `INCLUDEPATH` 中，以便我们可以在这个子项目中包含 `interface.h` 头文件。`textplugin.h` 文件如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use the `Q_PLUGIN_METADATA` macro to specify the unique `IID`, which is
    the same as the one we declared in `interface.h`, where `FILE "TextPlugin.json"`
    can be used to contain the metadata for this plugin. In this case, we just keep
    the `TextPlugin.json` file intact. Then, the `Q_INTERFACES` macro tells the compiler
    that this is a plugin for `InsertInterface`. In the `public` scope, there are
    just two reimplemented functions. Their definitions are located in the `textplugin.cpp`
    source file, whose content is pasted as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Q_PLUGIN_METADATA` 宏来指定唯一的 `IID`，它与我们在 `interface.h` 中声明的相同，其中 `FILE "TextPlugin.json"`
    可以用来包含此插件的元数据。在这种情况下，我们只是保留 `TextPlugin.json` 文件不变。然后，`Q_INTERFACES` 宏告诉编译器这是一个
    `InsertInterface` 的插件。在 `public` 范围内，只有两个重新实现的功能。它们的定义位于 `textplugin.cpp` 源文件中，其内容如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `name()` function simply returns the name of this plugin, which is `Text`
    in this case. As for `getObject`, it constructs a `QPainterPath` class that contains
    the text given by the user via a pop-up dialog, and then returns the `QPainterPath`
    object to the main program. The `addText` function will draw the text as a set
    of closed subpaths created from the font, while the first two arguments define
    the left end of the baseline for this text.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`name()` 函数简单地返回这个插件的名称，在这个例子中是 `Text`。至于 `getObject`，它构建一个包含用户通过弹出对话框提供的文本的
    `QPainterPath` 类，然后将 `QPainterPath` 对象返回给主程序。`addText` 函数将文本绘制为从字体创建的一组封闭子路径，而前两个参数定义了此文本基线的左端。'
- en: 'This is it for the plugin project. Now, just build it and you should expect
    a `libTextPlugin.a` file to be located under the `plugins` directory, while the
    `plugins` directory itself should be located in the parent directory of your project''s
    `build` folders, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 插件项目就到这里。现在，只需构建它，你应该期望在 `plugins` 目录下找到一个 `libTextPlugin.a` 文件，而 `plugins`
    目录本身应该位于项目 `build` 文件夹的父目录中，如图所示：
- en: '![Writing static plugins](img/4615OS_05_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![编写静态插件](img/4615OS_05_05.jpg)'
- en: It doesn't matter much if you put the files under other directories, although
    this means that you need to do some path modifications relevantly afterwards.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将文件放在其他目录下，这并不会影响太多，尽管这意味着你可能需要相应地进行一些路径修改。
- en: 'Now, let''s go back to the main program''s project, which is `painter_demo`
    in this example. Edit its `painter_demo.pro` project file and add the following
    line to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到主程序的项目，在这个例子中是 `painter_demo`。编辑它的 `painter_demo.pro` 项目文件，并向其中添加以下行：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The working directory during compilation is the `build` directory instead of
    the project source code directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程中的工作目录是 `build` 目录，而不是项目源代码目录。
- en: Then, edit `mainwindow.ui` in the **Design** mode; add a menu named `Plugins`
    to the menu bar, whose object name is `menuPlugins`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 **设计** 模式下编辑 `mainwindow.ui`；向菜单栏添加一个名为 `Plugins` 的菜单，其对象名为 `menuPlugins`。
- en: 'Among all the changes made in the main program, the modifications for the `MainWindow`
    class are maximum. Here is the code of the new `mainwindow.h` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序的所有更改中，对 `MainWindow` 类的修改最多。以下是新 `mainwindow.h` 文件的代码：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Still no clue about it? Well, its `mainwindow.cpp` source file is pasted here
    as well:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题还是毫无头绪？嗯，它的 `mainwindow.cpp` 源文件也粘贴在这里：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may have figured out that the `Q_IMPORT_PLUGIN` macro is used to import
    the plugin. Yes, it is, but only for static plugins. In the `loadPlugins()` function,
    we walked through all the static plugin instances and added them to the menu by
    invoking the `generatePluginMenu` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经弄清楚，`Q_IMPORT_PLUGIN` 宏用于导入插件。是的，是这样的，但仅限于静态插件。在 `loadPlugins()` 函数中，我们遍历了所有静态插件实例，并通过调用
    `generatePluginMenu` 函数将它们添加到菜单中。
- en: 'Plugins are treated as plain `QOjbect` objects at first, and then you can use
    `qobject_cast` to convert them to their own classes. The `qobject_cast` class
    will return a `NULL` pointer if it failed. Inside the `if` statement, there is
    a trick to use the plugin successfully later. Instead of calling a simplified
    and overloaded `addAction` function, we can construct `QAction` and add it to
    the menu, because `QAction` will have the plugin as its `QObject` parent. Therefore,
    you can see that we convert its parent to the relevant plugin class in the `onInsertInterface`
    function. Inside this function, we call the `insertPainterPath` function to paint
    the `QPainterPath` class returned by the plugin on `canvas`. Of course, we need
    to declare and define this function in the `Canvas` class. Add this statement
    to the `public` domain of the `canvas.h` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 插件最初被视为普通的`QOjbect`对象，然后您可以使用`qobject_cast`将它们转换为它们自己的类。如果`qobject_cast`类失败，它将返回一个`NULL`指针。在`if`语句中，有一个技巧可以在稍后成功使用插件。我们不是调用简化和重载的`addAction`函数，而是构造`QAction`并将其添加到菜单中，因为`QAction`将插件作为其`QObject`父对象。因此，您可以看到我们在`onInsertInterface`函数中将它的父对象转换为相关的插件类。在这个函数内部，我们调用`insertPainterPath`函数，将插件返回的`QPainterPath`类绘制到`canvas`上。当然，我们需要在`Canvas`类中声明和定义这个函数。将此语句添加到`canvas.h`文件的`public`域：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code''s definition in `canvas.cpp` is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码在`canvas.cpp`中的定义如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding statements should be familiar to you and they're also self-explanatory.
    Now, build and run this application again; don't forget to change the current
    active project back to `painter_demo` by right-clicking on the `painter_demo`
    project and selecting **Set "painter_demo" as Active Project**. When it runs,
    click on **Plugins**, select **Text**, input `Plugin!!` in the pop-up dialog,
    and confirm. Then, you'll see the text, **Plugin!!**, painted on the canvas as
    expected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句应该对您来说很熟悉，它们也是自我解释的。现在，再次构建并运行此应用程序；不要忘记通过右键单击`painter_demo`项目并选择**将"painter_demo"设置为活动项目**来将当前活动项目切换回`painter_demo`。当它运行时，点击**插件**，选择**文本**，在弹出对话框中输入`Plugin!!`，然后确认。然后，您将看到文本**Plugin!!**如预期地绘制在画布上。
- en: '![Writing static plugins](img/4615OS_05_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![编写静态插件](img/4615OS_05_06.jpg)'
- en: The executable's size grows as well because we statically linked our `TextPlugin`
    project file to it. In addition to this, you have to rebuild the main program
    if you changed the plugin. Otherwise, the newly generated plugin won't be linked
    to the executable as it should.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件的大小也会增加，因为我们将我们的`TextPlugin`项目文件静态链接到了它。此外，如果您更改了插件，您还必须重新构建主程序。否则，新生成的插件将不会像应该的那样链接到可执行文件。
- en: Writing dynamic plugins
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写动态插件
- en: Static plugins provide a convenient way to distribute your applications. However,
    this always requires a rebuild of the main program. By contrast, dynamic plugins
    are much more flexible since they're linked dynamically. This means the main project,
    which is `painter_demo` in this example, doesn't need to be built with dynamic
    plugins nor is it required to release its source code. Instead, it only needs
    to provide an interface and the header file of that interface, and then scan those
    dynamic plugins at runtime so that they can be loaded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 静态插件提供了一种方便的方式来分发您的应用程序。然而，这通常需要重新构建主程序。相比之下，动态插件由于它们是动态链接的，因此具有更大的灵活性。这意味着在本例中，主项目`painter_demo`不需要使用动态插件构建，也不需要发布其源代码。相反，它只需要提供一个接口及其头文件，然后在运行时扫描这些动态插件，以便它们可以被加载。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic plugins are commonly seen in complex applications, especially in commercial
    software such as Adobe Illustrator.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 动态插件在复杂应用程序中很常见，尤其是在像Adobe Illustrator这样的商业软件中。
- en: 'Similar to the static plugin we just wrote, we need to create a new Qt Plugin
    project and we''ll call it `EllipsePlugin` this time. Although you can write a
    new interface along with this plugin, here we will just focus on plugin-related
    topics. So, we just reuse the `InsertInterface` class while the `ellipseplugin.pro`
    project file is shown as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚刚编写的静态插件类似，我们需要创建一个新的 Qt 插件项目，这次我们将其命名为`EllipsePlugin`。虽然您可以在插件中编写新的接口，但在这里我们将只关注插件相关的话题。因此，我们只是重用了`InsertInterface`类，而`ellipseplugin.pro`项目文件如下所示：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Don't forget to change the `DESTDIR` and `INCLUDEPATH` variables in the `ellipseplugin.pro`
    file though, they're basically the same as the previous `TextPlugin` project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，不要忘记在`ellipseplugin.pro`文件中更改`DESTDIR`和`INCLUDEPATH`变量，它们基本上与之前的`TextPlugin`项目相同。
- en: 'Ignoring the source files, forms, and so on, it''s basically the same thing
    with only the removal of `static` in `CONFIG`. The `ellipseplugin.h` header file
    is shown as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略源文件、表单等，基本上是一样的，只是去掉了 `CONFIG` 中的 `static`。以下展示了 `ellipseplugin.h` 头文件：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see in the preceding code, we declare that this is a plugin using
    `InsertInterface` as the same in `TextPlugin`, whereas the difference is the declaration
    of an `onDialogAccepted` slot function and several `private` variables. Accordingly,
    the `ellipseplugin.cpp` file is shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们声明这是一个插件，使用 `InsertInterface` 作为与 `TextPlugin` 相同的方式，而不同之处在于声明了一个
    `onDialogAccepted` 插槽函数和几个 `private` 变量。因此，`ellipseplugin.cpp` 文件如下所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is nothing special about the `name()` function. By contrast, we use the
    `EllipseDialog` custom dialog to get some inputs from the user. Remember to connect
    all the signals and slots associated with the dialog before executing the `exec()`
    function; otherwise, the slots simply won't be connected. Also, note that the
    `exec()` function will block the event loop and return only after the dialog closes,
    which is pretty handy for our purposes because we can use the accepted values,
    such as `m_x` and `m_y`, to add an ellipse to `QPainterPath`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`name()` 函数没有特别之处。相比之下，我们使用 `EllipseDialog` 自定义对话框从用户那里获取一些输入。记住在执行 `exec()`
    函数之前连接与对话框相关的所有信号和槽；否则，槽将无法连接。还要注意，`exec()` 函数将阻塞事件循环，并且只有在对话框关闭后才会返回，这对于我们的目的来说非常方便，因为我们可以使用接受值，如
    `m_x` 和 `m_y`，来向 `QPainterPath` 添加椭圆。'
- en: 'As for the `EllipseDialog` custom dialog itself, it was created by adding a
    new Qt Designer Form Class via Qt Creator. Since it''s used to provide an interface
    for the user to specify some parameters, we use **Form Layout** in this dialog.
    Add `QLabel` and `QDoubleSpinBox`, as suggested in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `EllipseDialog` 自定义对话框本身，它是通过在 Qt Creator 中添加一个新的 Qt Designer 表单类创建的。由于它用于为用户提供指定一些参数的接口，我们在该对话框中使用了
    **表单布局**。按照以下截图中的建议添加 `QLabel` 和 `QDoubleSpinBox`：
- en: '![Writing dynamic plugins](img/4615OS_05_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![编写动态插件](img/4615OS_05_07.jpg)'
- en: Accordingly, their `objectName` values are `tlXLabel`, `tlXDoubleSpinBox`, `tlYLabel`,
    `tlYDoubleSpinBox`, `widthLabel`, `widthDoubleSpinBox`, `heightLabel`, and `heightDoubleSpinBox`.
    You should also change the `maximum` value to `9999.99` or something big enough
    in the **Property** panel of `QDoubleSpinBox`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们的 `objectName` 值分别是 `tlXLabel`、`tlXDoubleSpinBox`、`tlYLabel`、`tlYDoubleSpinBox`、`widthLabel`、`widthDoubleSpinBox`、`heightLabel`
    和 `heightDoubleSpinBox`。你还需要在 `QDoubleSpinBox` 的 `属性` 面板中将 `最大值` 改为 `9999.99`
    或更大的数值。
- en: 'In addition to this, also note that there is a removal of the default signal
    and slot in **Signals & Slots Editor**. Simply delete the `accepted()` signal
    pair of `buttonBox` because we need a more advanced handler. In this form class
    header file, `ellipsedialog.h`, we declare a new signal and a new slot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还要注意在 **信号与槽编辑器** 中移除了默认的信号和槽。只需删除 `buttonBox` 的 `accepted()` 信号对，因为我们需要一个更高级的处理程序。在这个表单类头文件
    `ellipsedialog.h` 中，我们声明了一个新的信号和一个新的槽：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `accepted(qreal, qreal, qreal, qreal)` signal here passes these values
    back to the plugin, while the `onAccepted()` slot handles the `accepted()` signal
    emitted from `buttonBox`. They are defined in the `ellipsedialog.cpp` source file,
    as shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里传递的 `accepted(qreal, qreal, qreal, qreal)` 信号将这些值传回插件，而 `onAccepted()` 插槽处理来自
    `buttonBox` 的 `accepted()` 信号。它们在 `ellipsedialog.cpp` 源文件中定义，如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inside the constructor, connect the `accepted()` signal of `buttonBox` to the
    `onAccepted()` advanced handler slot. In this slot, we emit the `accepted` signal,
    which contains the values that the user has entered. Then, call the `accept()`
    function to close this dialog.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，将 `buttonBox` 的 `accepted()` 信号连接到 `onAccepted()` 高级处理槽。在这个槽中，我们发出 `accepted`
    信号，其中包含用户输入的值。然后，调用 `accept()` 函数来关闭此对话框。
- en: '`EllipsePlugin` is finished at this point. Click on the **Build** button in
    the panel to build this project. You should expect the output, `EllipsePlugin.dll`
    on Windows, to be located in the same `plugins` directory as the previous `TextPlugin`
    project.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，`EllipsePlugin` 已完成。在面板中单击 **构建** 按钮来构建此项目。你应该期望输出，Windows 上的 `EllipsePlugin.dll`，位于与之前的
    `TextPlugin` 项目相同的 `plugins` 目录中。
- en: 'To make use of this dynamic plugin, we need a final step, which is to make
    the main program load the dynamic plugin(s). What we have to change here is the
    `loadPlugins()` function in `mainwindow.cpp`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个动态插件，我们需要一个最终步骤，即让主程序加载动态插件（s）。在这里我们需要更改的是`mainwindow.cpp`中的`loadPlugins()`函数：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to use the `QDir` class, you may also need to include this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`QDir`类，你可能还需要包含以下内容：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `QDir` class will provide access to directory structures and their contents,
    which we use to locate our dynamic plugins. The `qApp` macro is a global pointer,
    referring to this very application instance. It's equivalent to the `QCoreApplication::instance()`
    function and `QApplication::instance()` for non-GUI and GUI applications, respectively.
    On Windows platforms, our `plugins` directory is located in the second upper folder
    of the `build` path.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDir`类将提供对目录结构和其内容的访问，我们使用它来定位我们的动态插件。`qApp`宏是一个全局指针，指向这个应用程序实例。它对于非GUI和GUI应用程序分别等同于`QCoreApplication::instance()`函数和`QApplication::instance()`。在Windows平台上，我们的`plugins`目录位于`build`路径的第二上级目录。'
- en: Then, we just test each file in the `plugins` directory, load it, and generate
    a proper menu entry if it's a loadable plugin. Run this application again; you'll
    have an **Ellipse** entry inside the **Plugins** menu. It works as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需测试`plugins`目录中的每个文件，加载它，如果它是一个可加载的插件，就生成适当的菜单项。再次运行此应用程序；你将在**插件**菜单中看到一个**椭圆**条目。它按预期工作。
- en: '![Writing dynamic plugins](img/4615OS_05_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![编写动态插件](img/4615OS_05_08.jpg)'
- en: Merging plugins and main program projects
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并插件和主程序项目
- en: It is a tedious thing that opens several projects and builds them in order.
    This is not a big deal given that we have just two plugins and a main program.
    However, it'll become a serious inefficiency issue once the number of plugins
    increase. Therefore, it is a better practice to merge the plugins into the main
    project and get them built in a specified order every time we click on the **Build**
    button. It's totally feasible and is commonly seen in Qt projects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开几个项目并按顺序构建它们是一件繁琐的事情。鉴于我们只有两个插件和一个主程序，这并不是什么大问题。然而，一旦插件数量增加，这将成为一个严重的效率问题。因此，将插件合并到主项目中，并在每次点击**构建**按钮时按指定顺序构建它们，是一种更好的做法。这在Qt项目中是完全可行的，并且很常见。
- en: Firstly, we move all the files in the `painter_demo` directory, except for the
    `EllipsePlugin` and `TextPlugin` folders, into a newly created `main` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`painter_demo`目录中的所有文件（除了`EllipsePlugin`和`TextPlugin`文件夹）移动到一个新创建的`main`文件夹中。
- en: 'Then, rename the `painter_demo.pro` to `main.pro` in the `main` folder while
    creating a new `painter_demo.pro` project file outside in the `painter_demo` directory.
    This new `painter_demo.pro` project file needs to have contents as shown in the
    following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`文件夹中，将`painter_demo.pro`重命名为`main.pro`，同时在`painter_demo`目录外创建一个新的`painter_demo.pro`项目文件。这个新的`painter_demo.pro`项目文件需要包含以下代码所示的内容：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `subdirs` project is a special template, which means that this project file
    won't generate an application or a library. Instead, it tells `qmake` to build
    subdirectories. By adding `ordered` to `CONFIG`, we can ensure that the compiling
    process follows the exact order according to `SUBDIRS`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`subdirs`项目是一个特殊的模板，这意味着这个项目文件不会生成应用程序或库。相反，它告诉`qmake`构建子目录。通过将`ordered`添加到`CONFIG`中，我们可以确保编译过程按照`SUBDIRS`中的确切顺序进行。'
- en: 'To accomplish this, we need to modify the project files in the two plugins
    directories. Change the `INCLUDEPATH` variable to the following line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们需要修改两个插件目录中的项目文件。将`INCLUDEPATH`变量更改为以下行：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This change is obvious because we moved all the source code into the `main`
    directory. If we don't change `INCLUDEPATH`, the compiler will complain that it
    can't find the `interface.h` header file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改很明显，因为我们已经将所有源代码移动到了`main`目录。如果我们不更改`INCLUDEPATH`，编译器将抱怨找不到`interface.h`头文件。
- en: Creating a C++ plugin for QML applications
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为QML应用程序创建C++插件
- en: It's not too difficult to write a plugin for Qt/C++ applications, whereas it's
    somewhat more complex to create a plugin for the QML applications. The idea is
    the same, and here we will use a very basic example to demonstrate this topic.
    Basically, this application will encode the text input as `Base64` and display
    it. The `Base64` encoding part is implemented in the C++ plugin.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为Qt/C++应用程序编写插件并不太难，而创建QML应用程序的插件则稍微复杂一些。思路是相同的，在这里我们将使用一个非常基本的示例来演示这个主题。基本上，这个应用程序将文本输入编码为`Base64`并显示出来。`Base64`编码部分是在C++插件中实现的。
- en: 'This time, we''re going to create the plugin project first, and then complete
    the QML part. Creating a plugin project for a QML application shares the same
    procedure. Navigate to **Libraries** | **C++ Library**, and then select **Qt Plugin**
    with the name as `Base64Plugin`. Its project file, `Base64Plugin.pro`, is pasted
    here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将首先创建插件项目，然后完成QML部分。为QML应用程序创建插件项目遵循相同的步骤。导航到**库** | **C++库**，然后选择名为`Base64Plugin`的**Qt插件**。其项目文件`Base64Plugin.pro`如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We set `DESTDIR` to `../imports/Base64` for the sake of convenience. You can
    change this to some other path, but you may need to make some relevant changes
    later to be able to import this plugin.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`DESTDIR`设置为`../imports/Base64`以方便起见。你可以将其更改为其他路径，但可能需要稍后进行一些相关更改才能导入此插件。
- en: 'This project consists of two C++ classes. The `Base64` class will later be
    exported to QML, whereas `Base64Plugin` registers the `Base64` class. The former
    class'' `base64.h` header file is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目由两个C++类组成。`Base64`类将被导出到QML中，而`Base64Plugin`注册`Base64`类。前者的`base64.h`头文件如下所示：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `base.cpp` counterpart defines the `get` function, as shown in the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`base.cpp`的对应部分定义了`get`函数，如下所示：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The tricky part is in the `Base64Plugin` class, which is not identical to the
    previous plugin class. Its `base64plugin.h` header file is shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的部分在`Base64Plugin`类中，它与之前的插件类不完全相同。其`base64plugin.h`头文件如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the `QQmlExtensionPlugin` subclass, we''re able to write our own QML plugin.
    In fact, this class is used to declare the `Base64` class for QML. Also note that
    since `IID` in `Q_PLUGIN_METADATA` is fixed, you probably don''t want to change
    it. As a subclass, it has to reimplement the `registerTypes` function, which simply
    registers the class(es). The detailed definition is located in the `baseplugin.cpp`
    file whose contents are as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`QQmlExtensionPlugin`子类，我们可以编写自己的QML插件。实际上，这个类用于声明QML中的`Base64`类。还请注意，由于`Q_PLUGIN_METADATA`中的`IID`是固定的，你可能不想更改它。作为一个子类，它必须重新实现`registerTypes`函数，该函数简单地注册类。详细的定义位于`baseplugin.cpp`文件中，其内容如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Q_ASSERT` macro will ensure that the plugin is located inside the `Base64`
    directory. If not, it'll print a warning message containing the source code, filename,
    and line number. Note that `uri`, which is expected to be `Base64` in this case,
    is the module name for QML. Below this line, `qmlRegisterType` is a template function
    where you need to put the class name, `Base64`, inside brackets. These arguments
    will register the class with `Base64` as the QML name with Version 1.0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_ASSERT`宏将确保插件位于`Base64`目录内。如果不是，它将打印包含源代码、文件名和行号的警告信息。请注意，在此情况下预期的`uri`是`Base64`，它是QML的模块名。在这行下面，`qmlRegisterType`是一个模板函数，其中你需要将类名`Base64`放在括号内。这些参数将使用版本1.0将类注册为具有`Base64`
    QML名称。'
- en: 'A last piece is needed to declare a loadable plugin, which is the `qmldir`
    file. Note that it has no extension name. This file defines the module name and
    relevant files in the directory. Here is the content:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还需要一个声明可加载插件的文件，即`qmldir`文件。请注意，它没有扩展名。此文件定义了模块名和目录中的相关文件。以下是内容：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We need to put this file in the `../imports/Base64` directory, which is the
    `DESTDIR` of `Base64Plugin`. Along with a few lines in the QML application project's
    `main.cpp` file, QML can then import a plugin as it imports any other Qt Quick
    modules.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将此文件放在`../imports/Base64`目录中，这是`Base64Plugin`的`DESTDIR`。在QML应用程序项目的`main.cpp`文件中的几行代码之后，QML就可以像导入任何其他Qt
    Quick模块一样导入插件。
- en: 'It''s time to create a new Qt Quick application project now. The project name
    is simply `QML_Plugin` and we move the `Base64Plugin` class into the `QML_Plugin`
    directory, which enables the Qt Creator syntax to highlight the `Base64Plugin`
    class. Here is the content of `main.qml`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个新的Qt Quick应用程序项目了。项目名称简单地是`QML_Plugin`，我们将`Base64Plugin`类移动到`QML_Plugin`目录中，这样Qt
    Creator就能突出显示`Base64Plugin`类。以下是`main.qml`的内容：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember to state `import Base64 1.0` at the very beginning of the code so that
    our plugin can be loaded. Then, `Base64` is just like other QML types we have
    used before. In the `onEditingFinished` handler of `input TextField`, we use the
    `get` function, which is in the `Base64` class, to set `bt.text` to the corresponding
    `Base64` class-encoded string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在代码开头声明`import Base64 1.0`，以便我们的插件可以被加载。然后，`Base64`就像我们之前使用过的其他QML类型一样。在`input
    TextField`的`onEditingFinished`处理程序中，我们使用`Base64`类中的`get`函数，将`bt.text`设置为相应的`Base64`类编码字符串。
- en: You may wonder how a QML `string` type is converted to a `QString` object. Well,
    it's implicitly converted between QML and Qt/C++. There are plenty of these conversions
    for commonly-seen QML data types and Qt data classes. For details, you can look
    at the Qt documentation to see the full list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何将QML的`string`类型转换为`QString`对象。嗯，在QML和Qt/C++之间是隐式转换的。对于常见的QML数据类型和Qt数据类，有很多这样的转换。有关详细信息，您可以查看Qt文档以查看完整列表。
- en: 'Another thing is that we need to change `main.cpp`, as mentioned before. Similar
    to the Qt/C++ case, we use the `QDir` class to get an application directory and
    change it to `../imports`. Be aware that you should use `addImportPath` instead
    of `addPluginPath` to add `../imports` to the QML engine''s module search path.
    This is because we use `Base64` as a module, which should be located in the `imports`
    path. Meanwhile, the plugin path is for native plugins of imported modules, which
    are stated in `qmldir`. The content of the `main.cpp` file is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是我们需要更改`main.cpp`，如前所述。类似于Qt/C++的情况，我们使用`QDir`类来获取应用程序目录并将其更改为`../imports`。请注意，您应该使用`addImportPath`而不是`addPluginPath`来将`../imports`添加到QML引擎的模块搜索路径。这是因为我们使用`Base64`作为模块，它应该位于`imports`路径。同时，插件路径是用于导入模块的本地插件，这些插件在`qmldir`中声明。`main.cpp`文件的内容如下：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to run this application, perform the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此应用程序，请执行以下步骤：
- en: Build `Base64Plugin`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`Base64Plugin`。
- en: Copy the `qmldir` file into the `../imports/Base64` directory (the `imports`
    folder should be located in the same place as `plugins`).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`qmldir`文件复制到`../imports/Base64`目录（`imports`文件夹应位于与`plugins`相同的目录中）。
- en: Build and run the `QML_Plugin` project.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行`QML_Plugin`项目。
- en: 'You can test this application by inputting any string in the first input field
    and just pressing *Enter*. One scenario for this application is to encode your
    e-mail address to avoid a web spider, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在第一个输入字段中输入任何字符串并仅按*Enter*键来测试此应用程序。此应用程序的一个场景是将您的电子邮件地址编码以避免网络爬虫，如下所示：
- en: '![Creating a C++ plugin for QML applications](img/4615OS_05_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![为QML应用程序创建C++插件](img/4615OS_05_09.jpg)'
- en: If the module isn't well located, the application won't show up and it'll complain
    that `Base64` is not installed. If that happens, make sure you add the correct
    path in `main.cpp` and there is a `qmldir` file inside the `Base64` folder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块没有正确放置，应用程序将不会显示，并且会抱怨`Base64`未安装。如果发生这种情况，请确保在`main.cpp`中添加正确的路径，并且在`Base64`文件夹内有一个`qmldir`文件。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It is somewhat difficult to get started on writing plugins. However, after some
    basic practice, you'll find that it's actually easier than it looks. For Qt Widgets
    applications, plugins simply extend the application in a flexible way. Meanwhile,
    they enable developers to devise new forms for QML applications. We also covered
    using the `subdirs` project to manage multiple subprojects. Even if you don't
    plan to write plugins, this chapter covered painting-related stuff that is crucial
    for GUI application development, including `QPainter`, `paintEvent`, and `resizeEvent`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写插件有些困难。然而，经过一些基本实践后，你会发现它实际上比看起来容易。对于Qt Widgets应用程序，插件以灵活的方式扩展应用程序。同时，它们使开发者能够为QML应用程序设计新的形式。我们还介绍了使用`subdirs`项目来管理多个子项目。即使您不打算编写插件，本章也涵盖了对于GUI应用程序开发至关重要的绘画相关内容，包括`QPainter`、`paintEvent`和`resizeEvent`。
- en: In the next chapter, we're going to talk about network programming and multithreading
    in Qt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Qt中的网络编程和多线程。
