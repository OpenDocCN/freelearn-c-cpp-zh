- en: Appendix A. Rational and Complex Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Appendix defines the `Rational` and `Complex` classes from the *Converters*
    section in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Rational numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **rational** **number** can be expressed as a fraction of two integers, called
    the **numerator** and **denominator**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rational.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor initializes the numerator and denominator to 0 and
    1, respectively. The second constructor takes a string and throws a `NotaRationalNumber`
    exception if the string does not hold a valid rational number. The copy constructor
    and the assignment operator take another rational number. The `String` conversion
    operator returns the rational number as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A rational number is always normalized when it has been created by the constructor
    or any of the arithmetic operators: the numerator and the denominator are divided
    by their **Greatest Common Divisor** (**GCD**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Rational.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor initializes the numerator and the denominator, and
    throws an exception if the denominator is zero. This constructor and the next
    constructor that takes a string are actually the only places where the denominator
    can be zero. The following constructors and arithmetic operators always produce
    a rational number with non-zero denominators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Text can hold a rational number in two formats: as an integer followed by a
    slash (**/**) and another integer, or as a single integer. We start by initializing
    the numerator and the denominator to 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we try two integers and a slash; we read the numerator, slash, and denominator.
    Before the slash we set the `skipws` flag, which causes the stream to skip any
    potential white spaces before the slash. If we have reached the end of the line,
    the denominator is not 0, the character read into the `slash` variable really
    is a slash, the text holds a rational number, and we have read the numerator and
    denominator, then we are done and we return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If using two integers and a slash does not work, we try the case of a single
    integer. We create a new stream and read the numerator. If we have reached the
    end of the stream after that, the string holds a valid integer. We let the numerator
    hold its initialized value, which was 1, and return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If two integers and a slash as well as a single integer both failed, we have
    to draw the conclusion that the string does not hold a valid rational number,
    and we throw a `NotaRationalNumber` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The copy constructor simply copies the numerator and denominator of the rational
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment operator also copies the numerator and denominator of the rational
    number and returns its own `Rational` object (`*this`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `String` conversion operator creates an `OStringStream` object and looks
    into the denominator. If it is 1, the rational number can be expressed as a single
    integer; otherwise, it needs to be expressed as a fraction of the numerator and
    denominator. Finally, the stream is converted into a string that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As rational numbers are always normalized, we can conclude that two rational
    numbers are equal if they have the same numerator and denominator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When deciding whether a rational number is smaller than another rational number,
    in order not to involve floating values, we multiply both sides by the denominator
    and compare the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rational numbers](img/B05475_Appendix_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding two rational numbers, we multiply the numerator by the opposite
    denominator in each term:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rational numbers](img/B05475_Appendix_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When subtracting two rational numbers, we also multiply the numerator by the
    opposite denominator in each term:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rational numbers](img/B05475_Appendix_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When multiplying two rational numbers, we simply multiply the numerators and
    denominators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rational numbers](img/B05475_Appendix_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When dividing two rational numbers, we invert the second operand and then multiply
    the numerators and denominators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rational numbers](img/B05475_Appendix_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When normalizing the rational number, we first look into the numerator. If
    it is 0, we set the denominator to 1 regardless of its previous value and return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the numerator is not 0, we look into the denominator. If it is
    less than 0, we switch the sign of both the numerator and denominator so that
    the denominator is always greater than 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we calculate the Greatest Common Divisor by calling `GCD`, and then we
    divide both the numerator and denominator by the Greatest Common Divisor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `GCD` method calls itself recursively by comparing the numbers and subtracting
    the smaller number from the larger number. When they are equal, we return the
    number. The GCD algorithm is regarded as the world's oldest non-trivial algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **complex** **number** *z* = *x* + *yi* is the sum of a real number *x* and
    a real number *y* multiplied by the **imaginary unit** *i*, *i* ² = -1 ⇒ *i* =
    ±√(-1) , which is the solution of the equation *x* ² + 1 = 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors, assignment operators, and the `String` conversion operator
    are similar to their counterparts in `Rational`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When comparing two complex number, their absolute values (refer to `Abs`) are
    compared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The arithmetic operators apply to complex numbers and double values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The absolute value of a complex number (and its value converted to a `double`)
    is the Pythagoras theorem of the real and imaginary part, that is, the square
    root of the sum of the squares of the parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Complex.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When interpreting a text holding a rational number, we read the text from a
    stream, and we need some auxiliary functions to start with. The `ReadWhiteSpaces`
    method reads (and disposes of) all white spaces at the beginning of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Peek` method reads the white spaces and returns the zero character (\0)
    if it has reached the end of the stream. If not, we look into what comes next
    in the stream by calling `peek`, and return its resulting value. Note that `peek`
    does not consume the character from the stream; it just checks out the next character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadI` method verifies whether the next character in the stream is **i**
    or **I**. If it is, it reads the character from the stream and returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadSign` method verifies that the next character in the stream is a plus
    or minus sign. If it is, it reads the character from the stream, sets the sign
    parameter to **+** or **-**, and returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadValue` method verifies that the next two characters in the stream
    are a plus or a minus sign followed by a digit or a dot, or whether the first
    character is a digit or a dot. If the latter is the case, it reads the `value`
    parameter from the beginning of the stream and returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EndOfLine` method simply returns `true` if the next character in the stream
    is the zero character (\0), in which case we have reached the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to interpret a string as a rational number. We have the following
    ten cases, where *x* and *y* are real values, *i* is the imaginary unit, and ±
    is plus or minus. All ten cases represent valid complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* ± *yi*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* ± ±*i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* ± *i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*yi* ± *x*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ±*i* ± *x*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*i* ± *x*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*yi*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ±*i*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ReadStream` method creates an input stream from the text and tries to
    interpret it as one of the preceding ten cases. The idea is that we read the stream
    and try one part of the potential complex number at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the stream is made up of a value, a sign, another value, and i or I, we
    set *x* and *y* in accordance with case 1 (*x* ± *yi*) and return `true`. The
    *y* field is negative if the sign is minus. However, the second value may also
    be negative, in which case *y*is positive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the sign is not followed by a value, but by another sign and i or I, case
    2 (*x* ± ±*i*) applies and we return `true`. In this case, we actually have to
    adjust the value of *y* twice in accordance with both signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the sign is not followed by a value or another sign, but by i or I, case
    3 (*x* ± *i*) applies and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is not followed by a sign but by i or I, another sign, and another
    value, case 4 (*yi* ± *x*) applies and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is followed by i or I and nothing else, case 7 (*yi*) applies
    and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is followed by nothing else, case 10 (*x*) applies and we return
    `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the stream does not start with a value, but with a sign followed by i or
    I, another sign and another value, case 5 (±*i* ± *x*) applies and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If the stream starts with a sign followed by i or I and nothing else, case
    8 (±*i*) applies and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the stream does not start with a value or a sign, but with i or I followed
    by a sign and a value, case 6 (*i* ± *x*) applies and we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the stream is made up by i or I and nothing else, case 9 (*i*) applies and
    we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if none of the above cases apply, the text does not hold a complex
    number and we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor that takes a text simply calls `ReadStream` and throws a `NotaComplexNumber`
    exception if `ReadStream` returns `false`. However, if `ReadStream` returns `true`,
    *x* and *y* are set to the appropriate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `String` conversion operator, we look into several different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* + *i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* - *i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* ± *i*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: +*i*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: -*i*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*yi*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '0'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the real part *x* is not 0, we write its value on the stream and look into
    the first four cases with regard to the imaginary part, *y*. If *y* is plus or
    minus 1, we simply write `+i` or `-i`. If it is not plus or minus 1, and not 0,
    we write its value with the `showpos` flag, which forces the plus sign to be present
    in the case of a positive value. Finally, if *y* is 0, we do not write it at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If *x* is zero, we omit it and write the value of *y* in the same manner as
    we did earlier. However, if *y* is zero, we write 0; otherwise, nothing will be
    written if both *x* and *y* are 0\. Moreover, we omit the `showpos` flag, since
    it is not necessary to write the plus sign in the case of a positive value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Two complex numbers are equal if their real and imaginary parts are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When deciding whether a complex number is smaller than another complex number,
    we chose to compare their absolute values, which is given by the `Abs` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The addition operators all call the following final operator, which works for
    all four arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding two complex numbers, we add the real and imaginary parts separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When subtracting two complex numbers, we subtract the real and imaginary parts
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The product of two complex numbers can be established by some algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: (*x* [1] + *y* [1]*i*)(*x* [2] + *y[2]i*) = *x* [1]*x* [2] + *x* [1]*y* [2]*i*
    + *y* [1]*ix* [2] + *y* [1]*y* [2]*i* ² = *x* [1]*x* [2] + *x* [1]*y* [2]*i* +
    *y* [1]*ix* [2] *+ y* [1]*y* [2] (-1) = *x* [1]*x* [2] + *x* [1]*y* [2]*i* + *x*
    [2]*y* [1]*i* - *y* [1]*y* [2] = (*x* [1]*x* [2] - *y* [1]*y* [2]) + (*x* [1]*y*
    [2] + *x* [2]*y* [1])*i*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The quotient between two complex numbers can also be established by some algebra.
    The **conjugate** of a complex number *x* [2] + *y* [2]*i* is *x* [2] - *y* [2]*i*,
    which we can use in the conjugate rule:'
  prefs: []
  type: TYPE_NORMAL
- en: (*x* [2]+ *y* [2]*i*)(*x* [2] - *y* [2]*i*) = *x* [2]² - *x* [2]*y* [2]*i* +
    *x* [2]*y* [2]*i* - *y* [2]² (-1) = *x* [2]² - *x* [2]*y* [2]*i* + *x* [2]*y*
    [2]*i* + *y* [2]² = *x* [2]² + *y* [2]²
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the conjugate rule when dividing two complex numbers by multiplying
    the conjugate by both the numerator and the denominator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex numbers](img/B05475_Appendix_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By reading this book you have learned how to develop applications in Windows
    with Small Windows, a C++ object-oriented class library for graphical applications
    in Windows. I hope you have enjoyed the book!
  prefs: []
  type: TYPE_NORMAL
