- en: Appendix A. Rational and Complex Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 有理数和复数
- en: This Appendix defines the `Rational` and `Complex` classes from the *Converters*
    section in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录定义了来自前一章*转换器*部分的`Rational`和`Complex`类。
- en: Rational numbers
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有理数
- en: A **rational** **number** can be expressed as a fraction of two integers, called
    the **numerator** and **denominator**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**有理数**可以表示为两个整数的分数，称为**分子**和**分母**。'
- en: '**Rational.h**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rational.h**'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The default constructor initializes the numerator and denominator to 0 and
    1, respectively. The second constructor takes a string and throws a `NotaRationalNumber`
    exception if the string does not hold a valid rational number. The copy constructor
    and the assignment operator take another rational number. The `String` conversion
    operator returns the rational number as a string:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将分子和分母分别初始化为0和1。第二个构造函数接受一个字符串，如果字符串不包含有效的有理数则抛出`NotaRationalNumber`异常。复制构造函数和赋值运算符接受另一个有理数。`String`转换运算符将有理数作为字符串返回：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A rational number is always normalized when it has been created by the constructor
    or any of the arithmetic operators: the numerator and the denominator are divided
    by their **Greatest Common Divisor** (**GCD**):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当有理数是通过构造函数或任何算术运算符创建时，它总是被规范化：分子和分母被它们的**最大公约数**（**GCD**）除以：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Rational.cpp**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rational.cpp**'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The default constructor initializes the numerator and the denominator, and
    throws an exception if the denominator is zero. This constructor and the next
    constructor that takes a string are actually the only places where the denominator
    can be zero. The following constructors and arithmetic operators always produce
    a rational number with non-zero denominators:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数初始化分子和分母，如果分母为零则抛出异常。实际上，这个构造函数以及下一个接受字符串的构造函数是唯一可能分母为零的地方。以下构造函数和算术运算符总是产生分母非零的有理数：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Text can hold a rational number in two formats: as an integer followed by a
    slash (**/**) and another integer, or as a single integer. We start by initializing
    the numerator and the denominator to 0 and 1:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以以两种格式存储有理数：作为整数后跟一个斜杠（**/**）和另一个整数，或者作为一个单独的整数。我们首先将分子和分母初始化为0和1：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we try two integers and a slash; we read the numerator, slash, and denominator.
    Before the slash we set the `skipws` flag, which causes the stream to skip any
    potential white spaces before the slash. If we have reached the end of the line,
    the denominator is not 0, the character read into the `slash` variable really
    is a slash, the text holds a rational number, and we have read the numerator and
    denominator, then we are done and we return:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试两个整数和一个斜杠；我们读取分子、斜杠和分母。在斜杠之前设置`skipws`标志，这将导致流在斜杠之前跳过任何潜在的空白字符。如果我们到达行的末尾，分母不是0，读取到`slash`变量的字符确实是斜杠，文本包含一个有理数，并且我们已经读取了分子和分母，那么我们就完成了，并返回：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If using two integers and a slash does not work, we try the case of a single
    integer. We create a new stream and read the numerator. If we have reached the
    end of the stream after that, the string holds a valid integer. We let the numerator
    hold its initialized value, which was 1, and return.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用两个整数和一个斜杠不起作用，我们尝试单个整数的情形。我们创建一个新的流并读取分子。如果我们读取之后到达流的末尾，该字符串包含一个有效的整数。我们让分子保持其初始化的值，即1，并返回。
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If two integers and a slash as well as a single integer both failed, we have
    to draw the conclusion that the string does not hold a valid rational number,
    and we throw a `NotaRationalNumber` exception:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个整数以及一个斜杠和一个单独的整数都失败了，我们必须得出结论，该字符串不包含有效的有理数，并且我们抛出`NotaRationalNumber`异常：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The copy constructor simply copies the numerator and denominator of the rational
    number:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数只是复制有理数的分子和分母：
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The assignment operator also copies the numerator and denominator of the rational
    number and returns its own `Rational` object (`*this`):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符也会复制有理数的分子和分母，并返回其自己的`Rational`对象（`*this`）：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `String` conversion operator creates an `OStringStream` object and looks
    into the denominator. If it is 1, the rational number can be expressed as a single
    integer; otherwise, it needs to be expressed as a fraction of the numerator and
    denominator. Finally, the stream is converted into a string that is returned:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`转换运算符创建一个`OStringStream`对象并查看分母。如果它是1，有理数可以表示为一个单独的整数；否则，它需要表示为分子和分母的分数。最后，流被转换为返回的字符串：'
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As rational numbers are always normalized, we can conclude that two rational
    numbers are equal if they have the same numerator and denominator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有理数总是规范化，我们可以得出结论，如果两个有理数的分子和分母相同，则它们相等：
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When deciding whether a rational number is smaller than another rational number,
    in order not to involve floating values, we multiply both sides by the denominator
    and compare the products:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定一个有理数是否小于另一个有理数时，为了避免涉及浮点值，我们将两边都乘以分母并比较乘积：
- en: '![Rational numbers](img/B05475_Appendix_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![有理数](img/B05475_Appendix_01.jpg)'
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When adding two rational numbers, we multiply the numerator by the opposite
    denominator in each term:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个有理数相加时，我们也在每个项中乘以相反的分母：
- en: '![Rational numbers](img/B05475_Appendix_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![有理数](img/B05475_Appendix_02.jpg)'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When subtracting two rational numbers, we also multiply the numerator by the
    opposite denominator in each term:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当减去两个有理数时，我们也在每个项中乘以相反的分母：
- en: '![Rational numbers](img/B05475_Appendix_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![有理数](img/B05475_Appendix_03.jpg)'
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When multiplying two rational numbers, we simply multiply the numerators and
    denominators:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个有理数相乘时，我们简单地乘以分子和分母：
- en: '![Rational numbers](img/B05475_Appendix_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![有理数](img/B05475_Appendix_04.jpg)'
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When dividing two rational numbers, we invert the second operand and then multiply
    the numerators and denominators:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当除以两个有理数时，我们首先取第二个操作数的倒数，然后乘以分子和分母：
- en: '![Rational numbers](img/B05475_Appendix_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![有理数](img/B05475_Appendix_05.jpg)'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When normalizing the rational number, we first look into the numerator. If
    it is 0, we set the denominator to 1 regardless of its previous value and return:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当规范化有理数时，我们首先查看分子。如果它是 0，则无论其之前的值如何，我们都将其分母设置为 1 并返回：
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, if the numerator is not 0, we look into the denominator. If it is
    less than 0, we switch the sign of both the numerator and denominator so that
    the denominator is always greater than 0:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果分子不是 0，我们查看分母。如果它小于 0，则我们交换分子和分母的符号，使分母始终大于 0：
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we calculate the Greatest Common Divisor by calling `GCD`, and then we
    divide both the numerator and denominator by the Greatest Common Divisor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用 `GCD` 来计算最大公约数，然后将分子和分母都除以最大公约数：
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `GCD` method calls itself recursively by comparing the numbers and subtracting
    the smaller number from the larger number. When they are equal, we return the
    number. The GCD algorithm is regarded as the world's oldest non-trivial algorithm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`GCD` 方法通过比较数字并从较大的数字中减去较小的数字来递归调用自身。当它们相等时，我们返回该数字。GCD 算法被认为是世界上最早的非平凡算法。'
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Complex numbers
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: A **complex** **number** *z* = *x* + *yi* is the sum of a real number *x* and
    a real number *y* multiplied by the **imaginary unit** *i*, *i* ² = -1 ⇒ *i* =
    ±√(-1) , which is the solution of the equation *x* ² + 1 = 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **复数** *z* = *x* + *yi* 是一个实数 *x* 和一个实数 *y* 乘以 **虚数单位** *i* 的和，*i* ² = -1
    ⇒ *i* = ±√(-1) ，这是方程 *x* ² + 1 = 0 的解。
- en: '**Complex.h**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Complex.h**'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The constructors, assignment operators, and the `String` conversion operator
    are similar to their counterparts in `Rational`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数、赋值运算符和 `String` 转换运算符与 `Rational` 中的对应项类似：
- en: '[PRE23]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When comparing two complex number, their absolute values (refer to `Abs`) are
    compared.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个复数时，比较它们的绝对值（参考 `Abs`）。
- en: '[PRE24]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The arithmetic operators apply to complex numbers and double values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符适用于复数和双精度值：
- en: '[PRE25]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The absolute value of a complex number (and its value converted to a `double`)
    is the Pythagoras theorem of the real and imaginary part, that is, the square
    root of the sum of the squares of the parts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的绝对值（及其转换为 `double` 的值）是实部和虚部的毕达哥拉斯定理，即各部分平方和的平方根：
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Complex.cpp**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Complex.cpp**'
- en: '[PRE27]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When interpreting a text holding a rational number, we read the text from a
    stream, and we need some auxiliary functions to start with. The `ReadWhiteSpaces`
    method reads (and disposes of) all white spaces at the beginning of the stream:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释包含有理数的文本时，我们从流中读取文本，并且我们需要一些辅助函数来开始。`ReadWhiteSpaces` 方法读取（并处理）流开头的所有空白：
- en: '[PRE28]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Peek` method reads the white spaces and returns the zero character (\0)
    if it has reached the end of the stream. If not, we look into what comes next
    in the stream by calling `peek`, and return its resulting value. Note that `peek`
    does not consume the character from the stream; it just checks out the next character:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Peek` 方法读取空白字符并在达到流末尾时返回零字符 (\0)。如果没有，我们通过调用 `peek` 来查看流中的下一个内容，并返回其结果值。请注意，`peek`
    不会消耗流中的字符；它只是检查下一个字符：'
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `ReadI` method verifies whether the next character in the stream is **i**
    or **I**. If it is, it reads the character from the stream and returns `true`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadI` 方法验证流中的下一个字符是否为 **i** 或 **I**。如果是，它从流中读取字符并返回 `true`：'
- en: '[PRE30]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ReadSign` method verifies that the next character in the stream is a plus
    or minus sign. If it is, it reads the character from the stream, sets the sign
    parameter to **+** or **-**, and returns `true`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadSign` 方法验证流中的下一个字符是加号或减号。如果是，它从流中读取字符，将符号参数设置为 **+** 或 **-**，并返回 `true`：'
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `ReadValue` method verifies that the next two characters in the stream
    are a plus or a minus sign followed by a digit or a dot, or whether the first
    character is a digit or a dot. If the latter is the case, it reads the `value`
    parameter from the beginning of the stream and returns `true`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadValue` 方法验证流中的下一个两个字符是加号或减号后跟数字或点，或者第一个字符是数字或点。如果是后者，它从流的开始读取 `value`
    参数并返回 `true`：'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `EndOfLine` method simply returns `true` if the next character in the stream
    is the zero character (\0), in which case we have reached the end of the string:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndOfLine` 方法简单地返回 `true`，如果流中的下一个字符是零字符 (\0)，在这种情况下，我们已经到达了字符串的末尾：'
- en: '[PRE33]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we are ready to interpret a string as a rational number. We have the following
    ten cases, where *x* and *y* are real values, *i* is the imaginary unit, and ±
    is plus or minus. All ten cases represent valid complex numbers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将字符串解释为有理数。我们有以下十种情况，其中 *x* 和 *y* 是实数，*i* 是虚数单位，± 是加号或减号。所有十种情况都代表有效的复数：
- en: '*x* ± *yi*'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* ± *yi*'
- en: '*x* ± ±*i*'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* ± ±*i*'
- en: '*x* ± *i*'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* ± *i*'
- en: '*yi* ± *x*'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*yi* ± *x*'
- en: ±*i* ± *x*
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ±*i* ± *x*
- en: '*i* ± *x*'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*i* ± *x*'
- en: '*yi*'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*yi*'
- en: ±*i*
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ±*i*
- en: '*i*'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*i*'
- en: '*x*'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*'
- en: 'The `ReadStream` method creates an input stream from the text and tries to
    interpret it as one of the preceding ten cases. The idea is that we read the stream
    and try one part of the potential complex number at a time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadStream` 方法从文本创建一个输入流并尝试将其解释为前面提到的十种情况之一。想法是读取流并一次尝试潜在复数的一部分：'
- en: '[PRE34]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the stream is made up of a value, a sign, another value, and i or I, we
    set *x* and *y* in accordance with case 1 (*x* ± *yi*) and return `true`. The
    *y* field is negative if the sign is minus. However, the second value may also
    be negative, in which case *y*is positive:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流由一个值、一个符号、另一个值和 i 或 I 组成，我们根据情况1 (*x* ± *yi*) 设置 *x* 和 *y* 并返回 `true`。如果符号是负号，则
    *y* 字段为负。然而，第二个值也可能是负的，在这种情况下 *y* 为正：
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the sign is not followed by a value, but by another sign and i or I, case
    2 (*x* ± ±*i*) applies and we return `true`. In this case, we actually have to
    adjust the value of *y* twice in accordance with both signs:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号后面不是值，而是另一个符号和 i 或 I，则适用情况2 (*x* ± ±*i*)，我们返回 `true`。在这种情况下，我们必须根据两个符号调整
    *y* 的值两次：
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the sign is not followed by a value or another sign, but by i or I, case
    3 (*x* ± *i*) applies and we return `true`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号后面不是值或另一个符号，而是 i 或 I，则适用情况3 (*x* ± *i*)，我们返回 `true`：
- en: '[PRE37]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the value is not followed by a sign but by i or I, another sign, and another
    value, case 4 (*yi* ± *x*) applies and we return `true`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值后面不是符号，而是 i 或 I，然后是另一个符号和另一个值，则适用情况4 (*yi* ± *x*)，我们返回 `true`：
- en: '[PRE38]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the value is followed by i or I and nothing else, case 7 (*yi*) applies
    and we return `true`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值后面跟着 i 或 I 而没有其他内容，则适用情况7 (*yi*)，我们返回 `true`：
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the value is followed by nothing else, case 10 (*x*) applies and we return
    `true`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值后面没有其他内容，则适用情况10 (*x*)，我们返回 `true`：
- en: '[PRE40]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the stream does not start with a value, but with a sign followed by i or
    I, another sign and another value, case 5 (±*i* ± *x*) applies and we return `true`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流不以值开头，而是以符号后跟 i 或 I 开头，然后是另一个符号和另一个值，则适用情况5 (±*i* ± *x*)，我们返回 `true`：
- en: '[PRE41]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the stream starts with a sign followed by i or I and nothing else, case
    8 (±*i*) applies and we return `true`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流以符号开头后跟 i 或 I 而没有其他内容，则适用情况8 (±*i*)，我们返回 `true`：
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the stream does not start with a value or a sign, but with i or I followed
    by a sign and a value, case 6 (*i* ± *x*) applies and we return `true`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流不以值或符号开头，而是以 i 或 I 开头，后面跟着符号和值，则适用情况 6 (*i* ± *x*)，我们返回 `true`：
- en: '[PRE43]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the stream is made up by i or I and nothing else, case 9 (*i*) applies and
    we return `true`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流由 i 或 I 和其他内容组成，则适用情况 9 (*i*)，我们返回 `true`：
- en: '[PRE44]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, if none of the above cases apply, the text does not hold a complex
    number and we return `false`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果上述任何情况都不适用，文本不包含复数，我们返回 `false`：
- en: '[PRE45]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The constructor that takes a text simply calls `ReadStream` and throws a `NotaComplexNumber`
    exception if `ReadStream` returns `false`. However, if `ReadStream` returns `true`,
    *x* and *y* are set to the appropriate values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接收文本的构造函数简单地调用 `ReadStream`，如果 `ReadStream` 返回 `false`，则抛出 `NotaComplexNumber`
    异常。然而，如果 `ReadStream` 返回 `true`，则 *x* 和 *y* 被设置为适当的值：
- en: '[PRE46]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `String` conversion operator, we look into several different cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `String` 转换运算符中，我们考虑几个不同的案例：
- en: '*x* + *i*'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* + *i*'
- en: '*x* - *i*'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* - *i*'
- en: '*x* ± *i*'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* ± *i*'
- en: '*x*'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*'
- en: +*i*
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: +*i*
- en: -*i*
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: -*i*
- en: '*yi*'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*yi*'
- en: '0'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0'
- en: 'If the real part *x* is not 0, we write its value on the stream and look into
    the first four cases with regard to the imaginary part, *y*. If *y* is plus or
    minus 1, we simply write `+i` or `-i`. If it is not plus or minus 1, and not 0,
    we write its value with the `showpos` flag, which forces the plus sign to be present
    in the case of a positive value. Finally, if *y* is 0, we do not write it at all:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实部 *x* 不为 0，我们在流上写下它的值，并考虑虚部 *y* 的前四种情况。如果 *y* 是正或负 1，我们简单地写下 `+i` 或 `-i`。如果不是正或负
    1，并且不是 0，我们使用 `showpos` 标志写下它的值，这强制在正值的情况下出现加号。最后，如果 *y* 是 0，我们根本不写它：
- en: '[PRE47]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If *x* is zero, we omit it and write the value of *y* in the same manner as
    we did earlier. However, if *y* is zero, we write 0; otherwise, nothing will be
    written if both *x* and *y* are 0\. Moreover, we omit the `showpos` flag, since
    it is not necessary to write the plus sign in the case of a positive value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 *x* 是零，我们省略它，并以我们之前的方式写下 *y* 的值。然而，如果 *y* 是零，我们写 0；如果 *x* 和 *y* 都为零，则什么也不写。此外，我们省略
    `showpos` 标志，因为在正值的情况下不需要写加号： '
- en: '[PRE48]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Two complex numbers are equal if their real and imaginary parts are equal:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个复数的实部和虚部相等，则这两个复数相等：
- en: '[PRE49]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When deciding whether a complex number is smaller than another complex number,
    we chose to compare their absolute values, which is given by the `Abs` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定一个复数是否小于另一个复数时，我们选择比较它们的绝对值，这由`Abs`方法给出：
- en: '[PRE50]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The addition operators all call the following final operator, which works for
    all four arithmetic operators:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 加法运算符都调用以下最终运算符，该运算符适用于所有四个算术运算符：
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When adding two complex numbers, we add the real and imaginary parts separately:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当加两个复数时，我们分别相加它们的实部和虚部：
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When subtracting two complex numbers, we subtract the real and imaginary parts
    separately:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当减去两个复数时，我们分别减去它们的实部和虚部：
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The product of two complex numbers can be established by some algebra:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两个复数的乘积可以通过一些代数方法建立：
- en: (*x* [1] + *y* [1]*i*)(*x* [2] + *y[2]i*) = *x* [1]*x* [2] + *x* [1]*y* [2]*i*
    + *y* [1]*ix* [2] + *y* [1]*y* [2]*i* ² = *x* [1]*x* [2] + *x* [1]*y* [2]*i* +
    *y* [1]*ix* [2] *+ y* [1]*y* [2] (-1) = *x* [1]*x* [2] + *x* [1]*y* [2]*i* + *x*
    [2]*y* [1]*i* - *y* [1]*y* [2] = (*x* [1]*x* [2] - *y* [1]*y* [2]) + (*x* [1]*y*
    [2] + *x* [2]*y* [1])*i*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: (*x* [1] + *y* [1]*i*)(*x* [2] + *y[2]i*) = *x* [1]*x* [2] + *x* [1]*y* [2]*i*
    + *y* [1]*ix* [2] + *y* [1]*y* [2]*i* ² = *x* [1]*x* [2] + *x* [1]*y* [2]*i* +
    *x* [2]*y* [1]*i* - *y* [1]*y* [2] = (*x* [1]*x* [2] - *y* [1]*y* [2]) + (*x*
    [1]*y* [2] + *x* [2]*y* [1])*i*
- en: '[PRE54]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The quotient between two complex numbers can also be established by some algebra.
    The **conjugate** of a complex number *x* [2] + *y* [2]*i* is *x* [2] - *y* [2]*i*,
    which we can use in the conjugate rule:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 两个复数的商也可以通过一些代数方法建立。复数 *x* [2] + *y* [2]*i* 的共轭是 *x* [2] - *y* [2]*i*，我们可以用它来应用共轭规则：
- en: (*x* [2]+ *y* [2]*i*)(*x* [2] - *y* [2]*i*) = *x* [2]² - *x* [2]*y* [2]*i* +
    *x* [2]*y* [2]*i* - *y* [2]² (-1) = *x* [2]² - *x* [2]*y* [2]*i* + *x* [2]*y*
    [2]*i* + *y* [2]² = *x* [2]² + *y* [2]²
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: (*x* [2]+ *y* [2]*i*)(*x* [2] - *y* [2]*i*) = *x* [2]² - *x* [2]*y* [2]*i* +
    *x* [2]*y* [2]*i* - *y* [2]² (-1) = *x* [2]² - *x* [2]*y* [2]*i* + *x* [2]*y*
    [2]*i* + *y* [2]² = *x* [2]² + *y* [2]²
- en: 'We can use the conjugate rule when dividing two complex numbers by multiplying
    the conjugate by both the numerator and the denominator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在除以两个复数时使用共轭规则，通过将共轭乘以分子和分母：
- en: '![Complex numbers](img/B05475_Appendix_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![复数](img/B05475_Appendix_08.jpg)'
- en: '[PRE55]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: By reading this book you have learned how to develop applications in Windows
    with Small Windows, a C++ object-oriented class library for graphical applications
    in Windows. I hope you have enjoyed the book!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读这本书，你已经学会了如何在Windows中使用Small Windows开发应用程序，Small Windows是一个用于Windows图形应用程序的C++面向对象类库。我希望你喜欢这本书！
