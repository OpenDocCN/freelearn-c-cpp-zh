<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Iterators and Ranges</h1>
                
            
            
                
<p class="calibre2">In the previous chapter, we implemented several generic algorithms that operated on containers, but in an inefficient manner. In this chapter, you'll learn:</p>
<ul class="calibre14">
<li class="calibre15">How and why C++ generalizes the idea of pointers to create the <em class="calibre22">iterator</em> concept</li>
<li class="calibre15">The importance of <em class="calibre22">ranges</em> in C++, and the standard way to express a half-open range as a pair of iterators</li>
<li class="calibre15">How to write your own rock-solid, const-correct iterator types</li>
<li class="calibre15">How to write generic algorithms that operate on iterator pairs</li>
<li class="calibre15">The standard iterator hierarchy and its algorithmic importance</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The problem with integer indices</h1>
                
            
            
                
<p class="calibre2">In the previous chapter, we implemented several generic algorithms that operated on containers. Consider one of those algorithms again:</p>
<pre class="calibre23">    template&lt;typename Container&gt;<br class="title-page-name"/>    void double_each_element(Container&amp; arr) <br class="title-page-name"/>    {<br class="title-page-name"/>      for (int i=0; i &lt; arr.size(); ++i) {<br class="title-page-name"/>        arr.at(i) *= 2;<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">This algorithm is defined in terms of the lower-level operations <kbd class="calibre12">.size()</kbd> and <kbd class="calibre12">.at()</kbd>. This works reasonably well for a container type such as <kbd class="calibre12">array_of_ints</kbd> or <kbd class="calibre12">std::vector</kbd>, but it doesn't work nearly so well for, say, a linked list such as the previous chapter's <kbd class="calibre12">list_of_ints</kbd>:</p>
<pre class="calibre23">    class list_of_ints {<br class="title-page-name"/>      struct node {<br class="title-page-name"/>        int data;<br class="title-page-name"/>        node *next;<br class="title-page-name"/>      };<br class="title-page-name"/>      node *head_ = nullptr;<br class="title-page-name"/>      node *tail_ = nullptr;<br class="title-page-name"/>      int size_ = 0;<br class="title-page-name"/>    public:<br class="title-page-name"/>      int size() const { return size_; }<br class="title-page-name"/>      int&amp; at(int i) {<br class="title-page-name"/>        if (i &gt;= size_) throw std::out_of_range("at");<br class="title-page-name"/>        node *p = head_;<br class="title-page-name"/>        for (int j=0; j &lt; i; ++j) {<br class="title-page-name"/>          p = p-&gt;next;<br class="title-page-name"/>        }<br class="title-page-name"/>        return p-&gt;data;<br class="title-page-name"/>      }<br class="title-page-name"/>      void push_back(int value) {<br class="title-page-name"/>        node *new_tail = new node{value, nullptr};<br class="title-page-name"/>        if (tail_) {<br class="title-page-name"/>          tail_-&gt;next = new_tail;<br class="title-page-name"/>        } else {<br class="title-page-name"/>          head_ = new_tail;<br class="title-page-name"/>        }<br class="title-page-name"/>        tail_ = new_tail;<br class="title-page-name"/>        size_ += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>      ~list_of_ints() {<br class="title-page-name"/>        for (node *next, *p = head_; p != nullptr; p = next) {<br class="title-page-name"/>          next = p-&gt;next;<br class="title-page-name"/>          delete p;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The implementation of <kbd class="calibre12">list_of_ints::at()</kbd> is O(<em class="calibre22">n</em>) in the length of the list--the longer our list gets, the slower <kbd class="calibre12">at()</kbd> gets. And particularly, when our <kbd class="calibre12">count_if</kbd> function loops over each element of the list, it's calling that <kbd class="calibre12">at()</kbd> function <em class="calibre22">n</em> times, which makes the runtime of our generic algorithm O(<em class="calibre22">n</em><sup class="calibre26">2</sup>)--for a simple counting operation that ought to be O(<em class="calibre22">n</em>)!</p>
<p class="calibre2">It turns out that integer indexing with <kbd class="calibre12">.at()</kbd> isn't a very good foundation on which to build algorithmic castles. We ought to pick a primitive operation that's closer to how computers actually manipulate data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">On beyond pointers</h1>
                
            
            
                
<p class="calibre2">In the absence of any abstraction, how does one normally identify an element of an array, an element of a linked list, or an element of a tree? The most straightforward way would be to use a <em class="calibre22">pointer</em> to the element's address in memory. Here are some examples of pointers to elements of various data structures:</p>
<div><img src="img/00005.jpeg" class="calibre27"/></div>
<p class="calibre2">To iterate over an <em class="calibre22">array</em>, all we need is that pointer; we can handle all the elements in the array by starting with a pointer to the first element and simply incrementing that pointer until it reaches the last element. In C:</p>
<pre class="calibre23">    for (node *p = lst.head_; p != nullptr; p = p-&gt;next) {<br class="title-page-name"/>      if (pred(p-&gt;data)) {<br class="title-page-name"/>        sum += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>   }</pre>
<p class="calibre2">But in order to efficiently iterate over a <em class="calibre22">linked list</em>, we need more than just a raw pointer; incrementing a pointer of type <kbd class="calibre12">node*</kbd> is highly unlikely to produce a pointer to the next node in the list! In that case, we need something that acts like a pointer--in particular, we should be able to dereference it to retrieve or modify the pointed-to element--but has special, container-specific behavior associated with the abstract concept of incrementing.</p>
<p class="calibre2">In C++, given that we have operator overloading built into the language, when I say "associate special behavior with the concept of incrementing", you should be thinking "let's overload the <kbd class="calibre12">++</kbd> operator." And indeed, that's what we'll do:</p>
<pre class="calibre23">    struct list_node {<br class="title-page-name"/>      int data;<br class="title-page-name"/>      list_node *next;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints_iterator {<br class="title-page-name"/>      list_node *ptr_;<br class="title-page-name"/><br class="title-page-name"/>      friend class list_of_ints;<br class="title-page-name"/>      explicit list_of_ints_iterator(list_node *p) : ptr_(p) {}<br class="title-page-name"/>    public:<br class="title-page-name"/>      int&amp; operator*() const { return ptr_-&gt;data; }<br class="title-page-name"/>      list_of_ints_iterator&amp; operator++() { ptr_ = ptr_-&gt;next; return *this; }<br class="title-page-name"/>      list_of_ints_iterator operator++(int) { auto it = *this; ++*this; return it; }<br class="title-page-name"/>      bool operator==(const list_of_ints_iterator&amp; rhs) const<br class="title-page-name"/>        { return ptr_ == rhs.ptr_; }<br class="title-page-name"/>      bool operator!=(const list_of_ints_iterator&amp; rhs) const<br class="title-page-name"/>        { return ptr_ != rhs.ptr_; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints {<br class="title-page-name"/>      list_node *head_ = nullptr;<br class="title-page-name"/>      list_node *tail_ = nullptr;<br class="title-page-name"/>      // ...<br class="title-page-name"/>    public:<br class="title-page-name"/>      using iterator = list_of_ints_iterator;<br class="title-page-name"/>      iterator begin() { return iterator{head_}; }<br class="title-page-name"/>      iterator end() { return iterator{nullptr}; }<br class="title-page-name"/>    }; <br class="title-page-name"/><br class="title-page-name"/>    template&lt;class Container, class Predicate&gt;<br class="title-page-name"/>    int count_if(Container&amp; ctr, Predicate pred)<br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto it = ctr.begin(); it != ctr.end(); ++it) {<br class="title-page-name"/>        if (pred(*it)) {<br class="title-page-name"/>            sum += 1;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>   }</pre>
<p class="calibre2">Notice that we also overload the unary <kbd class="calibre12">*</kbd> operator (for dereferencing) and the <kbd class="calibre12">==</kbd> and <kbd class="calibre12">!=</kbd> operators; our <kbd class="calibre12">count_if</kbd> template requires all of these operations be valid for the loop control variable <kbd class="calibre12">it</kbd>. (Well, okay, technically our <kbd class="calibre12">count_if</kbd> doesn't require the <kbd class="calibre12">==</kbd> operation; but if you're going to overload one of the comparison operators, you should overload the other as well.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Const iterators</h1>
                
            
            
                
<p class="calibre2">There's just one more complication to consider, before we abandon this list iterator example. Notice that I quietly changed our <kbd class="calibre12">count_if</kbd> function template so that it takes <kbd class="calibre12">Container&amp;</kbd> instead of <kbd class="calibre12">const Container&amp;</kbd>! That's because the <kbd class="calibre12">begin()</kbd> and <kbd class="calibre12">end()</kbd> member functions we provided are non-const member functions; and that's because they return iterators whose <kbd class="calibre12">operator*</kbd> returns non-const references to the elements of the list. We'd like to make our list type (and its iterators) completely const-correct--that is, we'd like you to be able to define and use variables of type <kbd class="calibre12">const list_of_ints</kbd>, but prevent you from modifying the elements of a <kbd class="calibre12">const</kbd> list.</p>
<p class="calibre2">The standard library generally deals with this issue by giving each standard container two different kinds of iterator: <kbd class="calibre12">bag::iterator</kbd> and <kbd class="calibre12">bag::const_iterator</kbd>. The non-const member function <kbd class="calibre12">bag::begin()</kbd> returns an <kbd class="calibre12">iterator</kbd> and the <kbd class="calibre12">bag::begin() const</kbd> member function returns a <kbd class="calibre12">const_iterator</kbd>. The underscore is all-important! Notice that <kbd class="calibre12">bag::begin() const</kbd> does not return a mere <kbd class="calibre12">const iterator</kbd>; if the returned object were <kbd class="calibre12">const</kbd>, we wouldn't be allowed to <kbd class="calibre12">++</kbd> it. (Which, in turn, would make it darn difficult to iterate over a <kbd class="calibre12">const bag</kbd>!) No, <kbd class="calibre12">bag::begin() const</kbd> returns something more subtle: a non-const <kbd class="calibre12">const_iterator</kbd> object whose <kbd class="calibre12">operator*</kbd> simply happens to yield a <em class="calibre22">const</em> reference to its element.</p>
<p class="calibre2">Maybe an example would help. Let's go ahead and implement <kbd class="calibre12">const_iterator</kbd> for our <kbd class="calibre12">list_of_ints</kbd> container.</p>
<p class="calibre2">Since most of the code for the <kbd class="calibre12">const_iterator</kbd> type is going to be exactly the same as the code for the <kbd class="calibre12">iterator</kbd> type, our first instinct might be to cut and paste. But this is C++! When I say "most of this code is going to be exactly the same as this other code," you should be thinking "let's make the common parts into a template." And indeed, that's what we'll do:</p>
<pre class="calibre23">    struct list_node {<br class="title-page-name"/>      int data;<br class="title-page-name"/>      list_node *next;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    template&lt;bool Const&gt;<br class="title-page-name"/>    class list_of_ints_iterator {<br class="title-page-name"/>      friend class list_of_ints;<br class="title-page-name"/>      friend class list_of_ints_iterator&lt;!Const&gt;;<br class="title-page-name"/><br class="title-page-name"/>      using node_pointer = std::conditional_t&lt;Const, const list_node*, list_node*&gt;;<br class="title-page-name"/>      using reference = std::conditional_t&lt;Const, const int&amp;, int&amp;&gt;;<br class="title-page-name"/><br class="title-page-name"/>      node_pointer ptr_;<br class="title-page-name"/><br class="title-page-name"/>      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {}<br class="title-page-name"/>    public:<br class="title-page-name"/>      reference operator*() const { return ptr_-&gt;data; }<br class="title-page-name"/>      auto&amp; operator++() { ptr_ = ptr_-&gt;next; return *this; }<br class="title-page-name"/>      auto operator++(int) { auto result = *this; ++*this; return result; }<br class="title-page-name"/><br class="title-page-name"/>      // Support comparison between iterator and const_iterator types<br class="title-page-name"/>      template&lt;bool R&gt;<br class="title-page-name"/>      bool operator==(const list_of_ints_iterator&lt;R&gt;&amp; rhs) const<br class="title-page-name"/>        { return ptr_ == rhs.ptr_; }<br class="title-page-name"/><br class="title-page-name"/>      template&lt;bool R&gt;<br class="title-page-name"/>      bool operator!=(const list_of_ints_iterator&lt;R&gt;&amp; rhs) const<br class="title-page-name"/>        { return ptr_ != rhs.ptr_; }<br class="title-page-name"/><br class="title-page-name"/>      // Support implicit conversion of iterator to const_iterator<br class="title-page-name"/>      // (but not vice versa)<br class="title-page-name"/>      operator list_of_ints_iterator&lt;true&gt;() const<br class="title-page-name"/>        { return list_of_ints_iterator&lt;true&gt;{ptr_}; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints {<br class="title-page-name"/>      list_node *head_ = nullptr;<br class="title-page-name"/>      list_node *tail_ = nullptr;<br class="title-page-name"/>      // ...<br class="title-page-name"/>    public:<br class="title-page-name"/>      using const_iterator = list_of_ints_iterator&lt;true&gt;;<br class="title-page-name"/>      using iterator = list_of_ints_iterator&lt;false&gt;;<br class="title-page-name"/><br class="title-page-name"/>      iterator begin() { return iterator{head_}; }<br class="title-page-name"/>      iterator end() { return iterator{nullptr}; }<br class="title-page-name"/>      const_iterator begin() const { return const_iterator{head_}; }<br class="title-page-name"/>      const_iterator end() const { return const_iterator{nullptr}; }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The preceding code implements fully const-correct iterator types for our <kbd class="calibre12">list_of_ints</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A pair of iterators defines a range</h1>
                
            
            
                
<p class="calibre2">Now that we understand the fundamental concept of an iterator, let's put it to some practical use. We've already seen that if you have a pair of iterators as returned from <kbd class="calibre12">begin()</kbd> and <kbd class="calibre12">end()</kbd>, you can use a for-loop to iterate over all the elements of the underlying container. But more powerfully, you can use some pair of iterators to iterate over any sub-range of the container's elements! Let's say you only wanted to view the first half of a vector:</p>
<pre class="calibre23">    template&lt;class Iterator&gt;<br class="title-page-name"/>    void double_each_element(Iterator begin, Iterator end) <br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>        *it *= 2;<br class="title-page-name"/>      } <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    int main() <br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; v {1, 2, 3, 4, 5, 6};<br class="title-page-name"/>      double_each_element(v.begin(), v.end());<br class="title-page-name"/>        // double each element in the entire vector<br class="title-page-name"/>      double_each_element(v.begin(), v.begin()+3);<br class="title-page-name"/>        // double each element in the first half of the vector<br class="title-page-name"/>      double_each_element(&amp;v[0], &amp;v[3]);<br class="title-page-name"/>        // double each element in the first half of the vector<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that in the first and second test cases in <kbd class="calibre12">main()</kbd> we pass in a pair of iterators derived from <kbd class="calibre12">v.begin()</kbd>; that is, two values of type <kbd class="calibre12">std::vector::iterator</kbd>. In the third test case, we pass in two values of type <kbd class="calibre12">int*</kbd>. Since <kbd class="calibre12">int*</kbd> satisfies all the requirements of an iterator type in this case--namely: it is incrementable, comparable, and dereferenceable--our code works fine even with pointers! This example demonstrates the flexibility of the iterator-pair model. (However, in general you should avoid messing around with raw pointers, if you're using a container such as <kbd class="calibre12">std::vector</kbd> that offers a proper <kbd class="calibre12">iterator</kbd> type. Use iterators derived from <kbd class="calibre12">begin()</kbd> and <kbd class="calibre12">end()</kbd> instead.)</p>
<p class="calibre2">We can say that a pair of iterators implicitly defines a <em class="calibre22">range</em> of data elements. And for a surprisingly large family of algorithms, that's good enough! We don't need to have access to the <em class="calibre22">container</em> in order to perform certain searches or transformations; we only need access to the particular <em class="calibre22">range</em> of elements being searched or transformed. Going further down this line of thought will eventually lead us to the concept of a <em class="calibre22">non-owning view</em> (which is to a data sequence as a C++ reference is to a single variable), but views and ranges are still more modern concepts, and we ought to finish up with the 1998-vintage STL before we talk about those things.</p>
<p class="calibre2">In the previous code sample, we saw the first example of a real STL-style generic algorithm. Admittedly, <kbd class="calibre12">double_each_element</kbd> is not a terribly generic algorithm in the sense of implementing a behavior that we might want to reuse in other programs; but this version of the function is now perfectly generic in the sense of operating only on pairs of <kbd class="calibre12">Iterators</kbd>, where <kbd class="calibre12">Iterator</kbd> can be any type in the world that implements incrementability, comparability, and dereferenceability. (We'll see a version of this algorithm that is more generic in that first sense in this book's next chapter, when we talk about <kbd class="calibre12">std::transform</kbd>.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Iterator categories</h1>
                
            
            
                
<p class="calibre2">Let's revisit the <kbd class="calibre12">count</kbd> and <kbd class="calibre12">count_if</kbd> functions that we introduced in<br class="title-page-name"/>
<a target="_blank" href="part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 1</a>, <em class="calibre22">Classical Polymorphism and Generic Programming</em>. Compare the function template definition in this next example to the similar code from that chapter; you'll see that it's identical except for the substitution of a pair of <kbd class="calibre12">Iterators</kbd> (that is, an implicitly defined <em class="calibre22">range</em>) for the <kbd class="calibre12">Container&amp;</kbd> parameter--and except that I've changed the name of the first function from <kbd class="calibre12">count</kbd> to <kbd class="calibre12">distance</kbd>. That's because you can find this function, almost exactly as described here, in the Standard Template Library under the name <kbd class="calibre12">std::distance</kbd> and you can find the second function under the name <kbd class="calibre12">std::count_if</kbd>:</p>
<pre class="calibre23">    template&lt;typename Iterator&gt;<br class="title-page-name"/>    int distance(Iterator begin, Iterator end) <br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>        sum += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;typename Iterator, typename Predicate&gt;<br class="title-page-name"/>    int count_if(Iterator begin, Iterator end, Predicate pred) <br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>        if (pred(*it)) {<br class="title-page-name"/>            sum += 1;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum; <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() <br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9, 2, 6};<br class="title-page-name"/><br class="title-page-name"/>      int number_above = count_if(v.begin(), v.end(), [](int e) { return e &gt; 5; });<br class="title-page-name"/>      int number_below = count_if(v.begin(), v.end(), [](int e) { return e &lt; 5; });<br class="title-page-name"/><br class="title-page-name"/>      int total = distance(v.begin(), v.end()); // DUBIOUS <br class="title-page-name"/><br class="title-page-name"/>      assert(number_above == 2);<br class="title-page-name"/>      assert(number_below == 5);<br class="title-page-name"/>      assert(total == 8);<br class="title-page-name"/>    }</pre>
<p class="calibre2">But let's consider the line marked <kbd class="calibre12">DUBIOUS</kbd> in that example. Here we're computing the distance between two <kbd class="calibre12">Iterators</kbd> by repeatedly incrementing the one until it reaches the other. How performant is this approach? For certain kinds of iterators--for example, <kbd class="calibre12">list_of_ints::iterator</kbd>--we're not going to be able to do better than this. But for <kbd class="calibre12">vector::iterator</kbd> or <kbd class="calibre12">int*</kbd>, which iterate over contiguous data, it's a little silly of us to be using a loop and an O(n) algorithm when we could accomplish the same thing in O(1) time by simple pointer subtraction. That is, we'd like the standard library version of <kbd class="calibre12">std::distance</kbd> to include a template specialization something like this:</p>
<pre class="calibre23">    template&lt;typename Iterator&gt;<br class="title-page-name"/>    int distance(Iterator begin, Iterator end)<br class="title-page-name"/>    {<br class="title-page-name"/>      int sum = 0;<br class="title-page-name"/>      for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>        sum += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;&gt; <br class="title-page-name"/>    int distance(int *begin, int *end) <br class="title-page-name"/>    {<br class="title-page-name"/>      return end - begin;<br class="title-page-name"/>    }</pre>
<p class="calibre2">But we don't want the specialization to exist only for <kbd class="calibre12">int*</kbd> and <kbd class="calibre12">std::vector::iterator</kbd>. We want the standard library's <kbd class="calibre12">std::distance</kbd> to be efficient for all the iterator types that support this particular operation. That is, we're starting to develop an intuition that there are (at least) two different kinds of iterators: there are those that are incrementable, comparable, and dereferenceable; and then there are those that are incrementable, comparable, dereferenceable, <em class="calibre22">and also subtractable!</em> It turns out that for any iterator type where the operation <kbd class="calibre12">i = p - q</kbd> makes sense, its inverse operation <kbd class="calibre12">q = p + i</kbd> also makes sense. Iterators that support subtraction and addition are called <em class="calibre22">random-access iterators</em>.</p>
<p class="calibre2">So, the standard library's <kbd class="calibre12">std::distance</kbd> ought to be efficient for both random-access iterators and other kinds of iterators. To make it easier to supply the partial specializations for these templates, the standard library introduced the idea of a hierarchy of iterator kinds. Iterators such as <kbd class="calibre12">int*</kbd>, which support addition and subtraction, are known as random-access iterators. We'll say that they satisfy the concept <kbd class="calibre12">RandomAccessIterator</kbd>.</p>
<p class="calibre2">Iterators slightly less powerful than random-access iterators might not support addition or subtraction of arbitrary distances, but they at least support incrementing and decrementing with <kbd class="calibre12">++p</kbd> and <kbd class="calibre12">--p</kbd>. Iterators of this nature are called <kbd class="calibre12">BidirectionalIterator</kbd>. All <kbd class="calibre12">RandomAccessIterator</kbd> are <kbd class="calibre12">BidirectionalIterator</kbd>, but not necessarily vice versa. In some sense, we can imagine <kbd class="calibre12">RandomAccessIterator</kbd> to be a sub-class or sub-concept relative to <kbd class="calibre12">BidirectionalIterator</kbd>; and we can say that <kbd class="calibre12">BidirectionalIterator</kbd> is a <em class="calibre22">weaker concept</em>, imposing fewer requirements, than <kbd class="calibre12">RandomAccessIterator</kbd>.</p>
<p class="calibre2">An even weaker concept is the kind of iterators that don't even support decrementing. For example, our <kbd class="calibre12">list_of_ints::iterator</kbd> type doesn't support decrementing, because our linked list has no previous pointers; once you've got an iterator pointing at a given element of the list, you can only move forward to later elements, never backward to previous ones. Iterators that support <kbd class="calibre12">++p</kbd> but not <kbd class="calibre12">--p</kbd> are called <kbd class="calibre12">ForwardIterator</kbd>. <kbd class="calibre12">ForwardIterator</kbd> is a weaker concept than <kbd class="calibre12">BidirectionalIterator</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Input and output iterators</h1>
                
            
            
                
<p class="calibre2">We can imagine even weaker concepts than <kbd class="calibre12">ForwardIterator</kbd>! For example, one useful thing you can do with a <kbd class="calibre12">ForwardIterator</kbd> is to make a copy of it, save the copy, and use it to iterate twice over the same data. Manipulating the iterator (or copies of it) doesn't affect the underlying range of data at all. But we could invent an iterator like the one in the following snippet, where there is no underlying data at all, and it's not even meaningful to make a copy of the iterator:</p>
<pre class="calibre23">    class getc_iterator {<br class="title-page-name"/>      char ch;<br class="title-page-name"/>    public:<br class="title-page-name"/>      getc_iterator() : ch(getc(stdin)) {}<br class="title-page-name"/>      char operator*() const { return ch; }<br class="title-page-name"/>      auto&amp; operator++() { ch = getc(stdin); return *this; }<br class="title-page-name"/>      auto operator++(int) { auto result(*this); ++*this; return result; }<br class="title-page-name"/>      bool operator==(const getc_iterator&amp;) const { return false; }<br class="title-page-name"/>      bool operator!=(const getc_iterator&amp;) const { return true; }<br class="title-page-name"/>    };</pre>
<p class="calibre2">(In fact, the standard library contains some iterator types very similar to this one; we'll discuss one such type, <kbd class="calibre12">std::istream_iterator</kbd>, in <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>.) Such iterators, which are not meaningfully copyable, and do not point to data elements in any meaningful sense, are called <kbd class="calibre12">InputIterator</kbd> types.</p>
<p class="calibre2">The mirror-image case is also possible. Consider the following invented iterator type:</p>
<pre class="calibre23">    class putc_iterator {<br class="title-page-name"/>      struct proxy {<br class="title-page-name"/>        void operator= (char ch) { putc(ch, stdout); }<br class="title-page-name"/>      };<br class="title-page-name"/>    public:<br class="title-page-name"/>      proxy operator*() const { return proxy{}; }<br class="title-page-name"/>      auto&amp; operator++() { return *this; }<br class="title-page-name"/>      auto&amp; operator++(int) { return *this; }<br class="title-page-name"/>      bool operator==(const putc_iterator&amp;) const { return false; }<br class="title-page-name"/>      bool operator!=(const putc_iterator&amp;) const { return true; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      putc_iterator it;<br class="title-page-name"/>      for (char ch : {'h', 'e', 'l', 'l', 'o', '\n'}) {<br class="title-page-name"/>        *it++ = ch;<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">(Again, the standard library contains some iterator types very similar to this one; we'll discuss <kbd class="calibre12">std::back_insert_iterator</kbd> in <a href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator-Pair Algorithms</em>, and <kbd class="calibre12">std::ostream_iterator</kbd> in <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams.</em>) Such iterators, which are not meaningfully copyable, and are writeable-into but not readable-out-of, are called <kbd class="calibre12">OutputIterator</kbd> types.</p>
<p class="calibre2">Every iterator type in C++ falls into at least one of the following five categories:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">InputIterator</kbd></li>
<li class="calibre15"><kbd class="calibre12">OutputIterator</kbd></li>
<li class="calibre15"><kbd class="calibre12">ForwardIterator</kbd></li>
<li class="calibre15"><kbd class="calibre12">BidirectionalIterator</kbd>, and/or</li>
<li class="calibre15"><kbd class="calibre12">RandomAccessIterator</kbd></li>
</ul>
<p class="calibre2">Notice that while it's easy to figure out at compile time whether a particular iterator type conforms to the <kbd class="calibre12">BidirectionalIterator</kbd> or <kbd class="calibre12">RandomAccessIterator</kbd> requirements, it's impossible to figure out (purely from the syntactic operations it supports) whether we're dealing with an <kbd class="calibre12">InputIterator</kbd>, an <kbd class="calibre12">OutputIterator</kbd>, or a <kbd class="calibre12">ForwardIterator</kbd>. In our examples just a moment ago, consider: <kbd class="calibre12">getc_iterator</kbd>, <kbd class="calibre12">putc_iterator</kbd>, and <kbd class="calibre12">list_of_ints::iterator</kbd> support exactly the same syntactic operations--dereferencing with <kbd class="calibre12">*it</kbd>, incrementing with <kbd class="calibre12">++it</kbd>, and comparison with <kbd class="calibre12">it != it</kbd>. These three classes differ only at the semantic level. So how can the standard library distinguish between them?</p>
<p class="calibre2">It turns out that the standard library needs a bit of help from the implementor of each new iterator type. The standard library's algorithms will work only with iterator classes which define a <em class="calibre22">member typedef</em> named <kbd class="calibre12">iterator_category</kbd>. That is:</p>
<pre class="calibre23">    class getc_iterator {<br class="title-page-name"/>      char ch;<br class="title-page-name"/>    public:<br class="title-page-name"/>      using iterator_category = std::input_iterator_tag;<br class="title-page-name"/><br class="title-page-name"/>      // ...<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class putc_iterator {<br class="title-page-name"/>      struct proxy {<br class="title-page-name"/>        void operator= (char ch) { putc(ch, stdout); }<br class="title-page-name"/>      };<br class="title-page-name"/>    public:<br class="title-page-name"/>      using iterator_category = std::output_iterator_tag;<br class="title-page-name"/><br class="title-page-name"/>      // ...<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    template&lt;bool Const&gt;<br class="title-page-name"/>    class list_of_ints_iterator {<br class="title-page-name"/>      using node_pointer = std::conditional_t&lt;Const, const list_node*,<br class="title-page-name"/>       list_node*&gt;;<br class="title-page-name"/>      node_pointer ptr_;<br class="title-page-name"/><br class="title-page-name"/>    public:<br class="title-page-name"/>      using iterator_category = std::forward_iterator_tag;<br class="title-page-name"/><br class="title-page-name"/>      // ...<br class="title-page-name"/>    };</pre>
<p class="calibre2">Then any standard (or heck, non-standard) algorithm that wants to customize its behavior based on the iterator categories of its template type parameters can do that customization simply by inspecting those types' <kbd class="calibre12">iterator_category</kbd>.</p>
<p class="calibre2">The iterator categories described in the preceding paragraph, correspond to the following five standard tag types defined in the <kbd class="calibre12">&lt;iterator&gt;</kbd> header:</p>
<pre class="calibre23">    struct input_iterator_tag { };<br class="title-page-name"/>    struct output_iterator_tag { };<br class="title-page-name"/>    struct forward_iterator_tag : public input_iterator_tag { };<br class="title-page-name"/>    struct bidirectional_iterator_tag : public forward_iterator_tag { };<br class="title-page-name"/>    struct random_access_iterator_tag : public bidirectional_iterator_tag<br class="title-page-name"/>    { };</pre>
<p class="calibre2">Notice that <kbd class="calibre12">random_access_iterator_tag</kbd> actually derives (in the classical-OO, polymorphic-class-hierarchy sense) from <kbd class="calibre12">bidirectional_iterator_tag</kbd>, and so on: the <em class="calibre22">conceptual hierarchy</em> of iterator kinds is reflected in the <em class="calibre22">class hierarchy</em> of <kbd class="calibre12">iterator_category</kbd> tag classes. This turns out to be useful in template metaprogramming when you're doing tag dispatch; but all you need to know about it for the purposes of using the standard library is that if you ever want to pass an <kbd class="calibre12">iterator_category</kbd> to a function, a tag of type <kbd class="calibre12">random_access_iterator_tag</kbd> will be a match for a function expecting an argument of type <kbd class="calibre12">bidirectional_iterator_tag</kbd>:</p>
<pre class="calibre23">    void foo(std::bidirectional_iterator_tag t [[maybe_unused]])<br class="title-page-name"/>    {<br class="title-page-name"/>      puts("std::vector's iterators are indeed bidirectional..."); <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void bar(std::random_access_iterator_tag)<br class="title-page-name"/>    {<br class="title-page-name"/>      puts("...and random-access, too!");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void bar(std::forward_iterator_tag)<br class="title-page-name"/>    {<br class="title-page-name"/>      puts("forward_iterator_tag is not as good a match");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      using It = std::vector&lt;int&gt;::iterator;<br class="title-page-name"/>      foo(It::iterator_category{});<br class="title-page-name"/>      bar(It::iterator_category{});<br class="title-page-name"/>    }</pre>
<p class="calibre2">At this point I expect you're wondering: "But what about <kbd class="calibre12">int*</kbd>? How can we provide a member typedef to something that isn't a class type at all, but rather a primitive scalar type? Scalar types can't have member typedefs." Well, as with most problems in software engineering, this problem can be solved by adding a layer of indirection. Rather than referring directly to <kbd class="calibre12">T::iterator_category</kbd>, the standard algorithms are careful always to refer to <kbd class="calibre12">std::iterator_traits&lt;T&gt;::iterator_category</kbd>. The class template <kbd class="calibre12">std::iterator_traits&lt;T&gt;</kbd> is appropriately specialized for the case where <kbd class="calibre12">T</kbd> is a pointer type.</p>
<p class="calibre2">Furthermore, <kbd class="calibre12">std::iterator_traits&lt;T&gt;</kbd> proved to be a convenient place to hang other member typedefs. It provides the following five member typedefs, if and only if <kbd class="calibre12">T</kbd> itself provides all five of them (or if <kbd class="calibre12">T</kbd> is a pointer type): <kbd class="calibre12">iterator_category</kbd>, <kbd class="calibre12">difference_type</kbd>, <kbd class="calibre12">value_type</kbd>, <kbd class="calibre12">pointer</kbd>, and <kbd class="calibre12">reference</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Putting it all together</h1>
                
            
            
                
<p class="calibre2">Putting together everything we've learned in this chapter, we can now write code like the following example. In this example, we're implementing our own <kbd class="calibre12">list_of_ints</kbd> with our own iterator class (including a const-correct <kbd class="calibre12">const_iterator</kbd> version); and we're enabling it to work with the standard library by providing the five all-important member typedefs.</p>
<pre class="calibre23">    struct list_node {<br class="title-page-name"/>      int data;<br class="title-page-name"/>      list_node *next;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    template&lt;bool Const&gt;<br class="title-page-name"/>    class list_of_ints_iterator {<br class="title-page-name"/>      friend class list_of_ints;<br class="title-page-name"/>      friend class list_of_ints_iterator&lt;!Const&gt;;<br class="title-page-name"/><br class="title-page-name"/>      using node_pointer = std::conditional_t&lt;Const, const list_node*,<br class="title-page-name"/>        list_node*&gt;;<br class="title-page-name"/>      node_pointer ptr_;<br class="title-page-name"/><br class="title-page-name"/>      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {}<br class="title-page-name"/>    public:<br class="title-page-name"/>      // Member typedefs required by std::iterator_traits<br class="title-page-name"/>      using difference_type = std::ptrdiff_t;<br class="title-page-name"/>      using value_type = int;<br class="title-page-name"/>      using pointer = std::conditional_t&lt;Const, const int*, int*&gt;;<br class="title-page-name"/>      using reference = std::conditional_t&lt;Const, const int&amp;, int&amp;&gt;;<br class="title-page-name"/>      using iterator_category = std::forward_iterator_tag;<br class="title-page-name"/><br class="title-page-name"/>      reference operator*() const { return ptr_-&gt;data; }<br class="title-page-name"/>      auto&amp; operator++() { ptr_ = ptr_-&gt;next; return *this; }<br class="title-page-name"/>      auto operator++(int) { auto result = *this; ++*this; return result; }<br class="title-page-name"/><br class="title-page-name"/>      // Support comparison between iterator and const_iterator types<br class="title-page-name"/>      template&lt;bool R&gt;<br class="title-page-name"/>      bool operator==(const list_of_ints_iterator&lt;R&gt;&amp; rhs) const<br class="title-page-name"/>        { return ptr_ == rhs.ptr_; }<br class="title-page-name"/><br class="title-page-name"/>      template&lt;bool R&gt;<br class="title-page-name"/>      bool operator!=(const list_of_ints_iterator&lt;R&gt;&amp; rhs) const<br class="title-page-name"/>        { return ptr_ != rhs.ptr_; }<br class="title-page-name"/><br class="title-page-name"/>      // Support implicit conversion of iterator to const_iterator<br class="title-page-name"/>      // (but not vice versa)<br class="title-page-name"/>      operator list_of_ints_iterator&lt;true&gt;() const { return <br class="title-page-name"/>        list_of_ints_iterator&lt;true&gt;{ptr_}; }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints {<br class="title-page-name"/>      list_node *head_ = nullptr;<br class="title-page-name"/>      list_node *tail_ = nullptr;<br class="title-page-name"/>      int size_ = 0;<br class="title-page-name"/>    public:<br class="title-page-name"/>      using const_iterator = list_of_ints_iterator&lt;true&gt;;<br class="title-page-name"/>      using iterator = list_of_ints_iterator&lt;false&gt;;<br class="title-page-name"/><br class="title-page-name"/>      // Begin and end member functions<br class="title-page-name"/>      iterator begin() { return iterator{head_}; }<br class="title-page-name"/>      iterator end() { return iterator{nullptr}; }<br class="title-page-name"/>      const_iterator begin() const { return const_iterator{head_}; }<br class="title-page-name"/>      const_iterator end() const { return const_iterator{nullptr}; }<br class="title-page-name"/><br class="title-page-name"/>      // Other member operations<br class="title-page-name"/>      int size() const { return size_; }<br class="title-page-name"/>      void push_back(int value) {<br class="title-page-name"/>        list_node *new_tail = new list_node{value, nullptr};<br class="title-page-name"/>        if (tail_) {<br class="title-page-name"/>          tail_-&gt;next = new_tail;<br class="title-page-name"/>        } else {<br class="title-page-name"/>          head_ = new_tail;<br class="title-page-name"/>        }<br class="title-page-name"/>        tail_ = new_tail;<br class="title-page-name"/>        size_ += 1;<br class="title-page-name"/>      }<br class="title-page-name"/>      ~list_of_ints() {<br class="title-page-name"/>        for (list_node *next, *p = head_; p != nullptr; p = next) {<br class="title-page-name"/>          next = p-&gt;next;<br class="title-page-name"/>          delete p;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Then, to show that we understand how the standard library implements generic algorithms, we'll implement the function templates <kbd class="calibre12">distance</kbd> and <kbd class="calibre12">count_if</kbd> exactly as the C++17 standard library would implement them.</p>
<p>Notice the use of C++17's new <kbd class="calibre25">if constexpr</kbd> syntax in <kbd class="calibre25">distance</kbd>. We won't talk about C++17 core language features very much in this book, but suffice it to say, you can use <kbd class="calibre25">if constexpr</kbd> to eliminate a lot of awkward boilerplate compared to what you'd have had to write in C++14.</p>
<pre class="calibre23">    template&lt;typename Iterator&gt;<br class="title-page-name"/>    auto distance(Iterator begin, Iterator end)<br class="title-page-name"/>    {<br class="title-page-name"/>      using Traits = std::iterator_traits&lt;Iterator&gt;;<br class="title-page-name"/>      if constexpr (std::is_base_of_v&lt;std::random_access_iterator_tag,<br class="title-page-name"/>        typename Traits::iterator_category&gt;) {<br class="title-page-name"/>          return (end - begin);<br class="title-page-name"/>        } else {<br class="title-page-name"/>         auto result = typename Traits::difference_type{};<br class="title-page-name"/>         for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>           ++result;<br class="title-page-name"/>         }<br class="title-page-name"/>         return result;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    template&lt;typename Iterator, typename Predicate&gt;<br class="title-page-name"/>    auto count_if(Iterator begin, Iterator end, Predicate pred) <br class="title-page-name"/>    {<br class="title-page-name"/>      using Traits = std::iterator_traits&lt;Iterator&gt;;<br class="title-page-name"/>      auto sum = typename Traits::difference_type{};<br class="title-page-name"/>      for (auto it = begin; it != end; ++it) {<br class="title-page-name"/>        if (pred(*it)) {<br class="title-page-name"/>          ++sum;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return sum;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>       list_of_ints lst;<br class="title-page-name"/>       lst.push_back(1);<br class="title-page-name"/>       lst.push_back(2);<br class="title-page-name"/>       lst.push_back(3);<br class="title-page-name"/>       int s = count_if(lst.begin(), lst.end(), [](int i){<br class="title-page-name"/>          return i &gt;= 2;<br class="title-page-name"/>       });<br class="title-page-name"/>       assert(s == 2);<br class="title-page-name"/>       int d = distance(lst.begin(), lst.end());<br class="title-page-name"/>       assert(d == 3);<br class="title-page-name"/>    }</pre>
<p class="calibre2">In the next chapter we'll stop implementing so many of our own function templates from scratch, and start marching through the function templates provided by the Standard Template Library. But before we leave this deep discussion of iterators, there's one more thing I'd like to talk about.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The deprecated std::iterator</h1>
                
            
            
                
<p class="calibre2">You might be wondering: "Every iterator class I implement needs to provide the same five member typedefs. That's a lot of boilerplate--a lot of typing that I'd like to factor out, if I could." Is there no way to eliminate all that boilerplate?</p>
<p class="calibre2">Well, in C++98, and up until C++17, the standard library included a helper class template to do exactly that. Its name was <kbd class="calibre12">std::iterator</kbd>, and it took five template type parameters that corresponded to the five member typedefs required by <kbd class="calibre12">std::iterator_traits</kbd>. Three of these parameters had "sensible defaults," meaning that the simplest use-case was pretty well covered:</p>
<pre class="calibre23">    namespace std {<br class="title-page-name"/>      template&lt;<br class="title-page-name"/>        class Category,<br class="title-page-name"/>        class T,<br class="title-page-name"/>        class Distance = std::ptrdiff_t,<br class="title-page-name"/>        class Pointer = T*,<br class="title-page-name"/>        class Reference = T&amp;<br class="title-page-name"/>      &gt; struct iterator {<br class="title-page-name"/>        using iterator_category = Category;<br class="title-page-name"/>        using value_type = T;<br class="title-page-name"/>        using difference_type = Distance;<br class="title-page-name"/>        using pointer = Pointer;<br class="title-page-name"/>        using reference = Reference;<br class="title-page-name"/>      };<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    class list_of_ints_iterator :<br class="title-page-name"/>      public std::iterator&lt;std::forward_iterator_tag, int&gt;<br class="title-page-name"/>    {<br class="title-page-name"/>       // ...<br class="title-page-name"/>    };</pre>
<p class="calibre2">Unfortunately for <kbd class="calibre12">std::iterator</kbd>, real life wasn't that simple; and <kbd class="calibre12">std::iterator</kbd> was deprecated in C++17 for several reasons that we're about to discuss.</p>
<p class="calibre2">As we saw in the section <em class="calibre22">Const iterators</em>, const-correctness requires us to provide a const iterator type along with every "non-const iterator" type. So what we really end up with, following that example, is code like this:</p>
<pre class="calibre23">    template&lt;<br class="title-page-name"/>      bool Const,<br class="title-page-name"/>      class Base = std::iterator&lt;<br class="title-page-name"/>        std::forward_iterator_tag,<br class="title-page-name"/>        int,<br class="title-page-name"/>        std::ptrdiff_t,<br class="title-page-name"/>        std::conditional_t&lt;Const, const int*, int*&gt;,<br class="title-page-name"/>        std::conditional_t&lt;Const, const int&amp;, int&amp;&gt;<br class="title-page-name"/>      &gt;<br class="title-page-name"/>    &gt;<br class="title-page-name"/>    class list_of_ints_iterator : public Base<br class="title-page-name"/>    {<br class="title-page-name"/>      using typename Base::reference; // Awkward!<br class="title-page-name"/><br class="title-page-name"/>      using node_pointer = std::conditional_t&lt;Const, const list_node*,<br class="title-page-name"/>        list_node*&gt;;<br class="title-page-name"/>      node_pointer ptr_;<br class="title-page-name"/><br class="title-page-name"/>    public:<br class="title-page-name"/>      reference operator*() const { return ptr_-&gt;data; }<br class="title-page-name"/>      // ...<br class="title-page-name"/>    };</pre>
<p class="calibre2">The preceding code isn't any easier to read or write than the version that didn't use <kbd class="calibre12">std::iterator</kbd>; and furthermore, using <kbd class="calibre12">std::iterator</kbd> in the intended fashion complicates our code with <em class="calibre22">public inheritance</em>, which is to say, something that looks an awful lot like the classical object-oriented class hierarchy. A beginner might well be tempted to use that class hierarchy in writing functions like this one:</p>
<pre class="calibre23">    template&lt;typename... Ts, typename Predicate&gt;<br class="title-page-name"/>    int count_if(const std::iterator&lt;Ts...&gt;&amp; begin,<br class="title-page-name"/>                 const std::iterator&lt;Ts...&gt;&amp; end,<br class="title-page-name"/>                 Predicate pred);</pre>
<p class="calibre2">This looks superficially similar to our examples of "polymorphic programming" from <a target="_blank" href="part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 1</a>, <em class="calibre22">Classical Polymorphism and Generic Programming</em>, a function that implements different behaviors by taking parameters of type reference-to-base-class. But in the case of <kbd class="calibre12">std::iterator</kbd> this similarity is purely accidental and misleading; inheriting from <kbd class="calibre12">std::iterator</kbd> does <em class="calibre22">not</em> give us a polymorphic class hierarchy, and referring to that "base class" from our own functions is never the correct thing to do!</p>
<p class="calibre2">So, the C++17 standard deprecates <kbd class="calibre12">std::iterator</kbd> with an eye toward removing it completely in 2020 or some later standard. You shouldn't use <kbd class="calibre12">std::iterator</kbd> in code you write.</p>
<p class="calibre2">However, if you use Boost in your codebase, you might want to check out the Boost equivalent of <kbd class="calibre12">std::iterator</kbd>, which is spelled <kbd class="calibre12">boost::iterator_facade</kbd>. Unlike <kbd class="calibre12">std::iterator</kbd>, the <kbd class="calibre12">boost::iterator_facade</kbd> base class provides default functionality for pesky member functions such as <kbd class="calibre12">operator++(int)</kbd> and <kbd class="calibre12">operator!=</kbd> that would otherwise be tedious boilerplate. To use <kbd class="calibre12">iterator_facade</kbd>, simply inherit from it and define a few primitive member functions such as <kbd class="calibre12">dereference</kbd>, <kbd class="calibre12">increment</kbd>, and <kbd class="calibre12">equal</kbd>. (Since our list iterator is a <kbd class="calibre12">ForwardIterator</kbd>, that's all we need. For a <kbd class="calibre12">BidirectionalIterator</kbd> you would also need to provide a <kbd class="calibre12">decrement</kbd> member function, and so on.)</p>
<p class="calibre2">Since these primitive member functions are <kbd class="calibre12">private</kbd>, we grant Boost access to them via the declaration <kbd class="calibre12">friend class boost::iterator_core_access;</kbd>:</p>
<pre class="calibre23">    #include &lt;boost/iterator/iterator_facade.hpp&gt;<br class="title-page-name"/><br class="title-page-name"/>    template&lt;bool Const&gt;<br class="title-page-name"/>    class list_of_ints_iterator : public boost::iterator_facade&lt;<br class="title-page-name"/>      list_of_ints_iterator&lt;Const&gt;,<br class="title-page-name"/>      std::conditional_t&lt;Const, const int, int&gt;,<br class="title-page-name"/>      std::forward_iterator_tag<br class="title-page-name"/>    &gt;<br class="title-page-name"/>    {<br class="title-page-name"/>      friend class boost::iterator_core_access;<br class="title-page-name"/>      friend class list_of_ints;<br class="title-page-name"/>      friend class list_of_ints_iterator&lt;!Const&gt;;<br class="title-page-name"/><br class="title-page-name"/>      using node_pointer = std::conditional_t&lt;Const, const list_node*,<br class="title-page-name"/>        list_node*&gt;;<br class="title-page-name"/>      node_pointer ptr_;<br class="title-page-name"/><br class="title-page-name"/>      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {} <br class="title-page-name"/><br class="title-page-name"/>      auto&amp; dereference() const { return ptr_-&gt;data; }<br class="title-page-name"/>      void increment() { ptr_ = ptr_-&gt;next; }<br class="title-page-name"/><br class="title-page-name"/>      // Support comparison between iterator and const_iterator types<br class="title-page-name"/>      template&lt;bool R&gt;<br class="title-page-name"/>      bool equal(const list_of_ints_iterator&lt;R&gt;&amp; rhs) const {<br class="title-page-name"/>        return ptr_ == rhs.ptr_;}<br class="title-page-name"/><br class="title-page-name"/>    public:<br class="title-page-name"/>      // Support implicit conversion of iterator to const_iterator<br class="title-page-name"/>      // (but not vice versa)<br class="title-page-name"/>      operator list_of_ints_iterator&lt;true&gt;() const { return<br class="title-page-name"/>        list_of_ints_iterator&lt;true&gt;{ptr_}; }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Notice that the first template type argument to <kbd class="calibre12">boost::iterator_facade</kbd> is always the class whose definition you're writing: this is the Curiously Recurring Template Pattern, which we'll see again in <a target="_blank" href="part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 6</a>, <em class="calibre22">Smart Pointers</em>.</p>
<p class="calibre2">This list-iterator code using <kbd class="calibre12">boost::iterator_facade</kbd> is significantly shorter than the same code in the previous section; the savings comes mainly from not having to repeat the relational operators. Because our list iterator is a <kbd class="calibre12">ForwardIterator</kbd>, we only had two relational operators; but if it were a <kbd class="calibre12">RandomAccessIterator</kbd>, then <kbd class="calibre12">iterator_facade</kbd> would generate default implementations of operators <kbd class="calibre12">-</kbd>, <kbd class="calibre12">&lt;</kbd>, <kbd class="calibre12">&gt;</kbd>, <kbd class="calibre12">&lt;=</kbd>, and <kbd class="calibre12">&gt;=</kbd> all based on the single primitive member function <kbd class="calibre12">distance_to</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we've learned that traversal is one of the most fundamental things you can do with a data structure. However, raw pointers alone are insufficient for traversing complicated structures: applying <kbd class="calibre12">++</kbd> to a raw pointer often doesn't "go on to the next item" in the intended way.</p>
<p class="calibre2">The C++ Standard Template Library provides the concept of <em class="calibre22">iterator</em> as a generalization of raw pointers. Two iterators define a <em class="calibre22">range</em> of data. That range might be only part of the contents of a container; or it might be unbacked by any memory at all, as we saw with <kbd class="calibre12">getc_iterator</kbd> and <kbd class="calibre12">putc_iterator</kbd>. Some of the properties of an iterator type are encoded in its iterator category--input, output, forward, bidirectional, or random-access--for the benefit of function templates that can use faster algorithms on certain categories of iterators.</p>
<p class="calibre2">If you're defining your own container type, you'll need to define your own iterator types as well--both const and non-const versions. Templates are a handy way to do that. When implementing your own iterator types, avoid the deprecated <kbd class="calibre12">std::iterator</kbd>, but consider <kbd class="calibre12">boost::iterator_facade</kbd>.</p>


            

            
        
    </body></html>