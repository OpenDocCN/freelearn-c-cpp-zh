<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Using Audio Input and Output"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Using Audio Input and Output</h1></div></div></div><p>In this chapter, we will learn how to generate sounds using examples of ways to generate sounds driven by physics simulation. We will also present examples of visualizing sound with audio reactive animations.</p><p>The following recipes will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generating a sine oscillator</li><li class="listitem" style="list-style-type: disc">Generating sound with frequency modulation</li><li class="listitem" style="list-style-type: disc">Adding a delay effect</li><li class="listitem" style="list-style-type: disc">Generating sound upon the collision of objects</li><li class="listitem" style="list-style-type: disc">Visualizing FFT</li><li class="listitem" style="list-style-type: disc">Making sound-reactive particles</li></ul></div><div class="section" title="Generating a sine oscillator"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Generating a sine oscillator</h1></div></div></div><p>In this recipe, we <a id="id739" class="indexterm"/>will learn how to generatively create a sine wave oscillator by manipulating the sound card's <span class="strong"><strong>PCM</strong></span> (<span class="strong"><strong>Pulse-code Modulation</strong></span>
<a id="id740" class="indexterm"/>) audio buffer. The frequency of the sine wave will be defined by the mouse's y coordinate.</p><p>We will also draw the sine wave for a visual representation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec315"/>Getting ready</h2></div></div></div><p>Include the following files:</p><div class="informalexample"><pre class="programlisting">#include "cinder/audio/Output.h"
#include "cinder/audio/Callback.h"
#include "cinder/Rand.h"
#include "cinder/CinderMath.h"</pre></div><p>And add the following useful <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec316"/>How to do it…</h2></div></div></div><p>We will create a sine <a id="id741" class="indexterm"/>wave oscillator using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare the following member variables and the callback method:<div class="informalexample"><pre class="programlisting">void audioCallback( uint64_t inSampleOffset, uint32_t ioSampleCount, audio::Buffer32f *buffer );
float mFrequency;
float mPhase, mPhaseAdd;
vector&lt;float&gt; mOutput;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> module we will initialize the variables and create the audio callback using the following code:<div class="informalexample"><pre class="programlisting">mFrequency = 0.0f;
mPhase = 0.0f;
mPhaseAdd = 0.0f;
audio::Output::play( audio::createCallback( this, &amp;SineApp::audioCallback ) );</pre></div></li><li class="listitem">In the <code class="literal">update</code> module we will update <code class="literal">mFrequency</code> based on the mouse's <code class="literal">y</code> position. The mouse's position will be mapped and clamped to a frequency value between <code class="literal">0</code> and <code class="literal">5000</code>:<div class="informalexample"><pre class="programlisting">float maxFrequency = 5000.0f;
float targetFrequency = ( getMousePos().y / (float)getWindowHeight() ) * maxFrequency;
mFrequency = math&lt;float&gt;::clamp( targetFrequency, 0.0f, maxFrequency );</pre></div><p>Let's implement the audio callback. We'll begin by resizing <code class="literal">mOutput</code> if necessary. Then we will calculate and interpolate <code class="literal">mPhaseAdd</code>, and then loop through all the values in the audio buffer and calculate their values based on the sine of <code class="literal">mPhase</code> and add <code class="literal">mPhaseAdd</code> to <code class="literal">mPhase</code>:</p><div class="informalexample"><pre class="programlisting">if( mOutput.size() != ioSampleCount ){
 mOutput.resize( ioSampleCount );
}
int numChannels = buffer-&gt;mNumberChannels;
mPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;
for( int i=0; i&lt;ioSampleCount; i++ ){
 mPhase += mPhaseAdd;
 float output = math&lt;float&gt;::sin( mPhase * 2.0f * M_PI );
 for( int j=0; j&lt;numChannels; j++ ){
  buffer-&gt;mData[ i*numChannels + j ] = output;
 }
 mOutput[i] = output;
}</pre></div></li><li class="listitem">Finally, we need to draw the sine wave. In the <code class="literal">draw</code> method, we will clear the background with<a id="id742" class="indexterm"/> black and draw a scaled up sine wave with a line strip using the values stored in <code class="literal">mOutput</code>:<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) );
if( mOutput.size() &gt; 0 ){
 Vec2f scale;
 scale.x = (float)getWindowWidth() / (float)mOutput.size();
 scale.y = 100.0f;
 float centerY= getWindowHeight() / 2.0f;
 gl::begin( GL_LINE_STRIP );
 for( int i=0; i&lt;mOutput.size(); i++ ){
  float x = (float)i * scale.x;
  float y = mOutput[i] * scale.y + centerY;
  gl::vertex( x,  y );
 } 
 gl::end();
}</pre></div></li><li class="listitem">Build and run the application. Move the mouse vertically to change the frequency. A line representing the generated sine wave is shown in the following screenshot:<div class="mediaobject"><img src="graphics/8703OS_12_01.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec317"/>How it works…</h2></div></div></div><p>We are manipulating <a id="id743" class="indexterm"/>the PCM buffer. PCM is a method to represent audio through values' samples at regular intervals. By accessing the PCM buffer, we can directly manipulate the audio signal that will be output by the sound card.</p><p>Every time the <a id="id744" class="indexterm"/>
<code class="literal">audioCallback</code> method is called, we receive a sample of the PCM buffer, where we calculate the values to generate a continuous sine wave.</p><p>In the <code class="literal">update</code> module, we calculate the frequency by mapping the mouse's <code class="literal">y</code> position.</p><p>In the following line in the <code class="literal">audioCallback</code> implementation, we calculate how much <code class="literal">mPhase</code> has to increase based on a sample rate of <code class="literal">44100</code> to generate a wave with a frequency of <code class="literal">mFrequency</code>:</p><div class="informalexample"><pre class="programlisting">mPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;</pre></div></div></div></div>
<div class="section" title="Generating sound with frequency modulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec101"/>Generating sound with frequency modulation</h1></div></div></div><p>In this recipe, we will learn how to modulate a sine wave oscillator using another low frequency sine wave.<a id="id745" class="indexterm"/></p><p>We will be basing this recipe on the previous recipe, where the <code class="literal">y</code> position of the mouse controlled the frequency of the sine wave; in this recipe, we will use the <code class="literal">x</code> position of the mouse to control the modulation frequency.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec318"/>Getting ready</h2></div></div></div><p>We will be using the code from the previous recipe, <span class="emphasis"><em>Generating a sine oscillator</em></span>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec319"/>How to do it…</h2></div></div></div><p>We will multiply the sine wave created in the previous recipe with another low frequency sine wave.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following member variables:<div class="informalexample"><pre class="programlisting">float mModFrequency;
float mModPhase, mModPhaseAdd;</pre></div></li><li class="listitem">Add the following in the <code class="literal">setup</code> module to initialize the variables created previously:<div class="informalexample"><pre class="programlisting">mModFrequency = 0.0f;
mModPhase = 0.0f;
mModPhaseAdd = 0.0f;</pre></div></li><li class="listitem">In the <code class="literal">update</code> module, add the following code to calculate the modulation frequency based on the <code class="literal">x</code> position of the mouse cursor:<div class="informalexample"><pre class="programlisting">float maxModFrequency= 30.0f;
float targetModFrequency= ( getMousePos().x / (float)getWindowWidth() ) * maxModFrequency;
mModFrequency = math&lt;float&gt;::clamp( targetModFrequency, 0.0f, maxModFrequency );</pre></div></li><li class="listitem">We will need to calculate another sine wave using <code class="literal">mModFrequency</code>, <code class="literal">mModPhase</code>, and <code class="literal">mModPhaseAdd</code>, and use it to modulate our first sine wave.<p>The following is the implementation of <code class="literal">audioCallback</code>:</p><div class="informalexample"><pre class="programlisting">if( mOutput.size() != ioSampleCount ){
 mOutput.resize( ioSampleCount );
}
mPhaseAdd += ( ( mFrequency / 44100.0f ) - mPhaseAdd ) * 0.1f;
mModPhaseAdd += ( ( mModFrequency / 44100.0f ) - mModPhaseAdd )
  * 0.1f;
int numChannels= buffer-&gt;mNumberChannels;
for( int i=0; i&lt;ioSampleCount; i++ ){
 mPhase += mPhaseAdd;
 mModPhase += mModPhaseAdd;
 float output = math&lt;float&gt;::sin( mPhase * 2.0f * M_PI ) 
   * math&lt;float&gt;::sin( mModPhase * 2.0f * M_PI );
 for( int j=0; j&lt;numChannels; j++ ){
  buffer-&gt;mData[ i*numChannels + j ] = output;
 }
 mOutput[i] = output;
}</pre></div></li><li class="listitem">Build and run the application. Move the mouse cursor over the y axis to determine the <a id="id746" class="indexterm"/>frequency, and over the x axis to determine the modulation frequency.</li></ol></div><p>We can see how the sine wave created changes in the previous recipe, in the amplitude as it is multiplied by another low frequency sine wave.</p><div class="mediaobject"><img src="graphics/8703OS_12_02.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec320"/>How it works…</h2></div></div></div><p>We calculate a second sine<a id="id747" class="indexterm"/> wave with a <span class="strong"><strong>low frequency oscillation</strong></span> (<span class="strong"><strong>LFO</strong></span>) and use<a id="id748" class="indexterm"/> it to modulate the first sine wave. To modulate the waves, we multiply them by each other.</p></div></div>
<div class="section" title="Adding a delay effect"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec102"/>Adding a delay effect</h1></div></div></div><p>In this recipe, we will learn how to<a id="id749" class="indexterm"/> add a delay effect to the frequency modulation audio generated in the previous recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec321"/>Getting ready</h2></div></div></div><p>We will use the source code from the previous recipe, <span class="emphasis"><em>Generating sound with frequency modulation</em></span>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec322"/>How to do it…</h2></div></div></div><p>We will store our audio values and <a id="id750" class="indexterm"/>play them after an interval to achieve a delay effect using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following member variables:<div class="informalexample"><pre class="programlisting">int mDelay;
float mMix, mFeedback;
vector&lt;float&gt; mDelayLine;
int mDelayIndex;
int mDelaySize;</pre></div><p>Let's initialize the variables created above and initialize our delay line with zeros.</p><p>Then add the following in the <code class="literal">setup</code> method:</p><div class="informalexample"><pre class="programlisting">mDelay = 200;
mMix = 0.2f;
mFeedback = 0.3f;
mDelaySize = mDelay * 44.1f;
for( int i=0; i&lt;mDelaySize; i++ ){
 mDelayLine.push_back( 0.0f );
}</pre></div></li><li class="listitem">In the implementation of our <a id="id751" class="indexterm"/><code class="literal">audioCallback</code> method, we will read back from the buffer the values that were generated in the frequency modulation and calculate the delay.<p>The final value is again passed into the buffer for output.</p><p>Add the following code in the <code class="literal">audioCallback</code> method:</p><div class="informalexample"><pre class="programlisting">for( int i=0; i&lt;ioSampleCount; i++ ){
 float output = buffer-&gt;mData[ i*numChannels ];
 int readIndex= mDelayIndex - mDelaySize + 1;
 if( readIndex&lt; 0 ) readIndex += mDelaySize;
 float delay = mDelayLine[ readIndex * numChannels ];
 mDelayLine[ mDelayIndex ] = output + delay * mFeedback;
 if( ++mDelayIndex == mDelaySize ){
  mDelayIndex = 0;
 }
 output = math&lt;float&gt;::clamp(output+mMix*delay,-1.0f,1.0f);
 mOutput[i] = output;
 for( int j=0; j&lt;numChannels; j++ ){
  buffer-&gt;mData[ i*numChannels + j ] = output;
 } 
}</pre></div></li><li class="listitem">Build and run the<a id="id752" class="indexterm"/> application. By moving the mouse in the x axis, you control the oscillator frequency, and by moving the mouse in the y axis, you control the modulation frequency. The output will contain a delay effect as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8703OS_12_03.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec323"/>How it works...</h2></div></div></div><p>A delay is an audio effect where an input is stored and then played back after a determined amount of time. <a id="id753" class="indexterm"/>We achieve this by creating a buffer the size of <code class="literal">mDelay</code> multiplied by the frequency rate. Each time <code class="literal">audioCallback</code> gets called, we read from the delay line and update the delay line with the current output value. We then add the delay value to the output and advance <code class="literal">mDelayIndex</code>.</p></div></div>
<div class="section" title="Generating sound upon the collision of objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec103"/>Generating sound upon the collision of objects</h1></div></div></div><p>In this recipe, we will learn how to apply simple physics to object particles and generate sound upon the collision of two objects.<a id="id754" class="indexterm"/></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec324"/>Getting ready</h2></div></div></div><p>In this example, we are using code described in the recipe <span class="emphasis"><em>Generating a sine oscillator</em></span> in this chapter, so please refer to that recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec325"/>How to do it…</h2></div></div></div><p>We will create a Cinder application to illustrate the mechanism:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the following necessary header files:<div class="informalexample"><pre class="programlisting">#include "cinder/audio/Output.h"
#include "cinder/audio/Callback.h"
#include "cinder/Rand.h"
#include "cinder/CinderMath.h"
#include "ParticleSystem.h"</pre></div></li><li class="listitem">Add members to the application's <code class="literal">main</code> class for particle simulation:<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;
Vec2fattrPosition;
float attrFactor;
float attrRadius;</pre></div></li><li class="listitem">Add members to the application's <code class="literal">main</code> class to make the particles interactive:<div class="informalexample"><pre class="programlisting">bool    dragging;
Particle *dragParticle;</pre></div></li><li class="listitem">Add members for the generation of sound:<div class="informalexample"><pre class="programlisting">void audioCallback( uint64_t inSampleOffset, uint32_t ioSampleCount,audio::Buffer32f *buffer );
float mSndFrequency;
float mPhase, mPhaseAdd;
vector&lt;float&gt; mOutput;</pre></div></li><li class="listitem">Initialize the particle system inside the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mRunning= true;
dragging = false;
attrPosition = getWindowCenter();
attrRadius = 75.f;
attrFactor = 0.02f;
int numParticle= 10;
for( int i=0; i&lt;numParticle; i++ ){
 float x = Rand::randFloat( 0.0f, getWindowWidth() );
 float y = Rand::randFloat( 0.0f, getWindowHeight() );
 float radius = Rand::randFloat(2.f, 40.f);
 Rand::randomize();
 float mass = radius;
 float drag = 0.95f;
 Particle *particle = new Particle( Vec2f( x, y ), radius,
  mass, drag );
 mParticleSystem.addParticle( particle );
}</pre></div></li><li class="listitem">Initialize the members<a id="id755" class="indexterm"/> to generate sound and register an audio callback inside the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mSndFrequency = 0.0f;
mPhase = 0.0f;
mPhaseAdd = 0.0f;
audio::Output::play( audio::createCallback( this, &amp;MainApp::audioCallback ) );</pre></div></li><li class="listitem">Implement the <code class="literal">resize</code> method<a id="id756" class="indexterm"/> to update the attractor position whenever an application window will be resized:<div class="informalexample"><pre class="programlisting">void MainApp::resize(ResizeEvent event)
{
  attrPosition = getWindowCenter();
}</pre></div></li><li class="listitem">Implement the mouse events handlers for mouse interaction with particles:<div class="informalexample"><pre class="programlisting">void MainApp::mouseDown(MouseEvent event)</pre></div><div class="informalexample"><pre class="programlisting">{
 dragging = false;
 std::vector&lt;Particle*&gt;::iterator it;
 for( it = mParticleSystem.particles.begin(); 
   it != mParticleSystem.particles.end(); ++it ) {
  if( (*it)-&gt;position.distance(event.getPos()) 
    &lt; (*it)-&gt;radius ) {
   dragging = true;
   dragParticle = (*it);
  }
 }
}

void MainApp::mouseUp(MouseEvent event) {
 dragging = false;
}</pre></div></li><li class="listitem">Inside the <code class="literal">update</code><a id="id757" class="indexterm"/> method, add the following code for sound frequency calculation:<div class="informalexample"><pre class="programlisting">float maxFrequency = 15000.0f;
float targetFrequency = ( getMousePos().y / (float)getWindowHeight() ) * maxFrequency;
targetFrequency = mSndFrequency - 10000.f;
mSndFrequency = math&lt;float&gt;::clamp( targetFrequency, 0.0f, maxFrequency );</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> method, add the following code for particle movement calculation. At this point, we are detecting collisions and calculating the sound frequency:<div class="informalexample"><pre class="programlisting">std::vector&lt;Particle*&gt;::iterator it;
for( it = mParticleSystem.particles.begin(); 
  it != mParticleSystem.particles.end(); ++it ) {
 std::vector&lt;Particle*&gt;::iterator it2;
 for( it2 = mParticleSystem.particles.begin(); 
   it2 != mParticleSystem.particles.end(); ++it2 ) {
  float d = (*it)-&gt;position.distance( (*it2)-&gt;position );
  float d2 = (*it)-&gt;radius + (*it2)-&gt;radius;
  if(d &gt;0.f&amp;&amp; d &lt;= d2 ) {
   (*it)-&gt;forces += -1.1f * ( (*it2)-&gt;position 
     - (*it)-&gt;position );
   (*it2)-&gt;forces += -1.1f * ( (*it)-&gt;position 
     - (*it2)-&gt;position );
   mSndFrequency = 2000.f;
   mSndFrequency+= 10000.f
     * (1.f - ((*it)-&gt;radius / 40.f));
   mSndFrequency+= 10000.f 
     * (1.f - ((*it2)-&gt;radius / 40.f));
  }
 }
 Vec2f attrForce = attrPosition - (*it)-&gt;position;
 attrForce *= attrFactor;
 (*it)-&gt;forces += attrForce;
}
mSndFrequency = math&lt;float&gt;::clamp( mSndFrequency, 
 0.0f, maxFrequency );maxFrequency );</pre></div></li><li class="listitem">Update position of dragging particle, if any, and update particle system:<div class="informalexample"><pre class="programlisting">if(dragging) {
  dragParticle-&gt;forces = Vec2f::zero();
  dragParticle-&gt;position = getMousePos();
}

mParticleSystem.update();</pre></div></li><li class="listitem">Draw particles by<a id="id758" class="indexterm"/> implementing the <code class="literal">draw</code> method as follows:<div class="informalexample"><pre class="programlisting">gl::clear( Color::white() );
gl::setViewport(getWindowBounds());
gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );
gl::color( Color::black() );
mParticleSystem.draw();</pre></div></li><li class="listitem">Implement audio callback handler as covered in the recipe <span class="emphasis"><em>Generating a sine oscillator</em></span>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec326"/>How it works…</h2></div></div></div><p>We are generating random particles with applied physics and collision detection. While collision is detected, a frequency of a sine wave is calculated based on the particles' radii.</p><div class="mediaobject"><img src="graphics/8703OS_12_04.jpg" alt="How it works…"/></div><p>Inside the <code class="literal">update</code> method, <a id="id759" class="indexterm"/>we are iterating through the particles and checking the distance between each of them to detect collision, if it occurs. A generated frequency is calculated from the radii of the colliding particles—the bigger the radius, the lower the frequency of the sound.</p></div></div>
<div class="section" title="Visualizing FFT"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec104"/>Visualizing FFT</h1></div></div></div><p>In this recipe, <a id="id760" class="indexterm"/>we will show an <a id="id761" class="indexterm"/>example of <span class="strong"><strong>FFT</strong></span> (<span class="strong"><strong>Fast Fourier Transform</strong></span>) data visualization on a circular layout with some smooth animation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec327"/>Getting ready</h2></div></div></div><p>Save you favorite music piece in assets folder with the name <code class="literal">music.mp3</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec328"/>How to do it…</h2></div></div></div><p>We will create visualization <a id="id762" class="indexterm"/>based on an example FFT analysis using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the following necessary header files:<div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/audio/Io.h"
#include "cinder/audio/Output.h"
#include "cinder/audio/FftProcessor.h"
#include "cinder/audio/PcmBuffer.h"</pre></div></li><li class="listitem">Add the following members to your main application class:<div class="informalexample"><pre class="programlisting">void drawFft();
audio::TrackRef mTrack;
audio::PcmBuffer32fRef mPcmBuffer;
uint16_t bandCount;
float levels[32];
float levelsPts[32];</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method, initialize the members and load the sound file from the assets folder. We are decomposing the signal into 32 frequencies using FFT:<div class="informalexample"><pre class="programlisting">bandCount = 32;
std::fill(boost::begin(levels), boost::end(levels), 0.f);
std::fill(boost::begin(levelsPts), boost::end(levelsPts), 0.f);
mTrack = audio::Output::addTrack( audio::load( getAssetPath("music.mp3").c_str() ) );
mTrack-&gt;enablePcmBuffering( true );</pre></div></li><li class="listitem">Implement the <code class="literal">update</code> method as follows:<div class="informalexample"><pre class="programlisting">mPcmBuffer = mTrack-&gt;getPcmBuffer();
for( int i = 0; i&lt; ( bandCount ); i++ ) {
  levels[i] = max(0.f, levels[i] - 1.f );
  levelsPts[i] = max(0.f, levelsPts[i] - 0.95f );
}</pre></div></li><li class="listitem">Implement the <code class="literal">draw</code> method as follows:<div class="informalexample"><pre class="programlisting">gl::enableAlphaBlending();
gl::clear( Color( 1.0f, 1.0f, 1.0f ) );
gl::color( Color::black() );
gl::pushMatrices();
gl::translate(getWindowCenter());
gl::rotate( getElapsedSeconds() * 10.f );
drawFft();
gl::popMatrices();</pre></div></li><li class="listitem">Implement the <code class="literal">drawFft</code> method as follows:<div class="informalexample"><pre class="programlisting">float centerMargin= 25.0f;
if( !mPcmBuffer ) return;
std::shared_ptr&lt;float&gt; fftRef = audio::calculateFft( 
 mPcmBuffer-&gt;getChannelData( audio::CHANNEL_FRONT_LEFT ), 
 bandCount );
if( !fftRef ) {
return;
}
float *fftBuffer = fftRef.get();
gl::color( Color::black() );
gl::drawSolidCircle(Vec2f::zero(), 5.f);
glLineWidth(3.f);
float avgLvl= 0.f;
for( int i= 0; i&lt;bandCount; i++ ) {
  Vec2f p = Vec2f(0.f, 500.f);
  p.rotate( 2.f * M_PI * (i/(float)bandCount) );
  float lvl = fftBuffer[i] / bandCount * p.length();
  lvl = min(lvl, p.length());
  levels[i] = max(levels[i], lvl);
  levelsPts[i] = max(levelsPts[i], levels[i]);
  p.limit(1.f + centerMargin + levels[i]);
  gl::drawLine(p.limited(centerMargin), p);
  glPointSize(2.f);
  glBegin(GL_POINTS);
  gl::vertex(p+p.normalized()*levelsPts[i]);
  glEnd();
  glPointSize(1.f);
  avgLvl += lvl;
}
avgLvl /= (float)bandCount; glLineWidth(1.f);
gl::color( ColorA(0.f,0.f,0.f, 0.1f) );
gl::drawSolidCircle(Vec2f::zero(), 5.f+avgLvl);</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec329"/>How it works…</h2></div></div></div><p>We can divide visualization into<a id="id763" class="indexterm"/> bands, and the grey circle with alpha in the center. Bands are straight representations of data calculated by the <code class="literal">audio::calculateFft</code> function, and animated with some smoothing by going back towards the center. The grey circle shown in the following screenshot represents the average level of all the bands.</p><p>FFT is an <a id="id764" class="indexterm"/>algorithm to compute<a id="id765" class="indexterm"/> <span class="strong"><strong>DFT</strong></span> (<span class="strong"><strong>Discrete Fourier Transform</strong></span>), which decomposes the signal into list of different frequencies.</p><div class="mediaobject"><img src="graphics/8703OS_12_05.jpg" alt="How it works…"/></div></div></div>
<div class="section" title="Making sound-reactive particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec105"/>Making sound-reactive particles</h1></div></div></div><p>In this recipe, we will show an<a id="id766" class="indexterm"/> example of audio visualization based on audio-reactive particles.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec330"/>Getting ready</h2></div></div></div><p>Save your favorite music piece in assets folder with the name <code class="literal">music.mp3</code>.</p><p>Please refer<a id="id767" class="indexterm"/> to <a class="link" href="ch06.html" title="Chapter 6. Rendering and Texturing Particle Systems">Chapter 6</a>, <span class="emphasis"><em>Adding a Tail to Our Particles</em></span>, for instructions on how to draw particles with a tile.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec331"/>How to do it…</h2></div></div></div><p>We will create a sample audio-reactive visualization using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following necessary header files:<div class="informalexample"><pre class="programlisting">#include "cinder/Rand.h"
#include "cinder/MayaCamUI.h"
#include "cinder/audio/Io.h"
#include "cinder/audio/Output.h"
#include "cinder/audio/FftProcessor.h"
#include "cinder/audio/PcmBuffer.h"
#include "ParticleSystem.h"</pre></div></li><li class="listitem">Add the following members for audio playback and analysis:<div class="informalexample"><pre class="programlisting">audio::TrackRef mTrack;
audio::PcmBuffer32fRef mPcmBuffer;
float beatForce;
float beatSensitivity;
float avgLvlOld;
float randAngle;</pre></div></li><li class="listitem">Add the following members for particle simulation:<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;
Vec3f   attrPosition;
float attrFactor;
CameraPersp mCam;</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method, initialize the simulation of the members and particles:<div class="informalexample"><pre class="programlisting">beatForce = 150.f;
beatSensitivity = 0.03f;
avgLvlOld = 0.f;
randAngle = 15.f;
attrPosition = Vec3f::zero();
attrFactor = 0.05f;
int numParticle = 450;
for( int i=0; i&lt;numParticle; i++ ){
 float x = Rand::randFloat( 0.0f, getWindowWidth() );
 float y = Rand::randFloat( 0.0f, getWindowHeight() );
 float z = Rand::randFloat( 0.0f, getWindowHeight() );
 float radius = Rand::randFloat(2.f, 5.f);
 float mass = radius;
 if(i&gt;300) {
  radius = 1.f;
  mass = 1.0f; 
 }
 float drag = 0.95f;
 Particle *particle = new Particle( Vec3f( x, y, z ), radius,
  mass, drag );
 mParticleSystem.addParticle( particle );
}</pre></div></li><li class="listitem">Inside the <code class="literal">setup</code> method, initialize camera and audio playback:<div class="informalexample"><pre class="programlisting">mCam.setPerspective(45.0f, 640.f/480.f, 0.1, 10000);
mCam.setEyePoint(Vec3f(0.f,0.f,500.f));
mCam.setCenterOfInterestPoint(Vec3f::zero());
mTrack = audio::Output::addTrack( audio::load( getAssetPath("music.mp3").c_str() ) );
mTrack-&gt;enablePcmBuffering( true );</pre></div></li><li class="listitem">Implement <a id="id768" class="indexterm"/>the <code class="literal">resize</code> method for updating camera properties in regards to resizing windows:<div class="informalexample"><pre class="programlisting">void MainApp::resize(ResizeEvent event)
{
mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);
}</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> method, implement a simple beat detection. We are decomposing the signal into 32 frequencies using FFT:<div class="informalexample"><pre class="programlisting">float beatValue = 0.f;
mPcmBuffer = mTrack-&gt;getPcmBuffer();
if( mPcmBuffer ) {
 int bandCount= 32;
 std::shared_ptr&lt;float&gt; fftRef = audio::calculateFft( 
  mPcmBuffer-&gt;getChannelData( audio::CHANNEL_FRONT_LEFT ), 
  bandCount );
 if( fftRef ) {
  float * fftBuffer = fftRef.get();
  float avgLvl= 0.f;
  for( int i= 0; i&lt;bandCount; i++ ) {
   avgLvl += fftBuffer[i] / (float)bandCount;
  }
  avgLvl /= (float)bandCount;
  if(avgLvl&gt;avgLvlOld+beatSensitivity) {
   beatValue = avgLvl - beatSensitivity;
  }
  avgLvlOld = avgLvl;
 }
}</pre></div></li><li class="listitem">Also, inside <a id="id769" class="indexterm"/>the <code class="literal">update</code> method, calculate the particle simulation:<div class="informalexample"><pre class="programlisting">std::vector&lt;Particle*&gt;::iterator it;
for( it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {
    Vec3f attrForce = attrPosition - (*it)-&gt;position;
attrForce *= attrFactor;
if( attrPosition.distance( (*it)-&gt;position ) &lt;100.f ) {
  attrForce = (*it)-&gt;position - attrPosition;
  attrForce *= 0.02f;
    }
    (*it)-&gt;forces += attrForce;
    Vec3f bearForceVec = (*it)-&gt;position - attrPosition;
    bearForceVec.normalize();
    bearForceVec.rotate(randVec3f(), randAngle);
    bearForceVec *= beatValue*randFloat(beatForce*0.5f, beatForce);
    (*it)-&gt;forces += bearForceVec;
    std::vector&lt;Particle*&gt;::iterator it2;
    for( it2 = mParticleSystem.particles.begin(); it2 != mParticleSystem.particles.end(); ++it2 ) {
        (*it)-&gt;forces +=  ( (*it)-&gt;position - (*it2)-&gt;position ) *0.5f * 0.0001f;
    }
}
mParticleSystem.update();</pre></div></li><li class="listitem">Implement the <code class="literal">draw</code> method as follows:<div class="informalexample"><pre class="programlisting">gl::enableAlphaBlending();
gl::clear( ColorA::white() );
gl::setViewport(getWindowBounds());
gl::setModelView(mCam);
float r = getElapsedSeconds()*10.f;
gl::rotate(Vec3f::one()*r);
mParticleSystem.draw();</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec332"/>How it works…</h2></div></div></div><p>A particle is drawn as a black dot, or more precisely a sphere and a line as a tail. Due to specific frequency <a id="id770" class="indexterm"/>difference, forces repelling particles from the center of the attractor are applied, with a random vector added to these forces.</p><div class="mediaobject"><img src="graphics/8703OS_12_06.jpg" alt="How it works…"/></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec333"/>There's more…</h2></div></div></div><p>You might want to customize the visualization for a specific music piece.</p><div class="section" title="Adding GUI to tweak parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec21"/>Adding GUI to tweak parameters</h3></div></div></div><p>We will add GUI<a id="id771" class="indexterm"/> that affects particles' behavior using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following necessary header file:<div class="informalexample"><pre class="programlisting">#include "cinder/params/Params.h"</pre></div></li><li class="listitem">Add the following member to your application's <code class="literal">main</code> class:<div class="informalexample"><pre class="programlisting">params::InterfaceGl    mParams;</pre></div></li><li class="listitem">At the end of the <code class="literal">setup</code> method, initialize GUI using the following code:<div class="informalexample"><pre class="programlisting">mParams = params::InterfaceGl( "Parameters", Vec2i( 200, 100 ) );
mParams.addParam( "beatForce", &amp;beatForce, "step=0.01" );
mParams.addParam( "beatSensitivity", &amp;beatSensitivity, "step=0.01" );
mParams.addParam( "randAngle", &amp;randAngle, "step=0.01" );</pre></div></li><li class="listitem">At the and of the <code class="literal">draw</code> method, add the following code:<div class="informalexample"><pre class="programlisting">params::InterfaceGl::draw();</pre></div></li></ol></div></div></div></div></body></html>