- en: Chapter 7. Using 2D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work and draw with 2D graphics and built-in
    Cinder tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 2D geometric primitives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing arbitrary shapes with the mouse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a scribbler algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 2D metaballs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating text around curves
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a blur effect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a force-directed graph
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing 2D geometric primitives
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to draw the following 2D geometric shapes,
    as filled and stroked shapes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Circle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipse
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Include the necessary header to draw in OpenGL using Cinder commands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code at the top of your source file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create several geometric primitives using Cinder''s methods for drawing
    in 2D. Perform the following steps to do so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by declaring member variables to keep information about the shapes
    we will be drawing.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two `ci::Vec2f` objects to store the beginning and end of a line, a `ci::Rectf`
    object to draw a rectangle, a `ci::Vec2f` object to define the center of the circle,
    and a `float` object to define its radius. Finally, we will create `aci::Vec2f`
    to define the ellipse's radius and two `float` objects to define its width and
    height.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's also declare two `ci::Color` objects to define the stroke and fill colors.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `setup` method, let''s initialize the preceding members:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `draw` method, let's start by drawing filled shapes.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's clear the background and set `mFillColor` to be the drawing color.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Draw the filled shapes by calling the `ci::gl::drawSolidRect`, `ci::gl::drawSolidCircle`,
    and `ci::gl::drawSolidEllipse` methods.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the `draw` method:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To draw our shapes as stroked graphics, let's first set `mStrokeColor` as the
    drawing color.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's draw our shapes again, this time using only strokes by calling the `ci::gl::drawLine`,
    `ci::gl::drawStrokeRect`, `ci::gl::drawStrokeCircle`, and `ci::gl::drawStrokedEllipse`
    methods.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the `draw` method:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This results in the following:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/8703OS_07_01.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cinder's drawing methods use OpenGL calls internally to provide fast and easy
    drawing routines.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::gl::color` method sets the drawing color so that all shapes will be
    drawn with that color until another is set by calling `ci::gl::color` again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also set the stroke width by calling the `glLineWidth` method and passing
    a `float` value as a parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to set the stroke to be 5 pixels wide you should write the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Drawing arbitrary shapes with the mouse
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to draw arbitrary shapes using the mouse.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We will begin a new contour every time the user presses the mouse button, and
    draw when the user drags the mouse.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The shape will be drawn using fill and stroke.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Include the necessary files to draw and create a `ci::Shape2d` object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code snippet at the top of your source file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `ci::Shape2d` object and create vertices using mouse coordinates.
    Perform the following steps to do so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `ci::Shape2d` object to define our shape and two `ci::Color` objects
    to define the fill and stroke colors.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initialize the colors in the `setup` method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be using black for stroke and yellow for fill.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the drawing will be made with the mouse, it is necessary to use the `mouseDown`
    and `mouseDrag` events.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the necessary callback methods.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the implementation of `mouseDown` we will create a new contour by calling
    the `moveTo` method.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows what the method should look like:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `mouseDrag` method we will add a line to our shape by calling the `lineTo`
    method.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Its implementation should look like the following code snippet:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `draw` method, we will first need to clear the background, then set `mFillColor`
    as the drawing color, and draw `mShape`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All there is left to do is to set `mStrokeColor` as the drawing color and draw
    `mShape` as a stroked shape.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Build and run the application. Press the mouse button to begin drawing a new
    contour, and drag to draw.![How to do it…](img/8703OS_07_02.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ci:Shape2d` is a class that defines an arbitrary shape in two dimensions allowing
    multiple contours.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::Shape2d::moveTo` method creates a new contour starting at the coordinate
    passed as a parameter. Then, the `ci::Shape2d::lineTo` method creates a straight
    line from the last position to the coordinate which is passed as a parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The shape is internally tessellated into triangles when drawing a solid graphic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to add curves when constructing a shape using `ci::Shape2d`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Explanation |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `quadTo (constVec2f& p1, constVec2f& p2)` | Adds a quadratic curve from the
    last position to `p2`, using `p1` as a control point |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `curveTo (constVec2f& p1, constVec2f& p2, constVec2f& p3)` | Adds a curve
    from the last position to `p3`, using `p1` and `p2` as control points |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `arcTo (constVec2f& p, constVec2f& t, float radius)` | Adds an arc from the
    last position to `p1` using `t` as the tangent point and radius as the arc''s
    radius |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: Implementing a scribbler algorithm
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement a scribbler algorithm, which is very
    simple to implement using Cinder but gives an interesting effect while drawing.
    You can read more about the concept of connecting neighbor points at [http://www.zefrank.com/scribbler/about.html](http://www.zefrank.com/scribbler/about.html).
    You can find an example of scribbler at [http://www.zefrank.com/scribbler/](http://www.zefrank.com/scribbler/)
    or [http://mrdoob.com/projects/harmony/](http://mrdoob.com/projects/harmony/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement an application illustrating scribbler. Perform the following
    steps to do so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary headers:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add properties to your main application class:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `setup` method, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since the drawing will be made with the mouse, it is necessary to use the `mouseDown`
    and `mouseUp` events. Implement these methods, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, the implementation of drawing methods looks like the following code
    snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the left mouse button is down, we are adding a new point to our container
    and drawing lines connecting it with other points near it. The distance between
    the newly-added point and the points in its neighborhood we are looking for to
    draw a connection line has to be less than the value of the `mMaxDist` property.
    Please notice that we are clearing the drawing area only once, at the program
    startup at the end of the `setup` method, so we don't have to redraw all the connections
    to each frame, which would be very slow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Implementing 2D metaballs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can implement organic looking objects called
    metaballs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code base from the *Applying repulsion
    and attraction forces* recipe in [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement the metaballs'' rendering using a shader program. Perform
    the following steps to do so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file inside the `assets` folder with a name, `passThru_vert.glsl`,
    and put the following code snippet inside it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file inside the `assets` folder with a name, `mb_frag.glsl`, and put
    the following code snippet inside it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add the necessary header files.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add a property to your application's main class, which is the `GlslProg` object
    for our GLSL shader program.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `setup` method, change the values of `repulsionFactor` and `numParticle`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the end of the `setup` method, load our GLSL shader program, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last major change is in the `draw` method, which looks like the following
    code snippet:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important part of this recipe is the fragment shader program mentioned
    in step 2\. The shader generates texture with rendered metaballs based on the
    positions and radius passed to the shader from our particle system. In step 7,
    you can find out how to pass information to the shader program. We are using `setMatricesWindow`
    and `setViewport` to set OpenGL for drawing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A Wikipedia article on metaballs**: [http://en.wikipedia.org/wiki/Metaballs](http://en.wikipedia.org/wiki/Metaballs)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating text around curves
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can animate text around a user-defined
    curve.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We will create the `Letter` and `Word` classes to manage the animation, a `ci::Path2d`
    object to define the curve, and a `ci::Timer` object to define the duration of
    the animation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create and add the following files to your project:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`Word.h`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Word.cpp`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Letter.h`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Letter.cpp`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a word and animate its letters along a `ci::Path2d` object.
    Perform the following steps to do so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In the `Letter.h` file, include the necessary to use the `text`, `ci::Vec2f`,
    and `ci::gl::Texture` files.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also add the `#pragma once` macro
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Declare the `Letter` class with the following members and methods:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Move to the `Letter.cpp` file to implement the class.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, create a `ci::TextBox` object, set its parameters, and
    render it to texture. Also, set the width as the texture''s width plus a padding
    value of 10:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `draw` method, we will draw the texture and use OpenGL transformations
    to translate the texture to its position, and rotate according to the rotation:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `setPos` method implementation, we will update the position and calculate
    its rotation so that the letter is perpendicular to its movement. We do this by
    calculating the arc tangent of its velocity:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Letter` class is ready! Now move to the `Word.h` file, add the `#pragma
    once` macro, and include the `Letter.h` file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare the `Word` class with the following members and methods:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Move to the `Word.cpp` file and include the `Word.h` file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the constructor, we will iterate over each character of `text` and add a
    new `Letter` object.We will also calculate the total length of the text by calculating
    the sum of widths of all the letters:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the destructor, we will delete all the `Letter` objects to clean up memory
    used by the class:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `update` method, we will pass a reference to the `ci::Path2d` object,
    the total length of the path, and the progress of the animation as a normalized
    value from 0.0 to 1.0.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will calculate the position of each individual letter along the curve taking
    into account the length of `Word` and the current progress:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `draw` method, we will iterate over all letters and call the `draw`
    method of each letter:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the `Word` and `Letter` classes ready, it''s time to move to our application''s
    class source file. Start by including the necessary source files and adding the
    helpful `using` statements:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare the following members:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `setup` method, we will start by creating `std::string` and `ci::Font`
    and use them to initialize `mWord`. We will also initialize `mSeconds` with the
    seconds we want our animation to last for:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We now need to create the curve by creating the keypoints and connecting them
    by calling `curveTo`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s calculate the length of the path by summing the distance between each
    point and the one next to it. Add the following code snippet inside the `setup`
    method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to check if `mTimer` is running and calculate the progress by calculating
    the ratio between the elapsed seconds and `mSeconds`. Add the following code snippet
    inside the `update` method:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `draw` method, we will need to clear the background, enable alpha blending,
    draw `mWord`, and draw the path:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, we need to start the timer whenever the user presses any key.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `keyUp` event handler:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And the following is the implementation of the the `keyUp` event handler:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Build and run the application. Press any key to begin the animation.![How to
    do it…](img/8703OS_07_05.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a blur effect
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can apply a blur effect while drawing a
    texture.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use a Gaussian blur shader provided by Geeks3D
    at [http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/](http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement a sample Cinder application to illustrate the mechanism.
    Perform the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file inside the `assets` folder with the name `passThru_vert.glsl`
    and put the following code snippet inside it:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a file inside the `assets` folder with the name `gaussian_v_frag.glsland`
    and put the following code snippet inside it:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a file inside the `assets` folder with the name `gaussian_h_frag.glsl`
    and put the following code snippet inside it:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the necessary headers:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the properties to your application''s main class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `setup` method, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At the beginning of the `draw` method calculate the blur intensity:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `draw` function render an image to `mFboBlur1` with a first step shader
    applied:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `draw` function render a texture from `mFboBlur1` with a second step
    shader applied:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Set `mImageBlur` to the result texture from `mFboBlur2`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the end of the `draw` method draw a texture with the result and GUI:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a Gaussian blur shader needs to be applied twice—for the vertical and
    horizontal processing—we have to use **frame buffer object** (**FBO** ), a mechanism
    of drawing to the texture in the memory of graphic card. In step 8, we are drawing
    the original image from the `mImage` object and applying shader program stored
    in the `gaussian_v_frag.glsl` file loaded into `mGaussianVShaderobject`. At this
    point, everything is drawn into `mFboBlur1`. The next step is to use a texture
    from `mFboBlur2` and apply a shader to the second pass which you can find in step
    9\. The final processed texture is stored in `mImageBlur` in step 10\. In step
    7 we are calculating blur intensity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_06.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Implementing a force-directed graph
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A force-directed graph is a way of drawing an aesthetic graph using simple physics
    such as repealing and springs. We are going to make our graph interactive so that
    users can drag nodes around and see how graph reorganizes itself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the code base from the *Creating a particle
    system in 2D* recipe in [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. To get some details of how to draw nodes and connections
    between them, please refer to the *Connecting particles* recipe in [Chapter 6](ch06.html
    "Chapter 6. Rendering and Texturing Particle Systems"), *Rendering and Texturing
    Particle Systems*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用[第5章](ch05.html "第5章。构建粒子系统")中*Building Particle Systems*食谱的代码库，即*在2D中创建粒子系统*。有关如何绘制节点及其之间连接的详细信息，请参阅[第6章](ch06.html
    "第6章。渲染和纹理化粒子系统")中的*Connecting particles*食谱，*Rendering and Texturing Particle
    Systems*。
- en: How to do it…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will create an interactive force-directed graph. Perform the following steps
    to do so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个交互式力导向图。执行以下步骤：
- en: Add properties to your main application class.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的主应用程序类添加属性。
- en: '[PRE60]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the `setup` method set default values and create a graph.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中设置默认值并创建一个图。
- en: '[PRE61]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Implement interaction with the mouse.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现与鼠标的交互。
- en: '[PRE62]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Inside the `update` method, calculate all forces affecting particles.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部，计算影响粒子的所有力。
- en: '[PRE63]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the `draw` method implement drawing particles and links between them.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中实现绘制粒子和它们之间的链接。
- en: '[PRE64]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Inside the `Particle.cpp` source file, drawing of each particle should be implemented,
    as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件中，应实现每个粒子的绘制，如下所示：
- en: '[PRE65]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 2, in the `setup` method, we are creating our particles for each level
    of the graph and adding links between them. In the `update` method in step 4,
    we are calculating forces affecting all particles, which is repelling each particle
    from each other, and forces coming from the springs connecting the nodes. While
    repelling spreading particles, springs try to keep them at a fixed distance defined
    in `mLinkLength`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，在`setup`方法中，我们为图的每个级别创建粒子，并在它们之间添加链接。在步骤4中的`update`方法中，我们计算影响所有粒子的力，这些力使每个粒子相互排斥，以及来自连接节点的弹簧的力。在排斥扩散粒子时，弹簧试图将它们保持在`mLinkLength`中定义的固定距离。
- en: '![How it works…](img/8703OS_07_07.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_07_07.jpg)'
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**The Wikipedia article on Force-directed graph drawing**: [http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)](http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing))'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于力导向图绘制的维基百科文章**：[http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)](http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing))'
