- en: Chapter 7. Using 2D Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work and draw with 2D graphics and built-in
    Cinder tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 2D geometric primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing arbitrary shapes with the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a scribbler algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 2D metaballs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating text around curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a blur effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a force-directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing 2D geometric primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to draw the following 2D geometric shapes,
    as filled and stroked shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Circle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Include the necessary header to draw in OpenGL using Cinder commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code at the top of your source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create several geometric primitives using Cinder''s methods for drawing
    in 2D. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by declaring member variables to keep information about the shapes
    we will be drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two `ci::Vec2f` objects to store the beginning and end of a line, a `ci::Rectf`
    object to draw a rectangle, a `ci::Vec2f` object to define the center of the circle,
    and a `float` object to define its radius. Finally, we will create `aci::Vec2f`
    to define the ellipse's radius and two `float` objects to define its width and
    height.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's also declare two `ci::Color` objects to define the stroke and fill colors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup` method, let''s initialize the preceding members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, let's start by drawing filled shapes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's clear the background and set `mFillColor` to be the drawing color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Draw the filled shapes by calling the `ci::gl::drawSolidRect`, `ci::gl::drawSolidCircle`,
    and `ci::gl::drawSolidEllipse` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the `draw` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To draw our shapes as stroked graphics, let's first set `mStrokeColor` as the
    drawing color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's draw our shapes again, this time using only strokes by calling the `ci::gl::drawLine`,
    `ci::gl::drawStrokeRect`, `ci::gl::drawStrokeCircle`, and `ci::gl::drawStrokedEllipse`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet inside the `draw` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/8703OS_07_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cinder's drawing methods use OpenGL calls internally to provide fast and easy
    drawing routines.
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::gl::color` method sets the drawing color so that all shapes will be
    drawn with that color until another is set by calling `ci::gl::color` again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also set the stroke width by calling the `glLineWidth` method and passing
    a `float` value as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to set the stroke to be 5 pixels wide you should write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Drawing arbitrary shapes with the mouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to draw arbitrary shapes using the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin a new contour every time the user presses the mouse button, and
    draw when the user drags the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The shape will be drawn using fill and stroke.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Include the necessary files to draw and create a `ci::Shape2d` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code snippet at the top of your source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `ci::Shape2d` object and create vertices using mouse coordinates.
    Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `ci::Shape2d` object to define our shape and two `ci::Color` objects
    to define the fill and stroke colors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initialize the colors in the `setup` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be using black for stroke and yellow for fill.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the drawing will be made with the mouse, it is necessary to use the `mouseDown`
    and `mouseDrag` events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the necessary callback methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implementation of `mouseDown` we will create a new contour by calling
    the `moveTo` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows what the method should look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `mouseDrag` method we will add a line to our shape by calling the `lineTo`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Its implementation should look like the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method, we will first need to clear the background, then set `mFillColor`
    as the drawing color, and draw `mShape`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All there is left to do is to set `mStrokeColor` as the drawing color and draw
    `mShape` as a stroked shape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application. Press the mouse button to begin drawing a new
    contour, and drag to draw.![How to do it…](img/8703OS_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ci:Shape2d` is a class that defines an arbitrary shape in two dimensions allowing
    multiple contours.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::Shape2d::moveTo` method creates a new contour starting at the coordinate
    passed as a parameter. Then, the `ci::Shape2d::lineTo` method creates a straight
    line from the last position to the coordinate which is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The shape is internally tessellated into triangles when drawing a solid graphic.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to add curves when constructing a shape using `ci::Shape2d`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `quadTo (constVec2f& p1, constVec2f& p2)` | Adds a quadratic curve from the
    last position to `p2`, using `p1` as a control point |'
  prefs: []
  type: TYPE_TB
- en: '| `curveTo (constVec2f& p1, constVec2f& p2, constVec2f& p3)` | Adds a curve
    from the last position to `p3`, using `p1` and `p2` as control points |'
  prefs: []
  type: TYPE_TB
- en: '| `arcTo (constVec2f& p, constVec2f& t, float radius)` | Adds an arc from the
    last position to `p1` using `t` as the tangent point and radius as the arc''s
    radius |'
  prefs: []
  type: TYPE_TB
- en: Implementing a scribbler algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement a scribbler algorithm, which is very
    simple to implement using Cinder but gives an interesting effect while drawing.
    You can read more about the concept of connecting neighbor points at [http://www.zefrank.com/scribbler/about.html](http://www.zefrank.com/scribbler/about.html).
    You can find an example of scribbler at [http://www.zefrank.com/scribbler/](http://www.zefrank.com/scribbler/)
    or [http://mrdoob.com/projects/harmony/](http://mrdoob.com/projects/harmony/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement an application illustrating scribbler. Perform the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add properties to your main application class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `setup` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the drawing will be made with the mouse, it is necessary to use the `mouseDown`
    and `mouseUp` events. Implement these methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the implementation of drawing methods looks like the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the left mouse button is down, we are adding a new point to our container
    and drawing lines connecting it with other points near it. The distance between
    the newly-added point and the points in its neighborhood we are looking for to
    draw a connection line has to be less than the value of the `mMaxDist` property.
    Please notice that we are clearing the drawing area only once, at the program
    startup at the end of the `setup` method, so we don't have to redraw all the connections
    to each frame, which would be very slow.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing 2D metaballs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can implement organic looking objects called
    metaballs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the code base from the *Applying repulsion
    and attraction forces* recipe in [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement the metaballs'' rendering using a shader program. Perform
    the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file inside the `assets` folder with a name, `passThru_vert.glsl`,
    and put the following code snippet inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file inside the `assets` folder with a name, `mb_frag.glsl`, and put
    the following code snippet inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the necessary header files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a property to your application's main class, which is the `GlslProg` object
    for our GLSL shader program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method, change the values of `repulsionFactor` and `numParticle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `setup` method, load our GLSL shader program, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last major change is in the `draw` method, which looks like the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important part of this recipe is the fragment shader program mentioned
    in step 2\. The shader generates texture with rendered metaballs based on the
    positions and radius passed to the shader from our particle system. In step 7,
    you can find out how to pass information to the shader program. We are using `setMatricesWindow`
    and `setViewport` to set OpenGL for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A Wikipedia article on metaballs**: [http://en.wikipedia.org/wiki/Metaballs](http://en.wikipedia.org/wiki/Metaballs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating text around curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can animate text around a user-defined
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the `Letter` and `Word` classes to manage the animation, a `ci::Path2d`
    object to define the curve, and a `ci::Timer` object to define the duration of
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create and add the following files to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Word.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Word.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Letter.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Letter.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a word and animate its letters along a `ci::Path2d` object.
    Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Letter.h` file, include the necessary to use the `text`, `ci::Vec2f`,
    and `ci::gl::Texture` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also add the `#pragma once` macro
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `Letter` class with the following members and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move to the `Letter.cpp` file to implement the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, create a `ci::TextBox` object, set its parameters, and
    render it to texture. Also, set the width as the texture''s width plus a padding
    value of 10:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` method, we will draw the texture and use OpenGL transformations
    to translate the texture to its position, and rotate according to the rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setPos` method implementation, we will update the position and calculate
    its rotation so that the letter is perpendicular to its movement. We do this by
    calculating the arc tangent of its velocity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Letter` class is ready! Now move to the `Word.h` file, add the `#pragma
    once` macro, and include the `Letter.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `Word` class with the following members and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `Word.cpp` file and include the `Word.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor, we will iterate over each character of `text` and add a
    new `Letter` object.We will also calculate the total length of the text by calculating
    the sum of widths of all the letters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the destructor, we will delete all the `Letter` objects to clean up memory
    used by the class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `update` method, we will pass a reference to the `ci::Path2d` object,
    the total length of the path, and the progress of the animation as a normalized
    value from 0.0 to 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will calculate the position of each individual letter along the curve taking
    into account the length of `Word` and the current progress:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` method, we will iterate over all letters and call the `draw`
    method of each letter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `Word` and `Letter` classes ready, it''s time to move to our application''s
    class source file. Start by including the necessary source files and adding the
    helpful `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the following members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup` method, we will start by creating `std::string` and `ci::Font`
    and use them to initialize `mWord`. We will also initialize `mSeconds` with the
    seconds we want our animation to last for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to create the curve by creating the keypoints and connecting them
    by calling `curveTo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s calculate the length of the path by summing the distance between each
    point and the one next to it. Add the following code snippet inside the `setup`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to check if `mTimer` is running and calculate the progress by calculating
    the ratio between the elapsed seconds and `mSeconds`. Add the following code snippet
    inside the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` method, we will need to clear the background, enable alpha blending,
    draw `mWord`, and draw the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we need to start the timer whenever the user presses any key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `keyUp` event handler:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the following is the implementation of the the `keyUp` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application. Press any key to begin the animation.![How to
    do it…](img/8703OS_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a blur effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can apply a blur effect while drawing a
    texture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to use a Gaussian blur shader provided by Geeks3D
    at [http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/](http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement a sample Cinder application to illustrate the mechanism.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file inside the `assets` folder with the name `passThru_vert.glsl`
    and put the following code snippet inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file inside the `assets` folder with the name `gaussian_v_frag.glsland`
    and put the following code snippet inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file inside the `assets` folder with the name `gaussian_h_frag.glsl`
    and put the following code snippet inside it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the properties to your application''s main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `setup` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the beginning of the `draw` method calculate the blur intensity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` function render an image to `mFboBlur1` with a first step shader
    applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` function render a texture from `mFboBlur1` with a second step
    shader applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `mImageBlur` to the result texture from `mFboBlur2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `draw` method draw a texture with the result and GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a Gaussian blur shader needs to be applied twice—for the vertical and
    horizontal processing—we have to use **frame buffer object** (**FBO** ), a mechanism
    of drawing to the texture in the memory of graphic card. In step 8, we are drawing
    the original image from the `mImage` object and applying shader program stored
    in the `gaussian_v_frag.glsl` file loaded into `mGaussianVShaderobject`. At this
    point, everything is drawn into `mFboBlur1`. The next step is to use a texture
    from `mFboBlur2` and apply a shader to the second pass which you can find in step
    9\. The final processed texture is stored in `mImageBlur` in step 10\. In step
    7 we are calculating blur intensity.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a force-directed graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A force-directed graph is a way of drawing an aesthetic graph using simple physics
    such as repealing and springs. We are going to make our graph interactive so that
    users can drag nodes around and see how graph reorganizes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to use the code base from the *Creating a particle
    system in 2D* recipe in [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. To get some details of how to draw nodes and connections
    between them, please refer to the *Connecting particles* recipe in [Chapter 6](ch06.html
    "Chapter 6. Rendering and Texturing Particle Systems"), *Rendering and Texturing
    Particle Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an interactive force-directed graph. Perform the following steps
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add properties to your main application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method set default values and create a graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement interaction with the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `update` method, calculate all forces affecting particles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `draw` method implement drawing particles and links between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Particle.cpp` source file, drawing of each particle should be implemented,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 2, in the `setup` method, we are creating our particles for each level
    of the graph and adding links between them. In the `update` method in step 4,
    we are calculating forces affecting all particles, which is repelling each particle
    from each other, and forces coming from the springs connecting the nodes. While
    repelling spreading particles, springs try to keep them at a fixed distance defined
    in `mLinkLength`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The Wikipedia article on Force-directed graph drawing**: [http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)](http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
