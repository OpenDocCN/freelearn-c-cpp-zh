- en: Chapter 8. Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In this chapter, you will learn how to bring scripting facilities to your
    programs. You will gain knowledge of how to use a language based on JavaScript
    to implement the logic and details of your game without having to rebuild the
    main game engine. Although the environment we are going to focus on blends best
    with Qt applications, if you don''t like JavaScript you will be given suggestions
    about other languages that you can use to make your games scriptable.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why script?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might ask yourself, why should I use any scripting language if I can implement
    everything I need in C++? There are a number of benefits to providing a scripting
    environment to your games. Most modern games really consist of two parts. One
    of them is the main game engine that implements the core of the game (data structures,
    processing algorithms, and the rendering layer) and exposes an API to the other
    component, which provides details, behavior patterns, and action flows for the
    game. This other component is usually written in a scripting language. The main
    benefit of this is that story designers can work independently from the engine
    developers and they don't have to rebuild the whole game just to modify some of
    its parameters or check whether the new quest fits well into the existing story.
    This makes the development much quicker compared to the monolithic approach. Another
    benefit is that this development opens the game to modding—skilled end users can
    extend or modify the game to provide some added value to the game. It's also a
    way to make additional money on the game by implementing extensions on it on top
    of the existing scripting API without having to redeploy the complete game binary
    to every player or to expose new scripting endpoints to boost the creativity of
    the modders even more. Finally, you can reuse the same game driver for other games
    and just replace the scripts to obtain a totally different product.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides two implementations of a JavaScript-based scripting environment.
    In this chapter, we will be focusing on Qt Script. In the docs, you can see that
    the module is marked as "deprecated"; however, it currently provides a richer
    API (albeit with slower execution) than the other implementation. After we describe
    Qt Script, we will have a brief look at the other implementation as well. We will
    not discuss the details of the JavaScript language itself, as there are many good
    books and websites available out there where you can learn JavaScript. Besides,
    the JavaScript syntax is very similar to that of C, and you shouldn't have any
    problems understanding the scripts that we use in this chapter even if you haven't
    seen any JavaScript code before.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Qt Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Qt Script in your programs, you have to enable the script module for
    your projects by adding the `QT += script` line to the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating JavaScript expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ compilers do not understand JavaScript. Therefore, to execute any script,
    you need to have a running interpreter that will parse the script and evaluate
    it. In Qt, this is done with the `QScriptEngine` class. This is a Qt Script runtime
    that handles the execution of script code and manages all the resources related
    to scripts. It provides the `evaluate()` method, which can be used to execute
    JavaScript expressions. Let''s look at a "Hello World" program in Qt Script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This program is very simple. First, it creates an application object that is
    required for the script environment to function properly, and then it just instantiates
    `QScriptEngine` and invokes evaluate to execute the script source given to it
    as a parameter. After building and running the program, you will see a well-known
    `Hello World!` printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t get any output, then this probably means that the script didn''t
    get executed properly, possibly because of an error in the script''s source code.
    To verify that, we can extend our simple program to check whether there were any
    problems with the execution of the script. For this, we can query the engine state
    with `hasUncaughtExceptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code checks whether there is an exception and if yes, it fetches
    the exception object. You can see that its type is `QScriptValue`. This is a special
    type that is used to exchange data between the script engine and the C++ world.
    It is somewhat similar to `QVariant` in the way that it is really a facade for
    a number of primitive types that the script engine uses internally. One of the
    types is the type holding errors. We can check whether a script value object is
    an error using its `isError()` method, but in this case, we don''t do that since
    `uncaughtException()` is meant to return error objects. Instead, we immediately
    convert the error to a string representation and dump it to the console using
    `qDebug()`. For example, if you omit the closing single quote in the script source
    text and run the program, the following message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`QScriptEngine::evaluate()` also returns `QScriptValue`. This object represents
    the result of the evaluated script. You can make a script calculate some value
    for you that you can later use in your C++ code. For example, the script can calculate
    the amount of damage done to a creature when it is hit with a particular weapon.
    Modifying our code to use the result of the script is very simple. All that is
    required is to store the value returned by `evaluate()` and then it can be used
    elsewhere in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – creating a Qt Script editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a simple exercise and create a graphical editor to write and execute
    scripts. Start by creating a new GUI project and implement a main window composed
    of two plain text edit widgets (`ui->codeEditor` and `ui->logWindow`) that are
    separated using a vertical splitter. One of the edit boxes will be used as an
    editor to input code and the other will be used as a console to display script
    results. Then, add a menu and toolbar to the window and create actions to open
    (`ui->actionOpen`) and save (`ui->actionSave`) the document, create a new document
    (`ui->actionNew`), execute the script (`ui->actionExecute`), and to quit the application
    (`ui->actionQuit`). Remember to add them to the menu and toolbar. As a result,
    you should receive a window similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the quit action to the `QApplication::quit()` slot. Then, create an
    `openDocument()` slot and connect it to the appropriate action. In the slot, use
    `QFileDialog::getOpenFileName()` to ask the user for a document path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar fashion, implement the **Save** and **Save As** action handlers.
    Lastly, create the `open(const QString &filePath)` slot, make it read the document,
    and put its contents into the code editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `windowFilePath` property of `QWidget` can be used to associate a file with
    a window. You can then use it in actions related to using the file—when saving
    a document, you can check whether this property is empty and ask the user to provide
    a filename. Then, you can reset this property when creating a new document or
    when the user provides a new path for the document.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to run the program and use it to create scripts
    and save and reload them in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to execute the scripts, add a `QScriptEngine m_engine` member variable
    to the window class. Create a new slot, call it `run`, and connect it to the execute
    action. Put the following code in the body of the slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the program. To do so, enter the following script in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script in a file called `factorial.js` and then run it. You should
    get an output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, replace the script with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `run()` method clears the log window and evaluates the script using the
    method that we learned earlier in this chapter. If the evaluation is successful,
    it prints the result in the log window, which is what we see in the first screenshot
    shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: In the second attempt, we made an error in the script using a nonexistent variable.
    Evaluating such code results in an exception. In addition to reporting the actual
    error, we also use `uncaughtExceptionLineNumber()` to report the line that caused
    the problem. Next, we call the engine's `uncaughtExceptionBacktrace()` method,
    which returns a list of strings containing the backtrace (a stack of function
    calls) of the problem, which we also print on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another script. The following code defines the local variable `fun`,
    which is assigned an anonymous function that returns a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then call `fun()` like a regular function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at what happens if we delete the definition of `fun` from
    the script, but still keep the invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We still get the same result even though we didn't define what fun means! This
    is because the `QScriptEngine` object keeps its state across `evaluate()` invocations.
    If you define a variable in a script, it is kept in the current context of the
    engine. The next time `evaluate()` is called, it executes the script in the same
    context as before; therefore, all variables defined earlier are still valid. Sometimes,
    this is a desired behavior; however, a malicious script can wreck the context,
    which can cause trouble for subsequent evaluations in the engine. Therefore, it
    is usually better to make sure that the engine is left in a clean state after
    a script is done with the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sandboxed script evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next task for us is to modify our script editor so that it cleans up after
    the execution of each script. As was said, each script is executed in the current
    context of the engine, so the task of solving the problem boils down to making
    sure that each script executes in a separate context. Incorporate the following
    code in the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the program and repeat the last test to see that `fun` no longer persists
    across executions.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a function is called, a new execution context is pushed to the top of
    the stack. When the engine tries to resolve an object, it first looks for the
    object in the topmost context (which is the context of the function call). If
    it is not found, the engine looks into the next context on the stack and then
    the next until it finds the object or reaches the bottom of the stack. When the
    function returns, the context is popped from the stack and all variables defined
    there are destroyed. You can see how this works using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When `bar` is called, a new context is added to the stack. The script requests
    for the `foo` object, which is not present in the current context, so the engine
    looks into the surrounding context and finds a definition of `foo`. In our code,
    we follow this behavior by explicitly creating a new context using `pushContext()`
    and then removing it with `popContext()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can retrieve the current context object with `currentContext()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context has two important objects associated with it: the `activation`
    object and the `this` object. The former defines an object where all local variables
    are stored as the object''s properties. If you set any properties on the object
    before invoking a script, they will be directly available to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` object works in a similar fashion—it determines the object to be
    used when the script refers to an object called `this`. Any properties defined
    in C++ are accessible from the script and the other way round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Integrating Qt and Qt Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we were only evaluating some standalone scripts that could make use
    of the features built in JavaScript. Now, it is time to learn to use data from
    your programs in the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by exposing different kinds of entities to and from scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to expose data to Qt Script is to take advantage of Qt''s
    meta-object system. Qt Script is able to inspect `QObject` instances and detect
    their properties and methods. To use them in scripts, the object has to be visible
    to the script execution context. The easiest way to make this happen is to add
    it to the engine''s global object or to some context''s activation object. As
    you remember, all data between the script engine and C++ is exchanged using the
    `QScriptValue` class, so first we have to obtain a script value handle for the
    C++ object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`QScriptEngine::newQObject()` creates a script wrapper for an existing `QObject`
    instance. We then set the wrapper as a property of the global object called `pushButton`.
    This makes the button available in the global context of the engine as a JavaScript
    object. All the properties defined with `Q_PROPERTY` are available as properties
    of the object and every slot is accessible as a method of that object. Using this
    approach, you can share an existing object between the C++ and JavaScript worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are cases when you want to provide a rich interface for a class to manipulate
    it from within C++ easily, but to have a strict control over what can be done
    using scripting, you want to prevent scripters from using some of the properties
    or methods of the class.
  prefs: []
  type: TYPE_NORMAL
- en: For methods, this is quite easy—just don't make them slots. Remember that you
    can still use them as slots if you use the `connect()` variant, which takes a
    function pointer as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For properties, you can mark a property as accessible or inaccessible from
    scripts using the `SCRIPTABLE` keyword in the `Q_PROPERTY` declaration. By default,
    all properties are scriptable, but you can forbid their exposure to scripts by
    setting `SCRIPTABLE` to `false` as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – employing scripting for npc AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement a script serving as **artificial** **intelligence** (**AI**)
    for a nonplayer character in a simple Dungeons & Dragons game. The engine will
    periodically execute the script, exposing two objects to it—the creature and the
    player. The script will be able to query the properties of the player and invoke
    functions on the creature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project. We''ll start by implementing the C++ class for
    creatures in our game world. Since both the NPC and player are living entities,
    we can have a common base class for them. In [Chapter 4](ch04.html "Chapter 4. Qt
    Core Essentials"), *Qt Core Essentials*, we already had a data structure for players,
    so let''s use that as a base by equipping our entities with similar attributes.
    Implement `LivingEntity` as a subclass of `QObject` with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that this interface is read only—you cannot modify any of the properties
    using the `LivingEntity` class. Of course, we still need methods to change those
    values; so, implement them in the `public` interface of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you implement these methods, be sure to emit proper signals when you modify
    property values. Let''s add more methods that correspond to the actions that a
    creature can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last four methods are simple to implement; for the first three methods,
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, if the creature chooses to wait, it regains one hit point. If it
    dodges, this increases its chances to avoid damage when attacked. If it attacks
    another creature, this inflicts damage based on its own attack and the opponent's
    defensive score.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement the subclasses of `LivingEntity` so that we can
    manipulate the objects from Qt Script. To do this, implement the `NPC` class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What remains is to create a simple game engine to test our work. To do this,
    start by adding a `reset()` method to `LivingEntity` that will reset the armor
    bonus before every turn. Then, implement the `GameEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the application using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created two classes of objects: `LivingCreature`, which is the basic API
    to read data about a creature, and NPC, which provides a richer API. We obtained
    this effect by redeclaring the existing functions as slots. This is possible even
    when the methods are not virtual, as when slots are executed using Qt''s meta-object
    system, they are always treated as if they were virtual methods—a declaration
    in the derived class always shadows the declaration in the parent class. Having
    the two classes, we exposed their instances to the scripting environment, and
    we use a timer to call a user-defined script every second. Of course, this is
    a very simple approach to scripting, which can easily be abused if the user calls
    multiple action functions in the script, for example, by calling `attack()` many
    times in one script, the creature can perform multiple strikes on the opponent.
    Speaking of `attack()`, note that it takes a `LivingCreature` pointer as its parameter.
    In the script, we fed it with the player object that corresponds to the needed
    type in C++. The conversion is done by Qt Script automatically. Therefore, you
    can define methods by taking `QObject` pointers and using them with `QObject`
    instances that are exposed to scripts. In a similar fashion, you can define functions
    by taking `QVariant` or `QScriptValue` and passing any value to them in the script.
    If the script engine is able to convert the given value to the requested type,
    it will do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – extending the Dungeons & Dragons game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a number of ideas that can be used to extend our small game. The first
    is to add a script execution for the player as well so that it tries to defend
    against the creature. For that, you''ll need to expose the creature''s data using
    the `LivingCreature` API so that it is read only and exposes the player using
    a read-write interface. There are many ways to obtain it; the easiest is to provide
    two public `QObject` interfaces that operate on a shared pointer as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero – extending the Dungeons & Dragons game](img/8874OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The API already contains methods to move creatures. You can extend the fighting
    rules to take into consideration the distance between opponents and their relative
    orientation (for example, striking from behind usually yields more damage than
    when standing face-to-face with the enemy). You can even introduce ranged combat.
    Extend the `LivingCreature` interface with the properties and methods that manipulate
    the creature's inventory. Allow the creature to change its active weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final modification that you can apply is to prevent cheating, using the
    mechanism described earlier. Instead of executing an action immediately, mark
    which action the script has chosen (along with its parameters) and only execute
    that action after the script finishes executing, for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Another approach to this would be to assign action points to each creature's
    every turn and allow the creature to spend them on different actions. If there
    are not enough points left to execute an action, the script is notified about
    this and the action fails.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have been exporting objects to scripts and calling their properties
    and methods. However, there is also a way to call standalone C++ functions from
    scripts as well as call functions written in JavaScript from within C++ code.
    Let's have a look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing C++ functions to scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can expose a standalone function to Qt Script with the help of the `QScriptEngine::newFunction()`
    call. It returns `QScriptValue` as any function in JavaScript, is also an object,
    and can be represented by `QScriptValue`. In C++, if a function accepts three
    parameters, you have to pass exactly three parameters when calling it. In JavaScript,
    this is different—you can always pass any number of parameters to a function,
    and it is the function''s responsibility to do a proper argument validation. Therefore,
    the actual function that is exported should be wrapped in another function that
    will do what JavaScript expects from it before calling the actual function. The
    wrapper function needs to have an interface that is compatible with what `newFunction()`
    expects. It should take two parameters: the script context and the script engine,
    and it should return `QScriptValue`. The `context` contains all the information
    regarding the parameters of the function, including their count. Let''s try wrapping
    a function that takes two integers and returns their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the wrapper, we can create a function object for it and export
    it to the scripting environment in exactly the same way as we export regular objects—by
    making it a property of the script''s global object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to `newFunction()` defines how many arguments the function
    expects and is retrievable with the function object''s length property. This is
    just for your information, as the caller can pass as many arguments as he/she
    wants. Try evaluating the following script after exporting the sum function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of such behavior and extend the functionality of our `sum`
    function by making it return a sum of all the parameters passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can call the sum with any number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to an interesting question: can the function have different
    functionality depending on how many parameters you pass to it? The answer is positive;
    you can implement the function in any way you want, with the whole power of C++
    at hand. There is a specific case for JavaScript when such behavior makes particular
    sense. This is when the function is supposed to work as a getter and setter for
    a property. Getters and setters are functions that are called when the script
    wants to retrieve or set the value of a property in some object. By attaching
    getters and setters to objects, you can control where the value is stored (if
    at all) and how it is retrieved. This opens the possibility of adding properties
    to the exported Qt objects that have not been declared with the `Q_PROPERTY` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this code; here, we expose an instance of `CustomObject` to
    the script engine in a standard way. We also set the object''s value property
    to a function, passing an additional value to `setProperty()`, which contains
    a set of flags that tell the scripting environment how it should treat the property.
    In this case, we tell it that the passed value should be used as a getter and
    setter for the property. Let''s see how the function itself is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, we ask the function the context for the value representing the object
    that the function is called on. Then, we extract a `CustomObject` pointer from
    it using `qobject_cast`. Next, we check the number of arguments to the function
    call. In the case of a setter, the function is passed one parameter—the value
    to be set to the property. In such a situation, we use a C++ method of the object
    to apply that value to the object. Otherwise, (no arguments are passed) the function
    is used as a getter and we return the value after fetching it with the C++ method.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing script functions to C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the same way as C++ functions are exported to Qt Script with the use of
    `QScriptValue`, JavaScript functions can be imported to C++. You can ask for a
    script value representing a function like any other property. The following code
    asks the engine for the `Math.pow()` function, which performs the power operation
    on its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Having `QScriptValue` represent a function, you can invoke it using the value''s
    `call()` method and pass any parameters as a list of script values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter to `call()` is the value that is to be used as the `this`
    object of the function. In this particular case, we pass an empty object since
    the function is standalone—it does not make any use of its environment. There
    are situations, however, when you will want to set an existing object here, for
    example, to allow a function to directly access the existing properties or define
    new properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the newly learned functionality to improve our Dungeons & Dragons
    game in order to use a richer set of scripting functionality that is based on
    JavaScript functions and properties. The script used will contain a set of functions
    written in JavaScript that are going to be stored in the program and called in
    various situations. We'll be focusing here only on the scripting part. You will
    surely be able to fill in the C++ gaps yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – storing the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first task is to read the script, extract the needed functions from it,
    and store them in a safe place. Then, load the project for the game and add a
    new class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The reading method can have the same content as the original `readScriptFromFile`
    method. The evaluate method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `GameEngine` class to make use of the new code (remember to add
    the `m_ai` class member):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program by feeding it the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AIScript` object contains information about the AI for a single entity.
    The `start()` method now loads a script from the file and evaluates it. The script
    is expected to define a number of functions that are then retrieved from the activation
    object and stored in the `AIScript` object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – providing an initialization function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task for this exercise is to make it possible for the AI to initialize
    itself by invoking the `init()` function. Let''s get right down to business. Extend
    the `AIScript` structure with yet another field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This object will represent the AI itself. The script will be able to store
    data or define functions in it. Add the following code to the class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a call to `initialize()` at the end of `start()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program using the following `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In initialize, we prepare the script object with an empty JavaScript object
    and we call the function stored in `initFunction`, passing the script object as
    this. The function prints a debug statement and defines two properties in this
    object—one is a function to calculate the Manhattan distance and the other is
    an empty array where we will store a history of actions that the AI has taken.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manhattan distance is a metric to calculate the distance between objects; this
    is much faster to calculate than the real Euclidean distance. It is based on the
    assumption that when traversing a large city with a grid of buildings, one can
    only follow streets that go along those buildings and take 90 degree turns. The
    Manhattan distance between positions is then the number of crossings one has to
    walk through to get from the source to the destination. In C++ and Qt, you can
    compute this distance easily using the `manhattanLength()` method in the `QPoint`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing the heartbeat event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heart of AI is the heartbeat function that is executed at equal intervals
    of time to allow the AI to decide about the actions of the object. The script
    that is executed will have access to the creature that it operates on as well
    as its environment. It can also use anything that it defines in the `this` object.
    Now, add a heartbeat function to `AIScript`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Bring the timer back, set it to `start()`, and also enable the running heartbeat
    functionality from within the timer event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, giving it the following `heartbeat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `heartbeat`, we proceed in similar way as with `init`, but here, we pass
    the creature that the AI works on as a parameter of the function and we set the
    other entity as the enemy property of the `this` object, which makes it accessible
    to the function. After the call we remove the enemy property from the this object.
    The function itself performs an attack on the enemy and pushes an entry to the
    script object history. Unlike a direct invocation of evaluate when making a function
    call we don't have to push and pop an execution context as it is done for us automatically
    during `QScriptValue::call`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – defending against attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that we left out the defend script. Try extending the game
    by calling a script whenever the subject is attacked by the opponent. In the script,
    allow the creature to take different defensive stances, such as evading, blocking,
    or parrying attacks. Make each action have a different influence on the outcome
    of the strike. Also, apply all the modifications that you made to the original
    game. Try expanding on the code that was already written by providing additional
    hooks where scripts are run and adding new actions and objects. How about adding
    more enemies to the game? What about organizing a contest for the best AI algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: Using signals and slots in scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Script also offers the capability to use signals and slots. The slot can
    be either a C++ method or a JavaScript function. The connection can be made either
    in C++ or in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how to establish a connection within a script. When a `QObject`
    instance is exposed to a script, the object''s signals become the properties of
    the wrapping object. These properties have a `connect` method that accepts a function
    object that is to be called when the signal is emitted. The receiver can be a
    regular slot or a JavaScript function. To connect the `clicked()` signal of an
    object called `button` to a `clear()` slot of another object called `lineEdit`,
    you can use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If the receiver is a standalone function called `clearLineEdit`, the call becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also connect a signal to an anonymous function that was defined directly
    in the connection statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There is additional syntax available where you can define the `this` object
    for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to disconnect a signal from within a script, just replace `connect`
    with `disconnect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Emitting signals from within the script is also easy—just call the signal as
    a function and pass to it any necessary parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a signal-slot connection on the C++ side where the receiver is a
    script function, instead of a regular `connect()` statement, use `qScriptConnect()`.
    Its first two parameters are identical with the regular call and the two other
    parameters correspond to a script value that represents an object that is to act
    as the `this` object and a script value that represents a function to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this particular example, we pass an invalid object as the third parameter.
    In such a case, the `this` object will point to the engine's global object.
  prefs: []
  type: TYPE_NORMAL
- en: As for disconnecting signals, of course, there is `qScriptDisconnect()` available.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – triggering defense using signals and slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a task for yourself, try modifying the Dungeons & Dragons game so that the
    defend script function is not called manually by the script engine, but instead
    is invoked using a signal-slot connection. Have a creature emit the `attacked()`
    signal when it is attacked, and let the script connect a handler to that signal.
    Use a variant of connect that defines the `this` object for the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Qt objects in scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using existing objects from scripts sometimes is not enough to get a rich scripting
    experience. It is also useful to be able to create new Qt objects from within
    scripts and even return them to C++ so that they can be used by the game engine.
    There are two ways to approach this problem. Before we describe them, it is important
    to understand how JavaScript instantiates objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has no notion of classes. It constructs objects using prototypes—a
    prototype is an object whose properties are cloned into the new object. The object
    is constructed by invoking a constructor, which can be any function. When you
    invoke a function using the keyword new, the engine creates a new empty object,
    sets its constructor property to the function serving as the constructor, sets
    the object prototype to the function's prototype, and finally, invokes the function
    in the context of the new object, making that function act as a factory function
    for objects with a particular set of properties. Therefore, to construct objects
    of the type `QLineEdit`, there needs to be a function that can be called as a
    constructor for objects that behave like Qt's widget to enter a single line of
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that functions can be stored in `QScriptValue` objects. There
    are two ways to obtain a function that can act as a constructor for Qt objects.
    First, we can implement it ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We did three things here. First, we defined a function that instantiates `QPushButton`
    with a parent passed as the first argument to the function, wraps the object in
    `QScriptValue` (with an extra parameter noting that the environment responsible
    for deleting the object should be determined by the parent object), and that returns
    `QScriptValue` to the caller. Secondly, we wrapped the function itself into `QScriptValue`
    as we already did earlier with other functions. Finally, we set the function as
    a property of the global object of the engine so that it is always accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to obtain a constructor function is to make use of Qt''s meta-object
    system. You can use the following macro to define a constructor function very
    similar to what we have written manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can use the `QScriptEngine::scriptValueFromQMetaObject()` template
    method to get a script value wrapping that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can set the obtained script value as a constructor in the script
    engine just like before. Here is a complete code to make push buttons creatable
    from within the scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Error recovery and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only error recovery we''ve talked about so far is checking whether a script
    has ended up with an error and executing a script in a dedicated context to prevent
    polluting the namespace with local variables that are not used anymore. This is
    already a lot; however, we can do more. First, we can take care of preventing
    pollution of the global namespace. Pushing and popping the execution context does
    not prevent a script from modifying the engine''s global object, and we should
    prevent situations when a script, for example, replaces the `Math` object or the
    print function. The solution is to provide your own global object in place of
    the original one. There are two easy ways to do this. First, you can use the class
    called `QScriptValueIterator` to copy all the properties of the global object
    to a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can set the original global object as an internal prototype
    of the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, you will then need to replace the original global object with the
    temporary one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The other big thing to do when talking about error recovery is to provide debugging
    capabilities for scripts. Luckily, Qt contains a built-in component to debug scripts.
    If you build your project with the `QT+=scripttools` option, you will gain access
    to the `QScriptEngineDebugger` class. To start using the debugger with a script
    engine, you need to attach and bind them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an uncaught exception occurs, the debugger will kick in and show its
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error recovery and debugging](img/8874OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can then set breakpoints in the script, inspect variables or the call stack,
    and continue or break the execution. A good idea is to incorporate the debugger
    in your game so that script designers can use it when developing scripts. Of course,
    the debugger should not be running with the release version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QScriptEngine` has the ability to import extensions that provide additional
    functionality to the scripting environment (for example, a library of utility
    functions that can be used in different parts of the game without having to redefine
    them here and there) using the `importExtension()` method. The extension can be
    implemented in JavaScript by providing a set of files that contain scripts, making
    the extension or in C++ by subclassing `QScriptExtensionPlugin`. Now, we will
    focus on the second approach. Here is how a simple C++ extension looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The extension defined here is simple—it only attaches one property to the engine''s
    global object, which has a name property returning as a text string. You should
    put the resulting library in a subdirectory called `Simple` in a script subdirectory
    of a directory where your application looks for plugins (for example, the application
    where your application binary is placed). Then, you can import the plugin using
    `importExtension()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the *Deploying Plugins* section of the Qt reference manual for more
    information about where you can put plugins and how you can tell Qt where to look
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: The other Qt JavaScript environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned at the beginning of this chapter, Qt provides two environments
    to use JavaScript. We already talked about Qt Script; now it is time for us to
    tell you about its counterpart: `QJSEngine`. The newer JavaScript engine in Qt,
    which is also used for QML, about which you will learn in the next chapter. It
    has a different internal architecture than Qt Script, but most of what we have
    taught you also applies to `QJSEngine`. The main difference is that the root classes
    are named differently. Have a look at the following table, which shows equivalent
    classes for the two engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '| QtScript | QJSEngine |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QScriptEngine` | `QJSEngine` |'
  prefs: []
  type: TYPE_TB
- en: '| `QScriptValue` | `QJSValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `QScriptContext` | `–` |'
  prefs: []
  type: TYPE_TB
- en: The `QJSEngine` class is the equivalent of `QScriptEngine`. It also has an `evaluate()`
    method that is used to evaluate scripts. This method can create objects, wrap
    `QObject` instances, and use `QJSValue` (the equivalent of `QScriptValue`) to
    store values used in scripts in a way that they can be accessed from C++. You
    can also see that there is no equivalent to `QScriptContext` and thus its functionality
    is not available in the implementation based on `QJSEngine`. Another missing component
    is the integrated engine debugger. Also, at the time of writing, there is no easy
    way to export your own classes to the `QJSEngine`-based JavaScript environment
    to allow the creation of instances of those classes.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Script is an environment that is designed to be part of the Qt world. Since
    not everyone knows or likes JavaScript, we will present another language that
    can easily be used to provide scripting environments for games that are created
    with Qt. Just be aware that this is not going to be an in-depth description of
    the environment—we will just show you the basics that can provide foundations
    for your own research.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A popular language used for scripting is Python. There are two variants of
    Qt bindings that are available for Python: PySide and PyQt. PySide is the official
    binding that is available under LGPL, but currently, it only work with Qt 4\.
    PyQt is a third-party library that is available under GPL v3 and commercial licenses
    that have variants for Qt 4 as well as Qt 5\. Note that PyQt is not available
    under LGPL, so for commercial closed-source products you need to obtain a commercial
    license from Riverbank Computing!'
  prefs: []
  type: TYPE_NORMAL
- en: These bindings allow you to use the Qt API from within Python—you can write
    a complete Qt application using just Python. However, to call Python code from
    within C++, you will need a regular Python interpreter. Luckily, it is very easy
    to embed such an interpreter in a C++ application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need Python installed along with its development package. For
    example, for Debian-based systems, it is easiest to simply install the `libpythonX.Y-dev`
    (or a newer) package, where `X` and `Y` stand for the version of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to tell your program to link it against the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To call Python code from within a Qt app, the simplest way is to use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This code initializes a Python interpreter, then invokes a script by passing
    it directly as a string, and finally, it shuts down the interpreter before invoking
    Qt's event loop. Such code makes sense only for simple scripting. In real life,
    you'd want to pass some data to the script or fetch the result. For that, we have
    to write some more code. As the library exposes the C API only, let's write a
    nice Qt wrapper for it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing a Qt wrapper for embedding Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the first task, we will implement the last program using an object-oriented
    API. Create a new console project and add the following class to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a `main()` function as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally open the `.pro` file and tell Qt to link with the Python library. In
    case of Linux you can use `pkg-config` by adding two lines to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You might need to install Python library using a call equivalent to `apt-get
    install libpython3.4-dev`. For Windows you need to manually pass information to
    the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a class called `QtPython` that wraps the Python C API for us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never use a `Q` prefix to call your custom classes, as this prefix is reserved
    for official Qt classes. This is to make sure that your code will never have a
    name clash with future code added to Qt. The Qt prefix on the other hand is meant
    to be used with classes that are extensions to Qt. You probably still shouldn't
    use it, but the probability of a name clash is much smaller and yields a lesser
    impact than clashes with an official class. It is best to come up with your own
    prefix (such as `Qxy`, where `x` and `y` are your initials).
  prefs: []
  type: TYPE_NORMAL
- en: The class constructor creates a Python interpreter and the class destructor
    destroys it. We use `Py_InitializeEx(0)`, which has the same functionality as
    `Py_Initialize()`, but it does not apply C signal handlers, as this is not something
    we would want when embedding Python. Prior to this, we use `Py_SetProgramName()`
    to inform the interpreter of our context. We also defined a `run()` method, taking
    `QString` and returning `void`. It uses `qPrintable()`, which is a convenience
    function that extracts a C string pointer from a `QString` object, which is then
    fed into `PyRun_SimpleString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never store the output of `qPrintable()` as it returns an internal pointer to
    a temporary byte array (this is equivalent to calling `toLocal8Bit().constData()`
    on a string). It is safe to use directly, but the byte array is destroyed immediately
    afterwards; thus, if you store the pointer in a variable, the data may not be
    valid later when you try using that pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The hardest work when using embedded interpreters is to convert values between
    C++ and the types that the interpreter expects. With Qt Script, the `QScriptValue`
    type was used for this. We can implement something similar for our Python scripting
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – converting data between C++ and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class and call it `QtPythonValue`. Then, add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify the `main()` function to test our new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When you run the program, you will see that the conversion between C++ and Python
    works correctly in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `QtPythonValue` class wraps a `PyObject` pointer (through the `m_value`
    member), providing a nice interface to convert between what the interpreter expects
    and our Qt types. Let''s see how this is done. First, take a look at the three
    private methods: two versions of `incRef()` and one `decRef()`. `PyObject` contains
    an internal reference counter that counts the number of handles on the contained
    value. When that counter drops to `0`, the object can be destroyed. Our three
    methods use adequate Python C API calls to increase or decrease the counter in
    order to prevent memory leaks and keep Python''s garbage collector happy.'
  prefs: []
  type: TYPE_NORMAL
- en: The second important aspect is that the class defines a private constructor
    that takes a `PyObject` pointer, effectively creating a wrapper over the given
    value. The constructor is private; however, the `QtPython` class is declared as
    a friend of `QtPythonValue`, which means that only `QtPython` and `QtPythonValue`
    can instantiate values by passing `PyObject` pointers to it. Now, let's have a
    look at public constructors.
  prefs: []
  type: TYPE_NORMAL
- en: The default constructor creates an object pointing to a `None` value, which
    is Python's equivalent to the C++ null. The copy constructor and assignment operator
    are pretty standard, taking care of bookkeeping of the reference counter. Then,
    we have two constructors—one taking `int` and the other taking a `QString` value.
    They use appropriate Python C API calls to obtain a `PyObject` representation
    of the value. Note that these calls already increase the reference count for us,
    so we don't have to do it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The code ends with a destructor that decreases the reference counter and three
    methods that provide safe conversions from `QtPythonValue` to appropriate Qt/C++
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – implementing the remaining conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you should be able to implement other constructors and conversions for
    `QtPythonValue` that operates on the `float`, `bool`, or even on `QDate` and `QTime`
    types. Try implementing them yourself. If needed, have a look at [https://docs.python.org/3/](https://docs.python.org/3/)
    to find appropriate calls that you should use. We''ll give you a head start by
    providing a skeleton implementation of how to convert `QVariant` to `QtPythonValue`.
    This is especially important because Python makes use of two types whose equivalents
    are not available in C++, namely, tuples and dictionaries. We will need them later,
    so having a proper implementation is crucial. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows how to create a tuple (which is a list of arbitrary
    elements) from `QVariantList` and how to create a dictionary (which is an associative
    array) from `QVariantMap`. Try adding constructors by taking `QStringList`, `QVariantList`,
    and `QVariantMap` directly and returning tuples or a dictionary, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We have written quite a lot of code now, but so far there is no way of binding
    any data from our programs with Python scripting. Let's change that.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling functions and returning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next task is to provide ways to invoke Python functions and return values
    from scripts. Let''s start by providing a richer `run()` API. Implement the following
    method in the `QtPython` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a functionality to import Python modules. Add the following
    methods to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of the code is to extend `QtPythonValue` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can modify `main()` to test the new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You can replace `/home` with a directory of your choice. Then, you can run the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did two tests in the last program. First, we used the new `run()` method,
    passing to it the code that is to be executed and two dictionaries that define
    the current execution context—the first dictionary contains global symbols and
    the second contains local symbols. The dictionaries come from Python's `__main__`
    module (which among other things, defines the `print` function). The `run()` method
    may modify the contents of the two dictionaries—the first call defines the tuple
    called `foo` and the second call prints it to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: The second test calls a function from an imported module; in this case, we call
    two functions from the `os` module—the first function, `chdir`, changes the current
    working directory and the other called `getcwd` returns the current working directory.
    The convention is that we should pass a tuple to `call()`, where we pass the needed
    parameters. The first function takes a string as a parameter, therefore, we pass
    a `QStringList` object, assuming that there is a `QtPythonValue` constructor that
    converts `QStringList` to a tuple (you need to implement it if you haven't done
    it already). Since the second function does not take any parameters, we pass an
    empty tuple to the call. In the same way, you can provide your own modules and
    call functions from them, query the results, inspect dictionaries, and so on.
    This is a pretty good start for an embedded Python interpreter. Remember that
    a proper component should have some error checking code to avoid crashing the
    whole application.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend the functionality of the interpreter in many ways. You can even
    use PyQt5 to use Qt bindings in scripts, combining Qt/C++ code with Qt/Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – wrapping Qt objects into Python objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you should be experienced enough to try and implement a wrapper
    for the `QObject` instances to expose signals and slots to Python scripting. If
    you decide to pursue the goal, [https://docs.python.org/3/](https://docs.python.org/3/)
    will be your best friend, especially the section about extending Python with C++.
    Remember that `QMetaObject` provides information about the properties and methods
    of Qt objects and `QMetaObject::invokeMethod()` allows you to execute a method
    by its name. This is not an easy task, so don't be hard on yourself if you are
    not able to complete it. You can always return to it once you gain more experience
    in using Qt and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Before you head on to the next chapter, try testing your knowledge about scripting
    in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which is the method that you can use to execute JavaScript statements?
  prefs: []
  type: TYPE_NORMAL
- en: '`QScriptEngine::run()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QScriptEngine::evaluate()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QScriptProgram::execute()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What is the name of the class that serves as a bridge to exchange data
    between Qt Script and C++?
  prefs: []
  type: TYPE_NORMAL
- en: '`QScriptContext`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QScriptValue`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QVariant`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What is the name of the class that serves as a bridge that is used to exchange
    data between Python and C++?
  prefs: []
  type: TYPE_NORMAL
- en: '`PyValue`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PyObject`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QVariant`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. How do execution contexts work?
  prefs: []
  type: TYPE_NORMAL
- en: They mark some variables as "executable" to prevent rogue code from being executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They allow executing scripts in parallel, improving their speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They contain all the variables defined within a function invocation so that
    a set of variables visible from within a script can be modified without affecting
    the global environment (called sandboxing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that providing a scripting environment to your
    games opens up new possibilities. Implementing a functionality using scripting
    languages is usually faster than doing the full write-compile-test cycle with
    C++ and you can even use the skills and creativity of your users who have no understanding
    of the internals of your game engine to make your games better and more feature-rich.
    You were shown how to use Qt Script, which blends the C++ and JavaScript worlds
    together by exposing Qt objects to JavaScript and making cross-language signal-slot
    connections. If you're not a JavaScript fan, you learned the basics of scripting
    with Python. There are other scripting languages available (for example Lua) and
    many of them can be used together with Qt. Using the experience gained in this
    chapter, you should even be able to bring other scripting environments to your
    programs, as most embeddable interpreters offer similar approaches to that of
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to an environment very much like
    Qt Script in the way that it is heavily based on JavaScript. However, the purpose
    of using it is completely different—we will be using it to bleed edge-fancy graphics.
    Welcome to the world of Qt Quick.
  prefs: []
  type: TYPE_NORMAL
