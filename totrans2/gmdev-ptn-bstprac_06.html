<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Creating Objects with the Prototype Pattern</h1>
            

            
                
<p class="calibre2">We saw in the last chapter how using a Dynamic Factory can help us decouple our high-level modules, such as the <kbd class="calibre14">M5StageManager</kbd> or <kbd class="calibre14">M5ObjectManager</kbd> from the implementation details of our derived <kbd class="calibre14">M5Stage</kbd> or <kbd class="calibre14">M5Component</kbd> classes. We did this by pushing those dependencies into derived builder classes that would be used by a Dynamic Factory. This allowed us the freedom to change our derived stage and component classes without needing to modify our higher level modules. C++ template classes made using the Dynamic Factory very easy, since we were not required to create a derived class builder for every stage and component.</p>
<p class="calibre2">However, we are required to create a builder for each <kbd class="calibre14">M5Object</kbd> type we want, since they will contain a set of components that are unique to each object. Unfortunately, these builders may require frequent changes as we playtest, balance, and modify our game design. Each time these builders change, the game will be need to be recompiled.</p>
<p class="calibre2">The goal would be to have our game object types be completely defined in a file. This would give the game designer the ability to test, tweak, and balance the game without needing to touch C++ code or ever recompile. Of course, all of this could be done in a level editor tool, which could also be given to players, allowing them to create additional game content.</p>
<p class="calibre2">In this chapter, we will explore the Prototype pattern and how it can help us define objects completely within a text file. We will do this by first looking at a simple example of the pattern, then looking at how the Mach5 Engine, and the <kbd class="calibre14">M5ObjectManager</kbd> specifically, makes use of this pattern to read game object definitions from a file. Along the way, we will look at some language features of C++ that will help us write better, safer code.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            
                
Here is an outline of the topics we will cover and your tasks for this chapter:<br class="title-page-name"/>
<ul class="calibre17">
<li class="calibre18">Learn the trouble with using a factory for game objects</li>
<li class="calibre18">Implement the Prototype pattern</li>
<li class="calibre18">Learn how the Mach5 engine uses the Prototype pattern</li>
<li class="calibre18">Implement components within the Mach5 Engine</li>
<li class="calibre18">Learn how to define objects completely in a file</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The trouble with using a factory for game objects</h1>
            

            
                
<p class="calibre2">In <a href="part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 5</a>, <em class="calibre12">Decoupling Code via the Factory Method Pattern</em> we learned how to use a Dynamic Factory to decouple our stages, components, and objects from higher level modules. We did this by placing the dependencies of each derived class into a separate builder class instead of a high-level module. Let's look at an example of creating a derived type stage builder:</p>
<pre class="calibre23">
//SplashStageBuilder.h-------------------- <br class="title-page-name"/>#include "M5StageBuilder.h" <br class="title-page-name"/> <br class="title-page-name"/>class SplashStageBuilder: public M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual M5Stage* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//SplashStageBuilder.cpp-------------------- <br class="title-page-name"/>#include "SplashStageBuilder.h" <br class="title-page-name"/>#include "SplashStage.h" <br class="title-page-name"/> <br class="title-page-name"/>M5Stage* SplashStageBuilder::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  return new SplashStage(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The reason we did this is so that changes to the <kbd class="calibre14">SplashStage</kbd> class only affect this file as opposed to the <kbd class="calibre14">M5StageManager</kbd>, for example. This means any changes to derived stage or stage builder classes cannot break other code, because the other code will only be using an <kbd class="calibre14">M5Stage</kbd> pointer. Changes to this class could still break other code, particularly if this stage was removed from the game altogether. However, by minimizing dependencies, we reduce the chances that other code will need to be changed in the future.</p>
<p class="calibre2">In the Mach5 Engine, the <kbd class="calibre14">M5Stage</kbd> derived classes only need a default constructor. This is by design to keep the builder classes as simple as possible. Each stage class will read its own required data from a file. The logic for which file to read is written into the constructor. The same simple default constructor design is used in the <kbd class="calibre14">M5Component</kbd> derived classes as well. What this means is that instead of needing to create a builder class for each stage or component, we can instead use the power of C++ templates:</p>
<pre class="calibre23">
//M5StageBuilder.h <br class="title-page-name"/>class M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~M5StageBuilder(void) {} //empty virtual destructor <br class="title-page-name"/>  virtual M5Stage* Build(void) = 0; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>template &lt;typename T&gt; <br class="title-page-name"/>class M5StageTBuilder: public M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual M5Stage* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>template &lt;typename T&gt; <br class="title-page-name"/>M5Stage* M5StageTBuilder&lt;T&gt;::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  return new T(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">By using C++ templates, we can reduce the number of small classes that need to be manually created while still gaining the decoupling benefits of the factory. Of course, it is always possible that a few stages or components will need more complex constructors or builder classes. In that case, we can easily create the required classes when the need arises. Unfortunately, we don't get the option of using templates with our object types.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Using builders with objects</h1>
            

            
                
<p class="calibre2">Our game objects are mostly just collections of components. Each object type will have different components and component data based on the decisions of the designer. As the development progresses, those collections are likely to change. Remember, even though each individual component has a builder in the factory, the object will need to somehow instantiate the separate components. Let's look at shortened examples of using builders for the <kbd class="calibre14">Player</kbd> and <kbd class="calibre14">Raider</kbd> objects:</p>
<pre class="calibre23">
//PlayerBuilder.h-------------------- <br class="title-page-name"/>#include "M5ObjectBuilder.h" <br class="title-page-name"/> <br class="title-page-name"/>class PlayerBuilder: public M5ObjectBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>virtual M5Object* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//PlayerBuilder.cpp-------------------- <br class="title-page-name"/>#include "PlayerBuilder.h" <br class="title-page-name"/>#include "M5Object.h" <br class="title-page-name"/>#include "M5ObjectManager.h" <br class="title-page-name"/> <br class="title-page-name"/>M5Object* PlayerBuilder::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>M5Object* pObj = new M5Object; <br class="title-page-name"/>//Build and set Gfx component for player <br class="title-page-name"/>GfxComponent* pGfx = <br class="title-page-name"/>   M5ObjectManager::CreateComponent(CT_GfxComponent); <br class="title-page-name"/>pGfx-&gt;SetTexture("playerShip.tga"); <br class="title-page-name"/>pGfx-&gt;SetDrawSpace(DS_WORLD); <br class="title-page-name"/> <br class="title-page-name"/>//Build and set input component for player <br class="title-page-name"/>PlayerInputComponent* pPI = <br class="title-page-name"/>   M5ObjectManager::CreateComponent(CT_PlayerInputComponent); <br class="title-page-name"/>pPI-&gt;SetSpeed(100); <br class="title-page-name"/>pPI-&gt;SetRotationSpeed(10); <br class="title-page-name"/> <br class="title-page-name"/>pObj-&gt;AddComponent(pGfx); <br class="title-page-name"/>pObj-&gt;AddComponent(pPI); <br class="title-page-name"/> <br class="title-page-name"/>//...add more components here <br class="title-page-name"/> <br class="title-page-name"/>return pObj; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>//RaiderBuilder.h-------------------- <br class="title-page-name"/>#include "M5ObjectBuilder.h" <br class="title-page-name"/> <br class="title-page-name"/>class RaiderBuilder: public M5ObjectBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>virtual M5Object* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>// RaiderBuilder.cpp-------------------- <br class="title-page-name"/>#include "RaiderBuilder.h" <br class="title-page-name"/>#include "M5Object.h" <br class="title-page-name"/>#include "M5ObjectManager.h" <br class="title-page-name"/> <br class="title-page-name"/>M5Object* RaiderBuilder::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  M5Object* pObj = new M5Object; <br class="title-page-name"/>  //Build and set Gfx component for Raider <br class="title-page-name"/>  GfxComponent* pGfx = <br class="title-page-name"/>     M5ObjectManager::CreateComponent(CT_GfxComponent); <br class="title-page-name"/>  pGfx-&gt;SetTexture("enemyBlack3.tga"); <br class="title-page-name"/>  pGfx-&gt;SetDrawSpace(DS_WORLD); <br class="title-page-name"/> <br class="title-page-name"/>  //Build and set behavior for Raider <br class="title-page-name"/>  ChasePlayerComponent* pCP = <br class="title-page-name"/>     M5ObjectManager::CreateComponent(CT_ChasePlayerComponent); <br class="title-page-name"/>  pPI-&gt;SetSpeed(40); <br class="title-page-name"/> <br class="title-page-name"/>  pObj-&gt;AddComponent(pGfx); <br class="title-page-name"/>  pObj-&gt;AddComponent(pCP); <br class="title-page-name"/> <br class="title-page-name"/>return pObj; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">In these two simple examples, we can see why each object builder needs to be different. Each specific object type will have a unique set of components. These examples only use two components each, but we haven't considered our physics colliders, any weapon components, or additional behaviors. Even in these short examples, both object types use a <kbd class="calibre14">GfxComponent</kbd> but the differences in data, such as texture, mean that we need different code. Since there is only one object class, as opposed to a hierarchy of derived classes, there is no way to let the object manage the creation of the necessary components.</p>
<p class="calibre2">To deal with this, we will either need a builder class for each object type or one object builder with a <kbd class="calibre14">switch</kbd> statement and a case for each object type. The problem with both solutions is that the list of components and the data for each component is likely to change often. Now, instead of being worried about high-level modules and dependencies, we have two new problems to be worried about.</p>
<p class="calibre2">The first problem is constant, and possibly long, compile times. We already know that as development continues, the game design will change. This could mean not only changing components, but also changing values inside those components. At some point, especially toward the end of development, the game may be complete, but not quite balanced. During this phase, game objects and the code responsible for them will be constantly tweaked. Changes in health, damage, speed, and other attributes could be changed frequently causing the code to be recompiled.</p>
<p class="calibre2">There are a lot of factors that can affect how long it takes to compile a project. In the best-case scenario, we would only change one file, and recompiling could be very fast. However, even a short build time such as 10 seconds can get annoying if the only thing that changed is a speed value from 10 to 11. Something as simple as balancing a single unit can take all day, and then still need additional tweaks as other units get balanced. Our goal here is to make modifying the object and seeing the results of the modification as fast as possible.</p>
<p class="calibre2">The second problem that comes up is related to who is responsible for making these balance changes. One scenario is that the programmer is responsible because all balance changes are code changes. This is a bad situation because, as we already mentioned, balancing can take a long time, and now both the designer and the programmer are involved. The designer may not be able to properly explain the desired result to the programmer, so they must sit together tweaking and compiling, repeatedly. It would be better if the designer was free to balance, and the programmer was free to fix bugs or optimize code where needed.</p>
<p class="calibre2">The other scenario is that the designer is responsible for making these balance changes to the code. The problem here is that the designer may not be as familiar with the engine, or with the programming language. It is very possible that the designer doesn't have programming experience at all, so they would not be familiar with IDEs or version control systems. The chance of introducing bugs or breaking the project could be very high.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Solution - reading from files</h1>
            

            
                
<p class="calibre2">Our solution to both problems is to move all hard-coded values into text or binary files that will be read by the engine at runtime. Since we are using a component-based system in our game, this means being able to define which components belong to an object in the file as well. The benefit of this approach is that these files could be created with a level editor or some other content creation tool by a designer. For now, we won't focus on how these files get created, but instead on how they are read into our engine and how we can use them in place of an object builder class.</p>
<p class="calibre2">Now that we have decided to define our objects in files, we need to think about when they will be read by our engine. There are a few different solutions to our problem. The first solution is to simply have our builder read a file every time we need a new Raider, Bullet, or Asteroid. This is a common first thought, but is a very bad idea. Reading files from the hard disk is very slow compared to accessing data already in RAM. Depending on the factors, it can be anywhere from 10,000 to 50,000 times slower or more. This is like a normal 5 minute drive to the store taking 173 days, 14 hours, and 40 minutes. If you started your drive on January 1st, you would arrive at the store on June 21st.</p>
<p class="calibre2">This doesn't mean that we should never read files from the hard disk. It just means that we need to be more strategic about it. Using this solution would mean we could be reading the exact same file many times during the same frame. This would be like taking that half-year trip to the store to buy eggs, going home, then immediately going back to the store to buy milk. Instead of reading the same file many times we should read it once and store the data into RAM. Since it is so slow, we should avoid reading and writing files during gameplay and instead load as much from our files during load time as we can.</p>
<p class="calibre2">In large scale games, such as <em class="calibre12">Rockstar's Grand Theft Auto 3</em>, there is too much data to keep in RAM all at once. A game like this will be constantly reading data from files that aren't currently in memory, and releasing resources that are no longer in use. This is done by reading files on separate threads so the main gameplay isn't paused or slowed down. There is a lot of work involved in this file streaming process, including making sure that key gameplay elements are in memory when the player needs them so gameplay isn't affected. However, even games that stream data like this don't waste time reading files repeatedly once they are in memory.</p>
<p class="calibre2">We won't be worrying about threads for now. So, a more common solution for us would be to read the file once during a load screen to create the object types we need, then simply to copy these objects whenever we need a new instance of them. This will allow us to focus on the pattern, as well as solve key issues related to this problem, without worrying about the difficulties involved in multithreaded architecture.</p>
<p class="calibre2">Even without using threads, we still have a problem. How do we copy the object that contains components without knowing the types? Typically, when creating new objects, we need the new keyword, which means we also need a constructor to call. Of course, we have an <kbd class="calibre14">enum</kbd> for the type, which means we could use a switch statement and call the correct copy constructor. However, we already know that switch statements can be difficult to maintain and should be avoided.</p>
<p class="calibre2">The component factory will create a new component of the correct type, but we would still need to write a copy function that can copy the data once it has been created. It would be nice if we had a function that would construct and copy the data, based on the type of object it is. We need a constructor that works like a virtual function.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Prototype pattern explained</h1>
            

            
                
<p class="calibre2">The Prototype pattern gives us a way to copy a class without knowing the actual type of that class. This is often referred to as a virtual constructor because we can use it to create and copy a derived class while only using a base class pointer or reference. This pattern is most powerful when used with object hierarchies, but it doesn't only need to be used with virtual functions. Another purpose of the Prototype pattern is simply to create a prototypical (or archetypical) instance of an object and to use that to copy from.</p>
<p class="calibre2">Imagine that we are creating a level editor. In the middle of the tool we would have the map of the level. Here we can place tiles, power-ups, enemies, and players. Along the side of the map, we would have all the objects and tiles used in our game that can be placed on the map. This can be seen in the following screenshot:</p>
<div><img class="image-border21" src="img/00043.jpeg"/></div>
<p>Figure 6 1 - Example of a Simple Level Editor</p>
<p class="calibre2">Since we are striving for clean code, we have a clear separation between the part of the code that handles drawing, the part of the code that handles clicking and manipulating the objects on the side, and the part of the code that defines our specific object type. However, when we click and drag an object from the side, we would make a new instance of the object that was clicked and would draw it at the mouse location, and eventually on the map where the user places it. Based on the Dependency Inversion Principle, we know we don't want our high-level modules depending on our low-level objects. Instead, they should both depend on abstractions.</p>
<p>Prototype versus Archetype<br class="calibre27"/>
<br class="calibre27"/>Before we learn more about this pattern we should talk a little about word choice. In the Mach5 Engine, the files we will be reading and creating, as well as the enumerations we will be using, are called archetypes instead of prototypes. An Archetype is a perfect, unchanging, ideal example of a thing. A prototype is typically an early, usually unrefined version of something that later versions can depart from. While both words could be correct, the authors use the word Archetype to refer to the object definitions in the files, even though the pattern is called the Prototype pattern.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The virtual constructor</h1>
            

            
                
<p class="calibre2">The Prototype pattern is simple. It involves giving an object for which you might want to copy a <kbd class="calibre14">Clone</kbd> method, and letting the object know about the details of how to perform the clone. The actual name of the method isn't important. <kbd class="calibre14">Clone</kbd> is just one common example. This is most powerful when used with object hierarchies in which you want to copy an object, but don't know the type of derived object you might be holding. Simply add a <kbd class="calibre14">Clone</kbd> method to the interface of a hierarchy and have the derived classes each implement the method. Let's look at a simple example to start off:</p>
<div><img class="image-border22" src="img/00044.jpeg"/></div>
<p class="calibre2">In the following code, we have our interface object, <kbd class="calibre14">Shape</kbd>. We will just be talking about simple shapes in this example. Since this class will be used as an interface, we must mark the destructor as virtual so the correct destructor will get called when derived classes are deleted. Next, we have two pure virtual methods. The <kbd class="calibre14">Draw</kbd> method could be any action that we need virtual behavior with. In this simple case, we will just be using printed statements instead of drawing shapes on the screen. The <kbd class="calibre14">Clone</kbd> method will be our virtual constructor. This method will know how to copy itself and return a new instance:</p>
<pre class="calibre23">
class Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~Shape(void) {}//empty base class constructor <br class="title-page-name"/>  virtual void Draw(void) const    = 0; <br class="title-page-name"/>  virtual Shape* Clone(void) const = 0; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Now, let's look at the derived class examples:</p>
<pre class="calibre23">
class Circle : public Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual void Draw(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    std::cout &lt;&lt; "I'm a Circle" &lt;&lt; std::endl; <br class="title-page-name"/>  } <br class="title-page-name"/>  virtual Shape* Clone(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return new Circle(*this); <br class="title-page-name"/>  } <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class Square : public Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual void Draw(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    std::cout &lt;&lt; "I'm a Square" &lt;&lt; std::endl; <br class="title-page-name"/>  } <br class="title-page-name"/>  virtual Shape* Clone(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return new Square(*this); <br class="title-page-name"/>  } <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class Triangle : public Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual void Draw(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    std::cout &lt;&lt; "I'm a Triangle" &lt;&lt; std::endl; <br class="title-page-name"/>  } <br class="title-page-name"/>  virtual Shape* Clone(void) const <br class="title-page-name"/>  { <br class="title-page-name"/>    return new Triangle(*this); <br class="title-page-name"/>  } <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Of course, our derived classes know how to draw themselves. To keep things simple, the <kbd class="calibre14">Draw</kbd> methods are just printing to the console. The important part here is that each <kbd class="calibre14">Draw</kbd> method has a different behavior; in this case, a hardcoded string to print. The <kbd class="calibre14">Clone</kbd> methods are where the real magic happens--each one returns a new instance of itself. Specifically, they are calling their own copy constructors. This will allow the client to hold a pointer to any <kbd class="calibre14">Shape</kbd>, and get a copy of the correct derived type without knowing or caring which constructor to call. Let's look at an example of this using code:</p>
<pre class="calibre23">
int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  //seed the RNG <br class="title-page-name"/>  std::srand(static_cast&lt;unsigned&gt;(time(0))); <br class="title-page-name"/>  //Create my shapes <br class="title-page-name"/>  const int MAX = 3; <br class="title-page-name"/>  Shape* shapes[MAX] = { new Circle(),  <br class="title-page-name"/>                          new Square(),  <br class="title-page-name"/>                          new Triangle() }; <br class="title-page-name"/> <br class="title-page-name"/>      for (int i = 0; i &lt; MAX * 2; ++i) <br class="title-page-name"/>  { <br class="title-page-name"/>    Shape* pCopy = shapes[std::rand() % MAX]-&gt;Clone(); <br class="title-page-name"/>    copy-&gt;Draw(); <br class="title-page-name"/>    delete pCopy; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  //make sure to delete my original shapes <br class="title-page-name"/>  for (int i = 0; i &lt; MAX; ++i) <br class="title-page-name"/>    delete shapes[i]; <br class="title-page-name"/> <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The first few lines are simply initializing the random number generator and the array of shapes. In the array, you can see that we create a new instance of a <kbd class="calibre14">Circle</kbd>, <kbd class="calibre14">Square</kbd>, and <kbd class="calibre14">Triangle</kbd>. These will be our prototype <kbd class="calibre14">Shapes</kbd> to clone.</p>
<p class="calibre2">The next section is a loop to show the <kbd class="calibre14">Clone</kbd> method at work. We use a random index into the array and clone an object. Since it is random, we can't know which <kbd class="calibre14">Shape</kbd> will be cloned. This is simulating a random click by the user. Once we clone the <kbd class="calibre14">Shape</kbd>, we are free to call <kbd class="calibre14">Draw</kbd> or any other interface method we need. At the end of the loop, we delete the cloned <kbd class="calibre14">Shape</kbd> but, of course, that doesn't delete our prototype <kbd class="calibre14">Shape</kbd> from the array because it was a copy of the object. After the loop, we go through our prototype array and delete each of those shapes as well.</p>
<p class="calibre2">The following is the output for the preceding code:</p>
<pre class="calibre23">
I'm a Triangle <br class="title-page-name"/>I'm a Square <br class="title-page-name"/>I'm a Square <br class="title-page-name"/>I'm a Circle <br class="title-page-name"/>I'm a Circle <br class="title-page-name"/>I'm a Square 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The problem with constructors</h1>
            

            
                
<p class="calibre2">Now that we have seen a little about virtual constructors and the Prototype pattern, let's look at exactly what problem we are trying to solve.</p>
<p class="calibre2">To understand the problem of construction, we first need to understand the difference between a class and an object of that class. Classes are what the programmer creates. They are the code template or recipe that the program uses to create objects. In C++, we cannot create classes at runtime. We don't have a way to introduce new code while the program is running.</p>
<p class="calibre2">This is because C++ is a statically typed language. This means that the language tries to prevent operations if they can't be performed on that type at compile time. For example, we can't divide a float by a <kbd class="calibre14">void*</kbd> because the C++ compiler checks a compile time if the operation makes sense, and will issue an error if it doesn't.</p>
<p class="calibre2">This static typing in C++ is why we are forced to declare a type for every variable. It is also why we are required to specify the constructor in a case like this:</p>
<pre class="calibre23">
Base* p = new Derived; 
</pre>
<p class="calibre2">In this case, the compiler must know the class that we are trying to create. Unfortunately, in C++, classes do not have first class status. That means we can't pass a class as an argument to a function or use a class as a return value. We can't copy a class, save it in a variable, or create one at runtime. Some languages do have these features. Here is an example of what you could do if classes had first class status in C++:</p>
<pre class="calibre23">
//This isn't real C++ code <br class="title-page-name"/>Shape* CreateShape(class theShape) <br class="title-page-name"/>{ <br class="title-page-name"/>  Shape* pShape = new theShape; <br class="title-page-name"/>  return pShape; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">While this might be useful, we would be trading some type safety for flexibility. The static type checking that the C++ compiler performs has the chance to catch problems before they become bugs at runtime. This is a good thing. We should enjoy the type checking C++ provides. We should also recognize when it has an impact on our code flexibility.</p>
<p class="calibre2">Even though C++ is a statically typed language, we have ways of getting around this problem. One such way was with the factories that we created in the last chapter. We were forced to write the factories ourselves, but we still can choose which class gets created at runtime, while getting the benefits of static typing for all other classes and types. Factories are just one way we can avoid the rigidity of classes not having first class status. The virtual constructor is another way.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The benefits of a virtual constructor</h1>
            

            
                
<p class="calibre2">Using a virtual constructor can be very powerful. The biggest benefit is that we can now treat classes as if they had first class status. We can make copies of an object without knowing the exact type of the object. We can use the Prototype pattern in our level editor example, but we could also use it in our game. Anytime we need to make a copy without truly knowing the type, we can use this pattern. As we said before, C++ is a statically typed language, meaning the compiler will make sure we are using the correct types at compile time. This static type checking helps us write safer code.</p>
<p class="calibre2">By using Dynamic Factories and virtual constructors, we are bypassing this type checking a little. The compiler is still doing the type checking on the pointers we are working with, but we are choosing our derived class at runtime. This has the chance to lead to bugs that are difficult to find if we somehow mix up the types we are cloning. That doesn't mean we shouldn't use the patterns; it is just good to understand that we are giving up a little safety for flexibility.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">We don't need to know the type</h1>
            

            
                
<p class="calibre2">As we said, the biggest benefit of using the Prototype pattern is that we can make copies without knowing the type. This means we can make a copy of a function parameter or function return type without caring about the derived class involved. This also means that we can share a pointer with another class or method and we don't need to care if the type is modified.</p>
<p class="calibre2">In the following example, we have a <kbd class="calibre14">SpawnShape</kbd> class with the ability to spawn a specific type of shape. By using the Prototype pattern, the class doesn't need to care what type it is spawning. The constructor takes a pointer to some shape and then it just needs to call the <kbd class="calibre14">Clone</kbd> method. If the base class pointer is pointing to a <kbd class="calibre14">Circle</kbd>, then a circle will be created. However, if we have a pointer to a <kbd class="calibre14">Triangle</kbd>, then a triangle will be created. Here is an example that shows the Prototype pattern in action:</p>
<pre class="calibre23">
class ShapeSpawner <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>ShapeSpawner (Shape* pShape, float maxTime): <br class="title-page-name"/>  m_pToSpawn(pShape), <br class="title-page-name"/>  m_spawnTime(0.f), <br class="title-page-name"/>  m_maxSpawnTime(maxTime) <br class="title-page-name"/>{ <br class="title-page-name"/>  } <br class="title-page-name"/>void Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_spawnTime += dt; <br class="title-page-name"/>  if(m_spawnTime &gt; m_maxSpawnTime) <br class="title-page-name"/>  { <br class="title-page-name"/>    //The class doesn't care what type it is cloning <br class="title-page-name"/>    Shape* pClone = m_pToSpawn-&gt;Clone(); <br class="title-page-name"/> <br class="title-page-name"/>    //...Register the clone somehow <br class="title-page-name"/> <br class="title-page-name"/>    //Reset timer   <br class="title-page-name"/>    m_spawnTime = 0; <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>private: <br class="title-page-name"/>  Shape* m_pToSpawn; <br class="title-page-name"/>  float  m_spawnTime; <br class="title-page-name"/>  float  m_maxSpawnTime; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Our <kbd class="calibre14">SpawnShape</kbd> class doesn't care if it is spawning a <kbd class="calibre14">Circle</kbd>, <kbd class="calibre14">Square</kbd>, or <kbd class="calibre14">Triangle</kbd>, or any new shape we might create later. It can make copies without knowing the real type of the shape. If we add a public <kbd class="calibre14">SetShape</kbd> method, we could even change the type that spawns at runtime. Compare this with a more rigid example that can only spawn <kbd class="calibre14">Circles</kbd>:</p>
<pre class="calibre23">
<strong class="calibre1">class CircleSpawner</strong> <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>CircleSpawner (Circle* pCircle, float maxTime): <br class="title-page-name"/>  m_pToSpawn(pCircle), <br class="title-page-name"/>  m_spawnTime(0.f), <br class="title-page-name"/>  m_maxSpawnTime(maxTime) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/>  void Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_spawnTime += dt; <br class="title-page-name"/>  if(m_spawnTime &gt; m_maxSpawnTime) <br class="title-page-name"/>  { <br class="title-page-name"/>    //Use copy constructor <br class="title-page-name"/><strong class="calibre1">    Circle* pClone = new Circle(*m_pToSpawn);</strong> <br class="title-page-name"/> <br class="title-page-name"/>    //...Register the clone somehow <br class="title-page-name"/> <br class="title-page-name"/>    //Reset timer   <br class="title-page-name"/>    m_spawnTime = 0; <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>private: <br class="title-page-name"/><strong class="calibre1">  Circle* m_pToSpawn;</strong> <br class="title-page-name"/>  float   m_spawnTime; <br class="title-page-name"/>  float   m_maxSpawnTime; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">In the second example (not using the Prototype pattern) we are forced to use the copy constructor of the derived class, in this case the <kbd class="calibre14">Circle</kbd>. If we want to spawn a <kbd class="calibre14">Square</kbd> or a <kbd class="calibre14">Triangle</kbd>, we would need to create a <kbd class="calibre14">SquareSpawner</kbd> or <kbd class="calibre14">TriangleSpawner</kbd>. That is a lot of repeated code. It could get worse as we add even more shapes. By using the Prototype pattern, we can reduce the number of classes we need.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">No need to subclass</h1>
            

            
                
<p class="calibre2">The reduction in classes is another big benefit of using a virtual constructor. In the case above, we only needed a single <kbd class="calibre14">SpawnShape</kbd> instead of duplicating our spawn class or making derived versions. Consider our factory builder classes that we saw before. We were forced to create an abstract base class and create derived classes for every new <kbd class="calibre14">M5Component</kbd> and <kbd class="calibre14">M5Stage</kbd> that we used. C++ templates helped us autogenerate that code, but the code still exists.</p>
<p class="calibre2">By using a virtual constructor, we don't need derived builder classes for every <kbd class="calibre14">M5Stage</kbd>, <kbd class="calibre14">M5Component</kbd>, <kbd class="calibre14">Shape</kbd>, or other inheritance hierarchy. We can let the objects copy themselves. Does that mean we should remove our factories and always use the Prototype pattern? It depends.</p>
<p class="calibre2">Remember that with the Prototype pattern, we must first instantiate an object before it can be cloned. This is fine with shapes or components because these types are very small. However, the <kbd class="calibre14">M5Stage</kbd> derived classes may be very big and they also may cause side effects. This means that the constructor of a stage may add objects to the <kbd class="calibre14">M5ObjectManager</kbd> or may load textures or another large resource.</p>
<p class="calibre2">Since using C++ templates made creating our builders so easy, we can keep using them for stages and components. However, we want to avoid making builders for the <kbd class="calibre14">M5Object</kbd> because those builders are very likely to change during development. By using virtual constructors and creating prototypes (or archetypes) that can clone themselves, the rest of our code will not be affected by changes to our types.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">It's easy to make exact copies</h1>
            

            
                
<p class="calibre2">Here, the concept of a prototype doesn't need to be used with virtual functions. We may have a group of objects, for example, easy, hard, and insane enemies that we want to copy. These objects may be the exact same class type, but they could have very different values for health, speed, and damage. In this case, we have our prototypical example that we want to copy from. Of course, in this case we could also just use a copy constructor, but it is possible, as in the case of the Mach5 Engine, that the copy constructor doesn't exist.</p>
<p class="calibre2">Either way, since we don't need to create derived builder classes, we can add prototypes at runtime. Take the above example of the easy, hard, and insane enemy types. We could have just a single file that defines the health of an easy enemy with a value of <kbd class="calibre14">50</kbd>, for example. Then at runtime we could create a hard enemy prototype with a health of <kbd class="calibre14">100</kbd> and an insane enemy with a health of <kbd class="calibre14">200</kbd>. We could always just double the values of health and damage for each hard and insane enemy, or the file could contain the scale factor for the hard and insane versions.</p>
<p class="calibre2">Another example where we might want to modify the data would be if we had an enemy base that spawned enemies after a set time (like our <kbd class="calibre14">ShapeSpawner</kbd> from above). In this example, the base might increase the health and damage of the object over time. So, the base might initially create enemies with health of <kbd class="calibre14">50</kbd>, but after each spawn, the health is increased by <kbd class="calibre14">5</kbd>. So, the second enemy has a health of <kbd class="calibre14">55</kbd>. The third enemy has a health of <kbd class="calibre14">60</kbd>. Since each base has a specific instance, each base would be spawning enemies with different health values.</p>
<p class="calibre2">The object could also be modified via an in-game level editor. Imagine the benefit of play testing a level only to realize that enemies are killed too easily. With the Prototype pattern and an in-game level editor, we could pause the game, edit attributes of an object type, and continue playing. This method wouldn't require programmers, or recompile times. It doesn't even require a game restart. Of course, this same effect could also be done with a separate level editor or by just modifying the Archetype files and reloading the files at runtime. In these situations, we can see that creating copies of a specific instance is very easy and very useful.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Examples of the clone method in Mach5</h1>
            

            
                
<p class="calibre2">So far, we have seen simple examples of how the Prototype pattern is implemented. If you thought that the examples were easy, you are in luck--it doesn't get much harder than that. We also discussed a few ways in which an object instance and a virtual constructor can be useful in a game. Now let's look at how the Mach 5 Engine uses the Prototype pattern in the <kbd class="calibre14">M5Component</kbd> and <kbd class="calibre14">M5Object</kbd> classes. Since the <kbd class="calibre14">M5Object</kbd> class uses the <kbd class="calibre14">M5Component Clone</kbd> method, let's look at the components first.</p>
<p class="calibre2">In <a href="part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 3</a>, <em class="calibre12">Improving on the Decorator Pattern with the Component Object Model</em>, we examined almost all the methods and member variables in the <kbd class="calibre14">M5Component</kbd> class. However, the method we didn't talk about was the <kbd class="calibre14">Clone</kbd> method:</p>
<pre class="calibre23">
//! M5Component.h <br class="title-page-name"/>class M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>//! virtual constructor for M5Component, must override <br class="title-page-name"/>virtual M5Component* Clone(void) const = 0;   <br class="title-page-name"/>   <br class="title-page-name"/>//The rest of the class is the same as before <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">As you can see, the <kbd class="calibre14">M5Component</kbd> class implements a pure virtual <kbd class="calibre14">Clone</kbd> method just like we saw above in the <kbd class="calibre14">Shape</kbd> class. Since the <kbd class="calibre14">M5Component</kbd> class is used only as an abstract base class, we don't want to provide any default behaviors for cloning. Cloning only makes sense for derived classes. This part of the component was shown again so we can understand what the interface for overloading this method should be.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Gfx and collider components</h1>
            

            
                
<p class="calibre2">Now that we have seen the interface, let's look at two very important components. These are important because they allow game objects to interact with two of the other core pieces of our engine, graphics and physics.</p>
<p class="calibre2">The first one we will look at is the <kbd class="calibre14">GfxComponent</kbd> class. This class allows the game object to have a visual representation in the game. It contains the two minimum pieces of information to draw an object in the game:</p>
<pre class="calibre23">
//GfxComponent.h <br class="title-page-name"/>enum DrawSpace <br class="title-page-name"/>{ <br class="title-page-name"/>  DS_WORLD, <br class="title-page-name"/>  DS_HUD <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class GfxComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  GfxComponent(void); <br class="title-page-name"/>  ~GfxComponent(void); <br class="title-page-name"/>  void Draw(void) const; <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual GfxComponent* Clone(void) const; <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  void SetTextureID(int id); <br class="title-page-name"/>  void SetDrawSpace(DrawSpace drawSpace); <br class="title-page-name"/>private: <br class="title-page-name"/>  int       m_textureID;  //!&lt; Texture id loaded from graphics. <br class="title-page-name"/>  DrawSpace m_drawSpace;  //!The space to draw in <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">The two pieces of information we need to draw an object are which texture to draw and which space to draw in. Of course, we need a texture to draw, but the draw space may be a bit more confusing. It is just an <kbd class="calibre14">enum</kbd> letting us know which type of graphics projection should be used with the object. For now, it is enough to know that the HUD draw space is always on top and isn't affected by camera movement or camera zoom. Of course, there could be more data, such as texture color and texture coordinates. These could be added in a derived class if we wanted. Here we are just showing the basics.</p>
<p class="calibre2">There are a few functions used to set these values, as well as a <kbd class="calibre14">FromFile</kbd> function that we talked about a little before. The <kbd class="calibre14">Update</kbd> function doesn't do anything for this component because there is nothing to update. The <kbd class="calibre14">Draw</kbd> function will be called by the graphics engine, making each <kbd class="calibre14">M5Component</kbd> responsible for drawing itself. However, the most important function for this chapter is the <kbd class="calibre14">Clone</kbd>:</p>
<pre class="calibre23">
GfxComponent* GfxComponent::Clone(void) const <br class="title-page-name"/>{ <br class="title-page-name"/>  //Allocates new object and copies data <br class="title-page-name"/>  GfxComponent* pNew = new GfxComponent; <br class="title-page-name"/>  pNew-&gt;m_pObj = m_pObj; <br class="title-page-name"/>  pNew-&gt;m_textureID = m_textureID; <br class="title-page-name"/>  pNew-&gt;m_drawSpace = m_drawSpace; <br class="title-page-name"/> <br class="title-page-name"/>  if (m_drawSpace == DrawSpace::DS_WORLD) <br class="title-page-name"/>    M5Gfx::RegisterWorldComponent(pNew); <br class="title-page-name"/>  else <br class="title-page-name"/>    M5Gfx::RegisterHudComponent(pNew); <br class="title-page-name"/> <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">In this function, we simply create a new <kbd class="calibre14">GfxComponent</kbd> and copy the relevant data from this object to the newly created one. What you don't see is that in the <kbd class="calibre14">GfxComponent</kbd> constructor, the component type is set by calling the <kbd class="calibre14">M5Component</kbd> component constructor which, of course, also gives this component a unique ID. The last thing we do is register this component with the graphics engine depending on the draw space. This class automatically unregisters itself when it is destroyed:</p>
<pre class="calibre23">
GfxComponent::GfxComponent(void): <br class="title-page-name"/>  M5Component(CT_GfxComponent), <br class="title-page-name"/>  m_textureID(0), <br class="title-page-name"/>  m_drawSpace(DrawSpace::DS_WORLD) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/>GfxComponent::~GfxComponent(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  M5Gfx::UnregisterComponent(this); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Now that we have seen the <kbd class="calibre14">GfxComponent</kbd>, let's look at the most basic of all physics colliders. The Mach5 Engine <kbd class="calibre14">ColliderComponent</kbd> is as simple as possible for a 2D game. For now, it is only concerned with circle versus circle collisions. It could easily be extended to test for rectangle collision as well:</p>
<pre class="calibre23">
//ColliderComponent.h <br class="title-page-name"/>class ColliderComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ColliderComponent(void); <br class="title-page-name"/>  ~ColliderComponent(void); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  virtual ColliderComponent* Clone(void) const; <br class="title-page-name"/>  void TestCollision(const ColliderComponent* pOther); <br class="title-page-name"/>private: <br class="title-page-name"/>  float m_radius; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">This class is a lot like the previous one because it is connected to one of the core pieces of the game engine. Just like all components, <kbd class="calibre14">FromFile</kbd> must be overloaded to read component data from an <kbd class="calibre14">.ini</kbd> file. <kbd class="calibre14">Update</kbd> must also be overloaded but, just like with the <kbd class="calibre14">GfxComponent</kbd>, this doesn't do anything in this simple version. If the class used oriented bounding boxes, the <kbd class="calibre14">Update</kbd> function could be used to update the corner points of the oriented box. The <kbd class="calibre14">TestCollision</kbd> function is also important. It is called by the <strong class="calibre1">Physics Engine</strong> to test if this object is colliding with another object. If it is, the two objects are added to a list of colliding pairs that can be resolved later. Again, the most important function for this chapter is the <kbd class="calibre14">Clone</kbd>:</p>
<pre class="calibre23">
ColliderComponent* ColliderComponent::Clone(void) const <br class="title-page-name"/>{ <br class="title-page-name"/>  ColliderComponent* pNew = new ColliderComponent; <br class="title-page-name"/>  pNew-&gt;m_radius = m_radius; <br class="title-page-name"/>  pNew-&gt;m_pObj   = m_pObj; <br class="title-page-name"/>  M5Phy::RegisterCollider(pNew); <br class="title-page-name"/> <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Just like the <kbd class="calibre14">GfxComponent</kbd>, this component first creates a new version of itself, then copies the important information into the new component. Before returning the new component, it first registers itself with the physics engine. Since it is registered, it must be unregistered when it is destroyed, so we do that in the destructor:</p>
<pre class="calibre23">
ColliderComponent::ColliderComponent(void) : <br class="title-page-name"/>   M5Component(CT_ColliderComponent), m_radius(0) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/>ColliderComponent::~ColliderComponent(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  M5Phy::UnregisterCollider(this); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">There are a few things to point out with both classes. First, notice that we don't clone the <kbd class="calibre14">m_type</kbd>, the <kbd class="calibre14">m_id</kbd>, or the <kbd class="calibre14">isDead</kbd> variables. This isn't necessary. The type is set by the constructor in the <kbd class="calibre14">M5Component</kbd> base class when we call the constructor. The <kbd class="calibre14">id</kbd> is also set in the base class, but it is important to point out that the purpose of the <kbd class="calibre14">m_id</kbd> is to be unique. It wouldn't serve the correct purpose if we also copied the <kbd class="calibre14">id</kbd>. Instead, we are copying the rest of the important data but we recognize that this is a separate component, not just an exact copy. For the same reason, we also don't copy the <kbd class="calibre14">isDead</kbd> variable. We are creating a new component that is like the old one, but still a unique component. If we copied the <kbd class="calibre14">isDead</kbd>, this component would be deleted in this frame or the next.</p>
<p class="calibre2">Next, both classes register themselves with engines in the clone method instead of the constructor. This is because of how they are intended to be used. Our object manager will hold a collection of these pre-created prototype components at the start of the game so they are ready to be cloned. We don't want these initial components to pollute the graphics or physics engine.</p>
<p class="calibre2">However, we are assuming that an object is being cloned and it also needs to live in the game world, so we register at that time. This seems like the most standard reason for cloning. It is better for the user to only worry about cloning, than to worry about cloning, registering, and then unregistering. If the user wishes to do something non-standard, they are free to unregister after cloning.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Cloning an object</h1>
            

            
                
<p class="calibre2">We have seen a few examples of how <kbd class="calibre14">M5Component</kbd> derived classes use the Prototype pattern. We will look at a few more important ones a little later, but for now let's look at how the <kbd class="calibre14">M5Object</kbd> class uses these <kbd class="calibre14">Clone</kbd> methods, and how the <kbd class="calibre14">M5Object</kbd> itself is cloned. Recall that the <kbd class="calibre14">M5Object</kbd> also had a <kbd class="calibre14">Clone</kbd> method. Even though this class isn't part of a hierarchy, it can still use the concept of the Prototype pattern to create cloneable instances. Here is the <kbd class="calibre14">Clone</kbd> method of the <kbd class="calibre14">M5Object</kbd>:</p>
<pre class="calibre23">
//M5Object.h <br class="title-page-name"/>class M5Object//Everything is the same as before <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  M5Object*    Clone(void) const; <br class="title-page-name"/>}; <br class="title-page-name"/>//M5Object.cpp <br class="title-page-name"/>M5Object* M5Object::Clone(void) const <br class="title-page-name"/>{ <br class="title-page-name"/>  //create new object <br class="title-page-name"/>  M5Object* pClone = new M5Object(m_type); <br class="title-page-name"/>  //copy the internal data <br class="title-page-name"/>  pClone-&gt;pos         = pos; <br class="title-page-name"/>  pClone-&gt;vel         = vel; <br class="title-page-name"/>  pClone-&gt;scale       = scale; <br class="title-page-name"/>  pClone-&gt;rotation    = rotation; <br class="title-page-name"/>  pClone-&gt;rotationVel = rotationVel; <br class="title-page-name"/> <br class="title-page-name"/>  //clone all components <br class="title-page-name"/>  size_t size = m_components.size(); <br class="title-page-name"/>  for (size_t i = 0; i &lt; size; ++i) <br class="title-page-name"/>  { <br class="title-page-name"/>    M5Component* pComp = m_components[i]-&gt;Clone(); <br class="title-page-name"/>    pClone-&gt;AddComponent(pComp); <br class="title-page-name"/>  } <br class="title-page-name"/>  return pClone; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The important thing when we clone is that we copy all the relevant data from the old object. This includes not only things like the position and velocity but also all the components. So, we start off the function by both creating a new instance of the object we will be creating and passing the correct type to the constructor. This will set the <kbd class="calibre14">m_type</kbd> and <kbd class="calibre14">m_id</kbd> variables. Remember, even though we are cloning, we want to make sure that each object has a unique ID. Next, we copy the data. Just as with components, we don't need to copy the <kbd class="calibre14">isDead</kbd> value.</p>
<p class="calibre2">Finally, we have a loop to clone all components in the current object. This shows the power of the Prototype pattern. We don't need to know the types of each component--all we need to do is loop, call <kbd class="calibre14">Clone</kbd> to make our copy, then add that copy to the newly created object. Remember that the <kbd class="calibre14">AddComponent</kbd> method will change the <kbd class="calibre14">m_pObj</kbd> in each component. This will ensure that all components point to their correct owners.</p>
<p class="calibre2">In the end, the Prototype pattern is easy. Each component's <kbd class="calibre14">Clone</kbd> method is simple, and using them to clone an object is simple. Even using these cloned objects in the <kbd class="calibre14">M5ObjectManager</kbd> is easy. We will look at that in the next few pages, but first let's talk about a few details that some readers may have noticed. The first is that we didn't use a copy constructor in any of the Mach5 <kbd class="calibre14">Clone</kbd> methods, even though we did in the <kbd class="calibre14">Shape</kbd> example. The next is that the return types of the <kbd class="calibre14">GfxComponent</kbd> and <kbd class="calibre14">CollideComponent</kbd> are different from the return type in the <kbd class="calibre14">M5Component</kbd> interface.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Choosing a copy constructor</h1>
            

            
                
<p class="calibre2">As we said, and as you saw in the code examples above, we didn't use copy constructors in any of the component <kbd class="calibre14">Clone</kbd> methods. We also didn't use them in the <kbd class="calibre14">Clone</kbd> method of <kbd class="calibre14">M5Object</kbd>. By default, classes have copy constructors and assignment operators generated by the compiler. In the <kbd class="calibre14">Shape</kbd> example above, we used the compiler generated copy constructor in our <kbd class="calibre14">Clone</kbd> methods.</p>
<p class="calibre2">However, in the Mach5 Engine there is an important choice to consider. What should the copy constructor do about the <kbd class="calibre14">m_id</kbd> variable value? Remember that this ID is supposed to be unique for every object and every component. However, if we use the compiler generated copy constructor, each variable, including <kbd class="calibre14">m_id</kbd>, will be copied by value. This would mean that any time we use the copy constructor, we would have two objects with the exact same ID.</p>
<p class="calibre2">Sometimes this is what we want, such as if we wanted to have a vector of objects instead of pointers to objects, for example. When using standard vectors (and other containers), the copy constructor gets called when adding to the container. If we were to add an object, we probably would want it to copy the ID. It is also possible that we would want to shift the position of the object around the container. Most likely, we would want it to keep the same ID.</p>
<p class="calibre2">However, this is not the behavior we want in our <kbd class="calibre14">Clone</kbd> methods. We want each clone to be a separate entity with a different unique ID. Of course, we could write our own copy constructor and give a different ID to each newly created object or component, just as we do in the default constructors. Unfortunately, if we did that using standard containers we would be generating new IDs for every time they internally called the copy constructor. In this case, the IDs wouldn't match up to the correct objects or components.</p>
<p class="calibre2">In the Mach5 Engine we use containers of pointers instead of containers of objects or components, so the authors decided to remove the copy constructors (and assignment operators) all together. This will remove all confusion about the process. If you want a copy, you call the <kbd class="calibre14">Clone</kbd> method, because you can't call the copy constructor. It is fine to make a different decision. In a different engine that uses containers of objects instead of pointers, a different decision would probably be made.</p>
<p class="calibre2">In the Mach5 Engine, we remove these methods from the object by making them private so that they can't be called. In C++ 11, you can mark them as deleted so the compiler won't generate them for you. The assignment operators will already be removed because these classes contain <kbd class="calibre14">const</kbd> data that can't be reassigned:</p>
<pre class="calibre23">
//In M5Object.h <br class="title-page-name"/>M5Object(const M5Object&amp; rhs) = delete; <br class="title-page-name"/> <br class="title-page-name"/>//In M5Component.h <br class="title-page-name"/>M5Component(const M5Component&amp; rhs) = delete; 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Covariant return types</h1>
            

            
                
<p class="calibre2">Astute readers will also have noticed that the return types of each <kbd class="calibre14">Clone</kbd> method in the Mach5 Engine are actually different. The base <kbd class="calibre14">M5Component</kbd> class returns an <kbd class="calibre14">M5Component*</kbd>, however the derived classes return pointers to their own class types. This is a feature of C++ (as well as some other languages) known as covariant return types. Let's look at this feature using the <kbd class="calibre14">Shape</kbd> class from above:</p>
<pre class="calibre23">
class Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~Shape(void) {}//empty base class constructor <br class="title-page-name"/>  virtual void Draw(void) const    = 0; <br class="title-page-name"/>  virtual Shape* Clone(void) const = 0; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class Circle : public Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual void Draw(void) const; <br class="title-page-name"/>  virtual Shape* Clone(void) const; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  Circle* pCircle = new Circle(); <br class="title-page-name"/> <br class="title-page-name"/>   //The line won't compile <br class="title-page-name"/><strong class="calibre1">  Circle* pClone = pCircle-&gt;Clone();</strong> <br class="title-page-name"/> <br class="title-page-name"/>  delete pClone; <br class="title-page-name"/>  delete pCircle; <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">If the <kbd class="calibre14">Clone</kbd> method of the <kbd class="calibre14">Circle</kbd> class returns a <kbd class="calibre14">Shape*</kbd>, the compiler won't allow us to directly assign the result to a <kbd class="calibre14">Circle*</kbd>. We would need to do either a <kbd class="calibre14">static_cast</kbd> or <kbd class="calibre14">dynamic_cast</kbd>, meaning we would have to write code like this:</p>
<pre class="calibre23">
  Circle* pCircle = new Circle(); <br class="title-page-name"/>  Shape* pClone  = pCircle-&gt;Clone(); <br class="title-page-name"/>   <br class="title-page-name"/>  Circle* pCircle2 = dynamic_cast&lt;Circle*&gt;(pClone); <br class="title-page-name"/>  if (pCircle2) <br class="title-page-name"/>  { <br class="title-page-name"/>    //do something specific to circle <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">In both cases, the <kbd class="calibre14">Clone</kbd> method will return a circle. However, there is no way for the compiler to know this, so we are forced to do the cast. The standard rule for using virtual functions is that the function signature must be the same, including the return type. With covariant return types, the compiler will allow us to replace the base class of a return type with a more specific type in the inheritance hierarchy:</p>
<pre class="calibre23">
class Circle : public Shape <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual void Draw(void) const; <br class="title-page-name"/>   //Example of using a covariant return type <br class="title-page-name"/>  virtual Circle* Clone(void) const; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  Circle* pCircle = new Circle(); <br class="title-page-name"/>  //No need to cast <br class="title-page-name"/>  Circle* pClone = pCircle-&gt;Clone(); <br class="title-page-name"/>   <br class="title-page-name"/>  //... Do something Circle specific with pClone <br class="title-page-name"/> <br class="title-page-name"/>  delete pClone; <br class="title-page-name"/>  delete pCircle; <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">By using covariant return types, we can eliminate the need for unnecessary casting in cases where we clone an object that needs to access properties of its true type. It is worth noting that this feature only works with pointers or references. That means if the <kbd class="calibre14">Clone</kbd> method of <kbd class="calibre14">Shape</kbd> was returning a shape, instead of <kbd class="calibre14">Shape*</kbd>, we wouldn't have the option of doing this.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Loading archetypes from a file</h1>
            

            
                
<p class="calibre2">Now that we have seen the Prototype pattern in detail and discussed how it is used with the components of the Mach5 Engine, let's look at how we can use it to load object data from a file. To do that, we will need to first look at the object files, then look at specific methods in the <kbd class="calibre14">M5ObjectManager</kbd> used to load and create these objects.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Archetype files</h1>
            

            
                
<p class="calibre2">The first thing we need to do is look at how we define our object archetype within a file. The Mach5 Engine uses <kbd class="calibre14">.ini</kbd> files for archetypes, levels, and anything related to initialization of the engine. A more standard file format would be XML or JSON if you wanted to keep them as human readable and modifiable. If you didn't want them to be modified by users, the files could always be saved as binary.</p>
<p class="calibre2">We have chosen <kbd class="calibre14">.ini</kbd> files because they are easy to read by both humans and a computer program. They only have a few simple rules, so they are easy to explain in just a few sentences. They only contain named sections which are defined by square brackets <kbd class="calibre14">[ ]</kbd>, and key value pairs in the form of <kbd class="calibre14">key = value</kbd>. The only exception is the global section, which doesn't have a name and therefore no square brackets. Let's look at a basic example of an Archetype file. This is an example of <kbd class="calibre14">Player.ini</kbd>:</p>
<pre class="calibre23">
posX       = 0 <br class="title-page-name"/>posY       = 0 <br class="title-page-name"/>velX       = 0 <br class="title-page-name"/>velY       = 0 <br class="title-page-name"/>scaleX     = 10 <br class="title-page-name"/>scaleY     = 10 <br class="title-page-name"/>rot        = 0 <br class="title-page-name"/>rotVel     = 0 <br class="title-page-name"/>components = GfxComponent PlayerInputComponent ColliderComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture       = playerShip.tga <br class="title-page-name"/>drawSpace     = world <br class="title-page-name"/> <br class="title-page-name"/>[PlayerInputComponent] <br class="title-page-name"/>forwardSpeed  = 100 <br class="title-page-name"/>speedDamp     = .99 <br class="title-page-name"/>bulletSpeed   = 7000 <br class="title-page-name"/>rotationSpeed = 10 <br class="title-page-name"/> <br class="title-page-name"/>[ColliderComponent] <br class="title-page-name"/>radius        = 5 
</pre>
<p class="calibre2">As you can see, the global section of the <kbd class="calibre14">Player.ini</kbd> file contains values for everything variable that is defined in <kbd class="calibre14">M5Object</kbd>. Except for the components key, everything is read in the <kbd class="calibre14">FromFile</kbd> method of the <kbd class="calibre14">M5Object</kbd>. In this case, most of our starting values are zero. This is because things like the starting position for the player object will depend on the level, so this data will be modified after creation.</p>
<p class="calibre2">The more important part is the components. The components key contains a list of components that the object will use. These strings will be used by the <kbd class="calibre14">M5ObjectManager</kbd> to create a component and then read the specific component data defined in each section. This allows us to reuse components, such as the <kbd class="calibre14">ColliderComponent</kbd>, because each object that uses them can have different component data. In this case, the player object will have a radius of <kbd class="calibre14">5</kbd>, but a bullet might have a radius of <kbd class="calibre14">1</kbd>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The object manager</h1>
            

            
                
<p class="calibre2">The <kbd class="calibre14">M5ObjectManager</kbd> is a singleton class that is responsible for, among other things, loading archetypes and creating objects. There are a lot of members and methods in this class so looking at everything would take too long. In this section, we will only go over the methods specifically related to loading and creating an object from an Archetype file. Remember that since the class is a singleton, we have global access. For that reason, every member and method is static:</p>
<pre class="calibre23">
class M5ObjectManager <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  static M5Object* CreateObject(M5ArcheTypes type); <br class="title-page-name"/>  static void AddArcheType(M5ArcheTypes type,  <br class="title-page-name"/>                            const char* fileName); <br class="title-page-name"/>  static void RemoveArcheType(M5ArcheTypes type); <br class="title-page-name"/>    <br class="title-page-name"/>   //Plus other methods <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  typedef M5Factory&lt;M5ComponentTypes,  <br class="title-page-name"/>                   M5ComponentBuilder,  <br class="title-page-name"/>                   M5Component&gt;  ComponentFactory; <br class="title-page-name"/>  typedef std::unordered_map&lt;M5ArcheTypes,  <br class="title-page-name"/>                            M5Object*&gt;  ArcheTypeMap <br class="title-page-name"/>static ComponentFactory  s_componentFactory; <br class="title-page-name"/>static ArcheTypesMap     s_archetypes; <br class="title-page-name"/> <br class="title-page-name"/>//Plus other members <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Here we have the most important members and methods to show how objects are loaded from a file. What we haven't shown here are methods related to destroying or searching for specific objects. If you are interested in those functions, feel free to review the full source code that comes with this book.</p>
<p class="calibre2">In the public section, the <kbd class="calibre14">AddArcheType</kbd> method will be used to read an archetype file, create the object, and store it for later. The <kbd class="calibre14">RemoveArcheType</kbd> method is used to delete the object when it is no longer needed. Finally, the <kbd class="calibre14">CreateObject</kbd> method will be used to clone one of the previously loaded archetypes. In the private section, we have a few types defined for creating easier names. You can see we are using the templated Dynamic Factory that we created in <a href="part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 5</a>, <em class="calibre12">Decoupling Code via the Factory Method Pattern</em>. We also have a map of the loaded Archetype objects.</p>
<p class="calibre2">Let's take a closer look at these methods:</p>
<pre class="calibre23">
void M5ObjectManager::AddArcheType(M5ArcheTypes type, <br class="title-page-name"/>   const char* fileName) <br class="title-page-name"/>{ <br class="title-page-name"/>  MapItor found = s_archetypes.find(type); <br class="title-page-name"/>  M5DEBUG_ASSERT(found == s_archeypes.end(), <br class="title-page-name"/>     "Trying to add a prototype that already exists"); <br class="title-page-name"/> <br class="title-page-name"/>  M5IniFile file; <br class="title-page-name"/>  file.ReadFile(fileName); <br class="title-page-name"/>  M5Object* pObj = new M5Object(type); <br class="title-page-name"/>  pObj-&gt;FromFile(file); <br class="title-page-name"/>   <br class="title-page-name"/>  std::string components;//A string of all my components <br class="title-page-name"/>  file.GetValue("components", components); <br class="title-page-name"/> <br class="title-page-name"/>//parse the component string and create each component <br class="title-page-name"/>  std::stringstream ss(components); <br class="title-page-name"/>  std::string name; <br class="title-page-name"/> <br class="title-page-name"/>//Loop through the stream and get each component name <br class="title-page-name"/>  while (ss &gt;&gt; name) <br class="title-page-name"/>  { <br class="title-page-name"/>    M5Component* pComp = s_componentFactory.Build( <br class="title-page-name"/>                         StringToComponent(name)); <br class="title-page-name"/>    pComp-&gt;FromFile(file); <br class="title-page-name"/>    pObj-&gt;AddComponent(pComp); <br class="title-page-name"/>  } <br class="title-page-name"/>//Add the prototype to the prototype map <br class="title-page-name"/>  s_archeypes.insert(std::make_pair(type, pObj)); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This might seem like a difficult function, but this is where the magic happens. Let's start at the beginning. This function takes two parameters, an enumeration ID specifying the type to create, and a file name to associate with that <kbd class="calibre14">enum</kbd> ID. Next, we need to check if this <kbd class="calibre14">M5Archetypes</kbd> ID has been loaded before. If it has, there must be an error. After checking for the <kbd class="calibre14">enum</kbd> error, we read the <kbd class="calibre14">.ini</kbd> file. If the file does not exist, the <kbd class="calibre14">ReadFile</kbd> method will assert.</p>
<p class="calibre2">If there haven't been any errors, we create a brand new <kbd class="calibre14">M5Object</kbd>, and pass the <kbd class="calibre14">M5ArcheTypes</kbd> ID to the constructor. This simply sets the type of the object, but doesn't do anything else. To set the data for the object, we call the <kbd class="calibre14">FromFile</kbd> method to read the global section from the <kbd class="calibre14">.ini</kbd> file. This will set the position, scale, rotation, and everything else in the object except the actual component, which needs to be handled differently.</p>
<p class="calibre2">The trouble with the components is that the file contains the component names as strings but, for the sake of performance during the game, we want to avoid doing string comparisons. This means we need to somehow convert these strings to an <kbd class="calibre14">enum</kbd> value. This is the purpose of the <kbd class="calibre14">StringToComponent</kbd> function. This function is an <kbd class="calibre14">if</kbd>/<kbd class="calibre14">else</kbd> chain that will return the correct enum based on the parameter. Functions like this can be a problem to maintain. We will discuss in a later chapter about how to use Windows batch files to automate this process.</p>
<p class="calibre2">After we read the object data from the file, we read the component list from the file. This is a list of component names separated by a space. There are lots of ways we could extract each individual component name, but one of the easiest ways is to use an STL <kbd class="calibre14">stringstream</kbd> object. This allows us to extract separate strings from the stream, just like <kbd class="calibre14">std::cin</kbd>.</p>
<p class="calibre2">After creating our <kbd class="calibre14">stringstream</kbd> object, we loop through the stream and extract the name. We then use <kbd class="calibre14">s_componentFactory</kbd> to build the correct component, after it has been converted to a <kbd class="calibre14">M5ComponentTypes</kbd> enum. After the correct component is built, we pass the <kbd class="calibre14">.ini</kbd> file to the component's <kbd class="calibre14">FromFile</kbd> method to let the derived component read its own data. Then we make sure to add the component to the object. Finally, after all components have been read, we add the type and object pointer to our <kbd class="calibre14">s_archetypes</kbd> map.</p>
<p class="calibre2">This may seem like a complicated way of loading objects. However, this function doesn't need to know about any derived component types, or which components go with a specific object type. If our archetype <kbd class="calibre14">.ini</kbd> files change, we don't need to recompile this code. We are free to add, remove, or change objects in our game and our high-level module, the <kbd class="calibre14">M5ObjectManager</kbd>, doesn't need to change:</p>
<pre class="calibre23">
void M5ObjectManager::RemoveArcheType(M5ArcheTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>  MapItor found = s_archetypes.find(type); <br class="title-page-name"/>  M5DEBUG_ASSERT(found != s_archetypes.end(), <br class="title-page-name"/>     "Trying to Remove a prototype that doesn't exist"); <br class="title-page-name"/> <br class="title-page-name"/>  delete found-&gt;second; <br class="title-page-name"/>  found-&gt;second = 0; <br class="title-page-name"/>  s_archetypes.erase(found); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre14">RemoveArcheType</kbd> method is much simpler than the <kbd class="calibre14">AddArcheType</kbd>. All we need to do here is make sure the type to delete exists in the map, which we do by first finding and using a debug assert if it isn't there. Then we delete the prototype object and erase the iterator within the map.</p>
<p class="calibre2">The <kbd class="calibre14">RemoveArcheType</kbd> method doesn't need to be called since all archetype objects will be deleted when the game exits. However, this could be used if the user wanted to minimize which archetypes existed throughout the game. By default, the Mach5 Engine automatically loads all archetype <kbd class="calibre14">.ini</kbd> files before the game begins:</p>
<pre class="calibre23">
M5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>  MapItor found = s_archetypes.find(type); <br class="title-page-name"/>  M5DEBUG_ASSERT(found != s_archetypes.end(), <br class="title-page-name"/>     "Trying to create and Archetype that doesn't exist"); <br class="title-page-name"/> <br class="title-page-name"/>  M5Object* pClone = found-&gt;second-&gt;Clone(); <br class="title-page-name"/>  s_objects.push_back(pClone);//A std::vector&lt;M5Object*&gt; <br class="title-page-name"/>  return pClone; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Finally, we have the method that allows the user to create Archetype objects. Here, the user supplies the <kbd class="calibre14">M5ArcheTypes</kbd> type that they want to create. First, the method does the standard error checking that we are familiar with. Then, after finding the correct iterator, we make use of the Prototype pattern's <kbd class="calibre14">Clone</kbd> method to copy all data and components from the Archetype object. After creating the object, we automatically add it to the list of active game objects and return the pointer to the user so they can modify things such as position and velocity if needed.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we focused a lot on creating flexible code. Since we are using the Component Object Model with our game objects, we want to make sure that, as our objects change, they handle that change well. This means we don't want to modify lots of other files as we playtest and balance our objects.</p>
<p class="calibre2">We said at the beginning of this chapter that the goal for our game objects is to completely define them in a file. Since we are using components in our objects, we want to define the components that are used by the objects within the file as well. By defining objects in a file, our programmers are free to work on other code and the designers can work on balance and play testing without fear of breaking the game or introducing bugs.</p>
<p class="calibre2">After looking at a simple example of the Prototype pattern, we looked at how it is used in the Mach5 Engine. We saw both the <kbd class="calibre14">M5Component</kbd> class and the <kbd class="calibre14">M5Object</kbd> use a <kbd class="calibre14">Clone</kbd> method to make copying objects easy. These of course, were used by the <kbd class="calibre14">M5ObjectManager</kbd> to allow the user to create objects based on the <kbd class="calibre14">M5ArcheTypes</kbd> enum.</p>
<p class="calibre2">Now that creating objects can be done through a file, we should focus on a problem that is more difficult to see. Since we are using lots of object pointers that will have lots of component pointers, we should talk about a few problems related to memory. This is what we will cover in the next chapter.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>