- en: Sharing Objects with the Flyweight Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously learned about object pools in [Chapter 7](part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7),
    *Improving Performance with Object Pools*, and that they are great for avoiding
    slowdowns in our game due to dynamic memory allocation. But, there are still other
    steps that we can take to reduce the amount of memory that we use to begin with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: When creating projects, you'll often run into times where you want to have many
    objects on the screen at once. While computers have become much more powerful
    over the past few years, they still can't handle thousands of complex game objects
    on the screen by themselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In order to accomplish this feat, programmers need to think of ways to lighten
    the memory load on their program. Using the Flyweight pattern, we abstract the
    common parts of our object and share them with only the data that's unique to
    each instance (such as position and current health) being created.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will construct a particle system consisting of two parts:
    the particle itself, which will be a simple struct, as well as a particle system
    class that contains the system''s data.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'We will construct two different types of particle system: an explosion that
    moves on its own, and a static one that spawns at the position of our player''s
    ship. We will also explore two ways to deal with the system data. The first will
    be for each particle system to contain its own copy of the system data. Then,
    after learning about the Flyweight pattern, we will use it to construct separate
    system data classes that we can assign using files or code. Then, each particle
    system will simply reference an instance of the system data that it needs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Your objectives
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to particles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing particles in Mach5
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why memory is still an issue
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Flyweight pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to ParticleSystems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introductions to particles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In game development, you may have heard of particles. They are typically small
    2D sprites or simple 3D models that are created in order to simulate *fuzzy* things
    such as fires, explosions, and smoke trails to add visual flair to your projects.
    This visual flair is sometimes referred to as *juiciness*. Made popular by indie
    developers *Martin Jonasson* and *Petri Purho*, making a game *juicy* makes it
    more enjoyable to play and increases the feedback the player receives by playing
    the game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: This is usually something worked on more toward the end of development of titles
    in order to polish the project and add more feedback, but it's a good example
    of how we can want to have many things on the screen at one time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: For more information on juiciness and to watch their Martin and Petri's GDC
    talk on the subject, check out [http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php](http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The reason that these objects are so simple is because they are spawned hundreds
    and sometimes thousands of times, and this is done over and over again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Implementing particles in Mach5
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what particles are, let's put them into Mach5 so we can get
    an example of how they work. We will be creating particles to follow our ship
    while it moves in a similar fashion to a smoke trail. This will be a great way
    to show an example of particles on the screen but, to have something to show,
    we will first need to bring a new archetype into the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To do that, open up the `Example Code` folder for this chapter and bring the
    `particle.tga` file into the `EngineTest/Textures` folder of your Visual Studio
    project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, open up the `EngineTest/ArcheTypes` folder, create a new text file
    called `Particle.ini`, and fill it with the following info:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, we need the Mach5 engine to support our new object, so go to the
    `EngineTest` folder and then double-click on the `PreBuild.bat` file. The `M5ArcheTypes.h`
    file will be updated to include our particle:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nice! Now that we have the object in the game, there's still the issue of putting
    in the Particle component. Since this component is not exclusive to our game,
    let's move over to the Core/Components filter and create a new filter called `ParticleComp`.
    From there, create two new files, `ParticleComponent.h` and `ParticleComponent.cpp`,
    making sure their locations are set to the `Mach5-master\EngineTest\EngineTest\Source\`
    folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.h` file, use the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class looks similar to other components that we've added in the past, but
    this time we've added a `startScale` property to keep track of what scale our
    object had at the start of its life, and an `endScale` property to be a modifier
    on how to change the scale. We also have `lifeTime`, which will be how long this
    object should live before we remove it, and `lifeLeft`, which will be how much
    longer this object has to live. Finally, since we are going to change our scale,
    we added another function, `Lerp`, to linearly interpolate between a starting
    and ending value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.cpp` file, use the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code will modify the object''s scale by using the `Lerp` function to interpolate
    between the starting and ending scale. We also will modify how much life the particle
    has left, and if it has none, mark the particle for deletion:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Linear interpolation** (**Lerp**) allows us to obtain a value between `start`
    and `end` using the `fraction` property for how far along the transition it should
    be. If `fraction` is `0`, we would get the value of `start`. If we give `1`, we
    will get the value of `end`. If it''s `.5`, then we would get the half-way point
    between `start` and `end`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: For more information on interpolation including linear interpolation, check
    out *Keith Maggio*'s notes on the topic at [https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/](https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Clone` function allows us to create a copy of this object. It will create
    a new version of this component, and we will initialize the values of the new
    component with the values we currently have. This is used by the Mach5 engine
    in the creation of new game objects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like before, the `FromFile` function will read in our `ini` file we created
    previously and will use the values from it to set the properties of this component.
    In our case, here we set `lifeTime`, `lifeLeft`, and `endScale`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s start putting these objects into our game. Open up the `PlayerInputComponent.cpp`
    file and add the following to the top of the `Update` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will cause a particle to get spawned in every single frame and have the
    same position as our ship. Now, if we run the game, we should see some cool stuff!
    We can see this in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: As you can see, our ship now has a trail following behind it. Each part is a
    particle!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Why memory is still an issue
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The particle system that we are currently showing is probably running well enough
    on some computers, but note that a large number of the variables that we have
    created hold data that will never change once we've initialized them. Now, generally
    in programming we would mark a variable that wouldn't change as `const`, but we
    don't set the variable until we read from a file. We could potentially make the
    variables static, but there's also the chance that we may want to have more particle
    systems in the future and I don't want to create an archetype for each one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If we continue to spawn many particles, the memory that it takes up will increase
    and we will be wasting valuable space in memory that we could be using for other
    purposes. To solve this issue, we will employ the Flyweight pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Flyweight pattern
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Gang of Four states that a Flyweight is a shared object that can be used
    in multiple contexts simultaneously. Similarly to flyweight in boxing, which is
    the lightweight boxing category, we can have a lighter object that can be used
    in different places in our system simultaneously.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: While not used terribly often nowadays, the Flyweight pattern can be very helpful
    in scenarios when memory is constrained.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'A Flyweight will consist of two parts: the intrinsic state and the extrinsic
    state. The intrinsic state is the part that can be shared. The extrinsic state
    is modified based on the context it''s being used in and, as such, cannot be shared.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a UML diagram to see a closer look:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: We have the **FlyweightFactory** class, which is used to manage the Flyweights.
    Whenever we request one, we will either give one that's been created or create
    a new one ourselves.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The **Flyweight** object itself has data that is of whatever type is needed,
    as long as it won't change depending on the object that we're working with.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the **ConcreteFlyweight**, which acts as our extrinsic information
    that can access and use our **Flyweight** via the **FlyweightFactory**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to ParticleSystems
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So with that in mind, what we will do is separate the information that will
    be shared by each particle, which we will call a `ParticleSystem`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The class acts as our intrinsic state, which is shared. Since the starting scale,
    end scale, and lifetime of our object never change, it makes sense for these variables
    to be shared instead of each object having one. In our previous example, we only
    had one particle system, but we may want the ability to have more as well, and
    it's when we start using it that some of the benefits of the Flyweight pattern
    become even more apparent. That's why we gave this class two virtual functions: `Init`
    and `Update`. We can have our extrinsic state call these functions, giving the
    function information about the particular object we're dealing with, and then
    we can modify it using these properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Creating different system types
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new type of particle system in addition to our current one that
    doesn''t move. Let''s call it `Moving` and our previous one, `Static`. To differentiate
    between the two, let''s add an `enum`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now modify the original `ParticleComponent` class, by removing the previously
    created variables and instead including a reference to the kind of `ParticleSystem`
    we wish to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ParticleComponent` class acts as our extrinsic state, holding information
    about how much time it has left and the properties from the `M5Component` class,
    such as a reference to the object we want to create.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to create two classes to refer to each of these:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Developing the ParticleFactory
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need some way for our `ParticleComponent` to access this information. With
    that in mind, we will make use of the Factory design pattern that we learned about
    in [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7), *Decoupling
    Code via the Factory Method Pattern*, and create a `ParticleFactory` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `ParticleFactory` class is what we use to manage the creation of these
    Flyweights and to ensure that, if the object is already located in our map, we
    will return it. Otherwise, we will create a new object to be able to access it.
    I also added an `objectCount` variable to help us know how many objects currently
    exist and to verify that no memory leaks are occurring.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The `ParticleSystems` variable is of type map, which is actually one of my favorite
    containers in the `stl` and can be considered an *associative array*. By that,
    I mean instead of memorizing numbers in order to access certain indexes of an
    array, you can use a different type, such as a `string,` or in this case, an `enum`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the map container, check out [http://www.cprogramming.com/tutorial/stl/stlmap.html](http://www.cprogramming.com/tutorial/stl/stlmap.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we will need to define the two static variables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the ParticleFactory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will need to adjust our previously created Particle archetype and component
    to reflect these changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to change our `.ini` file. Since the `Particle` object is meant
    for all particle types, instead of having the properties being set there, we will
    instead set a base type for us to use:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This simplifies the particle object itself, but it''s for a good cause. We
    will now update the code of the `ParticleComponent` class as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this instance, you''ll notice that instead of modifying the scale and/or
    movement being done here, we use the `ParticleFactory` to update our code based
    on the `particleType` property:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we call the `Init` function for our particle system based on its type
    from the factory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are now going to set our particle type based on what is marked on the `ini`
    file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'But, of course, now that we are using the `GetParticleSystem` function, we
    need to implement it for our code to compile:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this script, we make use of the `particleSystems` map that we talked about
    earlier. The first thing that we do is check if there is an object in the map
    that has our `ParticleType` in it. If not, then we need to create one. In this
    case, I added a `switch` statement that will assign different values depending
    on the value mentioned in the `case` statement, but you could easily read these
    values from a text file in a similar manner to how files are read for archetypes.
    You''ll notice that we are calling new in order to create these, so we will need
    to call `delete` on them as well in order to avoid any memory leaks. To accomplish
    this, I''ve added in a destructor for the `ParticleFactory` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to write the implementations for our different `ParticleSystems`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Lerp` function does the same for either particle type, so it''s fine the
    way it was:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The static version of the `Init` and `Update` functions will just set our velocity
    to `0` so we don''t move:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For our moving particle system, we will set our velocity to a random number
    in the *x* and *y* axis, causing a nice explosion effect!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的运动粒子系统，我们将速度设置为*x*轴和*y*轴上的随机数，从而产生一个漂亮的爆炸效果！
- en: 'Now, instead of creating a copy of this data each time, we will have one copy
    that we will access, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再每次都创建数据的副本，而将有一个副本供我们访问，如下面的截图所示：
- en: '![](img/00059.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: As we play, you'll notice that we now have a new particle system working and
    it's doing its job quite well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，你会发现我们现在有一个新的粒子系统正在运行，并且它的工作相当出色。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we learned about particles and how they can
    be used in order to improve the polish of our game project. We learned how we
    can implement a particle system inside of the Mach5 engine, and then learned about
    the Flyweight pattern and how it can be used effectively in order to reduce the
    memory usage on your projects. We saw how to do this by making use of the Factory
    pattern too, while making it a lot easier for us to create new particle system
    types as well. Keeping this in mind, it will be a lot easier in the future to
    break apart pieces of your programs that stay consistent and only create additional
    variables when you need to!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们学习了粒子以及如何利用它们来提升我们的游戏项目的品质。我们学习了如何在Mach5引擎中实现粒子系统，然后学习了Flyweight模式以及如何有效地使用它来减少项目中的内存使用。我们还看到了如何通过使用工厂模式来实现这一点，同时使创建新的粒子系统类型变得更加容易。考虑到这一点，未来在需要时，将更容易拆分保持一致性的程序部分，并且只创建额外的变量！
- en: Moving forward, in the next chapter we will dive into graphics and the concepts
    needed to understand how our code will affect moving and animating game objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨图形以及理解我们的代码如何影响移动和动画游戏对象所需的概念。
