<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Containers</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Comparing strings in an ultra-fast manner</li><li class="listitem" style="list-style-type: disc">Using an unordered set and map</li><li class="listitem" style="list-style-type: disc">Making a map, where value is also a key</li><li class="listitem" style="list-style-type: disc">Using multi-index containers</li><li class="listitem" style="list-style-type: disc">Getting the benefits of single-linked list and memory pool</li><li class="listitem" style="list-style-type: disc">Using flat associative containers</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Introduction</h1></div></div></div><p>This chapter is devoted to the Boost containers<a id="id545" class="indexterm"/> and the things directly connected with them. This chapter provides information about the Boost classes that can be used in every day programming, and that will make your code much faster, and the development of new applications easier.</p><p>Containers differ not only by functionality, but also by the efficiency (complexity) of some of their members. The knowledge about complexities is essential for writing fast applications. This chapter doesn't just introduce some new containers to you; it gives you tips on when and when not to use a specific type of container or its methods.</p><p>So, let's begin!</p></div></div>
<div class="section" title="Comparing strings in an ultra-fast manner"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Comparing strings in an ultra-fast manner</h1></div></div></div><p>It is a common<a id="id546" class="indexterm"/> task to manipulate strings. Here we'll see how the operation of <a id="id547" class="indexterm"/>string comparison can be done quickly using some simple tricks. This recipe is a trampoline for the next one, where the techniques described here will be used to achieve constant time-complexity searches.</p><p>So, we need to make a class that is capable of quickly comparing strings for equality. We'll make a<a id="id548" class="indexterm"/> template function to measure the speed of comparison:</p><div class="informalexample"><pre class="programlisting">#include &lt;string&gt;

template &lt;class T&gt;
std::size_t test_default() {
    // Constants
    const std::size_t ii_max = 20000000;
    const std::string s(
        "Long long long string that "
        "will be used in tests to compare "
        "speed of equality comparisons."
    );
    
    // Making some data, that will be 
    // used in comparisons
    const T data[] = {
        T(s),
        T(s + s),
        T(s + ". Whooohooo"),
        T(std::string(""))
    };

    const std::size_t data_dimensions = sizeof(data) / sizeof(data[0]);
    std::size_t matches = 0u;
    for (std::size_t ii = 0; ii &lt; ii_max; ++ii) {
        for (std::size_t i = 0; i &lt; data_dimensions; ++i) {
            for (std::size_t j = 0; j &lt; data_dimensions; ++j) {
                if (data[i] == data[j]) {
                    ++ matches;
                }
            }
        }
    }

    return matches;
}</pre></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec339"/>Getting ready</h2></div></div></div><p>This recipe requires only the basic knowledge of STL and C++.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec340"/>How to do it...</h2></div></div></div><p>We'll make <code class="literal">std::string</code>
<a id="id549" class="indexterm"/> a public field in our own class, and add all the comparison code to our<a id="id550" class="indexterm"/> class, without writing helper methods to work with stored <code class="literal">std::string</code>, as shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To do so, we'll need the following header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/functional/hash.hpp&gt;</pre></div></li><li class="listitem">Now we can create our fast comparison class:<div class="informalexample"><pre class="programlisting">struct string_hash_fast {
    typedef std::size_t comp_type;

    const comp_type     comparison_;
    const std::string   str_;

    explicit string_hash_fast(const std::string&amp; s)
        : comparison_(
            boost::hash&lt;std::string&gt;()(s)
        )
        , str_(s)
    {}
};</pre></div></li><li class="listitem">Do not forget to define the equality comparison operators:<div class="informalexample"><pre class="programlisting">inline bool operator == (const string_hash_fast&amp; s1, 
    const string_hash_fast&amp; s2) 
{
    return s1.comparison_ == s2.comparison_ 
        &amp;&amp; s1.str_ == s2.str_;
}

inline bool operator != (const string_hash_fast&amp; s1, 
    const string_hash_fast&amp; s2) 
{
    return !(s1 == s2);
}</pre></div></li><li class="listitem">And, that's it! Now we can run our tests and see the result using the following code:<div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
int main(int argc, char* argv[]) {
    if (argc &lt; 2) {
        assert(
            test_default&lt;string_hash_fast&gt;()
            ==
            test_default&lt;std::string&gt;()
        );
        return 0;
    }

    switch (argv[1][0]) {
    case 'h':
        std::cout &lt;&lt; "HASH matched: "
                  &lt;&lt; test_default&lt;string_hash_fast&gt;();
        break;

    case 's':
        std::cout &lt;&lt; "STD matched: "
                  &lt;&lt; test_default&lt;std::string&gt;();
        break;

    default:
        assert(false);
        return -2;
    }
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec341"/>How it works...</h2></div></div></div><p>The<a id="id551" class="indexterm"/> comparison of strings is slow because we are required to compare all the characters of the string one-by-one, if the strings are of equal length. Instead of doing that, we replace the comparison of strings with the comparison of integers. This is done via the hash function—the function that makes some short-fixed length representation of the string. Let us talk about the hash values on apples. Imagine that you have two apples with labels, as shown in the following diagram, and you wish to check that the apples are of the same cultivar. The simplest way to compare those apples is to compare them by labels. Otherwise you'll lose a lot of time comparing the apples based on the color, size, form, and other parameters. A hash is something like a label that reflects the value of the object.</p><div class="mediaobject"><img src="graphics/4880OS_09_01.jpg" alt="How it works..."/></div><p>So, let's move step-by-step.</p><p>In step 1, we <a id="id552" class="indexterm"/>include the header file that contains the definitions of the hash functions. In step 2, we declare our new string class that contains <code class="literal">str_</code>, which is the original value of the string and <code class="literal">comparison_</code>, which is the computed hash value. Note the construction:</p><div class="informalexample"><pre class="programlisting">boost::hash&lt;std::string&gt;()(s)</pre></div><p>Here, <code class="literal">boost::hash&lt;std::string&gt;</code> is a structure, a functional object just like <code class="literal">std::negate&lt;&gt;</code>. That is why we need the first parenthesis—we construct that functional object. The second parenthesis with <code class="literal">s</code> inside is a call to <code class="literal">std::size_t operator()(const std::string&amp; s)</code>, which will compute the hash value.</p><p>Now take a look at step 3 where we define <code class="literal">operator==</code>. Look at the following code:</p><div class="informalexample"><pre class="programlisting">return s1.comparison_ == s2.comparison_ &amp;&amp; s1.str_ == s2.str_;</pre></div><p>And, take additional care about the second part of the expression. The hashing operation loses information, which means that there is a possibility that more than one string produces exactly the same hash value. It means that if the hashes mismatch, there is a 100 percent guarantee that the strings will not match, otherwise we are required to compare the strings using the traditional methods.</p><p>Well, it's time to compare numbers. If we measure the execution time using the default comparison method, it will give us 819 milliseconds; however, our hashing comparison works almost two times faster and finishes in 475 milliseconds.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec342"/>There's more...</h2></div></div></div><p>C++11<a id="id553" class="indexterm"/> has the hash functional object, you may find it in the <code class="literal">&lt;functional&gt;</code> header in the <code class="literal">std::</code> namespace. You will know that the default Boost implementation of hash does not allocate additional memory and also does not have virtual functions. Hashing in Boost and STL is fast and reliable.</p><p>You can also specialize hashing for your own types. In Boost, it is done via specializing the <code class="literal">hash_value</code> function<a id="id554" class="indexterm"/> in the namespace of a custom type:</p><div class="informalexample"><pre class="programlisting">// Must be in namespace of string_hash_fast class
inline std::size_t hash_value(const string_hash_fast&amp; v) {
    return v.comparison_;
}</pre></div><p>This is different from STL specialization of <code class="literal">std::hash</code>, where you are required to make a template specialization of the <code class="literal">hash&lt;&gt;</code> structure in the <code class="literal">std::</code> namespace.</p><p>Hashing in Boost is defined for all the basic type arrays (such as <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">double</code>, and <code class="literal">char</code>), and for all the STL containers including <code class="literal">std::array</code>, <code class="literal">std::tuple</code>, and <code class="literal">std::type_index</code>. Some libraries also provide hash specializations, for example, <code class="literal">Boost.Variant</code> can hash any <code class="literal">boost::variant</code> class.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec343"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read the <span class="emphasis"><em>Using an unordered set and map</em></span> recipe for more information about the hash functions' usage.</li><li class="listitem" style="list-style-type: disc">The official documentation of <code class="literal">Boost.Functional/Hash</code> will tell you how to combine multiple hashes and provides more examples. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/ha">http://www.boost.org/doc/libs/1_53_0/doc/html/hash.html</a>.</li></ul></div></div></div>
<div class="section" title="Using an unordered set and map"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Using an unordered set and map</h1></div></div></div><p>In the previous recipe, we saw how <a id="id555" class="indexterm"/>string comparison can be optimized using hashing. After<a id="id556" class="indexterm"/> reading it, <a id="id557" class="indexterm"/>the following question may <a id="id558" class="indexterm"/>arise, "Can we make a <a id="id559" class="indexterm"/>container that will cache hashed values to use faster comparison?".</p><p>The answer is yes, and we can do much more. We can achieve almost constant time complexities for search, insertion, and removal of elements.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec344"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ and STL containers is required. Reading the previous recipe will also help.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec345"/>How to do it...</h2></div></div></div><p>This <a id="id560" class="indexterm"/>will be<a id="id561" class="indexterm"/> the simplest of all recipes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">All you need to do is just include the <code class="literal">&lt;boost/unordered_map.hpp&gt;</code> header, if we wish to use maps or the <code class="literal">&lt;boost/unordered_set.hpp&gt;</code> header, if we wish to use sets.</li><li class="listitem">Now you are free to use <code class="literal">boost::unordered_map</code>, instead of <code class="literal">std::map</code> and <code class="literal">boost::unordered_set</code> instead of <code class="literal">std::set</code>:<div class="informalexample"><pre class="programlisting">#include &lt;boost/unordered_set.hpp&gt;
void example() {
    boost::unordered_set&lt;std::string&gt; strings;

    strings.insert("This");
    strings.insert("is");
    strings.insert("an");
    strings.insert("example");

    assert(strings.find("is") != strings.cend());
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec346"/>How it works...</h2></div></div></div><p>Unordered containers<a id="id562" class="indexterm"/> store values and remember the hash of each value. Now if you wish to find a value in them, they will compute the hash of that value and search for that hash in the container. After the hash is found, the containers check for equality between the found value and the searched value. Then, the iterator to the value, or to the end of the container is returned.</p><p>Because the container can search for a constant width integral hash value, it may use some optimizations and algorithms suitable only for integers. Those algorithms guarantee constant search complexity O(1), when traditional <code class="literal">std::set</code> and <code class="literal">std::map</code> provide worse complexity O(log(N)), where N is the number of elements in the container. This leads us to a situation where the more elements in traditional <code class="literal">std::set</code>
<a id="id563" class="indexterm"/> or <code class="literal">std::map</code>
<a id="id564" class="indexterm"/>, the slower it works. However, the performance of unordered containers does not depend on the element count.</p><p>Such good performance never comes free of cost. In unordered containers, values are unordered (you are not surprised, are you?). It means that if we'll be outputting elements of containers from <code class="literal">begin()</code> to <code class="literal">end()</code>, as follows:</p><div class="informalexample"><pre class="programlisting">template &lt;class T&gt;
void output_example() {
    T strings;
    
    strings.insert("CZ"); strings.insert("CD");
    strings.insert("A"); strings.insert("B");
    std::copy(
        strings.begin(),
        strings.end(),
        std::ostream_iterator&lt;std::string&gt;(std::cout, "  ")
    );
}</pre></div><p>We'll get <a id="id565" class="indexterm"/>the following output for <code class="literal">std::set</code> and <code class="literal">boost::unordered_set</code>:</p><div class="informalexample"><pre class="programlisting">boost::unordered_set&lt;std::string&gt; : B  A  CD  CZ
std::set&lt;std::string&gt; : A  B  CD  CZ</pre></div><p>So, how much does the performance differ? Have a look at the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ TIME="%E" time ./unordered s</strong></span>

<span class="strong"><strong>STD matched: 20000000</strong></span>

<span class="strong"><strong>0:31.39</strong></span>

<span class="strong"><strong>$ TIME="%E" time ./unordered h</strong></span>

<span class="strong"><strong>HASH matched: 20000000</strong></span>

<span class="strong"><strong>0:26.93</strong></span>
</pre></div><p>The performance was measured using the following code:</p><div class="informalexample"><pre class="programlisting">template &lt;class T&gt;
std::size_t test_default() {
    // Constants
    const std::size_t ii_max = 20000000;
    const std::string s("Test string");
    
    T map;
    
    for (std::size_t ii = 0; ii &lt; ii_max; ++ii) {
        map[s + boost::lexical_cast&lt;std::string&gt;(ii)] = ii;
    }

    // Inserting once more
    for (std::size_t ii = 0; ii &lt; ii_max; ++ii) {
        map[s + boost::lexical_cast&lt;std::string&gt;(ii)] = ii;
    }

    return map.size();
}</pre></div><p>Note that<a id="id566" class="indexterm"/> the code contains a lot of string constructions, so it is not 100 percent correct to measure the speedup using this test. It is here to show that unordered containers are usually faster than ordered ones.</p><p>Sometimes a task might arise where we need to use a user-defined type in unordered containers:</p><div class="informalexample"><pre class="programlisting">struct my_type {
    int         val1_;
    std::string val2_;
};</pre></div><p>To do that, we need to write a comparison operator for that type:</p><div class="informalexample"><pre class="programlisting">inline bool operator == (const my_type&amp; v1, const my_type&amp; v2) {
    return v1.val1_ == v2.val1_ &amp;&amp; v1.val2_ == v2.val2_;}</pre></div><p>Now, specialize the hashing function for that type. If the type consists of multiple fields, we usually just need to combine the hashes of all the fields that participate in equal comparison:</p><div class="informalexample"><pre class="programlisting">std::size_t hash_value(const my_type&amp; v) {
    std::size_t ret = 0u;
    
    boost::hash_combine(ret, v.val1_);
    boost::hash_combine(ret, v.val2_);
    return ret;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>It is highly recommended to combine hashes using the <code class="literal">boost::hash_combine</code> function.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec347"/>There's more...</h2></div></div></div><p>Multiversions of containers are also available: <code class="literal">boost::unordered_multiset</code> is defined in the <code class="literal">&lt;boost/unordered_set.hpp&gt;</code> header, and <code class="literal">boost::unordered_multimap</code> is defined in the <code class="literal">&lt;boost/unordered_map.hpp&gt;</code> header. Just like in the case of STL, multiversions of containers are capable of storing multiple equal key values.</p><p>All the unordered containers allow you to specify your own hashing functor, instead of the default <code class="literal">boost::hash</code>. They also allow you to specialize your own equal comparison functor, instead of the default <code class="literal">std::equal_to</code>.</p><p>C++11 has all the unordered containers from Boost. You may find them in the headers: <code class="literal">&lt;unordered_set&gt;</code> and <code class="literal">&lt;unordered_map&gt;</code>, in the <code class="literal">std::</code> namespace, instead of <code class="literal">boost::</code>. The <a id="id567" class="indexterm"/>Boost and the STL versions have the same performance, and must work in the same way. However, Boost's unordered containers are available even on C++03 compilers, and make use of the rvalue reference emulation of <code class="literal">Boost.Move</code>, so you can use those containers for the move-only classes in C++03.</p><p>C++11 has no <code class="literal">hash_combine</code> function<a id="id568" class="indexterm"/>, so you will need to write your own:</p><div class="informalexample"><pre class="programlisting">template &lt;class T&gt;
inline void hash_combine(std::size_t&amp; seed, const T&amp; v)
{
    std::hash&lt;T&gt; hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed&lt;&lt;6) + (seed&gt;&gt;2);
}</pre></div><p>Or just use <code class="literal">boost::hash_combine</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec348"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The recipe <span class="emphasis"><em>Using the C++11 move emulation</em></span> in <a class="link" href="ch01.html" title="Chapter 1. Starting to Write Your Application">Chapter 1</a>, <span class="emphasis"><em>Starting to Write Your Application</em></span>, for more details on rvalue reference emulation of <code class="literal">Boost.Move</code></li><li class="listitem" style="list-style-type: disc">More information about the unordered containers is available on the official site at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html">http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html</a></li><li class="listitem" style="list-style-type: disc">More information about combining hashes and computing hashes for ranges is available at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/do">http://www.boost.org/doc/libs/1_53_0/do</a><a class="ulink" href="http://c/html/hash.html">c/html/hash.html</a></li></ul></div></div></div>
<div class="section" title="Making a map, where value is also a key"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Making a map, where value is also a key</h1></div></div></div><p>Several times in a year, we need something that can store and index a pair of values. Moreover, we need to get the first part of the pair using the second, and get the second part using the first. Confused? Let me show you an example. We are creating a vocabulary class, wherein <a id="id569" class="indexterm"/>when the users put values into it, the class must return identifiers and when the users put identifiers into it, the class must return values.</p><p>To be more practical, users will be entering login names into our vocabulary, and wish to get the unique identifier of a person. They will also wish to get all the persons' names using identifiers.</p><p>Let's see how it can be implemented using Boost.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec349"/>Getting ready</h2></div></div></div><p>Basic knowledge of STL and templates are required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec350"/>How to do it...</h2></div></div></div><p>This recipe is about the abilities of the <code class="literal">Boost.Bimap</code> library. Let's see how it can be used to implement this task:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need the following includes:<div class="informalexample"><pre class="programlisting">#include &lt;boost/bimap.hpp&gt;
#include &lt;boost/bimap/multiset_of.hpp&gt;</pre></div></li><li class="listitem">Now we are ready to make<a id="id570" class="indexterm"/> our vocabulary structure:<div class="informalexample"><pre class="programlisting">    typedef boost::bimap&lt;
        std::string,
        boost::bimaps::multiset_of&lt;std::size_t&gt;
    &gt; name_id_type;

    name_id_type name_id;</pre></div></li><li class="listitem">It can be filled using the following syntax:<div class="informalexample"><pre class="programlisting">    // Inserting keys &lt;-&gt; values
    name_id.insert(name_id_type::value_type(
        "John Snow", 1
    ));

    name_id.insert(name_id_type::value_type(
        "Vasya Pupkin", 2
    ));
    
    name_id.insert(name_id_type::value_type(
        "Antony Polukhin", 3
    ));

    // Same person as "Antony Polukhin"
    name_id.insert(name_id_type::value_type(
        "Anton Polukhin", 3
    ));</pre></div></li><li class="listitem">We can work with the left part of bimap just like with a map:<div class="informalexample"><pre class="programlisting">    std::cout &lt;&lt; "Left:\n";
    typedef name_id_type::left_const_iterator  left_const_iterator;
    for (left_const_iterator it = name_id.left.begin(),
         iend = name_id.left.end();
         it!= iend;
         ++it)
    {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; " &lt;=&gt; " &lt;&lt; it-&gt;second 
            &lt;&lt; '\n';
    }</pre></div></li><li class="listitem">The right <a id="id571" class="indexterm"/>part of bimap is almost the same as the left:<div class="informalexample"><pre class="programlisting">    std::cout &lt;&lt; "\nRight:\n";
    typedef name_id_type::right_const_iterator right_const_iterator;
    for (right_const_iterator it = name_id.right.begin(),
         iend = name_id.right.end();
         it!= iend;
         ++it)
    {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; " &lt;=&gt; " &lt;&lt; it-&gt;second 
            &lt;&lt; '\n';
    }</pre></div></li><li class="listitem">We also need to ensure that there is such a person in the vocabulary:<div class="informalexample"><pre class="programlisting">    assert(
        name_id.find(name_id_type::value_type(
            "Anton Polukhin", 3
        )) != name_id.end()
    );</pre></div></li><li class="listitem">That's it. Now, if we put all the code (except includes) inside <code class="literal">int main()</code>, we'll get the following output:<div class="informalexample"><pre class="programlisting">Left:
Anton Polukhin &lt;=&gt; 3
Antony Polukhin &lt;=&gt; 3
John Snow &lt;=&gt; 1
Vasya Pupkin &lt;=&gt; 2

Right:
1 &lt;=&gt; John Snow
2 &lt;=&gt; Vasya Pupkin
3 &lt;=&gt; Antony Polukhin
3 &lt;=&gt; Anton Polukhin</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec351"/>How it works...</h2></div></div></div><p>In step 2, we define the <code class="literal">bimap</code> type:</p><div class="informalexample"><pre class="programlisting">    typedef boost::bimap&lt;
        std::string,
        boost::bimaps::multiset_of&lt;std::size_t&gt;
    &gt; name_id_type;</pre></div><p>The first template parameter tells that the first key must have type <code class="literal">std::string</code>, and should work as <code class="literal">std::set</code>. The second template parameter tells that the second key must have type <code class="literal">std::size_t</code>. Multiple first keys can have a single second key value, just like in <code class="literal">std::multimap</code>.</p><p>We can specify the underlying behavior of <code class="literal">bimap</code> using classes from the <code class="literal">boost::bimaps::</code> namespace. We can use hash map as an underlying type for the first key:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/bimap/unordered_set_of.hpp&gt;
#include &lt;boost/bimap/unordered_multiset_of.hpp&gt;

typedef boost::bimap&lt;
    boost::bimaps::unordered_set_of&lt;std::string&gt;, 
    boost::bimaps::unordered_multiset_of&lt;std::size_t&gt; 
&gt; hash_name_id_type;</pre></div><p>When we do not specify the behavior of the key, and just specify its type, <code class="literal">Boost.Bimap</code> uses <code class="literal">boost::bimaps::set_of</code> as a default behavior. Just like in our example, we can try to express the following code using STL:</p><div class="informalexample"><pre class="programlisting">#include &lt;boost/bimap/set_of.hpp&gt;

typedef boost::bimap&lt;
    boost::bimaps::set_of&lt;std::string&gt;, 
    boost::bimaps::multiset_of&lt;std::size_t&gt; 
&gt; name_id_type;</pre></div><p>Using STL it would look like a combination of the following two variables:</p><div class="informalexample"><pre class="programlisting">// name_id.left
std::map&lt;std::string, std::size_t&gt; key1; 

// name_id.right
std::multimap&lt;std::size_t, std::string&gt; key2; </pre></div><p>As we can see from the preceding comments, a call to <code class="literal">name_id.left</code> (in step 4) will return a reference to something with an interface close to <code class="literal">std::map&lt;std::string, std::size_t&gt;</code>. A call to <code class="literal">name_id.right</code> from step 5 will return something with an interface close to <code class="literal">std::multimap&lt;std::size_t, std::string&gt;</code>.</p><p>In step 6, we work with a whole <code class="literal">bimap</code>, searching for a pair of keys, and making sure that they are in the container.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec352"/>There's more...</h2></div></div></div><p>Unfortunately, C++11 has nothing close to <code class="literal">Boost.Bimap</code>. Here we have some other bad news: <code class="literal">Boost.Bimap</code> does not support rvalue references, and on some compilers, insane numbers of warnings will be shown. Refer to your compiler's documentation to get the information about suppressing specific warnings.</p><p>The good news is that <code class="literal">Boost.Bimap</code> usually uses less memory than two STL containers, and makes searches as fast as STL containers. It has no virtual function calls inside, but does use dynamic allocations.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec353"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe, <span class="emphasis"><em>Using multi-index containers</em></span>, will give you more information about multi-indexing, and about the Boost library that can be used instead of <code class="literal">Boost.Bimap</code></li><li class="listitem" style="list-style-type: disc">Read the official documentation for more examples and information about <code class="literal">bimap</code> at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Using multi-index containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Using multi-index containers</h1></div></div></div><p>In the <a id="id572" class="indexterm"/>previous recipe, we made some kind of vocabulary, <a id="id573" class="indexterm"/>which is good when we need to work with pairs. But, what if we need much more advanced indexing? Let's make a program that indexes persons:</p><div class="informalexample"><pre class="programlisting">struct person {
    std::size_t     id_;
    std::string     name_;
    unsigned int    height_;
    unsigned int    weight_;
    person(std::size_t id, const std::string&amp; name, unsigned int height, unsigned int weight)
        : id_(id)
        , name_(name)
        , height_(height)
        , weight_(weight)
    {}
};

inline bool operator &lt; (const person&amp; p1, const person&amp; p2) {
    return p1.name_ &lt; p2.name_;
}</pre></div><p>We will <a id="id574" class="indexterm"/>need a lot of indexes; for example, by name, ID, height, and weight.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec354"/>Getting ready</h2></div></div></div><p>Basic knowledge of STL containers and unordered maps is required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec355"/>How to do it...</h2></div></div></div><p>All the indexes can be constructed and managed by a single <a id="id575" class="indexterm"/>
<code class="literal">Boost.Multiindex</code> container.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To do so, we will need a lot of includes:<div class="informalexample"><pre class="programlisting">#include &lt;boost/multi_index_container.hpp&gt;
#include &lt;boost/multi_index/ordered_index.hpp&gt;
#include &lt;boost/multi_index/hashed_index.hpp&gt;
#include &lt;boost/multi_index/identity.hpp&gt;
#include &lt;boost/multi_index/member.hpp&gt;</pre></div></li><li class="listitem">The hardest part is to construct the multi-index type:<div class="informalexample"><pre class="programlisting">    typedef boost::multi_index::multi_index_container&lt;
        person,
        boost::multi_index::indexed_by&lt;
            // names are unique
            boost::multi_index::ordered_unique&lt;
                boost::multi_index::identity&lt;person&gt;
            &gt;,
            // IDs are not unique, but we do not need then //ordered
            boost::multi_index::hashed_non_unique&lt;
                boost::multi_index::member&lt;
                    person, std::size_t, &amp;person::id_
                &gt;
            &gt;,
            // Height may not be unique, but must be sorted
            boost::multi_index::ordered_non_unique&lt;
                boost::multi_index::member&lt;
                    person, unsigned int, &amp;person::height_
                &gt;
            &gt;,
            // Weight may not be unique, but must be sorted
            boost::multi_index::ordered_non_unique&lt;
                boost::multi_index::member&lt;
                    person, unsigned int, &amp;person::weight_
                &gt;
            &gt;
        &gt; // closing for `boost::multi_index::indexed_by&lt;
    &gt; indexes_t;</pre></div></li><li class="listitem">Now we may insert values into our multi-index:<div class="informalexample"><pre class="programlisting">    indexes_t persons;
    
    // Inserting values
    persons.insert(person(1, "John Snow", 185, 80));
    persons.insert(person(2, "Vasya Pupkin", 165, 60));
    persons.insert(person(3, "Antony Polukhin", 183, 70));
    // Same person as "Antony Polukhin"
    persons.insert(person(3, "Anton Polukhin", 182, 70));</pre></div></li><li class="listitem">Let's construct <a id="id576" class="indexterm"/>a function for printing the index content:<div class="informalexample"><pre class="programlisting">template &lt;std::size_t IndexNo, class Indexes&gt;
void print(const Indexes&amp; persons) {
    std::cout &lt;&lt; IndexNo &lt;&lt; ":\n";

    typedef typename Indexes::template nth_index&lt;
            IndexNo
    &gt;::type::const_iterator const_iterator_t;

    for (const_iterator_t it = persons.template get&lt;IndexNo&gt;().begin(),
         iend = persons.template get&lt;IndexNo&gt;().end();
         it != iend;
         ++it)
    {
        const person&amp; v = *it;
        std::cout 
            &lt;&lt; v.name_ &lt;&lt; ", " 
            &lt;&lt; v.id_ &lt;&lt; ", " 
            &lt;&lt; v.height_ &lt;&lt; ", " 
            &lt;&lt; v.weight_ &lt;&lt; '\n'
        ;
    }
    
    std::cout &lt;&lt; '\n';
}</pre></div></li><li class="listitem">Print all the indexes as follows:<div class="informalexample"><pre class="programlisting">    print&lt;0&gt;(persons);
    print&lt;1&gt;(persons);
    print&lt;2&gt;(persons);
    print&lt;3&gt;(persons);</pre></div></li><li class="listitem">Some <a id="id577" class="indexterm"/>code from the previous recipe can also be used:<div class="informalexample"><pre class="programlisting">    assert(persons.get&lt;1&gt;().find(2)-&gt;name_ == "Vasya Pupkin");
    assert(
        persons.find(person(
            77, "Anton Polukhin", 0, 0
        )) != persons.end()
    );

    // Won' compile
    //assert(persons.get&lt;0&gt;().find("John Snow")-&gt;id_ == 1);</pre></div></li><li class="listitem">Now if we run our example, it will output the content of the indexes:<div class="informalexample"><pre class="programlisting">0:
Anton Polukhin, 3, 182, 70
Antony Polukhin, 3, 183, 70
John Snow, 1, 185, 80
Vasya Pupkin, 2, 165, 60

1:
John Snow, 1, 185, 80
Vasya Pupkin, 2, 165, 60
Anton Polukhin, 3, 182, 70
Antony Polukhin, 3, 183, 70

2:
Vasya Pupkin, 2, 165, 60
Anton Polukhin, 3, 182, 70
Antony Polukhin, 3, 183, 70
John Snow, 1, 185, 80

3:
Vasya Pupkin, 2, 165, 60
Antony Polukhin, 3, 183, 70
Anton Polukhin, 3, 182, 70
John Snow, 1, 185, 80</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec356"/>How it works...</h2></div></div></div><p>The hardest part here<a id="id578" class="indexterm"/> is the construction of a multi-index type using <code class="literal">boost::multi_index::multi_index_container</code>. The first template parameter is a class that we are going to index. In our case, it is <code class="literal">person</code>. The second parameter is a type <code class="literal">boost::multi_index::indexed_by</code>, all the indexes must be described as a template parameter of that class.</p><p>Now, let's take a look at the first index description:</p><div class="informalexample"><pre class="programlisting">  boost::multi_index::ordered_unique&lt;
    boost::multi_index::identity&lt;person&gt;
  &gt;</pre></div><p>The usage of the <code class="literal">boost::multi_index::ordered_unique</code> class<a id="id579" class="indexterm"/> means that the index must work like <code class="literal">std::set</code>, and have all of its members. The <code class="literal">boost::multi_index::identity&lt;person&gt;</code> class means that the index will use the <code class="literal">operator &lt;</code> of a <code class="literal">person</code> class for orderings.</p><p>The next table shows the relation between the<a id="id580" class="indexterm"/> <code class="literal">Boost.MultiIndex</code> types and the STL containers:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>The Boost.MultiIndex types</p>
</th><th style="text-align: left" valign="bottom">
<p>STL containers</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multi_index::ordered_unique</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::set</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multi_index::ordered_non_unique</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::multiset</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multi_index::hashed_unique</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::unordered_set</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multi_index::hashed_non_unique</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::unordered_mutiset</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multi_index::sequenced</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::list</code></p>
</td></tr></tbody></table></div><p>Let's take a look at the second index:</p><div class="informalexample"><pre class="programlisting">    boost::multi_index::hashed_non_unique&lt;
      boost::multi_index::member&lt;
         person, std::size_t, &amp;person::id_
      &gt;
    &gt;</pre></div><p>The <code class="literal">boost::multi_index::hashed_non_unique</code> type means that the index will work like <code class="literal">std::set</code>, and <code class="literal">boost::multi_index::member&lt;person, std::size_t, &amp;person::id_&gt;</code> means that the index will apply the hash function only to a single member field of the person structure, to <code class="literal">person::id_</code>.</p><p>The remaining <a id="id581" class="indexterm"/>indexes won't  be a trouble now, so let's take a look at the usage of indexes in the print function instead. Getting the type of iterator for a specific index is done using the following code:</p><div class="informalexample"><pre class="programlisting">    typedef typename Indexes::template nth_index&lt;
            IndexNo
    &gt;::type::const_iterator const_iterator_t;</pre></div><p>This looks slightly overcomplicated because <code class="literal">Indexes</code> is a template parameter. The example would be simpler, if we could write this code in the scope of <code class="literal">indexes_t</code>:</p><div class="informalexample"><pre class="programlisting">    typedef indexes_t::nth_index&lt;0&gt;::type::const_iterator const_iterator_t;</pre></div><p>The <code class="literal">nth_index</code> member metafunction takes a zero-based number of index to use. In our example, index 1 is the index of IDs, index 2 is the index of heights and so on.</p><p>Now, let's take a look at how to use <code class="literal">const_iterator_t</code>:</p><div class="informalexample"><pre class="programlisting">    for (const_iterator_t it = persons.template get&lt;IndexNo&gt;().begin(),
         iend = persons.template get&lt;IndexNo&gt;().end();
         it != iend;
         ++it)
    {
        const person&amp; v = *it;
        // ...</pre></div><p>This can also be simplified for <code class="literal">indexes_t</code> being in scope:</p><div class="informalexample"><pre class="programlisting">    for (const_iterator_t it = persons.get&lt;0&gt;().begin(),
         iend = persons.get&lt;0&gt;().end();
         it != iend;
         ++it)
    {
        const person&amp; v = *it;
        // ...</pre></div><p>The function <code class="literal">get&lt;indexNo&gt;()</code> returns index. We can use that index almost like an STL container.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec357"/>There's more...</h2></div></div></div><p>C++11 has no multi-index library. The <code class="literal">Boost.MultiIndex</code> library<a id="id582" class="indexterm"/> is a fast library that uses no virtual functions. The official documentation of <code class="literal">Boost.MultiIndex</code> contains performance and memory usage measures, showing that this library in most cases uses less memory than STL-based handwritten code. Unfortunately, <code class="literal">boost::multi_index::multi_index_container</code> does not support C++11 features, and also has no rvalue references emulation using <code class="literal">Boost.Move</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec358"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation of <code class="literal">Boost.MultiIndex</code> contains tutorials, performance measures, examples, and other <code class="literal">Boost.Multiindex</code> libraries' description of useful features. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html</a>.</li></ul></div></div></div>
<div class="section" title="Getting the benefits of single-linked list and memory pool"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec89"/>Getting the benefits of single-linked list and memory pool</h1></div></div></div><p>Nowadays, we<a id="id583" class="indexterm"/> usually use <code class="literal">std::vector</code> when we need nonassociative and nonordered containers. This is recommended by <span class="emphasis"><em>Andrei Alexandrescu</em></span> and <span class="emphasis"><em>Herb Sutter</em></span> in the book <span class="emphasis"><em>C++ Coding Standards</em></span>, and even those users who did not read the<a id="id584" class="indexterm"/> book usually use <code class="literal">std::vector</code>. Why? Well, <code class="literal">std::list</code> is<a id="id585" class="indexterm"/> slower, and uses much more resources than <code class="literal">std::vector</code>. The <code class="literal">std::deque</code> container<a id="id586" class="indexterm"/> is very close to <code class="literal">std::vector</code>
<a id="id587" class="indexterm"/>, but stores values noncontinuously.</p><p>Everything is good until we do not need a container; however, if we need a container, erasing and inserting elements does not invalidate iterators. Then we are forced to choose the slower <code class="literal">std::list</code>.</p><p>But wait, there is a good solution in Boost for such cases!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec359"/>Getting ready</h2></div></div></div><p>Good knowledge of STL containers is required to understand the introductory part. After that, only basic knowledge of C++ and STL containers is required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec360"/>How to do it...</h2></div></div></div><p>In this recipe, we'll be using two Boost libraries at the same <a id="id588" class="indexterm"/>time: <code class="literal">Boost.Pool</code> and single-linked list from <code class="literal">Boost.Container</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need the following headers:<div class="informalexample"><pre class="programlisting">#include &lt;boost/pool/pool_alloc.hpp&gt;
#include &lt;boost/container/slist.hpp&gt;</pre></div></li><li class="listitem">Now we need to describe the type of our list. This can be done as shown in the following code:<div class="informalexample"><pre class="programlisting">typedef boost::fast_pool_allocator&lt;int&gt; allocator_t;
typedef boost::container::slist&lt;int, allocator_t&gt; slist_t;</pre></div></li><li class="listitem">We can work with our<a id="id589" class="indexterm"/> single-linked list like with <code class="literal">std::list</code>. Take a look at the function that is used to measure the speed of both the list types:<div class="informalexample"><pre class="programlisting">template &lt;class ListT&gt;
void test_lists() {
    typedef ListT list_t;
  
    // Inserting 1000000 zeros
    list_t  list(1000000, 0);
    for (int i = 0; i &lt; 1000; ++i) {
        list.insert(list.begin(), i);
    }

    // Searching for some value
    typedef typename list_t::iterator iterator;
    iterator it = std::find(list.begin(), list.end(), 777);
    assert(it != list.end());

    // Erasing some values
    for (int i = 0; i &lt; 100; ++i) {
        list.pop_front();
    }

    // Iterator still valid and points to same value
    assert(it != list.end());
    assert(*it == 777);

    // Inserting more values
    for (int i = -100; i &lt; 10; ++i) {
        list.insert(list.begin(), i);
    }

    // Iterator still valid and points to same value
    assert(it != list.end());
    assert(*it == 777);

    list_specific(list, it);
}</pre></div></li><li class="listitem">Features specific for each type of list are moved to <a id="id590" class="indexterm"/><code class="literal">list_specific</code> functions:<div class="informalexample"><pre class="programlisting">void list_specific(slist_t&amp; list, slist_t::iterator it) {
    typedef slist_t::iterator iterator;

    // Erasing element 776
    assert( *(++iterator(it)) == 776);
    assert(*it == 777);
    list.erase_after(it);
    assert(*it == 777);
    assert( *(++iterator(it)) == 775);

    // Freeing memory
    boost::singleton_pool&lt;
        boost::pool_allocator_tag,
        sizeof(int)
    &gt;::release_memory();
}

#include &lt;list&gt;
typedef std::list&lt;int&gt; stdlist_t;

void list_specific(stdlist_t&amp; list, stdlist_t::iterator it) {
    typedef stdlist_t::iterator iterator;

    // Erasing element 776
    ++it;
    assert( *it == 776);
    it = list.erase(it);
    assert(*it == 775);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec361"/>How it works...</h2></div></div></div><p>When we are using <code class="literal">std::list</code>, we may notice a slowdown because each node of the list needs a separate allocation. It means that usually when we insert 10 elements into <code class="literal">std::list</code>, the container calls new 10 times.</p><p>That is why we used boost<code class="literal">::fast_pool_allocator&lt;int&gt;</code> from <code class="literal">Boost.Pool</code>. This allocator tries to allocate bigger blocks of memory, so that at a later stage, multiple nodes can be constructed without any calls to allocate new ones.</p><p>The <code class="literal">Boost.Pool</code> library has a <a id="id591" class="indexterm"/>drawback—it uses memory for internal needs. Usually, an additional <code class="literal">sizeof</code> pointer is used per element. To workaround that issue, we are using a single linked list from <code class="literal">Boost.Containers</code>.</p><p>The <code class="literal">boost::container::slist</code> class<a id="id592" class="indexterm"/> is more compact, but its iterators can iterate only forward. Step 3 will be trivial for those readers who are aware of STL containers, so we move to step 4 to see some <code class="literal">boost::container::slist</code> specific features. Since the single-linked list iterator could iterate only forward, traditional algorithms of insertion and deletion will take linear time O(N). That's because when we are erasing or inserting, the previous element must be modified to point at new elements of the list. To workaround that issue, the single-linked list has the methods <code class="literal">erase_after</code> and <code class="literal">insert_after</code> that work for constant time O(1). These methods insert or erase elements right after the current position of the iterator.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>However, erasing and inserting values at the beginning of single-linked lists makes no big difference.</p></div></div><p>Take a careful look at the following code:</p><div class="informalexample"><pre class="programlisting">    boost::singleton_pool&lt;
        boost::pool_allocator_tag,
        sizeof(int)
    &gt;::release_memory();</pre></div><p>It is required because <code class="literal">boost::fast_pool_allocator</code> does not free memory, so we must do it by hand. The <span class="emphasis"><em>Doing something at scope exit</em></span> recipe from <a class="link" href="ch03.html" title="Chapter 3. Managing Resources">Chapter 3</a>, <span class="emphasis"><em>Managing Resources</em></span>, will be a help in freeing <code class="literal">Boost.Pool</code>.</p><p>Let's take a look at the execution results to see the difference:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$TIME="Runtime=%E RAM=%MKB" time ./slist_and_pool l</strong></span>

<span class="strong"><strong>std::list: Runtime=0:00.05 RAM=32440KB</strong></span>

<span class="strong"><strong>$ TIME="Runtime=%E RAM=%MKB" time ./slist_and_pool s</strong></span>

<span class="strong"><strong>slist_t:   Runtime=0:00.02 RAM=17564KB</strong></span>
</pre></div><p>As we can see, <code class="literal">slist_t</code> uses half the memory, and is twice as fast compared to the <code class="literal">std::list</code> class.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec362"/>There's more...</h2></div></div></div><p>C++11 has <code class="literal">std::forward_list</code>, which is very close to <code class="literal">boost::containers::slist</code>. It also has the <code class="literal">*_after</code> methods, but has no <code class="literal">size()</code> method<a id="id593" class="indexterm"/>. They have the same performance and neither of them have virtual functions, so these containers are fast and reliable. However, the Boost version is also usable on C++03 compilers, and even has support for rvalue references emulation via <code class="literal">Boost.Move</code>.</p><p>Pools are not part of C++11. Use the version from Boost; it is fast and does not use virtual functions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Guessing why <code class="literal">boost::fast_pool_allocator</code> does not free the memory by itself? That's because C++03 has no stateful allocators, so the containers are not copying and storing allocators. That makes it impossible to implement a <code class="literal">boost::fast_pool_allocator</code> function<a id="id594" class="indexterm"/> that deallocates memory by itself.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec363"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation of <code class="literal">Boost.Pool</code> contains more examples and classes to work with memory pools. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html</a>.</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using flat associative containers</em></span> recipe will introduce you to some more classes from <code class="literal">Boost.Container</code>. You can also read the official documentation of <code class="literal">Boost.Container</code> to study that library by yourself, or get full reference documentation of its classes at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/container.html">http://www.boost.org/doc/libs/1_53_0/doc/html/container.html</a>.</li><li class="listitem" style="list-style-type: disc">Read about why stateful allocators may be required at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction</a>.</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Vector vs List</em></span>, and other interesting topics from <span class="emphasis"><em>Bjarne Stroustrup</em></span>, the inventor of the C++ programming language, can be found at <a class="ulink" href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup">http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup</a><a class="ulink" href="http://-Cpp11-Style">-Cpp11-Style</a>.</li></ul></div></div></div>
<div class="section" title="Using flat associative containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec90"/>Using flat associative containers</h1></div></div></div><p>After reading the <a id="id595" class="indexterm"/>previous recipe, some of the readers may start using <a id="id596" class="indexterm"/>fast pool allocators everywhere; especially, for <code class="literal">std::set</code> and <code class="literal">std::map</code>. Well, I'm not going to stop you from doing that, but let's at least take a look at an alternative: flat associative containers. These containers are implemented on top of the traditional vector container and store the values ordered.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec364"/>Getting ready</h2></div></div></div><p>Basic knowledge of STL associative containers is required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec365"/>How to do it...</h2></div></div></div><p>The flat containers are part of the <code class="literal">Boost.Container</code> library. We already saw how to use some of its containers in the previous recipes. In this recipe we'll be using a <a id="id597" class="indexterm"/>
<code class="literal">flat_set</code> associative container:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need to include only a single header file:<div class="informalexample"><pre class="programlisting">#include &lt;boost/container/flat_set.hpp&gt;</pre></div></li><li class="listitem">After that, we are free to construct the flat container:<div class="informalexample"><pre class="programlisting">    boost::container::flat_set&lt;int&gt; set;</pre></div></li><li class="listitem">Reserving space for elements:<div class="informalexample"><pre class="programlisting">    set.reserve(4096);</pre></div></li><li class="listitem">Filling the container:<div class="informalexample"><pre class="programlisting">    for (int i = 0; i &lt; 4000; ++i) {
        set.insert(i);
    }</pre></div></li><li class="listitem">Now we can work with it just like with <code class="literal">std::set</code>:<div class="informalexample"><pre class="programlisting">    // 5.1
    assert(set.lower_bound(500) - set.lower_bound(100) == 400);

    // 5.2
    set.erase(0);

    // 5.3
    set.erase(5000);

    // 5.4
    assert(std::lower_bound(set.cbegin(), set.cend(), 900000) == set.cend());

    // 5.5
    assert(
        set.lower_bound(100) + 400 
        == 
        set.find(500)
    );</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec366"/>How it works...</h2></div></div></div><p>Steps 1 and 2 are trivial, but step 3 requires attention. It is one of the most important steps while working with flat associative containers and <code class="literal">std::vector</code>.</p><p>The <code class="literal">boost::container::flat_set</code> class<a id="id598" class="indexterm"/> stores its values ordered in vector, which means that any insertion or deletion of elements <a id="id599" class="indexterm"/>takes linear time O(N), just like in case of <code class="literal">std::vector</code>. This is a necessary evil. But for that, we gain almost three times less memory usage per element, more processor cache friendly storage, and random access iterators. Take a look at step 5, <code class="literal">5.1</code>, where we were getting the distance between two iterators returned by calls to the <code class="literal">lower_bound</code> member functions. Getting distance with a flat set takes constant time O(1), while the same operation on iterators of <code class="literal">std::set</code> takes linear time O(N). In the case of <code class="literal">5.1</code>, getting the distance using <code class="literal">std::set</code> would be 400 times slower than getting the distance for flat set containers.</p><p>Back to step 3. Without reserving memory, insertion of elements can become at times slower and less memory efficient. The <code class="literal">std::vector</code> class allocates the required chunk of memory and the in-place construct elements on that chunk. When we insert some element without reserving the memory, there is a chance that there is no free space remaining on the preallocated chunk of memory, so <code class="literal">std::vector</code> will allocate twice the chunk of memory that was allocated previously. After that, <code class="literal">std::vector</code> will copy or move elements from the first chunk to the second, delete elements of the first chunk, and deallocate the first chunk. Only after that, insertion will occur. Such copying and deallocation may occur multiple times during insertions, dramatically reducing the speed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>If you know the count of elements that <code class="literal">std::vector</code> or any flat container must store, reserve the space for those elements before insertion. There are no exceptions from that rule!</p></div></div><p>Step 4 is trivial, we are inserting elements here. Note that we are inserting ordered elements. This is not required, but recommended to speedup insertion. Inserting elements at the end of <code class="literal">std::vector</code> is much more cheaper than in the middle or at the beginning.</p><p>In step 5, <code class="literal">5.2</code> and <code class="literal">5.3</code> do not differ much, <a id="id600" class="indexterm"/>except of their execution speed. Rules for erasing elements are pretty much the same as for inserting them, so see the preceding paragraph for explanations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>Maybe I'm telling you trivial things about containers, but I have seen some very popular products that use features of C++11, have an insane amount of optimizations and lame usage of STL containers, especially <code class="literal">std::vector</code>.</p></div></div><p>In step 5, <code class="literal">5.4</code> shows you that the <code class="literal">std::lower_bound</code> function will work faster with <code class="literal">boost::container::flat_set</code> than with <code class="literal">std::set</code>, because of random access iterators.</p><p>In step 5, <code class="literal">5.5</code> also shows you the benefit of random access iterators. Note that we did not use the <code class="literal">std::find</code> function here. This is because that function takes linear time O(N), while the member <code class="literal">find</code> functions take logarithmic time O(log(N)).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec367"/>There's more...</h2></div></div></div><p>When should we use flat containers, and when should we use usual ones? Well, it's up to you, but here is a list of differences from the official documentation of <code class="literal">Boost.Container</code> that will help you to decide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Faster lookup than standard associative containers</li><li class="listitem" style="list-style-type: disc">Much faster iteration than standard associative containers</li><li class="listitem" style="list-style-type: disc">Less memory consumption for small objects (and for large objects if <code class="literal">shrink_to_fit</code> is used)</li><li class="listitem" style="list-style-type: disc">Improved cache performance (data is stored in contiguous memory)</li><li class="listitem" style="list-style-type: disc">Nonstable iterators (iterators are invalidated when inserting and erasing elements)</li><li class="listitem" style="list-style-type: disc">Non-copyable and non-movable value types can't be stored</li><li class="listitem" style="list-style-type: disc">Weaker exception safety than standard associative containers (copy/move constructors can throw an exception when shifting values in erasures and insertions)</li><li class="listitem" style="list-style-type: disc">Slower insertion and erasure than standard associative containers (specially for non-movable types)</li></ul></div><p>C++11 unfortunately has no flat containers. Flat containers from Boost are fast, have a lot of optimizations, and do not use virtual functions. Classes from <code class="literal">Boost.Containers</code> have support of rvalue reference emulation via <code class="literal">Boost.Move</code> so you are free to use them even on C++03 compilers.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec368"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Getting the benefits of single-linked list and memory pool</em></span> recipe for more information about <code class="literal">Boost.Container</code>.</li><li class="listitem" style="list-style-type: disc">The recipe <span class="emphasis"><em>Using the C++11 move emulation</em></span> in <a class="link" href="ch01.html" title="Chapter 1. Starting to Write Your Application">Chapter 1</a>, <span class="emphasis"><em>Starting to Write Your Application</em></span>, will give you the basics of emulation rvalue references on C++03 compatible compilers.</li><li class="listitem" style="list-style-type: disc">The official documentation of <code class="literal">Boost.Container</code> contains a lot of useful information about <code class="literal">Boost.Container</code> and full reference of each class. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/container.html">http://www.boost.org/doc/libs/1_53_0/doc/html/container.html</a>.</li></ul></div></div></div></body></html>