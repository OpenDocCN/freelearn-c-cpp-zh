<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. A Breath of Fresh Air – Entity Component System Continued</h1></div></div></div><p>In the previous chapter, we discussed the benefits of using aggregation versus simple inheritance. While not necessarily intuitive at first glance, entities composed of multiple components and operated on by systems inarguably enable higher flexibility and re-usability of code, not to mention a more convenient environment for future growth. Well, "The future is now!" as the popular expression states. A house is useless without a good foundation, just as much as a good foundation is useless without a house built on top of it. Since we already have a solid foundation, laying bricks until a proper structure emerges is what's next.</p><p>In this chapter, we will be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing basic movement</li><li class="listitem" style="list-style-type: disc">Developing a system for updating sprite sheets</li><li class="listitem" style="list-style-type: disc">Revisiting and implementing entity states</li><li class="listitem" style="list-style-type: disc">Studying the collision within the entity component system paradigm</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Adding entity movement</h1></div></div></div><p>Within<a id="id398" class="indexterm"/> the entity component system paradigm, movement of a particular body is quantified by all the forces imposed on it. The collection of these forces can be represented by a movable component:</p><div><pre class="programlisting">class C_Movable : public C_Base{
public:
    ...
private:
    sf::Vector2f m_velocity;
    float m_velocityMax;
    sf::Vector2f m_speed;
    sf::Vector2f m_acceleration;
    Direction m_direction;
};</pre></div><p>This component takes away physics elements from the second project of this book, namely the velocity, speed and acceleration attributes. In order to simplify the code, the velocity <a id="id399" class="indexterm"/>cap is represented by a single float this time, as it is unlikely we will ever need to limit the velocity differently based on its axis.</p><p>Let's take a look at the rest of the movable component class:</p><div><pre class="programlisting">C_Movable() : C_Base(Component::Movable),
    m_velocityMax(0.f), m_direction((Direction)0)
{}</pre></div><p>The constructor here initializes the data members to some default values, which are later replaced by ones from de-serialization:</p><div><pre class="programlisting">void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_velocityMax &gt;&gt; m_speed.x &gt;&gt; m_speed.y;

    unsigned int dir = 0;
    l_stream &gt;&gt; dir;
    m_direction = (Direction)dir;
}</pre></div><p>For purposes of easily manipulating velocity within a certain range, we provide the <code class="literal">AddVelocity</code> method:</p><div><pre class="programlisting">void AddVelocity(const sf::Vector2f&amp; l_vec){
  m_velocity += l_vec;
  if(std::abs(m_velocity.x) &gt; m_velocityMax){
    m_velocity.x = m_velocityMax *
      (m_velocity.x / std::abs(m_velocity.x));
  }

  if(std::abs(m_velocity.y) &gt; m_velocityMax){
    m_velocity.y = m_velocityMax *
      (m_velocity.y / std::abs(m_velocity.y));
  }
}</pre></div><p>After adding the provided argument velocity, the end result is checked for being higher than the maximum allowed value on each axis. If it is, the velocity is capped at the maximum allowed value with the appropriate sign.</p><div><pre class="programlisting">void ApplyFriction(const sf::Vector2f&amp; l_vec){
  if(m_velocity.x != 0 &amp;&amp; l_vec.x != 0){
    if(std::abs(m_velocity.x) - std::abs(l_vec.x) &lt; 0){
      m_velocity.x = 0;
    } else {
      m_velocity.x += (m_velocity.x &gt; 0 ? l_vec.x * -1 : l_vec.x);
    }
  }

  if(m_velocity.y != 0 &amp;&amp; l_vec.y != 0){
    if(std::abs(m_velocity.y) - std::abs(l_vec.y) &lt; 0){
      m_velocity.y = 0;
    } else {
      m_velocity.y += (m_velocity.y &gt; 0 ? l_vec.y * -1 : l_vec.y);
    }
  }
}</pre></div><p>Applying <a id="id400" class="indexterm"/>friction to the current velocity is also regulated. In order to avoid friction forcing the velocity to change its sign, it's checked to not be equal to zero, as well as if the difference between absolute values of current velocity and provided friction isn't going to be negative. If it is, the velocity is set to zero. Otherwise, the friction value is added to current velocity with an appropriate sign.</p><p>In order for an entity to move, it has to be accelerated. Let's supply a method for that:</p><div><pre class="programlisting">void Accelerate(const sf::Vector2f&amp; l_vec){ 
    m_acceleration += l_vec;
}
void Accelerate(float l_x, float l_y){ 
    m_acceleration += sf::Vector2f(l_x,l_y);
}</pre></div><p>For the sake of convenience, we provide the same method, overloaded to take in two types of arguments: a float vector and two separate float values. All it does is simply add the argument values to current acceleration.</p><p>Lastly, entities can also be moved based on a provided direction, instead of calling the <code class="literal">Accelerate</code> method manually:</p><div><pre class="programlisting">void Move(const Direction&amp; l_dir){
  if(l_dir == Direction::Up){
    m_acceleration.y -= m_speed.y;
  } else if (l_dir == Direction::Down){
    m_acceleration.y += m_speed.y;
  } else if (l_dir == Direction::Left){
    m_acceleration.x -= m_speed.x;
  } else if (l_dir == Direction::Right){
    m_acceleration.x += m_speed.x;
  }
}</pre></div><p>Based on the direction provided as an argument, the entity's speed is added to the acceleration<a id="id401" class="indexterm"/> vector.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec48"/>The movement system</h2></div></div></div><p>With <a id="id402" class="indexterm"/>the movement component designed, let's take a stab at implementing the actual system that will move our entities around:</p><div><pre class="programlisting">enum class Axis{ x, y };
class Map;
class S_Movement : public S_Base{
public:
  ...
  void SetMap(Map* l_gameMap);
private:
  void StopEntity(const EntityId&amp; l_entity,
    const Axis&amp; l_axis);
  void SetDirection(const EntityId&amp; l_entity,
    const Direction&amp; l_dir);
  const sf::Vector2f&amp; GetTileFriction(unsigned int l_elevation, 
    unsigned int l_x, unsigned int l_y);
  void MovementStep(float l_dT, C_Movable* l_movable,
    C_Position* l_position);
  Map* m_gameMap;
};</pre></div><p>First, an <code class="literal">Axis</code> enumeration is created, in order to simply the code in one of the private helper methods of this class. We then forward-declare a <code class="literal">Map</code> class, in order to be able to use it in the header. With that, comes a <code class="literal">Map</code> data member, as well as a public method for providing the movement system with an instance of <code class="literal">Map</code>. A few private helper methods are also needed in order to make the code more readable. Let's begin by setting up our constructor:</p><div><pre class="programlisting">S_Movement::S_Movement(SystemManager* l_systemMgr) 
  : S_Base(System::Movement,l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::Movable);
  m_requiredComponents.push_back(req);
  req.Clear();

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Is_Moving,this);

  m_gameMap = nullptr;
}</pre></div><p>The requirements for this system consist of two components: position and movable. In addition to that, this system also subscribes to the <code class="literal">Is_Moving</code> message type, in order to respond to it.</p><p>Next, let's <a id="id403" class="indexterm"/>update our entity information:</p><div><pre class="programlisting">void S_Movement::Update(float l_dT){
  if (!m_gameMap){ return; }
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    C_Position* position = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    C_Movable* movable = entities-&gt;
      GetComponent&lt;C_Movable&gt;(entity, Component::Movable);
    MovementStep(l_dT, movable, position);
    position-&gt;MoveBy(movable-&gt;GetVelocity() * l_dT);
  }
}</pre></div><p>As the requirements of this system suggest, it will be operating on the position component, as well as the movable component. For every entity that belongs to this system, we want to update its physics and adjust its position in accordance to its velocity and the time that has passed in between frames, producing movement based on forces.</p><p> Let's take a look at the movement step method:</p><div><pre class="programlisting">void S_Movement::MovementStep(float l_dT, C_Movable* l_movable,
  C_Position* l_position)
{
  sf::Vector2f f_coefficient = 
    GetTileFriction(l_position-&gt;GetElevation(),
    floor(l_position-&gt;GetPosition().x / Sheet::Tile_Size),
    floor(l_position-&gt;GetPosition().y / Sheet::Tile_Size));

  sf::Vector2f friction(l_movable-&gt;GetSpeed().x * f_coefficient.x,
    l_movable-&gt;GetSpeed().y * f_coefficient.y);

  l_movable-&gt;AddVelocity(l_movable-&gt;GetAcceleration() * l_dT);
  l_movable-&gt;SetAcceleration(sf::Vector2f(0.0f, 0.0f));
  l_movable-&gt;ApplyFriction(friction * l_dT);

  float magnitude = sqrt(
    (l_movable-&gt;GetVelocity().x * l_movable-&gt;GetVelocity().x) +
    (l_movable-&gt;GetVelocity().y * l_movable-&gt;GetVelocity().y));

  if (magnitude &lt;= l_movable-&gt;GetMaxVelocity()){ return; }
  float max_V = l_movable-&gt;GetMaxVelocity();
  l_movable-&gt;SetVelocity(sf::Vector2f(
    (l_movable-&gt;GetVelocity().x / magnitude) * max_V,
    (l_movable-&gt;GetVelocity().y / magnitude) * max_V));
}</pre></div><p>The friction <a id="id404" class="indexterm"/>value of the tile an entity is standing on is obtained first. It gets applied to the entity's movable component right after its velocity is updated based on the acceleration value.</p><p>Next, we must make sure that diagonal movement is handled correctly. Consider the following illustration:</p><div><img src="img/B04284_09_01.jpg" alt="The movement system"/></div><p>According to the Pythagorean theorem, the squared hypotenuse of a right triangle, which represents diagonal movement, is equal to the sum of its squared sides. In other words, its hypotenuse is shorter than the sum of both of its sides. Characters that move down-right, for example, would appear to move faster than they do in a single direction, unless we cap their velocity based on the magnitude of the velocity vector, also known as the hypotenuse of the triangle in our illustration. Once the magnitude is calculated, it is checked for exceeding the maximum possible velocity of an entity. If it does, it gets normalized and multiplied by the value of maximum velocity, in order to impose slower diagonal movement.</p><p>Obtaining the tile friction can be done like so:</p><div><pre class="programlisting">const sf::Vector2f&amp; S_Movement::GetTileFriction(
  unsigned int l_elevation, unsigned int l_x, unsigned int l_y)
{
  Tile* t = nullptr;
  while (!t &amp;&amp; l_elevation &gt;= 0){
    t = m_gameMap-&gt;GetTile(l_x, l_y, l_elevation);
    --l_elevation;
  }

  return(t ? t-&gt;m_properties-&gt;m_friction :
    m_gameMap-&gt;GetDefaultTile()-&gt;m_friction);
}</pre></div><p>A tile<a id="id405" class="indexterm"/> pointer is set up before a <code class="literal">while</code> loop is initiated. It will keep trying to fetch a tile at a provided location while decreasing the elevation each time. This means that tile friction is effectively yielded from the top-most tile that a player is over. If a tile hasn't been found, the default friction value is returned instead.</p><p>As you might be able to guess by now, the movement system needs to respond to quite a few events, due to its importance:</p><div><pre class="programlisting">void S_Movement::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event)
{
  switch(l_event){
  case EntityEvent::Colliding_X:
    StopEntity(l_entity,Axis::x); break;
  case EntityEvent::Colliding_Y:
    StopEntity(l_entity, Axis::y); break;
  case EntityEvent::Moving_Left:
    SetDirection(l_entity, Direction::Left); break;
  case EntityEvent::Moving_Right:
    SetDirection(l_entity, Direction::Right); break;
  case EntityEvent::Moving_Up:
    {
      C_Movable* mov = m_systemManager-&gt;GetEntityManager()-&gt;
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable);
      if(mov-&gt;GetVelocity().x == 0){
        SetDirection(l_entity, Direction::Up);
      }
    }
    break;
  case EntityEvent::Moving_Down:
    {
      C_Movable* mov = m_systemManager-&gt;GetEntityManager()-&gt;
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable);
      if(mov-&gt;GetVelocity().x == 0){
        SetDirection(l_entity, Direction::Down);
      }
    }
    break;
  }
}</pre></div><p>First, it handles two colliding events, to which it responds by calling the private <code class="literal">StopEntity</code> method<a id="id406" class="indexterm"/> in order to halt an entity on a specified axis. Next, we have four movement events. In cases of <code class="literal">Moving_Left</code> and <code class="literal">Moving_Right</code>, the private <code class="literal">SetDirection</code> method is invoked in order to update the direction of an entity. Moving up and down, however, is a little bit different. We want the entity's direction to only change if it has no velocity on the <em>x</em> axis. Otherwise, it ends up moving rather cheesily.</p><p>Next up, message handling:</p><div><pre class="programlisting">void S_Movement::Notify(const Message&amp; l_message){
  EntityManager* eMgr = m_systemManager-&gt;GetEntityManager();
  EntityMessage m = (EntityMessage)l_message.m_type;
  switch(m){
  case EntityMessage::Is_Moving:
    {
    if (!HasEntity(l_message.m_receiver)){ return; }
    C_Movable* movable = eMgr-&gt;GetComponent&lt;C_Movable&gt;
      (l_message.m_receiver, Component::Movable);
    if (movable-&gt;GetVelocity() != sf::Vector2f(0.0f, 0.0f))
    {
      return;
    }
    m_systemManager-&gt;AddEvent(l_message.m_receiver,
      (EventID)EntityEvent::Became_Idle);
    }
    break;
  }
}</pre></div><p>Here, we're only concerned with a single message type: <code class="literal">Is_Moving</code>. It's a message, designed to trigger another one being sent when the entity becomes idle. First, the system is checked for having the entity in question. Its movable component is then acquired, the velocity of which is checked for being at absolute zero. Given that that's the case, an event is created to signify the entity becoming idle.</p><p>All we have left now are the private helper methods. It's all of the redundant logic, the existence of which within methods saves us from code duplication. The first one we'll examine is responsible for halting an entity:</p><div><pre class="programlisting">void S_Movement::StopEntity(const EntityId&amp; l_entity, 
  const Axis&amp; l_axis)
{
  C_Movable* movable = m_systemManager-&gt;GetEntityManager()-&gt;
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable);
  if(l_axis == Axis::x){
    movable-&gt;SetVelocity(sf::Vector2f(0.f, movable-&gt;GetVelocity().y));
  } else if(l_axis == Axis::y){
    movable-&gt;SetVelocity(sf::Vector2f(movable-&gt;GetVelocity().x, 0.f));
  }
}</pre></div><p>After <a id="id407" class="indexterm"/>obtaining its movable component, the entity then has its velocity set to zero on an axis, provided as the argument to this method.</p><div><pre class="programlisting">void S_Movement::SetDirection(const EntityId&amp; l_entity, 
  const Direction&amp; l_dir)
{
  C_Movable* movable = m_systemManager-&gt;GetEntityManager()-&gt;
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable);
  movable-&gt;SetDirection(l_dir);

  Message msg((MessageType)EntityMessage::Direction_Changed);
  msg.m_receiver = l_entity;
  msg.m_int = (int)l_dir;
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
}</pre></div><p>The <code class="literal">SetDirection</code> method updates the direction of a movable component. A message is then dispatched to notify all the other systems of this change.</p><p>Finally, we're down to a single setter method for the <code class="literal">Map</code> class:</p><div><pre class="programlisting">void S_Movement::SetMap(Map* l_gameMap){ m_gameMap = l_gameMap; }</pre></div><p>In order for entities to have dynamic friction, the movement system has to have access to the <code class="literal">Map</code> class, so it gets set up in the game state:</p><div><pre class="programlisting">void State_Game::OnCreate(){
  ...
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
    GetSystem&lt;S_Movement&gt;(SYSTEM_MOVEMENT)-&gt;SetMap(m_gameMap);
}</pre></div><p>This last code snippet concludes the implementation of the movement system. Our entities are now able to move, based on the forces inflicted on them. Having support for movement, however, does not actually generate movement. This is where the entity state system comes in.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec49"/>Implementing states</h2></div></div></div><p>Movement, much <a id="id408" class="indexterm"/>like many other actions and events <a id="id409" class="indexterm"/>that are relevant to entities are contingent upon their current state being satisfactory. A dying player should not be able to move around. Relevant animations should be played, based on its current state. Enforcing those laws requires the entity to have a state component:</p><div><pre class="programlisting">enum class EntityState{ Idle, Walking, Attacking, Hurt, Dying };
class C_State : public C_Base{
public:
  C_State(): C_Base(Component::State){}
  void ReadIn(std::stringstream&amp; l_stream){
    unsigned int state = 0;
    l_stream &gt;&gt; state;
    m_state = (EntityState)state;
  }

  EntityState GetState(){ return m_state; }
  void SetState(const EntityState&amp; l_state){
    m_state = l_state;
  }
private:
  EntityState m_state;
};</pre></div><p>As you can tell already, this is a very simple chunk of code. It defines its own enumeration of possible entity states. The component class itself simply provides a setter and a getter, as well as the required method for de-serialization. The rest is, as always, left up to the system to hash out.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec09"/>The state system</h3></div></div></div><p>Since most <a id="id410" class="indexterm"/>of the system headers from here on out are going to look pretty much the same, they will be omitted. With that said, let's begin by implementing the constructor and destructor of our state system:</p><div><pre class="programlisting">S_State::S_State(SystemManager* l_systemMgr)
  : S_Base(System::State,l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::State);
  m_requiredComponents.push_back(req);

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Move,this);
  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Switch_State,this);
}</pre></div><p>All this <a id="id411" class="indexterm"/>system requires is the state component. It also subscribes to two message types: <code class="literal">Move</code> and <code class="literal">Switch_State</code>. While the latter is self-explanatory, the <code class="literal">Move</code> message is what gets sent by the methods in the game state in order to move the player. Because movement is entirely dependent on the entity state, this is the only system that handles this type of message and determines whether the state is appropriate for motion.</p><p>Next, let's take a look at the <code class="literal">Update</code> method:</p><div><pre class="programlisting">void S_State::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    C_State* state = entities-&gt;
      GetComponent&lt;C_State&gt;(entity, Component::State);
    if(state-&gt;GetState() == EntityState::Walking){
      Message msg((MessageType)EntityMessage::Is_Moving);
      msg.m_receiver = entity;
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    }
  }
}</pre></div><p>All that happens here is a simple check of the entity's current state. If it's in motion, a message <code class="literal">Is_Moving</code> is dispatched. If you recall, this type of message is handled by the movement system, which fires an event when the entity becomes idle. That event is handled by our state system:</p><div><pre class="programlisting">void S_State::HandleEvent(const EntityId&amp; l_entity,
  const EntityEvent&amp; l_event)
{
  switch(l_event){
  case EntityEvent::Became_Idle:
    ChangeState(l_entity,EntityState::Idle,false);
    break;
  }
}</pre></div><p>All it does is invoke a private method <code class="literal">ChangeState</code>, which alters the current state of an entity to <code class="literal">Idle</code>. The third argument here is simply a flag for whether the state change should be forced or not.</p><p>The last public method we'll be dealing with here is <code class="literal">Notify</code>:</p><div><pre class="programlisting">void S_State::Notify(const Message&amp; l_message){
  if (!HasEntity(l_message.m_receiver)){ return; }
  EntityMessage m = (EntityMessage)l_message.m_type;
  switch(m){
  case EntityMessage::Move:
    {
      C_State* state = m_systemManager-&gt;GetEntityManager()-&gt;
        GetComponent&lt;C_State&gt;(l_message.m_receiver,
        Component::State);
      if (state-&gt;GetState() == EntityState::Dying){ return; }
      EntityEvent e;
      if (l_message.m_int == (int)Direction::Up){
        e = EntityEvent::Moving_Up;
      } else if (l_message.m_int == (int)Direction::Down){
        e = EntityEvent::Moving_Down;
      } else if(l_message.m_int == (int)Direction::Left){
        e = EntityEvent::Moving_Left;
      } else if (l_message.m_int == (int)Direction::Right){
        e = EntityEvent::Moving_Right;
      }

      m_systemManager-&gt;AddEvent(l_message.m_receiver, (EventID)e);
      ChangeState(l_message.m_receiver,
        EntityState::Walking,false);
    }
    break;
  case EntityMessage::Switch_State: 
    ChangeState(l_message.m_receiver,
      (EntityState)l_message.m_int,false);
    break;
  }
}</pre></div><p>The <code class="literal">Move</code> message is<a id="id412" class="indexterm"/> handled by obtaining the state of an entity it targets. If the entity isn't dying, a <code class="literal">Moving_X</code> event is constructed based on which direction the message holds. Once the event is dispatched, the entity's state is changed to <code class="literal">Walking</code>.</p><p>The <code class="literal">Switch_State</code> message simply alters the current state of an entity without forcing it, by invoking this private method:</p><div><pre class="programlisting">void S_State::ChangeState(const EntityId&amp; l_entity, 
  const EntityState&amp; l_state, const bool&amp; l_force)
{
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  C_State* state = entities-&gt;
    GetComponent&lt;C_State&gt;(l_entity, Component::State);
  if (!l_force &amp;&amp; state-&gt;GetState() == EntityState::Dying){
    return;
  }
  state-&gt;SetState(l_state);
  Message msg((MessageType)EntityMessage::State_Changed);
  msg.m_receiver = l_entity;
  msg.m_int = (int)l_state;
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
}</pre></div><p>After the<a id="id413" class="indexterm"/> state is obtained, the <code class="literal">l_force</code> flag is checked. If it's set to <code class="literal">false</code>, the state is only altered if the entity isn't currently <code class="literal">DYING</code>. We don't want anything to snap entities out of death randomly. The state is changed regardless of that, if the <code class="literal">l_force</code> flag is set to <code class="literal">true</code>.</p><p>Now we have control over what can happen to an entity, based on its current state. With that in place, the entities are now ready to be controlled.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec50"/>The entity controller</h2></div></div></div><p>The idea <a id="id414" class="indexterm"/>behind having a separate system be responsible for moving an entity around is not only that we get to decide which entities are capable of being moved, but also further separation of logic, and hooks for future A.I. implementations. Let's take a look at the controller component:</p><div><pre class="programlisting">class C_Controller : public C_Base{
public:
    C_Controller() : C_Base(COMPONENT_CONTROLLER){}
    void ReadIn(std::stringstream&amp; l_stream){}
};</pre></div><p>Yes, it's just an empty component, that is simply used as a way to tell the control system that the entity it belongs to can be controlled. There might be some additional information it needs to store in the future, but for now, it's simply a "flag."</p><p>The actual control system is extremely simple to implement. Let's begin with the constructor:</p><div><pre class="programlisting">S_Control::S_Control(SystemManager* l_systemMgr)
  :S_Base(System::Control,l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::Movable);
  req.TurnOnBit((unsigned int)Component::Controller);
  m_requiredComponents.push_back(req);
  req.Clear();
}</pre></div><p>It imposes requirements for position, movable and controller components, in order to be able to move the entity, which is the only purpose of this system. The actual movement is handled by <a id="id415" class="indexterm"/>processing entity events like so:</p><div><pre class="programlisting">void S_Control::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event)
{
  switch(l_event){
  case EntityEvent::Moving_Left:
    MoveEntity(l_entity,Direction::Left); break;
  case EntityEvent::Moving_Right:
    MoveEntity(l_entity, Direction::Right); break;
  case EntityEvent::Moving_Up:
    MoveEntity(l_entity, Direction::Up); break;
  case EntityEvent::Moving_Down:
    MoveEntity(l_entity, Direction::Down); break;
  }
}</pre></div><p>All four events invoke the same private method, which simply calls the <code class="literal">Move</code> method of a movable component and passes in the appropriate direction:</p><div><pre class="programlisting">void S_Control::MoveEntity(const EntityId&amp; l_entity, 
  const Direction&amp; l_dir)
{
  C_Movable* mov = m_systemManager-&gt;GetEntityManager()-&gt;
    GetComponent&lt;C_Movable&gt;(l_entity, Component::Movable);
  mov-&gt;Move(l_dir);
}</pre></div><p>After this humble addition to our code-base, we can finally move the player around with the keyboard:</p><div><img src="img/B04284_09_02.jpg" alt="The entity controller"/></div><p>The only problem now is entities looking like they're sliding on ice, due to complete lack of animations. To resolve this issue, the animation system must be introduced.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Animating the entities</h1></div></div></div><p>If you recall <a id="id416" class="indexterm"/>from previous chapters, the <code class="literal">SpriteSheet</code> class we built already has great support for animations. There is no reason to annex that at this point, especially since we're only dealing with sprite-sheet based graphics. This saves us a lot of time and allows sprite-sheet animations to be handled by a single system, with no additional component overhead.</p><p>Let's start implementing the sprite sheet animation system, as always, by getting the constructor out of the way:</p><div><pre class="programlisting">S_SheetAnimation::S_SheetAnimation(SystemManager* l_systemMgr)
  : S_Base(System::SheetAnimation,l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::SpriteSheet);
  req.TurnOnBit((unsigned int)Component::State);
  m_requiredComponents.push_back(req);

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::State_Changed,this);
}</pre></div><p>Since entity animations are, so far, entirely state-based, this system requires a state component, in addition to the sprite sheet component. It also subscribes to the <code class="literal">State_Changed</code> message type in order to respond to state changes by playing the appropriate animation. Updating all of the entities is the area where this system has most of its logic, so let's take a look at the <code class="literal">Update</code> method:</p><div><pre class="programlisting">void S_SheetAnimation::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    C_SpriteSheet* sheet = entities-&gt;
      GetComponent&lt;C_SpriteSheet&gt;(entity, Component::SpriteSheet);
    C_State* state = entities-&gt;
      GetComponent&lt;C_State&gt;(entity, Component::State);

    sheet-&gt;GetSpriteSheet()-&gt;Update(l_dT);

    const std::string&amp; animName = sheet-&gt;
      GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;GetName();
    if(animName == "Attack"){
      if(!sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying())
      {
        Message msg((MessageType)EntityMessage::Switch_State);
        msg.m_receiver = entity;
        msg.m_int = (int)EntityState::Idle;
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
      } else if(sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsInAction())
      {
        Message msg((MessageType)EntityMessage::Attack_Action);
        msg.m_sender = entity;
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
      }
    } else if(animName == "Death" &amp;&amp;
      !sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying())
    {
      Message msg((MessageType)EntityMessage::Dead);
      msg.m_receiver = entity;
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg);
    }
  }
}</pre></div><p>First, both<a id="id417" class="indexterm"/> the sprite sheet and state components are obtained. The sprite sheet is then updated and the current name of the animation is retrieved. If an attack animation is no longer playing, a message of <code class="literal">Switch_State</code> type is sent out in order to put the entity back to an <code class="literal">Idle</code> state. Otherwise, the animation is checked for currently being within the "action" frame range, which is specified in the sprite sheet file. If it is, an <code class="literal">Attack_Action</code> message is sent out to the current entity, which can later be used by different systems to implement combat. On the other hand, if the death animation has concluded, a <code class="literal">Dead</code> message is dispatched.</p><p>Next, let's work on handling messages:</p><div><pre class="programlisting">void S_SheetAnimation::Notify(const Message&amp; l_message){
  if(HasEntity(l_message.m_receiver)){
    EntityMessage m = (EntityMessage)l_message.m_type;
    switch(m){
    case EntityMessage::State_Changed:
      {
        EntityState s = (EntityState)l_message.m_int;
        switch(s){
        case EntityState::Idle:
          ChangeAnimation(l_message.m_receiver,"Idle",true,true);
          break;
        case EntityState::Walking:
          ChangeAnimation(l_message.m_receiver,"Walk",true,true);
          break;
        case EntityState::Attacking:
          ChangeAnimation(l_message.m_receiver,
            "Attack",true,false);
          break;
        case EntityState::Hurt: break;
        case EntityState::Dying:
          ChangeAnimation(l_message.m_receiver,
            "Death",true,false);
          break;
        }
      }
      break;
    }
  }
}</pre></div><p>All possible <a id="id418" class="indexterm"/>messages this system would be interested in deal with specific entities, so that check is made first. For now, we'll only be dealing with a single message type: <code class="literal">State_Changed</code>. Every time a state is changed, we'll be altering the animation of the entity. The only possible exception here is the <code class="literal">Hurt</code> state, which will be dealt with later.</p><p>The last bit of code we need is the private <code class="literal">ChangeAnimation</code> method:</p><div><pre class="programlisting">void S_SheetAnimation::ChangeAnimation(const EntityId&amp; l_entity, 
  const std::string&amp; l_anim, bool l_play, bool l_loop)
{
  C_SpriteSheet* sheet = m_systemManager-&gt;GetEntityManager()-&gt;
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet);
  sheet-&gt;GetSpriteSheet()-&gt;SetAnimation(l_anim,l_play,l_loop);
}</pre></div><p>After obtaining the entity's sprite sheet component, it simply invokes its <code class="literal">SetAnimation</code> method to change the current animation that's playing. This code is redundant enough to warrant a separate method.</p><p>Upon successful compilation, we can see that our entities are now animated:</p><div><img src="img/B04284_09_03.jpg" alt="Animating the entities"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Handling collisions</h1></div></div></div><p>Making<a id="id419" class="indexterm"/> entities bump into each other, as well as into all the lush environments we'll be building is a mechanic, without which most games out there would not be able to function. In order for that to be possible, these animated images zooming around the screen must have a component, which represents their solidity. Bounding boxes worked really well for us in the past, so let's stick to them and begin constructing the collidable body component:</p><div><pre class="programlisting">enum class Origin{ Top_Left, Abs_Centre, Mid_Bottom };

class C_Collidable : public C_Base{
public:
    ...
private:
    sf::FloatRect m_AABB;
    sf::Vector2f m_offset;
    Origin m_origin;

    bool m_collidingOnX;
    bool m_collidingOnY;
};</pre></div><p>Every collidable entity must have a bounding box that represents the solid portion of it. That's exactly where the <code class="literal">m_AABB</code> rectangle comes in. In addition to that, the bounding box itself can be offset by a number of pixels, based on what kind of entity it is, as well as have a different origin. Lastly, we want to keep track of whether an entity is currently colliding on any given axis, which warrants the use of <code class="literal">m_collidingOnX</code> and <code class="literal">m_collidingOnY</code> flags.</p><p>The constructor of this component might look a little something like this:</p><div><pre class="programlisting">C_Collidable(): C_Base(Component::Collidable), 
  m_origin(Origin::Mid_Bottom), m_collidingOnX(false),
  m_collidingOnY(false)
{}</pre></div><p>After initializing the default values to some of its data members, this component, like many others, needs to have a way to be de-serialized:</p><div><pre class="programlisting">void ReadIn(std::stringstream&amp; l_stream){
    unsigned int origin = 0;
    l_stream &gt;&gt; m_AABB.width &gt;&gt; m_AABB.height &gt;&gt; m_offset.x&gt;&gt; m_offset.y &gt;&gt; origin;
    m_origin = (Origin)origin;
}</pre></div><p>Here are a few unique setter and getter methods that we'll be using:</p><div><pre class="programlisting">void CollideOnX(){ m_collidingOnX = true; }
void CollideOnY(){ m_collidingOnY = true; }
void ResetCollisionFlags(){
    m_collidingOnX = false;
    m_collidingOnY = false;
}
void SetSize(const sf::Vector2f&amp; l_vec){
    m_AABB.width      = l_vec.x;
    m_AABB.height     = l_vec.y;
}</pre></div><p>Finally, we<a id="id420" class="indexterm"/> arrive at the key method of this component, <code class="literal">SetPosition</code>:</p><div><pre class="programlisting">void SetPosition(const sf::Vector2f&amp; l_vec){
   switch(m_origin){
   case(Origin::Top_Left):
      m_AABB.left = l_vec.x + m_offset.x;
      m_AABB.top  = l_vec.y + m_offset.y;
      break;
   case(Origin::Abs_Centre):
      m_AABB.left = l_vec.x - (m_AABB.width / 2) + m_offset.x;
      m_AABB.top  = l_vec.y - (m_AABB.height / 2) + m_offset.y;
      break;
   case(Origin::Mid_Bottom):
      m_AABB.left = l_vec.x - (m_AABB.width / 2) + m_offset.x;
      m_AABB.top  = l_vec.y - m_AABB.height + m_offset.y;
      break;
   }
}</pre></div><p>In order to support different types of origins, the position of the bounding box rectangle must be set differently. Consider the following illustration:</p><div><img src="img/B04284_09_04.jpg" alt="Handling collisions"/></div><p>The origin of the actual bounding box rectangle is always going to be the top-left corner. To position it correctly, we use its width and height to compensate for differences between<a id="id421" class="indexterm"/> several possible origin types.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec51"/>The collision system</h2></div></div></div><p>The<a id="id422" class="indexterm"/> actual collision magic doesn't start happening until we have <a id="id423" class="indexterm"/>a system responsible for accounting for every collidable body in the game. Let's begin by taking a look at the data types that are going to be used in this system:</p><div><pre class="programlisting">struct CollisionElement{
  CollisionElement(float l_area, TileInfo* l_info,
    const sf::FloatRect&amp; l_bounds):m_area(l_area),
    m_tile(l_info), m_tileBounds(l_bounds){}
  float m_area;
  TileInfo* m_tile;
  sf::FloatRect m_tileBounds;
};

using Collisions = std::vector&lt;CollisionElement&gt;;</pre></div><p>For proper collision detection and response, we're also going to need a data structure that is capable of holding collision information, which can later be sorted and processed. For that, we're going to be using a vector of <code class="literal">CollisionElement</code> data types. It's a structure, consisting of a float, representing area of collision, a pointer to a <code class="literal">TileInfo</code> instance, which carries all of the information about a tile, and a simple float rectangle, which holds the bounding box information of a map tile.</p><p>In order to detect collisions between entities and tiles, the collision system needs to have access to a <code class="literal">Map</code> instance. Knowing all of that, let's get started on implementing the class!</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec10"/>Implementing the collision system</h3></div></div></div><p>As <a id="id424" class="indexterm"/>always, we're going to be setting up the component requirements right inside the constructor of this class:</p><div><pre class="programlisting">S_Collision::S_Collision(SystemManager* l_systemMgr) 
  :S_Base(System::Collision,l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::Collidable);
  m_requiredComponents.push_back(req);
  req.Clear();

  m_gameMap = nullptr;
}</pre></div><p>As you can see, this system imposes requirements of position and collidable components on entities. Its <code class="literal">m_gameMap</code> data member is also initialized to <code class="literal">nullptr</code>, until it gets set up via the use of this method:</p><div><pre class="programlisting">void S_Collision::SetMap(Map* l_map){ m_gameMap = l_map; }</pre></div><p>Next up is<a id="id425" class="indexterm"/> the oh-so-common update method that makes everything behave as it should:</p><div><pre class="programlisting">void S_Collision::Update(float l_dT){
  if (!m_gameMap){ return; }
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    C_Position* position = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    C_Collidable* collidable = entities-&gt;
      GetComponent&lt;C_Collidable&gt;(entity, Component::Collidable);
    collidable-&gt;SetPosition(position-&gt;GetPosition());
    collidable-&gt;ResetCollisionFlags();
    CheckOutOfBounds(position, collidable);
    MapCollisions(entity, position, collidable);
  }
  EntityCollisions();
}</pre></div><p>For clarity, the update method uses two other helper methods: <code class="literal">CheckOutOfBounds</code> and <code class="literal">MapCollisions</code>. While iterating over all collidable entities, this system obtains their position and collidable component. The latter is updated, using the entity's latest position. It also has its Boolean collision flags reset. After all entities have been updated, the private <code class="literal">EntityCollisions</code> method is invoked to process entity-on-entity intersection tests. Note the very beginning of this method. It immediately returns in case the map instance hasn't been properly set up.</p><p>First, the entity is checked for being outside the boundaries of our map:</p><div><pre class="programlisting">void S_Collision::CheckOutOfBounds(C_Position* l_pos,
  C_Collidable* l_col)
{
  unsigned int TileSize = m_gameMap-&gt;GetTileSize();

  if (l_pos-&gt;GetPosition().x &lt; 0){
    l_pos-&gt;SetPosition(0.0f, l_pos-&gt;GetPosition().y);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
  } else if (l_pos-&gt;GetPosition().x &gt;
    m_gameMap-&gt;GetMapSize().x * TileSize)
  {
    l_pos-&gt;SetPosition(m_gameMap-&gt;GetMapSize().x * TileSize,
      l_pos-&gt;GetPosition().y);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
  }

  if (l_pos-&gt;GetPosition().y &lt; 0){
    l_pos-&gt;SetPosition(l_pos-&gt;GetPosition().x, 0.0f);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
  } else if (l_pos-&gt;GetPosition().y &gt;
    m_gameMap-&gt;GetMapSize().y * TileSize)
  {
    l_pos-&gt;SetPosition(l_pos-&gt;GetPosition().x,
      m_gameMap-&gt;GetMapSize().y * TileSize);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
  }
}</pre></div><p>If the<a id="id426" class="indexterm"/> entity has somehow ended up outside the map, its position gets reset.</p><p>At this point, we begin running the tile-on-entity collision test:</p><div><pre class="programlisting">void S_Collision::MapCollisions(const EntityId&amp; l_entity,
  C_Position* l_pos, C_Collidable* l_col)
{
  unsigned int TileSize = m_gameMap-&gt;GetTileSize();
  Collisions c;

  sf::FloatRect EntityAABB = l_col-&gt;GetCollidable();
  int FromX = floor(EntityAABB.left / TileSize);
  int ToX = floor((EntityAABB.left + EntityAABB.width)/TileSize);
  int FromY = floor(EntityAABB.top / TileSize);
  int ToY = floor((EntityAABB.top + EntityAABB.height)/TileSize);
  ...
}</pre></div><p>A collision information vector named <code class="literal">c</code> is set up. It will contain all the important information about what the entity is colliding with, the size of the collision area and properties of the tile it's colliding with. The entity's bounding box is then obtained from the collidable component. A range of coordinates to be checked is calculated, based on that bounding box, as shown here:</p><div><img src="img/B04284_09_05.jpg" alt="Implementing the collision system"/></div><p>Those coordinates<a id="id427" class="indexterm"/> are immediately put to use, as we begin iterating over the calculated range of tiles, checking for collisions:</p><div><pre class="programlisting">for (int x = FromX; x &lt;= ToX; ++x){
  for (int y = FromY; y &lt;= ToY; ++y){
    for (int l = 0; l &lt; Sheet::Num_Layers; ++l){
      Tile* t = m_gameMap-&gt;GetTile(x, y, l);
      if (!t){ continue; }
      if (!t-&gt;m_solid){ continue; }
      sf::FloatRect TileAABB(x*TileSize, y*TileSize,TileSize, TileSize);
      sf::FloatRect Intersection;
      EntityAABB.intersects(TileAABB, Intersection);
      float S = Intersection.width * Intersection.height;
      c.emplace_back(S, t-&gt;m_properties, TileAABB);
      break;
    }
  }
}</pre></div><p>Once a solid tile is encountered, its bounding box, tile information and area of intersection details are gathered and inserted into the vector <code class="literal">c</code>. It's important to stop the layer loop if a solid tile is detected, otherwise collision detection may not function properly.</p><p>After all the solids the entity collides with in the calculated range have been found, they all must be sorted:</p><div><pre class="programlisting">if (c.empty()){ return; }
std::sort(c.begin(), c.end(),
  [](CollisionElement&amp; l_1, CollisionElement&amp; l_2){
    return l_1.m_area &gt; l_2.m_area;
});</pre></div><p>After sorting, we can finally begin resolving collisions:</p><div><pre class="programlisting">for (auto &amp;col : c){
  EntityAABB = l_col-&gt;GetCollidable();
  if (!EntityAABB.intersects(col.m_tileBounds)){ continue; }
  float xDiff = (EntityAABB.left + (EntityAABB.width / 2)) -
    (col.m_tileBounds.left + (col.m_tileBounds.width / 2));
  float yDiff = (EntityAABB.top + (EntityAABB.height / 2)) -
    (col.m_tileBounds.top + (col.m_tileBounds.height / 2));
  float resolve = 0;
  if (std::abs(xDiff) &gt; std::abs(yDiff)){
    if (xDiff &gt; 0){
      resolve = (col.m_tileBounds.left + TileSize) -
        EntityAABB.left;
    } else {
      resolve = -((EntityAABB.left + EntityAABB.width) -
        col.m_tileBounds.left);
    }
    l_pos-&gt;MoveBy(resolve, 0);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
    m_systemManager-&gt;AddEvent(l_entity,
      (EventID)EntityEvent::Colliding_X);
    l_col-&gt;CollideOnX();
  } else {
    if (yDiff &gt; 0){
      resolve = (col.m_tileBounds.top + TileSize) -
        EntityAABB.top;
    } else {
      resolve = -((EntityAABB.top + EntityAABB.height) -
        col.m_tileBounds.top);
    }
    l_pos-&gt;MoveBy(0, resolve);
    l_col-&gt;SetPosition(l_pos-&gt;GetPosition());
    m_systemManager-&gt;AddEvent(l_entity,
      (EventID)EntityEvent::Colliding_Y);
    l_col-&gt;CollideOnY();
  }
}</pre></div><p>Since <a id="id428" class="indexterm"/>resolution of one collision could potentially resolve another as well, the bounding box of an entity must be checked for intersections here as well, before we commit to resolving it. The actual resolution is pretty much the same as it was in <a class="link" href="ch07.html" title="Chapter 7. Rediscovering Fire – Common Game Design Elements">Chapter 7</a>, <em>Rediscovering Fire – Common Game Design Elements</em>.</p><p>Once the resolution details are calculated, the position component is moved based on it. The collidable component has to be updated here as well, because it would end up getting resolved multiple times and moved incorrectly otherwise. The last bit we need to worry about is adding a collision event to the entity's event queue and calling the <code class="literal">CollideOnX</code> or <code class="literal">CollideOnY</code> method in the collidable component to update its flags.</p><p>Now for entity-on-entity collisions:</p><div><pre class="programlisting">void S_Collision::EntityCollisions(){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto itr = m_entities.begin();
    itr != m_entities.end(); ++itr)
  {
    for(auto itr2 = std::next(itr);
      itr2 != m_entities.end(); ++itr2){
      C_Collidable* collidable1 = entities-&gt;
        GetComponent&lt;C_Collidable&gt;(*itr, Component::Collidable);
      C_Collidable* collidable2 = entities-&gt;
        GetComponent&lt;C_Collidable&gt;(*itr2, Component::Collidable);
      if(collidable1-&gt;GetCollidable().intersects(
        collidable2-&gt;GetCollidable()))
      {
        // Entity-on-entity collision!
      }
    }
  }
}</pre></div><p>This method <a id="id429" class="indexterm"/>checks all entities against all other entities for collisions between their bounding boxes, by using the <code class="literal">intersects</code> method, kindly provided by SFML's rectangle class. For now, we don't have to worry about responding to these types of collisions, however, we will be using this functionality in future chapters.</p><p>Lastly, just like its movement counterpart, the collision system requires a pointer to the <code class="literal">Map</code> class, so let's give it one in the game state's <code class="literal">OnCreate</code> method:</p><div><pre class="programlisting">void State_Game::OnCreate(){
  ...
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
    GetSystem&lt;S_Collision&gt;(SYSTEM_COLLISION)-&gt;SetMap(m_gameMap);
  ...
}</pre></div><p>This final code snippet gives the collision system all of the power it needs, in order to keep the entities from walking through solid tiles, as so:</p><div><img src="img/B04284_09_06.jpg" alt="Implementing the collision system"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Summary</h1></div></div></div><p>Upon completing this chapter, we've successfully moved away from inheritance-based entity design and reinforced our code-base with a much more modular approach, thus avoiding many pitfalls that composition leaves behind. A chain is only as strong as its weakest link, and now we can rest assured that the entity segment will hold.</p><p>In the next two chapters, we will be discussing how to make the game more interactive and user friendly by adding a GUI system, as well as adding a few different types of elements, managing their events and providing room for them to be graphically customizable. See you there!</p></div></body></html>