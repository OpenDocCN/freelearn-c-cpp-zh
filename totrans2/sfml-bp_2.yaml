- en: Chapter 2. General Game Architecture, User Inputs, and Resource Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the boring part is over, let''s start working with SFML. In this chapter,
    we are not yet going to build a complete game, but instead we''ll learn some basic
    skills that are required to build a game. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a basic game architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping a track of external resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these points are really important for any kind of game. But what do these
    points exactly mean? This is what I will explain to you in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: General structure of a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting to build randomly and without any specific planning, we need
    to have some information: what kind of game you want to build (RPG, FPS, or action-adventure),
    what elements will be used, and so on. The aim of this chapter is to understand
    the general game structure, which can be used in any kind of game. Through this
    part, we will study:'
  prefs: []
  type: TYPE_NORMAL
- en: The game class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frame rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have seen the minimal code required for a game,
    which contains:'
  prefs: []
  type: TYPE_NORMAL
- en: Window creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of graphic display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deal with the user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display game objects on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of having one function do all the work, we will make use of object-oriented
    practices and define various states in different functions. Moreover, we will
    encapsulate the methods in a new class named `Game`, and we will minimize the
    `main` function. This `Game` class will be the starting point for all our future
    games:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`= delete` is a C++11 feature that allows us to explicitly delete a special
    member function such as constructor, move constructor, copy constructor, copy-assignment
    operator, move copy-assignment operator, and destructor. It tells to the compiler
    to not build the default function. In this particular case, it makes the class
    noncopyable. Another solution would be to extend the class from `sf::NonCopyable`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`= default` is also possible to explicitly tell the compiler to build the default
    version of this member function. It could, for example, be used to define a custom
    constructor and a default constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the basic `Game` class structured, in which the functions are separated
    based on their features. Moreover, there is no loop anymore in the main function
    because we will be present in the `Game::run()` function. Now, we simply have
    to call the `Game::run()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move all the codes from the main function into the functions—`processEvents()`,
    `update()`, or `render()`—depending on what we are trying to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '`processEvents()`: This will manage all events from the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`: This will update the entire game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`: This will manage all the rendering of the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the future features will also be put into one of these private functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor initializes the window and the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Game::run()` method hides the main `game` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Game::processEvents()` method handles user inputs. It simply polls all
    the events received from the window since the last frame, such as a button in
    the window title bar or a keyboard key being pressed. In the following code, we
    check for the user pressing the window''s close button and the keyboard''s Esc
    key. In response, we close the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `update()` method updates our game logic. For the moment, we don''t have
    any logic, but in the near future we will see how to modify the logic of our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Game::render()` method renders the game to the screen. First, we clear
    the window with a color, usually `sf::Color::Black`, which is the default, then
    we render our object for the frame, and finally, we display it on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the color images of this book**'
  prefs: []
  type: TYPE_NORMAL
- en: We also provide you with a PDF file that has color images of the screenshots/diagrams
    used in this book. The color images will help you better understand the changes
    in the output. You can download this file from [https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf](https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no change on the final render of the scene, compared to the minimal
    example of the previous chapter, except the title and the size. Even if there
    is more code, the application is easier to maintain with the new architecture
    because the functions have been reduced to the minimal, and it''s easier for you
    to find what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game class](img/8477OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Game loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `Game` class has been introduced, let's talk about the loop inside
    the `Game::run()` function. This loop is called the `game` loop or `main` loop.
    It runs continuously during game play and performs several actions at each turn
    of the loop. Each iteration of this loop is called a frame. The term **frames
    per second** (**FPS**) is a measure that determines the number of iterations made
    by the game in 1 second. I will come back to this point later.
  prefs: []
  type: TYPE_NORMAL
- en: What you do inside this loop is quite simple. Firstly, we process the events.
    Then we update the games states. Finally, we render the game to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have noticed, this sounds a lot like the `run` method of the `Game`
    class. To explain more visually, this loop is a flowchart representing the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game loops](img/8477OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the moment, the loop is reduced to the minimum. For example, we don't detail
    the `Game::processEvents()` method in depth here. For the moment, the game loop
    has been kept simple, so you can learn the basics first. Later, we will be getting
    back to each of the methods in the `Game::run()` method, such as the `Game::processEvents()`
    method, and adding more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The frame rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now coming back to the frames. As I have already said, a frame is a complete
    iteration of the `game` loop. The final result is the new `game` states that can
    be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Humans are unable to see unlimited number of images per second. There is some
    interpolation between each image that we perceive with our brain. The result is
    that we don't need to display a great amount of images each second. But the more
    images displayed, the greater will the quality of the final result be. For example,
    at the cinema, only 24 images are displayed per second.
  prefs: []
  type: TYPE_NORMAL
- en: In video games, most of the time, we try to make a loop as quick as we can.
    The number of images displayed reaches 30 to 60 per second. Below 30 FPS, there
    can be a lag effect which can be due to the game, and we need to handle it to
    avoid problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common problems caused by the lag effect is the displacement
    of the entities. Most of the time, each entity has its own speed and direction.
    The speed is often measured in pixels per second. Now imagine your game, for any
    reason, has some lag and the FPS dropped to a small number like 5, then the graphical
    effect is that all your entities will teleport themselves. But this is not the
    main issue. The big issue is with the collisions. Take an example of an entity
    that was walking in the direction of a wall when the lag happens, the entity will
    literally cross over the wall. Here is a figure that represents the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The frame rate](img/8477OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To fix this problem, there are three different approaches. The first is called
    variable time steps, second is fixed time steps, and third that mix them together.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed time steps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fixed time steps approach, as its name suggests, is an approach where each
    call to the `Game::update()` function is made with the same time interval. The
    units used, for example, for the movement are relative to the frame. Because each
    frame is separate from the others of the same time, we don't need more complexity.
    The only thing we need to pay attention to is to choose the basic values to be
    sure that there are no problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the new flowchart of the `game` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed time steps](img/8477OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will implement the new `Game` class in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code ensures that each call to the `Game::update()` function will always
    take the same time as the parameter value. There no big difference with the previous
    version of the code. Here we just keep track of the time since the last call of
    the `Game::update()` function, and then we only call it again, when the time exceeds
    the frame rate. The code could be improved by sleeping with `sf::sleep` the remainder
    of the free time in the loop. It's a bit more difficult (because needs to measure
    the time spent in the previous update+render), but won't waste CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little change has been made on the `Game::update()` function by adding a
    parameter to it. Its new signature is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This parameter allows us to know the time elapsed since the last call of `Game::update()`.
    Currently, there is no great interest in it, but later there will be.
  prefs: []
  type: TYPE_NORMAL
- en: Because the state of the game is changed only when `Game::update()` is called,
    the call to `Game::render()` is made when at least an update is made.
  prefs: []
  type: TYPE_NORMAL
- en: Variable time steps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The variable time steps approach is different from fixed time steps, as the
    name suggests. The main idea here is to execute the `game` loop as quickly as
    we can, without any delay. This allows the game to be more reactive. The units
    here have to be like units per time (mostly, time refers to one second here).
    Because we cannot predict how many times the loop will run, we will make it a
    parameter in the `Game::update()` function, and multiply it with the base unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our actual implementation of the `game` loop corresponds to the variable time
    steps approach; we just need to add a system to keep a track of the elapsed time
    since the last loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing new here is `sf::Clock` and the parameter to the `Game::update()`
    method. But there is still a problem with this approach: when the game is too
    slow (the time between two steps is important).'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum time steps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is another solution, wherein the last two approaches are merged. The
    idea is to run the game as quickly as possible by ensuring the time parameter
    passed in the `Game::update()` method is not too high. The consequence is that
    we ensure to have a minimal frame rate, but no maximal. To sum up, we want two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow the game to run as quickly as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, for any reason, the time between the two loops becomes higher than, let's
    say, 30 FPS, we split this time as much as needed to ensure that the delta time
    pass to the `Game::update()` function is not higher than 30 FPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the flowchart representing this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Minimum time steps](img/8477OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will implement the new `run` function in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On each frame, the `Game::update()` and `Game::render()` methods are called,
    but when the delta time between two frames is more important than what we want,
    the `Game::update()` method is called with the maximum value allowed, as many
    times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: All these approaches have their strong points and their weak points. Depending
    on circumstances, one approach will be better than another. But from now on, we
    will use the minimum time steps approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these solutions are not well adapted to use a physics engine. We will return
    to this particular point in [Chapter 4](ch04.html "Chapter 4. Playing with Physics"),
    *Playing with Physics*. But knowing that it will take two loops: one for the physics
    and another one for the game logic. Each of these loops can have a frame rate
    different from each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other approaches to manage the frame rate of an application. One of
    the most common is the `sleep()` function, which interrupts the application during
    a specified time and gives the processor the opportunity to work on other tasks.
    But this is not a good solution in games and all kinds of applications that need
    exact timing. SFML provides us with a `sf::RenderWindow::setFramerateLimit()`
    function that tries to fix the frame rate of the running application by calling
    `sf::sleep()` internally. This is a good solution, but for testing only.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to use the vertical synchronization by calling `void sf::Window::setVerticalSyncEnabled(bool)`.
    It will limit the number of frames displayed to the refresh rate of the monitor
    (most of the time 60 Hz, but there is no guarantee). It helps in avoiding some
    visual artefacts, and limits the frame rate to a good value (but not constant
    across different computers). V-Sync can occasionally lock too low on some systems.
    This is why in full production games it can be turned on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Move our player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a clean `game` loop, let's move our `Player` object. For now,
    let's move it forward and make it turn right and left. We will make it in a way
    that will not depend on the frame rate. First, let's consider the player.
  prefs: []
  type: TYPE_NORMAL
- en: The player class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Player` is a really important class in any kind of game, and changes a lot
    with the type of game. Here our goal is just to be able to move and rotate it.
    So the information required is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Its shape, size, and color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s change the `Player` shape to a square using the SFML class `sf::RectangleShape`.
    The direction and the speed can be merged into a single object: a mathematical
    vector (we will speak about this in the next section). SFML provides a nice class
    for this: `sf::Vector2f`. We will also need to add speed and rotation and set
    the position of the player, but we will also update it and finally display it
    on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we obtain this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, the player needs to be displayed on the screen, so we extend
    it from `sf::Drawable`. This class simply adds the `draw()` virtual method to
    the class that we need to override. To be sure that we override it, we use the
    new keyword of C++11: `override`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using override, we are sure that we make an override and not an overload. This
    is a new keyword from C++11.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as in the `Game` class, we make the player non-copyable by explicitly
    deleting the default implementation of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s speak about the `Player::setPosition()` method. As you can see,
    its signature is really strange. Here, I use another C++11 feature: the `variadic`
    template. As you know, `sf::Transformable` has two versions of the `setPosition()`
    method. The first one takes two float numbers, and the second takes `sf::Vector2f`
    as the parameter. Because I don''t want to build the two versions, I use a new
    possibility of C++. I simply forward the arguments to `sf::Transformable::setPosition()`
    without knowing them. By using this, we can use both of the `sf::Transformable::setPosition()`
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare the parameter type of the function as the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we also want to have a variable number of parameters, so we use the
    ellipse operator. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t want to fix the type of parameter (constant, left-reference,
    or right-reference), we use another feature of C++11: the right value reference
    or, in this context, the forwarding/universal reference. This allows us to catch
    any kind of type by simply adding `&&`. The final signature of the function now
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to perfectly forward the parameters to `sf::Transformable::setPosition()`,
    we simply need to unpack the arguments pack using the ellipse operator and call
    `std::forward` on each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We can now use any of the `sf::Transformable::setPosition()` methods.
    This approach is really powerful to make some generic code, so try to understand
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Player` class also has two public attributes: `isMoving` and `rotation`.
    These attributes will simply store the inputs'' states.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look to the implementation of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just change the `_shape` constructor to fit with the `sf::RectangeShape`
    constructor, and center the origin of the shape to its gravity center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the important part. This function updates our player in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: First we rotate it if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, if the player is moving, we simply get the angle of rotation of the shape
    to know its direction, and then to its existing velocity, we add some speed depending
    on its direction. Notice that for the moment we don't clamp the maximal speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish, we just have to move it; this is incredibly easy. We simply need
    to call the `move` method on `shape` with `velocity` as the parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because each frame is not executed in the same time, we need to multiply all
    the values (rotation speed, acceleration, and velocity) by the time since the
    last call. Here I choose to use pixels per second as the unit, so we need to multiply
    the value with the number of seconds since the last call; `sf::Time` provides
    this ability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function is not difficult and should not surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the `Game::processEvents()` function to set the values
    of `isMoving` and `rotation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we set the value of `isMoving` to `true` when the up arrow key
    is pressed and to `false` when it is released. The same trick is used to set the
    rotation depending on the left and right arrows, but here we set the rotation
    direction, `1` for clockwise, `-1` for counterclockwise, and `0` to none. All
    the computations have already been made in `Player::update()`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing user inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing the events received from the user is a really important topic. SFML
    provides us with two different approaches. The first is by polling the events
    received from a `sf::Window` instance, and the other is by checking the state
    in real time of an entry.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, what is an event?
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, an event is an object that is triggered when something changes/happens.
    They are OS-dependent, but SFML provides us with a nice object to handle them
    in an OS-independent way. This is the `sf::Event` class. This class deals with
    a vast number of events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows contains four different kinds of events. They are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain/lose focus
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The mouse pointer goes in/out of the window
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three events for the mouse. They are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Key press/release
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wheel press, release, or move
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The keyboard contains two events. They are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys press/release
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Text entered
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The joystick is also managed with four events. They are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected/disconnected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Move
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Press/release the key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I suggest you take a look at the SFML documentation for this class at [http://www.sfml-dev.org/tutorials/2.2/window-events.php](http://www.sfml-dev.org/tutorials/2.2/window-events.php).
    An important thing to have in mind is that `sf::Event` is nothing but a big union,
    so you have to pay attention to access the right attributes of an event depending
    on its type.
  prefs: []
  type: TYPE_NORMAL
- en: Polling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These kinds of events are stored in a queue by a `sf::Window` instance. To
    deal with them, we simply need to extract them one by one using the `sf::Window::pollEvent()`
    method. Its signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This signature is a bit interesting. The return value is set to `true` if an
    event has been extracted from the queue and `false` in other cases. When an event
    is extracted, the event parameter is set to correspond to the correct value. In
    other words, the event parameter is the event that we get when the function returns
    `true`. The typical use of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we've done in our actual application. For the moment, we
    use the event polling to deal with the user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: These event types are used for specific cases (such as closing the window, using
    the escape key to exit, pausing the game, and so on), and not to move a player
    because events are perceived so jerky in a non-real-time. The resulting movement
    will also be jerky.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SFML provides us with the possibility to check the state of an entity at any
    time. This entity can be the mouse, keyboard, or a joystick. Here, we don't use
    events, but we simply check the position of the mouse, and whether a specific
    button or key is pressed. This is really different from the events, and is particularly
    well adapted for the player's actions such as movement, shooting, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you have probably noticed, our actual use of event in the `Player` class
    is wrong. So we need to change it to use real-time events without changing the
    controls keys. To do this, we will add a `processEvents()` method in the `Player`
    class that will set the value of `isMoving` and `rotation`. We will also change
    our `Game::processEvents()` function to call the newly created `Player::processEvents()`
    method. Also, because `isMoving` and `rotation` will be set inside the `Player`
    class, we will move them as private attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the signature of the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is the exact same signature as `Game::processEvents()`.
    Its implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set the `isMoving` value, depending on the up arrow state. To do
    this, we use the `sf::Keyboard::isKeyPressed()` function. Because this function
    is a static one, we can directly use it without any object. Take a look at its
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function returns `true` if the key is pressed, and `false` if not. Really
    simple, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about the rotation. The rotation depends on two different
    inputs. So, we need to think "What will happen if the user presses both at the
    same time?". It might sound a bit weird, but yes, some players will do this, so
    we need to consider it. Here, I use a really simple solution:'
  prefs: []
  type: TYPE_NORMAL
- en: First, I reset the value of `rotation`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, I add `rotation` depending on the input state for both the keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing this, if no key is pressed, `rotation` stays to its initial value,
    that is, `0`. If one of the inputs is pressed, then `rotation` takes the value
    of `1` or `-1`, and if both are pressed, the two inputs will cancel each other
    out, so everything is fine and we get the result we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s focus on the `Player::update()` method. This one is not really
    different. The only line we have to change is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we now set `rotation` inside the `Player` class, we are sure that its
    value is always accurate, so that we don''t need to verify it anymore and can
    remove it. The new line is reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the updated `Game::processEvents()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we drastically reduce the code size by removing any event dedicated to
    the player. The only thing to do is to call the `Player::processEvents()` method
    instead of managing the player controls.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the events are known better, it could be interesting to be able to
    bind them to some callback when they occur. The main idea behind this is to allow
    us to dynamically add functionalities. In a game, you sometimes have the possibility
    to upgrade some weapons, or to use new ones; one option is to make sure that the
    usage is allowed before executing it, and another is to add it to the player when
    he is able to use it. By doing this, we remove a lot of if statements in our code
    and increase the readability of the latter.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need a system that allows us to add functionalities to an entity,
    and that can be triggered by an event. This event can be in real time or generated
    by polling a `sf::Window` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Action class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new class containing an `sf::Event` instance that needs to
    be executed. This class will implement functionality to check if the internal
    `sf::Event` instance is executed. The comparison operators are a good way to do
    this, but it will not work for real-time events because we have nothing to compare
    with, as we don't pool them. So we will also need `Action::test()` to check if
    a real-time event is satisfied. We will also need to know whether the event has
    to be triggered by pressing or releasing the input, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `Action` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us follow this code step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define enum that will be used as flags in and by the constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we make the copy constructor and the copy operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next are the constructors. For the moment, we need to manage inputs from the
    mouse and the keyboard. So we make two constructors, one for each type of event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `test()` function will allow us to test whether the event is satisfied in
    real time, and the comparison operators will allow us to compare the event with
    others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We shall now take a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions simply copy the content of `Action` to another `Action`
    instance. Because the `sf::Event` class doesn''t implement the copy operator/constructor,
    we use the `std::memcpy()` function from the C string module. This allows us to
    copy the entire content of `sf::Event` simply by knowing its size, which can be
    known using the `sizeof()` operator. Notice that this is technically correct in
    this case only because `sf::Event` doesn''t contain any pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the constructor for the keyboard events. The `key` parameter defines
    the key to bind, and the `type` parameter defines the state of the input: real-time,
    pressed, released, or a combination of them. Because the `type` value is a flag,
    it can take the value of `Pressed` and `Released` at the same time; this creates
    a problem because the type of an event can''t be `sf::Event::EventType::KeyPressed`
    and `sf::Event::EventType::KeyReleased` at the same time. We need to bypass this
    limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, set the event type to `sf::Event::EventType::KeyPressed` no matter
    what the value of type is, and we will have some special cases to deal with later
    (in `test()` and comparison operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same idea as the previous constructor. The only difference is that
    `event.mouseButton` cannot be copied. So here we need to use `std::memcpy()` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Action::operator==()` is an interesting function. This function will test
    if two events are equivalent. But, because we have previously fixed the value
    for the keyboard and the mouse to `sf::Event::EventType::[Key/Button]Pressed`,
    we need to check these special cases. These cases are represented by the `if`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is pretty simple, first we check the type, and then, we forward
    the comparison to the comparison operator previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function is made for checking real-time events. As I have already mentioned,
    we only need the mouse and keyboard events. To check them, we use the static functions
    `sf::Keyboard::isKeyPressed()` and `sf::Mouse::isButtonPressed()`. Here we simply
    have to check the type of events and the state required, and that's it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `Action` class was made, let''s move on to the next step: binding
    them to a functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Action target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now need a system to bind a functionality to an event. So let's think
    about what a functionality is.
  prefs: []
  type: TYPE_NORMAL
- en: 'A functionality is a piece of code that has to be executed when a criterion
    is satisfied. Here the criterion is an action and thanks to our freshly defined
    class, we can now know whether the event is satisfied or not. But what about the
    piece of code? If we think a little bit about it, the functionality can be put
    in a function or method, so here we are: a functionality is nothing but a function.
    So to store the code, and be able to bind it at runtime, we will use the generic
    function wrapper from the C++11: the template class `std::function`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::function` is a generic wrapper for any type of function, method, and
    lambda. It''s a very powerful object to store callbacks. To do this, we will use
    another new class from the C++11, the template class `std::pair`, and a container.
    Due to our needs, a `std::` list will be perfectly fine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have all the keys in hand to build what we need. We will build a container
    to store as many actions paired with `std::function` as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we define the type of the function that will be managed with the new
    C++11 use of the `using` keyword. This syntax is equivalent to `typedef` except
    that it is more explicit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, we define a default constructor and the methods to verify the internal
    events. We create two of them. The first is for non-real-time events (polling),
    and the other is for real-time events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we add a method to bind an event to a function, and another to remove any
    existing event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, you can make the choice to separate the real-time and non-real-time
    events to avoid some `if` statements. The goal is to win some readability and
    computing power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The two `ActionTarget::processEvent[s]()` methods are not difficult and simply
    check the validity of the events by using the functions that have been made in
    the `Action` class. If the event is satisfied, we call the associated function
    with the `sf::Event` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here a new `for` loop, syntax is used. It''s the `foreach` style of the C++11
    `for` loop coupled with the `auto` keyword. This is both a very powerful and succinct
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This method adds a new event and its callback to the internal container. To
    avoid some `if` statements in the `processEvent[s]()` methods, I make the choice
    to separate the real-time event from the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, it could be useful to be able to remove some actions. This is the
    idea of this function. I use the `std::list::remove_if()` method here to remove
    all the actions of the internal list that match the parameter. It takes a function
    such as the parameter, so we create a lambda. The lambda functions are a new feature
    from the C++11\. Their syntax is a little special, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the preceding syntax in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A lambda is like any other function, except it doesn't have a name (also named
    anonymous functions). Because of this, a lambda doesn't know the context and sometimes,
    like here, you will need some variables from the calling context. These variables
    have to be specified in the `[]` part. You can prefix them with a `=` or `&` symbol
    depending on whether you want to access them by copy or by reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second is the parameters part. Nothing is new in this part. The parameter type
    is fixed by the `std::list::remove_if()` function to the same type of template
    parameter of the `std::list` used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then it's the return type. It's not an obligation, because this type can be
    deduced from the return statement, but here I've made the choice to explicitly
    write it, as a complete example. The return type is also fixed by the `std::list::remove_if()`
    method to `bool`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, between `{` and `}` is the implementation of the lambda. This implementation
    is really simple because all the work has already been done in the `Action` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here we are. We have our complete new `ActionTarget` class ready to be
    used. There are some new C++ features used in this part (`using`, `foreach`, `auto`,
    and `lambda`). If you don''t understand them, I suggest you learn them by reading
    the C++11 that can be find on this website : [http://en.cppreference.com/w/cpp/language](http://en.cppreference.com/w/cpp/language).
    It''s really essential you understand what is used here before you read on. So
    if need be, take as much time as required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have built the system to manage the events, let''s use it. We will
    change our player, and extend it from `ActionTarget`. We will need to change the
    code in the `.hpp` file a little bit. Since the C++ allows us to use the multiple
    inheritance, let''s use it, and change the class from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, the functionalities of the `ActionTarget` class are added to
    the `Player` class. Now, we need to update two functions: `Player::Player()` and
    `Player::processEvents()`. Notice, that this change imply a modification on the
    `isMoving` and `rotation` attributes that are now private members of the `Player`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we bind the keyboard keys to some callbacks using lambda functions. As
    you can see, we don't need to check the state of the input in the function because
    this has already been done in the `ActionTarget::proccessEvents()` method. The
    callback is called only when the event is satisfied, in this case, when the key
    is pressed. So we can directly set the value because we know that the key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is to be able to change the inputs without any change in the
    callbacks. This will be really interesting to build a custom input configuration
    in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we remove all of the codes that check the inputs states, and
    delegate this to the `ActionTaget::processEvents()` method. The only new thing
    to do is reset the variable that can be changed by the events.
  prefs: []
  type: TYPE_NORMAL
- en: There is no difference in the final result of our application, but now we have
    a good starting point to manage our events, and it simplifies our work.
  prefs: []
  type: TYPE_NORMAL
- en: Event map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined a system to check our event, it would be great to change
    the inputs associated to a functionality at runtime. This will allow us to create
    a system where the user can choose which key/button he wants to associate with
    a specific action. For the moment, we have hardcoded the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will need something that can associate a key with an action.
    This is what the `std::map` and `std::unordered_map` classes do. Because `std::unordered_map`
    is quicker than `std::map` at runtime, we prefer to use it. This class comes from
    the C++ 11.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, we need to associate a key with an action, so we will
    create a new class named `ActionMap` that will contain the association map and
    offer the possibility to add actions at runtime or get one action, thanks to its
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing complex here, we just make a wrapper around the container, and make
    the class in such a way that it cannot be copied with a default empty constructor.
    We also make the class as a template to be able to choose any kind of key type.
    In practice, we will often use an integer, but sometimes, it could be interesting
    to have a string as the key. This is the reason why the template type is `int`
    by default. Now, let''s look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is really simple to understand. We simply forward what we
    want to do to the internal container. Because `std::unordered_map` throws exceptions
    when we try to make an invalid access, for example, we don't need any test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that, because the class is a template, the implementation has to be made
    in the header file. But, in order to not lose readability in the header, there
    is another way; put the code in a `.tpl` file (`tpl` is the short form for template
    word) and include it at the end of the header. By doing this, we separate the
    declaration from the implementation. This is a good practice, and I recommend
    you to apply it. The `.inl` file extension is also common (shortcut for inline
    word) instead of `.tpl`.
  prefs: []
  type: TYPE_NORMAL
- en: If you pay attention, the class is not a static one and can be instantiated.
    This is so that it will allow us to use multiple `ActionMap` class in our project,
    for example, one to store the player inputs, and another to store the system inputs.
    But this approach clashes with our actual `ActionTarget` class, so we need to
    modify it a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Back to action target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since I want to be most generic as possible in the event system, we need to
    modify our `ActionTarget` class a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the `ActionTaget` class needs to be linked to `ActionMap`. This will
    allow us to use multiple `ActionMap` in a single project, and this can be very
    interesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, because the action is now stored in `ActionMap`, `ActionTarget` doesn't
    need to store them anymore, but instead it needs to store the key to get them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, because `ActionMap` is a template class, we will need to turn `ActionTaget`
    into a template class too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new header looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The major change is to turn all the references of the `Action` class to the
    template type. The action will now be identified by its key. Because we need to
    access the `Action` instances at runtime, we need to have a way to reach them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I use the SFML logic: one big object and a frontend class to use it.
    The big object is `ActionMap` and the frontend is `ActionTarget`. So, we internally
    store a reference to `ActionMap` used to store the events, and because we don''t
    need to modify it, we make it as constant.'
  prefs: []
  type: TYPE_NORMAL
- en: All these changes affect our class implementation. Instead of directly accessing
    an `Action` instance, we need to get it by calling `ActionMap::get()`, but nothing
    more difficult than this. The really important changes are made in the `Player`
    class, because now, we have the possibility to change the inputs at runtime, but
    we also need some default inputs, so we need to add a function to initialize the
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a player doesn''t have infinite possible control, we can create `enum`
    that will store all the keys that will be used in the code. For the moment, we
    have only one player, so we can present this function as static. The implication
    is that `ActionMap` internally used has to be static as well. This `ActionMap`
    will be added as a static attribute of the `Player` class. This is the new header
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Player::PlayerInputs` enum, the `Player::setDefaultsInputs()`
    function, and the `Player::_playerInputs` attribute have been added. We also change
    the `ActionMap` type to `ActionMap<int>`, because we will use the newly created
    `enum` as a key; the default type of `enum` is `int`. The implementation of the
    player class does not change, except in the constructor. Instead of directly creating
    an action and binding it, we first initialize `ActionMap` (in `Player::setDefaultsInputs`)
    and then use the key store in `enum` to refer to the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is the new constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we also need to specify the `_playerInputs` parameter of the
    `ActionTarget` constructor, and we change all the `Action` constructions to their
    associated key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we simply initialize the `_playerInputs` with some default keys. These
    keys are similar to the previous ones, but because `_playerInputs` is a static
    member of the `Player` class it has to be created somewhere. A good practice is
    to define it in the `.cpp` file. So the last change in the `Player.cpp` file is
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will create the object as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to initialize `ActionMap` by calling `Player::setDefaultsInputs()`.
    To do this, simply add this call to `main` before the game creation. The main
    should look like this by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The final result doesn't change, but I think that you can understand the power
    of the event system that has been created. It allows us to bind functionalities
    and change the key binding at runtime, this will be really useful in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the actual application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to action target](img/8477OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should also be able to rotate the square using the right and left arrows
    of your keyboard, and make it move by pressing the up arrow. The next step will
    be to turn this stupid square into a nice spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general game development, the term **resource** defines an external component
    that will be loaded at runtime within the application. Most of the time, a resource
    is a multimedia file such as music and image, but it can also be a script or a
    configuration file. Throughout this book, the term resource will mostly refer
    to a multimedia resource.
  prefs: []
  type: TYPE_NORMAL
- en: The resources require more memory, and one of the consequences of this is that
    all the operations on it run slowly, such as the copy. Another thing is that we
    don't want to have the same resource loaded multiple times in the memory. To avoid
    all this, we will use them in a particular way, with the help of a resource manager.
    Most of the time, a resource is loaded from a file to the hard disk, but there
    are other ways to load them, for example, from the memory or the network.
  prefs: []
  type: TYPE_NORMAL
- en: Resources in SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SFML library deals with a great numbers of different resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Graphics module | Audio module |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | SoundBuffer |'
  prefs: []
  type: TYPE_TB
- en: '| Image | Music |'
  prefs: []
  type: TYPE_TB
- en: '| Font |   |'
  prefs: []
  type: TYPE_TB
- en: '| Shader |   |'
  prefs: []
  type: TYPE_TB
- en: 'All of these resources have some common points. Firstly, we can''t use them
    directly as an output to the screen or the speakers. We have to use a frontend
    class that doesn''t hold the data, but instead holds a reference to it. One of
    the implications is that the coping objects are quicker. Secondly, all these resource
    classes share the same SFML API (Application Programming Interface) with some
    deviations sometimes. A typical example is loading the resources from the hard
    disk, which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the complete path (relative or absolute) of the file to
    load, and returns `true` if the loading is successful and `false` if there is
    an error. It's very important to check the returned value to deal with the possible
    error, most of the time, an invalid path.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other versions of this type of member function that allows us to
    load the resource from different kinds of media. The function `bool loadFromMemory(const
    void *data, std::size_t size);` allows the user to load the resource from a RAM.
    A typical use of this function is to load the resource from hardcoded data. The
    other option with the SFML is to load the resource from a custom stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This allows the user to fully define the load process. It can be used to load
    the data from a compressed or encrypted file, from the network, or from whatever
    device you want. But for now, we will focus on the file way (`loadFromFile()`)
    to design our future resources manager. Before starting to create it, take a look
    at each SFML resource class.
  prefs: []
  type: TYPE_NORMAL
- en: The texture class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sf::Texture` class represents an image as a pixel array. Each pixel is
    an **RGBA** (**red, green, blue, alpha**) value that defines the color at a specific
    position of the image. This pixel array is stored on the graphic card, in the
    video memory so it does not use any RAM. Because `sf::Texture` is stored in the
    video memory, the graphic card can access it quickly for each draw, but `sf::Texture`
    can''t be manipulated (changed) as freely as `sf::Image` can. Every time we want
    to change it, we will need to reupload it on the video memory using the `sf::Texture::upload()`
    function. These operations are quite slow, so be careful when you use them. There
    are several common image formats sported by the SFML: `.bmp`, `.png`, `.tga`,
    `.jpg`, `.gif`, `.psd`, `.hdr`, and `.pic`. Notice that the `.png` images can
    be transparent, and can have an alpha channel to smooth edges again a transparent
    background.'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend class used to display `sf::Texture` is `sf::Sprite`. It's the texture
    representation with its own transformation, colors, and position. An important
    thing is that `sf::Texture` must be alive as long as `sf::Sprite` that used it
    is alive in order to avoid undefined behaviors. This is because `sf::Sprite` doesn't
    copy the texture data, but instead keeps a reference of it.
  prefs: []
  type: TYPE_NORMAL
- en: The image class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sf::Image` class behaves as the `sf::Texture` class but with some important
    differences due to its storage. The pixel array is stored in the RAM instead of
    the graphic card. The implications are multiple. The first implication is that
    it''s possible to modify each pixel of the image without any transfer. The second
    is that it''s possible to save the image back to a file placed on the hard drive.
    The last is that it''s not possible to directly display an image on the screen.
    We need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, convert it to `sf::Texture`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create `sf::Sprite` referring to the texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, display this sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if the entire image is not required for the display, it's possible to use
    only a part of it. So there is no waste of memory on the graphic card. The supported
    file formats are exactly the same for `sf::Texture` and `sf::Image`.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to limit the use of `sf::Image` only when you really need it,
    for example, to modify a loaded image at runtime, to access any of its pixels,
    or to split it into multiple `sf::Texture` classes. In other cases, it's advisable
    to directly use `sf::Texture` for performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: The font class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sf::Font` class allows us to load and manipulate character fonts. Most
    of the common types of fonts are supported such as `TrueType`, `Type 1`, `CFF`,
    `OpenType`, `SFNT`, `X11 PCF`, `Windows FNT`, `BDF`, `PFR`, and `Type 42`. The
    `sf::Font` class holds the data, but it's not possible to use it directly. You
    will need to use the frontend class `sf::Text`, like `sf::Sprite` for `sf::Texture`.
    This class has some properties such as the font size, color, position, rotation,
    and so on. The `sf::Font` class must remain accessible as long as all of `sf::Text`
    that refer to it are alive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In SFML 2.1, there is no default font for `sf::Text`, so you need at least one
    font file to display them in your application. The default system font will not
    be used at all. Moreover, `sf:Text` is actually an object that inherits from `sf::Drawable`,
    and is physically represented by an OpenGL texture. You have to pay attention
    to the fact that updating the text every frame has a processing cost, and text
    needs to be updated only when it's changed.
  prefs: []
  type: TYPE_NORMAL
- en: The shader class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A shader is a program that will be executed directly on the graphic card, that
    is written in a specific language, GLSL, which is very similar to the C. There
    are two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragment shaders**: This modifies the geometry of an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel shaders**: This modifies the pixel''s value of the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders are really powerful, and allow us to apply some real-time manipulations
    on our scene, such as light. To use them, you only need to specify it on the `RenderTarget.draw(sf::drawable&,
    sf::shader)` function.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you read the entire description of `sf::Shader` in the documentation
    before starting to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The sound buffer class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sf::SoundBuffer` class is used to store a sound effect. This class is especially
    designed to hold the entire audio sample in the memory as an array of 16 bits
    signed integers. Use it for short audio samples that require no latency and that
    can fit in the memory, for example, foot steps or gun shots.
  prefs: []
  type: TYPE_NORMAL
- en: Many audio formats are supported, such as `.ogg`, `.wav`, `.flac`, `.aiff`,
    `.au`, `.raw`, `.paf`, `.svx`, `.nist`, `.voc`, `.ircam`, `.w64`, `.mat4`, `.mat5
    pvf`, `.htk`, `.sds`, `.avr`, `.sd2`, `.caf`, `.wve`, `.mpc2k`, and `.rf64`. Notice
    that the `.mp3` format is not supported because of its restrictive license.
  prefs: []
  type: TYPE_NORMAL
- en: Like `sf::Texture`, `sf::SoundBuffer` holds data, but does not allow us to play
    it directly. We need to use the `sf::Sound` class to do this. The `sf::Sound`
    class provides some common functionalities, such as play, stop, and pause but
    we can also change its volume, pitch, and position. A `sf::Sound` class refers
    to `ssf::SoundBuffer` that must stay valid as long as `sf::Sound` is played.
  prefs: []
  type: TYPE_NORMAL
- en: The music class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sf::Music` class is the class used to play music. Unlike `sf::SoundBuffer`
    that is appropriate for short effects, `sf::Music` is designed to deal with long
    music themes. Themes are generally much longer than effects, and need a lot of
    memory to hold them completely. To overcome this, `sf::Music` does not load the
    entire resource at once, but, instead, streams it. This is really useful for large
    music files that take hundreds of MBs to avoid saturating the memory. Moreover,
    `sf::Music` has almost no loading delay.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other resources, `sf::Music` does not have any lightweight class. You
    can directly use it. It allows us to use the same features as `sf::SoundBuffer`
    and `sf::Sound` paired, such as play, pause, stop, request its parameters (channels
    and sample rate), and change the way it is played (pitch, volume, and 3D position).
  prefs: []
  type: TYPE_NORMAL
- en: As a sound stream, a music file is played in its own thread in order to not
    block the rest of the program. This means that you can leave the music file alone
    after calling `play()`, it will manage itself very well.
  prefs: []
  type: TYPE_NORMAL
- en: Use case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, I''ve explained that we will turn the blue square
    into a nice space ship. It''s time to do that. Here is the result that will be
    obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case](img/8477OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's not a big change, but it's a starting point for our future game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to turn `sf::RectangleShape` that represents the `Player`
    class into `sf::Sprite`. We will also change the `_shape` attribute name into
    `_ship`; but there is an issue: where is the texture used to store the ship image?
    To make an attribute of the player of it can be a solution because there is only
    one player, but we will use another approach: a resources manager.'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to create the manager, let's talk about the **Resource Acquisition
    Is Initialization** (**RAII**) idiom.
  prefs: []
  type: TYPE_NORMAL
- en: RAII idiom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RAII is a principle in which a resource is acquired and released with a class
    construction and destruction, because these two functions are automatically called.
    It has the advantage over the manual management to be executed every time, even
    when some exceptions occur. It's used with the smart pointer classes in the C++11,
    and can be performed with every type of resource such as files, or in our case,
    SFML resources.
  prefs: []
  type: TYPE_NORMAL
- en: Building a resources manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of a resources manager is to manage the resources and ensure that all
    the resources are loaded only once to avoid any more copies.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, we focus on the resources loaded from the hard drive,
    so a good way to avoid any duplication is to use an identifier for the resource.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `std::unordered_map` again, and build a wrapper around it, as the
    `ActionMap` class. Because SFML provides a lot of different types of resources,
    and I don't want to make one for each of them, I will build the resources manager
    as a template class again. But this time, the template type will be the resource
    and the key type. We will use the RAII idiom to automate the load and release
    the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We make the class in such a manner that it cannot be copied, and create some
    functions to load a resource, and another one to get it. Because all the SFML
    resource classes don't have the exact same parameters for the `loadFromFile()`
    function (`sf::Shader`), I decided to use a template that will forward the arguments
    exactly as `Player::setPosition()`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, some classes cannot be copied, so we need to use a pointer to store
    them in a container. Because of the RAII idiom, the choice has been made to use
    the `std::unique_ptr` template class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new class from the C++11 is `std::unique_ptr` and it is one of the smart pointers.
    Its internals use the RAII idiom, so we don't need to manage the memory deallocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A feature from the C++11 is `std::move` and it allows us to use the `move` constructor
    instead of the `copy` constructor. The `std::unique_ptr` template class supports
    the type of constructor, so using it seems to be a good idea. The idea under the
    move semantic is to dump a temporary object by taking its content instead of copying
    it. The result is a gain in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a new resource using the template parameter `RESOURCE` as `std::unique_ptr`.
    Then we load the resource from the hard drive using the parameter pack `args`.
    Finally, we store it internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that if the load fails, an exception is thrown rather than returning
    `false` as value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This function simply delegates the job to the `std::unordered_map::at()` function
    by passing the `id` argument to it. The `::at()` method throws an exception when
    no object is found.
  prefs: []
  type: TYPE_NORMAL
- en: Because our actual `ResourceManager` class uses `loadFromFile()` in the `load()`
    method, we have a problem with the `sf::Music` class. `LoadFromFile()`, which
    doesn't exist in the `sf::Music` class and is replaced with `openFromFile()`.
    So we need to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will use the `partial` specialization. The partial specialization
    is a technical used in template programming to make some special case, exactly
    like this one. We need to specialize the `load()` method when `RESOURCE` is set
    to `sf::Music`. The problem is that we can''t do it directly because the `ResourceManager`
    class has two template parameters, and the other one doesn''t need to be fixed.
    So instead, we have to specialize the entire class by creating a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is the replica of the previous one, except that we have removed
    one template parameter to fix it to `sf::Music`. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here again, this is exactly the same, except that we have changed `loadFromFile()`
    to `openFromFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one class with a specialization has been constructed to deal with all
    the SFML resources types, and use the RAII idiom to free memory when required.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to use this class to change the appearance of the player.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the player's skin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have built a nice system to manage any kind of resource, let's use
    them. As previously mentioned, to change the player's square into a ship, we need
    to change `sf::RectangleShapethat`, represent the `Player` class in `sf::Sprite`,
    and then set the texture source of `sf::Sprite` loaded by the texture manager.
    So we need a texture manager.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about it, all the managers will be global to our application, so
    we will group them into a static class named `Configuration`. This class will
    hold all the game configurations and the managers. `ActionMap` can also be stored
    inside this class, so we will move `ActionMap` inside the player into this new
    class, and create an `initialize()` method to initialize all the inputs and textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is really simple, and can''t be instantiated, so all the attributes
    and methods will be static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the class is not really difficult. We only move the `_playerInputs`
    and `enum` from the `Player` class and add `ResourceManager` for textures. Here
    is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here again, the code is simple. We now have just a few changes to make in the
    player class to draw it as a spaceship. We need to replace `sf::RectangleShape
    _shape` with `sf::Sprite _ship;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, we need to set the texture and the origin of the sprite
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to call `Configuration::initialize()` from `main()` before anything
    else. We now have a nice spaceship as a player.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of code and different classes to get this result, but if you
    think about it, this will really help us in the future, and reduce the number
    of code lines in our final applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the general game architecture, the input management,
    and the resources. You also learned about the RAII idiom and some C++11 features
    such as lambda, variadic templates, smart pointers, move syntax, and perfect forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: All the basic building blocks are now set up, so in the next chapter, we will
    make complete games by completing the current application to raise it to the asteroid
    game, and we will also build a Tetris game.
  prefs: []
  type: TYPE_NORMAL
