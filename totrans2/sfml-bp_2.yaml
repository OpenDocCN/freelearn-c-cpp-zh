- en: Chapter 2. General Game Architecture, User Inputs, and Resource Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.通用游戏架构、用户输入和资源管理
- en: 'Now that the boring part is over, let''s start working with SFML. In this chapter,
    we are not yet going to build a complete game, but instead we''ll learn some basic
    skills that are required to build a game. These are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无聊的部分已经结束，让我们开始使用 SFML。在本章中，我们不会构建一个完整的游戏，而是学习构建游戏所需的一些基本技能。这些技能如下：
- en: Understanding a basic game architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本游戏架构
- en: Managing user inputs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户输入
- en: Keeping a track of external resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪外部资源
- en: All of these points are really important for any kind of game. But what do these
    points exactly mean? This is what I will explain to you in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点对于任何类型的游戏都至关重要。但这些点具体意味着什么呢？这就是我在本章中要向您解释的内容。
- en: General structure of a game
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏的一般结构
- en: 'Before starting to build randomly and without any specific planning, we need
    to have some information: what kind of game you want to build (RPG, FPS, or action-adventure),
    what elements will be used, and so on. The aim of this chapter is to understand
    the general game structure, which can be used in any kind of game. Through this
    part, we will study:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始无计划地随机构建之前，我们需要一些信息：你想要构建什么类型的游戏（RPG、FPS 或动作冒险），将使用哪些元素，等等。本章的目的是理解通用游戏结构，这可以用于任何类型的游戏。通过这部分，我们将研究：
- en: The game class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏类
- en: The frame rate
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧率
- en: The player class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家类
- en: Event management
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件管理
- en: The game class
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏类
- en: 'In the previous chapter, we have seen the minimal code required for a game,
    which contains:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了构建游戏所需的最小代码，它包含：
- en: Window creation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口
- en: Creation of graphic display
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图形显示
- en: Handle user inputs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Deal with the user inputs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Display game objects on the screen
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示游戏对象
- en: 'Instead of having one function do all the work, we will make use of object-oriented
    practices and define various states in different functions. Moreover, we will
    encapsulate the methods in a new class named `Game`, and we will minimize the
    `main` function. This `Game` class will be the starting point for all our future
    games:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让一个函数完成所有工作，我们将利用面向对象实践，并在不同的函数中定义各种状态。此外，我们将方法封装在一个名为 `Game` 的新类中，并最小化 `main`
    函数。这个 `Game` 类将成为我们所有未来游戏的起点：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`= delete` is a C++11 feature that allows us to explicitly delete a special
    member function such as constructor, move constructor, copy constructor, copy-assignment
    operator, move copy-assignment operator, and destructor. It tells to the compiler
    to not build the default function. In this particular case, it makes the class
    noncopyable. Another solution would be to extend the class from `sf::NonCopyable`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`= delete` 是 C++11 中的一个特性，允许我们显式地删除特殊成员函数，如构造函数、移动构造函数、拷贝构造函数、拷贝赋值运算符、移动拷贝赋值运算符和析构函数。它告诉编译器不要构建默认函数。在这种情况下，它使得类不可拷贝。另一种解决方案是从
    `sf::NonCopyable` 继承类。'
- en: '`= default` is also possible to explicitly tell the compiler to build the default
    version of this member function. It could, for example, be used to define a custom
    constructor and a default constructor.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`= default` 也可以显式地告诉编译器构建这个成员函数的默认版本。例如，它可以用来定义自定义构造函数和默认构造函数。'
- en: Now we have the basic `Game` class structured, in which the functions are separated
    based on their features. Moreover, there is no loop anymore in the main function
    because we will be present in the `Game::run()` function. Now, we simply have
    to call the `Game::run()` function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的 `Game` 类结构，其中函数根据其功能进行分离。此外，主函数中不再有循环，因为我们将在 `Game::run()` 函数中存在。现在，我们只需调用
    `Game::run()` 函数。
- en: 'We can now move all the codes from the main function into the functions—`processEvents()`,
    `update()`, or `render()`—depending on what we are trying to achieve:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有代码从主函数移动到函数中——`processEvents()`、`update()` 或 `render()`——取决于我们想要实现什么：
- en: '`processEvents()`: This will manage all events from the user'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processEvents()`: 这将管理所有来自用户的事件'
- en: '`update()`: This will update the entire game'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 这将更新整个游戏'
- en: '`render()`: This will manage all the rendering of the game'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`: 这将管理游戏的所有渲染'
- en: All the future features will also be put into one of these private functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未来的功能也将被放入这些私有函数之一。
- en: 'Now, let''s have a look at the implementation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现方式：
- en: 'The constructor initializes the window and the player:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化窗口和玩家：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Game::run()` method hides the main `game` loop:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game::run()` 方法隐藏主 `game` 循环：'
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Game::processEvents()` method handles user inputs. It simply polls all
    the events received from the window since the last frame, such as a button in
    the window title bar or a keyboard key being pressed. In the following code, we
    check for the user pressing the window''s close button and the keyboard''s Esc
    key. In response, we close the window:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game::processEvents()` 方法处理用户输入。它简单地轮询自上一帧以来从窗口接收到的所有事件，例如窗口标题栏中的按钮或按下的键盘键。在下面的代码中，我们检查用户是否按下了窗口的关闭按钮和键盘的
    Esc 键。作为回应，我们关闭窗口：'
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `update()` method updates our game logic. For the moment, we don''t have
    any logic, but in the near future we will see how to modify the logic of our game:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update()` 方法更新我们的游戏逻辑。目前，我们还没有任何逻辑，但不久的将来，我们将看到如何修改我们游戏中的逻辑：'
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Game::render()` method renders the game to the screen. First, we clear
    the window with a color, usually `sf::Color::Black`, which is the default, then
    we render our object for the frame, and finally, we display it on the screen:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game::render()` 方法将游戏渲染到屏幕上。首先，我们使用颜色清除窗口，通常是 `sf::Color::Black`，这是默认颜色，然后我们渲染帧的对象，最后，我们在屏幕上显示它：'
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Downloading the color images of this book**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载本书的颜色图像**'
- en: We also provide you with a PDF file that has color images of the screenshots/diagrams
    used in this book. The color images will help you better understand the changes
    in the output. You can download this file from [https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf](https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为您提供了一个包含本书中使用的截图/图表的颜色图像的 PDF 文件。这些颜色图像将帮助您更好地理解输出的变化。您可以从 [https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf](https://www.packtpub.com/sites/default/files/downloads/B03963_8477OS_Graphics.pdf)
    下载此文件。
- en: 'There is no change on the final render of the scene, compared to the minimal
    example of the previous chapter, except the title and the size. Even if there
    is more code, the application is easier to maintain with the new architecture
    because the functions have been reduced to the minimal, and it''s easier for you
    to find what you want:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的最小示例相比，场景的最终渲染没有变化，除了标题和大小。即使代码更多，由于函数已被简化到最小，使用新的架构维护应用程序更容易，因为更容易找到你想要的内容：
- en: '![The game class](img/8477OS_02_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![游戏类](img/8477OS_02_01.jpg)'
- en: Game loops
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Now that the `Game` class has been introduced, let's talk about the loop inside
    the `Game::run()` function. This loop is called the `game` loop or `main` loop.
    It runs continuously during game play and performs several actions at each turn
    of the loop. Each iteration of this loop is called a frame. The term **frames
    per second** (**FPS**) is a measure that determines the number of iterations made
    by the game in 1 second. I will come back to this point later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了 `Game` 类，让我们来谈谈 `Game::run()` 函数内部的循环。这个循环被称为 `game` 循环或 `main` 循环。在游戏过程中持续运行，并在每次循环迭代中执行多个操作。这个循环的每次迭代被称为一帧。术语
    **每秒帧数** （**FPS**） 是一个衡量指标，用于确定游戏在 1 秒内完成的迭代次数。我稍后会回到这个话题。
- en: What you do inside this loop is quite simple. Firstly, we process the events.
    Then we update the games states. Finally, we render the game to the screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环内部的操作相当简单。首先，我们处理事件。然后，我们更新游戏状态。最后，我们将游戏渲染到屏幕上。
- en: 'As you might have noticed, this sounds a lot like the `run` method of the `Game`
    class. To explain more visually, this loop is a flowchart representing the logic:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，这听起来很像 `Game` 类的 `run` 方法。为了更直观地解释，这个循环是一个表示逻辑的流程图：
- en: '![Game loops](img/8477OS_02_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环](img/8477OS_02_02.jpg)'
- en: For the moment, the loop is reduced to the minimum. For example, we don't detail
    the `Game::processEvents()` method in depth here. For the moment, the game loop
    has been kept simple, so you can learn the basics first. Later, we will be getting
    back to each of the methods in the `Game::run()` method, such as the `Game::processEvents()`
    method, and adding more complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，循环被简化到最小。例如，我们在这里不深入详细说明 `Game::processEvents()` 方法。目前，游戏循环被保持简单，这样你可以先学习基础知识。稍后，我们将回到
    `Game::run()` 方法中的每个方法，例如 `Game::processEvents()` 方法，并增加更多的复杂性。
- en: The frame rate
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧率
- en: We are now coming back to the frames. As I have already said, a frame is a complete
    iteration of the `game` loop. The final result is the new `game` states that can
    be displayed on the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回到帧上。正如我之前所说的，帧是 `game` 循环的完整迭代。最终结果是可以在屏幕上显示的新 `game` 状态。
- en: Humans are unable to see unlimited number of images per second. There is some
    interpolation between each image that we perceive with our brain. The result is
    that we don't need to display a great amount of images each second. But the more
    images displayed, the greater will the quality of the final result be. For example,
    at the cinema, only 24 images are displayed per second.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 人类每秒无法看到无限数量的图像。我们的大脑在感知到的每一张图像之间进行一些插值。结果是，我们不需要每秒显示大量的图像。但是显示的图像越多，最终结果的质量就越高。例如，在电影院，每秒只显示24张图像。
- en: In video games, most of the time, we try to make a loop as quick as we can.
    The number of images displayed reaches 30 to 60 per second. Below 30 FPS, there
    can be a lag effect which can be due to the game, and we need to handle it to
    avoid problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，大多数时候，我们试图使循环尽可能快。每秒显示的图像数量达到30到60。低于30 FPS时，可能会有延迟效应，这可能是由游戏引起的，我们需要处理它以避免问题。
- en: 'One of the most common problems caused by the lag effect is the displacement
    of the entities. Most of the time, each entity has its own speed and direction.
    The speed is often measured in pixels per second. Now imagine your game, for any
    reason, has some lag and the FPS dropped to a small number like 5, then the graphical
    effect is that all your entities will teleport themselves. But this is not the
    main issue. The big issue is with the collisions. Take an example of an entity
    that was walking in the direction of a wall when the lag happens, the entity will
    literally cross over the wall. Here is a figure that represents the problem:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由延迟效应引起的最常见问题之一是实体的位移。大多数情况下，每个实体都有自己的速度和方向。速度通常以每秒像素数来衡量。现在想象一下你的游戏，由于任何原因，有一些延迟，FPS下降到像5这样的小数字，那么图形效果就是所有的实体都会瞬间移动。但这不是主要问题。主要问题是碰撞。以一个在延迟发生时向墙壁方向行走的实体为例，该实体将实际上穿过墙壁。以下是表示该问题的图示：
- en: '![The frame rate](img/8477OS_02_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![帧率](img/8477OS_02_03.jpg)'
- en: To fix this problem, there are three different approaches. The first is called
    variable time steps, second is fixed time steps, and third that mix them together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有三种不同的方法。第一种是可变步长，第二种是固定步长，第三种是将它们混合在一起。
- en: Fixed time steps
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 固定步长
- en: The fixed time steps approach, as its name suggests, is an approach where each
    call to the `Game::update()` function is made with the same time interval. The
    units used, for example, for the movement are relative to the frame. Because each
    frame is separate from the others of the same time, we don't need more complexity.
    The only thing we need to pay attention to is to choose the basic values to be
    sure that there are no problems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 固定步长方法，正如其名所示，是一种每次调用 `Game::update()` 函数都使用相同时间间隔的方法。例如，用于移动的单位相对于帧。因为每个帧与其他相同时间的帧是分开的，所以我们不需要更多的复杂性。我们唯一需要关注的是选择基本值，以确保没有问题。
- en: 'Here is the new flowchart of the `game` loop:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `game` 循环的新流程图：
- en: '![Fixed time steps](img/8477OS_02_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![固定步长](img/8477OS_02_04.jpg)'
- en: 'Now we will implement the new `Game` class in the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在以下代码片段中实现新的 `Game` 类：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code ensures that each call to the `Game::update()` function will always
    take the same time as the parameter value. There no big difference with the previous
    version of the code. Here we just keep track of the time since the last call of
    the `Game::update()` function, and then we only call it again, when the time exceeds
    the frame rate. The code could be improved by sleeping with `sf::sleep` the remainder
    of the free time in the loop. It's a bit more difficult (because needs to measure
    the time spent in the previous update+render), but won't waste CPU time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确保每次调用 `Game::update()` 函数时都会花费与参数值相同的时间。与代码的先前版本没有太大区别。我们只是在 `Game::update()`
    函数的最后一次调用后跟踪时间，然后只有在时间超过帧率时才再次调用它。可以通过在循环中暂停 `sf::sleep` 剩余的自由时间来改进代码。这有点困难（因为需要测量前一个更新+渲染所花费的时间），但不会浪费CPU时间。
- en: 'A little change has been made on the `Game::update()` function by adding a
    parameter to it. Its new signature is now:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Game::update()` 函数上做了一点小的改动，给它添加了一个参数。它的新签名现在是：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This parameter allows us to know the time elapsed since the last call of `Game::update()`.
    Currently, there is no great interest in it, but later there will be.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数使我们能够知道自上次调用`Game::update()`以来经过的时间。目前，对此没有太大兴趣，但以后会有。
- en: Because the state of the game is changed only when `Game::update()` is called,
    the call to `Game::render()` is made when at least an update is made.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏状态仅在调用`Game::update()`时改变，因此当至少进行一次更新时，才会调用`Game::render()`。
- en: Variable time steps
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变时间步长
- en: The variable time steps approach is different from fixed time steps, as the
    name suggests. The main idea here is to execute the `game` loop as quickly as
    we can, without any delay. This allows the game to be more reactive. The units
    here have to be like units per time (mostly, time refers to one second here).
    Because we cannot predict how many times the loop will run, we will make it a
    parameter in the `Game::update()` function, and multiply it with the base unit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可变时间步长方法与固定时间步长方法不同，正如其名称所暗示的。这里的主要思想是尽可能快地执行`game`循环，没有任何延迟。这使得游戏更加反应灵敏。这里的单位必须是每时间单位（大多数情况下，时间指的是一秒）。因为我们无法预测循环将运行多少次，所以我们将它作为`Game::update()`函数中的一个参数，并将其与基本单位相乘。
- en: 'Our actual implementation of the `game` loop corresponds to the variable time
    steps approach; we just need to add a system to keep a track of the elapsed time
    since the last loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`game`循环的实际实现对应于可变时间步长方法；我们只需要添加一个系统来跟踪自上次循环以来经过的时间：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The only thing new here is `sf::Clock` and the parameter to the `Game::update()`
    method. But there is still a problem with this approach: when the game is too
    slow (the time between two steps is important).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新事物是`sf::Clock`和传递给`Game::update()`方法的参数。但这种方法仍然存在问题：当游戏运行得太慢（两个步骤之间的时间很重要）时。
- en: Minimum time steps
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最小时间步长
- en: 'There is another solution, wherein the last two approaches are merged. The
    idea is to run the game as quickly as possible by ensuring the time parameter
    passed in the `Game::update()` method is not too high. The consequence is that
    we ensure to have a minimal frame rate, but no maximal. To sum up, we want two
    things:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一种解决方案，即合并最后两种方法。想法是通过确保传递给`Game::update()`方法的时间参数不是太高，尽可能快地运行游戏。结果是，我们确保帧率最小，但没有最大值。总之，我们想要两件事：
- en: To allow the game to run as quickly as possible
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让游戏尽可能快地运行
- en: If, for any reason, the time between the two loops becomes higher than, let's
    say, 30 FPS, we split this time as much as needed to ensure that the delta time
    pass to the `Game::update()` function is not higher than 30 FPS.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于任何原因，两个循环之间的时间超过，比如说，30 FPS，我们将根据需要分割这段时间，以确保传递给`Game::update()`函数的delta时间不超过30
    FPS。
- en: 'Here is the flowchart representing this solution:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是表示此解决方案的流程图：
- en: '![Minimum time steps](img/8477OS_02_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![最小时间步长](img/8477OS_02_05.jpg)'
- en: 'Now we will implement the new `run` function in the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在以下代码片段中实现新的`run`函数：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On each frame, the `Game::update()` and `Game::render()` methods are called,
    but when the delta time between two frames is more important than what we want,
    the `Game::update()` method is called with the maximum value allowed, as many
    times as necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧上，都会调用`Game::update()`和`Game::render()`方法，但当两帧之间的时间差比我们想要的更重要时，`Game::update()`方法会以允许的最大值调用，所需次数。
- en: All these approaches have their strong points and their weak points. Depending
    on circumstances, one approach will be better than another. But from now on, we
    will use the minimum time steps approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都有其优点和缺点。根据具体情况，一种方法可能比另一种方法更好。但从现在开始，我们将使用最小时间步长方法。
- en: 'All these solutions are not well adapted to use a physics engine. We will return
    to this particular point in [Chapter 4](ch04.html "Chapter 4. Playing with Physics"),
    *Playing with Physics*. But knowing that it will take two loops: one for the physics
    and another one for the game logic. Each of these loops can have a frame rate
    different from each other.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解决方案都不太适合使用物理引擎。我们将在[第4章](ch04.html "第4章。玩转物理") *玩转物理*中回到这个特定点。但要知道它将需要两个循环：一个用于物理，另一个用于游戏逻辑。每个循环都可以有不同的帧率。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other approaches to manage the frame rate of an application. One of
    the most common is the `sleep()` function, which interrupts the application during
    a specified time and gives the processor the opportunity to work on other tasks.
    But this is not a good solution in games and all kinds of applications that need
    exact timing. SFML provides us with a `sf::RenderWindow::setFramerateLimit()`
    function that tries to fix the frame rate of the running application by calling
    `sf::sleep()` internally. This is a good solution, but for testing only.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 管理应用程序帧率的方法还有很多。其中最常见的是 `sleep()` 函数，它在指定时间内中断应用程序，并给处理器机会去处理其他任务。但这对游戏和所有需要精确时间调度的应用程序来说不是一个好的解决方案。SFML为我们提供了一个
    `sf::RenderWindow::setFramerateLimit()` 函数，它通过内部调用 `sf::sleep()` 来尝试固定运行应用程序的帧率。这是一个好的解决方案，但仅适用于测试。
- en: Another solution is to use the vertical synchronization by calling `void sf::Window::setVerticalSyncEnabled(bool)`.
    It will limit the number of frames displayed to the refresh rate of the monitor
    (most of the time 60 Hz, but there is no guarantee). It helps in avoiding some
    visual artefacts, and limits the frame rate to a good value (but not constant
    across different computers). V-Sync can occasionally lock too low on some systems.
    This is why in full production games it can be turned on and off.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用通过调用 `void sf::Window::setVerticalSyncEnabled(bool)` 的垂直同步。它将限制显示的帧数以匹配显示器的刷新率（大多数情况下是
    60 Hz，但无法保证）。这有助于避免一些视觉伪影，并将帧率限制在一个良好的值（但不是在不同计算机上恒定）。V-Sync有时在某些系统上锁定得太低。这就是为什么在完整生产游戏中，它可以被打开和关闭。
- en: Move our player
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动我们的玩家
- en: Now that we have a clean `game` loop, let's move our `Player` object. For now,
    let's move it forward and make it turn right and left. We will make it in a way
    that will not depend on the frame rate. First, let's consider the player.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个干净的 `game` 循环，让我们移动我们的 `Player` 对象。目前，让我们向前移动它，并让它向右和向左转。我们将以不依赖于帧率的方式来实现它。首先，让我们考虑玩家。
- en: The player class
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家类
- en: '`Player` is a really important class in any kind of game, and changes a lot
    with the type of game. Here our goal is just to be able to move and rotate it.
    So the information required is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 是任何类型游戏中非常重要的一个类，并且随着游戏类型的改变而有很多变化。我们的目标只是能够移动和旋转它。所以所需的信息如下：'
- en: Its shape, size, and color
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的形状、大小和颜色
- en: Its direction
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的方向
- en: Its speed
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的速度
- en: 'Let''s change the `Player` shape to a square using the SFML class `sf::RectangleShape`.
    The direction and the speed can be merged into a single object: a mathematical
    vector (we will speak about this in the next section). SFML provides a nice class
    for this: `sf::Vector2f`. We will also need to add speed and rotation and set
    the position of the player, but we will also update it and finally display it
    on the screen.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 SFML 类 `sf::RectangleShape` 将 `Player` 形状更改为正方形。方向和速度可以合并成一个单一的对象：一个数学向量（我们将在下一节中讨论这个）。SFML提供了一个很好的类来处理这个：`sf::Vector2f`。我们还需要添加速度和旋转，并设置玩家的位置，但我们还将更新它，最后在屏幕上显示它。
- en: 'Finally, we obtain this class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到这个类：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As mentioned, the player needs to be displayed on the screen, so we extend
    it from `sf::Drawable`. This class simply adds the `draw()` virtual method to
    the class that we need to override. To be sure that we override it, we use the
    new keyword of C++11: `override`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，玩家需要在屏幕上显示，所以我们从 `sf::Drawable` 扩展它。这个类简单地给我们需要重写的类添加了 `draw()` 虚拟方法。为了确保我们重写了它，我们使用了
    C++11 的新关键字：`override`。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using override, we are sure that we make an override and not an overload. This
    is a new keyword from C++11.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `override`，我们确保我们进行的是重写而不是重载。这是 C++11 中的一个新关键字。
- en: Moreover, as in the `Game` class, we make the player non-copyable by explicitly
    deleting the default implementation of methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像在 `Game` 类中一样，我们通过显式删除方法的默认实现来使玩家不可复制。
- en: 'Now, let''s speak about the `Player::setPosition()` method. As you can see,
    its signature is really strange. Here, I use another C++11 feature: the `variadic`
    template. As you know, `sf::Transformable` has two versions of the `setPosition()`
    method. The first one takes two float numbers, and the second takes `sf::Vector2f`
    as the parameter. Because I don''t want to build the two versions, I use a new
    possibility of C++. I simply forward the arguments to `sf::Transformable::setPosition()`
    without knowing them. By using this, we can use both of the `sf::Transformable::setPosition()`
    functions.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈 `Player::setPosition()` 方法。正如你所见，它的签名非常奇怪。在这里，我使用了 C++11 的另一个特性：可变模板。正如你所知，`sf::Transformable`
    有两个版本的 `setPosition()` 方法。第一个接受两个浮点数，第二个接受 `sf::Vector2f` 作为参数。由于我不想构建两个版本，我使用了
    C++ 的新特性。我只是将参数前向传递给 `sf::Transformable::setPosition()` 而不知道它们。通过这种方式，我们可以使用 `sf::Transformable::setPosition()`
    的两个函数。
- en: 'First, we declare the parameter type of the function as the following template:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将函数的参数类型声明为以下模板：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, we also want to have a variable number of parameters, so we use the
    ellipse operator. The result is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还想有一个可变数量的参数，所以我们使用椭圆操作符。结果如下：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since we don''t want to fix the type of parameter (constant, left-reference,
    or right-reference), we use another feature of C++11: the right value reference
    or, in this context, the forwarding/universal reference. This allows us to catch
    any kind of type by simply adding `&&`. The final signature of the function now
    is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想固定参数的类型（常量、左引用或右引用），我们使用了 C++11 的另一个特性：右值引用，或者在这个上下文中，是前向/通用引用。这允许我们通过简单地添加
    `&&` 来捕获任何类型的值。函数的最终签名现在如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to perfectly forward the parameters to `sf::Transformable::setPosition()`,
    we simply need to unpack the arguments pack using the ellipse operator and call
    `std::forward` on each of them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完美地前向传递参数到 `sf::Transformable::setPosition()`，我们只需使用椭圆操作符解包参数包，并对每个参数调用
    `std::forward`：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it! We can now use any of the `sf::Transformable::setPosition()` methods.
    This approach is really powerful to make some generic code, so try to understand
    it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以使用 `sf::Transformable::setPosition()` 的任何方法。这种方法在创建通用代码时非常强大，所以请尽量理解它。
- en: 'The `Player` class also has two public attributes: `isMoving` and `rotation`.
    These attributes will simply store the inputs'' states.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 类还有两个公共属性：`isMoving` 和 `rotation`。这些属性将简单地存储输入的状态。'
- en: 'Now take a look to the implementation of the functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看函数的实现：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we just change the `_shape` constructor to fit with the `sf::RectangeShape`
    constructor, and center the origin of the shape to its gravity center:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将 `_shape` 构造函数更改为与 `sf::RectangleShape` 构造函数兼容，并将形状的原点中心对准其重力中心：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the important part. This function updates our player in the following
    manner:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是重要的部分。这个函数以以下方式更新我们的玩家：
- en: First we rotate it if necessary.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果需要，我们旋转它。
- en: Then, if the player is moving, we simply get the angle of rotation of the shape
    to know its direction, and then to its existing velocity, we add some speed depending
    on its direction. Notice that for the moment we don't clamp the maximal speed.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果玩家正在移动，我们简单地获取形状的旋转角度以了解其方向，然后将其现有速度加上一些根据其方向的速度。注意，目前我们还没有限制最大速度。
- en: To finish, we just have to move it; this is incredibly easy. We simply need
    to call the `move` method on `shape` with `velocity` as the parameter.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们只需移动它；这非常简单。我们只需在 `shape` 上调用 `move` 方法，并将 `velocity` 作为参数。
- en: 'Because each frame is not executed in the same time, we need to multiply all
    the values (rotation speed, acceleration, and velocity) by the time since the
    last call. Here I choose to use pixels per second as the unit, so we need to multiply
    the value with the number of seconds since the last call; `sf::Time` provides
    this ability:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每一帧的执行时间并不相同，我们需要将所有值（旋转速度、加速度和速度）乘以自上次调用以来经过的时间。在这里，我选择使用每秒像素作为单位，因此我们需要将值乘以自上次调用以来经过的秒数；`sf::Time`
    提供了这个能力：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function is not difficult and should not surprise you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不难，不应该让你感到惊讶。
- en: 'Now, we need to update the `Game::processEvents()` function to set the values
    of `isMoving` and `rotation`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `Game::processEvents()` 函数来设置 `isMoving` 和 `rotation` 的值：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this code, we set the value of `isMoving` to `true` when the up arrow key
    is pressed and to `false` when it is released. The same trick is used to set the
    rotation depending on the left and right arrows, but here we set the rotation
    direction, `1` for clockwise, `-1` for counterclockwise, and `0` to none. All
    the computations have already been made in `Player::update()`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，当按下上箭头键时，我们将`isMoving`的值设置为`true`，当释放时设置为`false`。同样的技巧用于根据左右箭头设置旋转，但在这里我们设置旋转方向，`1`表示顺时针，`-1`表示逆时针，`0`表示无旋转。所有计算已经在`Player::update()`中完成。
- en: Managing user inputs
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户输入
- en: Managing the events received from the user is a really important topic. SFML
    provides us with two different approaches. The first is by polling the events
    received from a `sf::Window` instance, and the other is by checking the state
    in real time of an entry.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 管理从用户接收的事件是一个非常重要的主题。SFML为我们提供了两种不同的方法。第一种是通过轮询从`sf::Window`实例接收的事件，另一种是实时检查条目的状态。
- en: First of all, what is an event?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是事件？
- en: 'Generally, an event is an object that is triggered when something changes/happens.
    They are OS-dependent, but SFML provides us with a nice object to handle them
    in an OS-independent way. This is the `sf::Event` class. This class deals with
    a vast number of events, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件是在某些变化/发生时被触发的对象。它们是操作系统相关的，但SFML为我们提供了一个很好的对象，以操作系统无关的方式处理它们。这是`sf::Event`类。这个类处理大量的事件，如下所示：
- en: 'Windows contains four different kinds of events. They are as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口包含四种不同类型的事件。如下所示：
- en: Close
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭
- en: Resize
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整大小
- en: Gain/lose focus
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得或失去焦点
- en: The mouse pointer goes in/out of the window
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标指针进入/离开窗口
- en: 'There are three events for the mouse. They are as follows:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标有三个事件。如下所示：
- en: Move
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Key press/release
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键/释放
- en: Wheel press, release, or move
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚轮按下、释放或移动
- en: 'The keyboard contains two events. They are as follows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘包含两个事件。如下所示：
- en: Keys press/release
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘按键/释放
- en: Text entered
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入文本
- en: 'The joystick is also managed with four events. They are as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏手柄也通过四个事件进行管理。如下所示：
- en: Connected/disconnected
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接/断开
- en: Move
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Press/release the key
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键/释放键
- en: Enter text
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入文本
- en: I suggest you take a look at the SFML documentation for this class at [http://www.sfml-dev.org/tutorials/2.2/window-events.php](http://www.sfml-dev.org/tutorials/2.2/window-events.php).
    An important thing to have in mind is that `sf::Event` is nothing but a big union,
    so you have to pay attention to access the right attributes of an event depending
    on its type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您查看[http://www.sfml-dev.org/tutorials/2.2/window-events.php](http://www.sfml-dev.org/tutorials/2.2/window-events.php)上的SFML文档，了解这个类的信息。需要记住的一个重要事情是`sf::Event`不过是一个大的联合体，所以你必须注意根据事件类型访问正确的属性。
- en: Polling events
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询事件
- en: 'These kinds of events are stored in a queue by a `sf::Window` instance. To
    deal with them, we simply need to extract them one by one using the `sf::Window::pollEvent()`
    method. Its signature is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的事件由`sf::Window`实例存储在队列中。要处理它们，我们只需使用`sf::Window::pollEvent()`方法逐个提取它们。其签名如下：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This signature is a bit interesting. The return value is set to `true` if an
    event has been extracted from the queue and `false` in other cases. When an event
    is extracted, the event parameter is set to correspond to the correct value. In
    other words, the event parameter is the event that we get when the function returns
    `true`. The typical use of this is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名有点有趣。如果从队列中提取了事件，则返回值设置为`true`，在其他情况下设置为`false`。当事件被提取时，事件参数被设置为对应正确的值。换句话说，事件参数是我们当函数返回`true`时得到的事件。这种典型用法如下：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is exactly what we've done in our actual application. For the moment, we
    use the event polling to deal with the user inputs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在实际应用中所做的。目前，我们使用事件轮询来处理用户输入。
- en: These event types are used for specific cases (such as closing the window, using
    the escape key to exit, pausing the game, and so on), and not to move a player
    because events are perceived so jerky in a non-real-time. The resulting movement
    will also be jerky.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件类型用于特定情况（例如关闭窗口、使用Esc键退出、暂停游戏等），而不是移动玩家，因为在非实时中事件感知是如此不连贯。结果的运动也将是不连贯的。
- en: Real-time events
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时事件
- en: SFML provides us with the possibility to check the state of an entity at any
    time. This entity can be the mouse, keyboard, or a joystick. Here, we don't use
    events, but we simply check the position of the mouse, and whether a specific
    button or key is pressed. This is really different from the events, and is particularly
    well adapted for the player's actions such as movement, shooting, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: SFML为我们提供了在任何时候检查实体状态的可能性。这个实体可以是鼠标、键盘或游戏手柄。在这里，我们不使用事件，而是简单地检查鼠标的位置以及是否按下了特定的按钮或键。这与事件非常不同，特别适合玩家的动作，如移动、射击等。
- en: As you have probably noticed, our actual use of event in the `Player` class
    is wrong. So we need to change it to use real-time events without changing the
    controls keys. To do this, we will add a `processEvents()` method in the `Player`
    class that will set the value of `isMoving` and `rotation`. We will also change
    our `Game::processEvents()` function to call the newly created `Player::processEvents()`
    method. Also, because `isMoving` and `rotation` will be set inside the `Player`
    class, we will move them as private attributes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们在`Player`类中对事件的实际使用是错误的。因此，我们需要将其更改为使用实时事件，同时不改变控制键。为此，我们将在`Player`类中添加一个`processEvents()`方法，该方法将设置`isMoving`和`rotation`的值。我们还将更改我们的`Game::processEvents()`函数，以调用新创建的`Player::processEvents()`方法。此外，因为`isMoving`和`rotation`将在`Player`类内部设置，我们将它们移动为私有属性。
- en: 'Here is the signature of the new method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新方法的签名：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, this is the exact same signature as `Game::processEvents()`.
    Its implementation is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与`Game::processEvents()`的签名完全相同。其实现如下：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we set the `isMoving` value, depending on the up arrow state. To do
    this, we use the `sf::Keyboard::isKeyPressed()` function. Because this function
    is a static one, we can directly use it without any object. Take a look at its
    signature:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据向上箭头的状态设置`isMoving`的值。为此，我们使用`sf::Keyboard::isKeyPressed()`函数。因为这个函数是一个静态函数，我们可以直接使用它而不需要任何对象。看看它的签名：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function returns `true` if the key is pressed, and `false` if not. Really
    simple, isn't it?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按键被按下，此函数返回`true`，如果没有按下，则返回`false`。真的很简单，不是吗？
- en: 'Now, let''s talk about the rotation. The rotation depends on two different
    inputs. So, we need to think "What will happen if the user presses both at the
    same time?". It might sound a bit weird, but yes, some players will do this, so
    we need to consider it. Here, I use a really simple solution:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈旋转。旋转取决于两个不同的输入。因此，我们需要思考“如果用户同时按下这两个键会发生什么？”。这听起来可能有点奇怪，但确实，一些玩家会这样做，所以我们需要考虑这一点。在这里，我使用了一个非常简单的解决方案：
- en: First, I reset the value of `rotation`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我重置了`rotation`的值
- en: Then, I add `rotation` depending on the input state for both the keys
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我根据两个键的输入状态添加`rotation`
- en: By doing this, if no key is pressed, `rotation` stays to its initial value,
    that is, `0`. If one of the inputs is pressed, then `rotation` takes the value
    of `1` or `-1`, and if both are pressed, the two inputs will cancel each other
    out, so everything is fine and we get the result we expected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，如果没有按键被按下，`rotation`将保持其初始值，即`0`。如果按下其中一个输入，则`rotation`将取`1`或`-1`的值，如果同时按下两个，则两个输入将相互抵消，所以一切正常，我们得到了预期的结果。
- en: 'Now, let''s focus on the `Player::update()` method. This one is not really
    different. The only line we have to change is the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`Player::update()`方法。这个方法并没有太大的不同。我们唯一需要更改的是以下行：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because we now set `rotation` inside the `Player` class, we are sure that its
    value is always accurate, so that we don''t need to verify it anymore and can
    remove it. The new line is reduced to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在`Player`类内部设置`rotation`，我们可以确保其值始终是准确的，因此我们不再需要验证它，可以将其删除。新行简化为以下内容：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s take a look at the updated `Game::processEvents()` method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看更新的`Game::processEvents()`方法：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we drastically reduce the code size by removing any event dedicated to
    the player. The only thing to do is to call the `Player::processEvents()` method
    instead of managing the player controls.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过删除任何针对玩家的特定事件来大大减少了代码的大小。我们唯一要做的就是调用`Player::processEvents()`方法而不是管理玩家控制。
- en: Handling user inputs
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Now that the events are known better, it could be interesting to be able to
    bind them to some callback when they occur. The main idea behind this is to allow
    us to dynamically add functionalities. In a game, you sometimes have the possibility
    to upgrade some weapons, or to use new ones; one option is to make sure that the
    usage is allowed before executing it, and another is to add it to the player when
    he is able to use it. By doing this, we remove a lot of if statements in our code
    and increase the readability of the latter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对事件有了更深入的了解，能够将它们绑定到当它们发生时的某些回调函数可能会很有趣。这个想法背后的主要目的是允许我们动态地添加功能。在游戏中，有时你有升级某些武器或使用新武器的可能性；一个选项是在执行之前确保使用是允许的，另一个选项是在玩家能够使用时将其添加到玩家。通过这样做，我们移除了代码中的许多if语句，并提高了代码的可读性。
- en: To do this, we need a system that allows us to add functionalities to an entity,
    and that can be triggered by an event. This event can be in real time or generated
    by polling a `sf::Window` instance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要一个系统，允许我们向实体添加功能，并且可以通过事件触发。这个事件可以是实时的，或者是由轮询`sf::Window`实例生成的。
- en: Using the Action class
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Action类
- en: We will create a new class containing an `sf::Event` instance that needs to
    be executed. This class will implement functionality to check if the internal
    `sf::Event` instance is executed. The comparison operators are a good way to do
    this, but it will not work for real-time events because we have nothing to compare
    with, as we don't pool them. So we will also need `Action::test()` to check if
    a real-time event is satisfied. We will also need to know whether the event has
    to be triggered by pressing or releasing the input, or both.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类，该类包含一个需要执行的`sf::Event`实例。这个类将实现检查内部`sf::Event`实例是否被执行的功能。比较运算符是做这件事的好方法，但对于实时事件来说则不行，因为我们没有可以与之比较的东西，因为我们没有对它们进行池化。所以，我们还需要`Action::test()`来检查实时事件是否满足条件。我们还需要知道事件是否需要通过按下或释放输入来触发，或者两者都需要。
- en: 'The code for the `Action` class is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`类的代码如下：'
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let us follow this code step-by-step:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地跟踪这段代码：
- en: First, we define enum that will be used as flags in and by the constructors.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个枚举，它将被构造函数用作标志。
- en: Then, we make the copy constructor and the copy operator.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了复制构造函数和复制运算符。
- en: Next are the constructors. For the moment, we need to manage inputs from the
    mouse and the keyboard. So we make two constructors, one for each type of event.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是构造函数。目前，我们需要管理来自鼠标和键盘的输入。因此，我们创建了两个构造函数，一个用于每种类型的事件。
- en: The `test()` function will allow us to test whether the event is satisfied in
    real time, and the comparison operators will allow us to compare the event with
    others.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()`函数将允许我们测试事件是否在实时满足，比较运算符将允许我们比较事件与其他事件。'
- en: 'We shall now take a look at the implementation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These two functions simply copy the content of `Action` to another `Action`
    instance. Because the `sf::Event` class doesn''t implement the copy operator/constructor,
    we use the `std::memcpy()` function from the C string module. This allows us to
    copy the entire content of `sf::Event` simply by knowing its size, which can be
    known using the `sizeof()` operator. Notice that this is technically correct in
    this case only because `sf::Event` doesn''t contain any pointers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数只是简单地复制`Action`的内容到另一个`Action`实例。因为`sf::Event`类没有实现复制运算符/构造函数，我们使用了C字符串模块中的`std::memcpy()`函数。这允许我们通过知道其大小来简单地复制`sf::Event`的全部内容，这可以通过`sizeof()`运算符来实现。请注意，在这种情况下，这从技术上讲是正确的，因为`sf::Event`不包含任何指针：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the constructor for the keyboard events. The `key` parameter defines
    the key to bind, and the `type` parameter defines the state of the input: real-time,
    pressed, released, or a combination of them. Because the `type` value is a flag,
    it can take the value of `Pressed` and `Released` at the same time; this creates
    a problem because the type of an event can''t be `sf::Event::EventType::KeyPressed`
    and `sf::Event::EventType::KeyReleased` at the same time. We need to bypass this
    limitation.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是键盘事件的构造函数。`key`参数定义了要绑定的键，而`type`参数定义了输入的状态：实时、按下、释放，或者它们的组合。因为`type`值是一个标志，它可以同时具有`Pressed`和`Released`的值；这会引发一个问题，因为事件类型不能同时是`sf::Event::EventType::KeyPressed`和`sf::Event::EventType::KeyReleased`。我们需要绕过这个限制。
- en: 'To do this, set the event type to `sf::Event::EventType::KeyPressed` no matter
    what the value of type is, and we will have some special cases to deal with later
    (in `test()` and comparison operator):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，无论类型的值是什么，都将事件类型设置为 `sf::Event::EventType::KeyPressed`，我们将在稍后处理一些特殊情况（在
    `test()` 和比较操作符中）：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the same idea as the previous constructor. The only difference is that
    `event.mouseButton` cannot be copied. So here we need to use `std::memcpy()` again:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的构造函数是同样的想法。唯一的区别是 `event.mouseButton` 不能被复制。所以这里我们需要再次使用 `std::memcpy()`：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Action::operator==()` is an interesting function. This function will test
    if two events are equivalent. But, because we have previously fixed the value
    for the keyboard and the mouse to `sf::Event::EventType::[Key/Button]Pressed`,
    we need to check these special cases. These cases are represented by the `if`
    statements:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action::operator==()` 是一个有趣的函数。这个函数将测试两个事件是否等效。但是，因为我们之前已经将键盘和鼠标的值固定为 `sf::Event::EventType::[Key/Button]Pressed`，我们需要检查这些特殊情况。这些情况由
    `if` 语句表示：'
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function is pretty simple, first we check the type, and then, we forward
    the comparison to the comparison operator previously defined:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当简单，首先我们检查类型，然后，我们将比较操作转发到之前定义的比较操作符：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function is made for checking real-time events. As I have already mentioned,
    we only need the mouse and keyboard events. To check them, we use the static functions
    `sf::Keyboard::isKeyPressed()` and `sf::Mouse::isButtonPressed()`. Here we simply
    have to check the type of events and the state required, and that's it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是为了检查实时事件。正如我已经提到的，我们只需要鼠标和键盘事件。为了检查它们，我们使用静态函数 `sf::Keyboard::isKeyPressed()`
    和 `sf::Mouse::isButtonPressed()`。这里我们只需要检查事件类型和所需的状态，就是这样。
- en: 'Now that the `Action` class was made, let''s move on to the next step: binding
    them to a functionality.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了 `Action` 类，让我们继续下一步：将它们绑定到功能上。
- en: Action target
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作目标
- en: We will now need a system to bind a functionality to an event. So let's think
    about what a functionality is.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个系统将功能绑定到事件。那么，让我们思考一下什么是功能。
- en: 'A functionality is a piece of code that has to be executed when a criterion
    is satisfied. Here the criterion is an action and thanks to our freshly defined
    class, we can now know whether the event is satisfied or not. But what about the
    piece of code? If we think a little bit about it, the functionality can be put
    in a function or method, so here we are: a functionality is nothing but a function.
    So to store the code, and be able to bind it at runtime, we will use the generic
    function wrapper from the C++11: the template class `std::function`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 功能是一段代码，当满足某个条件时必须执行。在这里，条件是一个动作，多亏了我们刚刚定义的类，我们现在可以知道事件是否满足条件。但是，关于这段代码呢？如果我们稍微思考一下，功能可以被放入一个函数或方法中，所以这里就是：功能不过是一个函数。因此，为了存储代码，并在运行时绑定它，我们将使用
    C++11 的泛型函数包装器：模板类 `std::function`。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`std::function` is a generic wrapper for any type of function, method, and
    lambda. It''s a very powerful object to store callbacks. To do this, we will use
    another new class from the C++11, the template class `std::pair`, and a container.
    Due to our needs, a `std::` list will be perfectly fine.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function` 是任何类型函数、方法和 lambda 的泛型包装器。它是一个非常强大的对象，用于存储回调。为此，我们将使用 C++11
    的另一个新类：模板类 `std::pair` 和一个容器。由于我们的需求，一个 `std::` 列表将完全合适。'
- en: 'Now we have all the keys in hand to build what we need. We will build a container
    to store as many actions paired with `std::function` as we want:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了所有必要的工具来构建我们需要的。我们将构建一个容器来存储尽可能多的与 `std::function` 配对的动作：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s see what happens step by step:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看会发生什么：
- en: Firstly, we define the type of the function that will be managed with the new
    C++11 use of the `using` keyword. This syntax is equivalent to `typedef` except
    that it is more explicit.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用新的 C++11 `using` 关键字定义将要管理的函数类型。这种语法与 `typedef` 相当，但更加明确。
- en: Secondly, we define a default constructor and the methods to verify the internal
    events. We create two of them. The first is for non-real-time events (polling),
    and the other is for real-time events.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们定义一个默认构造函数和验证内部事件的方法。我们创建了两个：第一个用于非实时事件（轮询），另一个用于实时事件。
- en: Then we add a method to bind an event to a function, and another to remove any
    existing event.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们添加一个方法将事件绑定到函数，另一个方法用于移除任何现有的事件。
- en: Internally, you can make the choice to separate the real-time and non-real-time
    events to avoid some `if` statements. The goal is to win some readability and
    computing power.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，你可以选择将实时事件和非实时事件分开，以避免一些`if`语句。目标是提高可读性和计算能力。
- en: 'Now take a look at the implementation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看实现：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The two `ActionTarget::processEvent[s]()` methods are not difficult and simply
    check the validity of the events by using the functions that have been made in
    the `Action` class. If the event is satisfied, we call the associated function
    with the `sf::Event` as a parameter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`ActionTarget::processEvent[s]()`方法并不复杂，它们简单地通过使用在`Action`类中创建的函数来检查事件的有效性。如果事件满足条件，我们调用与`sf::Event`作为参数的关联函数。
- en: 'Here a new `for` loop, syntax is used. It''s the `foreach` style of the C++11
    `for` loop coupled with the `auto` keyword. This is both a very powerful and succinct
    syntax:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了新的`for`循环语法。这是C++11的`for`循环的`foreach`风格，结合了`auto`关键字。这是一种非常强大且简洁的语法：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method adds a new event and its callback to the internal container. To
    avoid some `if` statements in the `processEvent[s]()` methods, I make the choice
    to separate the real-time event from the others:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法向内部容器添加了一个新事件及其回调。为了避免在`processEvent[s]()`方法中的一些`if`语句，我选择将实时事件与其他事件分开：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At runtime, it could be useful to be able to remove some actions. This is the
    idea of this function. I use the `std::list::remove_if()` method here to remove
    all the actions of the internal list that match the parameter. It takes a function
    such as the parameter, so we create a lambda. The lambda functions are a new feature
    from the C++11\. Their syntax is a little special, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，能够移除一些动作可能会有用。这正是这个函数的思路。我在这里使用了`std::list::remove_if()`方法来移除所有与参数匹配的内部列表中的动作。它接受一个函数作为参数，因此我们创建了一个lambda。lambda函数是C++11的一个新特性。它们的语法有一点特别，如下所示：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s go through the preceding syntax in detail:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地看一下前面的语法：
- en: A lambda is like any other function, except it doesn't have a name (also named
    anonymous functions). Because of this, a lambda doesn't know the context and sometimes,
    like here, you will need some variables from the calling context. These variables
    have to be specified in the `[]` part. You can prefix them with a `=` or `&` symbol
    depending on whether you want to access them by copy or by reference.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda就像任何其他函数一样，除了它没有名字（也称为匿名函数）。正因为如此，lambda不知道上下文，有时，就像这里，你需要从调用上下文中获取一些变量。这些变量必须在`[]`部分中指定。你可以根据是否想通过复制还是通过引用来访问它们，在它们前面加上`=`或`&`符号。
- en: Second is the parameters part. Nothing is new in this part. The parameter type
    is fixed by the `std::list::remove_if()` function to the same type of template
    parameter of the `std::list` used.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分是参数部分。这部分没有新的内容。参数类型由`std::list::remove_if()`函数固定为`std::list`使用的相同模板参数类型。
- en: Then it's the return type. It's not an obligation, because this type can be
    deduced from the return statement, but here I've made the choice to explicitly
    write it, as a complete example. The return type is also fixed by the `std::list::remove_if()`
    method to `bool`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是返回类型。这不是强制性的，因为这个类型可以从返回语句中推断出来，但在这里我选择显式地写出它，作为一个完整的示例。返回类型也由`std::list::remove_if()`方法固定为`bool`。
- en: And finally, between `{` and `}` is the implementation of the lambda. This implementation
    is really simple because all the work has already been done in the `Action` class.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在`{`和`}`之间是lambda的实现。这个实现非常简单，因为所有的工作已经在`Action`类中完成了。
- en: 'And here we are. We have our complete new `ActionTarget` class ready to be
    used. There are some new C++ features used in this part (`using`, `foreach`, `auto`,
    and `lambda`). If you don''t understand them, I suggest you learn them by reading
    the C++11 that can be find on this website : [http://en.cppreference.com/w/cpp/language](http://en.cppreference.com/w/cpp/language).
    It''s really essential you understand what is used here before you read on. So
    if need be, take as much time as required.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了这里。我们已经有了完整的新的`ActionTarget`类，准备使用。在这个部分使用了某些新的C++特性（`using`、`foreach`、`auto`和`lambda`）。如果你不理解它们，我建议你通过阅读这个网站上的C++11来学习：[http://en.cppreference.com/w/cpp/language](http://en.cppreference.com/w/cpp/language)。在继续阅读之前，真正理解这里使用的内容是非常必要的。所以如果需要，请花尽可能多的时间。
- en: 'Now that we have built the system to manage the events, let''s use it. We will
    change our player, and extend it from `ActionTarget`. We will need to change the
    code in the `.hpp` file a little bit. Since the C++ allows us to use the multiple
    inheritance, let''s use it, and change the class from:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了管理事件的系统，让我们使用它。我们将更改我们的玩家，并从`ActionTarget`扩展它。我们需要稍微更改`.hpp`文件中的代码。由于C++允许我们使用多重继承，让我们使用它，并将类从：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: to
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: to
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By doing this, the functionalities of the `ActionTarget` class are added to
    the `Player` class. Now, we need to update two functions: `Player::Player()` and
    `Player::processEvents()`. Notice, that this change imply a modification on the
    `isMoving` and `rotation` attributes that are now private members of the `Player`
    class.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，`ActionTarget`类的功能被添加到`Player`类中。现在，我们需要更新两个函数：`Player::Player()`和`Player::processEvents()`。注意，这个更改意味着对`isMoving`和`rotation`属性进行了修改，这些属性现在是`Player`类的私有成员。
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we bind the keyboard keys to some callbacks using lambda functions. As
    you can see, we don't need to check the state of the input in the function because
    this has already been done in the `ActionTarget::proccessEvents()` method. The
    callback is called only when the event is satisfied, in this case, when the key
    is pressed. So we can directly set the value because we know that the key is pressed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用lambda函数将键盘键绑定到一些回调。正如你所看到的，我们不需要在函数中检查输入的状态，因为这已经在`ActionTarget::processEvents()`方法中完成了。回调仅在事件满足时被调用，在这种情况下，当按键被按下时。因此，我们可以直接设置值，因为我们知道按键已被按下。
- en: 'The idea here is to be able to change the inputs without any change in the
    callbacks. This will be really interesting to build a custom input configuration
    in the future:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是能够在不更改回调的情况下更改输入。这将非常有兴趣在将来构建一个自定义输入配置：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this method, we remove all of the codes that check the inputs states, and
    delegate this to the `ActionTaget::processEvents()` method. The only new thing
    to do is reset the variable that can be changed by the events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们移除了所有检查输入状态的代码，并将此委托给`ActionTaget::processEvents()`方法。唯一需要做的事情是重置可以由事件更改的变量。
- en: There is no difference in the final result of our application, but now we have
    a good starting point to manage our events, and it simplifies our work.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的最终结果没有区别，但现在我们有一个很好的起点来管理我们的事件，并且它简化了我们的工作。
- en: Event map
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件映射
- en: Now that we have defined a system to check our event, it would be great to change
    the inputs associated to a functionality at runtime. This will allow us to create
    a system where the user can choose which key/button he wants to associate with
    a specific action. For the moment, we have hardcoded the inputs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个系统来检查我们的事件，那么在运行时更改与功能关联的输入将会非常棒。这将使我们能够创建一个系统，用户可以选择他想要与特定动作关联的哪个键/按钮。目前，我们硬编码了输入。
- en: To do this, we will need something that can associate a key with an action.
    This is what the `std::map` and `std::unordered_map` classes do. Because `std::unordered_map`
    is quicker than `std::map` at runtime, we prefer to use it. This class comes from
    the C++ 11.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要能够将一个键与一个动作关联的东西。这正是`std::map`和`std::unordered_map`类所做的事情。因为`std::unordered_map`在运行时比`std::map`更快，所以我们更喜欢使用它。这个类来自C++
    11。
- en: 'As previously mentioned, we need to associate a key with an action, so we will
    create a new class named `ActionMap` that will contain the association map and
    offer the possibility to add actions at runtime or get one action, thanks to its
    key:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要将一个键与一个动作关联，因此我们将创建一个新的类名为`ActionMap`，它将包含关联映射并提供在运行时添加动作或通过其键获取一个动作的可能性：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Nothing complex here, we just make a wrapper around the container, and make
    the class in such a way that it cannot be copied with a default empty constructor.
    We also make the class as a template to be able to choose any kind of key type.
    In practice, we will often use an integer, but sometimes, it could be interesting
    to have a string as the key. This is the reason why the template type is `int`
    by default. Now, let''s look at its implementation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的，我们只是围绕容器创建了一个包装器，并使类以这种方式无法通过默认空构造函数进行复制。我们还使类成为模板，以便能够选择任何类型的键。实际上，我们通常会使用整数，但有时，使用字符串作为键可能很有趣。这就是为什么模板类型默认为`int`的原因。现在，让我们看看它的实现：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The implementation is really simple to understand. We simply forward what we
    want to do to the internal container. Because `std::unordered_map` throws exceptions
    when we try to make an invalid access, for example, we don't need any test.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单易懂。我们只需将我们想要执行的操作转发到内部容器。由于`std::unordered_map`在尝试进行无效访问时抛出异常，例如，我们不需要任何测试。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that, because the class is a template, the implementation has to be made
    in the header file. But, in order to not lose readability in the header, there
    is another way; put the code in a `.tpl` file (`tpl` is the short form for template
    word) and include it at the end of the header. By doing this, we separate the
    declaration from the implementation. This is a good practice, and I recommend
    you to apply it. The `.inl` file extension is also common (shortcut for inline
    word) instead of `.tpl`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于该类是模板，实现必须在头文件中完成。但是，为了不在头文件中失去可读性，还有一种方法；将代码放在一个`.tpl`文件（`tpl`是模板词的简称）中，并在头文件的末尾包含它。通过这样做，我们将声明与实现分开。这是一个好的做法，我建议你应用它。`.inl`文件扩展名也很常见（inline词的缩写）而不是`.tpl`。
- en: If you pay attention, the class is not a static one and can be instantiated.
    This is so that it will allow us to use multiple `ActionMap` class in our project,
    for example, one to store the player inputs, and another to store the system inputs.
    But this approach clashes with our actual `ActionTarget` class, so we need to
    modify it a little bit.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意的话，这个类不是静态的，可以实例化。这样，它将允许我们在项目中使用多个`ActionMap`类，例如，一个用于存储玩家输入，另一个用于存储系统输入。但是，这种方法与我们的实际`ActionTarget`类冲突，因此我们需要对其进行一点修改。
- en: Back to action target
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回到动作目标
- en: 'Since I want to be most generic as possible in the event system, we need to
    modify our `ActionTarget` class a bit:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我想在事件系统中尽可能通用，我们需要对我们的`ActionTarget`类进行一点修改：
- en: Firstly, the `ActionTaget` class needs to be linked to `ActionMap`. This will
    allow us to use multiple `ActionMap` in a single project, and this can be very
    interesting.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`ActionTaget`类需要与`ActionMap`链接。这将允许我们在单个项目中使用多个`ActionMap`，这可以非常有趣。
- en: Moreover, because the action is now stored in `ActionMap`, `ActionTarget` doesn't
    need to store them anymore, but instead it needs to store the key to get them.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，因为动作现在存储在`ActionMap`中，`ActionTarget`不再需要存储它们，而是需要存储获取它们的键。
- en: And finally, because `ActionMap` is a template class, we will need to turn `ActionTaget`
    into a template class too.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，因为`ActionMap`是一个模板类，所以我们需要将`ActionTaget`也转换为模板类。
- en: 'The new header looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 新的头文件看起来像这样：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The major change is to turn all the references of the `Action` class to the
    template type. The action will now be identified by its key. Because we need to
    access the `Action` instances at runtime, we need to have a way to reach them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的改变是将所有对`Action`类的引用转换为模板类型。现在，动作将通过其键来识别。由于我们需要在运行时访问`Action`实例，我们需要有一种方法来访问它们。
- en: 'Here, I use the SFML logic: one big object and a frontend class to use it.
    The big object is `ActionMap` and the frontend is `ActionTarget`. So, we internally
    store a reference to `ActionMap` used to store the events, and because we don''t
    need to modify it, we make it as constant.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我使用SFML逻辑：一个大对象和一个用于使用它的前端类。大对象是`ActionMap`，前端是`ActionTarget`。因此，我们内部存储一个用于存储事件的`ActionMap`的引用，并且由于我们不需要修改它，我们将其设置为常量。
- en: All these changes affect our class implementation. Instead of directly accessing
    an `Action` instance, we need to get it by calling `ActionMap::get()`, but nothing
    more difficult than this. The really important changes are made in the `Player`
    class, because now, we have the possibility to change the inputs at runtime, but
    we also need some default inputs, so we need to add a function to initialize the
    inputs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些更改都影响我们的类实现。我们不再直接访问`Action`实例，而是需要通过调用`ActionMap::get()`来获取它，但这并不比这更困难。真正重要的更改是在`Player`类中进行的，因为现在，我们有在运行时更改输入的可能性，但我们还需要一些默认输入，因此我们需要添加一个初始化输入的函数。
- en: 'Since a player doesn''t have infinite possible control, we can create `enum`
    that will store all the keys that will be used in the code. For the moment, we
    have only one player, so we can present this function as static. The implication
    is that `ActionMap` internally used has to be static as well. This `ActionMap`
    will be added as a static attribute of the `Player` class. This is the new header
    of the class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家没有无限的可能的控制，我们可以创建一个`enum`来存储代码中将使用的所有键。目前我们只有一个玩家，所以我们可以将这个函数作为静态的来展示。这意味着`ActionMap`内部使用的也必须是静态的。这个`ActionMap`将被添加为`Player`类的静态属性。这是类的新头文件：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, the `Player::PlayerInputs` enum, the `Player::setDefaultsInputs()`
    function, and the `Player::_playerInputs` attribute have been added. We also change
    the `ActionMap` type to `ActionMap<int>`, because we will use the newly created
    `enum` as a key; the default type of `enum` is `int`. The implementation of the
    player class does not change, except in the constructor. Instead of directly creating
    an action and binding it, we first initialize `ActionMap` (in `Player::setDefaultsInputs`)
    and then use the key store in `enum` to refer to the action.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已经添加了`Player::PlayerInputs`枚举、`Player::setDefaultsInputs()`函数和`Player::_playerInputs`属性。我们还更改了`ActionMap`的类型为`ActionMap<int>`，因为我们将使用新创建的`enum`作为键；`enum`的默认类型是`int`。玩家类的实现没有变化，除了在构造函数中。我们不是直接创建一个动作并绑定它，而是首先初始化`ActionMap`（在`Player::setDefaultsInputs`中），然后使用存储在`enum`中的键来引用动作。
- en: 'So here is the new constructor:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是新的构造函数：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, we also need to specify the `_playerInputs` parameter of the
    `ActionTarget` constructor, and we change all the `Action` constructions to their
    associated key:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还需要指定`ActionTarget`构造函数的`_playerInputs`参数，并将所有的`Action`构造转换为它们关联的键：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here we simply initialize the `_playerInputs` with some default keys. These
    keys are similar to the previous ones, but because `_playerInputs` is a static
    member of the `Player` class it has to be created somewhere. A good practice is
    to define it in the `.cpp` file. So the last change in the `Player.cpp` file is
    this line:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是用一些默认键初始化了`_playerInputs`。这些键与之前的类似，但因为在`Player`类中`_playerInputs`是一个静态成员，它必须创建在某个地方。一个好的做法是在`.cpp`文件中定义它。所以`Player.cpp`文件中的最后一个更改就是这一行：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will create the object as expected.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个预期的对象。
- en: 'We also need to initialize `ActionMap` by calling `Player::setDefaultsInputs()`.
    To do this, simply add this call to `main` before the game creation. The main
    should look like this by now:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过调用`Player::setDefaultsInputs()`来初始化`ActionMap`。为此，只需在游戏创建之前将此调用添加到`main`中。现在`main`应该看起来像这样：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The final result doesn't change, but I think that you can understand the power
    of the event system that has been created. It allows us to bind functionalities
    and change the key binding at runtime, this will be really useful in the future.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果没有变化，但我认为您可以理解所创建的事件系统的强大之处。它允许我们在运行时绑定功能并更改键绑定，这将在未来非常有用。
- en: 'The result of the actual application should look like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用的结果应该看起来像这样：
- en: '![Back to action target](img/8477OS_02_06.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![回到动作目标](img/8477OS_02_06.jpg)'
- en: You should also be able to rotate the square using the right and left arrows
    of your keyboard, and make it move by pressing the up arrow. The next step will
    be to turn this stupid square into a nice spaceship.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该能够使用键盘的左右箭头旋转方块，并通过按上箭头移动它。下一步将是将这个愚蠢的方块变成一个漂亮的宇宙飞船。
- en: Keeping track of resources
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪资源
- en: In general game development, the term **resource** defines an external component
    that will be loaded at runtime within the application. Most of the time, a resource
    is a multimedia file such as music and image, but it can also be a script or a
    configuration file. Throughout this book, the term resource will mostly refer
    to a multimedia resource.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般游戏开发中，术语**资源**定义了一个将在应用程序运行时加载的外部组件。大多数情况下，资源是一个多媒体文件，如音乐和图像，但它也可以是一个脚本或配置文件。在这本书中，术语资源将主要指多媒体资源。
- en: The resources require more memory, and one of the consequences of this is that
    all the operations on it run slowly, such as the copy. Another thing is that we
    don't want to have the same resource loaded multiple times in the memory. To avoid
    all this, we will use them in a particular way, with the help of a resource manager.
    Most of the time, a resource is loaded from a file to the hard disk, but there
    are other ways to load them, for example, from the memory or the network.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 资源需要更多的内存，这其中的一个后果是所有对其的操作都运行得比较慢，例如复制操作。还有一点是，我们不希望相同的资源在内存中加载多次。为了避免所有这些，我们将以特定的方式使用它们，借助资源管理器。大多数时候，资源是从文件加载到硬盘上的，但还有其他方法可以加载它们，例如从内存或网络加载。
- en: Resources in SFML
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML中的资源
- en: 'The SFML library deals with a great numbers of different resources:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: SFML库处理大量不同类型的资源：
- en: '| Graphics module | Audio module |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 图形模块 | 音频模块 |'
- en: '| --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Texture | SoundBuffer |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 纹理 | 声音缓冲区 |'
- en: '| Image | Music |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | 音乐 |'
- en: '| Font |   |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 字体 |   |'
- en: '| Shader |   |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 着色器 |   |'
- en: 'All of these resources have some common points. Firstly, we can''t use them
    directly as an output to the screen or the speakers. We have to use a frontend
    class that doesn''t hold the data, but instead holds a reference to it. One of
    the implications is that the coping objects are quicker. Secondly, all these resource
    classes share the same SFML API (Application Programming Interface) with some
    deviations sometimes. A typical example is loading the resources from the hard
    disk, which has the following signature:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些资源都有一些共同点。首先，我们不能直接将它们用作屏幕或扬声器的输出。我们必须使用一个前端类，该类不持有数据，而是持有对数据的引用。其中一个影响是复制对象更快。其次，所有这些资源类都共享相同的SFML
    API（应用程序编程接口），有时会有一些偏差。一个典型的例子是从硬盘加载资源，其签名如下：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function takes the complete path (relative or absolute) of the file to
    load, and returns `true` if the loading is successful and `false` if there is
    an error. It's very important to check the returned value to deal with the possible
    error, most of the time, an invalid path.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受要加载的文件的完整路径（相对或绝对），如果加载成功则返回 `true`，如果出错则返回 `false`。检查返回值非常重要，以处理可能出现的错误，大多数情况下是无效路径。
- en: 'There are other versions of this type of member function that allows us to
    load the resource from different kinds of media. The function `bool loadFromMemory(const
    void *data, std::size_t size);` allows the user to load the resource from a RAM.
    A typical use of this function is to load the resource from hardcoded data. The
    other option with the SFML is to load the resource from a custom stream:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此类成员函数还有其他版本，允许我们从不同类型的媒体中加载资源。函数 `bool loadFromMemory(const void *data, std::size_t
    size);` 允许用户从RAM中加载资源。此函数的一个典型用途是从硬编码的数据中加载资源。SFML的另一个选项是从自定义流中加载资源：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This allows the user to fully define the load process. It can be used to load
    the data from a compressed or encrypted file, from the network, or from whatever
    device you want. But for now, we will focus on the file way (`loadFromFile()`)
    to design our future resources manager. Before starting to create it, take a look
    at each SFML resource class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许用户完全定义加载过程。它可以用来从压缩或加密的文件、从网络或从您想要的任何设备加载数据。但就目前而言，我们将关注文件方式（`loadFromFile()`）来设计我们的未来资源管理器。在开始创建它之前，先看看每个SFML资源类。
- en: The texture class
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理类
- en: 'The `sf::Texture` class represents an image as a pixel array. Each pixel is
    an **RGBA** (**red, green, blue, alpha**) value that defines the color at a specific
    position of the image. This pixel array is stored on the graphic card, in the
    video memory so it does not use any RAM. Because `sf::Texture` is stored in the
    video memory, the graphic card can access it quickly for each draw, but `sf::Texture`
    can''t be manipulated (changed) as freely as `sf::Image` can. Every time we want
    to change it, we will need to reupload it on the video memory using the `sf::Texture::upload()`
    function. These operations are quite slow, so be careful when you use them. There
    are several common image formats sported by the SFML: `.bmp`, `.png`, `.tga`,
    `.jpg`, `.gif`, `.psd`, `.hdr`, and `.pic`. Notice that the `.png` images can
    be transparent, and can have an alpha channel to smooth edges again a transparent
    background.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Texture` 类将图像表示为一个像素数组。每个像素是一个 **RGBA**（红色、绿色、蓝色、透明度）值，它定义了图像特定位置的颜色。这个像素数组存储在图形卡上，在视频内存中，因此不使用任何
    RAM。由于 `sf::Texture` 存储在视频内存中，图形卡可以快速访问它进行每次绘制，但 `sf::Texture` 的操作（更改）不如 `sf::Image`
    自由。每次我们想要更改它时，都需要使用 `sf::Texture::upload()` 函数将其重新上传到视频内存。这些操作相当慢，所以使用时要小心。SFML
    支持几种常见的图像格式：`.bmp`、`.png`、`.tga`、`.jpg`、`.gif`、`.psd`、`.hdr` 和 `.pic`。请注意，`.png`
    图像可以是透明的，并且可以具有 alpha 通道以平滑透明背景的边缘。'
- en: The frontend class used to display `sf::Texture` is `sf::Sprite`. It's the texture
    representation with its own transformation, colors, and position. An important
    thing is that `sf::Texture` must be alive as long as `sf::Sprite` that used it
    is alive in order to avoid undefined behaviors. This is because `sf::Sprite` doesn't
    copy the texture data, but instead keeps a reference of it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示 `sf::Texture` 的前端类是 `sf::Sprite`。它是具有自己变换、颜色和位置的纹理表示。重要的是，只要使用它的 `sf::Sprite`
    存活，`sf::Texture` 就必须存活，以避免未定义的行为。这是因为 `sf::Sprite` 不复制纹理数据，而是保持对其的引用。
- en: The image class
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像类
- en: 'The `sf::Image` class behaves as the `sf::Texture` class but with some important
    differences due to its storage. The pixel array is stored in the RAM instead of
    the graphic card. The implications are multiple. The first implication is that
    it''s possible to modify each pixel of the image without any transfer. The second
    is that it''s possible to save the image back to a file placed on the hard drive.
    The last is that it''s not possible to directly display an image on the screen.
    We need to perform the following steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Image` 类的行为类似于 `sf::Texture` 类，但由于其存储方式，存在一些重要差异。像素数组存储在 RAM 中，而不是图形卡上。这带来了多重影响。首先，可以无需任何传输修改图像的每个像素。其次，可以将图像保存回硬盘上的文件。最后，无法直接在屏幕上显示图像。我们需要执行以下步骤：'
- en: First, convert it to `sf::Texture`
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将其转换为 `sf::Texture`
- en: Then, create `sf::Sprite` referring to the texture
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个指向纹理的 `sf::Sprite`
- en: Finally, display this sprite.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示这个精灵。
- en: Even if the entire image is not required for the display, it's possible to use
    only a part of it. So there is no waste of memory on the graphic card. The supported
    file formats are exactly the same for `sf::Texture` and `sf::Image`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 即使整个图像不需要显示，也可以只使用其中的一部分。因此，在图形卡上不会浪费内存。`sf::Texture` 和 `sf::Image` 支持的文件格式完全相同。
- en: It's important to limit the use of `sf::Image` only when you really need it,
    for example, to modify a loaded image at runtime, to access any of its pixels,
    or to split it into multiple `sf::Texture` classes. In other cases, it's advisable
    to directly use `sf::Texture` for performance issues.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是仅在真正需要时才限制使用 `sf::Image`，例如，在运行时修改加载的图像，访问其任何像素，或将它分割成多个 `sf::Texture` 类。在其他情况下，建议直接使用
    `sf::Texture` 以解决性能问题。
- en: The font class
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体类
- en: The `sf::Font` class allows us to load and manipulate character fonts. Most
    of the common types of fonts are supported such as `TrueType`, `Type 1`, `CFF`,
    `OpenType`, `SFNT`, `X11 PCF`, `Windows FNT`, `BDF`, `PFR`, and `Type 42`. The
    `sf::Font` class holds the data, but it's not possible to use it directly. You
    will need to use the frontend class `sf::Text`, like `sf::Sprite` for `sf::Texture`.
    This class has some properties such as the font size, color, position, rotation,
    and so on. The `sf::Font` class must remain accessible as long as all of `sf::Text`
    that refer to it are alive.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Font` 类允许我们加载和操作字符字体。大多数常见的字体类型都受支持，例如 `TrueType`，`Type 1`，`CFF`，`OpenType`，`SFNT`，`X11
    PCF`，`Windows FNT`，`BDF`，`PFR` 和 `Type 42`。`sf::Font` 类持有数据，但无法直接使用。您需要使用前端类 `sf::Text`，就像
    `sf::Sprite` 用于 `sf::Texture` 一样。这个类有一些属性，如字体大小、颜色、位置、旋转等。只要所有引用它的 `sf::Text`
    都存在，`sf::Font` 类必须保持可访问。'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In SFML 2.1, there is no default font for `sf::Text`, so you need at least one
    font file to display them in your application. The default system font will not
    be used at all. Moreover, `sf:Text` is actually an object that inherits from `sf::Drawable`,
    and is physically represented by an OpenGL texture. You have to pay attention
    to the fact that updating the text every frame has a processing cost, and text
    needs to be updated only when it's changed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SFML 2.1 中，`sf::Text` 没有默认字体，因此您至少需要一个字体文件来在您的应用程序中显示它们。默认系统字体将完全不被使用。此外，`sf:Text`
    实际上是一个继承自 `sf::Drawable` 的对象，并且由 OpenGL 纹理物理表示。您必须注意，每帧更新文本都有处理成本，并且只有在文本更改时才需要更新文本。
- en: The shader class
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器类
- en: 'A shader is a program that will be executed directly on the graphic card, that
    is written in a specific language, GLSL, which is very similar to the C. There
    are two of them:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是一个将在图形卡上直接执行的程序，它使用一种特定的语言编写，GLSL，这与C语言非常相似。有两种类型：
- en: '**Fragment shaders**: This modifies the geometry of an object'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这会修改一个对象的几何形状'
- en: '**Pixel shaders**: This modifies the pixel''s value of the scene'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素着色器**：这会修改场景中像素的值'
- en: Shaders are really powerful, and allow us to apply some real-time manipulations
    on our scene, such as light. To use them, you only need to specify it on the `RenderTarget.draw(sf::drawable&,
    sf::shader)` function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器非常强大，允许我们对场景应用一些实时操作，例如光照。要使用它们，您只需在 `RenderTarget.draw(sf::drawable&, sf::shader)`
    函数中指定即可。
- en: I recommend you read the entire description of `sf::Shader` in the documentation
    before starting to use them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在使用之前先阅读 `sf::Shader` 的整个描述文档。
- en: The sound buffer class
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频缓冲区类
- en: The `sf::SoundBuffer` class is used to store a sound effect. This class is especially
    designed to hold the entire audio sample in the memory as an array of 16 bits
    signed integers. Use it for short audio samples that require no latency and that
    can fit in the memory, for example, foot steps or gun shots.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::SoundBuffer` 类用于存储音效。这个类特别设计用来在内存中以16位有符号整数数组的形式存储整个音频样本。用于需要无延迟且可以适应内存的短音频样本，例如脚步声或枪声。'
- en: Many audio formats are supported, such as `.ogg`, `.wav`, `.flac`, `.aiff`,
    `.au`, `.raw`, `.paf`, `.svx`, `.nist`, `.voc`, `.ircam`, `.w64`, `.mat4`, `.mat5
    pvf`, `.htk`, `.sds`, `.avr`, `.sd2`, `.caf`, `.wve`, `.mpc2k`, and `.rf64`. Notice
    that the `.mp3` format is not supported because of its restrictive license.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多种音频格式，例如 `.ogg`, `.wav`, `.flac`, `.aiff`, `.au`, `.raw`, `.paf`, `.svx`,
    `.nist`, `.voc`, `.ircam`, `.w64`, `.mat4`, `.mat5 pvf`, `.htk`, `.sds`, `.avr`,
    `.sd2`, `.caf`, `.wve`, `.mpc2k`, 和 `.rf64`。请注意，`.mp3` 格式由于其限制性许可而不受支持。
- en: Like `sf::Texture`, `sf::SoundBuffer` holds data, but does not allow us to play
    it directly. We need to use the `sf::Sound` class to do this. The `sf::Sound`
    class provides some common functionalities, such as play, stop, and pause but
    we can also change its volume, pitch, and position. A `sf::Sound` class refers
    to `ssf::SoundBuffer` that must stay valid as long as `sf::Sound` is played.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sf::Texture` 类似，`sf::SoundBuffer` 持有数据，但无法直接播放。我们需要使用 `sf::Sound` 类来完成这个任务。`sf::Sound`
    类提供了一些常见功能，如播放、停止和暂停，但我们也可以更改其音量、音调和位置。一个 `sf::Sound` 类引用 `ssf::SoundBuffer`，它必须保持有效，只要
    `sf::Sound` 在播放。
- en: The music class
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐类
- en: The `sf::Music` class is the class used to play music. Unlike `sf::SoundBuffer`
    that is appropriate for short effects, `sf::Music` is designed to deal with long
    music themes. Themes are generally much longer than effects, and need a lot of
    memory to hold them completely. To overcome this, `sf::Music` does not load the
    entire resource at once, but, instead, streams it. This is really useful for large
    music files that take hundreds of MBs to avoid saturating the memory. Moreover,
    `sf::Music` has almost no loading delay.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Music`类是用来播放音乐的类。与适合短效果音的`sf::SoundBuffer`不同，`sf::Music`旨在处理长音乐主题。主题通常比效果长得多，需要大量内存来完全存储它们。为了克服这一点，`sf::Music`不会一次性加载整个资源，而是流式传输。这对于需要数百MB内存的大型音乐文件来说非常有用，可以避免内存饱和。此外，`sf::Music`几乎没有加载延迟。'
- en: Unlike other resources, `sf::Music` does not have any lightweight class. You
    can directly use it. It allows us to use the same features as `sf::SoundBuffer`
    and `sf::Sound` paired, such as play, pause, stop, request its parameters (channels
    and sample rate), and change the way it is played (pitch, volume, and 3D position).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他资源不同，`sf::Music`没有轻量级类。你可以直接使用它。它允许我们使用与`sf::SoundBuffer`和`sf::Sound`配对相同的特性，例如播放、暂停、停止、请求其参数（通道和采样率），以及更改其播放方式（音调、音量和3D位置）。
- en: As a sound stream, a music file is played in its own thread in order to not
    block the rest of the program. This means that you can leave the music file alone
    after calling `play()`, it will manage itself very well.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 作为音频流，音乐文件会在自己的线程中播放，以避免阻塞程序的其余部分。这意味着在调用`play()`之后，你可以单独处理音乐文件，它会很好地管理自己。
- en: Use case
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'Earlier in this chapter, I''ve explained that we will turn the blue square
    into a nice space ship. It''s time to do that. Here is the result that will be
    obtained:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我解释过我们将把蓝色方块变成一艘漂亮的宇宙飞船。现在是时候这么做啦。以下是将会得到的结果：
- en: '![Use case](img/8477OS_02_07.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![用例](img/8477OS_02_07.jpg)'
- en: It's not a big change, but it's a starting point for our future game.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很大的变化，但它是我们未来游戏的起点。
- en: 'To do this, we need to turn `sf::RectangleShape` that represents the `Player`
    class into `sf::Sprite`. We will also change the `_shape` attribute name into
    `_ship`; but there is an issue: where is the texture used to store the ship image?
    To make an attribute of the player of it can be a solution because there is only
    one player, but we will use another approach: a resources manager.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要将代表`Player`类的`sf::RectangleShape`转换为`sf::Sprite`。我们还将把`_shape`属性名称改为`_ship`；但是有一个问题：存储飞船图像的纹理在哪里？为了使玩家的属性可以是一个解决方案，因为只有一个玩家，但我们将采用另一种方法：资源管理器。
- en: Before starting to create the manager, let's talk about the **Resource Acquisition
    Is Initialization** (**RAII**) idiom.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建管理器之前，让我们先来谈谈**资源获取即初始化（Resource Acquisition Is Initialization，RAII**）惯用法。
- en: RAII idiom
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAII惯用法
- en: RAII is a principle in which a resource is acquired and released with a class
    construction and destruction, because these two functions are automatically called.
    It has the advantage over the manual management to be executed every time, even
    when some exceptions occur. It's used with the smart pointer classes in the C++11,
    and can be performed with every type of resource such as files, or in our case,
    SFML resources.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是一种原则，其中资源通过类的构造和析构来获取和释放，因为这些两个函数会自动调用。它比手动管理每次执行都有优势，即使在发生某些异常的情况下也是如此。它在C++11中与智能指针类一起使用，并且可以用于任何类型的资源，例如文件，或者在我们的情况下，SFML资源。
- en: Building a resources manager
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建资源管理器
- en: The goal of a resources manager is to manage the resources and ensure that all
    the resources are loaded only once to avoid any more copies.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理器的目标是管理资源，并确保所有资源只加载一次，以避免任何更多的副本。
- en: As previously mentioned, we focus on the resources loaded from the hard drive,
    so a good way to avoid any duplication is to use an identifier for the resource.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们关注从硬盘加载的资源，因此避免任何重复的一个好方法就是使用资源标识符。
- en: We will use `std::unordered_map` again, and build a wrapper around it, as the
    `ActionMap` class. Because SFML provides a lot of different types of resources,
    and I don't want to make one for each of them, I will build the resources manager
    as a template class again. But this time, the template type will be the resource
    and the key type. We will use the RAII idiom to automate the load and release
    the resources.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `std::unordered_map`，并围绕它构建一个包装器，作为 `ActionMap` 类。因为 SFML 提供了多种不同类型的资源，我不想为每一种都创建一个，所以我将资源管理器再次构建为一个模板类。但这次，模板类型将是资源和键类型。我们将使用
    RAII 习语来自动加载和释放资源。
- en: 'The class looks like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来是这样的：
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We make the class in such a manner that it cannot be copied, and create some
    functions to load a resource, and another one to get it. Because all the SFML
    resource classes don't have the exact same parameters for the `loadFromFile()`
    function (`sf::Shader`), I decided to use a template that will forward the arguments
    exactly as `Player::setPosition()`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式创建类，使其不能被复制，并创建一些函数来加载资源，另一个函数来获取它。因为所有 SFML 资源类对 `loadFromFile()` 函数的参数并不完全相同（`sf::Shader`），我决定使用一个模板，它将参数精确地转发，就像
    `Player::setPosition()`。
- en: Moreover, some classes cannot be copied, so we need to use a pointer to store
    them in a container. Because of the RAII idiom, the choice has been made to use
    the `std::unique_ptr` template class.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些类不能被复制，因此我们需要使用指针将它们存储在容器中。由于 RAII 习语，我们选择了使用 `std::unique_ptr` 模板类。
- en: Note
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A new class from the C++11 is `std::unique_ptr` and it is one of the smart pointers.
    Its internals use the RAII idiom, so we don't need to manage the memory deallocation.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 新增的一个类是 `std::unique_ptr`，它是一种智能指针。它的内部使用 RAII 习语，因此我们不需要管理内存的释放。
- en: 'Now the implementation is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的实现如下：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A feature from the C++11 is `std::move` and it allows us to use the `move` constructor
    instead of the `copy` constructor. The `std::unique_ptr` template class supports
    the type of constructor, so using it seems to be a good idea. The idea under the
    move semantic is to dump a temporary object by taking its content instead of copying
    it. The result is a gain in performance.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 的一个特性是 `std::move`，它允许我们使用移动构造函数而不是复制构造函数。`std::unique_ptr` 模板类支持这种构造函数类型，因此使用它似乎是个好主意。移动语义背后的想法是通过获取其内容而不是复制它来丢弃临时对象。结果是性能的提升。
- en: Here, we create a new resource using the template parameter `RESOURCE` as `std::unique_ptr`.
    Then we load the resource from the hard drive using the parameter pack `args`.
    Finally, we store it internally.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用模板参数 `RESOURCE` 创建一个新的资源，然后使用参数包 `args` 从硬盘加载资源。最后，我们将它内部存储。
- en: 'Notice that if the load fails, an exception is thrown rather than returning
    `false` as value:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果加载失败，会抛出异常而不是返回 `false` 值：
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This function simply delegates the job to the `std::unordered_map::at()` function
    by passing the `id` argument to it. The `::at()` method throws an exception when
    no object is found.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地通过传递 `id` 参数将任务委托给 `std::unordered_map::at()` 函数。当找不到对象时，`::at()` 方法会抛出异常。
- en: Because our actual `ResourceManager` class uses `loadFromFile()` in the `load()`
    method, we have a problem with the `sf::Music` class. `LoadFromFile()`, which
    doesn't exist in the `sf::Music` class and is replaced with `openFromFile()`.
    So we need to fix that.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的实际 `ResourceManager` 类在 `load()` 方法中使用 `loadFromFile()`，我们遇到了 `sf::Music`
    类的问题。`LoadFromFile()` 在 `sf::Music` 类中不存在，被 `openFromFile()` 替换。因此，我们需要修复这个问题。
- en: 'To do this, we will use the `partial` specialization. The partial specialization
    is a technical used in template programming to make some special case, exactly
    like this one. We need to specialize the `load()` method when `RESOURCE` is set
    to `sf::Music`. The problem is that we can''t do it directly because the `ResourceManager`
    class has two template parameters, and the other one doesn''t need to be fixed.
    So instead, we have to specialize the entire class by creating a new one:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用 `partial` 特化。部分特化是模板编程中用于创建特殊情况的技巧，就像这个例子一样。我们需要在 `RESOURCE` 设置为
    `sf::Music` 时特化 `load()` 方法。问题是，我们无法直接这样做，因为 `ResourceManager` 类有两个模板参数，另一个不需要修复。因此，我们必须通过创建一个新的类来特化整个类：
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This class is the replica of the previous one, except that we have removed
    one template parameter to fix it to `sf::Music`. Here is the implementation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是前一个类的副本，除了我们移除了一个模板参数以将其固定为 `sf::Music`。以下是实现：
- en: '[PRE57]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here again, this is exactly the same, except that we have changed `loadFromFile()`
    to `openFromFile()`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这完全一样，只是我们将 `loadFromFile()` 改为了 `openFromFile()`。
- en: Finally, one class with a specialization has been constructed to deal with all
    the SFML resources types, and use the RAII idiom to free memory when required.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了一个具有特化的类来处理所有 SFML 资源类型，并在需要时使用 RAII 习语来释放内存。
- en: The next step is to use this class to change the appearance of the player.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用这个类来改变玩家的外观。
- en: Changing the player's skin
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变玩家的皮肤
- en: Now that we have built a nice system to manage any kind of resource, let's use
    them. As previously mentioned, to change the player's square into a ship, we need
    to change `sf::RectangleShapethat`, represent the `Player` class in `sf::Sprite`,
    and then set the texture source of `sf::Sprite` loaded by the texture manager.
    So we need a texture manager.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个很好的系统来管理任何类型的资源，让我们使用它们。如前所述，要将玩家的方块变成一艘船，我们需要改变 `sf::RectangleShape
    that`，代表 `Player` 类在 `sf::Sprite` 中的表示，然后设置由纹理管理器加载的 `sf::Sprite` 的纹理源。因此，我们需要一个纹理管理器。
- en: If we think about it, all the managers will be global to our application, so
    we will group them into a static class named `Configuration`. This class will
    hold all the game configurations and the managers. `ActionMap` can also be stored
    inside this class, so we will move `ActionMap` inside the player into this new
    class, and create an `initialize()` method to initialize all the inputs and textures.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细想想，所有管理器都将对我们应用程序是全局的，所以我们将它们组合成一个名为 `Configuration` 的静态类。这个类将包含所有游戏配置和管理器。`ActionMap`
    也可以存储在这个类中，所以我们将 `ActionMap` 从玩家移动到这个新类中，并创建一个 `initialize()` 方法来初始化所有输入和纹理。
- en: 'This class is really simple, and can''t be instantiated, so all the attributes
    and methods will be static:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，不能实例化，所以所有属性和方法都将设置为静态：
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, the class is not really difficult. We only move the `_playerInputs`
    and `enum` from the `Player` class and add `ResourceManager` for textures. Here
    is the implementation:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个类并不真正困难。我们只是将 `_playerInputs` 和 `enum` 从 `Player` 类中移出，并为纹理添加了 `ResourceManager`。以下是实现方式：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here again, the code is simple. We now have just a few changes to make in the
    player class to draw it as a spaceship. We need to replace `sf::RectangleShape
    _shape` with `sf::Sprite _ship;`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码很简单。我们现在只需要在玩家类中做一些更改，就可以将其绘制成一艘太空船。我们需要将 `sf::RectangleShape _shape`
    替换为 `sf::Sprite _ship;`。
- en: 'In the constructor, we need to set the texture and the origin of the sprite
    as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们需要按照以下方式设置精灵的纹理和原点：
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Don't forget to call `Configuration::initialize()` from `main()` before anything
    else. We now have a nice spaceship as a player.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在做其他任何事情之前，不要忘记从 `main()` 中调用 `Configuration::initialize()`。我们现在有一个很棒的太空船作为玩家。
- en: There is a lot of code and different classes to get this result, but if you
    think about it, this will really help us in the future, and reduce the number
    of code lines in our final applications.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为了得到这个结果有很多代码和不同的类，但如果仔细思考，这真的会帮助我们，并减少我们最终应用程序中的代码行数。
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered the general game architecture, the input management,
    and the resources. You also learned about the RAII idiom and some C++11 features
    such as lambda, variadic templates, smart pointers, move syntax, and perfect forwarding.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了通用游戏架构、输入管理和资源。你还学习了 RAII 习语以及一些 C++11 特性，如 lambda、变长模板、智能指针、移动语法和完美转发。
- en: All the basic building blocks are now set up, so in the next chapter, we will
    make complete games by completing the current application to raise it to the asteroid
    game, and we will also build a Tetris game.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本构建块现在都已设置好，所以在下章中，我们将通过完成当前应用程序将其提升为小行星游戏来制作完整的游戏，我们还将构建一个俄罗斯方块游戏。
