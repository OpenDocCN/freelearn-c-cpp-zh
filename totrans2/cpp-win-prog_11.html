<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. The Document</h1></div></div></div><p>In the previous chapter we looked into the implementation of the <code class="literal">Application</code> and <code class="literal">Window</code> classes, which are useful for general Windows applications. In this chapter, we will look into the implementation of the <code class="literal">Document</code>, <code class="literal">StandardDocument</code>, <code class="literal">Menu</code>, and <code class="literal">Accelerator</code> classes, which are useful for document-based Windows applications.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec53"/>The Document class</h1></div></div></div><p>In this book, a <strong>document</strong> is a window intended for common document-based applications, such as the drawing program, spreadsheet program, and word processor of this book. The <code class="literal">Document</code> class implements the document described previously and is a direct subclass of the <code class="literal">Window</code> class. It supports caret and dirty flag, keyboard status, menus, accelerators, the mouse wheel, scroll bars, and drop files.</p><p>
<strong>Document.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  extern const Size USLetterPortrait, LineSize; &#13;
</pre><p>The keyboard holds either the <code class="literal">insert</code> or <code class="literal">overwrite</code> mode.</p><pre class="programlisting">  enum KeyboardMode {InsertKeyboard, OverwriteKeyboard}; &#13;
</pre><p>Similar to <code class="literal">Window</code>, <code class="literal">Document</code> has a public constructor intended for instantiation and a protected constructor intended for subclasses. A document of the <code class="literal">Document</code> class can accept drop files, and the line size is used by the scroll bar methods:</p><pre class="programlisting">  class Document : public Window { &#13;
    public: &#13;
      Document(CoordinateSystem system, Size pageSize, &#13;
               Window* parentPtr = nullptr, &#13;
               WindowStyle style=OverlappedWindow, &#13;
               WindowShow windowShow = Normal, &#13;
               bool acceptDropFiles = true, &#13;
               Size lineSize = LineSize); &#13;
 &#13;
    protected: &#13;
      Document(String className, CoordinateSystem system, &#13;
               Size pageSize, Window* parentPtr = nullptr, &#13;
               WindowStyle style = OverlappedWindow, &#13;
               WindowShow windowShow = Normal, &#13;
               bool acceptDropFiles = true, &#13;
               Size lineSize = LineSize); &#13;
</pre><p>A dirty flag is set if the window has been modified and needs to be saved before closing (the document has been <em>dirty</em>). The content of the document can be zoomed in accordance with a zoom factor; the default is 1.0. The name of the document is displayed in the document header by <code class="literal">GenerateHeader</code>, together with the zoom factor expressed as a percentage, and an asterisk (<strong>*</strong>) if the dirty flag is <code class="literal">true</code>. However, the zoom factor is not displayed if it is 100%:</p><pre class="programlisting">    public: &#13;
      ~Document(); &#13;
 &#13;
      String GetName() const; &#13;
      void SetName(String name); &#13;
      void SetZoom(double zoom); &#13;
      bool IsDirty() const; &#13;
      void SetDirty(bool dirty); &#13;
       &#13;
    private: &#13;
      void GenerateHeader();  &#13;
</pre><p>The <code class="literal">OnSize</code> method is overridden to modify the size of the scroll bar in accordance with the client size. Note that the parameter to <code class="literal">OnSize</code> is the logical size of the client area, not the size of the window:</p><pre class="programlisting">    public: &#13;
      virtual void OnSize(Size clientSize); &#13;
</pre><p>The <code class="literal">OnMouseWheel</code> method is overridden to scroll the vertical scroll bar one line for each wheel click:</p><pre class="programlisting">      virtual void OnMouseWheel(WheelDirection direction, &#13;
                          bool shiftPressed, bool controlPressed); &#13;
</pre><p>The <code class="literal">Document</code> class supports the caret, and the <code class="literal">OnGainFocus</code> and <code class="literal">OnLoseFocus</code> methods are overridden to show or hide the caret. The <code class="literal">SetCaret</code> and <code class="literal">ClearCaret</code> methods create and destroy the caret:</p><pre class="programlisting">      void OnGainFocus(); &#13;
      void OnLoseFocus(); &#13;
      void SetCaret(Rect caretLogicalRect); &#13;
      void ClearCaret(); &#13;
</pre><p>The <code class="literal">UpdateCaret</code> method is called when the caret needs to be modified, it is intended to be overridden and its default behavior is to do nothing:</p><pre class="programlisting">      virtual void UpdateCaret() {/* Empty. */} &#13;
</pre><p>The <code class="literal">SetMenuBar</code> method sets the menu bar of the window. The <code class="literal">OnCommand</code> method is called every time the user selects a menu item or presses an accelerator key, and <code class="literal">CommandInit</code> is called before the menus become visible in order to set a check mark or a radio button at the menu item or to enable or disable it:</p><pre class="programlisting">      void SetMenuBar(Menu&amp; menuBar); &#13;
      void OnCommand(WORD commandId); &#13;
      void OnCommandInit(); &#13;
</pre><p>If the <code class="literal">acceptDropFiles</code> parameter in the constructor is <code class="literal">true</code>, the document accepts drop files. If the user moves one or several files and drops them in the document window, <code class="literal">OnDropFile</code> is called with the list of path names as parameters. It is intended to be overridden by subclasses, and its default behavior is to do nothing:</p><pre class="programlisting">      virtual void OnDropFile(vector&lt;String&gt; pathList) &#13;
                             {/* Empty. */} &#13;
</pre><p>The <code class="literal">GetKeyboardMode</code> and <code class="literal">SetKeyboardMode</code> methods set and get the <code class="literal">keyboard</code> mode. The <code class="literal">OnKeyboardMode</code> method is called when the <code class="literal">keyboard</code> mode is changed; it is intended to be overridden and its default behavior is to do nothing:</p><pre class="programlisting">      KeyboardMode GetKeyboardMode() const {return keyboardMode;} &#13;
      void SetKeyboardMode(KeyboardMode mode) &#13;
                          {keyboardMode = mode;} &#13;
      virtual void OnKeyboardMode(KeyboardMode mode) &#13;
                                 {/* Empty. */} &#13;
</pre><p>The <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods handle the scroll messages. The scroll bar is set in accordance with the message settings:</p><pre class="programlisting">      virtual void OnHorizontalScroll(WORD flags,WORD thumbPos=0); &#13;
      virtual void OnVerticalScroll(WORD flags, WORD thumbPos =0); &#13;
</pre><p>The <code class="literal">KeyToScroll</code> method takes a key and performs an appropriate scroll bar action depending on the key and whether the <em>
<strong>Shift</strong>
</em> or <em>
<strong>Ctrl</strong>
</em> key is pressed. For instance, the <em>
<strong>Page Up</strong>
</em> key moves the vertical scroll bar one page upward:</p><pre class="programlisting">      virtual bool KeyToScroll(WORD key, bool shiftPressed, &#13;
                               bool controlPressed); &#13;
</pre><p>The following methods set or get the logical position, line size, page size, and total size of the horizontal and vertical scroll bar:</p><pre class="programlisting">      void SetHorizontalScrollPosition(int scrollPos); &#13;
      int GetHorizontalScrollPosition() const; &#13;
      void SetVerticalScrollPosition(int scrollPos); &#13;
      int GetVerticalScrollPosition() const; &#13;
 &#13;
      void SetHorizontalScrollLineWidth(int lineWidth); &#13;
      int GetHorizontalScrollLineHeight() const; &#13;
      void SetVerticalScrollLineHeight(int lineHeight); &#13;
      int GetVerticalScrollLineHeight() const; &#13;
 &#13;
      void SetHorizontalScrollPageWidth(int pageWidth); &#13;
      int GetHorizontalScrollPageWidth() const; &#13;
      void SetVerticalScrollPageHeight(int pageHeight); &#13;
      int GetVerticalScrollPageHeight() const; &#13;
 &#13;
      void SetHorizontalScrollTotalWidth(int scrollWidth); &#13;
      int GetHorizontalScrollTotalWidth() const; &#13;
      void SetVerticalScrollTotalHeight(int scrollHeight); &#13;
      int GetVerticalScrollTotalHeight() const; &#13;
</pre><p>The command map stores the menu items of the document; for each menu item, the selection, enable, check, and radio listeners are stored:</p><pre class="programlisting">    public: &#13;
      map&lt;WORD,Command&gt;&amp; CommandMap() {return commandMap;} &#13;
</pre><p>The accelerator set holds the accelerators of the document irrespective of whether it is a regular key or virtual key (for instance, <em>
<strong>F2</strong>
</em>, <em>
<strong>Home</strong>
</em>, or <em>
<strong>Delete</strong>
</em>) and whether the <em>
<strong>Ctrl</strong>
</em>, <em>
<strong>Shift</strong>
</em>, or <em>
<strong>Alt</strong>
</em> key is pressed. The set is used by the message loop in <code class="literal">Application</code>:</p><pre class="programlisting">      list&lt;ACCEL&gt;&amp; AcceleratorSet() {return acceleratorSet;} &#13;
 &#13;
    private: &#13;
      map&lt;WORD, Command&gt; commandMap; &#13;
      list&lt;ACCEL&gt; acceleratorSet; &#13;
</pre><p>The <code class="literal">name</code> field is the name of the document displayed at the top of the window; <code class="literal">caretPresent</code> is true when the caret is visible:</p><pre class="programlisting">      String name; &#13;
      bool caretPresent = false; &#13;
</pre><p>When the user presses one of the arrow keys, <code class="literal">OnKeyDown</code> is called. However, if <code class="literal">OnKeyDown</code> returns <code class="literal">false</code>, the scroll bar is changed; in that case, we need <code class="literal">lineSize</code> to define the size of a line to be scrolled:</p><pre class="programlisting">      Size lineSize; &#13;
</pre><p>The <code class="literal">dirtyFlag</code> field is <code class="literal">true</code> when the user has changed the document without saving, resulting in the <strong>Save</strong> menu item being enabled and the user being asked whether to save the document when closing the window or exiting the application:</p><pre class="programlisting">      bool dirtyFlag = false; &#13;
</pre><p>The <code class="literal">menuBarHandle</code> method is the Win32 API function that handles the menu bar of the document window:</p><pre class="programlisting">      HMENU menuBarHandle; &#13;
</pre><p>The keyboard can hold the <code class="literal">insert</code> or <code class="literal">overwrite</code> mode, which is stored in <code class="literal">keyboardMode</code>:</p><pre class="programlisting">      KeyboardMode keyboardMode = InsertKeyboard; &#13;
  }; &#13;
</pre><p>The <code class="literal">DocumentProc</code> method is called when the document window receives a message, similar to <code class="literal">WindowProc</code> in the <code class="literal">Window</code> class:</p><pre class="programlisting">  LRESULT CALLBACK DocumentProc(HWND windowHandle, UINT message, &#13;
                           WPARAM wordParam,LPARAM longParam); &#13;
</pre><p>The <code class="literal">ExtractPathList</code> method extracts the paths of the dropped files when the window receives the <code class="literal">WM_DROPFILES</code> message:</p><pre class="programlisting">  vector&lt;String&gt; ExtractPathList(WORD wordParam); &#13;
}; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch11lvl2sec97"/>Initialization</h2></div></div></div><p>The first <code class="literal">Document</code> constructor takes the coordinate system, the page size, parent window, style, appearance, whether the document accepts drop files, and the line size as its parameters. The size of a US Letter page in portrait mode (standing up) is 215.9 * 279.4 millimeters. A line (used by <code class="literal">KeyToScroll</code> when scrolling lines) is 5 millimeters in both the horizontal and vertical directions. Since a logical unit is one hundredth of a millimeter, we multiply each measure by one hundred.</p><p>
<strong>Document.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  const Size USLetterPortrait(21590, 27940), LineSize(500, 500); &#13;
</pre><p>The first constructor calls the second constructor with the <code class="literal">Windows</code> class named <code class="literal">Document</code> as the first parameter:</p><pre class="programlisting">  Document::Document(CoordinateSystem system, Size pageSize, &#13;
                     Window* parentPtr /* = nullptr */, &#13;
                     WindowStyle style /* = OverlappedWindow */, &#13;
                     WindowShow windowShow /* = Normal */, &#13;
                     bool acceptDropFiles /* = true */, &#13;
                     Size lineSize /* = LineSize */) &#13;
   :Document::Document(TEXT("document"), system, pageSize, &#13;
                       parentPtr, style, windowShow, &#13;
                       acceptDropFiles, lineSize) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The second constructor takes the same parameters as the first construct with the exception that it inserts the <code class="literal">Windows</code> class name as its first parameter:</p><pre class="programlisting">  Document::Document(String className, CoordinateSystem system, &#13;
                     Size pageSize, Window* parentPtr/*=nullptr*/, &#13;
                     WindowStyle style /* = OverlappedWindow */, &#13;
                     WindowShow windowShow /* = Normal */, &#13;
                     bool acceptDropFiles /* = true */, &#13;
                     Size lineSize /* = LineSize */) &#13;
   :Window(className, system, pageSize, parentPtr, &#13;
           style, NoStyle, windowShow), &#13;
</pre><p>The range and page size of the scroll bars are stored in the window's scroll bar settings. However, the size of the line needs to be stored in <code class="literal">lineSize</code>:</p><pre class="programlisting">    lineSize(lineSize) { &#13;
</pre><p>The header appears on the top bar of the document window:</p><pre class="programlisting">    GenerateHeader(); &#13;
</pre><p>The default position of the scroll bars is <code class="literal">0</code>:</p><pre class="programlisting">    SetHorizontalScrollPosition(0); &#13;
    SetVerticalScrollPosition(0); &#13;
</pre><p>The size of the scroll bars is the logical width and height of the page:</p><pre class="programlisting">    SetHorizontalScrollTotalWidth(pageSize.Width()); &#13;
    SetVerticalScrollTotalHeight(pageSize.Height()); &#13;
</pre><p>The page sizes of the scroll bars represent the visible part of the document, which is the logical size of the client area:</p><pre class="programlisting">    Size clientSize = GetClientSize(); &#13;
    SetHorizontalScrollPageWidth(clientSize.Width()); &#13;
    SetVerticalScrollPageHeight(clientSize.Height()); &#13;
</pre><p>The Win32 API function <code class="literal">DragAcceptFiles</code> makes the window accept drop files. Note that we need to convert the C++ <code class="literal">bool</code> type of <code class="literal">acceptDropFiles</code> to the value <code class="literal">TRUE</code> or <code class="literal">FALSE</code> of the Win32 API <code class="literal">BOOL</code> type:</p><pre class="programlisting">    ::DragAcceptFiles(windowHandle, &#13;
                      acceptDropFiles ? TRUE : FALSE); &#13;
  } &#13;
</pre><p>The destructor destroys the caret if present:</p><pre class="programlisting">  Document::~Document() { &#13;
    if (caretPresent) { &#13;
      ::DestroyCaret(); &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec98"/>The Document header</h2></div></div></div><p>The <code class="literal">GetName</code> method simply returns the name. However, <code class="literal">SetName</code> sets the name and regenerates the header of the document window. The same goes for <code class="literal">SetZoom</code> and <code class="literal">SetDirty</code>: they set the zoom factor and dirty flag and then regenerate the header:</p><pre class="programlisting">  String Document::GetName() const { &#13;
    return name; &#13;
  }  &#13;
&#13;
  void Document::SetName(String name) { &#13;
    this-&gt;name = name; &#13;
    GenerateHeader(); &#13;
  }  &#13;
&#13;
&#13;
&#13;
&#13;
  void Document::SetZoom(double zoom) { &#13;
    Window::SetZoom(zoom); &#13;
    GenerateHeader(); &#13;
  } &#13;
&#13;
  bool Document::IsDirty() const { &#13;
    return dirtyFlag; &#13;
  }  &#13;
&#13;
  void Document::SetDirty(bool dirty) { &#13;
    dirtyFlag = dirty; &#13;
    GenerateHeader(); &#13;
  } &#13;
</pre><p>The title of the document includes its name, whether the dirty flag is set (indicated by an asterisk), and the zoom status (as a percentage), unless it is 100%.</p><pre class="programlisting">  void Document::GenerateHeader() { &#13;
    String headerName = name.empty() ? TEXT("[No Name]") : name, &#13;
           dirtyText = dirtyFlag ? TEXT("*") : TEXT(""); &#13;
    int zoomPerCent = (int) (100 * GetZoom()); &#13;
 &#13;
    if (zoomPerCent!= 100) { &#13;
      String zoomText = &#13;
        TEXT(" ") + to_String(zoomPerCent) + TEXT("%"); &#13;
      SetHeader(headerName + dirtyText + zoomText); &#13;
    } &#13;
    else { &#13;
      SetHeader(headerName + dirtyText); &#13;
    } &#13;
  } &#13;
</pre><p>
<code class="literal">OnSize</code> modifies the page sizes of the horizontal and vertical scroll bars in accordance with the new client size:</p><pre class="programlisting">  void Document::OnSize(Size clientSize) { &#13;
    SetHorizontalScrollPageWidth(clientSize.Width()); &#13;
    SetVerticalScrollPageHeight(clientSize.Height()); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec99"/>The caret</h2></div></div></div><p>As mentioned in <a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>, <em>Introduction</em>, a caret is the marker indicating where to input the next character. It is a thin vertical bar in the <code class="literal">insert</code> mode and a block in the <code class="literal">overwrite</code> mode. The <code class="literal">OnGainFocus</code> and <code class="literal">OnLoseFocus</code> methods show and hide the caret, if present:</p><pre class="programlisting">  void Document::OnGainFocus() { &#13;
    if (caretPresent) { &#13;
      ::ShowCaret(windowHandle); &#13;
    } &#13;
  } &#13;
 &#13;
  void Document::OnLoseFocus() { &#13;
    if (caretPresent) { &#13;
      ::HideCaret(windowHandle); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">SetCaret</code> method displays a caret with the given dimensions. If there already is a caret present, it is destroyed:</p><pre class="programlisting">  void Document::SetCaret(Rect caretLogicalRect) { &#13;
    if (caretPresent) { &#13;
      ::DestroyCaret(); &#13;
    } &#13;
</pre><p>The size of the caret must be given in device units; there is a risk that the <code class="literal">LogicalToDevice</code> call rounds the width to zero (in the case of a vertical bar), in which case the width is set to 1:</p><pre class="programlisting">    Rect deviceCaretRect = LogicalToDevice(caretLogicalRect); &#13;
    if (deviceCaretRect.Width() == 0) {       &#13;
      deviceCaretRect.Right() = deviceCaretRect.Left() + 1; &#13;
    } &#13;
</pre><p>The new caret is created by the Win32 API functions <code class="literal">CreateCaret</code>, <code class="literal">SetCaretPos</code>, and <code class="literal">ShowCaret</code>:</p><pre class="programlisting">    ::CreateCaret(windowHandle, nullptr, deviceCaretRect.Width(), &#13;
                  deviceCaretRect.Height()); &#13;
    ::SetCaretPos(deviceCaretRect.Left(), deviceCaretRect.Top()); &#13;
    ::ShowCaret(windowHandle); &#13;
 &#13;
    caretPresent = true; &#13;
  } &#13;
</pre><p>The <code class="literal">ClearCaret</code> method destroys the caret, if present:</p><pre class="programlisting">  void Document::ClearCaret() { &#13;
    if (caretPresent) { &#13;
      ::DestroyCaret(); &#13;
    }  &#13;
    caretPresent = false; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec100"/>The mouse wheel</h2></div></div></div><p>When the user moves the mouse wheel, the vertical scroll bar is moved one line up or down (if they do not press the <em>Ctrl</em> key):</p><pre class="programlisting">  void Document::OnMouseWheel(WheelDirection wheelDirection, &#13;
                        bool shiftPressed, bool controlPressed){ &#13;
    if (controlPressed) { &#13;
      switch (wheelDirection) { &#13;
        case WheelUp: &#13;
          OnVerticalScroll(SB_LINEUP); &#13;
          break; &#13;
 &#13;
        case WheelDown: &#13;
          OnVerticalScroll(SB_LINEDOWN); &#13;
          break; &#13;
      } &#13;
    } &#13;
</pre><p>If the user presses the <em>
<strong>Ctrl</strong>
</em> key, then the client area is zoomed. The permitted range is 10% to 1,000%:</p><pre class="programlisting">    else { &#13;
      switch (wheelDirection) { &#13;
        case WheelUp: &#13;
          SetZoom(min(10.0, 1.11 * GetZoom())); &#13;
          break; &#13;
 &#13;
        case WheelDown: &#13;
          SetZoom(max(0.1, 0.9 * GetZoom())); &#13;
          break; &#13;
      } &#13;
    } &#13;
</pre><p>As the vertical scroll bar position has been modified, we need to repaint the whole client area:</p><pre class="programlisting">    Invalidate(); &#13;
    UpdateWindow(); &#13;
    UpdateCaret(); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec101"/>The menu bar</h2></div></div></div><p>The menu bar of the document is set by calling the Win32 API function <code class="literal">SetMenu</code>, which handles the document window and the menu bar; <code class="literal">menuBarHandle</code> is used when enabling or marking menu items in <code class="literal">OnCommandInit</code>, as shown here:</p><pre class="programlisting">  void Document::SetMenuBar(Menu&amp; menuBar) { &#13;
    menuBarHandle = menuBar.menuHandle; &#13;
    ::SetMenu(windowHandle, menuBarHandle); &#13;
  } &#13;
</pre><p>The <code class="literal">OnCommand</code> method is called when the user selects a menu item or an accelerator. It looks up and calls the selection listener associated with the given command identity number:</p><pre class="programlisting">  void Document::OnCommand(WORD commandId) { &#13;
    Command command = commandMap[commandId]; &#13;
    command.Selection()(this); &#13;
  } &#13;
</pre><p>The <code class="literal">OnCommandInit</code> method is called before a menu becomes visible. It iterates through every menu item and, for each of them, decides whether it should be annotated with a check mark or radio button, or enabled or disabled:</p><pre class="programlisting">  void Document::OnCommandInit() { &#13;
    for (pair&lt;WORD,Command&gt; pair : commandMap) { &#13;
      WORD commandId = pair.first; &#13;
      Command command = pair.second; &#13;
</pre><p>If the enable listener is not null, we call it and set the enable flag to <code class="literal">MF_ENABLED</code> or <code class="literal">MF_GRAYED</code> (disabled):</p><pre class="programlisting">      if (command.Enable() != nullptr) { &#13;
        UINT enableFlag = command.Enable()(this) ? &#13;
                          MF_ENABLED : MF_GRAYED; &#13;
        ::EnableMenuItem(menuBarHandle, commandId, &#13;
                         MF_BYCOMMAND | enableFlag); &#13;
      } &#13;
</pre><p>If the check or radio listeners are not null, we call them and set <code class="literal">checkflag</code> or <code class="literal">radioFlag</code>:</p><pre class="programlisting">      { bool checkFlag = false; &#13;
        if (command.Check() != nullptr) { &#13;
          BoolListener checkListener = command.Check(); &#13;
          checkFlag = checkListener(this); &#13;
        } &#13;
         &#13;
        bool radioFlag = false; &#13;
        if (command.Radio() != nullptr) { &#13;
          BoolListener radioListener = command.Radio(); &#13;
          radioFlag = radioListener(this); &#13;
        } &#13;
</pre><p>If either <code class="literal">checkFlag</code> or <code class="literal">radioFlag</code> is <code class="literal">true</code>, we check the menu item. Whether the menu item thereby becomes annotated with a check mark or a radio button is decided when the menu item is added to the menu, which is described in the <code class="literal">Menu</code> class in the next section. It is also stated in <code class="literal">Menu</code> that at least one of the check mark and radio listeners must be null, since it is not possible to annotate a menu item with both a check mark and a radio button:</p><pre class="programlisting">        UINT checkFlags = (checkFlag | radioFlag) ? &#13;
                          MF_CHECKED : MF_UNCHECKED; &#13;
        ::CheckMenuItem(menuBarHandle, commandId, &#13;
                        MF_BYCOMMAND | checkFlags); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec102"/>The scroll bar</h2></div></div></div><p>The <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods are called every time the user scrolls by clicking the scroll bar arrows, the scroll bar itself, or by dragging the scroll thumb.</p><p>The <code class="literal">scrollPos</code> field holds the current scroll bar setting. The <code class="literal">scrollLine</code> variable is the size of the line, <code class="literal">scrollPage</code> is the size of the page (representing the logical size of the visible part of the document and equal to the logical size of the client area), and <code class="literal">scrollSize</code> is the total size of the scroll bar (representing the logical size of the document):</p><pre class="programlisting">  void Document::OnHorizontalScroll(WORD flags, &#13;
                                    WORD thumbPos /*= 0 */) { &#13;
    int scrollPos = GetHorizontalScrollPosition(), &#13;
        scrollLine = GetHorizontalScrollLineHeight(), &#13;
        scrollPage = GetHorizontalScrollPageWidth(), &#13;
        scrollSize = GetHorizontalScrollTotalWidth(); &#13;
 &#13;
    switch (flags) { &#13;
      case SB_LEFT: &#13;
        SetHorizontalScrollPosition(0); &#13;
        break; &#13;
</pre><p>In the case of leftward movement, we need to verify that the new scroll position doesn't go below zero:</p><pre class="programlisting">      case SB_LINELEFT: &#13;
        SetHorizontalScrollPosition(max(0, scrollPos - &#13;
                                           scrollLine)); &#13;
        break; &#13;
 &#13;
      case SB_PAGELEFT: &#13;
        SetHorizontalScrollPosition(max(0, scrollPos - &#13;
                                           scrollPage)); &#13;
        break; &#13;
</pre><p>In the case of rightward movement, we need to verify that the scroll position does not exceed the scroll bar size:</p><pre class="programlisting">      case SB_LINERIGHT: &#13;
        SetHorizontalScrollPosition(min(scrollPos + scrollLine, &#13;
                                        scrollSize - scrollLine)); &#13;
        break; &#13;
 &#13;
      case SB_PAGERIGHT: &#13;
        SetHorizontalScrollPosition(min(scrollPos + scrollLine, &#13;
                                        scrollSize - scrollPage)); &#13;
        break; &#13;
 &#13;
      case SB_RIGHT: &#13;
        SetHorizontalScrollPosition(scrollSize - scrollPage); &#13;
        break; &#13;
</pre><p>If the user drags the scroll bar thumb, we just set the new scroll position. The difference between the messages is that <code class="literal">SB_THUMBTRACK</code> is sent continually as the user drags the thumb, while <code class="literal">SB_THUMBPOSITION</code> is sent when the user releases the mouse button:</p><pre class="programlisting">      case SB_THUMBTRACK: &#13;
      case SB_THUMBPOSITION: &#13;
        SetHorizontalScrollPosition(thumbPos); &#13;
        break; &#13;
    } &#13;
  } &#13;
</pre><p>Vertical scroll bar movements work in the same way as horizontal scroll bar movements:</p><pre class="programlisting">  void Document::OnVerticalScroll(WORD flags, &#13;
                                  WORD thumbPos /* = 0 */) { &#13;
    int scrollPos = GetVerticalScrollPosition(), &#13;
        scrollLine = GetVerticalScrollLineHeight(), &#13;
        scrollPage = GetVerticalScrollPageHeight(), &#13;
        scrollSize = GetVerticalScrollTotalHeight(); &#13;
 &#13;
    switch (flags) { &#13;
      case SB_TOP: &#13;
        SetVerticalScrollPosition(0); &#13;
        break; &#13;
 &#13;
&#13;
      case SB_LINEUP: &#13;
        SetVerticalScrollPosition(max(0, scrollPos - scrollLine)); &#13;
        break; &#13;
 &#13;
      case SB_PAGEUP: &#13;
        SetVerticalScrollPosition(max(0, scrollPos - scrollPage)); &#13;
        break; &#13;
 &#13;
      case SB_LINEDOWN: &#13;
        SetVerticalScrollPosition(min(scrollPos + scrollLine, &#13;
                                      scrollSize - scrollLine)); &#13;
        break; &#13;
 &#13;
      case SB_PAGEDOWN: &#13;
        SetVerticalScrollPosition(min(scrollPos + scrollLine, &#13;
                                      scrollSize - scrollPage)); &#13;
        break; &#13;
 &#13;
      case SB_BOTTOM: &#13;
        SetVerticalScrollPosition(scrollSize - scrollPage); &#13;
        break; &#13;
 &#13;
      case SB_THUMBTRACK: &#13;
      case SB_THUMBPOSITION: &#13;
        SetVerticalScrollPosition(thumbPos); &#13;
        break; &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">KeyToScroll</code> function is called when the user presses a key. It examines the key, performs an appropriate scroll action, and returns <code class="literal">true</code> if the key was used, indicating as much:</p><pre class="programlisting">  bool Document::KeyToScroll(WORD key, bool shiftPressed, &#13;
                             bool controlPressed) { &#13;
    switch (key) { &#13;
      case KeyUp: &#13;
        OnVerticalScroll(SB_LINEUP); &#13;
        return true; &#13;
 &#13;
      case KeyDown: &#13;
        OnVerticalScroll(SB_LINEDOWN); &#13;
        return true; &#13;
 &#13;
      case KeyPageUp: &#13;
        OnVerticalScroll(SB_PAGEUP); &#13;
        return true; &#13;
 &#13;
      case KeyPageDown: &#13;
        OnVerticalScroll(SB_PAGEDOWN); &#13;
        return true; &#13;
 &#13;
      case KeyLeft: &#13;
        OnHorizontalScroll(SB_LINELEFT); &#13;
        return true; &#13;
 &#13;
      case KeyRight: &#13;
        OnHorizontalScroll(SB_LINERIGHT); &#13;
        return true; &#13;
 &#13;
      case KeyHome: &#13;
        OnHorizontalScroll(SB_LEFT); &#13;
        if (controlPressed) { &#13;
          OnVerticalScroll(SB_TOP); &#13;
        } &#13;
        return true; &#13;
 &#13;
      case KeyEnd: &#13;
        OnHorizontalScroll(SB_RIGHT); &#13;
        if (controlPressed) { &#13;
          OnVerticalScroll(SB_BOTTOM); &#13;
        } &#13;
        return true; &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>If the scroll position has been changed, we set the new scroll position by calling the Win32 API function <code class="literal">SetScrollPos</code> and update the window and the caret:</p><pre class="programlisting">  void Document::SetHorizontalScrollPosition(int scrollPos) { &#13;
    if (scrollPos != GetHorizontalScrollPosition()) { &#13;
      ::SetScrollPos(windowHandle, SB_HORZ, scrollPos, TRUE); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
      UpdateCaret(); &#13;
    } &#13;
  } &#13;
</pre><p>The Win32 API function <code class="literal">GetScrollPos</code> returns the current scroll bar position:</p><pre class="programlisting">  int Document::GetHorizontalScrollPosition() const { &#13;
    return ::GetScrollPos(windowHandle, SB_HORZ); &#13;
  } &#13;
</pre><p>The methods for the vertical scroll position work in the same way as the methods for the horizontal scroll bar:</p><pre class="programlisting">  void Document::SetVerticalScrollPosition(int scrollPos) { &#13;
    if (scrollPos != GetVerticalScrollPosition()) { &#13;
      ::SetScrollPos(windowHandle, SB_VERT, scrollPos, TRUE); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
      UpdateCaret(); &#13;
    } &#13;
  }  &#13;
&#13;
  int Document::GetVerticalScrollPosition() const { &#13;
    return ::GetScrollPos(windowHandle, SB_VERT); &#13;
  } &#13;
</pre><p>The <code class="literal">SetHorizontalScrollLineWidth</code>, <code class="literal">GetHorizontalScrollLineHeight</code>, <code class="literal">SetVerticalScrollLineHeight</code>, and <code class="literal">GetVerticalScrollLineHeight</code> methods have no Win32 API counterparts. Instead, we store the size of a scrolled line in the <code class="literal">lineSize</code> field:</p><pre class="programlisting">  void Document::SetHorizontalScrollLineWidth(int lineWidth) { &#13;
    lineSize.Width() = lineWidth; &#13;
  } &#13;
 &#13;
  int Document::GetHorizontalScrollLineHeight() const { &#13;
    return lineSize.Width(); &#13;
  } &#13;
 &#13;
  void Document::SetVerticalScrollLineHeight(int lineHeight) { &#13;
    lineSize.Height() = lineHeight; &#13;
  } &#13;
 &#13;
  int Document::GetVerticalScrollLineHeight() const { &#13;
    return lineSize.Height(); &#13;
  } &#13;
</pre><p>The <code class="literal">SetHorizontalScrollPageWidth</code>, <code class="literal">GetHorizontalScrollPageWidth</code>, <code class="literal">SetVerticalScrollPageHeight</code>, and <code class="literal">GetVerticalScrollPageHeight</code> methods have no direct Win32 API counterparts. However, the <code class="literal">GetScrollInfo</code> and <code class="literal">SetScrollInfo</code> functions handle the general scroll information, and we can set and extract the page information:</p><pre class="programlisting">  void Document::SetHorizontalScrollPageWidth(int pageWidth) { &#13;
    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; &#13;
    scrollInfo.nPage = pageWidth; &#13;
&#13;
    ::SetScrollInfo(windowHandle, SB_HORZ, &amp;scrollInfo, TRUE); &#13;
  } &#13;
 &#13;
  int Document::GetHorizontalScrollPageWidth() const { &#13;
    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; &#13;
    ::GetScrollInfo(windowHandle, SB_HORZ, &amp;scrollInfo); &#13;
    return scrollInfo.nPage; &#13;
  } &#13;
 &#13;
  void Document::SetVerticalScrollPageHeight(int pageHeight) { &#13;
    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; &#13;
    scrollInfo.nPage = pageHeight; &#13;
    ::SetScrollInfo(windowHandle, SB_VERT, &amp;scrollInfo, TRUE); &#13;
  } &#13;
 &#13;
  int Document::GetVerticalScrollPageHeight() const { &#13;
    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; &#13;
    ::GetScrollInfo(windowHandle, SB_VERT, &amp;scrollInfo); &#13;
    return scrollInfo.nPage; &#13;
  } &#13;
</pre><p>The <code class="literal">SetHorizontalScrollTotalWidth</code>, <code class="literal">GetHorizontalScrollTotalWidth</code>, <code class="literal">SetVerticalScrollTotalHeight</code>, and <code class="literal">GetVerticalScrollTotalHeight</code> methods call the Win32 API functions <code class="literal">SetScrollRange</code> and <code class="literal">GetScrollRange</code>, which set and get the minimum and maximum scroll values. However, we ignore the minimum value since it is always 0:</p><pre class="programlisting">  void Document::SetHorizontalScrollTotalWidth(int scrollWidth) { &#13;
    ::SetScrollRange(windowHandle, SB_HORZ, 0, scrollWidth, TRUE); &#13;
  } &#13;
 &#13;
  int Document::GetHorizontalScrollTotalWidth() const { &#13;
    int minRange, maxRange; &#13;
    ::GetScrollRange(windowHandle, SB_HORZ, &amp;minRange, &amp;maxRange); &#13;
    return maxRange; &#13;
  } &#13;
 &#13;
  void Document::SetVerticalScrollTotalHeight(int scrollHeight) { &#13;
    ::SetScrollRange(windowHandle, SB_VERT, 0, scrollHeight,TRUE); &#13;
  } &#13;
 &#13;
  int Document::GetVerticalScrollTotalHeight() const { &#13;
    int minRange, maxRange; &#13;
    ::GetScrollRange(windowHandle, SB_VERT, &amp;minRange, &amp;maxRange); &#13;
    return maxRange; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec103"/>The DocumentProc method</h2></div></div></div><p>The <code class="literal">DocumentProc</code> method is called every time the document (of the <code class="literal">Document</code> class) receives a message. If it uses the message, 0 is returned; otherwise, <code class="literal">WindowProc</code> (described in the previous chapter) is called to further process the message:</p><pre class="programlisting">LRESULT CALLBACK DocumentProc(HWND windowHandle, UINT message, &#13;
                              WPARAM wordParam, LPARAM longParam){ &#13;
</pre><p>We look up the window in <code class="literal">WindowMap</code> in the <code class="literal">Window</code> class and take action only if the window is a <code class="literal">Document</code> object:</p><pre class="programlisting">    if ((windowHandle != nullptr) &amp;&amp;&#13;
        (WindowMap.count(windowHandle) == 1)) {&#13;
      Document* documentPtr = &#13;
        dynamic_cast&lt;Document*&gt;(WindowMap[windowHandle]); &#13;
 &#13;
      if (documentPtr != nullptr) { &#13;
        switch (message) { &#13;
</pre><p>The direction of the mouse wheel is downward if the word parameter's ninth bit is set:</p><pre class="programlisting">          case WM_MOUSEWHEEL: { &#13;
              bool down = (HIWORD(wordParam) &amp; 0x0100) != 0; &#13;
              WheelDirection wheelDirection = &#13;
                down ? WheelDown : WheelUp; &#13;
              bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
              bool controlPressed = (::GetKeyState(VK_CONTROL)&lt;0); &#13;
              documentPtr-&gt;OnMouseWheel(wheelDirection, &#13;
                             shiftPressed, controlPressed); &#13;
            } &#13;
            return 0; &#13;
</pre><p>The key-down messages both check the <em>
<strong>Insert</strong>
</em> key and call <code class="literal">OnKeyDown</code> and <code class="literal">KeyToScroll</code>, returning 0 if one of them uses the key:</p><pre class="programlisting">          case WM_KEYDOWN: { &#13;
              WORD key = wordParam; &#13;
</pre><p>If the user presses the <em>Insert</em> key, the keyboard mode is swapped between the insert and overwrite mode. <code class="literal">SetKeyboardMode</code> sets the keyboard mode and calls <code class="literal">OnKeyboardMode</code>, which is intended to be overridden by subclasses to alert the application of the change:</p><pre class="programlisting">              if (key == KeyInsert) { &#13;
                switch (documentPtr-&gt;GetKeyboardMode()) { &#13;
&#13;
&#13;
                  case InsertKeyboard: &#13;
                    documentPtr-&gt; &#13;
                      SetKeyboardMode(OverwriteKeyboard); &#13;
                    documentPtr-&gt; &#13;
                      OnKeyboardMode(OverwriteKeyboard); &#13;
                    break; &#13;
 &#13;
                  case OverwriteKeyboard: &#13;
                    documentPtr-&gt;SetKeyboardMode(InsertKeyboard); &#13;
                    documentPtr-&gt;OnKeyboardMode(InsertKeyboard); &#13;
                    break; &#13;
                } &#13;
 &#13;
                return 0; &#13;
              } &#13;
</pre><p>If the user does not press the <em>
<strong>Insert</strong>
</em> key, we check whether <code class="literal">OnKeyDown</code> uses the key (and thereby returns <code class="literal">true</code>). If it does not, we instead check whether <code class="literal">KeyToScroll</code> uses the key. If either <code class="literal">OnKeyDown</code> or <code class="literal">KeyToScroll</code> returns <code class="literal">true</code>, 0 is returned:</p><pre class="programlisting">              else { &#13;
                bool shiftPressed = (::GetKeyState(VK_SHIFT) &lt; 0); &#13;
                bool controlPressed=(::GetKeyState(VK_CONTROL)&lt;0); &#13;
 &#13;
                if (documentPtr-&gt;OnKeyDown(wordParam,shiftPressed, &#13;
                                           controlPressed) || &#13;
                    documentPtr-&gt;KeyToScroll(key, shiftPressed, &#13;
                                           controlPressed)) { &#13;
                return 0; &#13;
                } &#13;
              } &#13;
            } &#13;
            break; &#13;
</pre><p>The <code class="literal">WM_COMMAND</code> case is sent when the user selects a menu item, and <code class="literal">WM_INITMENUPOPUP</code> is sent before a menu becomes visible. Messages are handled by calling <code class="literal">OnCommand</code>, which executes the selection listener connected to the menu item, and <code class="literal">OnCommandInit</code>, which enables or annotates menu items with check marks or radio buttons before they become visible:</p><pre class="programlisting">          case WM_COMMAND: &#13;
            documentPtr-&gt;OnCommand(LOWORD(wordParam)); &#13;
            return 0; &#13;
 &#13;
          case WM_INITMENUPOPUP: &#13;
            documentPtr-&gt;OnCommandInit(); &#13;
            return 0; &#13;
</pre><p>When the user drops a set of files into the window, we need to extract their paths before calling <code class="literal">OnDropFile</code>. The <code class="literal">ExtractPath</code> method extracts the path of the files from the drop and returns a list of paths, which is sent to <code class="literal">OnDropFile</code>:</p><pre class="programlisting">          case WM_DROPFILES: { &#13;
              vector&lt;String&gt; pathList = &#13;
                ExtractPathList(wordParam); &#13;
              documentPtr-&gt;OnDropFile(pathList); &#13;
            } &#13;
            return 0; &#13;
</pre><p>The <code class="literal">WM_HSCROLL</code> and <code class="literal">WM_VSCROLL</code> messages are handled by calling their matching methods:</p><pre class="programlisting">          case WM_HSCROLL: { &#13;
              WORD flags = LOWORD(wordParam), &#13;
                   thumbPos = HIWORD(wordParam); &#13;
              documentPtr-&gt;OnHorizontalScroll(flags, thumbPos); &#13;
            } &#13;
            return 0; &#13;
 &#13;
          case WM_VSCROLL: { &#13;
              WORD flags = LOWORD(wordParam), &#13;
                   thumbPos = HIWORD(wordParam); &#13;
              documentPtr-&gt;OnVerticalScroll(flags, thumbPos); &#13;
            } &#13;
            return 0; &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>Finally, if the message is not caught by <code class="literal">DocumentProc</code>, <code class="literal">WindowProc</code> (from the previous chapter) is called to further process the message:</p><pre class="programlisting">    return WindowProc(windowHandle, message, &#13;
                      wordParam, longParam); &#13;
  } &#13;
</pre><p>The <code class="literal">ExtractPathList</code> method extracts the paths of the dropped files by calling the Win32 API function <code class="literal">DragQueryFile</code> and returns the list of paths:</p><pre class="programlisting">  vector&lt;String&gt; ExtractPathList(WORD wordParam) { &#13;
    vector&lt;String&gt; pathList; &#13;
    HDROP dropHandle = (HDROP) wordParam; &#13;
</pre><p>The <code class="literal">DragQueryFile</code> method returns the number of files when the second parameter is <code class="literal">0xFFFFFFFF</code>:</p><pre class="programlisting">    int size = &#13;
      ::DragQueryFile(dropHandle, 0xFFFFFFFF, nullptr, 0);  &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
</pre><p>The <code class="literal">DragQueryFile</code> method returns the size of the path string when the second parameter is a zero-based index and the third parameter is null:</p><pre class="programlisting">      int bufferSize =  &#13;
        ::DragQueryFile(dropHandle, index, nullptr, 0) + 1; &#13;
      TCHAR* path = new TCHAR[bufferSize]; &#13;
      assert(path!= nullptr); &#13;
</pre><p>The <code class="literal">DragQueryFile</code> method copies the path itself when the third parameter is a pointer to a text buffer rather than null:</p><pre class="programlisting">      assert(::DragQueryFile(dropHandle, index, &#13;
                             path, bufferSize) != 0); &#13;
      pathList.push_back(String(path)); &#13;
      delete [] path; &#13;
    } &#13;
 &#13;
    return pathList; &#13;
  } &#13;
}; &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec54"/>The Menu class</h1></div></div></div><p>The <code class="literal">Menu</code> class handles a menu, made up of a list of menu items, separator bars, or submenus. When a menu item is added, its command information is stored in the document's command map to be used when receiving the <code class="literal">WM_COMMAND</code> and <code class="literal">WM_INITCOMMAND</code> messages. If the menu item text includes an accelerator, it is added to the document's accelerator set. The <code class="literal">Command</code> class is an auxiliary class holding pointers to the menu items: selection, enable, check, and radio listeners.</p><p>
<strong>Command.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  typedef void (*VoidListener)(void* sourcePtr); &#13;
  typedef bool (*BoolListener)(void* sourcePtr);  &#13;
&#13;
  class Command { &#13;
    public: &#13;
      Command(); &#13;
      Command(VoidListener selection, BoolListener enable, &#13;
              BoolListener check, BoolListener radio); &#13;
 &#13;
      VoidListener Selection() const {return selection;} &#13;
      BoolListener Enable() const {return enable;} &#13;
      BoolListener Check() const {return check;} &#13;
      BoolListener Radio() const {return radio;} &#13;
 &#13;
    private: &#13;
      VoidListener selection; &#13;
      BoolListener enable, check, radio; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Command.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h"&#13;
 &#13;
namespace SmallWindows { &#13;
  Command::Command() &#13;
   :selection(nullptr), &#13;
    enable(nullptr), &#13;
    check(nullptr), &#13;
    radio(nullptr) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Command::Command(VoidListener selection, BoolListener enable, &#13;
                   BoolListener check, BoolListener radio) &#13;
   :selection(selection), &#13;
    enable(enable), &#13;
    check(check), &#13;
    radio(radio) { &#13;
    // Empty. &#13;
  } &#13;
}; &#13;
</pre><p>Menu and accelerator listeners are not regular methods. They are declared (they do not need to be defined) by the <code class="literal">DECLARE_BOOL_LISTENER</code> and <code class="literal">DECLARE_VOID_LISTENER</code> macros. This is because we cannot call a non-static method in an unknown class directly. Therefore, we let the macros declare a non-static method without parameters and define a static method with a <code class="literal">void</code> pointer as a parameter that calls the non-static method. The macros do not define the non-static method. That task is left for the user of Small Windows.</p><p>When the user adds a menu item with a listener, a <code class="literal">Command</code> object is created. It is actually the static method with the <code class="literal">void</code> pointer parameter that is added to the <code class="literal">Command</code> object. Moreover, when the user selects a menu item, it is the static method that is called. The static method in turn calls the non-static method, which is defined by the user.</p><p>The macros take the names of the current class and the listener as parameters. Note that the <code class="literal">bool</code> listener is constant, while the <code class="literal">void</code> listener is not constant. This is because <code class="literal">bool</code> listeners are intended to look up the values of one or several of the fields of the class, while <code class="literal">void</code> listeners also modify the fields.</p><p>
<strong>Menu.h</strong>
</p><pre class="programlisting">#define DEFINE_BOOL_LISTENER(SubClass, Listener)  \ &#13;
  virtual bool Listener() const;                  \ &#13;
  static bool SubClass::Listener(void* voidPtr) { \ &#13;
    return ((SubClass*) voidPtr)-&gt;Listener();     \ &#13;
  } &#13;
 &#13;
#define DEFINE_VOID_LISTENER(SubClass, Listener)  \ &#13;
  virtual void Listener();                        \ &#13;
  static void SubClass::Listener(void* voidPtr) { \ &#13;
    ((SubClass*) voidPtr)-&gt;Listener();            \ &#13;
  } &#13;
 &#13;
namespace SmallWindows { &#13;
  class Document; &#13;
 &#13;
  class Menu { &#13;
    public: &#13;
      Menu(Document* documentPtr, String text = TEXT("")); &#13;
      Menu(const Menu&amp; menu); &#13;
 &#13;
      void AddMenu(Menu&amp; menu); &#13;
      void AddSeparator(); &#13;
      void AddItem(String text, VoidListener selection, &#13;
                   BoolListener enable = nullptr, &#13;
                   BoolListener check = nullptr, &#13;
                   BoolListener radio = nullptr); &#13;
</pre><p>The document pointer is needed when accessing the command map and accelerator set of the document. Every menu except the menu bar has text that is displayed in the document window; <code class="literal">menuHandle</code> is the Win32 API menu handle wrapped by this class:</p><pre class="programlisting">    private: &#13;
      Document* documentPtr; &#13;
      String text; &#13;
      HMENU menuHandle; &#13;
 &#13;
      friend class Document; &#13;
      friend class StandardDocument; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Menu.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>The constructor initializes the pointer document and the text. It also creates the menu by calling the Win32 API function <code class="literal">CreateMenu</code>. Since the menu bar does not need text, the <code class="literal">text</code> parameter is empty by default:</p><pre class="programlisting">namespace SmallWindows { &#13;
  Menu::Menu(Document* documentPtr, String text /* = TEXT("") */) &#13;
   :documentPtr(documentPtr), &#13;
    text(text), &#13;
    menuHandle(::CreateMenu()) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The copy constructor copies the fields of the menu. Note that we copy the <code class="literal">menuHandle</code> field rather than creating a new menu handle.</p><pre class="programlisting">  Menu::Menu(const Menu&amp; menu) &#13;
   :documentPtr(menu.documentPtr), &#13;
    text(menu.text), &#13;
    menuHandle(menu.menuHandle) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The <code class="literal">AddMenu</code> method adds a menu (not a menu item) as a submenu to the menu, while <code class="literal">AddSeparator</code> adds a separator (a horizontal bar) to the menu:</p><pre class="programlisting">  void Menu::AddMenu(Menu&amp; menu) { &#13;
    ::AppendMenu(menuHandle, MF_STRING | MF_POPUP, &#13;
                 (UINT) menu.menuHandle, menu.text.c_str()); &#13;
  } &#13;
 &#13;
  void Menu::AddSeparator() { &#13;
    ::AppendMenu(menuHandle, MF_SEPARATOR, 0, nullptr); &#13;
  } &#13;
</pre><p>The <code class="literal">AddItem</code> method adds a menu item (not a menu) to the menu, with the selection, enable, check, and radio listeners:</p><pre class="programlisting">  void Menu::AddItem(String text, VoidListener selection, &#13;
                     BoolListener enable /* = nullptr */, &#13;
                     BoolListener check /* = nullptr */, &#13;
                     BoolListener radio /* = nullptr */) { &#13;
</pre><p>The selection listener is not allowed to be null, and at least one of the check marks and radio listeners must be null, since it is not possible to annotate a menu item with both a check mark and a radio button:</p><pre class="programlisting">    assert((selection != nullptr) &amp;&amp; &#13;
           ((check == nullptr) || (radio == nullptr))); &#13;
</pre><p>Each menu item is given a unique identity number, which we obtain from the current size of the command map:</p><pre class="programlisting">    map&lt;WORD,Command&gt;&amp; commandMap = documentPtr-&gt;CommandMap(); &#13;
    int itemId = commandMap.size(); &#13;
</pre><p>We add a <code class="literal">Command</code> object to the command map and add the menu item with the Win32 API function <code class="literal">AppendMenu</code>, which takes the menu handle, identity number, and text:</p><pre class="programlisting">    commandMap[itemId] = Command(listener, enable, check, radio); &#13;
    ::AppendMenu(menuHandle, MF_STRING, &#13;
                 (UINT) itemId, text.c_str()); &#13;
</pre><p>If the radio listener is not null, we need to call the Win32 API function <code class="literal">SetMenuItemInfo</code> in order for the radio button to appear with the menu item:</p><pre class="programlisting">    if (radio != nullptr) { &#13;
      MENUITEMINFO menuItemInfo; &#13;
      menuItemInfo.cbSize = sizeof menuItemInfo; &#13;
      menuItemInfo.fMask = MIIM_FTYPE; &#13;
      menuItemInfo.fType = MFT_RADIOCHECK; &#13;
      ::SetMenuItemInfo(menuHandle, (UINT) itemId, &#13;
                        FALSE, &amp;menuItemInfo); &#13;
    } &#13;
</pre><p>Finally, we call <code class="literal">TextToAccelerator</code> in <code class="literal">Accelerator</code> (described in the next section) to add an accelerator, if present, to the accelerator set of the document, which is used by the message loop of <code class="literal">Application</code>:</p><pre class="programlisting">    Accelerator::TextToAccelerator(text, itemId, &#13;
                                   documentPtr-&gt;AcceleratorSet()); &#13;
  } &#13;
}; &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec55"/>The Accelerator class</h1></div></div></div><p>It is possible to add an accelerator to a menu item. The accelerator text is preceded by a tabulator character (<code class="literal">\t</code>) and the text is made up of the optional prefixes <code class="literal">Ctrl+</code>, <code class="literal">Shift+</code>, or <code class="literal">Alt+</code> followed by a character (for instance, <code class="literal">&amp;Open\tCtrl+O</code>) or the name of a virtual key (for instance, <code class="literal">&amp;Save\tAlt+F2</code>).</p><p>
<strong>Accelerator.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
</pre><p>The Win32 API holds a set of virtual keys with names beginning with <code class="literal">VK_</code>. In Small Windows, they have been given other names, hopefully easier to understand. The virtual keys available are: <strong>F1</strong> - <strong>F12</strong>, <strong>Insert</strong>, <strong>Delete</strong>, <strong>Backspace</strong>, <strong>Tab</strong>, <strong>Home</strong>, <strong>End</strong>, <strong>Page Up</strong>, <strong>Page Down</strong>, <strong>Left</strong>, <strong>Right</strong>, <strong>Up</strong>, <strong>Down</strong>, <strong>Space</strong>, <strong>Escape</strong>, and <strong>Return</strong>:</p><pre class="programlisting">  enum Keys {KeyF1 = VK_F1, KeyF2 = VK_F2, KeyF3 = VK_F3, &#13;
             KeyF4 = VK_F4, KeyF5 = VK_F5, KeyF6 = VK_F6, &#13;
             KeyF7 = VK_F7, KeyF8 = VK_F8, KeyF9 = VK_F9, &#13;
             KeyF10 = VK_F10, KeyF11 = VK_F11, KeyF12 = VK_F12, &#13;
             KeyInsert = VK_INSERT, KeyDelete = VK_DELETE, &#13;
             KeyBackspace = VK_BACK, KeyTabulator = VK_TAB, &#13;
             KeyHome = VK_HOME, KeyEnd = VK_END, &#13;
             KeyPageUp = VK_PRIOR, KeyPageDown = VK_NEXT, &#13;
             KeyLeft = VK_LEFT, KeyRight = VK_RIGHT, &#13;
             KeyUp = VK_UP, KeyDown = VK_DOWN, &#13;
             KeySpace = VK_SPACE, KeyEscape = VK_ESCAPE, &#13;
             KeyReturn = VK_RETURN}; &#13;
</pre><p>The <code class="literal">Accelerator</code> class only holds the <code class="literal">TextToAccelerator</code> method, which takes text, extracts the accelerator, and adds it to the accelerator set, if present:</p><pre class="programlisting">  class Accelerator { &#13;
    public: &#13;
      static void TextToAccelerator(String&amp; text, int idemId, &#13;
                                    list&lt;ACCEL&gt;&amp; acceleratorSet); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Accelerator.cpp</strong>
</p><pre class="programlisting">    #include "SmallWindows.h"&#13;
</pre><p>
<code class="literal">TextToVirtualKey</code> is an auxiliary function that takes text and returns the corresponding virtual key. The <code class="literal">keyTable</code> array holds the map between the texts and the available virtual keys:</p><pre class="programlisting">namespace SmallWindows { &#13;
  WORD TextToVirtualKey(String&amp; text) { &#13;
    static const struct { &#13;
      TCHAR* textPtr; &#13;
      WORD key; &#13;
    } keyTable[] = { &#13;
      {TEXT("F1"), KeyF1}, {TEXT("F2"), KeyF2}, &#13;
      {TEXT("F3"), KeyF3}, {TEXT("F4"), KeyF4}, &#13;
      {TEXT("F5"), KeyF5}, {TEXT("F6"), KeyF6}, &#13;
      {TEXT("F7"), KeyF7}, {TEXT("F8"), KeyF8}, &#13;
      {TEXT("F9"), KeyF9}, {TEXT("F10"), KeyF10}, &#13;
      {TEXT("F11"), KeyF11}, {TEXT("F12"), KeyF12}, &#13;
      {TEXT("Insert"), KeyInsert}, {TEXT("Delete"), KeyDelete}, &#13;
      {TEXT("Back"), KeyBackspace}, {TEXT("Tab"), KeyTabulator}, &#13;
      {TEXT("Home"), KeyHome}, {TEXT("End"), KeyEnd}, &#13;
      {TEXT("Page Up"), KeyPageUp}, &#13;
      {TEXT("Page Down"), KeyPageDown}, &#13;
      {TEXT("Left"), KeyLeft}, {TEXT("Right"), KeyRight}, &#13;
      {TEXT("Up"), KeyUp}, {TEXT("Down"), KeyDown}, &#13;
      {TEXT("Space"), KeySpace},  {TEXT("Escape"), KeyEscape}, &#13;
      {TEXT("Return"), KeyReturn}, {nullptr, 0}}; &#13;
</pre><p>We loop through the table until we find the virtual key:</p><pre class="programlisting">    for (int index = 0; keyTable[index].textPtr != nullptr; &#13;
         ++index) { &#13;
      if (text == keyTable[index].textPtr) { &#13;
        return keyTable[index].key; &#13;
      } &#13;
    } &#13;
</pre><p>If we do not find a key matching the text, an assert occurs:</p><pre class="programlisting">    assert(false); &#13;
    return 0; &#13;
  } &#13;
</pre><p>In <code class="literal">TextToAccelerator</code>, we store the <strong>Control</strong>, <strong>Shift</strong>, <strong>Alt</strong>, and virtual key status together with the key in a Win32 API <code class="literal">ACCEL</code> structure:</p><pre class="programlisting">  void Accelerator::TextToAccelerator(String&amp; text, int itemId, &#13;
                                      list&lt;ACCEL&gt;&amp;acceleratorSet){ &#13;
</pre><p>First, we check whether the text contains a <em>Tab</em> key (<strong>\t</strong>). If it does, we initialize the <code class="literal">ACCEL</code> structure with <code class="literal">itemId</code> and extract the accelerator part of the text:</p><pre class="programlisting">    int tabulatorIndex = text.find(TEXT("\t")); &#13;
    if (tabulatorIndex != -1) { &#13;
      ACCEL accelerator; &#13;
      accelerator.fVirt = 0; &#13;
      accelerator.cmd = itemId; &#13;
      String acceleratorText = text.substr(tabulatorIndex + 1); &#13;
</pre><p>If the accelerator text contains the prefix <code class="literal">Ctrl+</code>, <code class="literal">Alt+</code>, or <code class="literal">Shift+</code>, we mask <code class="literal">FCONTROL</code>, <code class="literal">FALT</code>, or <code class="literal">FSHIFT</code> to the <code class="literal">fVirt</code> field and remove the prefix:</p><pre class="programlisting">      { String controlText = TEXT("Ctrl+"); &#13;
        int controlIndex = acceleratorText.find(controlText); &#13;
 &#13;
        if (controlIndex != -1) { &#13;
          accelerator.fVirt |= FCONTROL; &#13;
          acceleratorText.erase(controlIndex, &#13;
                                controlText.length()); &#13;
        } &#13;
      } &#13;
 &#13;
      { String altText = TEXT("Alt+"); &#13;
        int altIndex = acceleratorText.find(altText); &#13;
 &#13;
        if (altIndex != -1) { &#13;
          accelerator.fVirt |= FALT; &#13;
          acceleratorText.erase(altIndex, altText.length()); &#13;
        } &#13;
      } &#13;
 &#13;
      { String shiftText = TEXT("Shift+"); &#13;
        int shiftIndex = acceleratorText.find(shiftText); &#13;
 &#13;
        if (shiftIndex != -1) { &#13;
          accelerator.fVirt |= FSHIFT; &#13;
          acceleratorText.erase(shiftIndex, shiftText.length()); &#13;
        } &#13;
      } &#13;
</pre><p>After we remove the <code class="literal">Ctrl+</code>, <code class="literal">Shift+</code>, and <code class="literal">Alt+</code> prefixes, we look into the remaining part of the accelerator text. If there is one single character (the length is one), we save it in the <code class="literal">key</code> field. However, we do not save the ASCII number. Instead, we save the letter number, which starts with 1 for <code class="literal">a</code> or <code class="literal">A</code>:</p><pre class="programlisting">      if (acceleratorText.length() == 1) { &#13;
        accelerator.key = &#13;
          (WORD) ((tolower(acceleratorText[0]) - ''a'') + 1); &#13;
      } &#13;
</pre><p>If the remaining part of the accelerator text is made up of more than one character, we assume that it is a virtual key and call <code class="literal">TextToVirtualKey</code> to find it and mask the <code class="literal">FVIRTKEY</code> constant to the <code class="literal">fVirt</code> field:</p><pre class="programlisting">      else { &#13;
        accelerator.fVirt |= FVIRTKEY; &#13;
        accelerator.key = TextToVirtualKey(acceleratorText); &#13;
      } &#13;
</pre><p>If <code class="literal">fVirt</code> is still zero, the accelerator does not contain <code class="literal">Ctrl+</code>, <code class="literal">Shift+</code>, <code class="literal">Alt+</code>, or a virtual key, which is not allowed:</p><pre class="programlisting">      assert(accelerator.fVirt != 0); &#13;
</pre><p>Finally, we add the accelerator to the accelerator set:</p><pre class="programlisting">      acceleratorSet.push_back(accelerator); &#13;
    } &#13;
</pre><p>Note that no accelerator is added to the accelerator set if the text does not contain a tabulator:</p><pre class="programlisting">  } &#13;
}; &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec56"/>The StandardDocument class</h1></div></div></div><p>The <code class="literal">StandardDocument</code> class is a direct subclass of <code class="literal">Document</code>; it handles the <strong>File</strong>, <strong>Edit</strong>, and <strong>Help</strong> menus and implements file handling, cut, copy, and paste, drop files, and printing. There is no specific message function for this class; all messages are sent to <code class="literal">DocumentProc</code> in the <code class="literal">Document</code> section covered previously. The document name and the dirty flag are automatically updated by the framework. <code class="literal">StandardDocument</code> does also handle the Page Setup dialog, which is more closely described in <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <em>The Auxiliary Classes</em>.</p><p>
<strong>StandardDocument.h</strong>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class StandardDocument : public Document { &#13;
    public: &#13;
</pre><p>Most constructor parameters are sent to the <code class="literal">Document</code> constructor. What is specific for <code class="literal">StandardDocument</code> is the file description text and the copy and paste format lists. The file description is used by the standard save and open dialogs. The copy and paste lists are used when copying and pasting information between the application and the global Clipboard:</p><pre class="programlisting">      StandardDocument(CoordinateSystem system, Size pageSize, &#13;
                       String fileDescriptionsText, &#13;
                       Window* parentPtr=nullptr, &#13;
                       WindowStyle style = OverlappedWindow, &#13;
                       WindowShow windowShow = Normal, &#13;
                       initializer_list&lt;unsigned int&gt; &#13;
                         copyFormatList = {}, &#13;
                       initializer_list&lt;unsigned int&gt; &#13;
                         pasteFormatList = {}, &#13;
                       bool acceptDropFiles = true, &#13;
                       Size lineSize = LineSize); &#13;
 &#13;
    private: &#13;
      void InitializeFileFilter(String fileDescription); &#13;
 &#13;
</pre><p>The <code class="literal">StandardFileMenu</code>, <code class="literal">StandardEditMenu</code>, and <code class="literal">StandardHelpMenu</code> methods create and return the standard menus. If <code class="literal">print</code> in <code class="literal">StandardFileMenu</code> is <code class="literal">true</code>, the <strong>Page Setup</strong>, <strong>Print</strong>, and <strong>Print Preview</strong> menu items are included:</p><pre class="programlisting">    protected: &#13;
      Menu StandardFileMenu(bool print); &#13;
      Menu StandardEditMenu(); &#13;
      Menu StandardHelpMenu(); &#13;
</pre><p>The <strong>Save</strong> menu item is disabled when the document does not need to be saved (the dirty flag is <code class="literal">false</code>). The <code class="literal">SaveEnable</code> method is called before the <strong>Save</strong> menu item becomes visible and enables it if the dirty flag is <code class="literal">true</code>.</p><pre class="programlisting">    private: &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnNew); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnOpen); &#13;
      DEFINE_BOOL_LISTENER(StandardDocument, SaveEnable); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnSave); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnSaveAs); &#13;
</pre><p>The <code class="literal">OnSave</code> method calls <code class="literal">SaveFileWithName</code> or <code class="literal">SaveFileWidhoutName</code> depending on whether the document has been given a name. However, <code class="literal">OnSaveAs</code> always calls <code class="literal">SaveFileWithoutName</code>, regardless of whether the document has a name.</p><pre class="programlisting">   private: &#13;
      void SaveFileWithName(String name); &#13;
      void SaveFileWithoutName(); &#13;
</pre><p>The <code class="literal">ClearDocument</code>, <code class="literal">WriteDocumentToStream</code>, and <code class="literal">ReadDocumentFromStream</code> methods are called when the user selects the <strong>New</strong>, <strong>Save</strong>, <strong>Save As</strong>, or <strong>Open</strong> menu items and are intended to be overridden by subclasses to clear, write, and read the document:</p><pre class="programlisting">    protected: &#13;
      void ClearPageSetupInfo(); &#13;
      bool ReadPageSetupInfoFromStream(istream &amp;inStream); &#13;
      bool WritePageSetupInfoToStream(ostream &amp;outStream) const; &#13;
 &#13;
      virtual void ClearDocument() {/* Empty. */} &#13;
      virtual bool WriteDocumentToStream(String name, &#13;
                        ostream&amp; outStream) const {return true;} &#13;
      virtual bool ReadDocumentFromStream(String name, &#13;
                       istream&amp; inStream) {return true;} &#13;
</pre><p>The <code class="literal">OnCut</code>, <code class="literal">OnCopy</code>, <code class="literal">OnPaste</code>, and <code class="literal">OnDelete</code> methods are called when the user selects the corresponding menu item in the <strong>Edit</strong> menu. The default behavior for <code class="literal">OnCut</code> is to call <code class="literal">OnCopy</code> followed by <code class="literal">OnDelete</code>:</p><pre class="programlisting">      DEFINE_VOID_LISTENER(StandardDocument, OnCut); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnCopy); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnPaste); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnDelete); &#13;
</pre><p>The <code class="literal">CutEnable</code>, <code class="literal">CopyEnable</code>, <code class="literal">PasteEnable</code>, and <code class="literal">DeleteEnable</code> methods are listeners deciding whether the menu items are enabled. The default behavior for <code class="literal">CutEnable</code> and <code class="literal">DeleteEnable</code> is to call <code class="literal">CopyEnable</code>:</p><pre class="programlisting">      DEFINE_BOOL_LISTENER(StandardDocument, CutEnable); &#13;
      DEFINE_BOOL_LISTENER(StandardDocument, CopyEnable); &#13;
      DEFINE_BOOL_LISTENER(StandardDocument, PasteEnable); &#13;
      DEFINE_BOOL_LISTENER(StandardDocument, DeleteEnable); &#13;
</pre><p>The <code class="literal">IsCopyAsciiReady</code>, <code class="literal">IsCopyUnicodeReady</code>, and <code class="literal">IsCopyGenericReady</code> methods are called by <code class="literal">CopyEnable</code>. They are intended to be overridden and return <code class="literal">true</code> if the application is ready to be copied in the ASCII, Unicode, or generic formats. Their default behavior is to return <code class="literal">false</code>:</p><pre class="programlisting">      virtual bool IsCopyAsciiReady() const {return false;} &#13;
      virtual bool IsCopyUnicodeReady() const {return false;} &#13;
      virtual bool IsCopyGenericReady(int format) &#13;
                                      const {return false;} &#13;
</pre><p>The <code class="literal">CopyAscii</code>, <code class="literal">CopyUnicode</code>, and <code class="literal">CopyGeneric</code> methods are called by <code class="literal">OnCopy</code> when the user selects the <strong>Copy</strong> menu item. They are intended to be overridden by subclasses and are called in accordance with the copy format list in the constructor and the copy-ready methods:</p><pre class="programlisting">      virtual void CopyAscii(vector&lt;String&gt;&amp; textList) const &#13;
                            {/* Empty. */} &#13;
      virtual void CopyUnicode(vector&lt;String&gt;&amp; textList) const &#13;
                              {/* Empty. */} &#13;
      virtual void CopyGeneric(int format, InfoList&amp; infoList) &#13;
                               const {/* Empty. */} &#13;
</pre><p>The <code class="literal">IsPasteAsciiReady</code>, <code class="literal">IsPasteUnicodeReady</code>, and <code class="literal">IsPasteGenericReady</code> methods are called by <code class="literal">PasteEnable</code>, which returns <code class="literal">true</code> if at least one of the methods returns <code class="literal">true</code>. They are intended to be overridden and return <code class="literal">true</code> if the application is ready to be pasted in the ASCII, Unicode, or generic formats. Their default behavior is to return <code class="literal">true</code>:</p><pre class="programlisting">      virtual bool IsPasteAsciiReady &#13;
              (const vector&lt;String&gt;&amp;textList) const {return true;} &#13;
      virtual bool IsPasteUnicodeReady &#13;
              (const vector&lt;String&gt;&amp;textList) const {return true;} &#13;
      virtual bool IsPasteGenericReady(int format, &#13;
                        InfoList&amp; infoList) const {return true;} &#13;
</pre><p>The <code class="literal">PasteAscii</code>, <code class="literal">PasteUnicode</code>, and <code class="literal">PasteGeneric</code> methods are called by <code class="literal">OnPaste</code> when the user selects the <strong>Paste</strong> menu item. They are intended to be overridden by subclasses and are called in accordance with the paste format list in the constructor and the paste-ready methods. One difference between copying and pasting is that copying is performed in all available formats while pasting is performed in the first available format only:</p><pre class="programlisting">      virtual void PasteAscii(const vector&lt;String&gt;&amp; textList) &#13;
                             {/* Empty. */} &#13;
      virtual void PasteUnicode(const vector&lt;String&gt;&amp; textList) &#13;
                               {/* Empty. */} &#13;
      virtual void PasteGeneric(int format, InfoList&amp; infoList) &#13;
                               {/* Empty. */} &#13;
</pre><p>The <code class="literal">OnDropFile</code> methods is called when the user drops a set of files in the window's client area. If there is exactly one file with the suffix given in the constructor in the path list, that file is read in the same way as if the user had selected it in the standard open dialog. However, if there are no files or more than one file with the suffix in the list, an error message is displayed:</p><pre class="programlisting">      void OnDropFile(vector&lt;String&gt; pathList); &#13;
</pre><p>The <code class="literal">PageOuterSize</code> methods returns the logical size of the page in portrait or landscape mode depending on the page setup settings, without regard to the margins, while <code class="literal">PageInnerSize</code>, <code class="literal">PageInnerWidth</code>, and <code class="literal">PageInnerHeight</code> return the size of the page after subtracting the margins:</p><pre class="programlisting">    private: &#13;
      Size PageOuterSize() const; &#13;
      Size PageInnerSize() const; &#13;
 &#13;
    protected: &#13;
      int PageInnerWidth() const{return PageInnerSize().Width();} &#13;
      int PageInnerHeight()const{return PageInnerSize().Height();} &#13;
</pre><p>The <code class="literal">OnPageSetup</code>, <code class="literal">OnPrintPreview</code>, and <code class="literal">OnPrintItem</code> methods are called when the user selects the <strong>Page Setup</strong>, <strong>Print</strong>, and <strong>Print Preview</strong> menu items. They display <strong>Page Setup Dialog</strong>, <strong>Print Preview Window</strong>, and <strong>Print Dialog</strong>:</p><pre class="programlisting">    public: &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnPageSetup); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnPrintPreview); &#13;
      DEFINE_VOID_LISTENER(StandardDocument, OnPrintItem); &#13;
</pre><p>The <code class="literal">PrintPage</code> method is called by <code class="literal">OnPrintItem</code> and prints one page of the document:</p><pre class="programlisting">      bool PrintPage(Graphics* graphicsPtr, int page, &#13;
                     int copy, int totalPages); &#13;
</pre><p>The <code class="literal">OnPageSetup</code> method is called to notify the application when the user has selected the <strong>Page Setup</strong> menu item and has changed the page setup information. It is intended to be overridden by subclasses and its default behavior is to do nothing:</p><pre class="programlisting">      virtual void OnPageSetup(PageSetupInfo info) {/* Empty. */} &#13;
</pre><p>The <code class="literal">GetTotalPages</code> method returns the number of pages to print; the default is 1. It is intended to be overridden by subclasses:</p><pre class="programlisting">      virtual int GetTotalPages() const {return 1;} &#13;
</pre><p>The <code class="literal">OnPrint</code> method is called once by <code class="literal">OnPrintItem</code> for each page and copy. Its default behavior is to write the header and footer in accordance with the setting in the <strong>Page Setup Dialog</strong>, and then call <code class="literal">OnDraw</code> for the application-specific contents of the document:</p><pre class="programlisting">      virtual void OnPrint(Graphics&amp; graphics, int page, &#13;
                           int copy, int totalPages) const; &#13;
</pre><p>The <code class="literal">OnExit</code> method is called when the user selects the <strong>Exit</strong> menu item and quits the application if <code class="literal">TryClose</code> returns <code class="literal">true</code>. If the dirty flag is <code class="literal">true</code>, <code class="literal">TryClose</code> displays a message box, asking the user for permission to close the window:</p><pre class="programlisting">      DEFINE_VOID_LISTENER(StandardDocument, OnExit); &#13;
      virtual bool TryClose(); &#13;
</pre><p>The <code class="literal">OnAbout</code> method displays a simple message box with the application name:</p><pre class="programlisting">      DEFINE_VOID_LISTENER(StandardDocument, OnAbout); &#13;
</pre><p>The <code class="literal">fileFilter</code> fields are used by the <strong>Open</strong> and <strong>Save</strong> standard dialogs and <code class="literal">fileSuffixList</code> is used to check the file suffix of dropped files:</p><pre class="programlisting">    private: &#13;
      TCHAR fileFilter[MAX_PATH]; &#13;
      vector&lt;String&gt; fileSuffixList; &#13;
</pre><p>The <code class="literal">pageSetupInfo</code> field is used when the user selects the <strong>Page Setup</strong> menu item. It stores information about the header and footer text and font, page orientation (portrait or landscape), margins, and whether the pages are surrounded by a frame. Refer to the next chapter for a closer description.</p><pre class="programlisting">      PageSetupInfo pageSetupInfo; &#13;
</pre><p>The <code class="literal">copyFormatList</code> and <code class="literal">pasteFormatList</code> fields hold the formats available for cutting, copying, and pasting:</p><pre class="programlisting">      list&lt;unsigned int&gt; copyFormatList, pasteFormatList; &#13;
  }; &#13;
}; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch11lvl2sec104"/>Initialization</h2></div></div></div><p>The first <code class="literal">StandardDocument</code> constructor takes a large set of parameters. The coordinate system, page size, parent window, style, appearance, whether the document accepts drop files, and the line size parameters are the same as in the <code class="literal">Document</code> case covered previously.</p><p>What remains is the file description text, whether the print menu is present, and the format list for copying and pasting. The description text holds a semicolon-separated list of file descriptions and file suffixes for the allowed files, for instance, <strong>Calc Files</strong>, <em>clc</em>; <strong>Text Files</strong>, <em>txt</em>. The copy and paste format list holds the allowed formats for copying and pasting information.</p><p>
<strong>StandardDocument.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h"&#13;
</pre><p>Most constructor parameters are sent to the <code class="literal">Document</code> constructor. However, the copy and paste format lists are stored in <code class="literal">copyFormatList</code> and <code class="literal">pasteFormatList</code>. The file filter and file suffix lists are initialized by <code class="literal">InitializeFileFilter</code>:</p><pre class="programlisting">namespace SmallWindows { &#13;
  StandardDocument::StandardDocument(CoordinateSystem system, &#13;
                        Size pageSize, &#13;
                        String fileDescriptionsText, &#13;
                        Window* parentPtr /* = nullptr */, &#13;
                        WindowStyle style/* = OverlappedWindow */, &#13;
                        WindowShow windowShow /* = Normal */, &#13;
                        initializer_list&lt;unsigned int&gt; &#13;
                          copyFormatList /* = {} */, &#13;
                        initializer_list&lt;unsigned int&gt; &#13;
                          pasteFormatList /* = {}*/, &#13;
                        bool acceptDropFiles /* = true */, &#13;
                        Size lineSize /* = LineSize */) &#13;
   :Document(TEXT("standarddocument"), system, pageSize, &#13;
             parentPtr, style, windowShow, &#13;
             acceptDropFiles, lineSize), &#13;
    copyFormatList(copyFormatList), &#13;
    pasteFormatList(pasteFormatList) { &#13;
    InitializeFileFilter(fileDescriptionsText); &#13;
</pre><p>In <code class="literal">Window</code>, we used the page size for transforming between logical and physical units. In <code class="literal">Document</code>, we used it for setting the scroll page size. However, in <code class="literal">StandardDocument</code>, there are actually two kinds of page sizes: the outer and inner page size. The outer page size is the page size without taking the margins of the document into consideration. The inner page size is obtained by subtracting the margins from the outer page size. In <code class="literal">StandardDocument</code>, we use the inner page size to set the size of the scroll bar:</p><pre class="programlisting">    SetHorizontalScrollTotalWidth(PageInnerWidth()); &#13;
    SetVerticalScrollTotalHeight(PageInnerHeight()); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec105"/>Standard menus</h2></div></div></div><p>The code for this is shown as follows:</p><pre class="programlisting">  void StandardDocument::InitializeFileFilter(String fileListText) &#13;
  { OStringStream filterStream; &#13;
    vector&lt;String&gt; fileList = Split(fileListText, TEXT('';'')); &#13;
    assert(fileList.size() &gt; 0); &#13;
 &#13;
    for (String fileText : fileList) { &#13;
      vector&lt;String&gt; partList = Split(fileText, TEXT('','')); &#13;
      assert(partList.size() == 2); &#13;
      String description = Trim(partList[0]), &#13;
             suffix = Trim(partList[1]); &#13;
      fileSuffixList.push_back(suffix); &#13;
      filterStream &lt;&lt; description &lt;&lt; TEXT(" (*.") &lt;&lt; suffix &#13;
                   &lt;&lt; TEXT(")\n") &lt;&lt; TEXT("*.") &lt;&lt; suffix &#13;
                   &lt;&lt; TEXT("\n"); &#13;
    } &#13;
 &#13;
    filterStream &lt;&lt; TEXT("\n"); &#13;
 &#13;
    int index = 0; &#13;
    for (TCHAR c : filterStream.str()) { &#13;
      fileFilter[index++] = (c == TEXT(''\n'')) ? TEXT(''\0'') : c; &#13;
    } &#13;
  } &#13;
</pre><p>The standard <strong>File</strong> menu holds the <strong>New</strong>, <strong>Open</strong>, <strong>Save</strong>, <strong>Save As</strong>, and <strong>Exit</strong> menu items as well as (if <code class="literal">print</code> is <code class="literal">true</code>) the <strong>Page Setup</strong>, <strong>Print Preview</strong>, and <strong>Print</strong> menu items:</p><pre class="programlisting">  Menu StandardDocument::StandardFileMenu(bool print) { &#13;
    Menu fileMenu(this, TEXT("&amp;File")); &#13;
    fileMenu.AddItem(TEXT("&amp;New\tCtrl+N"), OnNew); &#13;
    fileMenu.AddItem(TEXT("&amp;Open\tCtrl+O"), OnOpen); &#13;
    fileMenu.AddItem(TEXT("&amp;Save\tCtrl+S"), OnSave, SaveEnable); &#13;
    fileMenu.AddItem(TEXT("Save &amp;As\tCtrl+Shift+S"), OnSaveAs); &#13;
 &#13;
    if (print) { &#13;
      fileMenu.AddSeparator(); &#13;
      fileMenu.AddItem(TEXT("Page Set&amp;up"), OnPageSetup); &#13;
      fileMenu.AddItem(TEXT("Print Pre&amp;view"), OnPrintPreview); &#13;
      fileMenu.AddItem(TEXT("&amp;Print\tCtrl+P"), OnPrintItem); &#13;
    } &#13;
 &#13;
    fileMenu.AddSeparator(); &#13;
    fileMenu.AddItem(TEXT("E&amp;xit\tAlt+X"), OnExit); &#13;
    return fileMenu; &#13;
  } &#13;
</pre><p>The standard <strong>Edit</strong> menu holds the <strong>Cut</strong>, <strong>Copy</strong>, <strong>Paste</strong>, and <strong>Delete</strong> menu items:</p><pre class="programlisting">  Menu StandardDocument::StandardEditMenu() { &#13;
    Menu editMenu(this, TEXT("&amp;Edit")); &#13;
    editMenu.AddItem(TEXT("C&amp;ut\tCtrl+X"), OnCut, CutEnable); &#13;
    editMenu.AddItem(TEXT("&amp;Copy\tCtrl+C"), OnCopy, CopyEnable); &#13;
    editMenu.AddItem(TEXT("&amp;Paste\tCtrl+V"), OnPaste,PasteEnable); &#13;
    editMenu.AddSeparator(); &#13;
    editMenu.AddItem(TEXT("&amp;Delete\tDelete"), &#13;
                     OnDelete, DeleteEnable); &#13;
    return editMenu; &#13;
  } &#13;
</pre><p>The standard <strong>Help</strong> menu holds the <strong>About</strong> menu item with the help of the application name:</p><pre class="programlisting">  Menu StandardDocument::StandardHelpMenu() { &#13;
    Menu helpMenu(this, TEXT("&amp;Help")); &#13;
    helpMenu.AddItem(TEXT("About ") + &#13;
                     Application::ApplicationName() + &#13;
                     TEXT(" ..."), OnAbout); &#13;
    return helpMenu; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec106"/>File management</h2></div></div></div><p>The <code class="literal">TryClose</code> method checks whether the dirty flag is <code class="literal">true</code> when the user tries to close the window. If it is <code class="literal">true</code>, the user is asked if they want to save the document before closing it. If they answer yes, the document is saved as if the user has selected the <strong>Save</strong> menu item. If the dirty flag is set to <code class="literal">false</code> after that, it means that the save operation went well and <code class="literal">true</code> is returned. If the user answers no, <code class="literal">true</code> is returned and the window is closed without saving. If the answer is cancel, <code class="literal">false</code> is returned and the closing is aborted:</p><pre class="programlisting">  bool StandardDocument::TryClose() { &#13;
    if (IsDirty()) { &#13;
      switch (MessageBox(TEXT("Do you want to save?"), &#13;
                         TEXT("Unsaved Document"), YesNoCancel)) { &#13;
        case Yes: &#13;
          OnSave(); &#13;
          return !IsDirty(); &#13;
 &#13;
        case No: &#13;
          return true; &#13;
 &#13;
        case Cancel: &#13;
          return false; &#13;
      } &#13;
    } &#13;
 &#13;
    return true; &#13;
  } &#13;
</pre><p>The <code class="literal">OnExit</code> method calls <code class="literal">TryClose</code> and deletes the application's main window, which eventually sends a quit message to the message loop that terminates the application, if <code class="literal">TryClose</code> returns <code class="literal">true</code>:</p><pre class="programlisting">  void StandardDocument::OnExit() { &#13;
    if (TryClose()) { &#13;
      delete Application::MainWindowPtr(); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">OnNew</code> method is called when the user selects the <strong>New</strong> menu item. It tries to close the window by calling <code class="literal">TryClose</code>. If <code class="literal">TryClose</code> returns <code class="literal">true</code>, the document, dirty flag, and name are cleared, and the window is invalidated and updated. The <code class="literal">ClearDocument</code> method is indented to be overridden by subclasses to clear the application-specific contents of the document:</p><pre class="programlisting">  void StandardDocument::OnNew() { &#13;
    if (TryClose()) { &#13;
      ClearDocument(); &#13;
      ClearPageSetupInfo(); &#13;
      SetZoom(1.0); &#13;
      SetDirty(false); &#13;
      SetName(TEXT("")); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
      UpdateCaret(); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">OnOpen</code> method is called when the user selects the <strong>Open</strong> menu item. It tries to close the window by calling <code class="literal">TryClose</code> and displays the standard open dialog to establish the path of the file if it succeeds. If <code class="literal">OpenDialog</code> returns <code class="literal">true</code> and the input stream is valid, the page setup information is read and the methods <code class="literal">ClearDocument</code> and <code class="literal">ReadDocumentFromStream</code>, which are intended to be overridden by subclasses, are called:</p><pre class="programlisting">  void StandardDocument::OnOpen() { &#13;
    if (TryClose()) { &#13;
      String name = GetName(); &#13;
 &#13;
      if (StandardDialog::OpenDialog(this, name, fileFilter, &#13;
                                     fileSuffixList)) { &#13;
        ClearDocument(); &#13;
        Invalidate(); &#13;
        UpdateWindow(); &#13;
        ifstream inStream(name.c_str()); &#13;
 &#13;
        if (inStream &amp;&amp; ReadDocumentFromStream(name, inStream)) { &#13;
          SetName(name); &#13;
        } &#13;
&#13;
&#13;
        else { &#13;
          MessageBox(TEXT("Could not open ") + &#13;
                     name + TEXT(".")); &#13;
        } &#13;
      } &#13;
    } &#13;
 &#13;
    SetDirty(false); &#13;
    SetZoom(1.0); &#13;
    Invalidate(); &#13;
    UpdateWindow(); &#13;
    UpdateCaret(); &#13;
  } &#13;
</pre><p>The <strong>Save</strong> menu item is enabled if the dirty flag is <code class="literal">true</code>:</p><pre class="programlisting">  bool StandardDocument::SaveEnable() const { &#13;
    return IsDirty(); &#13;
  } &#13;
</pre><p>When saving the file, we call <code class="literal">SaveFileWithName</code> if the file has a name. If the file has not yet been given a name, <code class="literal">SaveFileWithoutName</code> is called instead:</p><pre class="programlisting">  void StandardDocument::OnSave() { &#13;
    String name = GetName(); &#13;
 &#13;
    if (!name.empty()) { &#13;
      SaveFileWithName(name); &#13;
    } &#13;
    else { &#13;
      SaveFileWithoutName(); &#13;
    } &#13;
  } &#13;
</pre><p>When the user selects <strong>Save As</strong>, <code class="literal">SaveFileWithoutName</code> is called and the <strong>Save</strong> standard dialog is displayed, regardless of whether the document has a name:</p><pre class="programlisting">  void StandardDocument::OnSaveAs() { &#13;
    SaveFileWithoutName(); &#13;
  } &#13;
</pre><p>The <code class="literal">SaveFileWithoutName</code> method displays the save dialog. If the user presses the <strong>Ok</strong> button, the <code class="literal">SaveDialog</code> call returns <code class="literal">true</code>, the new name is set, and <code class="literal">SaveFileWithName</code> is called to do the actual writing of the document file:</p><pre class="programlisting">  void StandardDocument::SaveFileWithoutName() { &#13;
    String name = GetName(); &#13;
 &#13;
    if (StandardDialog::SaveDialog(this, name, fileFilter, &#13;
                                   fileSuffixList)) { &#13;
      SaveFileWithName(name); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">SaveFileWithName</code> method tries to open the document file for writing and calls <code class="literal">WriteDocumentToStream</code>, which is intended to be overridden by subclasses, to do the actually writing of the document's content. If the writing of both the page setup information and the contents of the document succeeds, the dirty flag is cleared:</p><pre class="programlisting">  void StandardDocument::SaveFileWithName(String name) { &#13;
    ofstream outStream(name.c_str()); &#13;
 &#13;
    if (outStream &amp;&amp; WriteDocumentToStream(name, outStream)) { &#13;
      SetName(name); &#13;
      SetDirty(false); &#13;
      SetZoom(1.0); &#13;
    } &#13;
  } &#13;
 &#13;
  void StandardDocument::ClearPageSetupInfo() { &#13;
    pageSetupInfo.ClearPageSetupInfo(); &#13;
  } &#13;
 &#13;
  bool StandardDocument::ReadPageSetupInfoFromStream &#13;
                         (istream &amp;inStream) { &#13;
    pageSetupInfo.ReadPageSetupInfoFromStream(inStream); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  bool StandardDocument::WritePageSetupInfoToStream &#13;
                         (ostream &amp;outStream) const { &#13;
    pageSetupInfo.WritePageSetupInfoToStream(outStream); &#13;
    return ((bool) outStream); &#13;
  } &#13;
</pre><p>When the user selects the <strong>About</strong> menu item in the <strong>Help</strong> standard menu, a message box with a message including the name of the application is displayed:</p><pre class="programlisting">  void StandardDocument::OnAbout() { &#13;
    String applicationName = Application::ApplicationName(); &#13;
    MessageBox(applicationName + TEXT(", version 1.0"), &#13;
               applicationName, Ok, Information); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec107"/>Cut, copy, and paste</h2></div></div></div><p>The default behavior for <code class="literal">CutEnable</code> and <code class="literal">DeleteEnable</code> is to simply call <code class="literal">CopyEnable</code>, since it is likely that they are enabled under the same conditions:</p><pre class="programlisting">  bool StandardDocument::CutEnable() const { &#13;
    return CopyEnable(); &#13;
  } &#13;
 &#13;
  bool StandardDocument::DeleteEnable() const { &#13;
    return CopyEnable(); &#13;
  } &#13;
</pre><p>The default behavior for <code class="literal">OnCut</code> is to simply call <code class="literal">OnCopy</code> and <code class="literal">OnDelete</code>, which is the common action for cutting:</p><pre class="programlisting">  void StandardDocument::OnCut() { &#13;
    OnCopy(); &#13;
    OnDelete(); &#13;
  } &#13;
</pre><p>The <code class="literal">OnDelete</code> method is empty and intended to be overridden by subclasses:</p><pre class="programlisting">  void StandardDocument::OnDelete() { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The <code class="literal">CopyEnable</code> method iterates through the paste format list and calls <code class="literal">IsCopyAsciiReady</code>, <code class="literal">IsCopyUnicodeReady</code>, or <code class="literal">IsCopyGenericReady</code> depending on the formats. As soon as one of the methods returns <code class="literal">true</code>, <code class="literal">CopyEnable</code> returns <code class="literal">true</code>, implying that it is enough that copying is allowed for one of the formats. When the actual copying occurs in <code class="literal">OnCopy</code>, the ready methods are called again:</p><pre class="programlisting">  bool StandardDocument::CopyEnable() const { &#13;
    for (unsigned int format : pasteFormatList) { &#13;
      switch (format) { &#13;
        case AsciiFormat: &#13;
          if (IsCopyAsciiReady()) { &#13;
            return true; &#13;
          } &#13;
          break; &#13;
 &#13;
        case UnicodeFormat: &#13;
          if (IsCopyUnicodeReady()) { &#13;
            return true; &#13;
          } &#13;
          break; &#13;
 &#13;
        default: &#13;
          if (IsCopyGenericReady(format)) { &#13;
            return true; &#13;
          } &#13;
          break; &#13;
      } &#13;
    }  &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">OnCopy</code> method iterates through the copy format list given in the constructor and calls appropriate methods depending on the formats:</p><pre class="programlisting">  void StandardDocument::OnCopy() { &#13;
    if (Clipboard::Open(this)) { &#13;
      Clipboard::Clear();  &#13;
      for (unsigned int format : copyFormatList) { &#13;
        switch (format) { &#13;
</pre><p>If the ASCII format applies and if <code class="literal">IsCopyAsciiReady</code> returns <code class="literal">true</code>, <code class="literal">CopyAscii</code> is called, which is intended to be overridden by subclasses to fill <code class="literal">asciiList</code> with ASCII text. When the list has been copied, it is passed on to <code class="literal">WriteAscii</code> in <code class="literal">Clipboard</code>, which stores the text on the global clipboard:</p><pre class="programlisting">          case AsciiFormat:  &#13;
            if (IsCopyAsciiReady()) { &#13;
              vector&lt;String&gt; asciiList; &#13;
              CopyAscii(asciiList); &#13;
              Clipboard::WriteText&lt;AsciiFormat,char&gt;(asciiList); &#13;
            } &#13;
            break; &#13;
</pre><p>If the Unicode format applies and if <code class="literal">IsCopyUnicodeReady</code> returns <code class="literal">true</code>, <code class="literal">CopyUnicode</code> is called, which is intended to be overridden by subclasses to fill <code class="literal">unicodeList</code> with Unicode text. When the list has been copied, it is passed on to <code class="literal">WriteUnicode</code> in <code class="literal">Clipboard</code>, which stores the text on the global clipboard:</p><pre class="programlisting">          case UnicodeFormat: &#13;
            if (IsCopyUnicodeReady()) { &#13;
              vector&lt;String&gt; unicodeList; &#13;
              CopyUnicode(unicodeList); &#13;
              Clipboard::WriteText&lt;UnicodeFormat,wchar_t&gt; &#13;
                                  (unicodeList); &#13;
            } &#13;
            break; &#13;
</pre><p>If neither ASCII nor Unicode applies and if <code class="literal">IsCopyGenericReady</code> returns <code class="literal">true</code>, <code class="literal">CopyGeneric</code> is called, which is intended to be overridden by subclasses to fill the character list with generic information. In C++, a value of type <code class="literal">char</code> always holds one byte; it is therefore used in the absence of a more generic byte type. When the information has been copied to <code class="literal">infoList</code>, it is passed on to <code class="literal">WriteGeneric</code> in <code class="literal">Clipboard</code> to store the information on the global Clipboard:</p><pre class="programlisting">          default: &#13;
            if (IsCopyGenericReady(format)) { &#13;
              InfoList infoList; &#13;
              CopyGeneric(format, infoList); &#13;
              Clipboard::WriteGeneric(format, infoList); &#13;
            } &#13;
            break; &#13;
        } &#13;
      }  &#13;
      Clipboard::Close(); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">PasteEnable</code> method iterates through the paste format list given in the constructor and returns <code class="literal">true</code> if at least one of the formats is available on the global Clipboard:</p><pre class="programlisting">  bool StandardDocument::PasteEnable() const { &#13;
    if (Clipboard::Open(this)) { &#13;
      for (unsigned int format : pasteFormatList) { &#13;
        if (Clipboard::Available(format)) { &#13;
          switch (format) { &#13;
            case AsciiFormat: { &#13;
                vector&lt;String&gt; asciiList; &#13;
                if (Clipboard::ReadText&lt;AsciiFormat,char&gt; &#13;
                                       (asciiList) &amp;&amp; &#13;
                    IsPasteAsciiReady(asciiList)) { &#13;
                  Clipboard::Close(); &#13;
                  return true; &#13;
                } &#13;
              } &#13;
              break;  &#13;
            case UnicodeFormat: { &#13;
                vector&lt;String&gt; unicodeList; &#13;
                if (Clipboard::ReadText&lt;UnicodeFormat,wchar_t&gt; &#13;
                                       (unicodeList) &amp;&amp; &#13;
                    IsPasteUnicodeReady(unicodeList)) { &#13;
                  Clipboard::Close(); &#13;
                  return true; &#13;
                } &#13;
              } &#13;
              break;  &#13;
            default: { &#13;
                InfoList infoList; &#13;
                if (Clipboard::ReadGeneric(format, infoList) &amp;&amp; &#13;
                    IsPasteGenericReady(format, infoList)) { &#13;
                  Clipboard::Close(); &#13;
                  return true; &#13;
                } &#13;
              } &#13;
          } &#13;
        } &#13;
      } &#13;
 &#13;
      Clipboard::Close(); &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">OnPaste</code> method iterates through the paste format list given in the constructor and, for each format, checks whether it is available on the global Clipboard. If it is, an appropriate method is called. Note that, while <code class="literal">OnCopy</code> iterates through the whole copy format list, <code class="literal">OnPaste</code> quits after the first format available on the Clipboard, which makes the order of the paste format list significant:</p><pre class="programlisting">  void StandardDocument::OnPaste() { &#13;
    if (Clipboard::Open(this)) { &#13;
      for (unsigned int format : pasteFormatList) { &#13;
        bool quit = false;  &#13;
        if (Clipboard::Available(format)) { &#13;
          switch (format) { &#13;
</pre><p>In the case of the ASCII format, <code class="literal">ReadAscii</code> in <code class="literal">Clipboard</code> is called, which reads the text list from the global clipboard and, if <code class="literal">IsPasteAsciiReady</code> returns <code class="literal">true</code>, calls <code class="literal">PasteAscii</code>, which is intended to be overridden by subclasses to do the actual application-specific pasting:</p><pre class="programlisting">            case AsciiFormat: { &#13;
                vector&lt;String&gt; asciiList; &#13;
                if (Clipboard::ReadText&lt;AsciiFormat,char&gt; &#13;
                               (asciiList) &amp;&amp; &#13;
                    IsPasteAsciiReady(asciiList)) { &#13;
                  PasteAscii(asciiList); &#13;
                  quit = true; &#13;
                } &#13;
              } &#13;
              break; &#13;
</pre><p>In the case of the Unicode format, <code class="literal">ReadUnicode</code> in <code class="literal">Clipboard</code> is called, which reads the text list from the global clipboard and, if <code class="literal">IsPasteUnicodeReady</code> returns <code class="literal">true</code>, it calls <code class="literal">PasteUnicode</code>, which is intended to be overridden by subclasses to do the actual application-specific pasting:</p><pre class="programlisting">            case UnicodeFormat: { &#13;
                vector&lt;String&gt; unicodeList; &#13;
                if (Clipboard::ReadText&lt;UnicodeFormat,wchar_t&gt; &#13;
                                     (unicodeList) &amp;&amp; &#13;
                    IsPasteUnicodeReady(unicodeList)) { &#13;
                  PasteUnicode(unicodeList); &#13;
                  quit = true; &#13;
                } &#13;
              } &#13;
              break; &#13;
</pre><p>If neither ASCII nor Unicode applies, <code class="literal">ReadGeneric</code> in <code class="literal">Clipboard</code> is called to read the generic information from the global clipboard and, if <code class="literal">IsPasteGenericReady</code> returns <code class="literal">true</code>, it calls <code class="literal">PasteGeneric</code>, which is intended be overridden by subclasses to do the actual pasting.</p><p>One difference between copying and pasting in the generic case is that <code class="literal">OnCopy</code> uses a character list since it does not know the size in advance (if we used a memory block, we would need two methods: one that calculates the size of the block and one that does the actual reading, which would be cumbersome), while <code class="literal">OnPaste</code> uses a memory block, which cannot be converted into a character list since we do not know the size. Only the document-specific overridden version of <code class="literal">PasteGeneric</code> can decide the size of the memory block:</p><pre class="programlisting">            default: { &#13;
                InfoList infoList; &#13;
                if (Clipboard::ReadGeneric(format, infoList) &amp;&amp; &#13;
                    IsPasteGenericReady(format, infoList)) { &#13;
                  PasteGeneric(format, infoList); &#13;
                  quit = true; &#13;
                } &#13;
              } &#13;
              break; &#13;
          }  &#13;
          if (quit) { &#13;
            break; &#13;
          } &#13;
        } &#13;
      }  &#13;
      Clipboard::Close(); &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec108"/>Drop files</h2></div></div></div><p>When the user drops one or several files in the client area of the window, we check the file suffix of each filename. If we find exactly one file with one of the file suffixes of the document (the <code class="literal">fileSuffixList</code> field) we open it in the same way as if the user had opened it with the standard <strong>Open</strong> dialog:</p><pre class="programlisting">  void StandardDocument::OnDropFile(vector&lt;String&gt; pathList) { &#13;
    set&lt;String&gt; pathSet; &#13;
</pre><p>We iterate through the path list and add every path with the file suffix to <code class="literal">pathSet</code>:</p><pre class="programlisting">    for (String path : pathList) { &#13;
      for (String suffix : fileSuffixList) { &#13;
        if (EndsWith(path, TEXT(".") + suffix)) { &#13;
          pathSet.insert(path); &#13;
          break; &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>If <code class="literal">pathSet</code> is empty, no files with the file suffix have been dropped.</p><pre class="programlisting">    if (pathSet.empty()) { &#13;
      MessageBox(TEXT("No suitable dropped file."), &#13;
                 TEXT("Drop File"), Ok, Stop); &#13;
    } &#13;
</pre><p>If <code class="literal">pathSet</code> holds more than one file, too many files with the file suffix have been dropped:</p><pre class="programlisting">    else if (pathSet.size() &gt; 1) { &#13;
      MessageBox(TEXT("To many suitable dropped files."), &#13;
                 TEXT("Drop File"), Ok, Stop); &#13;
    } &#13;
</pre><p>If <code class="literal">pathSet</code> holds exactly one file, it is read in the same way as if the user has selected the <strong>Open</strong> menu item:</p><pre class="programlisting">    else { &#13;
      String path = *pathSet.begin(); &#13;
 &#13;
      if (TryClose()) { &#13;
        ClearDocument(); &#13;
        ReadDocumentFromStream(path, ifstream(path)); &#13;
        SetName(path); &#13;
        SetDirty(false); &#13;
        SetZoom(1.0); &#13;
        Invalidate(); &#13;
        UpdateWindow(); &#13;
        UpdateCaret(); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec109"/>Page size</h2></div></div></div><p>The <code class="literal">PageOuterSize</code> method returns the page size with no regard to the margins. There are two page sizes, depending on the orientation in the <strong>Page Setup</strong> dialog. The page size given in the constructor refers to the <code class="literal">Portrait</code> orientation. In the case of the <code class="literal">Landscape</code> orientation, the width and height of the page are swapped:</p><pre class="programlisting">  Size StandardDocument::PageOuterSize() const { &#13;
    if (pageSetupInfo.GetOrientation() == Landscape) { &#13;
      return Size(pageSize.Height(), pageSize.Width()); &#13;
    } &#13;
 &#13;
    return pageSize; &#13;
  } &#13;
</pre><p>The <code class="literal">PageInnerSize</code> method returns the page size with regard to the margins. The width is subtracted by the left and right margins. The height is subtracted by the top and bottom margins. Remember that the margins are given in millimeters and the logical units are in hundredths of millimeters. Therefore, we multiply the margins by 100:</p><pre class="programlisting">  Size StandardDocument::PageInnerSize() const { &#13;
    Size outerSize = PageOuterSize(); &#13;
 &#13;
    int innerWidth = outerSize.Width() - &#13;
                     (100 * (pageSetupInfo.LeftMargin() + &#13;
                     pageSetupInfo.RightMargin())), &#13;
        innerHeight = outerSize.Height() - &#13;
                      (100 * (pageSetupInfo.TopMargin() + &#13;
                      pageSetupInfo.BottomMargin())); &#13;
 &#13;
    return Size(innerWidth, innerHeight); &#13;
  } &#13;
</pre><p>The <code class="literal">PageInnerWidth</code> and <code class="literal">PageInnerHeight</code> methods return the width and height of the document after the margins have been subtracted. As the margins are given in millimeters and one millimeter is one hundred logical units, we multiply the margins by 100 in order to obtain logical units:</p><pre class="programlisting">  int StandardDocument::PageInnerWidth() const { &#13;
    return PageOuterSize().Width() - &#13;
           (100 * (pageSetupInfo.LeftMargin() + &#13;
                   pageSetupInfo.RightMargin())); &#13;
  } &#13;
 &#13;
  int StandardDocument::PageInnerHeight() const { &#13;
    return PageOuterSize().Height() - &#13;
           (100 * (pageSetupInfo.TopMargin() + &#13;
                   pageSetupInfo.BottomMargin())); &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec110"/>Page setup</h2></div></div></div><p>The <code class="literal">OnPageSetup</code> method is called when the user selects the <strong>Page Setup</strong> menu item. It displays the <strong>Page Setup</strong> dialog (refer to <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <em>The Auxiliary Classes</em>) and calls <code class="literal">OnPageSetup</code>, which is intended to be overridden by subclasses, to notify the application that the page setup information has been changed:</p><pre class="programlisting">  void StandardDocument::OnPageSetup() { &#13;
    PageSetupDialog pageSetupDialog(this, &amp;pageSetupInfo); &#13;
 &#13;
    if (pageSetupDialog.DoModal()) { &#13;
      OnPageSetup(pageSetupInfo); &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec111"/>Printing</h2></div></div></div><p>The <code class="literal">OnPrintPreview</code> method is called when the user selects the <strong>Print Preview</strong> menu item. It displays the print preview document, which is more closely described in <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <em>The Auxiliary Classes</em>. The <code class="literal">GetTotalPages</code> method returns the current number of pages in the document:</p><pre class="programlisting">  void StandardDocument::OnPrintPreview() { &#13;
    new PrintPreviewDocument(this, GetTotalPages()); &#13;
  } &#13;
</pre><p>The <code class="literal">OnPrintItem</code> method is called when the user selects the <strong>Print</strong> menu item. It displays the standard <strong>Print</strong> dialog and prints the pages of the document in accordance with the page interval and the order and number of copies specified by the user in the dialog.</p><p>The method is named <code class="literal">OnPrintItem</code> so that it is not confused with <code class="literal">OnPrint</code> in <code class="literal">Window</code>, which is called when the window receives the <code class="literal">WM_PAINT</code> message. However, both methods could have been named <code class="literal">OnPrint</code> since they have different parameter lists:</p><pre class="programlisting">void StandardDocument::OnPrintItem() { &#13;
    int totalPages = GetTotalPages(), firstPage, lastPage, copies; &#13;
    bool sorted; &#13;
</pre><p>The <code class="literal">PrintDialog</code> method creates and returns a pointer to a <code class="literal">Graphics</code> object, if the user presses the <strong>Ok</strong> button, or a null pointer if the user presses the <strong>Cancel</strong> button. The <code class="literal">totalPages</code> parameters indicate the last possible page that the user can choose (the first possible page is 1). In the case of the <strong>Ok</strong> button, <code class="literal">firstPage</code>, <code class="literal">lastPage</code>, <code class="literal">copies</code>, and <code class="literal">sorted</code> are initialized: <code class="literal">firstPage</code> and <code class="literal">lastPage</code> are the page intervals to be printed, <code class="literal">copies</code> is the number of copies to be printed, and <code class="literal">sorted</code> indicates whether the copies (if more than one) will be sorted:</p><pre class="programlisting">    Graphics* graphicsPtr = &#13;
      StandardDialog::PrintDialog(this, totalPages, firstPage, &#13;
                                  lastPage, copies, sorted); &#13;
</pre><p>The Win32 API function <code class="literal">StartDoc</code> initializes the printing process. It takes the device context connected to the printer by the <code class="literal">Graphics</code> object and a <code class="literal">DOCINFO</code> structure that only needs to be initialized with the document name. If <code class="literal">StartDoc</code> returns a value greater than zero, we are clear to print the pages. We prepare the device context and disable the window while the printing occurs:</p><pre class="programlisting">    if (graphicsPtr != nullptr) { &#13;
      static DOCINFO docInfo; &#13;
      docInfo.cbSize = sizeof docInfo; &#13;
      docInfo.lpszDocName = GetName().c_str(); &#13;
 &#13;
      if (::StartDoc(graphicsPtr-&gt;GetDeviceContextHandle(), &#13;
                     &amp;docInfo) &gt; 0) { &#13;
        PrepareDeviceContext &#13;
          (graphicsPtr-&gt;GetDeviceContextHandle()); &#13;
        EnableWindow(false); &#13;
</pre><p>If <code class="literal">sorted</code> is <code class="literal">true</code>, the pages are printed in the sorted order. For instance, let's assume that <code class="literal">firstPage</code> is set to 1, <code class="literal">lastPage</code> is set to 3, and <code class="literal">copies</code> is set to 2. If <code class="literal">sorted</code> is <code class="literal">true</code>, the pages are printed in order 1, 2, 3, 1, 2, 3. If <code class="literal">sorted</code> is <code class="literal">false</code>, they are printed in the order 1, 1, 2, 2, 3, 3. <code class="literal">PrintPage</code> is called for each page and the printing continues as long as it returns true; <code class="literal">printOk</code> keeps track of whether the loop continues:</p><pre class="programlisting">        if (sorted) { &#13;
          bool printOk = true; &#13;
          for (int copy = 1; (copy &lt;= copies) &amp;&amp; printOk; ++copy){ &#13;
            for (int page = firstPage; &#13;
                 (page &lt;= lastPage) &amp;&amp; printOk; ++page){ &#13;
              printOk = PrintPage(graphicsPtr, page, &#13;
                                  copy, totalPages); &#13;
            } &#13;
          } &#13;
        } &#13;
        else { &#13;
          bool printOk = true; &#13;
          for (int page = firstPage; &#13;
               (page &lt;= lastPage) &amp;&amp; printOk; ++page) { &#13;
            for (int copy = 1; (copy &lt;= copies) &amp;&amp; printOk; &#13;
                 ++copy) { &#13;
              printOk = PrintPage(graphicsPtr, page, &#13;
                                  copy, totalPages); &#13;
            } &#13;
          } &#13;
        } &#13;
</pre><p>The Win32 API function <code class="literal">EndDoc</code> is used to finish printing:</p><pre class="programlisting">        ::EndDoc(graphicsPtr-&gt;GetDeviceContextHandle()); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">PrintPage</code> method calls the Win32 API functions <code class="literal">StartPage</code> and <code class="literal">EndPage</code> before and after the printing of the page. If they both return values greater than zero, it indicates that the printing went well, <code class="literal">true</code> is returned, and more pages can be printed. <code class="literal">OnPrint</code> (overridden from <code class="literal">Window</code>) is called to do the actual printing, <code class="literal">page</code> and <code class="literal">copy</code> are the current page and copy, and <code class="literal">totalPages</code> is the number of pages in the document:</p><pre class="programlisting">  bool StandardDocument::PrintPage(Graphics* graphicsPtr, &#13;
                              int page, int copy, int totalPages){ &#13;
    if (::StartPage(graphicsPtr-&gt;GetDeviceContextHandle()) &gt; 0) { &#13;
      OnPrint(*graphicsPtr, page, copy, totalPages); &#13;
      return (::EndPage(graphicsPtr-&gt;GetDeviceContextHandle())&gt;0); &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">OnPrint</code> method prints the information given by the <code class="literal">pageSetupInfo</code> field. Then, the contents of the documents are clipped and drawn by calling <code class="literal">OnDraw</code>, and finally the frame enclosing the contents of the document is drawn, if present:</p><pre class="programlisting">  void StandardDocument::OnPrint(Graphics&amp; graphics, int page, &#13;
                                 int copy, int totalPages) const { &#13;
</pre><p>The document is cleared by being painted white.</p><pre class="programlisting">    graphics.FillRectangle(Rect(0, 0, PageOuterSize().Width(), &#13;
                      PageOuterSize().Height()), White, White); &#13;
 &#13;
    int left = 100 * pageSetupInfo.LeftMargin(), &#13;
        top = 100 * pageSetupInfo.TopMargin(); &#13;
    int right = left + PageInnerWidth(), &#13;
                bottom = top + PageInnerHeight(); &#13;
</pre><p>The header text is written unless it is empty; if the current page is the first page, it is not written:</p><pre class="programlisting">    if (!pageSetupInfo.HeaderText().empty() &amp;&amp; &#13;
        !((page == 1) &amp;&amp; (!pageSetupInfo.HeaderFirst()))) { &#13;
      Rect headerRect(left, 0, right, top); &#13;
      String headerText = &#13;
        Template(this, pageSetupInfo.HeaderText(), &#13;
                 copy, page, totalPages); &#13;
      Color textColor = pageSetupInfo.HeaderFont().FontColor(); &#13;
      Color backColor = textColor.Inverse(); &#13;
      graphics.DrawText(headerRect, headerText, &#13;
               pageSetupInfo.HeaderFont(), textColor, backColor); &#13;
    } &#13;
</pre><p>Similar to the header text, the footer text is written unless it is empty; if the current page is the first page, it is not written:</p><pre class="programlisting">    if (!pageSetupInfo.FooterText().empty() &amp;&amp; &#13;
        !((page == 1) &amp;&amp; (!pageSetupInfo.HeaderFirst()))) { &#13;
      Rect footerRect(left, bottom, right, &#13;
                      PageOuterSize().Height()); &#13;
      String footerText = &#13;
        Template(this, pageSetupInfo.FooterText(), &#13;
                 copy, page, totalPages); &#13;
      Color textColor = pageSetupInfo.FooterFont().FontColor(); &#13;
      Color backColor = textColor.Inverse(); &#13;
      graphics.DrawText(footerRect, footerText, &#13;
               pageSetupInfo.FooterFont(), textColor, backColor); &#13;
    } &#13;
</pre><p>The current state of the device context is saved, the origin is set to the top-left corner of the current page, the area of the current page is clipped, <code class="literal">OnDraw</code> is called to draw the current page, and the paint area is finally restored:</p><pre class="programlisting">    int save = graphics.Save(); &#13;
    Point centerPoint(-left, &#13;
                      ((page - 1) * PageInnerHeight()) - top); &#13;
    graphics.SetOrigin(centerPoint); &#13;
    Rect clipRect(0, (page - 1) * PageInnerHeight(), &#13;
                  PageInnerWidth(), page * PageInnerHeight()); &#13;
    graphics.IntersectClip(clipRect); &#13;
    OnDraw(graphics, Print); &#13;
    graphics.Restore(save); &#13;
</pre><p>Finally, the page is enclosed by a rectangle if the frame field of the page setup information is <code class="literal">true</code>:</p><pre class="programlisting">    if (pageSetupInfo.Frame()) { &#13;
      graphics.DrawRectangle(Rect(left, top, right, bottom), &#13;
                             Black); &#13;
    } &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we studied the document classes of Small Windows: <code class="literal">Document</code>, <code class="literal">Menu</code>, <code class="literal">Accelerator</code>, and <code class="literal">StandardDocument</code>. In <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <em>The Auxiliary Classes</em>, we continue by looking into to the auxiliary classes of Small Windows.</p></div></body></html>