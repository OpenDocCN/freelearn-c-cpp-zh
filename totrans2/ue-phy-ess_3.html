<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Collision</h1></div></div></div><p>In this chapter, we will analyze collision in Unreal Engine 4, what it is, the different types of collision that exist in the engine, how to use it, and how to apply it to both static meshes and blueprints. To start with, we will first take an overview look of the different collisions that exist in Unreal Engine 4, but we will also cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Simple versus complex collision</li><li class="listitem">Generating simple collision</li><li class="listitem">Creating complex and custom collision hulls</li><li class="listitem">Collision interactions</li><li class="listitem">Custom object and trace channels</li><li class="listitem">In-depth collision presets</li></ul></div><p>For the purposes of this chapter, we will continue to work with Unreal Engine 4 using the <strong>Unreal_PhyProject</strong> that we created in the first chapter.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Collision and Trace Responses – an overview</h1></div></div></div><p>In the <a id="id127" class="indexterm"/>real world and in Unreal Engine 4, we define collision as an <a id="id128" class="indexterm"/>overlap of two or more objects. In the context of Unreal Engine 4, <strong>Collision</strong> and <strong>Trace Responses</strong> lay the groundwork for how Unreal Engine 4 handles collision and ray casting during the game. Every object that is given collision gets an <strong>Object Type</strong> and a series of responses that describe how it interacts with the other object types. In the event of either a collision or an overlap of two or more objects, all objects involved can be set to affect or to be affected by blocking, overlapping, or ignoring one another.</p><p>
<strong>Trace Responses</strong> describe how an object should react when you interact with a trace, which is done with a ray cast. An object can choose to block, overlap, or even ignore a trace from a particular source. By default, there are two different <strong>Trace Responses</strong>:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Visibility</strong>: This <a id="id129" class="indexterm"/>specifies a trace from one position to another</li><li class="listitem"><strong>Camera</strong>: This is <a id="id130" class="indexterm"/>exactly similar to the <strong>Visibility</strong> trace response, but it should be used when you use a ray cast from the camera</li></ul></div><p>
<strong>Object Responses</strong> describe how an object should respond when you interact with other objects in our game world. Similar to <strong>Trace Responses</strong>, <strong>Object Responses</strong> offer the ability to choose whether or not an object will block, overlap, or ignore other objects when a collision occurs. By default, there are six different types of <strong>Object Responses</strong>:</p><div><ul class="itemizedlist"><li class="listitem"><strong>WorldStatic</strong>: This <a id="id131" class="indexterm"/>object response is for objects in our game world that are static, meaning that they do not and cannot be moved by any means. Objects such as volumes, world geometry, or any other meshes in the game world are associated to this object response.</li><li class="listitem"><strong>WorldDynamic</strong>: This <a id="id132" class="indexterm"/>object response is for objects in our game world that are moving actors, outside of player pawns, physics bodies, vehicles, and destructible actors. Examples of <strong>WorldDynamic</strong> objects would be an elevator, a door that can open and close, or a wheel that a player can turn.</li><li class="listitem"><strong>Pawn</strong>: This object response is for player characters in our game or any other character that <a id="id133" class="indexterm"/>can be possessed by the player.</li><li class="listitem"><strong>PhysicsBody</strong>: This <a id="id134" class="indexterm"/>object response is for any physics body or object that can be simulated with physics in our game world. An example of a <strong>PhysicsBody</strong> object would be a basketball that the player can pick <a id="id135" class="indexterm"/>up and throw; <em>Half-Life 2</em> is a great example of how physics body object collisions are used in games.</li><li class="listitem"><strong>Vehicle</strong>: Although this object response is labeled as <strong>Vehicle</strong>, what this response is useful <a id="id136" class="indexterm"/>for is to have player pawns jump into them, such as a vehicle.</li><li class="listitem"><strong>Destructible</strong>: This object response is for any actors that are destructible, meaning that they can <a id="id137" class="indexterm"/>break apart using the destructible mesh editor.</li></ul></div><p>When you work on setting up collisions on an object or a component in Unreal Engine 4 blueprints, you will see the following properties:</p><div><img src="img/image00235.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>It is important to note that we want to make sure that our static mesh or blueprint component has collision generated before setting any collision presets to that object; otherwise, we will not receive any responses once a collision occurs. Later in this chapter, we will go into more detail on how to generate simple and complex collisions for our objects.</p><p>When it comes to setting up <strong>Collisions</strong> to an object, there are numerous collision presets that default to Unreal Engine 4 that either ignores, overlaps, or blocks a combination of trace and object responses. In addition to these presets, we do have the option to create a custom collision preset for certain circumstances in our blueprint. Feel free to explore some of the collision presets and how they differentiate from one another, but for the sake of this text, let's take a look at some of the more common presets. We will take an in-depth look at the following <a id="id138" class="indexterm"/>presets later on in this chapter:</p><div><ul class="itemizedlist"><li class="listitem"><strong>No Collision</strong>: As the <a id="id139" class="indexterm"/>name suggests, this collision preset eliminates any collision responses by setting the <strong>Visibility</strong> trace response and the <strong>Camera</strong> trace response to ignore and sets <strong>Collision Enabled</strong> to <strong>No Collision</strong>. Typically, we would use this for blueprint components that we don't want to react to any collisions that may occur.<div><img src="img/image00236.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Block All</strong>: This collision preset causes all the collisions with the associated component to <a id="id140" class="indexterm"/>result in a block. Alternatively, it causes all the objects involved in this collision to hit and bounce off one another if physics are applied. This is done by setting all the responses, including the trace and object responses, to <strong>Block</strong> under their <strong>Collision Responses</strong>, as shown in the following screenshot:<div><img src="img/image00237.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Overlap All</strong>: This collision preset results in all the collisions to generate an overlap between all the <a id="id141" class="indexterm"/>objects involved in the collision. As long as the <strong>Generate Overlap Events</strong> property is checked, we can use the blueprint collision events to enable behaviors or events to occur once this type is involved in a collision.<div><img src="img/image00238.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Pawn</strong>: This collision preset is useful if it is used for a player pawn or character in our <a id="id142" class="indexterm"/>game. By default, it is set to block <strong>Object Responses</strong>, block the <strong>Camera</strong> trace response, and ignore the <strong>Visibility</strong> trace response:<div><img src="img/image00239.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Physics Actor</strong>: This collision preset is used for any actor or component that is a physics-based <a id="id143" class="indexterm"/>actor, meaning that the object has in-game physics (such as gravity) applied to it. In order for this preset to work properly, we want to make sure that the <strong>Simulate Physics</strong> property in the <strong>Physics Tab</strong> is checked. By default, all the <strong>Trace Responses</strong> and <strong>Object Responses</strong> are set to <strong>Block</strong>:<div><img src="img/image00240.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>These are just a few of the different options that Unreal Engine 4 offers by default for collision, and we will cover the other options in more detail later on in this chapter. Although there are a handful of options when it comes to collision presets offered in Unreal Engine 4 by <a id="id144" class="indexterm"/>default, a really nice feature that is in place is the ability to create your own trace, object channels, and collision presets. To do this, we need to navigate to the <strong>Edit</strong> window and select <strong>Project Settings</strong>:</p><div><img src="img/image00241.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>From here, we need to navigate to the <strong>Collision</strong> option in the <strong>Engine</strong> category:</p><div><img src="img/image00242.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>In this menu, we can create custom collision presets, specify which object and trace channels to either ignore, overlap, or block, give it a specific name, and save it to the project file. For advanced <a id="id145" class="indexterm"/>needs, we can also create custom object and trace channels in this window. Later in this chapter, we will create our own custom collision preset and apply it to an object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Collision and Trace Responses – a section review</h1></div></div></div><p>In this section, we <a id="id146" class="indexterm"/>briefly looked at the different <strong>Collision</strong> and <strong>Trace Responses</strong> that exist in Unreal Engine 4 and defined a handful of these responses. We analyzed the different <strong>Trace Responses</strong> and <strong>Object Responses</strong> that default to Unreal Engine 4, and we also defined a limited number of collision presets that are provided. Now that we have a basic understanding of <strong>Collision</strong> and <strong>Trace Responses</strong>, we can move forward and learn more about simple and complex collision in Unreal Engine 4.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Simple versus complex collision</h1></div></div></div><p>In <a id="id147" class="indexterm"/>Unreal Engine 4, we will be able to autogenerate <a id="id148" class="indexterm"/>collisions for our meshes that can be used in our game. There are two different types of collision that exist in Unreal Engine 4: simple and complex collision. Each type of collision serves its own unique purpose, and in this section, we will simply define each collision type and provide examples of each. Later on in this chapter, we will work on how to apply these collisions to our objects. We will also test these collisions in our game. Let's begin with simple collision.</p><p>A simple collision is a collision mesh that uses basic shapes, such as boxes, spheres, capsules, and convex shapes, to define the bounds of our object. Convex shapes are ones that have one or more interior angles that are less than 180 degrees, whereas concave shapes are ones that possess one or more interior angles that are more than 180 degrees, as shown in the following image:</p><div><img src="img/image00243.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to these basic shapes, we can generate a form of simple collision called <strong>KDOP</strong> or <strong>K Discrete Oriented Polytope</strong> (where K is the number of axis-aligned planes). What <a id="id149" class="indexterm"/>this option essentially does is that it takes the <em>K</em> axis-aligned planes and moves them as close as possible to the selected mesh. We will go into more detail on how to generate these different types of simple collision later on. Now, let's define the different types of simple collision here:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Sphere</strong>: This <a id="id150" class="indexterm"/>creates a spherical bound mesh <a id="id151" class="indexterm"/>around the selected object. It can be used in <a id="id152" class="indexterm"/>physics objects and to apply collision to objects that are round.<div><img src="img/image00244.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Capsule</strong>: This <a id="id153" class="indexterm"/>creates a capsule bound mesh around the selected object and is typically used for character or pawn meshes:<div><img src="img/image00245.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Box</strong>: This <a id="id154" class="indexterm"/>creates a box bound mesh around the <a id="id155" class="indexterm"/>selected object. This type of simple collision is most commonly used for environment meshes:<div><img src="img/image00246.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>10DOP X</strong>: This <a id="id156" class="indexterm"/>creates a box with four edges beveled in the <em>X</em>-aligned edges:<div><img src="img/image00247.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>10DOP Y</strong>: This <a id="id157" class="indexterm"/>creates a box with four edges <a id="id158" class="indexterm"/>beveled in the <em>Y</em>-aligned edges:<div><img src="img/image00248.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>10DOP Z</strong>: This <a id="id159" class="indexterm"/>creates a box with four edges beveled in <a id="id160" class="indexterm"/>the <em>Z</em>-aligned edges:<div><img src="img/image00249.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>18DOP</strong>: This <a id="id161" class="indexterm"/>creates a box with all of its edges beveled:<div><img src="img/image00250.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>26DOP</strong>: This <a id="id162" class="indexterm"/>creates a box with all of its edges and <a id="id163" class="indexterm"/>corners beveled:<div><img src="img/image00251.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>The main advantage of simple collision is that it almost eliminates the possibility of an object getting stuck to a player or vice versa. An additional advantage is that the collision mesh is of a basic shape, which is less expensive to use in the game at runtime.</p><p>Complex collision is done for each polygon and is very expensive in Unreal Engine 4 as compared to simple collision. Moreover, complex collision is never used for an actor that is simulating physics, and it will just fall through the game world. In order to enable complex collision in the <strong>Static Mesh</strong> editor, we need to navigate to <strong>Details Panel</strong> and then to the <strong>Static Mesh Settings</strong> section. It is here that we can change the <strong>Collision Complexity</strong> parameter to <a id="id164" class="indexterm"/>
<strong>Use Simple Collision As Complex</strong> or <strong>Use Complex Collision As Simple</strong>:</p><div><img src="img/image00252.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Simple versus complex collision – a section review</h1></div></div></div><p>In this section, we looked at the different simple collisions offered by default in the <strong>Static Mesh</strong> editor in <a id="id165" class="indexterm"/>Unreal Engine 4. We also discussed the advantages and disadvantages of the simple and complex collision when it comes to game development and engine performance. Lastly, we briefly looked at how to create both these types of collision. With a basic understanding of simple and complex collision under our belts, we can now discuss how to create simple collision, and how to create collision hulls in Unreal Engine 4 later on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Creating simple collisions</h1></div></div></div><p>When it <a id="id166" class="indexterm"/>comes to creating collisions, there are many <a id="id167" class="indexterm"/>options that we can take advantage of to properly utilize collision and optimize game performance. As we discussed in the previous section, we have the option to create simple and complex collisions in the <strong>Static Mesh</strong> editor in Unreal Engine 4, but we can also use third-party art programs to create custom collision hulls. Let's first discuss how to create simple collisions in Unreal Engine 4, and in the next section, we will discuss how to create complex and custom collisions for our assets.</p><p>Let's begin by opening <code class="literal">StarterContent</code> and navigating to <strong>Content Browser</strong>. From here, let's go to the <code class="literal">StarterContent</code> folder and select the <code class="literal">Shapes</code> folder that contains multiple simple-shaped static meshes to select from. For this set of examples, we will choose the <code class="literal">Shape_Trim</code> mesh because it is a more complicated shape as compared to a sphere or box; this way, we can see the effects of different collision options. Double-click on the <code class="literal">Shape_Trim</code> asset to open the <strong>Static Mesh</strong> editor.</p><div><img src="img/image00253.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>Navigating to the <strong>Static Mesh</strong> editor is very similar to moving around in the <strong>Perspective</strong> view mode in the main game editor of Unreal Engine 4. At the top of the <strong>Static Mesh</strong> editor is the main <a id="id168" class="indexterm"/>toolbar that provides a handful of useful options when you view your mesh and its collision.</p><div><img src="img/image00254.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The toolbar provides us the options to save our mesh and its properties, to view the mesh in real time, which is useful if the mesh has an animated material applied to it, to view any applied <strong>Sockets</strong>, to toggle the <strong>Wireframe</strong> of the mesh, to view any <strong>Vertex Colors</strong> applied to the mesh, to toggle a background <strong>Grid</strong>, to toggle the <strong>Bounds</strong> of the mesh, and (most importantly) to toggle the <strong>Collision</strong> applied to the mesh. Additionally, we can view the mesh's <strong>Pivot Point</strong>, its <strong>Normals</strong>, <strong>Tangents</strong>, <strong>Bi-Normals</strong>, and <strong>UV</strong> sheet.</p><p>As we will <a id="id169" class="indexterm"/>work primarily with collisions, we will want to make sure that the <strong>Collision</strong> option is toggled on so that we can see the bounds of the bounding collision mesh. To do this, we can left-click on the <strong>Collision</strong> button to make sure that it's highlighted in orange, and if the mesh has any collision applied to it, we will see it in a light blue-colored wireframe around our object. By default, <code class="literal">Shape_Trim</code> does have a collision applied to it, so we first want to remove this collision so that we are able to apply only one collision mesh to the object at once for demonstration purposes.</p><div><ol class="orderedlist arabic"><li class="listitem">First, navigate to the <strong>Collision</strong> drop-down window at the very top of the <strong>Static Mesh</strong> editor located alongside the <strong>File</strong>, <strong>Edit</strong>, <strong>Asset</strong> window options.</li><li class="listitem">Then, select <strong>Remove Collision</strong>.</li></ol><div></div><p>Now, the light blue-colored wireframe outline mesh will disappear from our mesh, meaning that this asset no longer has any collision applied to it. It is also very important to keep in mind that we do not want more than one collision-bounding mesh applied to an object at once in order to keep our assets as optimized as possible, unless the shape of the mesh demands more than one collision mesh.</p><p>When it comes to generating simple collision in the <strong>Static Mesh</strong> editor, it is as easy as clicking on a few buttons in its interface. Let's start by creating a <strong>Sphere</strong> collision in our <code class="literal">Shape_Trim</code> mesh by clicking on the <strong>Collision</strong> drop-down menu and selecting <strong>Add Sphere Simplified Collision</strong>. Once complete, we should see a collision-bounding mesh that looks <a id="id170" class="indexterm"/>similar to the following screenshot:</p><div><img src="img/image00255.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The <strong>Sphere Simplified Collision</strong> option sets the radius of the sphere that best matches the size and shape of the mesh that it is applied to. We should also note that the collision wireframe changed <a id="id171" class="indexterm"/>from light blue to green; this means that the collision will use a simple shape. Once a collision is generated, the shape can be moved, rotated, and scaled to the desired size and shape. For this shape, a sphere collision does not seem to work as we would like it to work, so let's select the <strong>Remove Collision</strong> option from the <strong>Collision</strong> drop-down list and then the <strong>Add Capsule Simplified Collision</strong> option.</p><div><img src="img/image00256.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, the <strong>Capsule Simplified Collision</strong> option does a much better job of matching the size and shape of our mesh than the <strong>Sphere Simplified Collision</strong> option because it sets the capsule's height and radius as opposed to just setting the radius. We can still see that the collision-bounding mesh does not fit this shape as closely as we would like, so <a id="id172" class="indexterm"/>let's continue to add differently shaped collision meshes in order to find the best one.</p><p>Let's remove the <a id="id173" class="indexterm"/>capsule collision-bounding mesh and instead select the <strong>Add Box Simplified Collision</strong> option to <code class="literal">Shape_Trim</code>. Here, we can see that the box shape does a really good job of matching the size and shape of the mesh, and in most situations, we would use this option for this asset for use in our game.</p><div><img src="img/image00257.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>For the purposes of this chapter, we will continue to apply the <strong>KDOP Collision</strong> options to this mesh so that we have a better understanding of their purposes and the results that we can get from these options. Now, let's remove the <strong>Box Simplified Collision</strong> option and use the <strong>Add 10DOP-X Simplified Collision</strong> option. If you remember from the previous section, the <strong>10DOP-X Simplified Collision</strong> creates a box with four edges beveled in the <a id="id174" class="indexterm"/>
<em>X</em>-aligned edges. Then, we get the following <a id="id175" class="indexterm"/>result:</p><div><img src="img/image00258.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, the <strong>10DOP-X Simplified Collision</strong> option generates a collision-bounding mesh identical to the <strong>Box Simplified Collision</strong> option. Now, let's try applying the <strong>10DOP-Y Simplified Collision</strong> option, which creates a box with four edges beveled in the <em>Y</em>-aligned edges by first removing the <strong>10DOP-X Simplified Collision</strong> option and then selecting the <strong>Add 10DOP-Y Simplified Collision</strong> option to obtain the following collision mesh:</p><div><img src="img/image00259.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see here, the <strong>10DOP-Y Simplified Collision</strong> option does an excellent job of almost exactly matching the size and shape of our <code class="literal">Shape_Trim</code> static mesh. This is definitely a viable option to select when you generate a collision for this asset. Lastly, let's apply the <strong>10DOP-Z Simplified Collision</strong> option to view how it generates a collision mesh around our asset. First, let's remove the <strong>10DOP-Y Simplified Collision</strong> option and then <a id="id176" class="indexterm"/>navigate to the <strong>Collision</strong> drop-down menu and select <strong>Add 10DOP-Z Simplified Collision</strong>, which creates a box with four edges beveled in the <a id="id177" class="indexterm"/>
<em>Z</em>-aligned axis to obtain the following result:</p><div><img src="img/image00260.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The result is identical to what we obtained when we applied the <strong>Box Simplified Collision</strong> and <strong>10DOP-X Simplified Collision</strong> options. Based on the results we received from these options, the best choices for this asset would either be <strong>Box Simplified Collision</strong> or <strong>10DOP-Y Simplified Collision</strong>. Due to the simplicity of this asset, the <strong>18DOP</strong> and <strong>26DOP Simplified Collision</strong> options won't produce unique options, so to properly demonstrate these choices, we need to choose a different asset.</p><p>To demonstrate this, let's close <strong>Static Mesh</strong> editor for the <code class="literal">Shape_Trim</code> asset and navigate to <strong>Content Browser</strong>. Here, under the <code class="literal">Starter Content</code> folder in the <code class="literal">Props</code> folder, we will double-click on the <code class="literal">SM_Chair</code> asset to open this mesh in <strong>Static Mesh</strong> editor. The <code class="literal">SM_Chair</code> asset does have the default collision applied to it, so before we apply our own, let's first remove its collision. Then, let's go ahead and select the <strong>18DOP </strong>
<a id="id178" class="indexterm"/>
<strong>Simplified Collision</strong> option and view how it generates a <a id="id179" class="indexterm"/>collision-bounding mesh for our chair:</p><div><img src="img/image00261.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>If you remember, the <strong>18DOP Simplified Collision</strong> option creates a collision-bounding box with all of its edges beveled, creating a nice collision around our chair. Here, let's apply the <strong>26DOP Simplified Collision</strong> option by first removing our collision and then selecting the <strong>Add 26DOP Simplified Collision</strong> option:</p><div><img src="img/image00262.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the <strong>26DOP Simplified Collision</strong> option creates a box that has all of its edges and <a id="id180" class="indexterm"/>corners beveled, creating a smoother and more <a id="id181" class="indexterm"/>rounded collision mesh around our asset.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Creating simple collisions – a section review</h1></div></div></div><p>In this section, we <a id="id182" class="indexterm"/>took a more in-depth look at the different types of <a id="id183" class="indexterm"/>simple collision that can be generated in the <strong>Static Mesh</strong> editor in Unreal Engine 4 and the pros and cons of each type. Using starter content assets as examples, we applied each type of simple collision to view how they are generated based on the size and shape of our asset to better understand how they work. Now that we have taken a deeper look at how to generate simple collisions in Unreal Engine 4, let's now move on and take a look at how to generate complex and custom collision hulls using Unreal Engine 4.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Creating complex and custom collision hulls</h1></div></div></div><p>When it <a id="id184" class="indexterm"/>comes to creating complex collision <a id="id185" class="indexterm"/>in the <strong>Static Mesh</strong> editor, we can use the <a id="id186" class="indexterm"/>
<strong>Auto Convex Collision</strong> tool to customize <a id="id187" class="indexterm"/>the number of hulls and hull vertices that the collision mesh will have. For the purposes of this section, we will need to continue using <code class="literal">Unreal_PhyProject</code> that we created, and we will use the <code class="literal">SM_Lamp_Wall</code> asset as an example of how to generate custom and complex collision hulls. To navigate to this asset, we need to go to <strong>Content Browser</strong> and then to the <code class="literal">Starter Content</code> folder. Now, under props, we will find the <code class="literal">SM_Lamp_Wall</code> asset. Double-click on this asset to open the <strong>Static Mesh</strong> editor. If this static mesh has any default collisions applied to it, make sure to remove the said collision by navigating to the <strong>Collision</strong> drop-down menu and selecting remove collision. Make sure that the <strong>Collision Toggle</strong> option is set to on so that we can view the collision mesh in the <strong>Static Mesh</strong> editor.</p><p>For this asset, we will use the <strong>Auto Convex Collision</strong> tool that provides us with a set of parameters to generate <strong>Complex Collision</strong>. To use this tool, we need to navigate to the <strong>Collision</strong> drop-down menu and select the <strong>Auto Convex Collision</strong> option. Once done, we will be <a id="id188" class="indexterm"/>provided with a submenu on the right-hand <a id="id189" class="indexterm"/>side under <strong>Details Panel</strong> labeled as <a id="id190" class="indexterm"/>
<strong>Convex Decomposition</strong> with the following parameters:</p><div><img src="img/image00263.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Hulls</strong>: This parameter determines the number of hulls that are created to best match the size and shape of the mesh.</li><li class="listitem"><strong>Max Hull Verts</strong>: This parameter sets the maximum number of collision hull vertices. By increasing this value, we can see how complex the collision hulls can be.</li><li class="listitem"><strong>Apply</strong>: This parameter generates a collision mesh based on the <strong>Max Hulls</strong> and <strong>Max Hull Verts</strong> parameters.</li><li class="listitem"><strong>Defaults</strong>: This parameter resets the <strong>Max Hulls</strong> and <strong>Max Hull Verts</strong> parameters back to their default values of <code class="literal">4</code> and <code class="literal">12</code> respectively (as seen in the previous image).</li></ul></div><p>For the sake of <a id="id191" class="indexterm"/>providing examples, let's apply <strong>Auto Convex Collision</strong> to our <code class="literal">SM_Lamp_Wall</code> mesh and set the <strong>Max Hulls</strong> and <strong>Max Hull Verts</strong> parameters to their default values of <code class="literal">4</code> and <code class="literal">12</code> respectively:</p><div><img src="img/image00264.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>To really <a id="id192" class="indexterm"/>view the power of this tool, let's try <a id="id193" class="indexterm"/>applying <strong>Auto Convex Collision</strong> <a id="id194" class="indexterm"/>to the following parameters:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Hulls</strong>: Set this parameter to <code class="literal">1</code></li><li class="listitem"><strong>Max </strong><a id="id195" class="indexterm"/><strong>Hull Verts</strong>: Set this parameter to <code class="literal">6</code></li></ul></div><p>Then, we should see the following result:</p><div><img src="img/image00265.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, setting these parameters to the lowest values possible will result in a collision mesh that does the bare minimum and does not fit the size and shape of our lamp. Now, let's try applying <strong>Auto Convex Collision</strong> to the following parameters:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Hulls</strong>: Set this paramerter to 24</li><li class="listitem"><strong>Max Hull Verts</strong>: Set this paramerter to 32</li></ul></div><div><img src="img/image00266.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>With the maximum settings applied to the convex collision mesh, we can see that it does a much better job of covering the lamp in terms of its size and shape. In the end, we would want to choose a setting somewhere between the lowest and highest values for the <strong>Max Hulls</strong> and <strong>Max Hull Verts</strong> parameters in order to create the most optimized collision <a id="id196" class="indexterm"/>possible for our assets.</p><p>Now that <a id="id197" class="indexterm"/>we have covered the methods of <a id="id198" class="indexterm"/>how to create collisions with the tools offered in the <strong>Static Mesh</strong> editor of Unreal Engine 4, we will now briefly discuss how to create and import collisions created in third-party art programs (such as 3ds Max or Maya).</p><p>The idea behind <a id="id199" class="indexterm"/>creating customized collision geometry is to make it as simple as possible in order to optimize collision detection when you play the game. The more complicated the collision geometry for an object, the more calculations are required by the engine to ensure that the collision is done correctly on that object. When you import the <code class="literal">.FBX</code> file to Unreal Engine 4, the collision meshes included in this file are identified by the importer based on their name. Here is the collision-naming syntax required to ensure proper collision when you import your assets to Unreal Engine 4:</p><div><ul class="itemizedlist"><li class="listitem"><strong>UBX_[Mesh Name]</strong>: This naming syntax is required when you import collision meshes that are box shaped, using either the box object type in 3ds Max or the cube primitive in Maya. Keep in mind that if you move any of the vertices of the box collision in the third-party art program or deform the shape in any way to make it anything other than a rectangular prism, the import will not work.</li><li class="listitem"><strong>USP_[Mesh Name]</strong>: This naming syntax is required when you import collision meshes that are sphere shaped, using the sphere object type in 3ds Max and Maya. The sphere itself in the third-party art program does not need to have a specific number of segments because it is converted to a true sphere for collision once it is imported to Unreal Engine 4.</li><li class="listitem"><strong>UCX_[Mesh Name]</strong>: This naming syntax is required when you import collision meshes that are convex shaped or a shape that is completely closed and does not have an interior angle of more than 180 degrees.</li></ul></div><p>When you <a id="id200" class="indexterm"/>import the <code class="literal">.FBX</code> files that contain <a id="id201" class="indexterm"/>collision meshes, there are a few concepts <a id="id202" class="indexterm"/>that we have to keep in mind:</p><div><ol class="orderedlist arabic"><li class="listitem">At the time of writing this book, spheres are only used for rigid-body collisions and Unreal's zero-extent traces, such as weapons, and not for instances (such as player movements).</li><li class="listitem">In the naming syntax mentioned earlier, the <strong>Mesh Name</strong> component must be identical to the name of the mesh that the collision is associated with in the third- party art program. An example would be a box collision mesh for an object named <code class="literal">Chair_01</code> would be labeled as <code class="literal">UBX_Chair_01</code>, or if there are multiple <a id="id203" class="indexterm"/>collision meshes for this object, an additional collision mesh could be named <code class="literal">UBX_Chair_01_02</code>, and so on.</li><li class="listitem">Once the collision meshes are created and named properly, we can export both the collision and the mesh that the collision is associated with in the <code class="literal">.FBX</code> file. Once imported, Unreal Engine 4 will find the collision, separate it from the actual mesh, and transform it into a collision model.</li><li class="listitem">In the instance that an object has a collision composed of multiple shapes, the best results are found when the collision hulls do not intersect with one another.</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Creating complex and custom collision hulls – a section review</h1></div></div></div><p>In this <a id="id204" class="indexterm"/>section, we took an in-depth look at <a id="id205" class="indexterm"/>how to create more complex collisions. We also <a id="id206" class="indexterm"/>looked at how to create custom collision <a id="id207" class="indexterm"/>hulls in third-party art programs (such as 3ds Max and Maya). Moreover, we analyzed the <strong>Auto Convex Collision</strong> tool in the <strong>Static Mesh</strong> editor of Unreal Engine 4. We also discussed how the <strong>Max Hulls</strong> and <strong>Max Hull Verts</strong> parameters affect the collision that is generated around our asset. Lastly, we looked at all the necessary naming conventions required in our art applications that ensure proper <a id="id208" class="indexterm"/>exporting and importing of our meshes and <a id="id209" class="indexterm"/>collisions to Unreal Engine 4. Now that we have a very strong understanding of how to generate collisions in Unreal <a id="id210" class="indexterm"/>Engine 4 and third-party art applications, we can now talk about about the different collision interactions that exist in Unreal Engine 4 in detail.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Collision interactions</h1></div></div></div><p>After <a id="id211" class="indexterm"/>discussing a lot about what collision is and how to generate different types of collision, let's now talk about how the different collision responses function when you interact with the player and other objects in our game world. For the purposes of this section, we will want to have <code class="literal">Unreal_PhyProject</code> open, and we will work with the <code class="literal">FirstPersonExampleMap</code> level and use the default starter content to analyze these interactions.</p><p>In <code class="literal">FirstPersonExampleMap</code>, we will find numerous cube physics actors spread across the surface of the level (each starting awake and active at game time). If we select any of these cube actors in the editor by left-clicking on it, we will see the following <strong>Collision</strong> settings in its <strong>Details Panel</strong>:</p><div><img src="img/image00267.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, these actors will use <strong>Physics Actor</strong> collision preset and have an <strong>Object Type</strong> of <strong>PhysicsBody</strong>. If we were to jump to the level with the first person project example (which we have in place) by pressing <em>Alt</em> + <em>P</em>, we can shoot these cubes with the <strong>First-Person Projectile</strong> blueprint by left-clicking on it. We can see that on colliding, there is an impulse created that causes the boxes to be pushed, and the collision itself causes the projectile to bounce off because it is also a physics object that has <strong>Physics Body Object Response</strong> set to <strong>Block</strong>. To get a better idea of what is happening, let's open the <strong>First Person Projectile</strong> blueprint by navigating to <strong>Content Browser</strong> and then to the <code class="literal">First Person BP</code> folder. In the <code class="literal">Blueprints</code> folder, we will find the <strong>First Person Projectile</strong> blueprint. Double-click on this asset to open its blueprint. It will bring us to the main <strong>Event Graph</strong>, as shown in the following screenshot:</p><div><img src="img/image00268.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>If we are viewing the blueprint graph for the first time, this may be a little confusing, but we can easily break down the logic flow and understand exactly what the projectile will do once it's spawned and collides with an actor.</p><p>Let's first <a id="id212" class="indexterm"/>look at the main event of this graph: the <strong>Event Hit</strong> event node. What this event node checks for is whether or not the main root component of the blueprint is hit in a collision. In this case, the main root of this blueprint is the <strong>Sphere Collision Component</strong> option, labeled as <strong>Collision Component</strong>. Let's select this component by left-clicking on <strong>Collision Component</strong> in the <strong>Components</strong> tab in the top-left corner of the blueprint screen and then view its collision in <strong>Details Panel</strong>:</p><div><img src="img/image00269.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>When you view its collision, you will see that it is set exactly similar to the physics cube actors in the level, possessing a <strong>Physics Actor</strong> collision preset and an <strong>Object Type</strong> set to <strong>Physics Body</strong>. What this means in terms of collision is that this projectile will act similar to a normal physics ball, such as a baseball or a basketball, when spawned into our game world. A ball in both the real world and our game world will more than likely end up hitting something, and when it does, our <strong>Event Hit</strong> node will be called.</p><p>What happens next in the <strong>First Person Projectile</strong> blueprint is that it checks whether or not the other component that hits our projectile is a box, a wall, a player, or the floor. In particular, this blueprint will check whether the other hit component of any collision to this projectile is <strong>Simulating Physics</strong> or a physics actor. The <strong>Is Simulating Physics</strong> function node returns a <strong>Boolean</strong> value (<strong>True</strong> or <strong>False</strong>), irrespective of whether or not the other hit component is a physics actor. We then use a <strong>Branch</strong> node that uses this <strong>True</strong> or <strong>False</strong> condition from the <strong>Is Simulating Physics</strong> function to perform actions based on whether or not the hit component is a physics actor. We can see that from the <strong>True</strong> execution pin, we can add an impulse at the location of the projectile and use the <strong>Other Component</strong> of the <strong>Hit</strong> collision as our target to apply this impulse to. To determine the force of this impulse, we can perform a simple multiplication between the velocity vector of the projectile. We multiply it by a constant <strong>Float</strong> value. In addition to <strong>Add Impulse at Location</strong>, this math is what causes the physics cube to bounce or react to the projectile on collision, and <strong>Is Simulating Physics</strong> checks to ensure that no impulses are created when hitting the walls, the floor, or even the player. To have some fun with this <a id="id213" class="indexterm"/>blueprint, let's change the constant Float value from <code class="literal">100</code> to <code class="literal">1000</code> and see how it drastically changes the results when the projectile hits a physics object.</p><p>To change the way this projectile behaves in the game, we can change its collision preset from <strong>Physics Actor</strong> to <strong>Custom</strong> so that we can individually set how the collision interacts with the different object responses. For example, let's set the <strong>Physics Body</strong> object response from <strong>Block</strong> to <strong>Overlap</strong> and then compile the blueprint so that we can see the changes in the game. The result is that the projectile goes straight through the physics cube. However, it still reacts normally to the <strong>World Static</strong> object type (such as the floor and the walls). This is because we changed the object response to <strong>Physics Body</strong> from <strong>Block</strong> to <strong>Overlap</strong>. This causes the <strong>Event Hit</strong> event node to never get called.</p><p>In the blueprints of Unreal Engine 4, there are event nodes we can use when objects overlap. This is called the <strong>On Component Begin</strong> overlap. As we made our projectile use the <strong>Custom Collision</strong> preset that overlaps the physics bodies in the game, we can use the <strong>On Component Begin Overlap</strong> event node to have any number of actions to take place during this collision. To set up a basic example in our projectile blueprint, select the <strong>Collision Component</strong> option in the <strong>Components</strong> tab so that it is highlighted. Next, right-click on an empty space of <strong>Event Graph</strong> and navigate to <strong>Add Event</strong> for <strong>Collision Component</strong> and then to <strong>Collision</strong>. Finally, select the <strong>Add On Component Begin Overlap</strong> event node.</p><div><img src="img/image00270.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>To have a similar behavior to what we had in the <strong>Event Hit</strong> node checking for objects that are physics actors, let's copy and paste the <strong>Is Simulating Physics</strong> function node and <strong>Branch</strong> that was used in the original blueprint logic and connect the nodes, as shown in the following <a id="id214" class="indexterm"/>screenshot:</p><div><img src="img/image00271.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>So far, we had our projectile check for objects in our world that are physics actors once the collision is overlapped, but we have no actions taking place if this check is <strong>True</strong> or <strong>False</strong>. Instead of performing any kind of complicated actions, we will simply use the <strong>Print String</strong> function to print the dialogue to our console so that we know that the check is working. Let's right-click on the empty space of <strong>Event Graph</strong> and search for the <strong>Print String</strong> function node. In the <strong>In String</strong> parameter, enter <code class="literal">Overlapped Physics Body</code>, and connect it to the <strong>True</strong> executional output pin, as shown in the following screenshot:</p><div><img src="img/image00272.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>If we click on the <strong>Compile</strong> button at the top of the blueprint and play the game, we can see that the projectile goes right through our physics objects, but we do not see our <strong>Print String</strong> outputted to the console. This is because both the physics cubes in the level and our projectile collision don't have the <strong>Generate Overlap Events</strong> parameter set to <strong>True</strong> by default, so let's select one or more of the cubes and navigate to their <strong>Collision Settings</strong> in <strong>Details Panel</strong> and make sure that <strong>Generate Overlap Events</strong> is set to <strong>True</strong>. Let's perform the same function to <strong>Collision Component</strong> in our projectile blueprint. Now, if we play again and shoot the physics cubes that we customized, we will now see our <strong>Print String</strong> <a id="id215" class="indexterm"/>outputted to the console.</p><div><img src="img/image00273.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>From here, feel free to experiment and customize the collision presets that the projectile has, see how it changes and reacts in our game world, and add more blueprint functionalities to see what else is possible.</p><p>The last collision interaction that can exist between objects, apart from <strong>Block</strong> and <strong>Overlap</strong>, is the <strong>Ignore</strong> option. There is not much to this type of <strong>Collision Response</strong> because it will ignore the different <strong>Object Responses</strong> completely if it is set to <strong>Ignore</strong>. For the purpose of our example, in our <strong>First Person Projectile</strong> blueprint, let's change the <strong>Physics Body</strong> object response from <strong>Overlap</strong> to <strong>Ignore</strong>. If we play now, we can shoot at the physics cubes, but it will go completely through the object, and neither the <strong>On Component Begin Overlap</strong> nor the <strong>Event Hit</strong> event nodes will be called.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Collision interactions – a section review</h1></div></div></div><p>In this section, we got our hands dirty by applying the different combinations of collision presets to the <strong>First Person Projectile</strong> blueprint to see how it interacts with the physics actors in our game world. By setting the <strong>Physics Body</strong> object response to <strong>Block</strong>, the <strong>Event Hit</strong> event node will be called. Also, an impulse will be created at the projectiles' location, resulting in a small push force applied to the physics actor the projectile collides with. By setting the <strong>Physics Body</strong> object response to <strong>Overlap</strong>, we can use the <strong>On Component Begin Overlap Event</strong> node to call different actions once the projectile overlaps with a physics <a id="id216" class="indexterm"/>actor. We just need to make sure that the physics actors in our level and our projectile have the <strong>Generate Overlap Events</strong> set to <strong>True</strong>. Lastly, we briefly discussed the results of when our projectile has the <strong>Physics Body</strong> object response set to <strong>Ignore</strong>. Like the name suggests, it ignores the object response, and no events are fired. Now that we talked more about collision interactions, let's move on and discuss how to create and use custom object and trace channel responses in Unreal Engine 4.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Custom object and trace channel responses</h1></div></div></div><p>Sometimes, the default object and trace channel responses are not enough for what we want to <a id="id217" class="indexterm"/>do in our games. So, it may be necessary to create customized object and trace channel responses for certain assets and scenarios. To <a id="id218" class="indexterm"/>accomplish this, we can navigate to the <strong>Edit</strong> drop-down window at the top of the Unreal Engine 4 editor and select <strong>Project Settings</strong>. From here, select the <strong>Collision</strong> option under the <strong>Engine</strong> section. Here, we can create custom <strong>Objects</strong>, <strong>Trace Channels</strong>, and <strong>Presets</strong> that we can use when we apply collisions to our assets.</p><p>Let's start with creating a new <strong>Object Channel</strong> by selecting this option and clicking on the <strong>New Object Channel</strong> button. Here, a dialogue window pops up. Then, we can customize how <strong>Object Channel</strong> responds by default.</p><div><img src="img/image00274.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>Name the <strong>Object Channel</strong> <code class="literal">Projectile</code>, and set its <strong>Default Response</strong> to <strong>Block</strong>. Now, let's create a custom <strong>Collision Preset</strong> by selecting this option and selecting the <strong>New</strong> button so that a dialogue window appears. Here, we can set the presets default values:</p><div><img src="img/image00275.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>We can also name this new <strong>Collision Preset Profile</strong>, <code class="literal">Projectile</code>, set the <strong>Collision Enabled</strong> property to <strong>Collision Enabled</strong>, <strong>Object Type</strong> to <code class="literal">Projectile</code>, (the one that we have just created), and the <strong>Description</strong> property to anything that will remind us of what this <strong>Collision Preset</strong> is used for. Lastly, we can set all the <strong>Trace</strong> and <strong>Object Channels</strong> for this preset to <strong>Block</strong>.</p><p>For the <a id="id219" class="indexterm"/>purposes of this section's demonstration, we won't create a custom <strong>Trace Channel</strong>, but if we ever needed to, it works exactly <a id="id220" class="indexterm"/>similar to creating a custom <strong>Object Channel</strong>; select the <strong>Trace Channels</strong> option, left-click on the <strong>New Trace Channel</strong> button, name the channel, and set the <strong>Default Response</strong> to either <strong>Block</strong>, <strong>Overlap</strong>, or <strong>Ignore</strong>.</p><p>Now that we have created a custom <strong>Object Channel</strong> and a custom <strong>Collision Preset</strong>, let's apply these to the <strong>Collision Component</strong> of the <strong>First Person Projectile</strong> blueprint. Once you are in the <strong>First Person Projectile</strong> blueprint, select the <strong>Collision</strong> component from the <strong>Components</strong> tab in the top-left corner and navigate to the <strong>Collision</strong> section of the <strong>Details Panel</strong> in the bottom-right corner of the blueprint window. If we look at the <strong>Collision Presets</strong> drop-down menu, we will see our <code class="literal">Projectile</code> <strong>Collision Preset</strong> available, and when we select this option, we will see the default values that we set:</p><div><img src="img/image00276.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>We can also see our <code class="literal">Projectile</code> <strong>Object Channel Response</strong> that we created earlier in the <strong>Object Responses</strong> section of the <strong>Collision Component</strong>. Now, if we ever need to, we can set all <a id="id221" class="indexterm"/>of our projectile assets to have the <strong>Projectile Collision Preset</strong> so that all of our projectiles behave the same during collisions. In addition to this, we can have other assets collide in a specific way to projectiles by setting the <strong>Projectile</strong> object response to <strong>Block</strong>, <strong>Overlap</strong>, or <strong>Ignore</strong> projectiles on <a id="id222" class="indexterm"/>colliding. Now, when we play the game, we can see that the <strong>First Person Projectile</strong> blueprint behaves exactly as intended when you fire the projectile.</p><p>Just as a reminder, we can only have up to 18 custom <strong>Object Channels</strong> and <strong>Trace Channels</strong>, and if we ever delete an <strong>Object Type</strong> that has been used in our game, it will revert back to <strong>WorldStatic</strong>, and if we delete a trace channel that has been used in our game, the behavior of the trace is undefined.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Custom object and trace channel responses – a section review</h1></div></div></div><p>In this section, we took a deeper look at how to create and implement custom objects, trace channels, and custom collision presets. We then applied these customized channels and presets to the <a id="id223" class="indexterm"/>
<strong>First Person Projectile</strong> blueprint and found that we can have the same collision behavior exist for the projectile when we <a id="id224" class="indexterm"/>use custom collision presets and <strong>Object</strong> channels. Now that we have created our very own custom object and trace channels and created our own collision preset, we can now move on and take an in-depth look at the additional default collision presets that exist in Unreal Engine 4.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>In-depth collision presets</h1></div></div></div><p>To conclude this <a id="id225" class="indexterm"/>chapter, let's briefly discuss the remaining collision presets <a id="id226" class="indexterm"/>available in Unreal Engine 4 that we have not gone through at this point:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Custom</strong>: This <a id="id227" class="indexterm"/>collision preset allows you to fully customize how you want the collision to behave by selecting the <strong>Collision Enabled</strong> property, setting the <strong>Object Type</strong> property, and fully customizing how the <strong>Trace</strong> and <strong>Object Responses</strong> react to different types of collisions. This type of collision preset is useful when we need to customize an assets collision, and where the default collision presets does not fit the type of collision we need.</li><li class="listitem"><strong>Block All Dynamic</strong>: This collision preset blocks all the actors by default and makes the <a id="id228" class="indexterm"/>collision itself a <strong>WorldDynamic</strong> object. This type of collision preset is useful for dynamic objects or objects that can move in your game world that you want to block when you collide with other objects. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>Overlap All Dynamic</strong>: This collision preset overlaps all the actors by default and makes <a id="id229" class="indexterm"/>the collision itself a <strong>WorldDynamic</strong> object. This type of collision preset is useful for dynamic objects that you want to overlap when you collide with other objects. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>, meaning that the assets' collision won't use game physics.</li><li class="listitem"><strong>Ignore Only Pawn</strong>: This collision preset blocks all the actors by default, but it ignores <a id="id230" class="indexterm"/>the <strong>Pawn</strong> and <strong>Vehicle</strong> object responses. This preset also sets the <strong>Object Type</strong> of the collision to <strong>WorldDynamic</strong> and is useful for assets that you want to ignore for <strong>Pawns</strong> and <strong>Vehicles</strong> in your game world. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>.</li><li class="listitem"><strong>Overlap Only Pawn</strong>: This collision preset blocks all the actors by default, but it <a id="id231" class="indexterm"/>overlaps the <strong>Pawn</strong> and <strong>Vehicle</strong> object responses. It also overlaps the <strong>Camera</strong> trace channel. This preset also sets the <strong>Object Type</strong> of the collision to <strong>WorldDynamic</strong> and is useful for assets that need overlap events to fire when it is overlapped during a collision with <strong>Pawns</strong>, <strong>Vehicles</strong>, and <strong>Camera Traces</strong>. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>.</li><li class="listitem"><strong>Spectator</strong>: This collision preset ignores all the actors by default, except the <strong>WorldStatic</strong> <a id="id232" class="indexterm"/>object responses. This preset also sets the <strong>Object Type</strong> of the collision to <strong>Pawn</strong> and is useful when you want players to see a game in multiplayer situations. Lastly, the <strong>Collision Enabled</strong> <a id="id233" class="indexterm"/>property is set to <strong>No Physics Collision</strong>.</li><li class="listitem"><strong>Character Mesh</strong>: This collision preset is a <strong>Pawn Object Type</strong> that is used for a <strong>Character </strong><a id="id234" class="indexterm"/><strong>Mesh</strong> when you create a player character. By default, this preset ignores the <strong>Visibility</strong> trace response and the <strong>Pawn</strong> and <strong>Vehicle</strong> object responses, although it blocks the remaining values. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>.</li><li class="listitem"><strong>Destructible</strong>: This <a id="id235" class="indexterm"/>collision preset is a <strong>Destructible Object Type</strong> that is used for assets that can be destructible in the game. By default, this preset blocks all the <strong>Trace</strong> and <strong>Object Channels</strong>. Its <strong>Collision Enabled</strong> property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>Invisible Wall</strong>: This collision preset is a <strong>World Static Object Type</strong> that is used as an <a id="id236" class="indexterm"/>invisible wall that blocks all the <strong>Trace</strong> and <strong>Object Responses</strong>, except the <strong>Visibility Trace Response</strong>, which this preset ignores. This preset works exactly similar to a blocking volume. Lastly, its <strong>Collision Enabled</strong> property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>Invisible Wall Dynamic</strong>: This collision preset is a <strong>World Dynamic Object Type</strong> that is <a id="id237" class="indexterm"/>used as an invisible wall that functions exactly similar to the <strong>Invisible Wall</strong> collision preset, in which it blocks all the <strong>Trace</strong> and <strong>Object Responses</strong>, except the <strong>Visibility Trace Response</strong>, which this preset also ignores. Lastly, its <strong>Collision Enabled</strong> property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>Trigger</strong>: This collision preset is a <strong>World Dynamic Object Type</strong> that is used as a <strong>Trigger</strong>, meaning that it functions similar to a <strong>Trigger Volume</strong> so that we can use it to <a id="id238" class="indexterm"/>call all the events and functions in our game. By default, the <strong>Trigger Collision Preset</strong> overlaps all the <strong>Trace</strong> and <strong>Object Channel Responses</strong>, except the <strong>Visibility Trace Channel</strong>, which this preset ignores. Lastly, its <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>.</li><li class="listitem"><strong>Ragdoll</strong>: This collision preset is used to simulate skeletal mesh components. Its <strong>Object Type</strong> <a id="id239" class="indexterm"/>is set to <strong>Physics Body</strong>. We can use this <a id="id240" class="indexterm"/>preset for character meshes that would turn rag doll when players are killed or lose control and would want the player character to be taken over by physics. By default, this collision preset blocks all the <strong>Trace</strong> and <strong>Object Responses</strong>, except the <strong>Pawn Object Response</strong>, which it ignores. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>Vehicle</strong>: This collision <a id="id241" class="indexterm"/>preset is a <strong>Vehicle Object Type</strong> that is used for any moving vehicle assets in our game world. By default, this preset blocks all the <strong>Trace</strong> and <strong>Object Responses</strong>. Its <strong>Collision Enabled</strong> <a id="id242" class="indexterm"/>property is set to <strong>Collision Enabled</strong>.</li><li class="listitem"><strong>UI</strong>: This collision <a id="id243" class="indexterm"/>preset is a <strong>World Dynamic Object Type</strong> that is used for any <strong>UI</strong> assets (such as <strong>UMG HUD</strong> elements). By default, this preset overlaps all the <strong>Trace</strong> and <strong>Object Responses</strong>, except the <strong>Visibility Trace </strong><a id="id244" class="indexterm"/><strong>Response</strong>, which this preset blocks. Lastly, the <strong>Collision Enabled</strong> property is set to <strong>No Physics Collision</strong>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec42"/>In-depth collision presets – a section review</h1></div></div></div><p>In this section, we <a id="id245" class="indexterm"/>took an in-depth look at all the collision presets that Unreal <a id="id246" class="indexterm"/>Engine 4 provides users by default, and by doing so, we analyzed the purpose and functionalities of each. Now that we have covered collision presets, we can now conclude this chapter and move on to discussing constraints in Unreal Engine 4.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we discussed how collision works and how it is implemented in Unreal Engine 4 by first analyzing the topics of trace and collision responses. We also discussed how these responses work, their parameter values, and how to implement these responses to our blueprint assets in detail.</p><p>Next, you learned about simple and complex collisions by defining what each type is and how they are used. We also looked at its pros and cons and how to generate the different types of simple collision.</p><p>Additionally, you learned more about complex collisions and how to generate these types of collisions in Unreal Engine 4. You also looked at how to create custom collision hulls in third-party art programs.</p><p>Furthermore, you learned about collision interactions. We used the <strong>First Person Projectile</strong> blueprint as an example of how these interactions are used when it comes to scripting different behaviors for our assets.</p><p>Moreover, we went through the purposes of custom objects and trace channels. We discussed how to create custom collision presets, including how to implement these customized parameters in blueprints.</p><p>Lastly, we discussed the different collision presets that exist in Unreal Engine 4, their purposes, and how they function in detail.</p><p>Now that we have a stronger understanding of how collision works and how to implement the different collisions for our assets, we can now dive deep into creating constraints in Unreal Engine 4.</p></div></body></html>