<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Collision"><div class="titlepage" id="aid-11C3M2"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Collision</h1></div></div></div><p>In this chapter, we will analyze collision in Unreal Engine 4, what it is, the different types of collision that exist in the engine, how to use it, and how to apply it to both static meshes and blueprints. To start with, we will first take an overview look of the different collisions that exist in Unreal Engine 4, but we will also cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Simple versus complex collision</li><li class="listitem">Generating simple collision</li><li class="listitem">Creating complex and custom collision hulls</li><li class="listitem">Collision interactions</li><li class="listitem">Custom object and trace channels</li><li class="listitem">In-depth collision presets</li></ul></div><p>For the purposes of this chapter, we will continue to work with Unreal Engine 4 using the <span class="strong"><strong>Unreal_PhyProject</strong></span> that we created in the first chapter.</p><div class="section" title="Collision and Trace Responses – an overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Collision and Trace Responses – an overview</h1></div></div></div><p>In the <a id="id127" class="indexterm"/>real world and in Unreal Engine 4, we define collision as an <a id="id128" class="indexterm"/>overlap of two or more objects. In the context of Unreal Engine 4, <span class="strong"><strong>Collision</strong></span> and <span class="strong"><strong>Trace Responses</strong></span> lay the groundwork for how Unreal Engine 4 handles collision and ray casting during the game. Every object that is given collision gets an <span class="strong"><strong>Object Type</strong></span> and a series of responses that describe how it interacts with the other object types. In the event of either a collision or an overlap of two or more objects, all objects involved can be set to affect or to be affected by blocking, overlapping, or ignoring one another.</p><p>
<span class="strong"><strong>Trace Responses</strong></span> describe how an object should react when you interact with a trace, which is done with a ray cast. An object can choose to block, overlap, or even ignore a trace from a particular source. By default, there are two different <span class="strong"><strong>Trace Responses</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Visibility</strong></span>: This <a id="id129" class="indexterm"/>specifies a trace from one position to another</li><li class="listitem"><span class="strong"><strong>Camera</strong></span>: This is <a id="id130" class="indexterm"/>exactly similar to the <span class="strong"><strong>Visibility</strong></span> trace response, but it should be used when you use a ray cast from the camera</li></ul></div><p>
<span class="strong"><strong>Object Responses</strong></span> describe how an object should respond when you interact with other objects in our game world. Similar to <span class="strong"><strong>Trace Responses</strong></span>, <span class="strong"><strong>Object Responses</strong></span> offer the ability to choose whether or not an object will block, overlap, or ignore other objects when a collision occurs. By default, there are six different types of <span class="strong"><strong>Object Responses</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>WorldStatic</strong></span>: This <a id="id131" class="indexterm"/>object response is for objects in our game world that are static, meaning that they do not and cannot be moved by any means. Objects such as volumes, world geometry, or any other meshes in the game world are associated to this object response.</li><li class="listitem"><span class="strong"><strong>WorldDynamic</strong></span>: This <a id="id132" class="indexterm"/>object response is for objects in our game world that are moving actors, outside of player pawns, physics bodies, vehicles, and destructible actors. Examples of <span class="strong"><strong>WorldDynamic</strong></span> objects would be an elevator, a door that can open and close, or a wheel that a player can turn.</li><li class="listitem"><span class="strong"><strong>Pawn</strong></span>: This object response is for player characters in our game or any other character that <a id="id133" class="indexterm"/>can be possessed by the player.</li><li class="listitem"><span class="strong"><strong>PhysicsBody</strong></span>: This <a id="id134" class="indexterm"/>object response is for any physics body or object that can be simulated with physics in our game world. An example of a <span class="strong"><strong>PhysicsBody</strong></span> object would be a basketball that the player can pick <a id="id135" class="indexterm"/>up and throw; <span class="emphasis"><em>Half-Life 2</em></span> is a great example of how physics body object collisions are used in games.</li><li class="listitem"><span class="strong"><strong>Vehicle</strong></span>: Although this object response is labeled as <span class="strong"><strong>Vehicle</strong></span>, what this response is useful <a id="id136" class="indexterm"/>for is to have player pawns jump into them, such as a vehicle.</li><li class="listitem"><span class="strong"><strong>Destructible</strong></span>: This object response is for any actors that are destructible, meaning that they can <a id="id137" class="indexterm"/>break apart using the destructible mesh editor.</li></ul></div><p>When you work on setting up collisions on an object or a component in Unreal Engine 4 blueprints, you will see the following properties:</p><div class="mediaobject"><img src="../Images/image00235.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>It is important to note that we want to make sure that our static mesh or blueprint component has collision generated before setting any collision presets to that object; otherwise, we will not receive any responses once a collision occurs. Later in this chapter, we will go into more detail on how to generate simple and complex collisions for our objects.</p><p>When it comes to setting up <span class="strong"><strong>Collisions</strong></span> to an object, there are numerous collision presets that default to Unreal Engine 4 that either ignores, overlaps, or blocks a combination of trace and object responses. In addition to these presets, we do have the option to create a custom collision preset for certain circumstances in our blueprint. Feel free to explore some of the collision presets and how they differentiate from one another, but for the sake of this text, let's take a look at some of the more common presets. We will take an in-depth look at the following <a id="id138" class="indexterm"/>presets later on in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>No Collision</strong></span>: As the <a id="id139" class="indexterm"/>name suggests, this collision preset eliminates any collision responses by setting the <span class="strong"><strong>Visibility</strong></span> trace response and the <span class="strong"><strong>Camera</strong></span> trace response to ignore and sets <span class="strong"><strong>Collision Enabled</strong></span> to <span class="strong"><strong>No Collision</strong></span>. Typically, we would use this for blueprint components that we don't want to react to any collisions that may occur.<div class="mediaobject"><img src="../Images/image00236.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Block All</strong></span>: This collision preset causes all the collisions with the associated component to <a id="id140" class="indexterm"/>result in a block. Alternatively, it causes all the objects involved in this collision to hit and bounce off one another if physics are applied. This is done by setting all the responses, including the trace and object responses, to <span class="strong"><strong>Block</strong></span> under their <span class="strong"><strong>Collision Responses</strong></span>, as shown in the following screenshot:<div class="mediaobject"><img src="../Images/image00237.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Overlap All</strong></span>: This collision preset results in all the collisions to generate an overlap between all the <a id="id141" class="indexterm"/>objects involved in the collision. As long as the <span class="strong"><strong>Generate Overlap Events</strong></span> property is checked, we can use the blueprint collision events to enable behaviors or events to occur once this type is involved in a collision.<div class="mediaobject"><img src="../Images/image00238.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Pawn</strong></span>: This collision preset is useful if it is used for a player pawn or character in our <a id="id142" class="indexterm"/>game. By default, it is set to block <span class="strong"><strong>Object Responses</strong></span>, block the <span class="strong"><strong>Camera</strong></span> trace response, and ignore the <span class="strong"><strong>Visibility</strong></span> trace response:<div class="mediaobject"><img src="../Images/image00239.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Physics Actor</strong></span>: This collision preset is used for any actor or component that is a physics-based <a id="id143" class="indexterm"/>actor, meaning that the object has in-game physics (such as gravity) applied to it. In order for this preset to work properly, we want to make sure that the <span class="strong"><strong>Simulate Physics</strong></span> property in the <span class="strong"><strong>Physics Tab</strong></span> is checked. By default, all the <span class="strong"><strong>Trace Responses</strong></span> and <span class="strong"><strong>Object Responses</strong></span> are set to <span class="strong"><strong>Block</strong></span>:<div class="mediaobject"><img src="../Images/image00240.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>These are just a few of the different options that Unreal Engine 4 offers by default for collision, and we will cover the other options in more detail later on in this chapter. Although there are a handful of options when it comes to collision presets offered in Unreal Engine 4 by <a id="id144" class="indexterm"/>default, a really nice feature that is in place is the ability to create your own trace, object channels, and collision presets. To do this, we need to navigate to the <span class="strong"><strong>Edit</strong></span> window and select <span class="strong"><strong>Project Settings</strong></span>:</p><div class="mediaobject"><img src="../Images/image00241.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>From here, we need to navigate to the <span class="strong"><strong>Collision</strong></span> option in the <span class="strong"><strong>Engine</strong></span> category:</p><div class="mediaobject"><img src="../Images/image00242.jpeg" alt="Collision and Trace Responses – an overview"/></div><p style="clear:both; height: 1em;"> </p><p>In this menu, we can create custom collision presets, specify which object and trace channels to either ignore, overlap, or block, give it a specific name, and save it to the project file. For advanced <a id="id145" class="indexterm"/>needs, we can also create custom object and trace channels in this window. Later in this chapter, we will create our own custom collision preset and apply it to an object.</p></div></div>
<div class="section" title="Collision and Trace Responses &#x2013; a section review" id="aid-12AK81"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Collision and Trace Responses – a section review</h1></div></div></div><p>In this section, we <a id="id146" class="indexterm"/>briefly looked at the different <span class="strong"><strong>Collision</strong></span> and <span class="strong"><strong>Trace Responses</strong></span> that exist in Unreal Engine 4 and defined a handful of these responses. We analyzed the different <span class="strong"><strong>Trace Responses</strong></span> and <span class="strong"><strong>Object Responses</strong></span> that default to Unreal Engine 4, and we also defined a limited number of collision presets that are provided. Now that we have a basic understanding of <span class="strong"><strong>Collision</strong></span> and <span class="strong"><strong>Trace Responses</strong></span>, we can move forward and learn more about simple and complex collision in Unreal Engine 4.</p></div>
<div class="section" title="Simple versus complex collision"><div class="titlepage" id="aid-1394Q2"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Simple versus complex collision</h1></div></div></div><p>In <a id="id147" class="indexterm"/>Unreal Engine 4, we will be able to autogenerate <a id="id148" class="indexterm"/>collisions for our meshes that can be used in our game. There are two different types of collision that exist in Unreal Engine 4: simple and complex collision. Each type of collision serves its own unique purpose, and in this section, we will simply define each collision type and provide examples of each. Later on in this chapter, we will work on how to apply these collisions to our objects. We will also test these collisions in our game. Let's begin with simple collision.</p><p>A simple collision is a collision mesh that uses basic shapes, such as boxes, spheres, capsules, and convex shapes, to define the bounds of our object. Convex shapes are ones that have one or more interior angles that are less than 180 degrees, whereas concave shapes are ones that possess one or more interior angles that are more than 180 degrees, as shown in the following image:</p><div class="mediaobject"><img src="../Images/image00243.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to these basic shapes, we can generate a form of simple collision called <span class="strong"><strong>KDOP</strong></span> or <span class="strong"><strong>K Discrete Oriented Polytope</strong></span> (where K is the number of axis-aligned planes). What <a id="id149" class="indexterm"/>this option essentially does is that it takes the <span class="emphasis"><em>K</em></span> axis-aligned planes and moves them as close as possible to the selected mesh. We will go into more detail on how to generate these different types of simple collision later on. Now, let's define the different types of simple collision here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Sphere</strong></span>: This <a id="id150" class="indexterm"/>creates a spherical bound mesh <a id="id151" class="indexterm"/>around the selected object. It can be used in <a id="id152" class="indexterm"/>physics objects and to apply collision to objects that are round.<div class="mediaobject"><img src="../Images/image00244.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Capsule</strong></span>: This <a id="id153" class="indexterm"/>creates a capsule bound mesh around the selected object and is typically used for character or pawn meshes:<div class="mediaobject"><img src="../Images/image00245.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>Box</strong></span>: This <a id="id154" class="indexterm"/>creates a box bound mesh around the <a id="id155" class="indexterm"/>selected object. This type of simple collision is most commonly used for environment meshes:<div class="mediaobject"><img src="../Images/image00246.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>10DOP X</strong></span>: This <a id="id156" class="indexterm"/>creates a box with four edges beveled in the <span class="emphasis"><em>X</em></span>-aligned edges:<div class="mediaobject"><img src="../Images/image00247.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>10DOP Y</strong></span>: This <a id="id157" class="indexterm"/>creates a box with four edges <a id="id158" class="indexterm"/>beveled in the <span class="emphasis"><em>Y</em></span>-aligned edges:<div class="mediaobject"><img src="../Images/image00248.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>10DOP Z</strong></span>: This <a id="id159" class="indexterm"/>creates a box with four edges beveled in <a id="id160" class="indexterm"/>the <span class="emphasis"><em>Z</em></span>-aligned edges:<div class="mediaobject"><img src="../Images/image00249.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>18DOP</strong></span>: This <a id="id161" class="indexterm"/>creates a box with all of its edges beveled:<div class="mediaobject"><img src="../Images/image00250.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><span class="strong"><strong>26DOP</strong></span>: This <a id="id162" class="indexterm"/>creates a box with all of its edges and <a id="id163" class="indexterm"/>corners beveled:<div class="mediaobject"><img src="../Images/image00251.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>The main advantage of simple collision is that it almost eliminates the possibility of an object getting stuck to a player or vice versa. An additional advantage is that the collision mesh is of a basic shape, which is less expensive to use in the game at runtime.</p><p>Complex collision is done for each polygon and is very expensive in Unreal Engine 4 as compared to simple collision. Moreover, complex collision is never used for an actor that is simulating physics, and it will just fall through the game world. In order to enable complex collision in the <span class="strong"><strong>Static Mesh</strong></span> editor, we need to navigate to <span class="strong"><strong>Details Panel</strong></span> and then to the <span class="strong"><strong>Static Mesh Settings</strong></span> section. It is here that we can change the <span class="strong"><strong>Collision Complexity</strong></span> parameter to <a id="id164" class="indexterm"/>
<span class="strong"><strong>Use Simple Collision As Complex</strong></span> or <span class="strong"><strong>Use Complex Collision As Simple</strong></span>:</p><div class="mediaobject"><img src="../Images/image00252.jpeg" alt="Simple versus complex collision"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Simple versus complex collision &#x2013; a section review" id="aid-147LC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Simple versus complex collision – a section review</h1></div></div></div><p>In this section, we looked at the different simple collisions offered by default in the <span class="strong"><strong>Static Mesh</strong></span> editor in <a id="id165" class="indexterm"/>Unreal Engine 4. We also discussed the advantages and disadvantages of the simple and complex collision when it comes to game development and engine performance. Lastly, we briefly looked at how to create both these types of collision. With a basic understanding of simple and complex collision under our belts, we can now discuss how to create simple collision, and how to create collision hulls in Unreal Engine 4 later on.</p></div>
<div class="section" title="Creating simple collisions"><div class="titlepage" id="aid-1565U2"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Creating simple collisions</h1></div></div></div><p>When it <a id="id166" class="indexterm"/>comes to creating collisions, there are many <a id="id167" class="indexterm"/>options that we can take advantage of to properly utilize collision and optimize game performance. As we discussed in the previous section, we have the option to create simple and complex collisions in the <span class="strong"><strong>Static Mesh</strong></span> editor in Unreal Engine 4, but we can also use third-party art programs to create custom collision hulls. Let's first discuss how to create simple collisions in Unreal Engine 4, and in the next section, we will discuss how to create complex and custom collisions for our assets.</p><p>Let's begin by opening <code class="literal">StarterContent</code> and navigating to <span class="strong"><strong>Content Browser</strong></span>. From here, let's go to the <code class="literal">StarterContent</code> folder and select the <code class="literal">Shapes</code> folder that contains multiple simple-shaped static meshes to select from. For this set of examples, we will choose the <code class="literal">Shape_Trim</code> mesh because it is a more complicated shape as compared to a sphere or box; this way, we can see the effects of different collision options. Double-click on the <code class="literal">Shape_Trim</code> asset to open the <span class="strong"><strong>Static Mesh</strong></span> editor.</p><div class="mediaobject"><img src="../Images/image00253.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>Navigating to the <span class="strong"><strong>Static Mesh</strong></span> editor is very similar to moving around in the <span class="strong"><strong>Perspective</strong></span> view mode in the main game editor of Unreal Engine 4. At the top of the <span class="strong"><strong>Static Mesh</strong></span> editor is the main <a id="id168" class="indexterm"/>toolbar that provides a handful of useful options when you view your mesh and its collision.</p><div class="mediaobject"><img src="../Images/image00254.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The toolbar provides us the options to save our mesh and its properties, to view the mesh in real time, which is useful if the mesh has an animated material applied to it, to view any applied <span class="strong"><strong>Sockets</strong></span>, to toggle the <span class="strong"><strong>Wireframe</strong></span> of the mesh, to view any <span class="strong"><strong>Vertex Colors</strong></span> applied to the mesh, to toggle a background <span class="strong"><strong>Grid</strong></span>, to toggle the <span class="strong"><strong>Bounds</strong></span> of the mesh, and (most importantly) to toggle the <span class="strong"><strong>Collision</strong></span> applied to the mesh. Additionally, we can view the mesh's <span class="strong"><strong>Pivot Point</strong></span>, its <span class="strong"><strong>Normals</strong></span>, <span class="strong"><strong>Tangents</strong></span>, <span class="strong"><strong>Bi-Normals</strong></span>, and <span class="strong"><strong>UV</strong></span> sheet.</p><p>As we will <a id="id169" class="indexterm"/>work primarily with collisions, we will want to make sure that the <span class="strong"><strong>Collision</strong></span> option is toggled on so that we can see the bounds of the bounding collision mesh. To do this, we can left-click on the <span class="strong"><strong>Collision</strong></span> button to make sure that it's highlighted in orange, and if the mesh has any collision applied to it, we will see it in a light blue-colored wireframe around our object. By default, <code class="literal">Shape_Trim</code> does have a collision applied to it, so we first want to remove this collision so that we are able to apply only one collision mesh to the object at once for demonstration purposes.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, navigate to the <span class="strong"><strong>Collision</strong></span> drop-down window at the very top of the <span class="strong"><strong>Static Mesh</strong></span> editor located alongside the <span class="strong"><strong>File</strong></span>, <span class="strong"><strong>Edit</strong></span>, <span class="strong"><strong>Asset</strong></span> window options.</li><li class="listitem">Then, select <span class="strong"><strong>Remove Collision</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>Now, the light blue-colored wireframe outline mesh will disappear from our mesh, meaning that this asset no longer has any collision applied to it. It is also very important to keep in mind that we do not want more than one collision-bounding mesh applied to an object at once in order to keep our assets as optimized as possible, unless the shape of the mesh demands more than one collision mesh.</p><p>When it comes to generating simple collision in the <span class="strong"><strong>Static Mesh</strong></span> editor, it is as easy as clicking on a few buttons in its interface. Let's start by creating a <span class="strong"><strong>Sphere</strong></span> collision in our <code class="literal">Shape_Trim</code> mesh by clicking on the <span class="strong"><strong>Collision</strong></span> drop-down menu and selecting <span class="strong"><strong>Add Sphere Simplified Collision</strong></span>. Once complete, we should see a collision-bounding mesh that looks <a id="id170" class="indexterm"/>similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00255.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The <span class="strong"><strong>Sphere Simplified Collision</strong></span> option sets the radius of the sphere that best matches the size and shape of the mesh that it is applied to. We should also note that the collision wireframe changed <a id="id171" class="indexterm"/>from light blue to green; this means that the collision will use a simple shape. Once a collision is generated, the shape can be moved, rotated, and scaled to the desired size and shape. For this shape, a sphere collision does not seem to work as we would like it to work, so let's select the <span class="strong"><strong>Remove Collision</strong></span> option from the <span class="strong"><strong>Collision</strong></span> drop-down list and then the <span class="strong"><strong>Add Capsule Simplified Collision</strong></span> option.</p><div class="mediaobject"><img src="../Images/image00256.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, the <span class="strong"><strong>Capsule Simplified Collision</strong></span> option does a much better job of matching the size and shape of our mesh than the <span class="strong"><strong>Sphere Simplified Collision</strong></span> option because it sets the capsule's height and radius as opposed to just setting the radius. We can still see that the collision-bounding mesh does not fit this shape as closely as we would like, so <a id="id172" class="indexterm"/>let's continue to add differently shaped collision meshes in order to find the best one.</p><p>Let's remove the <a id="id173" class="indexterm"/>capsule collision-bounding mesh and instead select the <span class="strong"><strong>Add Box Simplified Collision</strong></span> option to <code class="literal">Shape_Trim</code>. Here, we can see that the box shape does a really good job of matching the size and shape of the mesh, and in most situations, we would use this option for this asset for use in our game.</p><div class="mediaobject"><img src="../Images/image00257.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>For the purposes of this chapter, we will continue to apply the <span class="strong"><strong>KDOP Collision</strong></span> options to this mesh so that we have a better understanding of their purposes and the results that we can get from these options. Now, let's remove the <span class="strong"><strong>Box Simplified Collision</strong></span> option and use the <span class="strong"><strong>Add 10DOP-X Simplified Collision</strong></span> option. If you remember from the previous section, the <span class="strong"><strong>10DOP-X Simplified Collision</strong></span> creates a box with four edges beveled in the <a id="id174" class="indexterm"/>
<span class="emphasis"><em>X</em></span>-aligned edges. Then, we get the following <a id="id175" class="indexterm"/>result:</p><div class="mediaobject"><img src="../Images/image00258.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, the <span class="strong"><strong>10DOP-X Simplified Collision</strong></span> option generates a collision-bounding mesh identical to the <span class="strong"><strong>Box Simplified Collision</strong></span> option. Now, let's try applying the <span class="strong"><strong>10DOP-Y Simplified Collision</strong></span> option, which creates a box with four edges beveled in the <span class="emphasis"><em>Y</em></span>-aligned edges by first removing the <span class="strong"><strong>10DOP-X Simplified Collision</strong></span> option and then selecting the <span class="strong"><strong>Add 10DOP-Y Simplified Collision</strong></span> option to obtain the following collision mesh:</p><div class="mediaobject"><img src="../Images/image00259.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see here, the <span class="strong"><strong>10DOP-Y Simplified Collision</strong></span> option does an excellent job of almost exactly matching the size and shape of our <code class="literal">Shape_Trim</code> static mesh. This is definitely a viable option to select when you generate a collision for this asset. Lastly, let's apply the <span class="strong"><strong>10DOP-Z Simplified Collision</strong></span> option to view how it generates a collision mesh around our asset. First, let's remove the <span class="strong"><strong>10DOP-Y Simplified Collision</strong></span> option and then <a id="id176" class="indexterm"/>navigate to the <span class="strong"><strong>Collision</strong></span> drop-down menu and select <span class="strong"><strong>Add 10DOP-Z Simplified Collision</strong></span>, which creates a box with four edges beveled in the <a id="id177" class="indexterm"/>
<span class="emphasis"><em>Z</em></span>-aligned axis to obtain the following result:</p><div class="mediaobject"><img src="../Images/image00260.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>The result is identical to what we obtained when we applied the <span class="strong"><strong>Box Simplified Collision</strong></span> and <span class="strong"><strong>10DOP-X Simplified Collision</strong></span> options. Based on the results we received from these options, the best choices for this asset would either be <span class="strong"><strong>Box Simplified Collision</strong></span> or <span class="strong"><strong>10DOP-Y Simplified Collision</strong></span>. Due to the simplicity of this asset, the <span class="strong"><strong>18DOP</strong></span> and <span class="strong"><strong>26DOP Simplified Collision</strong></span> options won't produce unique options, so to properly demonstrate these choices, we need to choose a different asset.</p><p>To demonstrate this, let's close <span class="strong"><strong>Static Mesh</strong></span> editor for the <code class="literal">Shape_Trim</code> asset and navigate to <span class="strong"><strong>Content Browser</strong></span>. Here, under the <code class="literal">Starter Content</code> folder in the <code class="literal">Props</code> folder, we will double-click on the <code class="literal">SM_Chair</code> asset to open this mesh in <span class="strong"><strong>Static Mesh</strong></span> editor. The <code class="literal">SM_Chair</code> asset does have the default collision applied to it, so before we apply our own, let's first remove its collision. Then, let's go ahead and select the <span class="strong"><strong>18DOP </strong></span>
<a id="id178" class="indexterm"/>
<span class="strong"><strong>Simplified Collision</strong></span> option and view how it generates a <a id="id179" class="indexterm"/>collision-bounding mesh for our chair:</p><div class="mediaobject"><img src="../Images/image00261.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>If you remember, the <span class="strong"><strong>18DOP Simplified Collision</strong></span> option creates a collision-bounding box with all of its edges beveled, creating a nice collision around our chair. Here, let's apply the <span class="strong"><strong>26DOP Simplified Collision</strong></span> option by first removing our collision and then selecting the <span class="strong"><strong>Add 26DOP Simplified Collision</strong></span> option:</p><div class="mediaobject"><img src="../Images/image00262.jpeg" alt="Creating simple collisions"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the <span class="strong"><strong>26DOP Simplified Collision</strong></span> option creates a box that has all of its edges and <a id="id180" class="indexterm"/>corners beveled, creating a smoother and more <a id="id181" class="indexterm"/>rounded collision mesh around our asset.</p></div>
<div class="section" title="Creating simple collisions &#x2013; a section review" id="aid-164MG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Creating simple collisions – a section review</h1></div></div></div><p>In this section, we <a id="id182" class="indexterm"/>took a more in-depth look at the different types of <a id="id183" class="indexterm"/>simple collision that can be generated in the <span class="strong"><strong>Static Mesh</strong></span> editor in Unreal Engine 4 and the pros and cons of each type. Using starter content assets as examples, we applied each type of simple collision to view how they are generated based on the size and shape of our asset to better understand how they work. Now that we have taken a deeper look at how to generate simple collisions in Unreal Engine 4, let's now move on and take a look at how to generate complex and custom collision hulls using Unreal Engine 4.</p></div>
<div class="section" title="Creating complex and custom collision hulls"><div class="titlepage" id="aid-173722"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Creating complex and custom collision hulls</h1></div></div></div><p>When it <a id="id184" class="indexterm"/>comes to creating complex collision <a id="id185" class="indexterm"/>in the <span class="strong"><strong>Static Mesh</strong></span> editor, we can use the <a id="id186" class="indexterm"/>
<span class="strong"><strong>Auto Convex Collision</strong></span> tool to customize <a id="id187" class="indexterm"/>the number of hulls and hull vertices that the collision mesh will have. For the purposes of this section, we will need to continue using <code class="literal">Unreal_PhyProject</code> that we created, and we will use the <code class="literal">SM_Lamp_Wall</code> asset as an example of how to generate custom and complex collision hulls. To navigate to this asset, we need to go to <span class="strong"><strong>Content Browser</strong></span> and then to the <code class="literal">Starter Content</code> folder. Now, under props, we will find the <code class="literal">SM_Lamp_Wall</code> asset. Double-click on this asset to open the <span class="strong"><strong>Static Mesh</strong></span> editor. If this static mesh has any default collisions applied to it, make sure to remove the said collision by navigating to the <span class="strong"><strong>Collision</strong></span> drop-down menu and selecting remove collision. Make sure that the <span class="strong"><strong>Collision Toggle</strong></span> option is set to on so that we can view the collision mesh in the <span class="strong"><strong>Static Mesh</strong></span> editor.</p><p>For this asset, we will use the <span class="strong"><strong>Auto Convex Collision</strong></span> tool that provides us with a set of parameters to generate <span class="strong"><strong>Complex Collision</strong></span>. To use this tool, we need to navigate to the <span class="strong"><strong>Collision</strong></span> drop-down menu and select the <span class="strong"><strong>Auto Convex Collision</strong></span> option. Once done, we will be <a id="id188" class="indexterm"/>provided with a submenu on the right-hand <a id="id189" class="indexterm"/>side under <span class="strong"><strong>Details Panel</strong></span> labeled as <a id="id190" class="indexterm"/>
<span class="strong"><strong>Convex Decomposition</strong></span> with the following parameters:</p><div class="mediaobject"><img src="../Images/image00263.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Max Hulls</strong></span>: This parameter determines the number of hulls that are created to best match the size and shape of the mesh.</li><li class="listitem"><span class="strong"><strong>Max Hull Verts</strong></span>: This parameter sets the maximum number of collision hull vertices. By increasing this value, we can see how complex the collision hulls can be.</li><li class="listitem"><span class="strong"><strong>Apply</strong></span>: This parameter generates a collision mesh based on the <span class="strong"><strong>Max Hulls</strong></span> and <span class="strong"><strong>Max Hull Verts</strong></span> parameters.</li><li class="listitem"><span class="strong"><strong>Defaults</strong></span>: This parameter resets the <span class="strong"><strong>Max Hulls</strong></span> and <span class="strong"><strong>Max Hull Verts</strong></span> parameters back to their default values of <code class="literal">4</code> and <code class="literal">12</code> respectively (as seen in the previous image).</li></ul></div><p>For the sake of <a id="id191" class="indexterm"/>providing examples, let's apply <span class="strong"><strong>Auto Convex Collision</strong></span> to our <code class="literal">SM_Lamp_Wall</code> mesh and set the <span class="strong"><strong>Max Hulls</strong></span> and <span class="strong"><strong>Max Hull Verts</strong></span> parameters to their default values of <code class="literal">4</code> and <code class="literal">12</code> respectively:</p><div class="mediaobject"><img src="../Images/image00264.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>To really <a id="id192" class="indexterm"/>view the power of this tool, let's try <a id="id193" class="indexterm"/>applying <span class="strong"><strong>Auto Convex Collision</strong></span> <a id="id194" class="indexterm"/>to the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Max Hulls</strong></span>: Set this parameter to <code class="literal">1</code></li><li class="listitem"><span class="strong"><strong>Max </strong></span><a id="id195" class="indexterm"/><span class="strong"><strong>Hull Verts</strong></span>: Set this parameter to <code class="literal">6</code></li></ul></div><p>Then, we should see the following result:</p><div class="mediaobject"><img src="../Images/image00265.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, setting these parameters to the lowest values possible will result in a collision mesh that does the bare minimum and does not fit the size and shape of our lamp. Now, let's try applying <span class="strong"><strong>Auto Convex Collision</strong></span> to the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Max Hulls</strong></span>: Set this paramerter to 24</li><li class="listitem"><span class="strong"><strong>Max Hull Verts</strong></span>: Set this paramerter to 32</li></ul></div><div class="mediaobject"><img src="../Images/image00266.jpeg" alt="Creating complex and custom collision hulls"/></div><p style="clear:both; height: 1em;"> </p><p>With the maximum settings applied to the convex collision mesh, we can see that it does a much better job of covering the lamp in terms of its size and shape. In the end, we would want to choose a setting somewhere between the lowest and highest values for the <span class="strong"><strong>Max Hulls</strong></span> and <span class="strong"><strong>Max Hull Verts</strong></span> parameters in order to create the most optimized collision <a id="id196" class="indexterm"/>possible for our assets.</p><p>Now that <a id="id197" class="indexterm"/>we have covered the methods of <a id="id198" class="indexterm"/>how to create collisions with the tools offered in the <span class="strong"><strong>Static Mesh</strong></span> editor of Unreal Engine 4, we will now briefly discuss how to create and import collisions created in third-party art programs (such as 3ds Max or Maya).</p><p>The idea behind <a id="id199" class="indexterm"/>creating customized collision geometry is to make it as simple as possible in order to optimize collision detection when you play the game. The more complicated the collision geometry for an object, the more calculations are required by the engine to ensure that the collision is done correctly on that object. When you import the <code class="literal">.FBX</code> file to Unreal Engine 4, the collision meshes included in this file are identified by the importer based on their name. Here is the collision-naming syntax required to ensure proper collision when you import your assets to Unreal Engine 4:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>UBX_[Mesh Name]</strong></span>: This naming syntax is required when you import collision meshes that are box shaped, using either the box object type in 3ds Max or the cube primitive in Maya. Keep in mind that if you move any of the vertices of the box collision in the third-party art program or deform the shape in any way to make it anything other than a rectangular prism, the import will not work.</li><li class="listitem"><span class="strong"><strong>USP_[Mesh Name]</strong></span>: This naming syntax is required when you import collision meshes that are sphere shaped, using the sphere object type in 3ds Max and Maya. The sphere itself in the third-party art program does not need to have a specific number of segments because it is converted to a true sphere for collision once it is imported to Unreal Engine 4.</li><li class="listitem"><span class="strong"><strong>UCX_[Mesh Name]</strong></span>: This naming syntax is required when you import collision meshes that are convex shaped or a shape that is completely closed and does not have an interior angle of more than 180 degrees.</li></ul></div><p>When you <a id="id200" class="indexterm"/>import the <code class="literal">.FBX</code> files that contain <a id="id201" class="indexterm"/>collision meshes, there are a few concepts <a id="id202" class="indexterm"/>that we have to keep in mind:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">At the time of writing this book, spheres are only used for rigid-body collisions and Unreal's zero-extent traces, such as weapons, and not for instances (such as player movements).</li><li class="listitem">In the naming syntax mentioned earlier, the <span class="strong"><strong>Mesh Name</strong></span> component must be identical to the name of the mesh that the collision is associated with in the third- party art program. An example would be a box collision mesh for an object named <code class="literal">Chair_01</code> would be labeled as <code class="literal">UBX_Chair_01</code>, or if there are multiple <a id="id203" class="indexterm"/>collision meshes for this object, an additional collision mesh could be named <code class="literal">UBX_Chair_01_02</code>, and so on.</li><li class="listitem">Once the collision meshes are created and named properly, we can export both the collision and the mesh that the collision is associated with in the <code class="literal">.FBX</code> file. Once imported, Unreal Engine 4 will find the collision, separate it from the actual mesh, and transform it into a collision model.</li><li class="listitem">In the instance that an object has a collision composed of multiple shapes, the best results are found when the collision hulls do not intersect with one another.</li></ol><div style="height:10px; width: 1px"/></div></div>
<div class="section" title="Creating complex and custom collision hulls &#x2013; a section review" id="aid-181NK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Creating complex and custom collision hulls – a section review</h1></div></div></div><p>In this <a id="id204" class="indexterm"/>section, we took an in-depth look at <a id="id205" class="indexterm"/>how to create more complex collisions. We also <a id="id206" class="indexterm"/>looked at how to create custom collision <a id="id207" class="indexterm"/>hulls in third-party art programs (such as 3ds Max and Maya). Moreover, we analyzed the <span class="strong"><strong>Auto Convex Collision</strong></span> tool in the <span class="strong"><strong>Static Mesh</strong></span> editor of Unreal Engine 4. We also discussed how the <span class="strong"><strong>Max Hulls</strong></span> and <span class="strong"><strong>Max Hull Verts</strong></span> parameters affect the collision that is generated around our asset. Lastly, we looked at all the necessary naming conventions required in our art applications that ensure proper <a id="id208" class="indexterm"/>exporting and importing of our meshes and <a id="id209" class="indexterm"/>collisions to Unreal Engine 4. Now that we have a very strong understanding of how to generate collisions in Unreal <a id="id210" class="indexterm"/>Engine 4 and third-party art applications, we can now talk about about the different collision interactions that exist in Unreal Engine 4 in detail.</p></div>
<div class="section" title="Collision interactions"><div class="titlepage" id="aid-190862"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Collision interactions</h1></div></div></div><p>After <a id="id211" class="indexterm"/>discussing a lot about what collision is and how to generate different types of collision, let's now talk about how the different collision responses function when you interact with the player and other objects in our game world. For the purposes of this section, we will want to have <code class="literal">Unreal_PhyProject</code> open, and we will work with the <code class="literal">FirstPersonExampleMap</code> level and use the default starter content to analyze these interactions.</p><p>In <code class="literal">FirstPersonExampleMap</code>, we will find numerous cube physics actors spread across the surface of the level (each starting awake and active at game time). If we select any of these cube actors in the editor by left-clicking on it, we will see the following <span class="strong"><strong>Collision</strong></span> settings in its <span class="strong"><strong>Details Panel</strong></span>:</p><div class="mediaobject"><img src="../Images/image00267.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, these actors will use <span class="strong"><strong>Physics Actor</strong></span> collision preset and have an <span class="strong"><strong>Object Type</strong></span> of <span class="strong"><strong>PhysicsBody</strong></span>. If we were to jump to the level with the first person project example (which we have in place) by pressing <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>P</em></span>, we can shoot these cubes with the <span class="strong"><strong>First-Person Projectile</strong></span> blueprint by left-clicking on it. We can see that on colliding, there is an impulse created that causes the boxes to be pushed, and the collision itself causes the projectile to bounce off because it is also a physics object that has <span class="strong"><strong>Physics Body Object Response</strong></span> set to <span class="strong"><strong>Block</strong></span>. To get a better idea of what is happening, let's open the <span class="strong"><strong>First Person Projectile</strong></span> blueprint by navigating to <span class="strong"><strong>Content Browser</strong></span> and then to the <code class="literal">First Person BP</code> folder. In the <code class="literal">Blueprints</code> folder, we will find the <span class="strong"><strong>First Person Projectile</strong></span> blueprint. Double-click on this asset to open its blueprint. It will bring us to the main <span class="strong"><strong>Event Graph</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00268.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>If we are viewing the blueprint graph for the first time, this may be a little confusing, but we can easily break down the logic flow and understand exactly what the projectile will do once it's spawned and collides with an actor.</p><p>Let's first <a id="id212" class="indexterm"/>look at the main event of this graph: the <span class="strong"><strong>Event Hit</strong></span> event node. What this event node checks for is whether or not the main root component of the blueprint is hit in a collision. In this case, the main root of this blueprint is the <span class="strong"><strong>Sphere Collision Component</strong></span> option, labeled as <span class="strong"><strong>Collision Component</strong></span>. Let's select this component by left-clicking on <span class="strong"><strong>Collision Component</strong></span> in the <span class="strong"><strong>Components</strong></span> tab in the top-left corner of the blueprint screen and then view its collision in <span class="strong"><strong>Details Panel</strong></span>:</p><div class="mediaobject"><img src="../Images/image00269.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>When you view its collision, you will see that it is set exactly similar to the physics cube actors in the level, possessing a <span class="strong"><strong>Physics Actor</strong></span> collision preset and an <span class="strong"><strong>Object Type</strong></span> set to <span class="strong"><strong>Physics Body</strong></span>. What this means in terms of collision is that this projectile will act similar to a normal physics ball, such as a baseball or a basketball, when spawned into our game world. A ball in both the real world and our game world will more than likely end up hitting something, and when it does, our <span class="strong"><strong>Event Hit</strong></span> node will be called.</p><p>What happens next in the <span class="strong"><strong>First Person Projectile</strong></span> blueprint is that it checks whether or not the other component that hits our projectile is a box, a wall, a player, or the floor. In particular, this blueprint will check whether the other hit component of any collision to this projectile is <span class="strong"><strong>Simulating Physics</strong></span> or a physics actor. The <span class="strong"><strong>Is Simulating Physics</strong></span> function node returns a <span class="strong"><strong>Boolean</strong></span> value (<span class="strong"><strong>True</strong></span> or <span class="strong"><strong>False</strong></span>), irrespective of whether or not the other hit component is a physics actor. We then use a <span class="strong"><strong>Branch</strong></span> node that uses this <span class="strong"><strong>True</strong></span> or <span class="strong"><strong>False</strong></span> condition from the <span class="strong"><strong>Is Simulating Physics</strong></span> function to perform actions based on whether or not the hit component is a physics actor. We can see that from the <span class="strong"><strong>True</strong></span> execution pin, we can add an impulse at the location of the projectile and use the <span class="strong"><strong>Other Component</strong></span> of the <span class="strong"><strong>Hit</strong></span> collision as our target to apply this impulse to. To determine the force of this impulse, we can perform a simple multiplication between the velocity vector of the projectile. We multiply it by a constant <span class="strong"><strong>Float</strong></span> value. In addition to <span class="strong"><strong>Add Impulse at Location</strong></span>, this math is what causes the physics cube to bounce or react to the projectile on collision, and <span class="strong"><strong>Is Simulating Physics</strong></span> checks to ensure that no impulses are created when hitting the walls, the floor, or even the player. To have some fun with this <a id="id213" class="indexterm"/>blueprint, let's change the constant Float value from <code class="literal">100</code> to <code class="literal">1000</code> and see how it drastically changes the results when the projectile hits a physics object.</p><p>To change the way this projectile behaves in the game, we can change its collision preset from <span class="strong"><strong>Physics Actor</strong></span> to <span class="strong"><strong>Custom</strong></span> so that we can individually set how the collision interacts with the different object responses. For example, let's set the <span class="strong"><strong>Physics Body</strong></span> object response from <span class="strong"><strong>Block</strong></span> to <span class="strong"><strong>Overlap</strong></span> and then compile the blueprint so that we can see the changes in the game. The result is that the projectile goes straight through the physics cube. However, it still reacts normally to the <span class="strong"><strong>World Static</strong></span> object type (such as the floor and the walls). This is because we changed the object response to <span class="strong"><strong>Physics Body</strong></span> from <span class="strong"><strong>Block</strong></span> to <span class="strong"><strong>Overlap</strong></span>. This causes the <span class="strong"><strong>Event Hit</strong></span> event node to never get called.</p><p>In the blueprints of Unreal Engine 4, there are event nodes we can use when objects overlap. This is called the <span class="strong"><strong>On Component Begin</strong></span> overlap. As we made our projectile use the <span class="strong"><strong>Custom Collision</strong></span> preset that overlaps the physics bodies in the game, we can use the <span class="strong"><strong>On Component Begin Overlap</strong></span> event node to have any number of actions to take place during this collision. To set up a basic example in our projectile blueprint, select the <span class="strong"><strong>Collision Component</strong></span> option in the <span class="strong"><strong>Components</strong></span> tab so that it is highlighted. Next, right-click on an empty space of <span class="strong"><strong>Event Graph</strong></span> and navigate to <span class="strong"><strong>Add Event</strong></span> for <span class="strong"><strong>Collision Component</strong></span> and then to <span class="strong"><strong>Collision</strong></span>. Finally, select the <span class="strong"><strong>Add On Component Begin Overlap</strong></span> event node.</p><div class="mediaobject"><img src="../Images/image00270.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>To have a similar behavior to what we had in the <span class="strong"><strong>Event Hit</strong></span> node checking for objects that are physics actors, let's copy and paste the <span class="strong"><strong>Is Simulating Physics</strong></span> function node and <span class="strong"><strong>Branch</strong></span> that was used in the original blueprint logic and connect the nodes, as shown in the following <a id="id214" class="indexterm"/>screenshot:</p><div class="mediaobject"><img src="../Images/image00271.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>So far, we had our projectile check for objects in our world that are physics actors once the collision is overlapped, but we have no actions taking place if this check is <span class="strong"><strong>True</strong></span> or <span class="strong"><strong>False</strong></span>. Instead of performing any kind of complicated actions, we will simply use the <span class="strong"><strong>Print String</strong></span> function to print the dialogue to our console so that we know that the check is working. Let's right-click on the empty space of <span class="strong"><strong>Event Graph</strong></span> and search for the <span class="strong"><strong>Print String</strong></span> function node. In the <span class="strong"><strong>In String</strong></span> parameter, enter <code class="literal">Overlapped Physics Body</code>, and connect it to the <span class="strong"><strong>True</strong></span> executional output pin, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00272.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>If we click on the <span class="strong"><strong>Compile</strong></span> button at the top of the blueprint and play the game, we can see that the projectile goes right through our physics objects, but we do not see our <span class="strong"><strong>Print String</strong></span> outputted to the console. This is because both the physics cubes in the level and our projectile collision don't have the <span class="strong"><strong>Generate Overlap Events</strong></span> parameter set to <span class="strong"><strong>True</strong></span> by default, so let's select one or more of the cubes and navigate to their <span class="strong"><strong>Collision Settings</strong></span> in <span class="strong"><strong>Details Panel</strong></span> and make sure that <span class="strong"><strong>Generate Overlap Events</strong></span> is set to <span class="strong"><strong>True</strong></span>. Let's perform the same function to <span class="strong"><strong>Collision Component</strong></span> in our projectile blueprint. Now, if we play again and shoot the physics cubes that we customized, we will now see our <span class="strong"><strong>Print String</strong></span> <a id="id215" class="indexterm"/>outputted to the console.</p><div class="mediaobject"><img src="../Images/image00273.jpeg" alt="Collision interactions"/></div><p style="clear:both; height: 1em;"> </p><p>From here, feel free to experiment and customize the collision presets that the projectile has, see how it changes and reacts in our game world, and add more blueprint functionalities to see what else is possible.</p><p>The last collision interaction that can exist between objects, apart from <span class="strong"><strong>Block</strong></span> and <span class="strong"><strong>Overlap</strong></span>, is the <span class="strong"><strong>Ignore</strong></span> option. There is not much to this type of <span class="strong"><strong>Collision Response</strong></span> because it will ignore the different <span class="strong"><strong>Object Responses</strong></span> completely if it is set to <span class="strong"><strong>Ignore</strong></span>. For the purpose of our example, in our <span class="strong"><strong>First Person Projectile</strong></span> blueprint, let's change the <span class="strong"><strong>Physics Body</strong></span> object response from <span class="strong"><strong>Overlap</strong></span> to <span class="strong"><strong>Ignore</strong></span>. If we play now, we can shoot at the physics cubes, but it will go completely through the object, and neither the <span class="strong"><strong>On Component Begin Overlap</strong></span> nor the <span class="strong"><strong>Event Hit</strong></span> event nodes will be called.</p></div>
<div class="section" title="Collision interactions &#x2013; a section review" id="aid-19UOO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Collision interactions – a section review</h1></div></div></div><p>In this section, we got our hands dirty by applying the different combinations of collision presets to the <span class="strong"><strong>First Person Projectile</strong></span> blueprint to see how it interacts with the physics actors in our game world. By setting the <span class="strong"><strong>Physics Body</strong></span> object response to <span class="strong"><strong>Block</strong></span>, the <span class="strong"><strong>Event Hit</strong></span> event node will be called. Also, an impulse will be created at the projectiles' location, resulting in a small push force applied to the physics actor the projectile collides with. By setting the <span class="strong"><strong>Physics Body</strong></span> object response to <span class="strong"><strong>Overlap</strong></span>, we can use the <span class="strong"><strong>On Component Begin Overlap Event</strong></span> node to call different actions once the projectile overlaps with a physics <a id="id216" class="indexterm"/>actor. We just need to make sure that the physics actors in our level and our projectile have the <span class="strong"><strong>Generate Overlap Events</strong></span> set to <span class="strong"><strong>True</strong></span>. Lastly, we briefly discussed the results of when our projectile has the <span class="strong"><strong>Physics Body</strong></span> object response set to <span class="strong"><strong>Ignore</strong></span>. Like the name suggests, it ignores the object response, and no events are fired. Now that we talked more about collision interactions, let's move on and discuss how to create and use custom object and trace channel responses in Unreal Engine 4.</p></div>
<div class="section" title="Custom object and trace channel responses"><div class="titlepage" id="aid-1AT9A2"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Custom object and trace channel responses</h1></div></div></div><p>Sometimes, the default object and trace channel responses are not enough for what we want to <a id="id217" class="indexterm"/>do in our games. So, it may be necessary to create customized object and trace channel responses for certain assets and scenarios. To <a id="id218" class="indexterm"/>accomplish this, we can navigate to the <span class="strong"><strong>Edit</strong></span> drop-down window at the top of the Unreal Engine 4 editor and select <span class="strong"><strong>Project Settings</strong></span>. From here, select the <span class="strong"><strong>Collision</strong></span> option under the <span class="strong"><strong>Engine</strong></span> section. Here, we can create custom <span class="strong"><strong>Objects</strong></span>, <span class="strong"><strong>Trace Channels</strong></span>, and <span class="strong"><strong>Presets</strong></span> that we can use when we apply collisions to our assets.</p><p>Let's start with creating a new <span class="strong"><strong>Object Channel</strong></span> by selecting this option and clicking on the <span class="strong"><strong>New Object Channel</strong></span> button. Here, a dialogue window pops up. Then, we can customize how <span class="strong"><strong>Object Channel</strong></span> responds by default.</p><div class="mediaobject"><img src="../Images/image00274.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>Name the <span class="strong"><strong>Object Channel</strong></span> <code class="literal">Projectile</code>, and set its <span class="strong"><strong>Default Response</strong></span> to <span class="strong"><strong>Block</strong></span>. Now, let's create a custom <span class="strong"><strong>Collision Preset</strong></span> by selecting this option and selecting the <span class="strong"><strong>New</strong></span> button so that a dialogue window appears. Here, we can set the presets default values:</p><div class="mediaobject"><img src="../Images/image00275.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>We can also name this new <span class="strong"><strong>Collision Preset Profile</strong></span>, <code class="literal">Projectile</code>, set the <span class="strong"><strong>Collision Enabled</strong></span> property to <span class="strong"><strong>Collision Enabled</strong></span>, <span class="strong"><strong>Object Type</strong></span> to <code class="literal">Projectile</code>, (the one that we have just created), and the <span class="strong"><strong>Description</strong></span> property to anything that will remind us of what this <span class="strong"><strong>Collision Preset</strong></span> is used for. Lastly, we can set all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Channels</strong></span> for this preset to <span class="strong"><strong>Block</strong></span>.</p><p>For the <a id="id219" class="indexterm"/>purposes of this section's demonstration, we won't create a custom <span class="strong"><strong>Trace Channel</strong></span>, but if we ever needed to, it works exactly <a id="id220" class="indexterm"/>similar to creating a custom <span class="strong"><strong>Object Channel</strong></span>; select the <span class="strong"><strong>Trace Channels</strong></span> option, left-click on the <span class="strong"><strong>New Trace Channel</strong></span> button, name the channel, and set the <span class="strong"><strong>Default Response</strong></span> to either <span class="strong"><strong>Block</strong></span>, <span class="strong"><strong>Overlap</strong></span>, or <span class="strong"><strong>Ignore</strong></span>.</p><p>Now that we have created a custom <span class="strong"><strong>Object Channel</strong></span> and a custom <span class="strong"><strong>Collision Preset</strong></span>, let's apply these to the <span class="strong"><strong>Collision Component</strong></span> of the <span class="strong"><strong>First Person Projectile</strong></span> blueprint. Once you are in the <span class="strong"><strong>First Person Projectile</strong></span> blueprint, select the <span class="strong"><strong>Collision</strong></span> component from the <span class="strong"><strong>Components</strong></span> tab in the top-left corner and navigate to the <span class="strong"><strong>Collision</strong></span> section of the <span class="strong"><strong>Details Panel</strong></span> in the bottom-right corner of the blueprint window. If we look at the <span class="strong"><strong>Collision Presets</strong></span> drop-down menu, we will see our <code class="literal">Projectile</code> <span class="strong"><strong>Collision Preset</strong></span> available, and when we select this option, we will see the default values that we set:</p><div class="mediaobject"><img src="../Images/image00276.jpeg" alt="Custom object and trace channel responses"/></div><p style="clear:both; height: 1em;"> </p><p>We can also see our <code class="literal">Projectile</code> <span class="strong"><strong>Object Channel Response</strong></span> that we created earlier in the <span class="strong"><strong>Object Responses</strong></span> section of the <span class="strong"><strong>Collision Component</strong></span>. Now, if we ever need to, we can set all <a id="id221" class="indexterm"/>of our projectile assets to have the <span class="strong"><strong>Projectile Collision Preset</strong></span> so that all of our projectiles behave the same during collisions. In addition to this, we can have other assets collide in a specific way to projectiles by setting the <span class="strong"><strong>Projectile</strong></span> object response to <span class="strong"><strong>Block</strong></span>, <span class="strong"><strong>Overlap</strong></span>, or <span class="strong"><strong>Ignore</strong></span> projectiles on <a id="id222" class="indexterm"/>colliding. Now, when we play the game, we can see that the <span class="strong"><strong>First Person Projectile</strong></span> blueprint behaves exactly as intended when you fire the projectile.</p><p>Just as a reminder, we can only have up to 18 custom <span class="strong"><strong>Object Channels</strong></span> and <span class="strong"><strong>Trace Channels</strong></span>, and if we ever delete an <span class="strong"><strong>Object Type</strong></span> that has been used in our game, it will revert back to <span class="strong"><strong>WorldStatic</strong></span>, and if we delete a trace channel that has been used in our game, the behavior of the trace is undefined.</p></div>
<div class="section" title="Custom object and trace channel responses &#x2013; a section review" id="aid-1BRPS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Custom object and trace channel responses – a section review</h1></div></div></div><p>In this section, we took a deeper look at how to create and implement custom objects, trace channels, and custom collision presets. We then applied these customized channels and presets to the <a id="id223" class="indexterm"/>
<span class="strong"><strong>First Person Projectile</strong></span> blueprint and found that we can have the same collision behavior exist for the projectile when we <a id="id224" class="indexterm"/>use custom collision presets and <span class="strong"><strong>Object</strong></span> channels. Now that we have created our very own custom object and trace channels and created our own collision preset, we can now move on and take an in-depth look at the additional default collision presets that exist in Unreal Engine 4.</p></div>
<div class="section" title="In-depth collision presets"><div class="titlepage" id="aid-1CQAE2"><div><div><h1 class="title"><a id="ch03lvl1sec41"/>In-depth collision presets</h1></div></div></div><p>To conclude this <a id="id225" class="indexterm"/>chapter, let's briefly discuss the remaining collision presets <a id="id226" class="indexterm"/>available in Unreal Engine 4 that we have not gone through at this point:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Custom</strong></span>: This <a id="id227" class="indexterm"/>collision preset allows you to fully customize how you want the collision to behave by selecting the <span class="strong"><strong>Collision Enabled</strong></span> property, setting the <span class="strong"><strong>Object Type</strong></span> property, and fully customizing how the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span> react to different types of collisions. This type of collision preset is useful when we need to customize an assets collision, and where the default collision presets does not fit the type of collision we need.</li><li class="listitem"><span class="strong"><strong>Block All Dynamic</strong></span>: This collision preset blocks all the actors by default and makes the <a id="id228" class="indexterm"/>collision itself a <span class="strong"><strong>WorldDynamic</strong></span> object. This type of collision preset is useful for dynamic objects or objects that can move in your game world that you want to block when you collide with other objects. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>Overlap All Dynamic</strong></span>: This collision preset overlaps all the actors by default and makes <a id="id229" class="indexterm"/>the collision itself a <span class="strong"><strong>WorldDynamic</strong></span> object. This type of collision preset is useful for dynamic objects that you want to overlap when you collide with other objects. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>, meaning that the assets' collision won't use game physics.</li><li class="listitem"><span class="strong"><strong>Ignore Only Pawn</strong></span>: This collision preset blocks all the actors by default, but it ignores <a id="id230" class="indexterm"/>the <span class="strong"><strong>Pawn</strong></span> and <span class="strong"><strong>Vehicle</strong></span> object responses. This preset also sets the <span class="strong"><strong>Object Type</strong></span> of the collision to <span class="strong"><strong>WorldDynamic</strong></span> and is useful for assets that you want to ignore for <span class="strong"><strong>Pawns</strong></span> and <span class="strong"><strong>Vehicles</strong></span> in your game world. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li><li class="listitem"><span class="strong"><strong>Overlap Only Pawn</strong></span>: This collision preset blocks all the actors by default, but it <a id="id231" class="indexterm"/>overlaps the <span class="strong"><strong>Pawn</strong></span> and <span class="strong"><strong>Vehicle</strong></span> object responses. It also overlaps the <span class="strong"><strong>Camera</strong></span> trace channel. This preset also sets the <span class="strong"><strong>Object Type</strong></span> of the collision to <span class="strong"><strong>WorldDynamic</strong></span> and is useful for assets that need overlap events to fire when it is overlapped during a collision with <span class="strong"><strong>Pawns</strong></span>, <span class="strong"><strong>Vehicles</strong></span>, and <span class="strong"><strong>Camera Traces</strong></span>. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li><li class="listitem"><span class="strong"><strong>Spectator</strong></span>: This collision preset ignores all the actors by default, except the <span class="strong"><strong>WorldStatic</strong></span> <a id="id232" class="indexterm"/>object responses. This preset also sets the <span class="strong"><strong>Object Type</strong></span> of the collision to <span class="strong"><strong>Pawn</strong></span> and is useful when you want players to see a game in multiplayer situations. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> <a id="id233" class="indexterm"/>property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li><li class="listitem"><span class="strong"><strong>Character Mesh</strong></span>: This collision preset is a <span class="strong"><strong>Pawn Object Type</strong></span> that is used for a <span class="strong"><strong>Character </strong></span><a id="id234" class="indexterm"/><span class="strong"><strong>Mesh</strong></span> when you create a player character. By default, this preset ignores the <span class="strong"><strong>Visibility</strong></span> trace response and the <span class="strong"><strong>Pawn</strong></span> and <span class="strong"><strong>Vehicle</strong></span> object responses, although it blocks the remaining values. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li><li class="listitem"><span class="strong"><strong>Destructible</strong></span>: This <a id="id235" class="indexterm"/>collision preset is a <span class="strong"><strong>Destructible Object Type</strong></span> that is used for assets that can be destructible in the game. By default, this preset blocks all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Channels</strong></span>. Its <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>Invisible Wall</strong></span>: This collision preset is a <span class="strong"><strong>World Static Object Type</strong></span> that is used as an <a id="id236" class="indexterm"/>invisible wall that blocks all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span>, except the <span class="strong"><strong>Visibility Trace Response</strong></span>, which this preset ignores. This preset works exactly similar to a blocking volume. Lastly, its <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>Invisible Wall Dynamic</strong></span>: This collision preset is a <span class="strong"><strong>World Dynamic Object Type</strong></span> that is <a id="id237" class="indexterm"/>used as an invisible wall that functions exactly similar to the <span class="strong"><strong>Invisible Wall</strong></span> collision preset, in which it blocks all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span>, except the <span class="strong"><strong>Visibility Trace Response</strong></span>, which this preset also ignores. Lastly, its <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>Trigger</strong></span>: This collision preset is a <span class="strong"><strong>World Dynamic Object Type</strong></span> that is used as a <span class="strong"><strong>Trigger</strong></span>, meaning that it functions similar to a <span class="strong"><strong>Trigger Volume</strong></span> so that we can use it to <a id="id238" class="indexterm"/>call all the events and functions in our game. By default, the <span class="strong"><strong>Trigger Collision Preset</strong></span> overlaps all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Channel Responses</strong></span>, except the <span class="strong"><strong>Visibility Trace Channel</strong></span>, which this preset ignores. Lastly, its <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li><li class="listitem"><span class="strong"><strong>Ragdoll</strong></span>: This collision preset is used to simulate skeletal mesh components. Its <span class="strong"><strong>Object Type</strong></span> <a id="id239" class="indexterm"/>is set to <span class="strong"><strong>Physics Body</strong></span>. We can use this <a id="id240" class="indexterm"/>preset for character meshes that would turn rag doll when players are killed or lose control and would want the player character to be taken over by physics. By default, this collision preset blocks all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span>, except the <span class="strong"><strong>Pawn Object Response</strong></span>, which it ignores. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>Vehicle</strong></span>: This collision <a id="id241" class="indexterm"/>preset is a <span class="strong"><strong>Vehicle Object Type</strong></span> that is used for any moving vehicle assets in our game world. By default, this preset blocks all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span>. Its <span class="strong"><strong>Collision Enabled</strong></span> <a id="id242" class="indexterm"/>property is set to <span class="strong"><strong>Collision Enabled</strong></span>.</li><li class="listitem"><span class="strong"><strong>UI</strong></span>: This collision <a id="id243" class="indexterm"/>preset is a <span class="strong"><strong>World Dynamic Object Type</strong></span> that is used for any <span class="strong"><strong>UI</strong></span> assets (such as <span class="strong"><strong>UMG HUD</strong></span> elements). By default, this preset overlaps all the <span class="strong"><strong>Trace</strong></span> and <span class="strong"><strong>Object Responses</strong></span>, except the <span class="strong"><strong>Visibility Trace </strong></span><a id="id244" class="indexterm"/><span class="strong"><strong>Response</strong></span>, which this preset blocks. Lastly, the <span class="strong"><strong>Collision Enabled</strong></span> property is set to <span class="strong"><strong>No Physics Collision</strong></span>.</li></ul></div></div>
<div class="section" title="In-depth collision presets &#x2013; a section review" id="aid-1DOR01"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec42"/>In-depth collision presets – a section review</h1></div></div></div><p>In this section, we <a id="id245" class="indexterm"/>took an in-depth look at all the collision presets that Unreal <a id="id246" class="indexterm"/>Engine 4 provides users by default, and by doing so, we analyzed the purpose and functionalities of each. Now that we have covered collision presets, we can now conclude this chapter and move on to discussing constraints in Unreal Engine 4.</p></div>
<div class="section" title="Summary" id="aid-1ENBI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we discussed how collision works and how it is implemented in Unreal Engine 4 by first analyzing the topics of trace and collision responses. We also discussed how these responses work, their parameter values, and how to implement these responses to our blueprint assets in detail.</p><p>Next, you learned about simple and complex collisions by defining what each type is and how they are used. We also looked at its pros and cons and how to generate the different types of simple collision.</p><p>Additionally, you learned more about complex collisions and how to generate these types of collisions in Unreal Engine 4. You also looked at how to create custom collision hulls in third-party art programs.</p><p>Furthermore, you learned about collision interactions. We used the <span class="strong"><strong>First Person Projectile</strong></span> blueprint as an example of how these interactions are used when it comes to scripting different behaviors for our assets.</p><p>Moreover, we went through the purposes of custom objects and trace channels. We discussed how to create custom collision presets, including how to implement these customized parameters in blueprints.</p><p>Lastly, we discussed the different collision presets that exist in Unreal Engine 4, their purposes, and how they function in detail.</p><p>Now that we have a stronger understanding of how collision works and how to implement the different collisions for our assets, we can now dive deep into creating constraints in Unreal Engine 4.</p></div></body></html>