["```cpp\n    char *greet(const char *name) {\n      char buffer[100];\n      snprintf(buffer, 100, \"hello %s\", name);\n      return strdup(buffer);\n    }\n\n    void test() {\n      const char *who = \"world\";\n      char *hw = greet(who);\n      assert(strcmp(hw, \"hello world\") == 0);\n      free(hw);\n    }\n```", "```cpp\n    std::string greet(const std::string& name) {\n      return \"hello \" + name;\n    }\n\n    void test() {\n      std::string who = \"world\";\n      assert(greet(who) == \"hello world\");\n    }\n```", "```cpp\n    namespace std {\n      template<typename T>\n      class reference_wrapper {\n        T *m_ptr;\n        public:\n        reference_wrapper(T& t) noexcept : m_ptr(&t) {}\n\n        operator T& () const noexcept { return *m_ptr; }\n        T& get() const noexcept { return *m_ptr; }\n      };\n\n      template<typename T>\n      reference_wrapper<T> ref(T& t);\n    } // namespace std\n```", "```cpp\n     int result = 0;\n     auto task = [](int& r) {\n       r = 42;\n     };\n\n     // Trying to use a native reference wouldn't compile.\n     //std::thread t(task, result);\n\n     // Correctly pass result \"by reference\" to the new thread.\n     std::thread t(task, std::ref(result));\n```", "```cpp\n    enum class Color {\n      RED = 1,\n      BLACK = 2,\n    };\n\n    enum class Size {\n      SMALL = 1,\n      MEDIUM = 2,\n      LARGE = 3,\n    };\n```", "```cpp\n    data SixType = ColorandSizeOf Color Size;\n    data FiveType = ColorOf Color | SizeOf Size;\n```", "```cpp\n    using sixtype = std::pair<Color, Size>;\n    using fivetype = std::variant<Color, Size>;\n```", "```cpp\n    template<class A, class B>\n    struct pair {\n      A first;\n      B second;\n    };\n```", "```cpp\n    using Author = std::pair<std::string, std::string>;\n    std::vector<Author> authors = {\n      {\"Fyodor\", \"Dostoevsky\"},\n      {\"Sylvia\", \"Plath\"},\n      {\"Vladimir\", \"Nabokov\"},\n      {\"Douglas\", \"Hofstadter\"},\n    };\n\n    // Sort by first name then last name.\n    std::sort(\n      authors.begin(), authors.end(),\n      [](auto&& a, auto&& b) {\n        return std::tie(a.first, a.second) < std::tie(b.first, b.second);\n      }\n    );\n    assert(authors[0] == Author(\"Douglas\", \"Hofstadter\"));\n\n    // Sort by last name then first name.\n    std::sort(\n      authors.begin(), authors.end(),\n      [](auto&& a, auto&& b) {\n        return std::tie(a.second, a.first) < std::tie(b.second, b.first);\n      }\n    );\n    assert(authors[0] == Author(\"Fyodor\", \"Dostoevsky\"));\n```", "```cpp\n    std::string s;\n    int i;\n\n    // Assign both s and i at once.\n    std::tie(s, i) = std::make_tuple(\"hello\", 42);\n```", "```cpp\n    auto [i, j, k] = std::tuple{1, 2, 3};\n\n    // make_tuple decays reference_wrapper...\n    auto t1 = std::make_tuple(i, std::ref(j), k);\n    static_assert(std::is_same_v< decltype(t1),\n      std::tuple<int, int&, int>\n    >);\n\n    // ...whereas the deduced constructor does not.\n    auto t2 = std::tuple(i, std::ref(j), k);\n    static_assert(std::is_same_v< decltype(t2),\n      std::tuple<int, std::reference_wrapper<int>, int>\n    >);\n```", "```cpp\n        template<class T>\n        constexpr size_t tuple_size(T&&)\n        {\n          return std::tuple_size_v<std::remove_reference_t<T>>;\n        }\n\n        template<class... Ts>\n        constexpr size_t simpler_tuple_size(const std::tuple<Ts...>&)\n        {\n          return sizeof...(Ts);\n        }\n```", "```cpp\n        template<typename F>\n        void run_zeroarg(const F& f);\n\n        template<typename F, typename... Args>\n        void run_multiarg(const F& f, Args&&... args)\n        {\n          auto fwd_args =\n            std::forward_as_tuple(std::forward<Args>(args)...);\n          auto lambda = [&f, fwd_args]() {\n            std::apply(f, fwd_args);\n          };\n          run_zeroarg(f);\n        }\n```", "```cpp\n    std::variant<int, double> v1;\n\n    v1 = 1; // activate the \"int\" member\n    assert(v1.index() == 0);\n    assert(std::get<0>(v1) == 1);\n\n    v1 = 3.14; // activate the \"double\" member\n    assert(v1.index() == 1);\n    assert(std::get<1>(v1) == 3.14);\n    assert(std::get<double>(v1) == 3.14);\n\n    assert(std::holds_alternative<int>(v1) == false);\n    assert(std::holds_alternative<double>(v1) == true);\n\n    assert(std::get_if<int>(&v1) == nullptr);\n    assert(*std::get_if<double>(&v1) == 3.14);\n```", "```cpp\n    // Worst...\n    try {\n      std::cout << std::get<int>(v1) << std::endl;\n    } catch (const std::bad_variant_access&) {}\n\n    // Still bad...\n    if (v1.index() == 0) {\n      std::cout << std::get<int>(v1) << std::endl; \n    }\n\n    // Slightly better... \n    if (std::holds_alternative<int>(v1)) {\n      std::cout << std::get<int>(v1) << std::endl;\n    } \n\n    // ...Best.\n    if (int *p = std::get_if<int>(&v1)) {\n      std::cout << *p << std::endl; \n    }\n```", "```cpp\n    struct Visitor {\n      double operator()(double d) { return d; }\n      double operator()(int i) { return double(i); }\n      double operator()(const std::string&) { return -1; }\n    };\n\n    using Var = std::variant<int, double, std::string>;\n\n    void show(Var v)\n    {\n      std::cout << std::visit(Visitor{}, v) << std::endl;\n    }\n\n    void test() \n    {\n      show(3.14);\n      show(1);\n      show(\"hello world\");\n    }\n```", "```cpp\n    std::visit([](const auto& alt) {\n      if constexpr (std::is_same_v<decltype(alt), const std::string&>) {\n        std::cout << double(-1) << std::endl;\n      } else {\n        std::cout << double(alt) << std::endl;\n      }\n    }, v);\n```", "```cpp\n    struct MultiVisitor {\n      template<class T, class U, class V>\n      void operator()(T, U, V) const { puts(\"wrong\"); }\n\n      void operator()(char, int, double) const { puts(\"right!\"); }\n    };\n\n    void test()\n    {\n      std::variant<int, double, char> v1 = 'x';\n      std::variant<char, int, double> v2 = 1;\n      std::variant<double, char, int> v3 = 3.14;\n      std::visit(MultiVisitor{}, v1, v2, v3); // prints \"right!\"\n    }\n```", "```cpp\n    struct A {\n      A() { throw \"ha ha!\"; }\n    };\n    struct B {\n      operator int () { throw \"ha ha!\"; }\n    };\n    struct C {\n      C() = default;\n      C& operator=(C&&) = default;\n      C(C&&) { throw \"ha ha!\"; }\n    };\n\n    void test()\n    {\n      std::variant<int, A, C> v1 = 42;\n\n      try {\n        v1.emplace<A>();\n      } catch (const char *haha) {}\n      assert(v1.valueless_by_exception());\n\n      try {\n        v1.emplace<int>(B());\n      } catch (const char *haha) {}\n      assert(v1.valueless_by_exception());\n    }\n```", "```cpp\n    v1 = 42;\n\n    // Constructing the right-hand side of this assignment\n    // will throw; yet the variant is unaffected.\n    try { v1 = A(); } catch (...) {}\n    assert(std::get<int>(v1) == 42);\n\n    // In this case as well.\n    try { v1 = B(); } catch (...) {}\n    assert(std::get<int>(v1) == 42);\n\n    // But a throwing move-constructor can still foul it up.\n    try { v1 = C(); } catch (...) {}\n    assert(v1.valueless_by_exception());\n```", "```cpp\n    std::map<std::string, int> g_limits = {\n      { \"memory\", 655360 }\n    };\n\n    std::variant<std::monostate, int>\n    get_resource_limit(const std::string& key)\n    {\n      if (auto it = g_limits.find(key); it != g_limits.end()) {\n        return it->second;\n      }\n      return std::monostate{};\n    }\n\n    void test()\n    {\n      auto limit = get_resource_limit(\"memory\");\n      if (std::holds_alternative<int>(limit)) {\n        use( std::get<int>(limit) );\n      } else {\n        use( some_default );\n      }\n    }\n```", "```cpp\n    std::optional<int>\n    get_resource_limit(const std::string& key)\n    {\n      if (auto it = g_limits.find(key); it != g_limits.end()) {\n        return it->second;\n      }\n      return std::nullopt;\n    }\n\n    void test()\n    {\n      auto limit = get_resource_limit(\"memory\");\n      if (limit.has_value()) {\n        use( *limit );\n      } else {\n        use( some_default );\n      }\n    }\n```", "```cpp\n    std::optional<int> get_resource_limit(const std::string&);\n\n    void test() {\n      auto limit = get_resource_limit(\"memory\");\n      use( limit.value_or(some_default) );\n    }\n```", "```cpp\n    auto make_lambda(int arg) {\n      return [arg](int x) { return x + arg; };\n    }\n    using L = decltype(make_lambda(0));\n\n    static_assert(!std::is_default_constructible_v<L>);\n    static_assert(!std::is_move_assignable_v<L>);\n```", "```cpp\n    class ProblematicAdder {\n      L fn_;\n    };\n\n    static_assert(!std::is_default_constructible_v<ProblematicAdder>);\n```", "```cpp\n    class Adder {\n      std::optional<L> fn_;\n      public:\n      void setup(int first_arg) {\n        fn_.emplace(make_lambda(first_arg));\n      }\n      int call(int second_arg) {\n        // this will throw unless setup() was called first\n        return fn_.value()(second_arg);\n      }\n    };\n\n    static_assert(std::is_default_constructible_v<Adder>);\n\n    void test() {\n      Adder adder;\n      adder.setup(4);\n      int result = adder.call(5);\n      assert(result == 9); \n    }\n```", "```cpp\n    using JSONValue = std::variant<\n      std::nullptr_t,\n      bool,\n      double,\n      std::string,\n      std::vector<JSONValue>,\n      std::map<std::string, JSONValue>\n    >;\n```", "```cpp\n    using JSONValue = boost::variant<\n      std::nullptr_t,\n      bool,\n      double,\n      std::string,\n      std::vector<boost::recursive_variant_>,\n      std::map<std::string, boost::recursive_variant_>\n    >;\n```", "```cpp\n    struct JSONValue {\n      std::variant<\n        std::nullptr_t,\n        bool,\n        double,\n        std::string,\n        std::vector<JSONValue>,\n        std::map<std::string, JSONValue>\n      > value_;\n    };\n```", "```cpp\n    std::any a; // construct an empty container\n\n    assert(!a.has_value());\n\n    a = std::string(\"hello\");\n    assert(a.has_value());\n    assert(a.type() == typeid(std::string));\n\n    a = 42;\n    assert(a.has_value());\n    assert(a.type() == typeid(int));\n```", "```cpp\n    if (std::string *p = std::any_cast<std::string>(&a)) {\n      use(*p);\n    } else {\n      // go fish!\n    }\n\n    try {\n      std::string& s = std::any_cast<std::string&>(a);\n      use(s);\n    } catch (const std::bad_any_cast&) {\n      // go fish!\n    }\n```", "```cpp\n    template<class T> struct Widget {};\n\n    std::any get_widget() {\n      return std::make_any<Widget<int>>();\n    }\n```", "```cpp\n    template<class T> struct Widget {};\n\n    template<class T> int size(Widget<T>& w) {\n      return sizeof w;\n    }\n\n    void test()\n    {\n      std::any a = get_widget();\n      int sz = hypothetical_any_visit([](auto&& w){\n        return size(w);\n      }, a);\n      assert(sz == sizeof(Widget<int>));\n    }\n```", "```cpp\n    struct Animal {\n      virtual ~Animal() = default;\n    };\n\n    struct Cat : Animal {};\n\n    void test()\n    {\n      std::any a = Cat{};\n\n      // The held object is a \"Cat\"...\n      assert(a.type() == typeid(Cat));\n      assert(std::any_cast<Cat>(&a) != nullptr);\n\n      // Asking for a base \"Animal\" will not work.\n      assert(a.type() != typeid(Animal));\n      assert(std::any_cast<Animal>(&a) == nullptr);\n\n      // Asking for void* certainly will not work!\n      assert(std::any_cast<void>(&a) == nullptr);\n    }\n```", "```cpp\n    class any;\n\n    struct AnyBase {\n      virtual const std::type_info& type() = 0;\n      virtual void copy_to(any&) = 0;\n      virtual void move_to(any&) = 0;\n      virtual ~AnyBase() = default;\n    };\n\n    template<typename T>\n    struct AnyImpl : AnyBase {\n      T t_;\n      const std::type_info& type() {\n        return typeid(T);\n      }\n      void copy_to(any& rhs) override {\n        rhs.emplace<T>(t_);\n      }\n      void move_to(any& rhs) override {\n        rhs.emplace<T>(std::move(t_));\n      }\n      // the destructor doesn't need anything\n      // special in this case\n    };\n```", "```cpp\n    class any {\n      std::unique_ptr<AnyBase> p_ = nullptr;\n      public:\n      template<typename T, typename... Args>\n      std::decay_t<T>& emplace(Args&&... args) {\n        p_ = std::make_unique<AnyImpl<T>>(std::forward<Args>(args)...);\n      }\n\n      bool has_value() const noexcept {\n        return (p_ != nullptr);\n      }\n\n      void reset() noexcept {\n        p_ = nullptr;\n      }\n\n      const std::type_info& type() const {\n        return p_ ? p_->type() : typeid(void);\n      }\n\n      any(const any& rhs) {\n        *this = rhs;\n      }\n\n      any& operator=(const any& rhs) {\n        if (rhs.has_value()) {\n          rhs.p_->copy_to(*this);\n        }\n        return *this;\n      }\n    };\n```", "```cpp\n    using Ptr = std::unique_ptr<int>;\n\n    template<class T>\n    struct Shim {\n      T get() { return std::move(*t_); }\n\n      template<class... Args>\n      Shim(Args&&... args) : t_(std::in_place,\n        std::forward<Args>(args)...) {}\n\n      Shim(Shim&&) = default;\n      Shim& operator=(Shim&&) = default;\n      Shim(const Shim&) { throw \"oops\"; }\n      Shim& operator=(const Shim&) { throw \"oops\"; }\n      private:\n      std::optional<T> t_;\n    };\n\n    void test()\n    {\n      Ptr p = std::make_unique<int>(42);\n\n      // Ptr cannot be stored in std::any because it is move-only.\n      // std::any a = std::move(p);\n\n      // But Shim<Ptr> can be!\n      std::any a = Shim<Ptr>(std::move(p));\n      assert(a.type() == typeid(Shim<Ptr>));\n\n      // Moving a Shim<Ptr> is okay...\n      std::any b = std::move(a);\n\n      try {\n        // ...but copying a Shim<Ptr> will throw.\n        std::any c = b;\n      } catch (...) {}\n\n      // Get the move-only Ptr back out of the Shim<Ptr>.\n      Ptr r = std::any_cast<Shim<Ptr>&>(b).get();\n      assert(*r == 42);\n    }\n```", "```cpp\n    int my_abs(int x) { return x < 0 ? -x : x; }\n    long unusual(long x, int y = 3) { return x + y; }\n\n    void test()\n    {\n      std::function<int(int)> f; // construct an empty container\n      assert(!f);\n\n      f = my_abs; // store a function in the container\n      assert(f(-42) == 42);\n\n      f = [](long x) { return unusual(x); }; // or a lambda!\n      assert(f(-42) == -39);\n    }\n```", "```cpp\n    f = [i=0](int) mutable { return ++i; };\n    assert(f(-42) == 1); \n    assert(f(-42) == 2);\n\n    auto g = f;\n    assert(f(-42) == 3);\n    assert(f(-42) == 4);\n    assert(g(-42) == 3);\n    assert(g(-42) == 4);\n```", "```cpp\n    if (f.target_type() == typeid(int(*)(int))) {\n      int (*p)(int) = *f.target<int (*)(int)>();\n      use(p);\n    } else {\n      // go fish!\n    }\n```", "```cpp\n    // templated_for_each is a template and must be visible at the\n    // point where it is called.\n    template<class F>\n    void templated_for_each(std::vector<int>& v, F f) {\n      for (int& i : v) {\n        f(i);\n      }\n    }\n\n    // type_erased_for_each has a stable ABI and a fixed address.\n    // It can be called with only its declaration in scope.\n    extern void type_erased_for_each(std::vector<int>&,\n      std::function<void(int)>);\n```", "```cpp\n    auto capture = [](auto& p) {\n      using T = std::decay_t<decltype(p)>;\n      return std::make_shared<T>(std::move(p));\n    };\n\n   std::promise<int> p;\n\n   std::function<void()> f = [sp = capture(p)]() {\n     sp->set_value(42);\n   };\n```"]