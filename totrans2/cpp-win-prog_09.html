<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Formula Interpretation"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Formula Interpretation</h1></div></div></div><p>The spreadsheet program is capable of handling text, numerical values, and formulas composed by the four arithmetic operators. In order to do so, we need to interpret the formulas. We also need to find the sources of a formula (the cells referred to in the formula) and the targets of a cell (the cells affected by a change).</p><p>In this chapter, we will take a look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interpretation (scanning and parsing) of numerical expressions</li><li class="listitem" style="list-style-type: disc">Parse and syntax trees</li><li class="listitem" style="list-style-type: disc">Evaluation of formulas</li><li class="listitem" style="list-style-type: disc">References and matrices</li><li class="listitem" style="list-style-type: disc">Drawing of cells</li><li class="listitem" style="list-style-type: disc">Loading and saving of cells</li></ul></div><p>In the following spreadsheet, the <code class="literal">C3</code> cell is being edited:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_01.jpg" alt="Formula Interpretation"/></div><p>
</p><div class="section" title="Formula interpretation"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec40"/>Formula interpretation</h1></div></div></div><p>The core of a spreadsheet program is its ability to interpret formulas. When the user inputs a formula in a cell, it is interpreted and its value is evaluated. The process of formula interpretation is divided into three separate steps. First, given the input string, the <span class="strong"><strong>Scanner</strong></span> generates a <span class="strong"><strong>Token List</strong></span>, then the <span class="strong"><strong>Parser</strong></span> generates a <span class="strong"><strong>Syntax Tree</strong></span>, and the <span class="strong"><strong>Evaluator</strong></span> determines the value.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_02.jpg" alt="Formula interpretation"/></div><p>
</p><p>A token is the least significant part of the formula. For instance, <span class="emphasis"><em>a1</em></span> is interpreted as a reference and <span class="emphasis"><em>1.2</em></span> is interpreted as a value. Assuming that the cells have values according to the following sheet, the formula interpretation process will be as follows. Remember that a formula is text beginning with an equal sign (<span class="strong"><strong>=</strong></span>).</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_03.jpg" alt="Formula interpretation"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_04.jpg" alt="Formula interpretation"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_05.jpg" alt="Formula interpretation"/></div><p>
</p><div class="section" title="The tokens"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>The tokens</h2></div></div></div><p>The scanner takes a string as input and finds its least significant parts-its tokens. Spaces between the tokens are ignored, and the scanner makes out no difference between capital and small letters. The <code class="literal">Value</code> token needs an extra piece of information to keep track of the actual value, which is called an <span class="strong"><strong>attribute</strong></span>. In the same way, <code class="literal">Reference</code> needs an attribute to keep track of reference. In this application, there are nine different tokens:</p><p>
<span class="strong"><strong>Token.h</strong></span>
</p><pre class="programlisting">enum TokenId {Plus, Minus, Star, Slash, LeftParenthesis, &#13;
              RightParenthesis, RefToken, Number, EndOfLine}; &#13;
</pre><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Token</strong></span></p>
</td><td>
<p><span class="strong"><strong>Description</strong></span></p>
</td></tr><tr><td>
<p>
<code class="literal">Plus</code>, <code class="literal">Minus</code>, <code class="literal">Star</code>, and <code class="literal">Slash</code>
</p>
</td><td>
<p>These are the four arithmetic operators: "<code class="literal">+</code>", "<code class="literal">-</code>", "<code class="literal">*</code>", and "<code class="literal">/</code>"</p>
</td></tr><tr><td>
<p>
<code class="literal">LeftParenthesis</code> and <code class="literal">RightParenthesis</code>
</p>
</td><td>
<p>These are the left and right parentheses: "<code class="literal">(</code>" and "<code class="literal">)</code>"</p>
</td></tr><tr><td>
<p>Value</p>
</td><td>
<p>This is a numerical value, for instance, <code class="literal">124</code>, <code class="literal">3.14</code>, or <code class="literal">-0.23</code>. It does not matter whether the value is integral or decimal. Nor does it matter if the decimal point (if present) is preceded or succeeded by digits. However, the value must contain at least one digit. This needs a value of type double as an attribute.</p>
</td></tr><tr><td>
<p>Reference</p>
</td><td>
<p>This is a reference, for instance, <code class="literal">b8, c6</code>. This needs <code class="literal">Reference</code> object as an attribute.</p>
</td></tr><tr><td>
<p>EndOfLine</p>
</td><td>
<p>This is at the end of the line, there are no more (non-space) characters in the string.</p>
</td></tr></tbody></table></div><p>As stated previously, the string <span class="emphasis"><em>1.2 * (b2 + c3)</em></span> generates the tokens in the table on the next page. The end-of-line token is added at the end of the list.</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Text</strong></span></p>
</td><td>
<p><span class="strong"><strong>Token</strong></span></p>
</td><td>
<p><span class="strong"><strong>Attribute</strong></span></p>
</td></tr><tr><td>
<p>1.2</p>
</td><td>
<p>Value</p>
</td><td>
<p>1.2</p>
</td></tr><tr><td>
<p>*</p>
</td><td>
<p>Star</p>
</td><td>
</td></tr><tr><td>
<p>(</p>
</td><td>
<p>LeftParenthesis</p>
</td><td>
</td></tr><tr><td>
<p>b2</p>
</td><td>
<p>Reference</p>
</td><td>
<p>row <code class="literal">1</code>, col <code class="literal">1</code>
</p>
</td></tr><tr><td>
<p>+</p>
</td><td>
<p>Plus</p>
</td><td>
</td></tr><tr><td>
<p>c3</p>
</td><td>
<p>Reference</p>
</td><td>
<p>row <code class="literal">2</code>, col <code class="literal">2</code>
</p>
</td></tr><tr><td>
<p>)</p>
</td><td>
<p>RightParanthesis</p>
</td><td>
</td></tr><tr><td>
</td><td>
<p>EndOfLine</p>
</td><td>
</td></tr></tbody></table></div><p>The tokens are defined in the <code class="literal">Token</code> class. A token is made up of a token identifier, a double value in case of the value token, and a <code class="literal">Reference</code> object in case of the reference token.</p><p>
<span class="strong"><strong>Token.h</strong></span>
</p><pre class="programlisting">class Token { &#13;
  public: &#13;
    Token(TokenId tokenId); &#13;
    Token(double value); &#13;
    Token(Reference reference); &#13;
 &#13;
    TokenId Id() const {return tokenId;} &#13;
    double Value() const {return value;} &#13;
    Reference ReferenceField() const {return reference;} &#13;
 &#13;
  private: &#13;
    TokenId tokenId; &#13;
    double value; &#13;
    Reference reference; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Token.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
 &#13;
Token::Token(TokenId tokenId) &#13;
 :tokenId(tokenId) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
Token::Token(double value) &#13;
 :tokenId(Number), &#13;
  value(value) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
Token::Token(Reference reference) &#13;
 :tokenId(RefToken), &#13;
  reference(reference) { &#13;
  // Empty. &#13;
} &#13;
</pre></div><div class="section" title="The tree node"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>The tree node</h2></div></div></div><p>As mentioned earlier, the parser generates a syntax tree. More specifically, it generates an object of the <code class="literal">Tree</code> class (described in <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <span class="emphasis"><em>Auxiliary Classes</em></span>), which is a template class with a node type: <code class="literal">TreeNode</code>. There are 10 identities for a node and, similar to <code class="literal">Token</code>, a value node has a double value as its attribute and a reference node has a reference object as attribute.</p><p>
<span class="strong"><strong>TreeNode.h</strong></span>
</p><pre class="programlisting">enum TreeId {EmptyTree, UnaryAdd, UnarySubtract, BinaryAdd, BinarySubtract, &#13;
             Multiply, Divide, Parenthesis, RefId, ValueId}; &#13;
</pre><p>The default constructor is used when reading the value from a file or the clipboard buffer.</p><pre class="programlisting">class TreeNode { &#13;
  public: &#13;
    TreeNode(); &#13;
    TreeNode(TreeId id); &#13;
    TreeNode(Reference reference); &#13;
    TreeNode(double value); &#13;
</pre><p>A cell of a spreadsheet can be saved to a file as well as cut, copied, and pasted, thus we included the following methods:</p><pre class="programlisting">    bool WriteTreeNodeToStream(ostream&amp; outStream) const; &#13;
    bool ReadTreeNodeFromStream(istream&amp; inStream); &#13;
    void WriteTreeNodeToClipboard(InfoList&amp; infoList) const; &#13;
    void ReadTreeNodeFromClipboard(InfoList&amp; infoList); &#13;
</pre><p>The identity and value of the node can only be inspected, not modified. However, the reference can be modified, since it is updated when the user copies a cell and then pastes it to another location:</p><pre class="programlisting">    TreeId Id() const {return id;} &#13;
    double Value() const {return value;} &#13;
    Reference ReferenceField() const {return reference;} &#13;
    Reference&amp; ReferenceField() {return reference;} &#13;
&#13;
 &#13;
  private: &#13;
    TreeId id; &#13;
    Reference reference; &#13;
    double value; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>TreeNode.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "TreeNode.h" &#13;
 &#13;
TreeNode::TreeNode() &#13;
 :id(EmptyTree), &#13;
  value(0) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
TreeNode::TreeNode(TreeId id) &#13;
 :id(id), &#13;
  value(0) { &#13;
    // Empty. &#13;
} &#13;
 &#13;
TreeNode::TreeNode(Reference reference) &#13;
: id(RefId), &#13;
  value(0), &#13;
  reference(reference) { &#13;
  // Empty. &#13;
} &#13;
 &#13;
TreeNode::TreeNode(double value) &#13;
 :id(ValueId), &#13;
  value(value) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The node identity, the value, and the reference are written and read, as follows:</p><pre class="programlisting">bool TreeNode::WriteTreeNodeToStream(ostream&amp; outStream) const { &#13;
  outStream.write((char*) &amp;id, sizeof id); &#13;
  outStream.write((char*) &amp;value, sizeof value); &#13;
  reference.WriteReferenceToStream(outStream); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool TreeNode::ReadTreeNodeFromStream(istream&amp; inStream) { &#13;
  inStream.read((char*) &amp;id, sizeof id); &#13;
  inStream.read((char*) &amp;value, sizeof value); &#13;
  reference.ReadReferenceFromStream(inStream); &#13;
  return ((bool) inStream); &#13;
} &#13;
 &#13;
void TreeNode::WriteTreeNodeToClipboard(InfoList&amp; infoList) const  { &#13;
  infoList.AddValue&lt;TreeId&gt;(id); &#13;
  infoList.AddValue&lt;double&gt;(value); &#13;
  reference.WriteReferenceToClipboard(infoList); &#13;
} &#13;
 &#13;
void TreeNode::ReadTreeNodeFromClipboard(InfoList&amp; infoList) { &#13;
  infoList.GetValue&lt;TreeId&gt;(id); &#13;
  infoList.GetValue&lt;double&gt;(value); &#13;
  reference.ReadReferenceFromClipboard(infoList); &#13;
} &#13;
</pre></div><div class="section" title="The Scanner – Generating the list of tokens"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec76"/>The Scanner – Generating the list of tokens</h2></div></div></div><p>The task of the <code class="literal">Scanner</code> class is to group characters into tokens. For instance, <span class="emphasis"><em>12.34</em></span> is interpreted as the value <span class="emphasis"><em>12.34</em></span>. The constructor takes a string as parameter while <code class="literal">Scan</code> generates a list of tokens by repeatedly calling <code class="literal">NextToken</code> until the string is empty.</p><p>
<span class="strong"><strong>Scanner.h</strong></span>
</p><pre class="programlisting">class Scanner { &#13;
  public: &#13;
    Scanner(String buffer); &#13;
    list&lt;Token&gt; Scan(); &#13;
</pre><p>The <code class="literal">NextToken</code> method returns <code class="literal">EndOfLine</code> when it encounters the end of the string. The <code class="literal">ScanValue</code> and <code class="literal">ScanReference</code> methods return <code class="literal">true</code> if they encounter a value or a reference:</p><pre class="programlisting">    Token NextToken(); &#13;
    bool ScanValue(double&amp; value); &#13;
    bool ScanReference(Reference&amp; reference); &#13;
</pre><p>The next token is continually read from the buffer until it is empty:</p><pre class="programlisting">  private: &#13;
    String buffer; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Scanner.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
#include "Error.h" &#13;
#include "Scanner.h" &#13;
</pre><p>
<code class="literal">TEXT('\0')</code> is added to the string for simplicity; instead of checking whether the remaining text is empty, we look for the <code class="literal">null</code> character:</p><pre class="programlisting">Scanner::Scanner(String buffer) &#13;
 :buffer(buffer + TEXT('\0')) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The <code class="literal">Scan</code> method adds the token from the buffer to <code class="literal">tokenList</code> until it encounters <code class="literal">EndOfLine</code>. Finally, the list is returned:</p><pre class="programlisting">list&lt;Token&gt; Scanner::Scan() { &#13;
  list&lt;Token&gt; tokenList; &#13;
 &#13;
  while (true) { &#13;
    Token token = NextToken(); &#13;
    tokenList.push_back(token); &#13;
 &#13;
    if (token.Id() == EndOfLine) { &#13;
      break; &#13;
    } &#13;
  } &#13;
 &#13;
  return tokenList; &#13;
} &#13;
</pre><p>The <code class="literal">NextToken</code> method does the actual work of the scanner by finding the next token in the buffer. First, we skip the blanks. It is rather simple to extract the token when it comes to the arithmetic symbols and the parentheses. We just check the next character of the buffer. It becomes slightly more difficult when it comes to numerical values or references. We have two auxiliary methods for that purpose: <code class="literal">ScanValue</code> and <code class="literal">ScanReference</code>. Take a look at the following code:</p><pre class="programlisting">Token Scanner::NextToken() { &#13;
  while (buffer[0] == TEXT(' ')) { &#13;
    buffer.erase(0, 1); &#13;
  } &#13;
&#13;
   switch (buffer[0]) { &#13;
    case TEXT('\0'): &#13;
      return Token(EndOfLine); &#13;
 &#13;
    case TEXT('+'): &#13;
      buffer.erase(0, 1); &#13;
      return Token(Plus); &#13;
 &#13;
    case TEXT('-'): &#13;
      buffer.erase(0, 1); &#13;
      return Token(Minus); &#13;
 &#13;
    case TEXT('*'): &#13;
      buffer.erase(0, 1); &#13;
      return Token(Star); &#13;
 &#13;
    case TEXT('/'): &#13;
      buffer.erase(0, 1); &#13;
      return Token(Slash); &#13;
 &#13;
    case TEXT('('): &#13;
      buffer.erase(0, 1); &#13;
      return Token(LeftParenthesis); &#13;
 &#13;
    case TEXT(')'): &#13;
      buffer.erase(0, 1); &#13;
      return Token(RightParenthesis); &#13;
</pre><p>If none of the trivial cases apply, the token may be a value or a reference. The <code class="literal">ScanValue</code> and <code class="literal">ScanReference</code> methods find out if that is the case. If not, the scanner has encountered an unknown character and a syntax error exception is thrown:</p><pre class="programlisting">    default: { &#13;
      double value; &#13;
      Reference reference; &#13;
      if (ScanValue(value)) { &#13;
        return Token(value); &#13;
      } &#13;
&#13;
&#13;
      else if (ScanReference(reference)) { &#13;
        return Token(reference); &#13;
      } &#13;
      else { &#13;
        throw Error(SyntaxError); &#13;
      } &#13;
    } &#13;
    break; &#13;
  } &#13;
} &#13;
</pre><p>
<code class="literal">ScanValue</code> uses the <code class="literal">_stscanf_s</code> standard function, which is the safe generic version of <code class="literal">sscanf</code>. The returned value is stored in <code class="literal">fieldCount</code>, which is set to <code class="literal">1</code> if the double value was successfully read. We also need the number of the character read, which is stored in <code class="literal">charCount</code>, in order to erase the correct number of characters from the buffer:</p><pre class="programlisting">bool Scanner::ScanValue(double&amp; value) { &#13;
  int charCount; &#13;
  int fieldCount = _stscanf_s(buffer.c_str(), TEXT("%lf%n"), &#13;
                              &amp;value, &amp;charCount); &#13;
 &#13;
  if (fieldCount &gt; 0) { &#13;
    buffer.erase(0, charCount); &#13;
    return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>
<code class="literal">ScanReference</code> checks whether the first two characters are a letter and a digit. If so, it extracts the column and the row of the reference:</p><pre class="programlisting">bool Scanner::ScanReference(Reference&amp; reference) { &#13;
  if (isalpha(buffer[0]) &amp;&amp; (isdigit(buffer[1]))) { &#13;
</pre><p>We extract the column by subtracting the lowercase letter from <span class="emphasis"><em>a</em></span>, which gives that the first column has the index zero, and erases the letter from the buffer.</p><pre class="programlisting">    reference.Col() = tolower(buffer[0]) - TEXT('a'); &#13;
    buffer.erase(0, 1); &#13;
</pre><p>Similar to <code class="literal">ScanValue</code>, we extract the row by calling <code class="literal">_stscanf_s</code>, which reads the row integer value and the number of characters, which we use to erase the characters read from the buffer:</p><pre class="programlisting">    int row; &#13;
    int charCount; &#13;
    _stscanf_s(buffer.c_str(), TEXT("%d%n"), &amp;row, &amp;charCount); &#13;
    reference.Row() = row - 1; &#13;
    buffer.erase(0, charCount); &#13;
    return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre></div><div class="section" title="The parser – Generating the syntax tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec77"/>The parser – Generating the syntax tree</h2></div></div></div><p>The user inputs a formula beginning with an equal sign (<span class="strong"><strong>=</strong></span>). The parser's task is to translate the scanner's token list into a syntax tree. The syntax of a valid formula can be defined by a <span class="strong"><strong>grammar</strong></span>. Let's start with a grammar that handles expressions that make use of the arithmetic operators:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_06.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>A grammar is a set of rules. In the preceding grammar, there are eight rules. <span class="strong"><strong>Formula</strong></span> and <span class="strong"><strong>Expression</strong></span> are called <span class="strong"><strong>non-terminals</strong></span>; <span class="strong"><strong>EndOfLine</strong></span>, <span class="strong"><strong>Value</strong></span>, and the characters <span class="strong"><strong>+</strong></span>, <span class="strong"><strong>-</strong></span>, <span class="strong"><strong>*</strong></span>, <span class="strong"><strong>/</strong></span>, <span class="strong"><strong>(</strong></span>, and <span class="strong"><strong>)</strong></span> are called <span class="strong"><strong>terminals</strong></span>. Terminals and non-terminals are called symbols. One of the rules is the grammar's <span class="strong"><strong>start rule</strong></span>, in our case the first rule. The symbol to the left of the start rules is called the grammar's <span class="strong"><strong>start symbol</strong></span>, in our case <span class="strong"><strong>Formula</strong></span>.</p><p>The arrow can be read as "<span class="strong"><strong>is</strong></span>", and the preceding grammar can be read as:</p><p>
<span class="emphasis"><em>A formula is an expression followed by end-of-line. An expression is the sum of two expressions, the difference of two expressions, the product of two expressions, the quotient of two expressions, an expression enclosed by parentheses, a reference, or a numerical value.</em></span>
</p><p>This is a good start, but there are a few problems. Let's test if the string <span class="emphasis"><em>1 + 2 * 3</em></span> is accepted by the grammar. We can test that by doing a <span class="strong"><strong>derivation</strong></span>, where we start with the start symbol <code class="literal">Formula</code> and apply the rules until there are only terminals. The digits in the following derivation refer to the grammar rules:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_07.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The derivation can be illustrated by the development of a <span class="strong"><strong>parse tree</strong></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_08.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p>Let's try another derivation of the same string, with the rules applied in a different order.
<p>
</p><div class="mediaobject"><img src="graphics/B05475_09_09.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>This derivation generates a different parse tree, which is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_10.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The grammar is said to be ambiguous as it can generate two different parse trees for the same input string, which we would like to avoid. The second tree is obviously a violation of the laws of mathematics, stating that multiplication has higher precedence than addition, but the grammar does not know that. One way to avoid ambiguity is to introduce a new set of rules for each level of precedence:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_11.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The new grammar is not ambiguous. If we try our string with this grammar, we can only generate one parse tree, regardless of the order that we choose to apply the rules. There are formal methods to prove that the grammar is not ambiguous; however, that is outside the scope of this book. Check out the references at the end of this chapter for references.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_12.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>This derivation gives the following tree. As it is not possible to derive two different trees from the same input string, the grammar is <span class="strong"><strong>unambiguous</strong></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_13.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>We are now ready to write a parser. Essentially, there are two types of parsers: <span class="strong"><strong>top-down parser</strong></span> and <span class="strong"><strong>bottom-up parser</strong></span>. As the terms imply, a top-down parser starts by the grammar's start symbol together with the input string, and it tries to apply rules until we are left with only terminals. A bottom-up parser starts with the input string and tries to apply rules backward, reducing the rules until we reach the start symbol.</p><p>It is a complicated matter to construct a bottom-up parser. It is usually not done manually; instead, there are <span class="strong"><strong>parser generators</strong></span> constructing a <span class="strong"><strong>parser table</strong></span> for the given grammar and skeleton code for the implementation of the parser. However, the theory of bottom-up parsing is outside the scope of this book.</p><p>It is easier to construct a top-down parser than a bottom-up parser. One way to construct a simple, but inefficient, top-down parser would be to apply all possible rules in random order. If we reach a dead end, we simply backtrack and try another rule. A more efficient, but rather simple, parser is a look-ahead parser. Given a suitable grammar, we only need to look at the next token in order to uniquely determine the rule to apply. If we reach a dead end, we do not have to backtrack; we simply draw the conclusion that the input string is incorrect according to the grammar-it is said to be <span class="strong"><strong>syntactically incorrect</strong></span>, that is, it has a <span class="strong"><strong>syntax error</strong></span>.</p><p>The first attempt to implement a look-ahead parser could be to write a function for each rule in the grammar. Unfortunately, we cannot do that quite yet because that would result in a function <code class="literal">Expression</code> like this:</p><pre class="programlisting">Tree&lt;TreeNode&gt;* Parser::Expression() { &#13;
  Token token = tokenList.front(); &#13;
 &#13;
  switch (token.Id()) { &#13;
    case Plus: &#13;
      Tree&lt;TreeNode&gt;* plusTree = Expression(); &#13;
      // ... &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>Do you see the problem? The method calls itself without changing the input stream, which would result in an infinite number of recursive calls. This is called <span class="strong"><strong>left recursion</strong></span>. We can solve the problem, however, with the help of a simple translation.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_14.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The preceding rules can be translated to the equivalent set of rules (where epsilon ε denotes empty string):</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_15.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>If we apply this transformation to the <span class="strong"><strong>Expression</strong></span> and <span class="strong"><strong>Term</strong></span> rules in the preceding grammar, we receive the following grammar:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_16.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>Let's try this new grammar with our string <span class="emphasis"><em>1 + 2 * 3</em></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_17.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The derivation generates the following parse tree:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_18.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The requirement for a grammar to be suitable for a look-ahead parser is that every set of rules with the same left-hand side symbol must begin with different terminals at its right-hand side. If it does not have an empty rule, it may have at the most one rule with a non-terminal as the first symbol on the right-hand side. The preceding grammar we covered meets these requirements.</p><p>Now we are ready to write the parser. However, the parser should also generate some kind of output, representing the string. One such representation is the <span class="strong"><strong>syntax tree</strong></span>, which can be viewed as an abstract parse tree-we keep only the essential information. For instance, the previous parse tree has a matching syntax, which is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_19.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>The following is the <code class="literal">Parser</code> class. The idea is that we write a method for every set of rules with the same left-hand symbol. Each such method generates a part of the resulting syntax tree. The constructor takes the text to parse and lets the scanner generate a list of tokens. Then, <code class="literal">Parse</code> starts the parsing process, and returns the generated syntax tree. If an error occurs during the parsing process, a syntax error exception is thrown. When the token list has been parsed, we should make sure that there are no extra tokens left in the list except <code class="literal">EndOfLine</code>. Also, if the input buffer is completely empty (the user inputs only a single equal sign), there is still the <code class="literal">EndOfLine</code> token in the list.</p><p>The result of the parsing is a syntax tree representing the formula. For instance, the formula <span class="emphasis"><em>a1 * c3 / 3.6 + 2.4 * (b2 - 2.4)</em></span> generates the following syntax tree, and we take advantage of the <code class="literal">Tree</code> class of <a class="link" href="ch12.html" title="Chapter 12. The Auxiliary Classes">Chapter 12</a>, <span class="emphasis"><em>Auxiliary Classes</em></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_09_20.jpg" alt="The parser – Generating the syntax tree"/></div><p>
</p><p>As mentioned in the <code class="literal">TreeNode</code> section earlier, there are nine types of syntax tree: the four arithmetic operators, unary addition and subtraction, expressions in parentheses, references, and numerical values. We do not actually need the parentheses to store the formula correctly, as the priority of the expression is stored in the syntax tree itself. However, we need it to regenerate the original string from the syntax tree when written in a cell.</p><p>
<span class="strong"><strong>Parser.h</strong></span>
</p><pre class="programlisting">class Parser { &#13;
  public: &#13;
    Parser(String buffer); &#13;
    Tree&lt;TreeNode&gt;* Parse(); &#13;
    void Match(int tokenId); &#13;
    Tree&lt;TreeNode&gt;* Expression(); &#13;
    Tree&lt;TreeNode&gt;* NextExpression(Tree&lt;TreeNode&gt;* leftTermPtr); &#13;
    Tree&lt;TreeNode&gt;* Term(); &#13;
    Tree&lt;TreeNode&gt;* NextTerm(Tree&lt;TreeNode&gt;* leftFactorPtr); &#13;
    Tree&lt;TreeNode&gt;* Factor(); &#13;
 &#13;
  private: &#13;
    list&lt;Token&gt; tokenList; &#13;
}; &#13;
</pre><p>The <code class="literal">Parse</code> method is called in order to interpret the text that the user has input. It receives the token list from the scanner, which holds at least the <code class="literal">EndOfLine</code> token and parses the token list and receives a pointer to the syntax tree. When the token list has been parsed, it checks whether the next token is <code class="literal">EndOfLine</code> to make sure that there are no extra characters (except spaces) left in the buffer:</p><p>
<span class="strong"><strong>Parser.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
#include "Error.h" &#13;
#include "Scanner.h" &#13;
#include "TreeNode.h" &#13;
#include "Parser.h" &#13;
 &#13;
Parser::Parser(String buffer) { &#13;
  Scanner scanner(buffer); &#13;
  tokenList = scanner.Scan(); &#13;
} &#13;
 &#13;
Tree&lt;TreeNode&gt;* Parser::Parse() { &#13;
  Tree&lt;TreeNode&gt;* resultTreePtr = Expression(); &#13;
  Match(EndOfLine); &#13;
  return resultTreePtr; &#13;
} &#13;
</pre><p>The <code class="literal">Match</code> method is used to match the next token in the list with the expected token. If they do not match or if the token list is empty, a syntax error exception is thrown. Otherwise, the next token is removed from the list:</p><pre class="programlisting">void Parser::Match(int tokenId) { &#13;
  if (tokenList.empty() || (tokenList.front().Id() != tokenId)) { &#13;
    throw Error(SyntaxError); &#13;
  } &#13;
 &#13;
  tokenList.pop_front(); &#13;
} &#13;
</pre><p>The rest of the methods implement the grammar we discussed earlier. There is one method for each for the symbols <code class="literal">Expression</code>, <code class="literal">NextExpression</code>, <code class="literal">Term</code>, <code class="literal">NextTerm</code>, and <code class="literal">Factor</code>:</p><pre class="programlisting">Tree&lt;TreeNode&gt;* Parser::Expression() { &#13;
  Tree&lt;TreeNode&gt;* termTreePtr = Term(); &#13;
  return NextExpression(termTreePtr); &#13;
} &#13;
</pre><p>The <code class="literal">NextExpression</code> method takes care of addition and subtraction. If the next token is <code class="literal">Plus</code> or <code class="literal">Minus</code>, we match it and parse its right operand. Then, we create and return a new syntax tree with the operator in question. If the next token is neither <code class="literal">Plus</code> nor <code class="literal">Minus</code>, we just assume that another rule applies and return the given left syntax tree:</p><pre class="programlisting">Tree&lt;TreeNode&gt;* Parser::NextExpression(Tree&lt;TreeNode&gt;* &#13;
                                       leftTermTreePtr) { &#13;
  Token token = tokenList.front();  &#13;
  switch (token.Id()) { &#13;
    case Plus: { &#13;
      Match(Plus); &#13;
      Tree&lt;TreeNode&gt;* rightTermTreePtr = Term(); &#13;
      Tree&lt;TreeNode&gt;* sumTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(BinaryAdd), &#13;
                           {leftTermTreePtr, rightTermTreePtr}); &#13;
      assert(sumTreePtr != nullptr); &#13;
      return NextExpression(sumTreePtr); &#13;
    } &#13;
&#13;
    case Minus: { &#13;
      Match(Minus); &#13;
      Tree&lt;TreeNode&gt;* rightTermTreePtr = Term(); &#13;
         Tree&lt;TreeNode&gt;* diffTreePtr = &#13;
             new Tree&lt;TreeNode&gt;(TreeNode(BinarySubtract),&#13;
                                {leftTermTreePtr, rightTermTreePtr});&#13;
      assert(diffTreePtr != nullptr); &#13;
      return NextExpression(diffTreePtr); &#13;
    } &#13;
 &#13;
    default: &#13;
      return leftTermTreePtr; &#13;
  } &#13;
}  &#13;
&#13;
Tree&lt;TreeNode&gt;* Parser::Term() { &#13;
  Tree&lt;TreeNode&gt;* pFactorTree = Factor(); &#13;
  return NextTerm(pFactorTree); &#13;
} &#13;
</pre><p>The <code class="literal">NextTerm</code> method works with multiplication and division in a way similar to <code class="literal">NextExpression</code>. Remember that we need a set of methods for each precedence level of the grammar.</p><pre class="programlisting">Tree&lt;TreeNode&gt;* Parser::NextTerm(Tree&lt;TreeNode&gt;*leftFactorTreePtr) { &#13;
  Token token = tokenList.front(); &#13;
 &#13;
  switch (token.Id()) { &#13;
    case Star: { &#13;
      Match(Star); &#13;
      Tree&lt;TreeNode&gt;* rightFactorTreePtr = Factor(); &#13;
      Tree&lt;TreeNode&gt;* productTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(Multiply), &#13;
      Tree&lt;TreeNode&gt;* productTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(Multiply), &#13;
                       {leftFactorTreePtr, rightFactorTreePtr}); &#13;
      assert(productTreePtr != nullptr); &#13;
      return NextExpression(productTreePtr); &#13;
    } &#13;
 &#13;
    case Slash: { &#13;
      Match(Slash); &#13;
      Tree&lt;TreeNode&gt;* rightFactorTreePtr = Factor(); &#13;
      Tree&lt;TreeNode&gt;* quotientTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(Divide), &#13;
                       {leftFactorTreePtr, rightFactorTreePtr}); &#13;
      assert(quotientTreePtr != nullptr); &#13;
      return NextExpression(quotientTreePtr); &#13;
    } &#13;
   &#13;
    default: &#13;
      return leftFactorTreePtr; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">Factor</code> method parses values, references, and expressions enclosed by parentheses. If the next token is a unary operator (plus or minus), we parse its expression and create a syntax tree holding the expression:</p><pre class="programlisting">Tree&lt;TreeNode&gt;* Parser::Factor() { &#13;
  Token token = tokenList.front(); &#13;
 &#13;
  switch (token.Id()) { &#13;
    case Plus: { &#13;
      Match(Plus); &#13;
      Tree&lt;TreeNode&gt;* nextExprTreePtr = Expression(); &#13;
      Tree&lt;TreeNode&gt;* plusTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(UnaryAdd), &#13;
                           {nextExprTreePtr}); &#13;
      assert(plusTreePtr!= nullptr); &#13;
      return plusTreePtr; &#13;
    } &#13;
 &#13;
    case Minus: { &#13;
      Match(Minus); &#13;
      Tree&lt;TreeNode&gt;* nextExprTreePtr = Expression(); &#13;
      Tree&lt;TreeNode&gt;* minusTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(UnaryAdd), &#13;
                           {nextExprTreePtr}); &#13;
      assert(minusTreePtr!= nullptr); &#13;
      return minusTreePtr; &#13;
    } &#13;
</pre><p>If the next token is a left parenthesis, we match it, parse the following expression, and match the closing right parenthesis:</p><pre class="programlisting">    case LeftParenthesis: { &#13;
      Match(LeftParenthesis); &#13;
      Tree&lt;TreeNode&gt;* innerExprTreePtr = Expression(); &#13;
      Match(RightParenthesis); &#13;
      Tree&lt;TreeNode&gt;* resultTreePtr =  &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(Parenthesis), &#13;
                           {innerExprTreePtr}); &#13;
      assert(resultTreePtr != nullptr); &#13;
      return resultTreePtr; &#13;
    } &#13;
</pre><p>If the next token is a reference, we receive the reference attribute with its row and column and match the reference token. We create a new syntax tree holding a reference. Note that the parser does not check whether the reference is valid (refers to a cell inside the spreadsheet); that is the task of the evaluation of the formula's value:</p><pre class="programlisting">    case RefToken: { &#13;
      Match(RefToken); &#13;
      Tree&lt;TreeNode&gt;* resultTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(token.ReferenceField())); &#13;
      assert(resultTreePtr != nullptr); &#13;
      return resultTreePtr; &#13;
    }  &#13;
&#13;
    case Number: { &#13;
      Match(Number); &#13;
      Tree&lt;TreeNode&gt;* resultTreePtr = &#13;
        new Tree&lt;TreeNode&gt;(TreeNode(token.Value())); &#13;
      assert(resultTreePtr != nullptr); &#13;
      return resultTreePtr; &#13;
    } &#13;
</pre><p>If none of the preceding tokens applies, the user has input an invalid expression and a syntax error exception is thrown:</p><pre class="programlisting">    default: &#13;
      throw Error(SyntaxError); &#13;
  } &#13;
} &#13;
</pre></div></div></div>
<div class="section" title="Matrix and reference"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec41"/>Matrix and reference</h1></div></div></div><p>The <code class="literal">Matrix</code> class is used when storing the cells of spreadsheet, and the <code class="literal">Reference</code> class is used when accessing cells in the spreadsheet.</p><div class="section" title="The reference class"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec78"/>The reference class</h2></div></div></div><p>The <code class="literal">Reference</code> class holds the row and column of a cell in the <code class="literal">Matrix</code> class, as shown in the next section:</p><p>
<span class="strong"><strong>Reference.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Reference; &#13;
  extern const Reference ZeroReference;  &#13;
&#13;
  class Reference { &#13;
    public: &#13;
</pre><p>The default constructor initializes the row and column to zero. A reference can be initialized by and assigned to another reference:</p><pre class="programlisting">      Reference(); &#13;
      Reference(int row, int col); &#13;
      Reference(const Reference&amp; ref); &#13;
      Reference&amp; operator=(const Reference&amp; ref); &#13;
</pre><p>The compare operators first compare the rows. If they are equal, the columns are then compared:</p><pre class="programlisting">      friend bool operator==(const Reference&amp; ref1, &#13;
                             const Reference&amp; ref2); &#13;
      friend bool operator!=(const Reference&amp; ref1, &#13;
                             const Reference&amp; ref2); &#13;
      friend bool operator&lt;(const Reference&amp; ref1, &#13;
                            const Reference&amp; ref2); &#13;
      friend bool operator&lt;=(const Reference&amp; ref1, &#13;
                             const Reference&amp; ref2); &#13;
&#13;
      friend bool operator&gt;(const Reference&amp; ref1, &#13;
                            const Reference&amp; ref2); &#13;
      friend bool operator&gt;=(const Reference&amp; ref1, &#13;
                             const Reference&amp; ref2); &#13;
</pre><p>The addition operators add and subtract the rows and columns separately:</p><pre class="programlisting">      Reference&amp; operator+=(const Reference&amp; ref); &#13;
      Reference&amp; operator-=(const Reference&amp; ref); &#13;
      friend Reference operator+(const Reference&amp; ref1, &#13;
                                 const Reference&amp; ref2); &#13;
      friend Reference operator-(const Reference&amp; ref1, &#13;
                                 const Reference&amp; ref2); &#13;
</pre><p>The <code class="literal">Clear</code> method sets both the row and column to zero, and <code class="literal">IsEmpty</code> returns <code class="literal">true</code> if the row and column is zero:</p><pre class="programlisting">      void Clear() {row = 0; col = 0;} &#13;
      bool IsEmpty() const {return ((row == 0) &amp;&amp; (col == 0));} &#13;
</pre><p>The <code class="literal">ToString</code> method returns a string representing the reference:</p><pre class="programlisting">      String ToString() const; &#13;
</pre><p>A reference is inside a block of references defined by a smallest and a largest reference if it is greater than or equal to the smallest one and less than or equal to the largest one:</p><pre class="programlisting">      bool Inside(Reference minRef, Reference maxRef); &#13;
</pre><p>The reference can be written to and read from a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WriteReferenceToStream(ostream&amp; outStream) const; &#13;
      bool ReadReferenceFromStream(istream&amp; inStream); &#13;
      void WriteReferenceToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadReferenceFromClipboard(InfoList&amp; infoList); &#13;
      void WriteReferenceToRegistry(String key) const; &#13;
      void ReadReferenceFromRegistry(String key, &#13;
                            Reference defaultRef = ZeroReference); &#13;
</pre><p>The row and column are inspected by the constant methods and modified by the non-constant methods:</p><pre class="programlisting">      int Row() const {return row;} &#13;
      int Col() const {return col;} &#13;
      int&amp; Row() {return row;} &#13;
      int&amp; Col() {return col;} &#13;
&#13;
 &#13;
    private: &#13;
      int row, col; &#13;
  }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Reference.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"  &#13;
namespace SmallWindows { &#13;
  const Reference ZeroReference(0, 0);  &#13;
  Reference::Reference() &#13;
   :row(0), &#13;
    col(0) { &#13;
    // Empty. &#13;
  }  &#13;
&#13;
  Reference::Reference(int row, int col) &#13;
   :row(row), &#13;
    col(col) { &#13;
    // Empty. &#13;
  }  &#13;
&#13;
  Reference::Reference(const Reference&amp; ref) &#13;
   :row(ref.row), &#13;
    col(ref.col) { &#13;
    // Empty. &#13;
  }  &#13;
&#13;
  Reference&amp; Reference::operator=(const Reference&amp; ref) { &#13;
    if (this != &amp;ref) { &#13;
      row = ref.row; &#13;
      col = ref.col; &#13;
    } &#13;
    return *this; &#13;
  } &#13;
 &#13;
  bool operator==(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return (ref1.row == ref2.row) &amp;&amp; (ref1.col == ref2.col); &#13;
  } &#13;
 &#13;
  bool operator!=(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return !(ref1 == ref2); &#13;
  } &#13;
 &#13;
  bool operator&lt;(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return (ref1.row &lt; ref2.row) || &#13;
           ((ref1.row == ref2.row) &amp;&amp; (ref1.col &lt; ref2.col)); &#13;
  } &#13;
 &#13;
  bool operator&lt;=(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return (ref1 &lt; ref2) || (ref1 == ref2); &#13;
  } &#13;
 &#13;
  bool operator&gt;(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return !(ref1 &lt;= ref2); &#13;
  } &#13;
 &#13;
  bool operator&gt;=(const Reference&amp; ref1, const Reference&amp; ref2) { &#13;
    return !(ref1 &lt; ref2); &#13;
  }  &#13;
&#13;
  Reference&amp; Reference::operator+=(const Reference&amp; ref) { &#13;
    row += ref.row; &#13;
    col += ref.col; &#13;
    return *this; &#13;
  }  &#13;
&#13;
  Reference&amp; Reference::operator-=(const Reference&amp; ref) { &#13;
    row -= ref.row; &#13;
    col -= ref.col; &#13;
    return *this; &#13;
  }  &#13;
&#13;
  Reference operator+(const Reference&amp; ref1, &#13;
                      const Reference&amp; ref2) { &#13;
    return Reference(ref1.row + ref2.row, ref1.col + ref2.col); &#13;
  }  &#13;
&#13;
  Reference operator-(const Reference&amp; ref1, &#13;
                      const Reference&amp; ref2) { &#13;
    return Reference(ref1.row - ref2.row, ref1.col - ref2.col); &#13;
  } &#13;
</pre><p>The <code class="literal">ToString</code> method returns to reference as a string. We increase the number of rows by one, implying that row zero corresponds to <span class="emphasis"><em>1</em></span>. The column is converted to characters, implying that column zero corresponds to <span class="emphasis"><em>a</em></span>. If the number of rows or columns is less than zero, <code class="literal">?</code> is returned:</p><pre class="programlisting">  String Reference::ToString() const {&#13;
    String result;&#13;
&#13;
    if (row &gt;= 0) {&#13;
      result.push_back((TCHAR) (col + TEXT('a')));&#13;
    }&#13;
    else {&#13;
      result.push_back(TEXT('?'));&#13;
    }&#13;
&#13;
    if (col &gt;= 0) {&#13;
      result.append(to_String(row + 1));&#13;
    }&#13;
    else {&#13;
      result.push_back(TEXT('?'));&#13;
    }&#13;
&#13;
    return result;&#13;
  } &#13;
 &#13;
  bool Reference::Inside(Reference minRef, Reference maxRef) { &#13;
    return ((minRef.row &lt;= row) &amp;&amp; (row &lt;= maxRef.row) &amp;&amp;&#13;
            (minRef.col &lt;= col) &amp;&amp; (col &lt;= maxRef.col));&#13;
  } &#13;
 &#13;
  bool Reference::WriteReferenceToStream(ostream&amp; outStream)const { &#13;
    outStream.write((char*) &amp;row, sizeof row); &#13;
    outStream.write((char*) &amp;col, sizeof col); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool Reference::ReadReferenceFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;row, sizeof row); &#13;
    inStream.read((char*) &amp;col, sizeof col); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  void Reference::WriteReferenceToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;int&gt;(row); &#13;
    infoList.AddValue&lt;int&gt;(col); &#13;
  } &#13;
 &#13;
  void Reference::ReadReferenceFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;int&gt;(row); &#13;
    infoList.GetValue&lt;int&gt;(col); &#13;
  } &#13;
</pre><p>When communicating with the registry, we use the <code class="literal">WriteBuffer</code> and <code class="literal">ReadBuffer</code> static methods. In order for that to work, we place the row and column values in the <code class="literal">ReferenceStruct</code> structure:</p><pre class="programlisting">  struct ReferenceStruct {int row, col;}; &#13;
 &#13;
  void Reference::WriteReferenceToRegistry(String key) const { &#13;
    ReferenceStruct writeStruct = {row, col}; &#13;
    Registry::WriteBuffer(key, &amp;writeStruct, sizeof writeStruct); &#13;
  } &#13;
 &#13;
  void Reference::ReadReferenceFromRegistry(String key,&#13;
                      Reference defaultRef /* = ZeroReference */){&#13;
    ReferenceStruct readStruct; &#13;
    ReferenceStruct defaultStruct = &#13;
      {defaultRef.row, defaultRef.col}; &#13;
    Registry::ReadBuffer(key, &amp;readStruct, sizeof readStruct, &#13;
                         &amp;defaultStruct); &#13;
    row = readStruct.row; &#13;
    col = readStruct.col; &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="The Matrix class"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec79"/>The Matrix class</h2></div></div></div><p>The <code class="literal">Matrix</code> class holds a set of cells organized in rows and columns.</p><p>
<span class="strong"><strong>Matrix.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  template &lt;int Rows, int Cols, class Type&gt; &#13;
 &#13;
  class Matrix { &#13;
    public: &#13;
</pre><p>The matrix can be initialized by or assigned to another matrix; in both cases, they call <code class="literal">Init</code> to do the actual initialization:</p><pre class="programlisting">    public: &#13;
      Matrix(); &#13;
      Matrix(const Matrix&amp; matrix); &#13;
      Matrix&amp; operator=(const Matrix&amp; matrix); &#13;
 &#13;
    private: &#13;
      void Init(const Matrix&lt;Rows,Cols,Type&gt;&amp; matrix); &#13;
</pre><p>The index operator takes a row or a <code class="literal">Reference</code> object. In the case of a row, an array of columns is returned (technically, the address of its first value is returned), which can be further indexed by the regular index operator to obtain the value in the buffer. In the case of a reference, the value is accessed directly by indexing the row and column of the buffer. Note that in this class, the vertical row coordinate holds the first index and the horizontal column coordinate the second index:</p><pre class="programlisting">    public: &#13;
      const Type* operator[](int row) const &#13;
                          {return ((const Type*) buffer[row]);} &#13;
&#13;
      Type&amp; operator[](const Reference&amp; ref) &#13;
                      {return buffer[ref.Row()][ref.Col()];} &#13;
      Type operator[](const Reference&amp; ref) const &#13;
                     {return buffer[ref.Row()][ref.Col()];} &#13;
 &#13;
    private: &#13;
      Type buffer[Rows][Cols]; &#13;
  }; &#13;
</pre><p>Since Matrix is a template class, we place the definition of its methods in the <code class="literal">header</code> file. The default constructor lets the default cell constructor initialize the cells:</p><pre class="programlisting">  template &lt;int Rows, int Cols, class Type&gt; &#13;
  Matrix&lt;Rows,Cols,Type&gt;::Matrix() { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The copy constructor and the assignment operator copies the cells by calling <code class="literal">Init</code>:</p><pre class="programlisting">  template &lt;int Rows, int Cols, class Type&gt; &#13;
  Matrix&lt;Rows,Cols,Type&gt;::Matrix(const Matrix&lt;Rows,Cols,Type&gt;&amp; &#13;
                                 matrix) { &#13;
    Init(matrix); &#13;
  } &#13;
 &#13;
  template&lt;int Rows, int Cols, class Type&gt; &#13;
  Matrix&lt;Rows,Cols,Type&gt;&amp; Matrix&lt;Rows,Cols,Type&gt;::operator= &#13;
                          (const Matrix&lt;Rows,Cols,Type&gt;&amp; matrix) { &#13;
    if (this != &amp;matrix) { &#13;
      Init(matrix); &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
 &#13;
  template &lt;int Rows, int Cols, class Type&gt; &#13;
  void Matrix&lt;Rows,Cols,Type&gt;::Init &#13;
                        (const Matrix&lt;Rows,Cols,Type&gt;&amp; matrix) { &#13;
    for (int row = 0; row &lt; Rows; ++row) { &#13;
      for (int col = 0; col &lt; Cols; ++col) { &#13;
        buffer[row][col] = matrix.buffer[row][col]; &#13;
      } &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div></div>
<div class="section" title="The cell"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec42"/>The cell</h1></div></div></div><p>The cell can hold three modes: (possible empty) text, a numerical value, or a formula. Its mode is stored in the <code class="literal">cellMode</code> field. It can hold the value <code class="literal">TextMode</code>, <code class="literal">ValueMode</code>, or <code class="literal">FormulaMode</code>. Similar to <code class="literal">CalcDocument</code> in this chapter and <code class="literal">WordDocument</code> in the previous chapters, we refer to the current value of <code class="literal">cellMode</code> in expressions such as <span class="strong"><strong>in text mode</strong></span>, <span class="strong"><strong>in value mode</strong></span>, and <span class="strong"><strong>in formula mode</strong></span>.</p><p>
<code class="literal">HeaderWidth</code>, <code class="literal">HeaderHeight</code>, <code class="literal">ColWidth</code>, and <code class="literal">RowHeight</code> are the size of the headers and cells of the spreadsheet. In order for the cell text to not overwrite the cell's borders, <code class="literal">CellMargin</code> is used. The spreadsheet is made up of ten rows and four columns.</p><p>
<span class="strong"><strong>Cell.h</strong></span>
</p><pre class="programlisting">extern const int HeaderWidth, HeaderHeight, &#13;
                 ColWidth, RowHeight, CellMargin; &#13;
 &#13;
#define Rows 10 &#13;
#define Cols 4 &#13;
</pre><p>A cell can be aligned at the left, center, right or justified in the horizontal direction, and it can be aligned at the top, center, or bottom in the vertical direction:</p><pre class="programlisting">enum Alignment {Left, Center, Right, Justified, Top, Bottom};  &#13;
 &#13;
class Cell { &#13;
  public: &#13;
    Cell(); &#13;
    ~Cell(); &#13;
 &#13;
    Cell(const Cell&amp; cell); &#13;
    Cell&amp; operator=(const Cell&amp; cell); &#13;
</pre><p>The <code class="literal">Clear</code> method is called when the user selects the new menu item and clears the font and background color of the cell before calling <code class="literal">Reset</code>, which clears the text and sets the cell to the text mode. <code class="literal">Reset</code> is also called when the user deletes the cell, in that case, the text is cleared, but not the font or color:</p><pre class="programlisting">    void Clear(); &#13;
    void Reset(); &#13;
</pre><p>The <code class="literal">CharDown</code> method is called when the user inputs a character that is inserted before the current character or overwrites it depending on the value of the <code class="literal">keyboardMode</code> parameter. When the user double-clicks on the text in a cell, <code class="literal">MouseToIndex</code> calculates the index of the character clicked on:</p><pre class="programlisting">    void CharDown(int editIndex, TCHAR tChar, &#13;
                  KeyboardMode keyboardMode); &#13;
    int MouseToIndex(int x) const; &#13;
</pre><p>The <code class="literal">Text</code> and <code class="literal">CaretList</code> methods return the text and caret rectangle list of the cell.</p><pre class="programlisting">    vector&lt;Rect&gt; CaretList() const {return caretList;} &#13;
 &#13;
    String GetText() const {return text;} &#13;
    void SetText(String&amp; t) {text = t;} &#13;
 &#13;
    bool IsFormula() const {return (cellMode == FormulaMode);} &#13;
</pre><p>The font and background color of the cell can both be modified and inspected, so can the horizontal and vertical alignment:</p><pre class="programlisting">    Font CellFont() const {return font;} &#13;
    Font&amp; CellFont() {return font;} &#13;
    Color BackgroundColor() const {return backgroundColor;} &#13;
    Color&amp; BackgroundColor() {return backgroundColor;} &#13;
 &#13;
    Alignment HorizontalAlignment() const &#13;
                        {return horizontalAlignignment;} &#13;
    Alignment&amp; HorizontalAlignment() &#13;
                         {return horizontalAlignignment;} &#13;
    Alignment VerticalAlignment() const &#13;
                      {return verticalAlignignment;} &#13;
    Alignment&amp; VerticalAlignment() {return verticalAlignignment;} &#13;
</pre><p>The <code class="literal">DrawCell</code> method draws the border of the cell in black, fills the cell with the background color, and draws the text. All colors are inverted if the inverse parameter is true, which it is if the cell is either being edited or is marked:</p><pre class="programlisting">    void DrawCell(Graphics&amp; graphics, Reference cellRef, &#13;
                  bool inverse) const; &#13;
    void GenerateCaretList(Window* windowPtr); &#13;
</pre><p>The <code class="literal">DisplayFormula</code> method is called when the user starts editing the cell. A cell with a formula can be displayed with its value or its formula. When the user edits the cell, the formula is displayed. When they mark it, its value is displayed. The <code class="literal">DisplayFormula</code> method replaces the value by the formula (or an error message in case of an incorrect formula):</p><pre class="programlisting">    void DisplayFormula (); &#13;
</pre><p>The <code class="literal">InterpretCell</code> method interprets the text of the cell, which is interpreted as text, a numerical value, or a formula. If the formula contains a syntax error, an exception is thrown:</p><pre class="programlisting">    void InterpretCell(set&lt;Reference&gt;&amp; sourceSet); &#13;
</pre><p>In the <code class="literal">formula</code> mode, <code class="literal">GenerateSourceSet</code> analyzes the formula and returns the (possibly empty) set of all its references. In the <code class="literal">text</code> or <code class="literal">value</code> mode, an empty set is returned:</p><pre class="programlisting">    void GenerateSourceSet(set&lt;Reference&gt;&amp; sourceSet) const; &#13;
    void GenerateSourceSet(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                           set&lt;Reference&gt;&amp; sourceSet) const; &#13;
</pre><p>In the <code class="literal">formula</code> mode, <code class="literal">TreeToString</code> returns the formula converted from the syntax tree to the string that is displayed in the cell when being edited:</p><pre class="programlisting">    String TreeToString() const; &#13;
    String TreeToString(Tree&lt;TreeNode&gt;* syntaxNodePtr) const; &#13;
</pre><p>When the user cuts, copies, and pastes cells, their references are updated. <code class="literal">UpdateTree</code> updates all references in the formula mode:</p><pre class="programlisting">    void UpdateTree(Reference diffRef, set&lt;Reference&gt;&amp; sourceSet); &#13;
    void UpdateTree(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                    Reference diffRef, set&lt;Reference&gt;&amp; sourceSet); &#13;
</pre><p>The <code class="literal">HasValue</code> method returns <code class="literal">true</code> if the cell holds a value: <code class="literal">true</code> in the <code class="literal">value</code> mode, <code class="literal">false</code> in the <code class="literal">text</code> mode, and <code class="literal">true</code> in the <code class="literal">formula</code> mode if it has been evaluated to a value, <code class="literal">false</code> if an evaluation error (missing value, reference out of scope, circular reference, or division by zero) occurred:</p><pre class="programlisting">    bool HasValue() const; &#13;
    double GetValue() const {return value;} &#13;
</pre><p>The <code class="literal">Evaluate</code> method evaluates the syntax tree of the formula; <code class="literal">valueMap</code> holds the values of the cells in the source set:</p><pre class="programlisting">    void Evaluate(map&lt;Reference,double&gt;&amp; valueMap); &#13;
    double Evaluate(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                    map&lt;Reference,double&gt;&amp; valueMap); &#13;
</pre><p>The cell can be saved to a file or cut, copied, and pasted:</p><pre class="programlisting">    bool WriteCellToStream(ostream&amp; outStream) const; &#13;
    bool ReadCellFromStream(istream&amp; inStream); &#13;
 &#13;
    void WriteCellToClipboard(InfoList&amp; infoList) const; &#13;
    void ReadCellFromClipboard(InfoList&amp; infoList); &#13;
</pre><p>As mentioned at the beginning of this section, the cell can hold (possibly empty) text, a numerical value, or a formula, indicated by the value <code class="literal">cellMode</code>:</p><pre class="programlisting">  private: &#13;
    enum CellMode {TextMode, ValueMode, FormulaMode} cellMode; &#13;
</pre><p>All characters in the cell hold the same font and background color. The cell can be aligned at the left, center, right, or justified horizontally, and it can be aligned at the top, center, or bottom vertically:</p><pre class="programlisting">    Font font; &#13;
    Color backgroundColor; &#13;
    Alignment horizontalAlignignment, verticalAlignignment; &#13;
</pre><p>The <code class="literal">text</code> field holds the text displayed in the cell. In the <code class="literal">edit</code> mode, it is the text currently input by the user. In the <code class="literal">mark</code> mode, it is the text input by the user (in text mode), a numerical value input by the user converted to text, the calculated value of a formula, or an error message (missing value, reference out of scope, circular reference, or division by zero):</p><pre class="programlisting">    String text; &#13;
</pre><p>The caret list holds the caret rectangle of each character in <code class="literal">text</code>. It also holds the rectangle for the index after the last character, which means that the size of the caret list is always one more than the text:</p><pre class="programlisting">    vector&lt;Rect&gt; caretList; &#13;
</pre><p>When the value of a formula is being calculated, it may result in a value or any of the errors we discussed earlier. If the cell holds a value, <code class="literal">hasValue</code> is <code class="literal">true</code> and <code class="literal">value</code> holds the actual value:</p><pre class="programlisting">    bool hasValue; &#13;
    double value; &#13;
</pre><p>When the user inputs a formula starting with <span class="emphasis"><em>=</em></span>, it is interpreted as a syntax tree by the <code class="literal">Scanner</code> and <code class="literal">Parser</code> classes, and it is stored in <code class="literal">syntaxTreePtr</code>:</p><pre class="programlisting">    Tree&lt;TreeNode&gt;* syntaxTreePtr; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Cell.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Token.h" &#13;
#include "Error.h" &#13;
#include "Scanner.h" &#13;
#include "TreeNode.h" &#13;
#include "Parser.h" &#13;
#include "Cell.h" &#13;
 &#13;
const int CellMargin = 100, &#13;
          ColWidth = 4000, RowHeight = 1000, &#13;
          HeaderWidth = 1000, HeaderHeight = 700; &#13;
</pre><p>The width of a cell is the width of the column minus the margins, and its height is the row height minus the margins:</p><pre class="programlisting">const int CellWidth = ColWidth - (2 * CellMargin), &#13;
          CellHeight = RowHeight - (2 * CellMargin); &#13;
</pre><p>When a cell is created, it is empty, it holds the text mode, it is center aligned in both horizontal and vertical directions, and it holds the system font with black text on white background:</p><pre class="programlisting">Cell::Cell() &#13;
 :cellMode(TextMode), &#13;
  font(SystemFont), &#13;
  backgroundColor(White), &#13;
  horizontalAlignignment(Center), &#13;
  verticalAlignignment(Center), &#13;
  hasValue(false), &#13;
  value(0), &#13;
  syntaxTreePtr(nullptr) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The copy constructor and assignment operator check whether <code class="literal">syntaxTreePtr</code> is <code class="literal">null</code>, if it is not null it is copied dynamically, its constructor continues copying its children recursively. It is not enough to simply copy the pointer, since one of the formulas of either the original or copy cell may be changed, but not the other one:</p><pre class="programlisting">Cell::Cell(const Cell&amp; cell) &#13;
 :cellMode(cell.cellMode), &#13;
  font(cell.font), &#13;
  backgroundColor(cell.backgroundColor), &#13;
  horizontalAlignignment(cell.horizontalAlignignment), &#13;
  verticalAlignignment(cell.verticalAlignignment), &#13;
  text(cell.text), &#13;
  caretList(cell.caretList), &#13;
  hasValue(cell.hasValue), &#13;
  value(cell.value) { &#13;
  if (cell.syntaxTreePtr != nullptr) { &#13;
    syntaxTreePtr = new Tree&lt;TreeNode&gt;(*cell.syntaxTreePtr); &#13;
    assert(syntaxTreePtr != nullptr); &#13;
  } &#13;
  else { &#13;
    syntaxTreePtr = nullptr; &#13;
  } &#13;
} &#13;
</pre><p>One difference between the copy constructor and the assignment operator is that we delete the syntax tree pointer in the assignment operator since it may point at dynamically allocated memory, which is not the case in the copy constructor. If it points at <code class="literal">null</code>, the <code class="literal">delete</code> operator does nothing:</p><pre class="programlisting">Cell&amp; Cell::operator=(const Cell&amp; cell) { &#13;
  if (this != &amp;cell) { &#13;
    cellMode = cell.cellMode; &#13;
    font = cell.font; &#13;
    backgroundColor = cell.backgroundColor; &#13;
    horizontalAlignignment = cell.horizontalAlignignment; &#13;
    verticalAlignignment = cell.verticalAlignignment; &#13;
    text = cell.text; &#13;
    caretList = cell.caretList; &#13;
    hasValue = cell.hasValue; &#13;
    value = cell.value; &#13;
    delete syntaxTreePtr; &#13;
 &#13;
    if (cell.syntaxTreePtr != nullptr) { &#13;
      syntaxTreePtr = new Tree&lt;TreeNode&gt;(*cell.syntaxTreePtr); &#13;
      assert(syntaxTreePtr != nullptr); &#13;
    } &#13;
&#13;
    else { &#13;
      syntaxTreePtr = nullptr; &#13;
    } &#13;
  } &#13;
 &#13;
  return *this; &#13;
} &#13;
</pre><p>The syntax tree is the only dynamically allocated memory of the cell. Again, in case of a null pointer, <code class="literal">delete</code> does nothing:</p><pre class="programlisting">Cell::~Cell() { &#13;
  delete syntaxTreePtr; &#13;
} &#13;
</pre><p>The difference between <code class="literal">Clear</code> and <code class="literal">Reset</code> is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Clear</code> is called when the user selects the <span class="strong"><strong>New</strong></span> menu item and the spreadsheet shall be totally cleared and also the cell's font, color and alignment shall be reset.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Reset</code> is called when the user deletes a cell and its mode and text shall be reset.</li></ul></div><pre class="programlisting">void Cell::Clear() { &#13;
  font = SystemFont; &#13;
  backgroundColor = White; &#13;
  horizontalAlignignment = Center; &#13;
  verticalAlignignment = Center; &#13;
  Reset(); &#13;
} &#13;
 &#13;
void Cell::Reset() { &#13;
  cellMode = TextMode; &#13;
  text.clear(); &#13;
  delete syntaxTreePtr; &#13;
  syntaxTreePtr = nullptr; &#13;
} &#13;
</pre><div class="section" title="Character input"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/>Character input</h2></div></div></div><p>The <code class="literal">CharDown</code> method is called by <code class="literal">WindowProc</code> (which in turn is called by the Windows system) every time the user presses a graphical character. If the input index is at the end of the text (one step to the right of the text), we just add the character at the end. If it is not at the end of the text, we have to take into consideration the keyboard mode, which is either insert or overwrite.</p><p>In case of an insert, we insert the character, and in case of overwrite, we overwrite the character previously located at the edit index. Unlike the word processor in the previous chapters, we do not have to deal with the font, since all characters in the cell have the same font:</p><pre class="programlisting">void Cell::CharDown(int editIndex, TCHAR tChar, &#13;
                    KeyboardMode keyboardMode) { &#13;
  if (editIndex == text.length()) { &#13;
    text.append(1, tChar); &#13;
  } &#13;
  else { &#13;
    switch (keyboardMode) { &#13;
      case InsertKeyboard: &#13;
        text.insert(editIndex, 1, tChar); &#13;
        break; &#13;
 &#13;
      case OverwriteKeyboard: &#13;
        text[editIndex] = tChar; &#13;
        break; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">MouseToIndex</code> method is called when the user double-clicks on the cell. First, we need to subtract the cell margin from the mouse position, then we iterate the caret list and return the position of the character hit by the mouse. If the user hits to the left of the first character (aligned at the center or right), zero index is returned, and if they hit to the right of the last character (aligned to the left or center), the size of the text is returned, which corresponds to the index to the right of the last character:</p><pre class="programlisting">int Cell::MouseToIndex(int x) const { &#13;
  x -= CellMargin; &#13;
 &#13;
  if (x &lt; caretList[0].Left()) { &#13;
    return 0; &#13;
  } &#13;
 &#13;
  int size = text.length(); &#13;
  for (int index = 0; index &lt; size; ++index) { &#13;
    if (x &lt; caretList[index].Right()) { &#13;
      return index; &#13;
    } &#13;
  } &#13;
 &#13;
  return size; &#13;
} &#13;
</pre></div><div class="section" title="Drawing"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>Drawing</h2></div></div></div><p>The <code class="literal">Draw</code> method is called when the contents of the cell are to be drawn. The drawing of the text is rather straightforward-for each character in the character list, we just draw the character in its caret rectangle. This particular cell may be marked or in the process of being edited, in which case the inverse is true. In that case, the text, background, and border colors are inverted. In order to not overwrite the border of the cell, we also take the cell margin into consideration:</p><pre class="programlisting">void Cell::DrawCell(Graphics&amp; graphics, Reference cellRef, &#13;
                    bool inverse) const { &#13;
  Point topLeft(HeaderWidth + cellRef.Col() * ColWidth, &#13;
                HeaderHeight + cellRef.Row() * RowHeight); &#13;
  Size cellSize(ColWidth, RowHeight); &#13;
  Rect cellRect(topLeft, cellSize); &#13;
 &#13;
  Color textColor = font.FontColor(), &#13;
        backColor = backgroundColor, borderColor = Black; &#13;
 &#13;
  if (inverse) { &#13;
    textColor = textColor.Inverse(); &#13;
    backColor = backColor.Inverse(); &#13;
    borderColor = borderColor.Inverse(); &#13;
  } &#13;
 &#13;
  graphics.FillRectangle(cellRect, borderColor, backColor); &#13;
  Size marginSize(CellMargin, CellMargin); &#13;
  int size = text.length(); &#13;
 &#13;
  for (int index = 0; index &lt; size; ++index) { &#13;
    TCHAR tChar = text[index]; &#13;
    Rect caretRect = caretList[index]; &#13;
 &#13;
    Rect charRect = (topLeft + marginSize) + caretRect; &#13;
    TCHAR text[] = {tChar, TEXT('\0')}; &#13;
    graphics.DrawText(charRect, text, font, textColor, backColor); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Caret rectangle list generation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/>Caret rectangle list generation</h2></div></div></div><p>When the user adds or removes a character of the text of a cell or changes its font or alignment, the caret rectangles need to be recalculated. <code class="literal">GenerateCaretList</code> can be considered a simplified version of <code class="literal">GenerateParagraph</code> in the word processor of the previous chapters. Its task is to calculate the character rectangles, which are used when setting the caret, drawing the text, and calculating the index of a mouse click.</p><p>First, we need to calculate the width of each character as well as the width of the text in order to set its horizontal start position. In case of justified alignment, we calculate the text width without spaces and count the spaces:</p><pre class="programlisting">void Cell::GenerateCaretList(Window* windowPtr) { &#13;
  vector&lt;int&gt; widthList; &#13;
  int textWidth = 0, spaceCount = 0, noSpaceWidth = 0; &#13;
 &#13;
  for (const TCHAR tChar : text) { &#13;
    int charWidth = windowPtr-&gt;GetCharacterWidth(font, tChar); &#13;
    widthList.push_back(charWidth); &#13;
    textWidth += charWidth; &#13;
 &#13;
    if (horizontalAlignignment == Justified) { &#13;
      if (tChar == TEXT(' ')) { &#13;
        ++spaceCount; &#13;
      } &#13;
      else { &#13;
        noSpaceWidth += charWidth; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>When we have calculated the text width, we set the horizontal start position. In case of left or justified alignment, the start position is set to the cell margin. In the case of justified alignment, we also set the width of each space in the text. In the case of right alignment, we add the difference between the width of the cell and the text to the cell margin in order to place the rightmost part of the text at the right border in the cell. In the case of center alignment, we add half the difference in order for the text to be placed in the middle of the cell:</p><pre class="programlisting">  int startPos = 0, spaceWidth, cellWidth = ColWidth - (2 * CellMargin); &#13;
 &#13;
  switch (horizontalAlignignment) { &#13;
    case Left: &#13;
      startPos = CellMargin; &#13;
      break; &#13;
 &#13;
    case Justified: { &#13;
        startPos = CellMargin; &#13;
        if (spaceCount &gt; 0) { &#13;
          spaceWidth = max(0,(cellWidth-noSpaceWidth)/spaceCount); &#13;
        } &#13;
      } &#13;
      break; &#13;
 &#13;
    case Right: &#13;
      startPos = CellMargin + max(0, cellWidth - textWidth); &#13;
      break; &#13;
 &#13;
    case Center: &#13;
      startPos = CellMargin + max(0, (cellWidth - textWidth) / 2); &#13;
      break; &#13;
  } &#13;
</pre><p>The vertical top position is set in a similar manner. In the case of top alignment, the top position is set to the cell margin. In the case of bottom alignment, we add the difference between the height of the cell and the text to the cell margin in order to place the bottom part of the text at the bottom border in the cell. In the case of center alignment, we add half the difference in order to place the text in the middle of the cell:</p><pre class="programlisting">  int topPos = 0, &#13;
      textHeight = windowPtr-&gt;GetCharacterHeight(font), &#13;
      cellHeight = RowHeight - (2 * CellMargin); &#13;
 &#13;
  switch (verticalAlignignment) { &#13;
    case Top: &#13;
      topPos = CellMargin; &#13;
      break; &#13;
 &#13;
    case Bottom: &#13;
      topPos = CellMargin + max(0, cellHeight - textHeight); &#13;
      break; &#13;
 &#13;
    case Center: &#13;
      topPos = CellMargin + max(0, (cellHeight - textHeight) / 2); &#13;
      break; &#13;
  } &#13;
</pre><p>When the horizontal start position and the top vertical position has been set, we iterate through the characters and add the rectangles to <code class="literal">caretList</code> for each of them. Note that we use the value of <code class="literal">spaceWidth</code> for spaces in the case of justified alignment:</p><pre class="programlisting">  caretList.clear(); &#13;
  int size = text.size(); &#13;
  for (int index = 0; index &lt; size; ++index) { &#13;
    int charWidth = widthList[index]; &#13;
 &#13;
    if ((horizontalAlignignment == Justified) &amp;&amp; &#13;
        (text[index] == TEXT(' '))) { &#13;
      charWidth = spaceWidth; &#13;
    } &#13;
 &#13;
    Point topLeft(startPos, topPos); &#13;
    Size charSize(charWidth, textHeight); &#13;
    caretList.push_back(Rect(topLeft, charSize)); &#13;
    startPos += charWidth; &#13;
  } &#13;
</pre><p>When each rectangle is added, we add the rectangle for the character to the right of the text. We set its width to the width of an average character of the cell's font:</p><pre class="programlisting">  Point topLeft(startPos, topPos); &#13;
  int averageWidth = windowPtr-&gt;GetCharacterAverageWidth(font); &#13;
  Size charSize(averageWidth, textHeight); &#13;
  caretList.push_back(Rect(topLeft, charSize)); &#13;
} &#13;
</pre></div><div class="section" title="Formula interpretation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec83"/>Formula interpretation</h2></div></div></div><p>When the user single-clicks or double-clicks on a cell, its text remains unchanged in the text or value mode, but it gets changed in the formula mode. In the formula mode, the calculated value of the formula is displayed in the mark mode, while in the edit mode, the formula itself is displayed. <code class="literal">DisplayFormula</code> calls <code class="literal">TreeToString</code> in the formula mode, which generates the text of the formula:</p><pre class="programlisting">void Cell::DisplayFormula() { &#13;
  switch (cellMode) { &#13;
    case TextMode: &#13;
    case ValueMode: &#13;
      break; &#13;
 &#13;
    case FormulaMode: &#13;
      text = TEXT("=") + TreeToString(syntaxTreePtr); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">InterpretCell</code> method is called when the user terminates the text input by pressing the <span class="emphasis"><em>
<span class="strong"><strong>Enter</strong></span>
</em></span> or <span class="emphasis"><em>
<span class="strong"><strong>Tab</strong></span>
</em></span> key or clicking the mouse. If the user has input a formula (starting with <span class="emphasis"><em>=</em></span>), it is parsed. <code class="literal">Parse</code> returns a syntax tree holding the formula or throws an exception in the case of a syntax error. Note that <code class="literal">InterpretCell</code> only report the syntax error. All other errors (missing value, references out of range, circular reference, or division by zero) are handled by the following <code class="literal">Evaluate</code>:</p><pre class="programlisting">void Cell::InterpretCell(set&lt;Reference&gt;&amp; sourceSet) { &#13;
  String trimText = Trim(text); &#13;
 &#13;
  if (IsNumeric(trimText)) { &#13;
    cellMode = ValueMode; &#13;
    value = stod(trimText); &#13;
  } &#13;
  else if (!trimText.empty() &amp;&amp; (trimText[0] == TEXT('='))) { &#13;
    cellMode = FormulaMode; &#13;
    Parser parser(trimText.substr(1)); &#13;
    syntaxTreePtr = parser.Parse(); &#13;
    GenerateSourceSet(syntaxTreePtr, sourceSet); &#13;
  } &#13;
  else { &#13;
    cellMode = TextMode; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">GenerateSourceSet</code> method traverses the syntax tree and extracts a (possible empty) set of all its references in the formula mode. In the case of text or value mode, the set is empty, since only formulas hold references:</p><pre class="programlisting">void Cell::GenerateSourceSet(set&lt;Reference&gt;&amp; sourceSet) const{ &#13;
  if (cellMode == FormulaMode) { &#13;
    GenerateSourceSet(syntaxTreePtr, sourceSet); &#13;
  } &#13;
} &#13;
</pre><p>In case of unary addition or subtraction or an expression enclosed by parentheses, the source set of its child node is returned:</p><pre class="programlisting">void Cell::GenerateSourceSet(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                             set&lt;Reference&gt;&amp; sourceSet) const{ &#13;
  DynamicList&lt;Tree&lt;TreeNode&gt;*&gt; childList = &#13;
    syntaxNodePtr-&gt;ChildList();  &#13;
  switch (syntaxNodePtr-&gt;NodeValue().Id()) { &#13;
    case UnaryAdd: &#13;
    case UnarySubtract: &#13;
    case Parenthesis: &#13;
      return GenerateSourceSet(childList[0]); &#13;
</pre><p>In the case of a binary expression, the union of the source sets of the two children is returned:</p><pre class="programlisting">    case BinaryAdd: &#13;
    case BinarySubtract: &#13;
    case Multiply: &#13;
    case Divide: { &#13;
        set&lt;Reference&gt; leftSet = GenerateSourceSet(childList[0]), &#13;
                       rightSet = GenerateSourceSet(childList[1]); &#13;
        leftSet.insert(rightSet.begin(), rightSet.end()); &#13;
        return leftSet; &#13;
      } &#13;
</pre><p>In the case of a reference, a set holding only the reference is returned if it is located in the spreadsheet. No references outside the spreadsheet are included in the set:</p><pre class="programlisting">    case RefId: { &#13;
        set&lt;Reference&gt; singleSet; &#13;
        Reference sourceRef = &#13;
          syntaxNodePtr-&gt;NodeValue().ReferenceField(); &#13;
 &#13;
        if ((sourceRef.Row() &gt;= 0) &amp;&amp; (sourceRef.Row() &lt; Rows) &amp;&amp; &#13;
            (sourceRef.Col() &gt;= 0) &amp;&amp; (sourceRef.Col() &lt; Cols)) { &#13;
          singleSet.insert(sourceRef); &#13;
        } &#13;
 &#13;
        return singleSet; &#13;
      } &#13;
</pre><p>Finally, in the case of a value, an empty set is returned:</p><pre class="programlisting">    case ValueId: &#13;
      return set&lt;Reference&gt;(); &#13;
  } &#13;
 &#13;
  assert(false); &#13;
  return set&lt;Reference&gt;(); &#13;
} &#13;
</pre><p>The <code class="literal">TreeToString</code> method traverses the syntax tree and converts it to a string. Note that it is quite possible to have a formula with a reference out of scope. However, the <code class="literal">Reference</code> class returns <code class="literal">?</code> in that case:</p><pre class="programlisting">String Cell::TreeToString() const { &#13;
  if (cellMode == FormulaMode) { &#13;
    return TEXT("=") + TreeToString(syntaxTreePtr); &#13;
  } &#13;
&#13;
  else { &#13;
    return text; &#13;
  } &#13;
} &#13;
</pre><p>In the case of unary addition or subtraction, <code class="literal">+</code> or <code class="literal">-</code> is added to the text of the child node:</p><pre class="programlisting">String Cell::TreeToString(Tree&lt;TreeNode&gt;* syntaxNodePtr) const { &#13;
  DynamicList&lt;Tree&lt;TreeNode&gt;*&gt; childList = &#13;
    syntaxNodePtr-&gt;ChildList(); &#13;
 &#13;
  switch (syntaxNodePtr-&gt;NodeValue().Id()) { &#13;
    case UnaryAdd: &#13;
      return TEXT("+") + TreeToString(childList[0]); &#13;
 &#13;
    case UnarySubtract: &#13;
      return TEXT("-") + TreeToString(childList[0]); &#13;
      break; &#13;
</pre><p>In the case of a binary expressions <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, or <code class="literal">/</code> is inserted between the text of the child nodes:</p><pre class="programlisting">    case BinaryAdd: &#13;
      return TreeToString(childList[0]) + TEXT("+") + &#13;
             TreeToString(childList[1]); &#13;
 &#13;
    case BinarySubtract: &#13;
      return TreeToString(childList[0]) + TEXT("-") + &#13;
             TreeToString(childList[1]); &#13;
 &#13;
    case Multiply: &#13;
      return TreeToString(childList[0]) + TEXT("*") + &#13;
             TreeToString(childList[1]); &#13;
 &#13;
    case Divide: &#13;
      return TreeToString(childList[0]) + TEXT("/") + &#13;
             TreeToString(childList[1]); &#13;
</pre><p>In the case of an expression enclosed by parentheses, the text of the child node enclosed by parentheses is returned:</p><pre class="programlisting">    case Parenthesis: &#13;
      return TEXT("(") + TreeToString(childList[0]) + TEXT(")"); &#13;
</pre><p>In the case of a reference, its text is returned. Again, if the reference is out of range, <code class="literal">?</code> is returned:</p><pre class="programlisting">    case RefId: &#13;
      return syntaxNodePtr-&gt; &#13;
             NodeValue().ReferenceField().ToString(); &#13;
</pre><p>In the case of a value, its converted text is returned:</p><pre class="programlisting">    case ValueId: &#13;
      return to_String(syntaxNodePtr-&gt;NodeValue().Value()); &#13;
  } &#13;
 &#13;
  assert(false); &#13;
  return TEXT(""); &#13;
} &#13;
</pre><p>When the user copies and pastes a block of cells, the references of each formula are relative and will be updated. <code class="literal">UpdateTree</code> looks for and updates references in the syntax tree. In all other cases, it iterates through the child list and calls <code class="literal">UpdateTree</code> recursively for each child (one child each in a unary expression and a parentheses expression, two children in a binary expression, and no children in values or references):</p><pre class="programlisting">void Cell::UpdateTree(Reference diffRef,set&lt;Reference&gt;&amp;sourceSet) { &#13;
  if (cellMode == FormulaMode) { &#13;
    UpdateTree(syntaxTreePtr, diffRef, sourceSet); &#13;
  } &#13;
}  &#13;
&#13;
void Cell::UpdateTree(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                 Reference diffRef, set&lt;Reference&gt;&amp; sourceSet) { &#13;
  if (syntaxNodePtr-&gt;NodeValue().Id() == RefId) { &#13;
    syntaxNodePtr-&gt;NodeValue().ReferenceField() += diffRef;&#13;
    sourceSet.insert(syntaxNodePtr-&gt;NodeValue().ReferenceField()); &#13;
  } &#13;
  else { &#13;
    for (Tree&lt;TreeNode&gt;* childNodePtr : &#13;
         syntaxNodePtr-&gt;ChildList()) { &#13;
      UpdateTree(childNodePtr, diffRef, sourceSet); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>When the value of a formula is evaluated, it may return a valid value, in which case <code class="literal">hasValue</code> is set to <code class="literal">true</code>. However, if an error occurs during the evaluation (missing value, references out of range, circular reference, or division by zero), <code class="literal">hasValue</code> is set to <code class="literal">false</code>. <code class="literal">hasValue</code> is called when a value of a formula of another cell is being evaluated. If it returns <code class="literal">false</code>, the evaluation will result in the missing value error:</p><pre class="programlisting">bool Cell::HasValue() const{ &#13;
  switch (cellMode) { &#13;
    case TextMode: &#13;
      return false;  &#13;
    case ValueMode: &#13;
      return true; &#13;
 &#13;
    case FormulaMode: &#13;
      return hasValue; &#13;
  }  &#13;
&#13;
  assert(false); &#13;
  return false; &#13;
} &#13;
</pre><p>In the formula mode, the formula is being evaluated to a value. If an error occurs (missing value, reference out of range, circular reference, or division by zero), an exception is thrown by <code class="literal">Evaluate</code>, and the cell text is set to the error message text. Note that it is possible to input references out of scope, which <code class="literal">InterpretCell</code> accepts. However, <code class="literal">Evaluate</code> throws an exception with an error message that is displayed in the cell.</p><p>Moreover, it is quite possible to cut, copy, and paste a cell so that its references get located out of the scope and then cut, copied, and pasted again so that the references become valid. However, if the user edits a formula with references out of the scope, <code class="literal">?</code> is returned by the <code class="literal">ToString</code> method in the <code class="literal">Reference</code> class, since it is difficult to express references with negative columns:</p><pre class="programlisting">void Cell::Evaluate(map&lt;Reference,double&gt;&amp; valueMap) { &#13;
  if (cellMode == FormulaMode) { &#13;
    try { &#13;
      value = Evaluate(syntaxTreePtr, valueMap); &#13;
      text = to_String(value); &#13;
      hasValue = true; &#13;
    } &#13;
    catch (Error error) { &#13;
      text = error.ErrorText(); &#13;
      hasValue = false; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">Evaluate</code> method finds the current value of the cell by looking up the values of the cells referred to by the formula:</p><pre class="programlisting">double Cell::Evaluate(Tree&lt;TreeNode&gt;* syntaxNodePtr, &#13;
                      map&lt;Reference,double&gt;&amp; valueMap) { &#13;
  DynamicList&lt;Tree&lt;TreeNode&gt;*&gt; childList = &#13;
    syntaxNodePtr-&gt;ChildList(); &#13;
</pre><p>In the case of a unary or binary expression, the value is calculated (unary addition is only present for the sake of completeness and does not change the value):</p><pre class="programlisting">  switch (syntaxNodePtr-&gt;NodeValue().Id()) { &#13;
    case UnaryAdd: &#13;
      return Evaluate(childList[0], valueMap); &#13;
 &#13;
    case UnarySubtract: &#13;
      return -Evaluate(childList[0], valueMap); &#13;
 &#13;
    case BinaryAdd: &#13;
      return Evaluate(childList[0], valueMap) + &#13;
             Evaluate(childList[1], valueMap); &#13;
 &#13;
    case BinarySubtract: &#13;
      return Evaluate(childList[0], valueMap) - &#13;
             Evaluate(childList[1], valueMap); &#13;
 &#13;
    case Multiply: &#13;
      return Evaluate(childList[0], valueMap) * &#13;
             Evaluate(childList[1], valueMap); &#13;
</pre><p>In case of division by zero, an exception is thrown.</p><pre class="programlisting">    case Divide: { &#13;
        double remainder = Evaluate(childList[1], valueMap); &#13;
 &#13;
        if (remainder != 0) { &#13;
          return Evaluate(childList[0], valueMap) / remainder; &#13;
        } &#13;
        else { &#13;
          throw Error(DivisionByZero); &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In the case of an expression within parentheses, we simply return its evaluated value:</p><pre class="programlisting">    case Parenthesis: &#13;
      return Evaluate(childList[0], valueMap); &#13;
</pre><p>In the case of a reference, we look up the source cell in <code class="literal">valueMap</code>. In the case of a source cell with a missing value (not present in <code class="literal">valueMap</code>) or a reference out of scope (referring to a cell outside the spreadsheet), exceptions are thrown:</p><pre class="programlisting">    case RefId: { &#13;
        Reference sourceRef = &#13;
          syntaxNodePtr-&gt;NodeValue().ReferenceField(); &#13;
 &#13;
        if ((sourceRef.Row() &gt;= 0) &amp;&amp; (sourceRef.Row() &lt; Rows) &amp;&amp; &#13;
            (sourceRef.Col() &gt;= 0) &amp;&amp; (sourceRef.Col() &lt; Cols)) { &#13;
          if (valueMap.find(sourceRef) != valueMap.end()) { &#13;
            return valueMap[sourceRef]; &#13;
          } &#13;
          else { &#13;
            throw Error(MissingValue); &#13;
          } &#13;
        } &#13;
        else { &#13;
          throw Error(ReferenceOutOfRange); &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>In the case of a value, we simply return the value:</p><pre class="programlisting">    case ValueId: &#13;
      return syntaxNodePtr-&gt;NodeValue().Value(); &#13;
  } &#13;
 &#13;
  assert(false); &#13;
  return 0; &#13;
} &#13;
</pre></div><div class="section" title="File management"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec84"/>File management</h2></div></div></div><p>The <code class="literal">WriteDocumentToStream</code> method is called by <code class="literal">CalcDocument</code> every time the user selects the <span class="strong"><strong>Save</strong></span> or <span class="strong"><strong>Save As</strong></span> menu items from the file menu. In the formula mode, we call <code class="literal">WriteTreeToStream</code> on the syntax tree:</p><pre class="programlisting">bool Cell::WriteCellToStream(ostream&amp; outStream) const { &#13;
  outStream.write((char*) &amp;cellMode, sizeof cellMode); &#13;
  outStream.write((char*) &amp;horizontalAlignignment, &#13;
                  sizeof horizontalAlignignment); &#13;
  outStream.write((char*) &amp;verticalAlignignment, &#13;
                  sizeof verticalAlignignment); &#13;
  outStream.write((char*) &amp;hasValue, sizeof hasValue); &#13;
  outStream.write((char*) &amp;value, sizeof value); &#13;
 &#13;
  backgroundColor.WriteColorToStream(outStream); &#13;
  font.WriteFontToStream(outStream); &#13;
 &#13;
  int charListSize = text.size(); &#13;
  outStream.write((char*) &amp;charListSize, sizeof charListSize); &#13;
 &#13;
  for (const TCHAR tChar : text) { &#13;
    outStream.write((char*) &amp;tChar, sizeof tChar); &#13;
  } &#13;
 &#13;
  for (const Rect caretRect : caretList) { &#13;
    caretRect.WriteRectToStream(outStream); &#13;
  } &#13;
 &#13;
  if (cellMode == FormulaMode) { &#13;
    syntaxTreePtr-&gt;WriteTreeToStream(outStream); &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
</pre><p>In <code class="literal">ReadCellFromStream</code>, we dynamically create and read the syntax tree in the formula mode:</p><pre class="programlisting">bool Cell::ReadCellFromStream(istream&amp; inStream) { &#13;
  inStream.read((char*) &amp;cellMode, sizeof cellMode); &#13;
  inStream.read((char*) &amp;horizontalAlignignment, &#13;
                sizeof horizontalAlignignment); &#13;
  inStream.read((char*) &amp;verticalAlignignment, &#13;
                sizeof verticalAlignignment); &#13;
  inStream.read((char*) &amp;hasValue, sizeof hasValue); &#13;
  inStream.read((char*) &amp;value, sizeof value); &#13;
 &#13;
  backgroundColor.ReadColorFromStream(inStream); &#13;
  font.ReadFontFromStream(inStream); &#13;
 &#13;
  int charListSize; &#13;
  inStream.read((char*) &amp;charListSize, sizeof charListSize); &#13;
 &#13;
  for (int count = 0; count &lt; charListSize; ++count) { &#13;
    TCHAR tChar; &#13;
    inStream.read((char*) &amp;tChar, sizeof tChar); &#13;
    text.append(1, tChar); &#13;
  } &#13;
 &#13;
  for (int count = 0; count &lt; (charListSize + 1); ++count) { &#13;
    Rect caretRect; &#13;
    caretRect.ReadRectFromStream(inStream); &#13;
    caretList.push_back(caretRect); &#13;
  } &#13;
 &#13;
  if (cellMode == FormulaMode) { &#13;
    syntaxTreePtr = new Tree&lt;TreeNode&gt;(); &#13;
    assert(syntaxTreePtr != nullptr); &#13;
    syntaxTreePtr-&gt;ReadTreeFromStream(inStream); &#13;
  } &#13;
  else { &#13;
    syntaxTreePtr = nullptr; &#13;
  } &#13;
 &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">WriteCellToClipboard</code> and <code class="literal">ReadCellFromClipboard</code> methods are called by <code class="literal">CalcDocument</code> when the user cuts, copies, and pastes the cell. It works in the same way as <code class="literal">WriteDocumentToStream</code> and <code class="literal">ReadCellFromStream</code> we saw earlier:</p><pre class="programlisting">void Cell::WriteCellToClipboard(InfoList&amp; infoList) const { &#13;
  infoList.AddValue&lt;CellMode&gt;(cellMode); &#13;
  infoList.AddValue&lt;Alignment&gt;(horizontalAlignignment); &#13;
  infoList.AddValue&lt;Alignment&gt;(verticalAlignignment); &#13;
  infoList.AddValue&lt;double&gt;(value); &#13;
  infoList.AddValue&lt;bool&gt;(hasValue); &#13;
 &#13;
  font.WriteFontToClipboard(infoList); &#13;
  backgroundColor.WriteColorToClipboard(infoList); &#13;
  infoList.AddValue&lt;int&gt;(text.size()); &#13;
 &#13;
  for (const TCHAR tChar : text) { &#13;
    infoList.AddValue&lt;TCHAR&gt;(tChar); &#13;
  } &#13;
 &#13;
  if (cellMode == FormulaMode) { &#13;
    syntaxTreePtr-&gt;WriteTreeToClipboard(infoList); &#13;
  } &#13;
} &#13;
 &#13;
void Cell::ReadCellFromClipboard(InfoList&amp; infoList) { &#13;
  infoList.GetValue&lt;CellMode&gt;(cellMode); &#13;
  infoList.GetValue&lt;Alignment&gt;(horizontalAlignignment); &#13;
  infoList.GetValue&lt;Alignment&gt;(verticalAlignignment); &#13;
  infoList.GetValue&lt;double&gt;(value); &#13;
  infoList.GetValue&lt;bool&gt;(hasValue); &#13;
 &#13;
  font.ReadFontFromClipboard(infoList); &#13;
  backgroundColor.ReadColorFromClipboard(infoList); &#13;
 &#13;
  int listSize; &#13;
  infoList.GetValue&lt;int&gt;(listSize); &#13;
 &#13;
  for (int count = 0; count &lt; listSize; ++count) { &#13;
    TCHAR tChar; &#13;
    infoList.GetValue&lt;TCHAR&gt;(tChar); &#13;
    text.push_back(tChar);&#13;
  } &#13;
 &#13;
  for (int count = 0; count &lt; (listSize + 1); ++count) { &#13;
    Rect caretRect; &#13;
    caretRect.ReadRectFromClipboard(infoList); &#13;
    caretList.push_back(caretRect); &#13;
  } &#13;
 &#13;
  if (cellMode == FormulaMode) { &#13;
    syntaxTreePtr = new Tree&lt;TreeNode&gt;(); &#13;
    assert(syntaxTreePtr != nullptr); &#13;
    syntaxTreePtr-&gt;ReadTreeFromClipboard(infoList); &#13;
  } &#13;
  else { &#13;
    syntaxTreePtr = nullptr; &#13;
  } &#13;
} &#13;
</pre></div></div>
<div class="section" title="Further reading"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec43"/>Further reading</h1></div></div></div><p>If the scanner and parser of this chapter have got you interested in compilers, I recommend that you refer to <span class="emphasis"><em>Compilers: Principles, Techniques, and Tools</em></span> by A. V. Aho et al. (second edition. Addison Wesley, 2007). It is the second edition of the classic <span class="emphasis"><em>Dragon Book</em></span>. The authors explain the theory and practice of compilers from scanning and parsing to advanced optimization.</p><p>If the concept of graphs has caught your interest, I recommend <span class="emphasis"><em>Introduction to Graph Theory</em></span> by D. B. West (Prentice Hall, 2000), which reasons about graphs from a mathematical point of view.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we covered the spreadsheet program implementation. This chapter concludes the first part of this book: how to develop an application with Small Windows. <a class="link" href="ch10.html" title="Chapter 10. The Framework">Chapter 10</a>, <span class="emphasis"><em>The Framework</em></span>, introduces the second part: the implementation of Small Windows.</p></div></body></html>