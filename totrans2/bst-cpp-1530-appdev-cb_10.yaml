- en: Chapter 10. Gathering Platform and Compiler Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 收集平台和编译器信息
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Detecting int128 support
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测int128支持
- en: Detecting RTTI support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测RTTI支持
- en: Speeding up compilation using C++11 extern templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++11 extern模板加速编译
- en: Writing metafunctions using simpler methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更简单的方法编写元函数
- en: Reducing code size and increasing performance of user-defined types (UDTs) in
    C++11
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++11中减少用户定义类型（UDT）的代码大小并提高性能
- en: The portable way to export and import functions and classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出和导入函数和类的可移植方式
- en: Detecting the Boost version and getting latest features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Boost版本和获取最新功能
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Different projects and companies have different coding requirements. Some of
    them forbid exceptions or RTTI and some forbid C++11\. If you are willing to write
    portable code that can be used by a wide range of projects, this chapter is for
    you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的项目和公司有不同的编码要求。其中一些禁止异常或RTTI，而另一些禁止C++11。如果您愿意编写可移植的代码，这些代码可以用于广泛的工程，那么这一章就是为您准备的。
- en: Want to make your code as fast as possible and use the latest C++ features?
    You'll definitely need a tool for detecting compiler features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使您的代码尽可能快并使用最新的C++功能？您肯定会需要一个用于检测编译器功能的工具。
- en: Some compilers have unique features that may greatly simplify your life. If
    you are targeting a single compiler, you can save many hours and use those features.
    No need to implement their analogues from scratch!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器具有独特的功能，这些功能可能会极大地简化您的生活。如果您针对单个编译器，您可以节省许多小时并使用这些功能。无需从头开始实现它们的类似功能！
- en: This chapter is devoted to different helper macros used to detect compiler,
    platform, and Boost features. Those macro are widely used across Boost libraries
    and are essential for writing portable code that is able to work with any compiler
    flags.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于不同类型的辅助宏，用于检测编译器、平台和Boost功能。这些宏在Boost库中广泛使用，对于编写能够与任何编译器标志一起工作的可移植代码至关重要。
- en: Detecting int128 support
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测int128支持
- en: Some compilers have support for extended arithmetic types such as 128-bit floats
    or integers. Let's take a quick glance at how to use them using Boost. We'll be
    creating a method that accepts three parameters and returns the multiplied value
    of those methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器支持扩展算术类型，例如128位浮点数或整数。让我们快速了解一下如何使用Boost来使用它们。我们将创建一个接受三个参数并返回这些方法乘积的方法。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要具备基本的C++知识。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: What do we need to work with 128-bit integers? Macros that show that they are
    available and a few typedefs to have portable type names across platforms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要什么来处理128位整数？显示它们可用的宏以及一些跨平台的typedef来具有可移植的类型名称。
- en: 'We''ll need only a single header:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要一个头文件：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we need to detect int128 support:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要检测int128支持：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add some typedefs and implement the method as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些typedef并按以下方式实现方法：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For compilers that do not support the int128 type, we may require support of
    the int64 type:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于不支持int128类型的编译器，我们可能需要支持int64类型：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we need to provide some implementation for compilers without int128 support
    using int64:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为不支持int128的编译器提供使用int64的实现：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The header `<boost/config.hpp>` contains a lot of macros to describe compiler
    and platform features. In this example, we used `BOOST_HAS_INT128` to detect support
    of 128-bit integers and `BOOST_NO_LONG_LONG` to detect support of 64-bit integers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件 `<boost/config.hpp>` 包含了许多宏来描述编译器和平台功能。在这个例子中，我们使用了 `BOOST_HAS_INT128` 来检测128位整数的支持，以及
    `BOOST_NO_LONG_LONG` 来检测64位整数的支持。
- en: 'As we may see from the example, Boost has typedefs for 64-bit signed and unsigned
    integers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中看到的那样，Boost为64位有符号和无符号整数提供了typedef：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It also has typedefs for 128-bit signed and unsigned integers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它也提供了128位有符号和无符号整数的typedef：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: C++11 has support of 64-bit types via the `long long int` and `unsigned long
    long int` built-in types. Unfortunately, not all compilers support C++11, so `BOOST_NO_LONG_LONG`
    will be useful for you. 128-bit integers are not a part of C++11, so typedefs
    and macros from Boost are the only way to write portable code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过 `long long int` 和 `unsigned long long int` 内置类型支持64位类型。不幸的是，并非所有编译器都支持C++11，所以
    `BOOST_NO_LONG_LONG` 对您将很有用。128位整数不是C++11的一部分，因此Boost的typedef和宏是编写可移植代码的唯一方法。
- en: See also
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read the recipe *Detecting RTTI support* for more information about `Boost.Config`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `Boost.Config` 的更多信息，请参阅食谱 *检测RTTI支持*。
- en: Read the official documentation of `Boost.Config` for more information about
    its abilities at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a library in Boost that allows constructing types of unlimited precision.
    Take a look at the `Boost.Multiprecision` library at [http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting RTTI support
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some companies and libraries have specific requirements for their C++ code,
    such as successful compilation without **Runtime type information** (**RTTI**).
    In this small recipe, we'll take a look at how we can detect disabled RTTI, how
    to store information about types, and compare types at runtime, even without `typeid`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ RTTI usage is required for this recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting disabled RTTI, storing information about types, and comparing types
    at runtime are tricks that are widely used across Boost libraries. The examples
    are `Boost.Exception` and `Boost.Function`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to include the following header:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s first look at the situation where RTTI is enabled and the C++11 `std::type_index`
    class is available:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Otherwise, we need to construct our own `type_index` class:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final step is to define the `type_id` function:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can compare types:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The macro `BOOST_NO_RTTI` will be defined if RTTI is disabled, and the macro
    `BOOST_NO_CXX11_HDR_TYPEINDEX` will be defined when the compiler has no `<typeindex>`
    header and no `std::type_index` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The handwritten `type_index` structure from step 3 of the previous section only
    holds the pointer to some string; nothing really interesting here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `BOOST_CURRENT_FUNCTION` macro. It returns the full name
    of the current function, including template parameters, arguments, and the return
    type. For example, `type_id<double>()` will be represented as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, for any other type, `BOOST_CURRENT_FUNCTION` will return a different string,
    and that's why the `type_index` variable from the example won't compare equal-to
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different compilers have different macros for getting the full function name
    and RTTI. Using macros from Boost is the most portable solution. The `BOOST_CURRENT_FUNCTION`
    macro returns the name at compile time, so it implies minimal runtime penalty.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the upcoming recipes for more information on `Boost.Config`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse to [https://github.com/apolukhin/type_index](https://github.com/apolukhin/type_index)
    and refer to the library there, which uses all the tricks from this recipe to
    implement `type_index`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up compilation using C++11 extern templates
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++11外部模板加速编译
- en: Remember some situations where you were using some complicated template class
    declared in the header file? Examples of such classes would be `boost::variant`,
    containers from `Boost.Container`, or `Boost.Spirit` parsers. When we use such
    classes or methods, they are usually compiled (instantiated) separately in each
    source file that is using them, and duplicates are thrown away during linking.
    On some compilers, that may lead to slow compilation speed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你曾经使用过的一些在头文件中声明的复杂模板类的情况吗？这样的类的例子包括`boost::variant`、来自`Boost.Container`的容器或`Boost.Spirit`解析器。当我们使用这样的类或方法时，它们通常在每个使用它们的源文件中单独编译（实例化），并且在链接过程中会丢弃重复项。在某些编译器上，这可能会导致编译速度变慢。
- en: If only there was some way to tell the compiler in which source file to instantiate
    it!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方法可以告诉编译器在哪个源文件中实例化它就好了！
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of templates is required for this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要具备模板的基本知识才能完成此食谱。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: This method is widely used in modern C++ standard libraries for compilers that
    do support it. For example, the STL library, which is shipped with GCC, uses this
    technique to instantiate `std::basic_string<char>` and `std::basic_fstream<char>`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在现代C++标准库中广泛用于支持它的编译器。例如，与GCC一起提供的STL库使用这种技术实例化`std::basic_string<char>`和`std::basic_fstream<char>`。
- en: 'To do it by ourselves, we need to include the following header:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要自行完成，我们需要包含以下头文件：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to include a header file that contains a template class whose
    instantiation count we wish to reduce:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要包含一个包含我们希望减少实例化计数的模板类的头文件：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the code for compilers with support for C++11 extern templates:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为支持C++11外部模板的编译器提供的代码：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to add the following code to the source file where we wish the
    template to be instantiated:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将以下代码添加到我们希望模板实例化的源文件中：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The C++11 keyword `extern template` just tells the compiler not to instantiate
    the template without an explicit request to do that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++11关键字`extern template`只是告诉编译器不要在没有显式请求的情况下实例化模板。
- en: The code in step 4 is an explicit request to instantiate the template in this
    source file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步中的代码是显式请求在此源文件中实例化模板。
- en: The `BOOST_NO_CXX11_EXTERN_TEMPLATE` macro is defined when the compiler has
    support of C++11 extern templates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器支持C++11外部模板时，定义了`BOOST_NO_CXX11_EXTERN_TEMPLATE`宏。
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Extern templates do not affect the runtime performance of your program, but
    can significantly reduce the compilation time of some template classes. Do not
    overuse them; they are nearly useless for small template classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模板不会影响你程序的运行时性能，但可以显著减少某些模板类的编译时间。不要过度使用它们；对于小型模板类来说，它们几乎毫无用处。
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read the other recipes of this chapter to get more information about `Boost.Config`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读本章的其他食谱，以获取有关`Boost.Config`的更多信息。
- en: Read the official documentation of `Boost.Config` for information about macros
    that was not covered in this chapter, at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关本章未涵盖的宏的官方文档，请参阅`Boost.Config`的文档，网址为[http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)
- en: Writing metafunctions using simpler methods
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更简单的方法编写元函数
- en: '[Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*,
    and [Chapter 8](ch08.html "Chapter 8. Metaprogramming"), *Metaprogramming*, were
    devoted to metaprogramming. If you were trying to use techniques from those chapters,
    you may have noticed that writing a metafunction can take a lot of time. So it
    may be a good idea to experiment with metafunctions using more user-friendly methods,
    such as C++11 `constexpr`, before writing a portable implementation.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。编译时技巧")，“编译时技巧”，和[第8章](ch08.html "第8章。元编程")，“元编程”，都是关于元编程的。如果你试图使用那些章节中的技术，你可能已经注意到编写元函数可能需要花费很多时间。因此，在编写可移植实现之前，使用更用户友好的方法，如C++11
    `constexpr`进行元函数实验可能是一个好主意。'
- en: In this recipe, we'll take a look at how to detect `constexpr` support.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨如何检测`constexpr`支持。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `constexpr` functions are functions that can be evaluated at compile time.
    That is all we need to know for this recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数是可以编译时评估的函数。这就是我们为此食谱需要了解的所有内容。'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Currently, not many compilers support the `constexpr` feature, so a good new
    compiler may be required for experiments. Let''s see how we can detect compiler
    support for the `constexpr` feature:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in other recipes from this chapter, we start with the following header:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we will work with `constexpr`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s print an error if C++11 features are missing:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That''s it; now we are free to write code such as the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_CONSTEXPR` macro is defined when C++11 `constexpr` is available.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The `constexpr` keyword tells the compiler that the function can be evaluated
    at compile time if all the inputs for that function are compile-time constants.
    C++11 imposes a lot of limitations on what a `constexpr` function can do. C++14
    will remove some of the limitations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_HDR_ARRAY` macro is defined when the C++11 `std::array`
    class and the `<array>` header are available.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, there are other usable and interesting macros for `constexpr` too,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR` macro expands to `constexpr` or does not expand
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR_OR_CONST` macro expands to `constexpr` or `const`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_STATIC_CONSTEXPR` macro is the same as `static BOOST_CONSTEXPR_OR_CONST`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using those macros, it is possible to write code that takes advantage of C++11
    constant expression features if they are available:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can use `integral_constant` as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the example, `BOOST_CONSTEXPR operator T()` will be called to get the array
    size.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The C++11 constant expressions may improve compilation speed and diagnostic
    information in case of error. It's a good feature to use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about `constexpr` usage can be read at [http://en.cppreference.com/w/cpp/language/constexpr](http://en.cppreference.com/w/cpp/language/constexpr)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` for more information about
    macros at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code size and increasing performance of user-defined types (UDTs) in
    C++11
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has very specific logic when **user-defined types** (**UDTs**) are used
    in STL containers. Containers will use move assignment and move construction only
    if the move constructor does not throw exceptions or there is no copy constructor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can ensure the `move_nothrow` assignment operator and `move_nothrow`
    constructor of our type do not throw exceptions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++11 rvalue references is required for this recipe. Knowledge
    of STL containers will also serve you well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how we can improve our C++ classes using Boost.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is mark the `move_nothrow` assignment operator and `move_nothrow`
    constructor with the `BOOST_NOEXCEPT` macro:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we may use the class with `std::vector` in C++11 without any modifications:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we remove `BOOST_NOEXCEPT` from the move constructor, we''ll get the following
    error for GCC-4.7 and later compilers:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从移动构造函数中移除 `BOOST_NOEXCEPT`，对于 GCC-4.7 及以后的编译器，我们将得到以下错误：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BOOST_NOEXCEPT` macro expands to `noexcept` on compilers that support it.
    The STL containers use type traits to detect if the constructor throws an exception
    or not. Type traits make their decision mainly based on `noexcept` specifiers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持它的编译器上，`BOOST_NOEXCEPT` 宏展开为 `noexcept`。STL 容器使用类型特性来检测构造函数是否抛出异常。类型特性主要基于
    `noexcept` 说明符做出决定。
- en: Why do we get an error without `BOOST_NOEXCEPT`? GCC's type traits return the
    move constructor that `move_nothrow` throws, so `std::vector` will try to use
    the copy constructor of `move_nothrow`, which is not defined.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有 `BOOST_NOEXCEPT` 会出错？GCC 的类型特性返回 `move_nothrow` 抛出的移动构造函数，因此 `std::vector`
    将尝试使用 `move_nothrow` 的复制构造函数，而这个复制构造函数并未定义。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `BOOST_NOEXCEPT` macro also reduces binary size irrespective of whether
    the definition of the `noexcept` function or method is in a separate source file
    or not.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_NOEXCEPT` 宏无论 `noexcept` 函数或方法的定义是在单独的源文件中还是不在，都会减少二进制文件的大小。'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's because in the latter case, the compiler knows that the function will
    not throw exceptions and so there is no need to generate code that handles them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在后一种情况下，编译器知道该函数不会抛出异常，因此不需要生成处理它们的代码。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a function marked as `noexcept` does throw an exception, your program will
    terminate without calling destructors for the constructed objects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标记为 `noexcept` 的函数抛出异常，则程序将在不调用构造对象的析构函数的情况下终止。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料还有
- en: A document describing why move constructors are allowed to throw exceptions
    and how containers must move objects is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份描述为什么移动构造函数允许抛出异常以及容器如何移动对象的文档可在[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)找到。
- en: Read the official documentation of `Boost.Config` for more examples of `noexcept`
    macros existing in Boost, at [http://www.boost.org/doc/libs/1_53_0/libs/conf](http://www.boost.org/doc/libs/1_53_0/libs/conf)[ig/doc/html/index.html](http://ig/doc/html/index.html)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `Boost.Config` 的官方文档中提供了更多 `noexcept` 宏在 Boost 中的示例，请参阅[http://www.boost.org/doc/libs/1_53_0/libs/conf](http://www.boost.org/doc/libs/1_53_0/libs/conf)[ig/doc/html/index.html](http://ig/doc/html/index.html)。
- en: The portable way to export and import functions and classes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植地导出和导入函数和类的方法
- en: 'Almost all modern languages have the ability to make libraries, which is a
    collection of classes and methods that have a well-defined interface. C++ is no
    exception to this rule. We have two types of libraries: runtime (also called shared
    or dynamic load) and static. But writing libraries is not a trivial task in C++.
    Different platforms have different methods for describing which symbols must be
    exported from the shared library.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代语言都有创建库的能力，库是一组具有良好定义接口的类和方法。C++ 也不例外。我们有两种类型的库：运行时库（也称为共享或动态加载）和静态库。但在
    C++ 中编写库并不是一个简单任务。不同的平台有不同的方法来描述必须从共享库中导出的符号。
- en: Let's have a look at how to manage symbol visibility in a portable way using
    Boost.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Boost 以可移植的方式管理符号可见性。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Experience in creating dynamic and static libraries will be useful in this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，创建动态和静态库的经验将很有用。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The code for this recipe consists of two parts. The first part is the library
    itself. The second part is the code that uses that library. Both parts use the
    same header, in which the library methods are declared. Managing symbol visibility
    in a portable way using Boost is simple and can be done using the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的代码由两部分组成。第一部分是库本身。第二部分是使用该库的代码。这两部分都使用相同的头文件，在该头文件中声明了库方法。使用 Boost 以可移植的方式管理符号可见性简单且可以通过以下步骤完成：
- en: 'In the header file, we''ll need definitions from the following `include` header:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中，我们需要从以下 `include` 头文件中获取定义：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code must also be added to the header file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码也必须添加到头文件中：
- en: '[PRE28]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now all the declarations must use the `MY_LIBRARY_API` macro:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有声明都必须使用 `MY_LIBRARY_API` 宏：
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Exceptions must be declared with `BOOST_SYMBOL_VISIBLE`, otherwise they can
    be caught only using `catch(...)` in the code that will use the library:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常必须使用 `BOOST_SYMBOL_VISIBLE` 声明，否则只能在将使用库的代码中使用 `catch(...)` 来捕获：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Library source files must include the header file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库源文件必须包含头文件：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Definitions of methods must also be in the source files of the library:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法的定义也必须在库的源文件中：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can use the library as shown in the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像以下代码所示使用库：
- en: '[PRE33]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the work is done in step 2\. There we are defining the macro `MY_LIBRARY_API`,
    which will be applied to classes and methods that we wish to export from our library.
    In step 2, we check for `MY_LIBRARY_LINK_DYNAMIC`; if it is not defined, we are
    building a static library and there is no need to define `MY_LIBRARY_API`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都在第2步完成。在那里我们定义了宏`MY_LIBRARY_API`，它将被应用于我们希望从库中导出的类和方法。在第2步中，我们检查`MY_LIBRARY_LINK_DYNAMIC`是否已定义；如果没有定义，我们正在构建一个静态库，因此不需要定义`MY_LIBRARY_API`。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The developer must take care of `MY_LIBRARY_LINK_DYNAMIC`! It will not define
    itself. So we need to make our build system to define it, if we are making a dynamic
    library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须注意`MY_LIBRARY_LINK_DYNAMIC`！它不会自动定义。因此，如果我们正在构建动态库，我们需要让我们的构建系统来定义它。
- en: 'If `MY_LIBRARY_LINK_DYNAMIC` is defined, we are building a runtime library,
    and that''s where the workarounds start. You, as the developer, must tell the
    compiler that we are now exporting these methods to the user. The user must tell
    the compiler that he/she is importing methods from the library. To have a single
    header file for both library import and export, we use the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`MY_LIBRARY_LINK_DYNAMIC`，我们正在构建一个运行时库，这就是解决方案开始的地方。作为开发者，你必须告诉编译器我们现在正在将这些方法导出给用户。用户必须告诉编译器他/她正在从库中导入方法。为了有一个用于库导入和导出的单个头文件，我们使用以下代码：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When exporting the library (or, in other words, compiling it), we must define
    `MY_LIBRARY_COMPILATION`. This leads to `MY_LIBRARY_API` being defined to `BOOST_SYMBOL_EXPORT`.
    For example, see step 5, where we defined `MY_LIBRARY_COMPILATION` before including
    `my_library.hpp`. If `MY_LIBRARY_COMPILATION` is not defined, the header is included
    by the user, who doesn't know anything about that macro. And, if the header is
    included by the user, the symbols must be imported from the library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当导出库（或者说，换句话说，编译它）时，我们必须定义`MY_LIBRARY_COMPILATION`。这导致`MY_LIBRARY_API`被定义为`BOOST_SYMBOL_EXPORT`。例如，参见第5步，我们在包含`my_library.hpp`之前定义了`MY_LIBRARY_COMPILATION`。如果未定义`MY_LIBRARY_COMPILATION`，则由用户包含头文件，而用户对此宏一无所知。而且，如果头文件由用户包含，则必须从库中导入符号。
- en: The `BOOST_SYMBOL_VISIBLE` macro must be used only for those classes that are
    not exported and are used by RTTI. Examples of such classes are exceptions and
    classes being cast using `dynamic_cast`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 必须仅使用`BOOST_SYMBOL_VISIBLE`宏来处理那些未导出且用于RTTI的类。此类类的例子包括异常和被`dynamic_cast`转换的类。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some compilers export all the symbols by default but provide flags to disable
    such behavior. For example, GCC provides `-fvisibility=hidden`. It is highly recommended
    to use those flags because it leads to smaller binary size, faster loading of
    dynamic libraries, and better logical structuring of binary input. Some inter-procedural
    optimizations can perform better when fewer symbols are exported.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器默认导出所有符号，但提供标志来禁用此行为。例如，GCC提供`-fvisibility=hidden`标志。强烈建议使用这些标志，因为它会导致二进制文件大小减小，动态库加载更快，以及二进制输入的逻辑结构更好。当导出的符号较少时，一些过程间优化可以表现得更好。
- en: C++11 has generalized attributes that someday may be used to provide a portable
    way to work with visibilities, but until then we have to use macros from Boost.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C++11已经推广了属性，将来可能会被用来提供一种可移植的方式来处理可见性，但在此之前，我们必须使用Boost的宏。
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read this chapter from the beginning to get more examples of `Boost.Config`
    usage
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，以获取更多`Boost.Config`使用的示例
- en: Consider reading the official documentation of `Boost.Config` for the full list
    of the `Boost.Config` macro and their description at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.htm)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑阅读`Boost.Config`的官方文档，以获取`Boost.Config`宏及其描述的完整列表，请参阅[http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.htm)
- en: Detecting the Boost version and getting latest features
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Boost版本和获取最新功能
- en: Boost is being actively developed, so each release contains new features and
    libraries. Some people wish to have libraries that compile for different versions
    of Boost and also want to use some of the features of the new versions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Boost正在积极开发中，因此每个版本都包含新的特性和库。有些人希望有针对不同Boost版本的库，并且还想使用新版本的一些特性。
- en: Let's take a look at the `boost::lexical_cast` change log. According to it,
    Boost 1.53 has a `lexical_cast(const CharType* chars, std::size_t count)` function
    overload. Our task for this recipe will be to use that function overload for new
    versions of Boost, and work around that missing function overload for older versions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`boost::lexical_cast`的变更日志。根据它，Boost 1.53有一个`lexical_cast(const CharType*
    chars, std::size_t count)`函数重载。我们这个菜谱的任务将是使用该函数重载来处理Boost的新版本，并为旧版本处理缺失的函数重载。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and the `Boost.Lexical` library is required.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要具备基本的C++知识和`Boost.Lexical`库知识。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Well, all we need to do is get a version of Boost and use it to write optimal
    code. This can be done as shown in the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们所需做的只是获取一个Boost版本并使用它来编写最优代码。这可以通过以下步骤完成：
- en: 'We need to include headers containing the Boost version and `boost::lexical_cast`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含包含Boost版本和`boost::lexical_cast`的头文件：
- en: '[PRE35]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will use the new feature of `Boost.LexicalCast` if it is available:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可用，我们将使用`Boost.LexicalCast`的新特性：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Otherwise, we are required to copy data to `std::string` first:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们首先需要将数据复制到`std::string`中：
- en: '[PRE37]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can use the code as shown here:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码：
- en: '[PRE38]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `BOOST_VERSION` macro contains the Boost version written in the following
    format: a single number for the major version, followed by three numbers for the
    minor version, and then two numbers for the patch level. For example, Boost 1.46.1
    will contain the `104601` number in the `BOOST_VERSION` macro.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_VERSION`宏包含以以下格式编写的Boost版本：一个用于主版本的数字，后面跟着三个用于次版本的数字，然后是两个用于修补级别的数字。例如，Boost
    1.46.1将在`BOOST_VERSION`宏中包含`104601`这个数字。'
- en: So, we will check the Boost version in step 2 and choose the correct implementation
    of the `to_int` function according to the abilities of `Boost.LexicalCast`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第二步中，我们将检查Boost版本，并根据`Boost.LexicalCast`的能力选择正确的`to_int`函数实现。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Having a version macro is a common practice for big libraries. Some of the Boost
    libraries allow you to specify the version of the library to use; see `Boost.Thread`
    and its `BOOST_THREAD_VERSION` macro for an example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型库来说，拥有一个版本宏是一种常见做法。一些Boost库允许你指定要使用的库版本；例如，参见`Boost.Thread`及其`BOOST_THREAD_VERSION`宏。
- en: See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read the recipe *Creating an execution thread* in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, for more information about `BOOST_THREAD_VERSION` and how it
    affects the `Boost.Thread` library, or read the documentation at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`BOOST_THREAD_VERSION`及其如何影响`Boost.Thread`库的更多信息，请参阅[第5章](ch05.html "第5章。多线程")中的菜谱*创建执行线程*，或者阅读[http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html)上的文档。
- en: Read this chapter from the beginning or consider reading the official documentation
    of `Boost.Config` at [http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本章开始阅读，或者考虑阅读[http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html)上的官方`Boost.Config`文档。
