<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Best Practices</h1>
            

            <article>
                
<p class="calibre2">Learning to program is difficult for many reasons, but learning to program games is even more difficult, specifically because there are so many different systems and object types that need to interact with each other. Throughout this book, we have covered some of the most important design patterns to make those interactions as simple as possible. Each chapter focused explicitly on a design pattern to help make coding easier. However, buried within each paragraph and code sample are core ideas and techniques to help make our design easier to read and maintain.</p>
<p class="calibre2">These <em class="calibre12">Best Practices</em> can sometimes be found in other books; however, programming books often strive to teach you the grammar of a language, as opposed to style, design, and organization. Even books about design patterns may gloss over these fundamental techniques. Since they are so fundamental, it is easy to forget they are not necessarily explicitly discussed everywhere. That leaves you, the reader, forced to read dozens of books and scour the Internet for blog posts that talk about these fundamentals. Worse, you are required to spend hours and hours writing code with the feeling that it could be better, but you just don't understand why it isn't.</p>
<p class="calibre2">Of course, all those things will happen anyway. Part of being a programmer is constantly reading books like this. You should be looking for ways to improve by reading blogs and you will write code that you consider garbage after six months. This is all part of becoming better. It is our hope in writing this book that you can understand and incorporate these fundamentals into your programs sooner rather than later.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will be focusing on fundamental ideas and techniques that will improve your code and improve your game. These ideas come from years of programming as well as years of teaching. If these seem simple and obvious, that is great. However, we chose these topics because they are things that we, the authors, struggled with early on, or that our students struggled with.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            <article>
                
Over the course of this chapter we will be discussing a number of topics:<br class="title-page-name"/>
<ul class="calibre17">
<li class="calibre18">Learn fundamental code quality techniques</li>
<li class="calibre18">Learn and understand the uses of the const keyword</li>
<li class="calibre18">Learn how iteration can improve your game and code design</li>
<li class="calibre18">Learn when to use scripting in a game</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Learning fundamental code quality techniques</h1>
            

            <article>
                
<p class="calibre2">The process of moving from beginner to expert programmer can be challenging. In the beginning, you must learn not only the rules of the language, but also how to use a compiler and understand the error messages. Moreover, you are trying to solve increasingly difficult programming problems while following what might seem like arbitrary rules for writing <em class="calibre12">good</em> code. Most novice programmers are focused on solving a given problem, as opposed to making the code look nice. To many, it seems worthless to spend time making the code look clean, because it will almost certainly be deleted after writing it. Even more experienced programmers may ignore code style in the rush to complete an assignment or finish a project.</p>
<p class="calibre2">This is bad for a few reasons. First, well-written code is easier to read and understand. It almost certainly has fewer errors, and is more efficient than code that is carelessly mixed together and never polished. Just as we discussed in earlier chapters, the time you spend upfront making sure the code is bug free, is time you won't need to use debugging it later. The time you spend making sure the code is readable and easy to maintain is time you won't need to spend later making changes or deciphering old code.</p>
<p class="calibre2">Second, good programming style is a matter of habit. Taking time to read and debug your code is slow at first. However, the more you improve your code, the easier and quicker it becomes. Eventually, you will develop habits and writing quality code will happen naturally. Without this habit, it can be easy to push style aside and worry about it later. However, the code that is being written is almost always sloppy, and it can be hard to find the time later to go back and improve it, since there is always another deadline approaching. With good habits, you will be able to write clean, readable code in even the most time-constrained situations, such as an interview or a fast-approaching deadline.</p>
<p class="calibre2">Finally, at some point in the future you will almost certainly be working with other programmers. This could be a small team of two or three, or perhaps in a company with dozens of programmers all over the world. Even if you understand what your code is doing, it is not guaranteed that your teammates will. Writing code that is hard to understand will lead to people using your code incorrectly. Instead, strive to make your code easy to use and hard to break. Take pride in how much other people love to use your code, your teammates and boss will thank you. You will appreciate it if your teammates do the same thing. At some point, you will be required to maintain other programmers code after they have left the job. You will find it much easier to do if they wrote high quality code, so write code that will be easy to work with after you have left.</p>
<p class="calibre2">Over the next few pages, we will cover some very basic but extremely important code quality tips. As we said, these come from years of reading programming, as well as teaching. Use these techniques for every single line of code that you write. Think about these techniques for every piece of code that you read. Doing so will help you form great habits.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Avoid magic numbers</h1>
            

            <article>
                
<p class="calibre2">Hard coding number literals into code is generally considered a bad idea. The problem with using a number literal instead of a named constant is that the purpose of that number is unknown to the reader. The number appears in code as if by magic. Consider the following code:</p>
<pre class="calibre23">
M5Object* pUfo = M5ObjectManager::CreateObject(AT_Ufo); <br class="title-page-name"/>pUfo-&gt;pos.x    = M5Random::GetFloat(-100, 100); <br class="title-page-name"/>pUfo-&gt;pos.y    = M5Random::GetFloat(-60, 60); 
</pre>
<p class="calibre2">It is hard to know why those four numbers were chosen. It is also hard to know how the program will be changed if the values are modified. Code like this would be much more readable and maintainable if the named constants or variables were used:</p>
<pre class="calibre23">
M5Object* pUfo = M5ObjectManager::CreateObject(AT_Ufo); <br class="title-page-name"/>pUfo-&gt;pos.x    = M5Random::GetFloat(minWorldX, maxWorldX); <br class="title-page-name"/>pUfo-&gt;pos.y    = M5Random::GetFloat(minWorldY, MaxWorldY); 
</pre>
<p class="calibre2">After the change, it is much easier to understand that the position of the new UFO is being randomly placed within the world. We can understand that if we change the values, the possible starting location of the UFO would either be outside of the world, or constrained to a tighter rectangle around the center of the world.</p>
<p class="calibre2">Besides being hard to read and understand, using magic numbers makes the code hard to maintain and update. Let's say we have an array of size 256. Every loop that needs to manipulate the array must hardcode the value 256. If the array size needs to be larger or smaller, we would need to change every occurrence of 256. We can't simply do a <em class="calibre12">find and replace</em> because it is very possible that 256 is used elsewhere in the code for a completely different reason. Instead we must look through every occurrence of the number and make sure that we are changing the code correctly. If we miss even one, we could create a bug. For example, if we are changing the size of the array to something smaller, such as 128. Any loops that still treat the array as if it had size 256 will cause undefined behavior:</p>
<pre class="calibre23">
int buffer[256]; <br class="title-page-name"/> <br class="title-page-name"/>//Some function to give start values <br class="title-page-name"/>InitializeBuffer(buffer, 256);  <br class="title-page-name"/> <br class="title-page-name"/>for(int i = 0; i &lt; 256; ++i) <br class="title-page-name"/>std::cout &lt;&lt; i " " &lt;&lt; std::endl; 
</pre>
<p class="calibre2">As before, it is better to use a named constant instead of a magic number. The constant is more readable and easy to change because it only needs to be changed in one place. It is also less likely to cause bugs because we are only changing the values associated with the array. We won't accidentally change a value we shouldn't or miss a value that we should change:</p>
<pre class="calibre23">
const int BUFFER_SIZE = 256;  <br class="title-page-name"/>int buffer[BUFFER_SIZE]; <br class="title-page-name"/> <br class="title-page-name"/>//Some function to give start values <br class="title-page-name"/>InitializeBuffer(buffer, BUFFER_SIZE);  <br class="title-page-name"/> <br class="title-page-name"/>for(int i = 0; i &lt; BUFFER_SIZE; ++i) <br class="title-page-name"/>std::cout &lt;&lt; i " " &lt;&lt; std::endl; 
</pre>
<p class="calibre2">Another important reason we don't want to use magic numbers is that they are inflexible. Throughout this book, we try to emphasize the benefits of reading data from a file. Obviously, if you hardcode a value, it can't be read from a file. In the preceding example, if <kbd class="calibre14">BUFFER_SIZE</kbd> ever needs to be changed, the code needs to be recompiled. However, if the size of the buffer is read from a file at runtime, the code only needs to be compiled one time and the program will work for buffers of all sizes:</p>
<pre class="calibre23">
int bufferSize = GetSizeFromFile(fileName);  <br class="title-page-name"/> <br class="title-page-name"/>//we can Dynamically allocate our buffer <br class="title-page-name"/>int* buffer = new int[bufferSize]; <br class="title-page-name"/> <br class="title-page-name"/>//Some function to give start values <br class="title-page-name"/>InitializeBuffer(buffer, bufferSize);  <br class="title-page-name"/> <br class="title-page-name"/>for(int i = 0; i &lt; bufferSize; ++i) <br class="title-page-name"/>std::cout &lt;&lt; i " " &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/>delete [] buffer;//We must remember to deallocate 
</pre>
<p class="calibre2">In the preceding example, we must remember to deallocate the buffer. Remember, that probably won't be the usual case because for arrays, we could always use an STL vector. The more general case is that we are reading ints or floats from a file. These could be used for anything from screen resolution, to player speed, or even the time interval between spawning enemies.</p>
<p class="calibre2">As with all rules, there are a few exceptions or special cases where it might be fine to hardcode numbers. The numbers <kbd class="calibre14">0</kbd> and <kbd class="calibre14">1</kbd> are generally consider OK. These might be used as the initialization values for ints or floats, or just the starting index for an array.</p>
<p class="calibre2">Your goal is to make your code as readable and flexible as possible, so a named constant is almost always going to be better than a hardcoded number. Do your best to make sure that your code can be understood by others. Your code isn't more readable if you simply have a variable named <kbd class="calibre14">ZERO</kbd> or <kbd class="calibre14">TWO</kbd>, so you should use your best judgment and perhaps ask another programmer if you think the meaning is unclear.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">White space</h1>
            

            <article>
                
<p class="calibre2">When thinking about high quality code, white space is often forgotten. Maybe this is because white space isn't code you write, but is instead the empty space between your code. However, if you don't use white space correctly, your code will be unreadable. When we say white space, we are talking about the spaces, tabs, newlines, and blank lines within your program. How you use these can make the difference between code that is easy to read and maintain, and code that will give you nightmares. Here is a piece of code with very little thought about white space:</p>
<pre class="calibre23">
RECT rect={0}; <br class="title-page-name"/>int xStart= 0,yStart = 0; <br class="title-page-name"/>rect.right=s_width;rect.bottom=s_height; <br class="title-page-name"/>s_isFullScreen = fullScreen; <br class="title-page-name"/>if (fullScreen) {DEVMODE settings;  <br class="title-page-name"/>settings.dmSize = sizeof(settings); <br class="title-page-name"/>EnumDisplaySettings(0, ENUM_CURRENT_SETTINGS, &amp;settings); <br class="title-page-name"/>settings.dmPelsWidth=(DWORD)s_width;  <br class="title-page-name"/>settings.dmPelsHeight = (DWORD)s_height; <br class="title-page-name"/>settings.dmFields = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT; <br class="title-page-name"/>s_style = FULLSCREEN_STYLE; <br class="title-page-name"/>if (ChangeDisplaySettings(&amp;settings <br class="title-page-name"/>,CDS_FULLSCREEN) !=DISP_CHANGE_SUCCESSFUL) { <br class="title-page-name"/>s_isFullScreen = false;s_style = WINDOWED_STYLE; <br class="title-page-name"/>ChangeDisplaySettings(0, 0);M5Debug::MessagePopup( <br class="title-page-name"/>"FullScreen is not supported. " <br class="title-page-name"/>"You are being switched to Windowed Mode"); }  <br class="title-page-name"/>} <br class="title-page-name"/> else {ChangeDisplaySettings(0, 0); s_style = WINDOWED_STYLE;} 
</pre>
<p class="calibre2">The preceding code is perfectly acceptable to the compiler. For humans, however, the code above is hard to read because there is no line spacing, no indentation, and no consistency. Of course, this is an extreme example, but throughout our years of teaching, we have seen examples of code with just as little thought to style and formatting. When code looks like the example above, the quality of comments and identifier names doesn't matter because the entire block is difficult to read. Compare the preceding code with the following version, which has tried to code for human readability:</p>
<pre class="calibre23">
/*Set window rect size and start position*/ <br class="title-page-name"/>RECT rect   = { 0 }; <br class="title-page-name"/>rect.right  = s_width; <br class="title-page-name"/>rect.bottom = s_height; <br class="title-page-name"/>int xStart  = 0; <br class="title-page-name"/>int yStart  = 0; <br class="title-page-name"/> <br class="title-page-name"/>/*save input parameter to static var*/ <br class="title-page-name"/>s_isFullScreen = fullScreen; <br class="title-page-name"/> <br class="title-page-name"/>/*Check if we are going into full screen or not*/ <br class="title-page-name"/>if (fullScreen) <br class="title-page-name"/>{ <br class="title-page-name"/>  /*Get the current display settings*/ <br class="title-page-name"/>  DEVMODE settings; <br class="title-page-name"/>  settings.dmSize = sizeof(settings); <br class="title-page-name"/>  EnumDisplaySettings(0, ENUM_CURRENT_SETTINGS, &amp;settings); <br class="title-page-name"/> <br class="title-page-name"/>  /*Change the resolution to the resolution of my window*/ <br class="title-page-name"/>  settings.dmPelsWidth  = static_cast&lt;DWORD&gt;(s_width); <br class="title-page-name"/>  settings.dmPelsHeight = static_cast&lt;DWORD&gt;(s_height); <br class="title-page-name"/>  settings.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH  |  <br class="title-page-name"/>                          DM_PELSHEIGHT; <br class="title-page-name"/> <br class="title-page-name"/>  /*Make sure my window style is full screen*/ <br class="title-page-name"/>  s_style = FULLSCREEN_STYLE; <br class="title-page-name"/> <br class="title-page-name"/>  /*If we can't change, switch back to desktop mode*/ <br class="title-page-name"/>  if ( ChangeDisplaySettings(&amp;settings, CDS_FULLSCREEN) !=  <br class="title-page-name"/>                                  DISP_CHANGE_SUCCESSFUL ) <br class="title-page-name"/>  { <br class="title-page-name"/>    s_isFullScreen = false; <br class="title-page-name"/>    s_style        = WINDOWED_STYLE; <br class="title-page-name"/>    ChangeDisplaySettings(0, 0); <br class="title-page-name"/>    M5Debug::MessagePopup("FullScreen is not supported. " <br class="title-page-name"/>    "You are being switched to Windowed Mode"); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>else /*If we are already fullscreen, switch to desktop*/ <br class="title-page-name"/>{ <br class="title-page-name"/>  /*Make sure I am in windows style*/ <br class="title-page-name"/>  s_style = WINDOWED_STYLE; <br class="title-page-name"/>  ChangeDisplaySettings(0, 0); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">While the preceding example is by no means the perfect example of high quality code, it is certainly more readable and maintainable than the first example. When it comes to real-world programs and programmers, there is no such thing as perfect. Every programmer has their own style, which really means that every programmer believes their style is the easiest to read. However, as you read more code, you will notice that there are certain common elements to code that is readable. Let's look at some of those elements now.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Indentation</h1>
            

            <article>
                
<p class="calibre2">Block statements such as loops and conditionals should have the sub statements indented. This easily shows the program intent to the reader. The number of spaces to indent is less important than the indentation itself. Most programmers agree that 2 to 4 spaces are sufficient for readability. The most important thing is to be consistent with your spacing. Likewise, the placement of the starting curly brace isn't important, (although you can find some interesting arguments online), but it is important to consistently place it in the same location:</p>
<pre class="calibre23">
//This shows the purpose of the statement <br class="title-page-name"/>if (s_isFullScreen) <br class="title-page-name"/>{ <br class="title-page-name"/>  s_style = FULLSCREEN_STYLE; <br class="title-page-name"/>  SetFullScreen(true); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>//So does this <br class="title-page-name"/>if (s_isFullScreen) { <br class="title-page-name"/>  s_style = FULLSCREEN_STYLE; <br class="title-page-name"/>  SetFullScreen(true); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/> <br class="title-page-name"/>//This does not shows the intent of the statement <br class="title-page-name"/>if (s_isFullScreen) <br class="title-page-name"/>{ <br class="title-page-name"/>s_style = FULLSCREEN_STYLE; <br class="title-page-name"/>SetFullScreen(true); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">It is important to remember that in C++, indentation has no meaning to the compiler. Without the curly braces, loops and conditionals will execute only one statement. For this reason, some programmers will always use the curly braces, regardless of how many sub statements are needed:</p>
<pre class="calibre23">
/*Single statement in the loop*/ <br class="title-page-name"/>while (i++ &lt; 10) <br class="title-page-name"/>  printf("The value of i is %d\n", i); <br class="title-page-name"/> <br class="title-page-name"/>   <br class="title-page-name"/>/*After adding another statement*/ <br class="title-page-name"/>while (i++ &lt; 10) <br class="title-page-name"/>  printf("The value of i is %d\n", i); <br class="title-page-name"/>  printf("i squared is %d\n", i*i); 
</pre>
<p class="calibre2">The preceding example is misleading, because only the first statement will be part of the loop. It can be a common mistake when writing a loop or conditional to forget to add curly braces after adding a second statement. For this reason, some programmers will use curly braces even for single statement loops and conditionals. The idea is that the code is more readable and easier to maintain, and so it is less prone to error.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Blank lines and spaces</h1>
            

            <article>
                
<p class="calibre2">As we said before, how you use white space will determine how readable your code is. Using indentation for code blocks is one way to show the logical structure of a program. Another good way to show this is by using blank lines. Just as a good piece of writing is separated into paragraphs, a good piece of code should be separated into some form of logical grouping. Group statements together that logically go together. Put blank lines between the groups to improve the readability:</p>
<pre class="calibre23">
//Save position and scale to variables for readability. <br class="title-page-name"/>const float HALF = .5f; <br class="title-page-name"/>M5Vec2 halfScale = m_pObj-&gt;scale * HALF; <br class="title-page-name"/>M5Vec2 pos = m_pObj-&gt;pos; <br class="title-page-name"/>//Get world extents <br class="title-page-name"/>M5Vec2 botLeft; <br class="title-page-name"/>M5Vec2 topRight; <br class="title-page-name"/>M5Gfx::GetWorldBotLeft(botLeft); <br class="title-page-name"/>M5Gfx::GetWorldTopRight(topRight); <br class="title-page-name"/>//If object is outside of world, mark as dead <br class="title-page-name"/>if (pos.x - halfScale.x &gt; topRight.x || pos.x + <br class="title-page-name"/>    halfScale.x &lt; botLeft.x || pos.y - halfScale.y  <br class="title-page-name"/>    &gt; topRight.y || pos.y + halfScale.y &lt; botLeft.y) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_pObj-&gt;isDead = true; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The preceding code has no blank lines so the code seems to run together. It is hard to look at it and understand what the code is doing because your brain tries to understand all of it at once. Even though there are comments, they don't really help because they blend in to the rest of the code. The if statement is also hard to read because the conditions are separated by how they fit on the line instead of a logical alignment. In the following code, we have added some blank lines to separate the logic grouping of the statements:</p>
<pre class="calibre23">
//Save position and scale to variables for readability. <br class="title-page-name"/>const float HALF = .5f; <br class="title-page-name"/>M5Vec2 halfScale = m_pObj-&gt;scale * HALF; <br class="title-page-name"/>M5Vec2 pos       = m_pObj-&gt;pos; <br class="title-page-name"/> <br class="title-page-name"/>//Get world extents <br class="title-page-name"/>M5Vec2 botLeft; <br class="title-page-name"/>M5Vec2 topRight; <br class="title-page-name"/>M5Gfx::GetWorldBotLeft(botLeft); <br class="title-page-name"/>M5Gfx::GetWorldTopRight(topRight); <br class="title-page-name"/>   <br class="title-page-name"/>//If object is outside of world, mark as dead <br class="title-page-name"/>if ( pos.x - halfScale.x &gt; topRight.x ||  <br class="title-page-name"/>     pos.x + halfScale.x &lt; botLeft.x  || <br class="title-page-name"/>     pos.y - halfScale.y &gt; topRight.y ||  <br class="title-page-name"/>     pos.y + halfScale.y &lt; botLeft.y  ) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_pObj-&gt;isDead = true; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">By using line breaks to group related statements together, the code is separated into easy to understand chunks. These chunks help the reader understand which statements should logically go together. In addition, the comment at the beginning of each chunk sticks out much more and explains in English exactly what will happen will contained in the chunk.</p>
<p class="calibre2">Complicated conditional statements should be separated and aligned based on the conditions so they are easier to understand. In the preceding code, each of the four conditions are aligned in the same way. This gives a clue to the reader as to how the condition will be executed. Using parentheses along with aligning the code further adds to the readability:</p>
<pre class="calibre23">
//If object is outside of world, mark as dead <br class="title-page-name"/>if (( (pos.x - halfScale.x) &gt; topRight.x ) ||  <br class="title-page-name"/>    ( (pos.x + halfScale.x) &lt; botLeft.x  ) || <br class="title-page-name"/>    ( (pos.y - halfScale.y) &gt; topRight.y ) ||  <br class="title-page-name"/>    ( (pos.y + halfScale.y) &lt; botLeft.y  )) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_pObj-&gt;isDead = true; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Using parentheses isn't just helpful in conditionals. All complicated expressions should be grouped together with parentheses. Of course, everyone's definition of complicated differs, so a good general rule is <kbd class="calibre14">*</kbd>, <kbd class="calibre14">/</kbd>, and <kbd class="calibre14">%</kbd> are executed before <kbd class="calibre14">+</kbd> and <kbd class="calibre14">-</kbd>; use parentheses for everything else. In addition to being clearer to the reader, this will ensure that the code is executing exactly as you expect. Even if you understand all the C++ rules of precedence and associativity, your teammates may not. Parentheses don't cost anything but can improve the readability, so feel free to use them as much as possible to show the intent of the code.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Comments and self-documenting code</h1>
            

            <article>
                
<p class="calibre2">Comments and documentation seem to be more controversial than they should be. On the one hand, many people think comments and documentation are a waste of time. Writing documentation literally takes time away from writing code, and reading comments takes time away from reading the code. In addition, some people think that comments just don't help because they can become out of date, and don't explain anything that isn't already in the source code. The worst situation with comments is when they are flat out wrong. In that case, the code would be better off without the comments at all.</p>
<p class="calibre2">However, there are few things more frustrating than debugging code written by someone that didn't add comments. Even debugging your own code just a few months after you have written it can be difficult. In the end, the time spent writing and updating comments is time that you and your teammates won't need to spend deciphering code.</p>
<p class="calibre2">While the use of comments may be controversial, writing clean, high-quality code is important to everyone. As we have already seen earlier, using white space well can improve readability. However, white space alone doesn't make code readable. We really want our code to be self-documenting. Here is an example of that, which is difficult to read, even though it has proper white space:</p>
<pre class="calibre23">
void DoStuff(bool x[], int y) <br class="title-page-name"/>{   <br class="title-page-name"/>  for(int i = 0; i &lt; y; ++i) <br class="title-page-name"/>    x[i] = true; <br class="title-page-name"/>     <br class="title-page-name"/>  x[0] = x[1] = false; <br class="title-page-name"/> <br class="title-page-name"/>  int b = static_cast&lt;int&gt;(std::sqrt(y)); <br class="title-page-name"/> <br class="title-page-name"/>  for(int a = 2; a &lt;= b; ++a) <br class="title-page-name"/>  { <br class="title-page-name"/>    if(x[a] == false) <br class="title-page-name"/>      continue; <br class="title-page-name"/> <br class="title-page-name"/>    for(int c = a * 2; c &lt; y; c += a) <br class="title-page-name"/>      x[c] = false; <br class="title-page-name"/>  } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Can you tell what the algorithm is doing? Unless you happen to know this algorithm already, chances are that you may not understand the intent of the function. Comments would help here, but the bigger problem is the low quality of the identifiers. Good variable names provide a hint as to what they will be used for. The idea is that, with good variable names, you should be able to understand the code without the need for comments. This is how you make your code self-documenting:</p>
<pre class="calibre23">
void CalculateSievePrimes(bool primes[], int arraySize) <br class="title-page-name"/>{     <br class="title-page-name"/>  for(int i = 0; i &lt; arraySize; ++i) <br class="title-page-name"/>    primes[i] = true; <br class="title-page-name"/>     <br class="title-page-name"/>  primes[0] = primes[1] = false; <br class="title-page-name"/>   <br class="title-page-name"/>  int upperBound = static_cast&lt;int&gt;(std::sqrt(arraySize)); <br class="title-page-name"/> <br class="title-page-name"/>  for(int candidate = 2; candidate &lt;= upperBound; ++candidate) <br class="title-page-name"/>  { <br class="title-page-name"/>    if(primes[candidate] == false) <br class="title-page-name"/>      continue; <br class="title-page-name"/>       <br class="title-page-name"/>    int multiple = candidate * 2; <br class="title-page-name"/>    for(; multiple &lt; arraySize; multiple += candidate) <br class="title-page-name"/>      primes[multiple] = false; <br class="title-page-name"/>  } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Even if you don't understand every single line of the preceding code example, you can at least use the function name as a guide. The name <kbd class="calibre14">CalculateSievePrimes</kbd> is a big clue as to what the function is doing. From there you should be able to piece together what each line is doing. Names such as candidate, <kbd class="calibre14">arraySize</kbd>, and multiple are much more meaningful than <kbd class="calibre14">a</kbd>, <kbd class="calibre14">b</kbd>, and <kbd class="calibre14">c</kbd>. The best part about self-documenting code is that it can never be wrong, and never become out of date. Of course, the code can still contain bugs. It just can't be out of sync with the documentation, because the code is the documentation.</p>
<p class="calibre2">There are a few things that you can do to attempt to make the code self-documenting, as we said before. Good variable names are a start. The variable name should explain the exact purpose of the variable and they should only be used for that purpose. For Boolean variables, give a name that makes it obvious what true means. A name such as <kbd class="calibre14">isActive</kbd> is much better than simply <kbd class="calibre14">active</kbd> or <kbd class="calibre14">activeFlag</kbd> because the names gives a hint as to what true means for that variable.</p>
<p class="calibre2">Often there will be naming conventions that distinguish between types, local variables, constants, and static or global variables. Some of these naming conventions, such as using all capital letters for <kbd class="calibre14">const</kbd> variables, are very common and used by most programmers. Other naming conventions, such as beginning all static variable names with an <kbd class="calibre14">s_</kbd>, or adding a <kbd class="calibre14">p</kbd> at the beginning of pointers, are less common. Whether you think these styles look ugly or not, understand that they are there to help readability and make wrong code look wrong. The compiler will already catch some of the problems that these naming conventions aim to solve, but since they can still help readability they are worth considering.</p>
<p class="calibre2">When giving names to methods and functions, similar rules apply. Give a clear name that explains the purpose of the function. Make sure the function or method only has one purpose. Typically, the name should be an action. <kbd class="calibre14">CalculateSievePrimes</kbd> is a much clearer name than <kbd class="calibre14">SeivePrimes</kbd> or even just <kbd class="calibre14">Calculate</kbd>. As with Boolean variables, methods or functions that return Boolean values are often named with a hint. The name <kbd class="calibre14">IsEmpty</kbd> or <kbd class="calibre14">IsPowerOfTwo</kbd> are much more clear than <kbd class="calibre14">Empty</kbd> or <kbd class="calibre14">PowerOfTwo</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Commenting</h1>
            

            <article>
                
<p class="calibre2">If the code is self-documenting, then why do we need to add comments at all? This is certainly the feeling of some programmers. When the comments aren't doing more than simply repeating the code, or when comments are out of date and difficult to update, then it is easy to understand why they feel that way. However, this is the opposite of what good comments should be.</p>
<p class="calibre2">Good comments should explain things that the code cannot. For example, copyright information, or author and contact information are things that can't be represented in code, but may be of use to the reader. Additionally, good comments do not simply repeat the code. The comment below is completely worthless. It adds nothing to the code:</p>
<pre class="calibre23">
//Assign START_VALUE to x <br class="title-page-name"/>int x = START_VALUE; 
</pre>
<p class="calibre2">Instead, good comments should explain the intent and purpose of the code. Even if you understand what a block of code is supposed to do, you can't know what the author was thinking when they wrote it. Knowing what the author was trying to accomplish can save you a lot of time when debugging someone else's code:</p>
<pre class="calibre23">
/****************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Given an array of "arraySize" mark all indices that are prime as true. <br class="title-page-name"/> <br class="title-page-name"/>\param [out] primes  <br class="title-page-name"/>The array to modify and Output. <br class="title-page-name"/> <br class="title-page-name"/>\param [in] arraySize  <br class="title-page-name"/>  The number of elements in the array <br class="title-page-name"/> <br class="title-page-name"/>\return  <br class="title-page-name"/>  None. Indices that are prime will be marked as true <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/****************************************************************/ <br class="title-page-name"/>void CalculateSievePrimes(bool primes[], int arraySize) <br class="title-page-name"/>{  <br class="title-page-name"/>  /*Ensure array is properly initialized */    <br class="title-page-name"/>  for(int i = 0; i &lt;size; ++i) <br class="title-page-name"/>    primes[i] = true; <br class="title-page-name"/>    <br class="title-page-name"/>  /*Zero and One are never prime*/  <br class="title-page-name"/>  primes[0] = primes[1] = false; <br class="title-page-name"/>   <br class="title-page-name"/>/*Check values up to the square root of the max value*/ <br class="title-page-name"/>  int upperBound = static_cast&lt;int&gt;(std::sqrt(arraySize)); <br class="title-page-name"/> <br class="title-page-name"/>  /*Check each value, if valid, mark all multiples as false*/ <br class="title-page-name"/>  for(int candidate = 2; candidate &lt;= upperBound; ++candidate) <br class="title-page-name"/>  { <br class="title-page-name"/>    if(primes[candidate] == false) <br class="title-page-name"/>      continue; <br class="title-page-name"/>       <br class="title-page-name"/>    int multiple = candidate * 2; <br class="title-page-name"/>    for(; multiple &lt; arraySize; multiple += candidate) <br class="title-page-name"/>      primes[multiple] = false; <br class="title-page-name"/>  } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The comments above explain what the author was thinking while writing the code. They do not just repeat what the code is doing. Notice that some comments explain a single line, while other comments summarize entire code blocks. There aren't any hard rules about how many comments should be in your code. A rough suggestion is that every code block should have a comment explaining its purpose, with additional comments for more complex lines.</p>
<p class="calibre2">The comment blocks such as the one at the top of the method are the least likely to be used but they can serve an important purpose as well. Just as the section headers of this book help when you are scanning for something specific, function headers can help you when scanning a source code file looking for a specific function.</p>
<p class="calibre2">Functions headers can be very helpful because they summarize everything about the function without the need to look at the code. Anyone can easily understand the purpose of the parameters, return values, and even any exceptions that may be thrown. The best part is, by using a tool such as Doxygen, the header blocks can be extracted to make external documentation.</p>
<div class="packt_infobox">Check out the Doxygen tool and documentation at <a href="http://www.stack.nl/~dimitri/doxygen/" target="_blank" class="calibre24"><span class="urlpackt">http://www.stack.nl/~dimitri/doxygen/</span></a>.</div>
<p class="calibre2">Of course, these are the most difficult to write and maintain. It is comment blocks like these that often become out of date or are flat out wrong. It is up to you and your team if you want to use them. It takes discipline to keep up with them, but they can be worth it if you happen to be working on another programmer's code after they have left the team.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Learning and understand the uses of the const keyword</h1>
            

            <article>
                
<p class="calibre2">Using <kbd class="calibre14">const</kbd> is another area of programming that seems to be a little controversial. Some programmers argue that they have never had a bug where using <kbd class="calibre14">const</kbd> would have helped. Others feel that, since you can't guarantee that a <kbd class="calibre14">const</kbd> object won't be modified, it is completely worthless. The fact is that <kbd class="calibre14">const</kbd> objects can be modified. <kbd class="calibre14">const</kbd> is not magic. So, is <kbd class="calibre14">const</kbd> correctness still a good thing? Before we get into that, let's have a look at what <kbd class="calibre14">const</kbd> is.</p>
<p class="calibre2">When you create a <kbd class="calibre14">const</kbd> variable, you must initialize it. All <kbd class="calibre14">const</kbd> variables will be checked at compile time to make sure that the variable is never assigned a new value. Since it happens at compile time, it doesn't have an influence on the performance. These are a few benefits that we should consider. First, it improves readability. By marking a variable as <kbd class="calibre14">const</kbd>, you are letting the reader know that this variable is not supposed to change. You are sharing your intent about the variable and making your code self-documenting. <kbd class="calibre14">const</kbd> variables are also usually named in all capital letters, which further helps with readability. Second, since the variable is checked at compile time, there is no way for the user to accidently change the value. If someone tries to modify the variable, it will cause a compiler error. This is great for you if you were expecting the value to stay the same. This is great for the user if the modification was truly an accident.</p>
<p class="calibre2">Compiler errors should always be preferred over runtime. Anytime we can use the compiler to help us find problems, we should. This is the same reason that many programmers choose to set their compiler warnings to maximum and treat those warnings as errors. Time spent fixing a known compiler issue is time you won't have to spend finding the runtime error that it might cause.</p>
<p class="calibre2">Additionally, <kbd class="calibre14">const</kbd> variables should be preferred over C style <kbd class="calibre14">#define</kbd> macros. Macros are a blunt tool. Sometimes they may be the only tool for the job, but they are overkill for simple symbolic constants. Macros do a blind <em class="calibre12">find and replace</em>. Anywhere the symbolic constant is in the source code, the value will replace it. While these situations may be rare, they can also be frustrating. Since the values are replaced in the pre-processing phase, the source code is unchanged when you go to fix the problem.</p>
<p class="calibre2">The <kbd class="calibre14">const</kbd> variables, on the other hand, are part of the language. They follow all the normal language rules for types and operators. There is nothing mysterious happening. They are just variables that can't be reassigned:</p>
<pre class="calibre23">
int i1;            //No initialization, OK <br class="title-page-name"/>int i2    = 0;     //Initialization, OK <br class="title-page-name"/> <br class="title-page-name"/>const int ci1;     //ERROR: No initialization <br class="title-page-name"/>const int ci2 = 0; //Initialization, OK <br class="title-page-name"/> <br class="title-page-name"/>i1 = 10;           //Assignment, OK <br class="title-page-name"/>i2 += 2;           //Assignment, OK <br class="title-page-name"/> <br class="title-page-name"/>ci1 = 10;          //ERROR: Can't Assign <br class="title-page-name"/>ci2 += 2;          //ERROR: Can't Assign 
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Const function parameters</h1>
            

            <article>
                
<p class="calibre2">Creating <kbd class="calibre14">const</kbd> variables as symbolic constants makes code more readable because we are avoiding magic numbers. However, <kbd class="calibre14">const</kbd> correctness is more than just creating symbolic constants. It is important to understand <kbd class="calibre14">const</kbd> in relation to function parameters.</p>
<p class="calibre2">It is important to understand the difference between these different function signatures:</p>
<pre class="calibre23">
void Foo(int* a);      //Pass by pointer <br class="title-page-name"/>void Foo(int&amp; a);      //Pass by reference <br class="title-page-name"/>void Foo(int a);       //Pass by value <br class="title-page-name"/>void Foo(const int a); //Pass by const value <br class="title-page-name"/>void Foo(const int* a);//Pass by pointer to const <br class="title-page-name"/>void Foo(const int&amp; a);//Pass by reference to const 
</pre>
<p class="calibre2">The default behavior of C and C++ is to pass by value. This means that, when you pass a variable to a function, a copy is made. Changes made to function parameters do not modify the original variable. The function author has freedom to use the variable however they want, while the original variable owner can be sure that the values will remain unchanged.</p>
<p class="calibre2">That means, as far as the original variable owner is concerned, these two function signatures behave the same. In fact, the compiler doesn't make a distinction between these two when considering function overloading:</p>
<pre class="calibre23">
void Foo(int a);       //Pass by value <br class="title-page-name"/>void Foo(const int a); //Pass by const value 
</pre>
<p class="calibre2">Since it is impossible for a pass by value variable to be modified when it gets passed to a function, many programmers do not mark these parameters as <kbd class="calibre14">const</kbd>. It can still be a good idea to mark them as <kbd class="calibre14">const</kbd>, because it signifies to the reader that the variable value shouldn't be changed. However, this type of parameter is less important to mark as <kbd class="calibre14">const</kbd> since it can't be changed.</p>
<p class="calibre2">What about when you want to pass an array to a function? Remember that one of the little quirks of C and C++ is the fact that arrays and pointers are sometimes treated similarly. When you pass an array to a function, a copy of the array is not made. Instead, a pointer to the first element is passed. One side effect of this default behavior is that the function can now modify the original data:</p>
<pre class="calibre23">
//A Poorly named function that unexpectedly modifies data <br class="title-page-name"/>void PrintArray(int buffer[], int size) <br class="title-page-name"/>{ <br class="title-page-name"/>  for(int i = 0; i &lt; size; ++i) <br class="title-page-name"/>  { <br class="title-page-name"/>    buffer[i] = 0; //Whoops!!! <br class="title-page-name"/>    std::cout &lt;&lt; buffer[i] &lt;&lt; " "; <br class="title-page-name"/>  } <br class="title-page-name"/>  std::cout &lt;&lt; std::endl; <br class="title-page-name"/>} <br class="title-page-name"/>//Example of creating an array and passing it to the function <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  const int SIZE  = 5; <br class="title-page-name"/>  int array[SIZE] = {1, 2, 3, 4, 5}; <br class="title-page-name"/> <br class="title-page-name"/>  PrintArray(array, SIZE); <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The output for the preceding code is as follows:</p>
<pre class="calibre23">
0 0 0 0 0  
</pre>
<p class="calibre2">As you can see, there is nothing preventing the function from modifying the original data. The <kbd class="calibre14">size</kbd> variable in the function is a copy of <kbd class="calibre14">SIZE</kbd> in main. However, the <kbd class="calibre14">buffer</kbd> variable is a pointer to array. The <kbd class="calibre14">PrintArray</kbd> function is short, so finding this bug might be easy, but in a longer function that may pass the pointer to additional functions, this problem can be difficult to track down.</p>
<p class="calibre2">If the user wanted to prevent the function from modifying the data, they could mark array as const. However, they won't be able to use the <kbd class="calibre14">PrintArray</kbd> function, and they won't be able to modify the data either:</p>
<pre class="calibre23">
int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  const int SIZE  = 5; <br class="title-page-name"/>  const int array[SIZE] = {1, 2, 3, 4, 5};//Marked as const <br class="title-page-name"/> <br class="title-page-name"/>  array[0] = 0;//ERROR: Can't modify a const array <br class="title-page-name"/> <br class="title-page-name"/>  PrintArray(array, SIZE);//Error: Function doesn't accept const <br class="title-page-name"/>return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Of course, sometimes the purpose of the function is to modify data. In that case, the user would just have to accept that if they wanted to use the function. With a name like <kbd class="calibre14">PrintArray</kbd>, the user probably expects that the data will be unchanged after the function call. Is the data modification on purpose or an accident? The user has no way of knowing.</p>
<p class="calibre2">Since the problem is with the poor function name, it is up to the function author to make the change. They can choose to make the name clearer, perhaps something such as <kbd class="calibre14">ClearAndPrintArray</kbd>, or fix the error. Of course, fixing the error doesn't prevent something like this from happening again, and it doesn't clarify the intent of the function.</p>
<p class="calibre2">A better idea would be for the author to mark buffer as a const parameter. This will allow the compiler to catch any accidents like the one above, and it will signal to the user that the function promises not to modify the data:</p>
<pre class="calibre23">
//Const prevents the function from modifying the data <br class="title-page-name"/>void PrintArray(const int buffer[], int size) <br class="title-page-name"/>{ <br class="title-page-name"/>for(int i = 0; i &lt; size; ++i) <br class="title-page-name"/>{ <br class="title-page-name"/>  //buffer[i] = 0; //This would be a compiler error <br class="title-page-name"/>  std::cout &lt;&lt; buffer[i] &lt;&lt; " "; <br class="title-page-name"/>  } <br class="title-page-name"/>std::cout &lt;&lt; std::endl; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  const int SIZE  = 5; <br class="title-page-name"/>  int array[SIZE] = {1, 2, 3, 4, 5}; <br class="title-page-name"/> <br class="title-page-name"/>  array[0] = 0;//Modifying the array is fine <br class="title-page-name"/> <br class="title-page-name"/>  PrintArray(array, SIZE);//OK. Can accept non-const <br class="title-page-name"/>return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As we said before, the <kbd class="calibre14">size</kbd> variable could also be marked as const. This would more clearly demonstrate that the variable shouldn't change, but it isn't necessary because it is a copy. Any modification of size will not change the value of <kbd class="calibre14">SIZE</kbd> in main. For this reason, many programmers, even the ones that strive for const correctness, do not mark <em class="calibre12">pass by value</em> parameters as const.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Const classes as parameters</h1>
            

            <article>
                
<p class="calibre2">We have now discussed the default behavior when passing arrays to functions. The compiler will automatically pass in a pointer to the first element of the array. This is good for both speed and flexibility. Since only a pointer is passed in, the compiler doesn't need to spend time copying a (possibly) large array. This is also more flexible, because the function can work with arrays of all sizes instead of just a specific size.</p>
<p class="calibre2">Unfortunately, when passing structs or classes to a function, the default behavior is <em class="calibre12">pass by value</em>. We say unfortunately, because this will automatically evoke the copy constructor, which may be expensive and unnecessary if the function is only reading data from the data type. A good general rule to follow is when passing structs or classes to functions, do not pass by value, pass by pointer, or reference. This avoids the possibly expensive copy of the data. There are certainly exceptions to this rule, but 99% of the time, passing by value is the wrong thing to do:</p>
<pre class="calibre23">
//Simplified GameObject struct <br class="title-page-name"/>struct GameObject <br class="title-page-name"/>{ <br class="title-page-name"/>M5Vec2 pos; <br class="title-page-name"/>M5Vec2 vel; <br class="title-page-name"/>int    textureID; <br class="title-page-name"/>std::list&lt;M5Component*&gt; components; <br class="title-page-name"/>std::string name; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>void DebugPrintGameObject(GameObject&amp; gameObject) <br class="title-page-name"/>{ <br class="title-page-name"/>//Do printing  <br class="title-page-name"/>gameObject.textureID = 0;//WHOOPS!!! <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We would like to avoid the expensive copy constructor call when passing <kbd class="calibre14">GameObjects</kbd> to functions. Unfortunately, when we pass by pointer or reference, the function has access to our public data and can modify it. As before, the solution is to pass by pointer to <kbd class="calibre14">const</kbd> or reference to <kbd class="calibre14">const</kbd>:</p>
<pre class="calibre23">
void DebugPrintGameObject(const GameObject&amp; gameObject) <br class="title-page-name"/>{ <br class="title-page-name"/>//Do printing  <br class="title-page-name"/>gameObject.textureID = 0;//ERROR: gameObject is const <br class="title-page-name"/>} 
</pre>
<p class="calibre2">When writing functions, if the purpose is to modify the data, then you should pass by reference. However, if the purpose is not to modify the data, then pass by reference to const. You will avoid the expensive copy constructor call, and the data will be protected from accidental modification. Additionally, by making a habit of passing by reference or reference to <kbd class="calibre14">const</kbd>, you code will be self-documenting.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Const member functions</h1>
            

            <article>
                
<p class="calibre2">In the previous example, we kept the struct very simple. Since the struct didn't have any member functions, we only needed to worry about when non-member functions want to modify the data. However, object-oriented programming suggests that we shouldn't have data be public. Instead, all data should be private and accessed through public member functions. Let's look at a very simple example to understand this concept:</p>
<pre class="calibre23">
class Simple <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>Simple(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_data = 0; <br class="title-page-name"/>  } <br class="title-page-name"/>void SetData(int data) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_data = data; <br class="title-page-name"/>} <br class="title-page-name"/>int GetData(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  return m_data; <br class="title-page-name"/>  } <br class="title-page-name"/>private: <br class="title-page-name"/>int m_data; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>Simple s; <br class="title-page-name"/>const Simple cs; <br class="title-page-name"/> <br class="title-page-name"/>s.SetData(10);          //Works as Expected <br class="title-page-name"/>int value = s.GetData();//Works as Expected <br class="title-page-name"/> <br class="title-page-name"/>cs.SetData(10);         //Error as expected <br class="title-page-name"/>value = cs.GetData();   //Error: Not Expected <br class="title-page-name"/>return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As expected, when our class is not marked as <kbd class="calibre14">const</kbd>, we can use both the <kbd class="calibre14">SetData</kbd> and <kbd class="calibre14">GetData</kbd> member functions. However, when we mark our class as <kbd class="calibre14">const</kbd>, we expect that we won't be able to use the <kbd class="calibre14">SetData</kbd> member function, because it modifies the data. However, unexpectedly, we can't use the <kbd class="calibre14">GetData</kbd> member function, even though it doesn't modify the data at all. To understand what is going on, we need to understand how member functions are called and how a member function modifies the correct data.</p>
<p class="calibre2">Whenever a non-static member function is called. The first parameter is always the hidden <kbd class="calibre14">this</kbd> pointer. It is a pointer to the instance that is calling the function. This parameter is how the <kbd class="calibre14">SetData</kbd> and <kbd class="calibre14">GetData</kbd> can act upon the correct data. The <kbd class="calibre14">this</kbd> pointer is optional within the member function, as programmers, we can choose to use it or not:</p>
<pre class="calibre23">
//Example showing the hidden this pointer. This code won't //compile <br class="title-page-name"/>Simple::Simple(Simple* this) <br class="title-page-name"/>{ <br class="title-page-name"/>  this-&gt;m_data = 0; <br class="title-page-name"/>} <br class="title-page-name"/>void Simple::SetData(Simple* this, int data) <br class="title-page-name"/>{ <br class="title-page-name"/>  this-&gt;m_data = data; <br class="title-page-name"/>} <br class="title-page-name"/>int Simple::GetData(Simple* this) <br class="title-page-name"/>{ <br class="title-page-name"/>  return this-&gt;m_data; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This is completely true. The <kbd class="calibre14">this</kbd> pointer is actually a <kbd class="calibre14">const</kbd> pointer to a <kbd class="calibre14">Simple</kbd> class. We didn't talk about const pointers, but it just means the pointer can't be modified, but the data it points to (the <kbd class="calibre14">Simple</kbd> class) can be. This distinction is important. The pointer is <kbd class="calibre14">const</kbd>, but the <kbd class="calibre14">Simple</kbd> class is not. The actual hidden parameter would look something like this:</p>
<pre class="calibre23">
//Not Real Code. Will Not Compile <br class="title-page-name"/>Simple::Simple(Simple* const this) <br class="title-page-name"/>{ <br class="title-page-name"/>  this-&gt;m_data = 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">When we have code like this that calls a member function:</p>
<pre class="calibre23">
Simple s; <br class="title-page-name"/>s.SetData(10); 
</pre>
<p class="calibre2">The compiler is really turning it into code that looks like this:</p>
<pre class="calibre23">
Simple s; <br class="title-page-name"/>Simple::SetData(&amp;s, 10); 
</pre>
<p class="calibre2">This is the reason we get errors when we try to pass a <kbd class="calibre14">const Simple</kbd> object to the member function. The function signature is not correct. The function does not accept a <kbd class="calibre14">const Simple</kbd> object. Unfortunately, since the <kbd class="calibre14">this</kbd> pointer is hidden, we cannot simply make the <kbd class="calibre14">GetData</kbd> function accept a <kbd class="calibre14">const Simple</kbd> pointer. Instead we must mark the function as <kbd class="calibre14">const</kbd>:</p>
<pre class="calibre23">
//What we would like to do but can't <br class="title-page-name"/>int Simple::GetData(const Simple* const this); <br class="title-page-name"/> <br class="title-page-name"/>//We must mark the function as const <br class="title-page-name"/>   int Simple::GetData(void) const; 
</pre>
<p class="calibre2">We must mark the function as const within the class as well. Notice that <kbd class="calibre14">SetData</kbd> is not marked const, because the purpose of that function is to modify the class, but <kbd class="calibre14">GetData</kbd> is marked <kbd class="calibre14">const</kbd> because it only reads data from the class. So, our code would look something like the following. To save space, we didn't include the function definitions again:</p>
<pre class="calibre23">
class Simple <br class="title-page-name"/>{ <br class="title-page-name"/>  public: <br class="title-page-name"/>  Simple(void); <br class="title-page-name"/>  void SetData(int data); <br class="title-page-name"/>  int GetData(void) const; <br class="title-page-name"/>  private: <br class="title-page-name"/>  int m_data; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  Simple s; <br class="title-page-name"/>  const Simple cs; <br class="title-page-name"/> <br class="title-page-name"/>  s.SetData(10);          //Works as Expected <br class="title-page-name"/>  int value = s.GetData();//Works as Expected <br class="title-page-name"/> <br class="title-page-name"/>  cs.SetData(10);         //Error as expected <br class="title-page-name"/>  value = cs.GetData();   //Works as Expected <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can see, by marking the <kbd class="calibre14">GetData</kbd> member function as const, it can be used when the variable instance is marked const. Marking member functions as const allows the class to work correctly with non-member functions that may be attempting const correctness. For example, a non-member function (possibly written by another programmer) trying to display a <kbd class="calibre14">Simple</kbd> object by using the <kbd class="calibre14">GetData</kbd> member function:</p>
<pre class="calibre23">
//Const correct global function using member functions to access <br class="title-page-name"/>//the data <br class="title-page-name"/>void DisplaySimple(const Simple&amp; s) <br class="title-page-name"/>{ <br class="title-page-name"/>  std::cout &lt;&lt; s.GetData() &lt;&lt; std::end; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Since <kbd class="calibre14">DisplaySimple</kbd> isn't intending to change the data in the class, the parameter should be marked as <kbd class="calibre14">const</kbd>. However, this code will only work if <kbd class="calibre14">GetData</kbd> is a <kbd class="calibre14">const</kbd> member function.</p>
<p class="calibre2">Being const-correct takes a little work and may seem difficult at first. However, if you make it a habit, it will eventually become the natural way that you program. When you are const-correct, your code is cleaner, more protected, self-documenting, and more flexible, because you are prepared for const and non-const instances. As a rule, if your function isn't going to modify the data, mark the parameter as const. If the member function isn't going to modify the class data, mark the member function as const.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Problems with const</h1>
            

            <article>
                
<p class="calibre2">As we said before, const isn't magic. It doesn't make your code 100% secure and protected. Knowing and understanding the rules related with const parameters and const member function will help prevent mistakes. However, failing to understand the rules and behaviors of const can lead to bugs.</p>
<p class="calibre2">The biggest problem with const in C++ is a misunderstanding of bitwise const versus logical const. This means that the compiler will try to ensure that the bits and bytes will not change through that specific variable. This doesn't mean that those bits won't change through another variable, and it doesn't mean that the data you may care about won't change. Consider the following code:</p>
<pre class="calibre23">
//Example of modifying const bits through different variables. <br class="title-page-name"/>int i = 0; <br class="title-page-name"/>const int&amp; ci = i; <br class="title-page-name"/> <br class="title-page-name"/>ci = 10; //ERROR: can't modify the bits through const variable <br class="title-page-name"/>i  = 10; //OK. i is not const <br class="title-page-name"/> <br class="title-page-name"/>std::cout &lt;&lt; ci &lt;&lt; std::endl;//Prints 10 
</pre>
<p class="calibre2">In the preceding example, <kbd class="calibre14">i</kbd> is not const, but <kbd class="calibre14">ci</kbd> is a reference to a const <kbd class="calibre14">int</kbd>. Both <kbd class="calibre14">i</kbd> and <kbd class="calibre14">ci</kbd> are addressing the same bits. Since <kbd class="calibre14">ci</kbd> is marked const, we cannot change the value through that variable. However, <kbd class="calibre14">i</kbd> is not const, so we are free to modify the value. The fact that we can have a multiple const and non-const variables pointing to the same address has consequences for const member functions:</p>
<pre class="calibre23">
class Simple <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>     Simple(void); <br class="title-page-name"/>  int GetData(void) const; <br class="title-page-name"/>private: <br class="title-page-name"/>  int m_data; <br class="title-page-name"/>  Simple* m_this; <br class="title-page-name"/>}; <br class="title-page-name"/>Simple::Simple(void):m_data(0), m_this(this) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/>int Simple::GetData(void) const <br class="title-page-name"/>{ <br class="title-page-name"/>  m_this-&gt;m_data = 10; <br class="title-page-name"/>  return m_data; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>int main(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  const Simple s; <br class="title-page-name"/>  std::cout &lt;&lt; s.GetData() &lt;&lt; std::endl; <br class="title-page-name"/>  return 0; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">In the preceding code, we have given the <kbd class="calibre14">Simple</kbd> class a pointer to itself. This pointer can be used to modify its own data in a const member function. Remember, in a <kbd class="calibre14">const</kbd> member function, the <kbd class="calibre14">this</kbd> pointer is marked <kbd class="calibre14">const</kbd>, so data can't be changed through that variable. However, as in this case, the data can still be changed through another variable. Even if we didn't use another variable, the use of <kbd class="calibre14">const_cast</kbd> could also allow us to change the data:</p>
<pre class="calibre23">
int Simple::GetData(void) const <br class="title-page-name"/>{ <br class="title-page-name"/>  const_cast&lt;Simple*&gt;(this)-&gt;m_data = 10; <br class="title-page-name"/>   m_data; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">It is very important to understand that you should never write code like this. It is undefined behavior to try to modify a const variable with <kbd class="calibre14">const_cast</kbd> or using a non-const pointer to a <kbd class="calibre14">const</kbd> object. The original data could be placed in read-only memory, and code like this could cause the program to crash. It is also possible that the compiler could optimize away multiple reads to memory that shouldn't change. Therefore, the old value may be used for any future calculations. Casting away <kbd class="calibre14">const</kbd> with <kbd class="calibre14">const_cast</kbd> is meant for backwards compatibility with old C++ libraries. It should <em class="calibre12">NEVER</em> be used to modify const values. If there is a piece of data that needs to be modified even when the class is <kbd class="calibre14">const</kbd>, use the <kbd class="calibre14">mutable</kbd> keyword.</p>
<p class="calibre2">Even when avoiding undefined behavior, bitwise constness can get us into trouble with const member variables. Consider a simple class that will contain some dynamic memory. Since it contains dynamic memory and pointers, we should add a copy constructor, destructor, and other things to prevent memory leaks and memory corruption, but we will omit those for now since they aren't important for our discussion on const:</p>
<pre class="calibre23">
class LeakyArray <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>LeakyArray(int size) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_array = new int[size]; <br class="title-page-name"/>  } <br class="title-page-name"/>void SetValue(int index, int value) <br class="title-page-name"/>{ <br class="title-page-name"/>  m_array[index] = value; <br class="title-page-name"/>} <br class="title-page-name"/>int GetValue(int index) const <br class="title-page-name"/>{ <br class="title-page-name"/>  //function is const so we can't do this <br class="title-page-name"/>  //m_array = 0; <br class="title-page-name"/> <br class="title-page-name"/>  //but we can do this!!!!!!! <br class="title-page-name"/>  m_array[index] = 0; <br class="title-page-name"/> <br class="title-page-name"/>  return m_array[index]; <br class="title-page-name"/> <br class="title-page-name"/>  } <br class="title-page-name"/>private: <br class="title-page-name"/>  int* m_array; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">As you can see, bitwise const only prevents us from modifying the actual bits inside the class. This means we can't point <kbd class="calibre14">m_array</kbd> to a new location. However, it doesn't prevent us from modifying data in the array. There is nothing preventing <kbd class="calibre14">GetValue</kbd> from modifying the array in the const function, because the array data isn't part of the class, only the pointer is. Most users aren't concerned about where the data is located, but they would expect a const array to remain unchanged.</p>
<p class="calibre2">As you can see, being const, correct is certainly not a guarantee that the data will never be modified. If you are diligent about using const, as well as understand and avoid the problems that can arise, the benefits are worth it.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Learning how iteration can improve your game and code design</h1>
            

            <article>
                
<p class="calibre2">While it's nice to imagine it to be this way, games never come fully-formed from the mind of a designer/developer. A game is made up of many different ideas from many different people. While in the past people could develop games with only a single person, now it's much more common for teams to be made up of many different disciplines and every game developer on your team has ideas, many of them good that can contribute to the final product that gets made. But with that in mind you may be wondering how does a game get to the final point with all those different changes made? The answer to that is iteration.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The game development cycle</h1>
            

            <article>
                
<p class="calibre2">Game development is a process, and different people have different names and/or phrases for each of these steps, but most people can agree that, for commercial game development, there are three main phases:</p>
<ul class="calibre17">
<li class="calibre18">Pre-Production</li>
<li class="calibre18">Production</li>
<li class="calibre18">Post-Production</li>
</ul>
<p class="calibre2">Each of these states has their own steps within them as well. Due to page constraints, I'm unable to write about the entire process, but we will be focusing on the Production aspect of development, since that's where the most relevant content will be for our readers.</p>
<div class="packt_infobox">If you are interested in learning more about the different aspects of the game development process, check out <a href="https://en.wikipedia.org/wiki/Video_game_development#Development_process" target="_blank" class="calibre24"><span class="urlpackt">https://en.wikipedia.org/wiki/Video_game_development#Development_process</span></a>.</div>
<p class="calibre2">During game development, you'll see a lot of companies use an agile development process, which is based on iterative prototyping, using feedback and refinement of the game's iterations while gradually increasing the game's feature set. A lot of companies enjoy this method as there is always a version of the game playable every couple of weeks, and you can make adjustments as the project is being worked on. If you have heard of Scrum, it is a popular method of agile software development, and one that I use with my students as well as what I used in the game industry.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Production phase</h1>
            

            <article>
                
<p class="calibre2">Upon entering the production phase, we have come up with our base idea for our project and have created our proposal and game design document. Now that we have this information, we can start doing the following three steps:</p>
<ul class="calibre17">
<li class="calibre18">Prototyping</li>
<li class="calibre18">Playtesting</li>
<li class="calibre18">Iterating</li>
</ul>
<p class="calibre2">Each of these steps serves a valuable process and will be completed in this order. We will be repeating these steps repeatedly until release, so it's a good idea to have an understanding of them.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Prototyping</h1>
            

            <article>
                
<p class="calibre2">Prototyping is when you make the simplest version of your ideas in a quick manner to prove if your concept works well or not. For some people, they will do this via index cards, paper, chits, and boards, which is called a paper prototype. This can be quite useful, as you don't have to think about the code side of things to begin with, and instead it allows you to experience the core of the game without having all the nice art and polish. A game that is fun to play with bad graphics will only be improved when you add to it.</p>
<p class="calibre2">Of course, assuming you have purchased this book, you are probably already a developer, but it's still a good idea to think of it as an option. <em class="calibre12">Jesse Schell</em> wrote about paper prototypes in his book <em class="calibre12">The Art of Game Design: A Book of Lenses</em>, where he explained how you could create a paper prototype of the game Tetris. To do so, you could cut out cardboard pieces and then put them into a pile and pick them out randomly, and then slide them down the board, which would be a piece of paper. Once you completed a line, you would grab an X-acto knife and then cut the pieces. While it doesn't give you the same experience entirely, it captures enough of the experience to see if you are using the right kinds of shapes and how fast the pieces should drop. The big advantage would be that you could create this prototype in 10 to 15 minutes, while programming it may take a lot longer.</p>
<p class="calibre2">It's a lot easier to justify 30 minutes of work rather than a day for something that doesn't work out. This can be done with 3D games as well, such as First Person Shooters, by creating maps in a similar way to how you create combat encounters in a pen and paper role playing game such as Wizards of the Coast's <em class="calibre12">Dungeons and Dragons</em> (which is a great thing to learn how to play as a designer, as you learn about telling a story and developing interesting encounters).</p>
<p class="calibre2">A prototype's job is to prove if your game works and, specifically, how it works. Don't invest in only one idea specifically, but rather create a number of small prototypes thatare quick to make, without worrying if it is polished or you've made it the best possible.</p>
<div class="packt_infobox">For some more information on building a prototype and an example of a prototype that was created in seven days about <em class="calibre25">Tower of Goo</em>, which was the prototype for their indie hit <em class="calibre25">World of Goo</em>, check out <a href="http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1" target="_blank" class="calibre24">http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1</a>.</div>
<p class="calibre2">One of the most vital skills as a game developer is being able to create rapid prototypes, to see how it works, and then test it. We call this process of testing out a game idea playtesting.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Playtesting</h1>
            

            <article>
                
<p class="calibre2">Once we have a prototype, we can then begin the playtesting process. Playtest as soon as possible in your development, and do it often. As soon as you have something playable, get people in front of it. First play the game yourself and see how you feel about it. Then invite some friends over to your house and have them play it as well.</p>
<p class="calibre2">Oftentimes, I find my students have difficulty at first actually doing playtests and may be hesitant to show people their projects as it's not <em class="calibre12">ready</em> yet or because they won't get it. Or they know that their project isn't finished so they think they know what they should be working on already, so there's no need to do playtesting. I find this usually comes from them being shy, and one of the first major obstacles you'll need to overcome as a developer is being able to show your ideas to the world.</p>
<p class="calibre2">If the play testers of your game aren't your close friends and/or family, it is likely that people will say negative things about the game. This is a good thing. They will also mention many things that you already know your game doesn't have yet or that you don't have the budget for. This isn't a time for you to defend any points, or explain why things are the way they are, but instead a time for you to accept the points and note them, as you can take them into consideration in the future.</p>
<p class="calibre2">As a game developer, one thing that's important to note is that you are one of the worst judges of your games, especially when just starting out. A lot of times I see starting developers trying to justify the problems in their games, stating that it is their vision and people don't get it because it's not in a final game. It's a very important skill of a game developer to beable to get feedback, take criticism, and evaluate if things are worth changing or not.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Conducting a playtest</h1>
            

            <article>
                
<p class="calibre2">Now that we know how valuable it is to do a playtest, you may wonder how to go about doing one. First, I do want to note that it is vitally important that you are in the room while your project is being playtested. While they are playing the game, you can see not only what someone thinks, but also how they react to things as well as what they do with your game. This is the time where you find out what works well and what doesn't. If for some reason, you are unable to be there in person, have them record themselves playing, both on the PC and from the webcam if possible.</p>
<p class="calibre2">When someone comes to a computer to playtest your game, you may be tempted to tell them things about your project, such as the controls and the story, and the mechanics, and anything else, but you should resist these urges. See what the player does without any prompting to begin with. This will give you an idea of what players will want to do naturally given the environment that you created and what needs to be explained more. Once they play for a while and you've gotten the information you need on that end, then you can tell them some things.</p>
<p class="calibre2">When playtesting, it's a good idea to get as much information from the player as you can. When they finish, ask them what they liked, what they disliked, if they found anything confusing, where they got stuck, and what was the most interesting thing to them. Do note that what a player says and what they actually do are two different things, so it's important that you are there and watching them. Getting your game played and seeing what those players do is where you will start to see the cracks in your design's form, and seeing what people do will show how they experience the things you have created. While doing this testing, I've seen a lot of people do the exact opposite of what I expected and not understand something that I thought was quite simple. The player isn't wrong in this regard though, I was. The player can only do what they know from prior playing or from what is taught in the game.</p>
<p class="calibre2">All of the information that you get during a playtest is important. Not just what they say, but also what they don't say. Once they finish playing, give them a survey to fill out. I find using Google Sheets does a good job at storing this information and isn't too difficult to set up, and you have hard data from which you can make decisions without having to remember what people say. Plus, it's a lot easier for people to select a number from 1-10 for how they enjoyed different aspects of the game than to ask their thoughts for everything and doesn't require them to write paragraphs of info (unless they want to in a comments section at the end).</p>
<div class="packt_infobox">In case you'd like to see an example playtesting form, while this form is for board games, I feel it does a good job of making it easy for play testers to give information that can be useful: <a href="https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/" target="_blank" class="calibre24"><span class="urlpackt">https://www.reddit.com/r/boardgames/comments/1ej13y/i_created_a_streamlined_playtesting_feedback_form/</span></a>.<br class="calibre27"/>
<br class="calibre27"/>
If you're looking for some ideas of questions to ask, <em class="calibre25">Wesley Rockholz</em> wrote some examples of questions that may be useful for you to use: <a href="http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php" target="_blank" class="calibre24"><span class="urlpackt">http://www.gamasutra.com/blogs/WesleyRockholz/20140418/215819/10_Insightful_Playtest_Questions.php</span></a>.</div>
<p class="calibre2">In addition, the order in which players give their feedback is also important as it communicates how important different things are to them. You may find that what was intended to be the main mechanic isn't as engaging and/or fun as something else. That is valuable feedback, and you may decide to focus on that secondary mechanic instead for the title, as I've seen happen repeatedly on projects. It's better to do this as early as possible so you will waste as little of your time as possible.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Iteration</h1>
            

            <article>
                
<p class="calibre2">At this point, we've playtested our project and have gotten our player's feedback, and, if we have set it up, gotten data and analytics from which we can build upon. Now we need to take this information into consideration, make some changes to our current prototype, and then bring it back to be play tested again. This is what's known as the iteration stage of development.</p>
<p class="calibre2">In this stage, you'll need to take this feedback and then decide how to incorporate it into your design. You'll need to decide what should be changed as well as what shouldn't. While doing so, keep in mind the scope of the project, realistically evaluating how long it will take to make the changes, and be willing to cut features, even those that you love, to have the best project.</p>
<p class="calibre2">After making these decisions again, we will once again create a new prototype, which you will then playtest again. Then iterate again. Then build another prototype, where you will continue to test, removing prototypes that don't work and features that don't work well for the project. You'll also try adding new features using feedback and remove previous features that would no longer fit the game in its current state. You will keep doing this cycle repeatedly until you reach your final release!</p>
<p class="calibre2">If you're waiting for your game to be <em class="calibre12">perfect</em> before releasing it, you'll never release it. Games are never finished, they're only abandoned. If the project is at a point where it is good enough, you should ship, because it's only when you ship a project that you can finally say you've developed a title.</p>
<div class="packt_infobox">If you'd like to see an example of this process and how it can benefit a title, check out: <a href="http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php" target="_blank" class="calibre24"><span class="urlpackt">http://www.gamasutra.com/blogs/PatrickMorgan/20160217/265915/Gurgamoth_Lessons_in_Iterative_Game_Development.php</span></a>.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Meeting milestones</h1>
            

            <article>
                
<p class="calibre2">When working on a commercial game project, especially when you have a publisher, you often times will have a schedule to keep and milestones to meet. Milestones are ways for everyone to know if the game is on track or not, because certain things need to be accomplished by them. Not making a milestone can often be a horrible thing, because your publisher usually will only pay your team if the milestone has everything in it that was agreed upon. There's no standard milestone schedule, as every company is different, but some of the most common ones are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">First-playable</strong>: This is the first version of the game that can be played. Has the main mechanic of the game in and can demonstrate how it works.</li>
<li class="calibre18"><strong class="calibre1">Alpha</strong>: When all the features of your game are in, known as being feature complete. Features can change slightly, and make revisions based on feedback and testing, but at this point, unimplemented things may be dropped to finish the title on time.</li>
<li class="calibre18"><strong class="calibre1">Beta</strong>: The game is complete, with all assets and features completed and finished. At this point you are only doing bug testing and fixes for potential problems that would prevent your game from being shipped.</li>
<li class="calibre18"><strong class="calibre1">Gold</strong>: This is the final version of the game, which you'll either be releasing, or sending to your publisher to create copies on disks, cartridges, or whatever your device uses.</li>
</ul>
<p class="calibre2">Do note that every company is different and these milestones may mean different things to different people, so be sure to clarify before diving into development.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Learning when to use scripting in a game</h1>
            

            <article>
                
<p class="calibre2">Scripting languages are something that can be quite beneficial to developers when working on a team with multiple disciplines in it. But before we dive into what they are and how they work, and the pros and cons of using a scripting language, it's best to get a bit of a history lesson in terms of how code executes.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction to assembly</h1>
            

            <article>
                
<p class="calibre2">Underneath the hood, all the code that we have written over the course of this book is ones and zeroes indicating what switches should be marked as on and off by our computer's processor. Low-level programming languages such as machine language use these switches to execute commands. This was the only way to program to begin with, but we have developed more readable languages for us to work with instead.</p>
<p class="calibre2">Starting with assembly languages, low-level languages have a very strong connection between the language's instructions and the machine code's instructions. While more readable than a sequence of <kbd class="calibre14">0</kbd>s and <kbd class="calibre14">1</kbd>s, it was still quite difficult to write code. For example, here is some assembly code used to add two numbers in Assembly Language:</p>
<pre class="calibre23">
        push    rbp <br class="title-page-name"/>        mov     rbp, rsp <br class="title-page-name"/>        mov     DWORD PTR [rbp-20], edi <br class="title-page-name"/>        mov     DWORD PTR [rbp-24], esi <br class="title-page-name"/>        mov     edx, DWORD PTR [rbp-20] <br class="title-page-name"/>        mov     eax, DWORD PTR [rbp-24] <br class="title-page-name"/>        add     eax, edx <br class="title-page-name"/>        mov     DWORD PTR [rbp-4], eax <br class="title-page-name"/>        nop <br class="title-page-name"/>        pop     rbp <br class="title-page-name"/>        ret 
</pre>
<p class="calibre2">Each computer architecture has its own assembly language, so writing code in low-level languages has the disadvantage of not being portable as they are machine dependent. Back in the day, people would have to learn many different languages in order to port your program to another processor. Program structures became more complicated, as the demands of functionality increased over time, making it quite difficult for programmers to implement efficient programs that were robust enough.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Moving to higher-level programming languages</h1>
            

            <article>
                
<p class="calibre2">As programmers, we are inherently lazy, so we seek ways to make our job easier or rather to find the best use of our time. With that in mind, we have developed other higher level languages, which are even easier to read. By higher level, we mean closer to the way that humans think or closer to the problem we are trying to solve. By abstracting the machine details from our code, we simplify programming tasks.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introducing the compiler</h1>
            

            <article>
                
<p class="calibre2">Once we have finished our code, we use a compiler to translate that high-level code into assembly, which in turn will get turned into machine language that our computer can execute. Afterwards, it will translate that program into an executable file that the user can run. Functionally, it looks something like this:</p>
<div class="packt_figure"><img class="image-border8" src="../images/00095.jpeg"/></div>
<p class="calibre2">This has several advantages, as it provides abstraction from the hardware details. For example, we don't need to work directly with registers, memory, addresses, and so on anymore. It also makes our code portable in that we can use the same program and have it translated by different assemblers for the different machines that use it. This was one of the reasons C took off and became so popular, because it allowed people to write code once and then have it work everywhere. You may notice that Unity has taken the same thought process to game development, and that's one of the reasons that I feel they've been so successful as of this writing.</p>
<p class="calibre2">This is a much more efficient use of time than writing assembly language code as it allows us to create more complex programs and machines, and modern compilers such as Microsoft's produce some highly efficient assembly code in most circumstances. This is what we have been using over the course of this book.</p>
<p class="calibre2">Writing code in assembly can still have its benefits though. For instance, after you've written your game in a higher-level language, you can start profiling it and seeing what aspects of the game are the bottlenecks, and then determine if rewriting it in assembly will give you a speed boost. The point of using a lower-level language is the fact that you can gain some substantial speed advantages.</p>
<div class="packt_infobox">For a real-life example as to how assembly was used to optimize a game engine, check out the following article from Intel: <a href="https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/" target="_blank" class="calibre24"><span class="urlpackt">https://software.intel.com/en-us/articles/achieving-performance-an-approach-to-optimizing-a-game-engine/</span></a>.</div>
<p class="calibre2">One of the issues with writing code that needs to be compiled before running is the fact that as projects increase in size, so do compile times. Recompiling a full game can take minutes to hours depending on the size of the project, and while that's going on, you are unable to work on your project, or else you'd need to recompile again. This is one of the reasons why scripting languages can be useful.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction to scripting languages</h1>
            

            <article>
                
<p class="calibre2">A scripting language is a programming language that allows scripts to be written for it. A script is a program that can be executed without being compiled in one of a few different ways. Scripting languages are also sometimes referred to as very high-level programming languages, as they operate at a high level of abstraction, being very fast to learn how to write in.</p>
<p class="calibre2">Scripting languages also have the advantage of taking care of a lot of things that programmers would need to take care of, such as garbage collection, memory management, and pointers, which often confuse non-developers. Even a visual editor such as Unreal 4's blueprints is still a scripting language, as it accomplishes the same thing as a written one does.</p>
<p class="calibre2">Most games use scripting languages in some form, but other games may use it a lot more, such as how GameMaker uses <strong class="calibre1">Game Maker Language</strong> (<strong class="calibre1">GML</strong>) for their logic.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using interpreters</h1>
            

            <article>
                
<p class="calibre2">To use a scripting language, we need to be able to execute new code on the fly. However, unlike a compiler, there's also another way to convert code into something that can be understood by a machine that is called an interpreter. Interpreters do not produce a program themselves, and rather stay around for the execution of a program. This program will either:</p>
<ul class="calibre17">
<li class="calibre18">Execute the source code directly</li>
<li class="calibre18">Translate the source code into some other efficient intermediate representation (code) and then immediately execute it</li>
<li class="calibre18">Explicitly execute stored precompiled code made by a compiler that is part of the interpreter system</li>
</ul>
<p class="calibre2">The interpreter translates one line at a time, as opposed to the compiler doing it all at once.</p>
<p class="calibre2">Visually, it looks a bit like the following:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00096.jpeg"/></div>
<p class="calibre2">As you can see here, the <strong class="calibre1">Interpreter</strong> takes in the <strong class="calibre1">Source Code</strong> and any <strong class="calibre1">Input</strong> that has been received, and will then <strong class="calibre1">Output</strong> what is expected of it.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Just in time compilation</h1>
            

            <article>
                
<p class="calibre2">There is yet another way to run code,using what's called a <strong class="calibre1">just in time compiler</strong>, or <strong class="calibre1">JIT</strong> for short. A JIT caches the instructions, that have been previously interpreted to machine code, and reuses those native machine code instructions thus saving time and resources by not having to re-interpret statements that have already been interpreted.</p>
<p class="calibre2">Visually, it looks similar to this:</p>
<div class="packt_figure"><img class="image-border49" src="../images/00097.jpeg"/></div>
<p class="calibre2">Now, Unity uses a JIT and AOT compiler to convert code into machine code, which can then be read by the machine. The first time that a function is called, the game will convert that code into machine language and then the next time it is called, it will go directly to the translated code, so you only need to do conversions to things that are happening. Due to this happening at runtime, this may cause your project to lag when using a lot of new things.</p>
<div class="packt_infobox">A great talk about how scripting works inside of the Unity game engine can be found here:<a href="https://www.youtube.com/watch?v=WE3PWHLGsX4" target="_blank" class="calibre24"><span class="urlpackt">https://www.youtube.com/watch?v=WE3PWHLGsX4</span></a>.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Why use a scripting language?</h1>
            

            <article>
                
<p class="calibre2">C++ is often overkill when it comes to building things for your game, such as tools, or for high-level game tasks that could be handled by your technical designers. It has some definite advantages for ease of development. Specifically, that you don't have to worry about a lot of the low-level things, as the language takes care of it for you; there's also fewer errors by the programmer due to the limited options available. There's less of a technical programming knowledge required, and it can be customized to fit your game's needs. This also makes the game more data driven instead of hardcoding things into the game engine, and allows you to patch the game without having to send over the entire project.</p>
<p class="calibre2">Often in game development, game logic and configurations can be found in script files. This way, it's very easy for scripts to be modified and adjusted by people on the team that aren't programmers (such as designers), allowing them to playtest the game and tweak the gameplay without having to recompile the game.</p>
<p class="calibre2">Many games also have a console window, which uses a scripting language to do things like this even at runtime. For instance, Unreal Engine has a console window open by default when you press <span>Tab</span> and in Source engine, pressing the <span>~</span> button at the pause menu will open one up.</p>
<p class="calibre2">Scripting languages are also often used in areas that have level design as well, such as having triggers for when you enter certain areas, or for controlling cinematics. It also allows you to let players of your game mod the game as well, which could potentially increase the lifespan of your game and help foster your game's community.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">When to use C++</h1>
            

            <article>
                
<p class="calibre2">C++ is a great language to be using, as performance isa crucial first step. This used to be all aspects of game engines, but now is used primarily with graphics and AI code. Scripting languages also have the problem of being slower than C++, sometimes even 10x slower than what it would be otherwise. Due to scripting languages having memory management taken care of for them automatically, there could be times when commands are interrupted or take a while to complete garbage collection, causing lag and other problems.</p>
<p class="calibre2">C++ also has the advantage of much better IDEs and Debuggers, making it a lot easier for you to find mistakes and fix them when they do occur.</p>
<p class="calibre2">There's also the possibility that you are working with a legacy code base. Most game companies aren't starting with a fresh slate. It can also be useful to make use of the middleware libraries that C++ has, such as FMOD and AntTweakBar.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Compiled versus scripting</h1>
            

            <article>
                
<p class="calibre2">For some game engines, the game engine itself is programmed in C++, but the game logic is entirely done in a scripting language, like most development for Unity, for example. This allows you to iterate on gameplay much faster, and allows technical designers and artists to modify behaviors without having to bother a programmer. Also, depending on the language, it can allow people to use a more appropriate language for the problem's domain (for example, AI may not be the easiest thing to implement in C++).</p>
<p class="calibre2">Different companies handle working with languages differently. When I was working at aAAA (pronounced triple-A)studio, we would have designers prototype ideas for mechanics and get it working in the best possible way making use of scripting languages. Upon approval from the leads as something to add to the project, if the script had performance issues, programmers would use the scripting language code as a base and then create a super-efficient version using C++ that would work in all levels. However, when I was working on an indie title, all of the code for the project was written in a scripting language (C#), since we didn't have access to the engine's source code (Unity). Also, if you are wanting to target devices that are limited in memory and processing power (such as the Nintendo 3DS), you are likely wanting to care about performance a lot more so it's more important to use more optimized code. It's a good idea to be familiar with both options and be comfortable working either way.</p>
<p class="calibre2">If you are interested in using a scripting language for your project, Lua is very widely used in the game industry because it's very easy to learn and fairly easy to incorporate into your engine. Lua started off as a configuration language. This has some nice quirks, in that it's great for creating and configuring things - which is what you want to do in a game. It's important to note, though,that it's not object-oriented but uses a small amount of memory.</p>
<div class="packt_infobox">A list of games that use Lua as a scripting language can be found here: <a href="https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games" target="_blank" class="calibre24"><span class="urlpackt">https://en.wikipedia.org/wiki/Category%3aLua-scripted_video_games</span></a>.</div>
<p class="calibre2">If you are interested in integrating Lua into your project or would like to see how it works, I highly suggest checking out <a href="http://www.lua.org/start.html" target="_blank" class="calibre7"><span>http://www.lua.org/start.html</span></a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we covered a lot of best-practice information, which we hope will give you a good foundation when building your own projects in the future. We touched on why hardcoding values is a bad idea, in addition to making a number of other code-quality suggestions, to ensure that your code is easy to understand and easy to extend from in the future, when it needs to be.</p>
<p class="calibre2">We also learned how iteration is useful in game development, talking about the traditional game development cycle, with tips and tricks about playtesting and how it can be immensely useful when developing your projects.</p>
<p class="calibre2">We also looked into low-level and high-level programming languages, learning about how scripting languages run inside another program that we have to build into our project. They are not compiled but rather interpreted, and are generally easier to use and write code for than a compiled language, but come at the cost of performance. Depending on how complex your game is, it may be a good idea to stick to just C++, but if you are working with designers, it can be quite useful to give them the tools to do things on their own.</p>
<p class="calibre2">With that, we've reached the end of the book. We hope that you found the information both interesting and useful. As you go out there and build your own projects, make use of the design patterns and best practices that we've talked about over the past 12 chapters, and make the best games that you can!</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>