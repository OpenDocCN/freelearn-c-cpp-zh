- en: Chapter 6. Polishing the Silver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 精炼银色
- en: I'm sure that you are as excited as I am about the progress that you have made
    on your game. It's almost ready to publish, right? Well, not quite! There is a
    lot of work that goes into polishing your game before it is ready, and that's
    what this chapter is all about.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您和我一样，对您在游戏上取得的进展感到兴奋。它几乎准备好发布了，对吧？嗯，还不完全是！在游戏准备好发布之前，还有很多工作要做，这正是本章的主题。
- en: 'Many people have a great idea for a game, and lots of enthusiastic coders,
    such as you, actually code their game to the point where we have reached so far.
    Unfortunately, this is where a lot of projects die. For some reason, many first-time
    game coders don''t take the time to really finish their game. There are lots of
    things that still need to be done to make your game presentable:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人有一个很好的游戏想法，也有很多像您这样的热情的程序员实际上将他们的游戏编码到了我们现在所达到的程度。不幸的是，这就是许多项目失败的地方。由于某种原因，许多第一次尝试编写游戏的程序员没有花时间真正完成他们的游戏。还有很多事情要做，才能使您的游戏看起来更专业：
- en: '**Game state**: We already touched on game state a little bit when you learned
    how to pause your game. This chapter will continue the discussion of how you use
    game state to manage your game at various stages of gameplay.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态**：当您学习如何暂停游戏时，我们已经稍微提到了游戏状态。本章将继续讨论如何使用游戏状态来管理游戏在游戏过程中的各个阶段。'
- en: '**Splash screen**: Most games display one or more screens before the game starts.
    These screens, known as splash screens, often display the logo and name of the
    studios that were involved in creating the game. A splash screen shows that you
    went the extra mile in polishing your game.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动画面**：大多数游戏在游戏开始之前会显示一个或多个屏幕。这些屏幕被称为启动画面，通常显示参与游戏制作的公司的标志和名称。启动画面表明您在精炼游戏方面已经做得很好。'
- en: '**Menu screen**: Most games start with a menu of choices for the player. We
    will create a simple menu that loads after our splash screen and gives the player
    a few options.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单屏幕**：大多数游戏都是以供玩家选择的菜单开始的。我们将在启动画面之后创建一个简单的菜单，为玩家提供一些选项。'
- en: '**Scoring and statistics**: You probably noticed that our game currently doesn''t
    keep score. Although it is possible to design a game that doesn''t involve scoring,
    most players want to know how they are doing in the game.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**得分和统计数据**：您可能已经注意到，我们的游戏目前还没有得分。虽然设计一个不涉及得分的游戏是可能的，但大多数玩家想知道他们在游戏中的表现。'
- en: '**Winning and losing**: Again, while there are certainly games out there where
    no one wins or loses, most games have win-or-lose conditions that signal that
    the game is over.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜利和失败**：同样，虽然确实存在一些游戏没有胜利或失败的情况，但大多数游戏都有胜利或失败的条件，这标志着游戏的结束。'
- en: '**Game progression**: Most games allow the player to continue playing as long
    as the player has achieved certain goals. Many games are broken down into a series
    of levels, with each level becoming a little more difficult than the previous
    one. You will learn how to add this type of progression to your game.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏进度**：大多数游戏允许玩家在达到某些目标之前继续玩游戏。许多游戏被分解成一系列关卡，每个关卡都比前一个关卡稍微难一些。您将学习如何将这种进度添加到您的游戏中。'
- en: '**Credits**: Everyone likes to get credit for their work! Just like the movies,
    it is traditional to include a screen that shows each person that was involved
    in creating the game and what their role was. I''ll show you how to create a simple
    credits screen.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**致谢**：每个人都喜欢为自己的工作获得认可！就像电影一样，包含一个显示参与游戏制作的所有人员及其角色的屏幕是传统的。我将向你展示如何创建一个简单的致谢屏幕。'
- en: The state of the game
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏状态
- en: 'Remember when we coded the pause button back in [Chapter 4](ch04.html "Chapter 4. Control
    Freak"), *Control Freak*? We had to add some code that told the game whether it
    was active or paused. In fact, we defined the following enums:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第4章](ch04.html "第4章. 控制狂")中编码暂停按钮的时候吗，*控制狂*？我们必须添加一些代码来告诉游戏它是处于活动状态还是暂停状态。实际上，我们定义了以下枚举：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These `enums` defined two game states: `GS_Running`, and `GS_Paused`. We then
    set the default game state to `GS_Running` in the `StartGame` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`枚举`定义了两个游戏状态：`GS_Running`和`GS_Paused`。然后我们在`StartGame`函数中将默认游戏状态设置为`GS_Running`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As long as the game state is set to `GS_Running`, then the game continues to
    cycle through the game loop, processing updates, and rendering the scene. However,
    when you click the pause button, the game state is set to `GS_Paused`. When the
    game is paused, we no longer update the game objects (that is, the robot, pickups,
    and enemies), but we do continue to render the scene and process the UI (user
    interface) so that buttons can be clicked.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只要游戏状态设置为`GS_Running`，游戏就会继续循环通过游戏循环，处理更新，并渲染场景。然而，当你点击暂停按钮时，游戏状态就会设置为`GS_Paused`。当游戏暂停时，我们不再更新游戏对象（即机器人、拾取物和敌人），但我们仍然继续渲染场景并处理用户界面（UI），以便可以点击按钮。
- en: State machines
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: 'The mechanism used to set up and control game states is known as a **state
    machine**. A state machine sets up separate and distinct stages (or **states**)
    for the game. Each state defines a certain set of rules for what is supposed to
    happen or not happen during each state. For example, our simple state machine
    has two states with the following rules, illustrated by the following matrix:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用于设置和控制游戏状态的机制被称为**状态机**。状态机为游戏设置单独且不同的阶段（或**状态**）。每个状态定义了在每个状态下应该发生或不应发生的一定规则。例如，我们的简单状态机有两个状态，以下矩阵展示了这些规则：
- en: '|   | GS_Running | GS_Paused |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   | GS_Running | GS_Paused |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Input** | All input | Only UI input |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | 所有输入 | 仅UI输入 |'
- en: '| **Objects Updating** | All objects | Only UI objects |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **对象更新** | 所有对象 | 仅UI对象 |'
- en: '| **Collision Detection** | All collideables | No need to check for collisions
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **碰撞检测** | 所有可碰撞对象 | 无需检查碰撞 |'
- en: '| **Spawning** | All spawnables | No spawning |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **生成** | 所有可生成对象 | 不需要生成 |'
- en: '| **Rendering** | All objects | All objects |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **渲染** | 所有对象 | 所有对象 |'
- en: 'The state machine also defines the progression from one state to another. Here
    is a simple diagram showing the progression in our current state machine:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机还定义了从一个状态到另一个状态的转换。以下是一个简单的图，展示了我们当前状态机的转换过程：
- en: '![State machines](img/8199OS_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![状态机](img/8199OS_06_01.jpg)'
- en: This state diagram is pretty simple. If you are in the running state, then it
    is legal to go to the paused state. If you are in the paused state, then it is
    legal to go to the running state. As we will see, most games are much more complex
    than this!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态图相当简单。如果你处于运行状态，那么切换到暂停状态是合法的。如果你处于暂停状态，那么切换到运行状态也是合法的。正如我们将看到的，大多数游戏比这要复杂得多！
- en: Why do we need a state machine?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要状态机？
- en: At first glance, you may wonder why we even need a state machine. You could,
    for example, set up several Boolean flags (maybe one called `running` and one
    called `paused`), and then insert them into the code in the same way that we are
    using our enums.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能想知道我们为什么甚至需要状态机。例如，你可以设置几个布尔标志（可能一个叫`running`，另一个叫`paused`），然后像使用枚举一样将它们插入到代码中。
- en: 'This solution may work considering that our current game only has two states,
    but even then, it starts to get complicated if you choose to use Booleans. For
    example, to change the state from running to paused, I would always have to make
    sure to properly set both Booleans:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们当前的游戏只有两个状态，这个解决方案可能可行，但即使如此，如果你选择使用布尔值，它也会开始变得复杂。例如，要将状态从运行更改为暂停，我必须始终确保正确设置这两个布尔值：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When I went from the running state to the paused state, I would have to set
    both Booleans again:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我从运行状态切换到暂停状态时，我必须再次设置这两个布尔值：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Imagine the problem if I forgot to change both Booleans and left the game in
    a state where it was both running and paused! Then imagine how complicated this
    becomes if my game has three, four, or ten states!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我忘记更改这两个布尔值，游戏处于同时运行和暂停的状态，会发生什么问题！然后想象一下，如果我的游戏有三个、四个或十个状态，这会变得多么复杂！
- en: 'Using enums is not the only way to set up a state engine, but it does have
    immediate advantages over using Booleans:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举不是设置状态机的唯一方法，但它确实在使用布尔值时具有立即的优势：
- en: Enums have a descriptive name associated with their value (for example, `GS_Paused`),
    whereas Booleans only have `true` and `false`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举与其值相关联的描述性名称（例如，`GS_Paused`），而布尔值只有`true`和`false`。
- en: Enums are already mutually exclusive. In order to make a set of Booleans mutually
    exclusive, I have to set one to `true` and all the others to `false`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举已经互斥。为了使一组布尔值互斥，我必须将一个设置为`true`，而将所有其他设置为`false`。
- en: 'The next consideration as to why we need a state machine is that it simplifies
    the coding of the control of the game. Most games have several game states, and
    it is important that we are able to easily manage which code runs in which state.
    An example of game states that are common to most games includes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来考虑为什么我们需要状态机的原因是它简化了游戏控制的编码。大多数游戏都有几个游戏状态，我们能够轻松地管理哪些代码在哪个状态下运行是很重要的。大多数游戏常见的游戏状态示例包括：
- en: Loading
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载
- en: Starting
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始
- en: Running
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Paused
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Ending
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束
- en: GameWon
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏胜利
- en: GameLost
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏失败
- en: GameOver
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束
- en: NextLevel
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个等级
- en: Exiting
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出
- en: 'Of course, this is just a representative list, and each coder picks his or
    her own names for their game states. But I think that you get the idea: there
    are a lot of states that a game can be in, and that means it is important to be
    able to manage what happens during each state. Players tend to get angry if their
    character dies while the game was paused!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个代表性的列表，每个程序员都会为自己的游戏状态选择自己的名称。但我认为你已经明白了：游戏可以处于很多状态，这意味着能够管理每个状态发生的事情是很重要的。如果玩家在游戏暂停时角色死亡，他们往往会感到愤怒！
- en: Planning for state
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划状态
- en: We are going to expand our simple state machine to include several more game
    states. This is going to help us to better organize the processing of the game,
    and better define which processes should be running at any particular time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的简单状态机，以包括几个更多的游戏状态。这将帮助我们更好地组织游戏的处理，并更好地定义在任何特定时间应该运行哪些过程。
- en: 'The following table shows the game states that we are going to define for our
    game:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了我们将为我们的游戏定义的游戏状态：
- en: '| State | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Loading | The game is loading and the Splash screen should be displayed |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 加载 | 游戏正在加载，应显示启动画面 |'
- en: '| Menu | The main menu is showing |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 菜单 | 主菜单正在显示 |'
- en: '| Running | The game is actively running |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 运行 | 游戏正在积极运行 |'
- en: '| Paused | The game is paused |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 暂停 | 游戏已暂停 |'
- en: '| NextLevel | The game is loading the next level |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 下一个等级 | 游戏正在加载下一个等级 |'
- en: '| GameOver | The game is over and the stats are being displayed |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 游戏结束 | 游戏结束，正在显示统计数据 |'
- en: '| Credits | Showing the Credits screen |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 信用 | 显示信用屏幕 |'
- en: 'Here is our state diagram machine:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的状态图机器：
- en: '|   | Splash | Loading | Menu | Running | Paused | Next | GameOver | Credits
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|   | 启动画面 | 加载 | 菜单 | 运行 | 暂停 | 下一个 | 游戏结束 | 信用 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Input** | None | None | UI | All | UI | UI | UI | UI |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | 无 | 无 | UI | 所有 | UI | UI | UI | UI |'
- en: '| **Updating** | Splash | Splash | UI | All | UI | UI | UI | UI |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **更新** | 启动画面 | 启动画面 | UI | 所有 | UI | UI | UI | UI |'
- en: '| **Collision Detection** | None | None | None | All | None | None | None |
    None |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **碰撞检测** | 无 | 无 | 无 | 所有 | 无 | 无 | 无 | 无 |'
- en: '| **Spawning** | None | None | None | All | None | None | None | None |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **生成** | 无 | 无 | 无 | 所有 | 无 | 无 | 无 | 无 |'
- en: '| **Rendering** | Splash | Splash | Menu | Game | Game | Game | GameOver |
    Credits |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **渲染** | 启动画面 | 启动画面 | 菜单 | 游戏 | 游戏 | 游戏 | 游戏结束 | 信用 |'
- en: 'Finally, here is our state diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的状态图：
- en: '![Planning for state](img/8199OS_06_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![规划状态](img/8199OS_06_02.jpg)'
- en: It turns out that our state diagram will also double as a UI diagram. A UI diagram
    is a diagram of all of the screens in a program and how they interact with each
    other. It turns out that each time that we want to change to a different screen
    in our game, we are also changing to a different screen. This isn't exactly the
    case—when the game is paused, it doesn't launch a completely new screen. However,
    there is often a very close correlation between the UI diagram and the state diagram.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们的状态图也将作为UI图。UI图是程序中所有屏幕及其相互交互的图。结果是，每次我们想要在我们的游戏中切换到不同的屏幕时，我们也在切换到不同的屏幕。这并不完全是这样——当游戏暂停时，它不会启动一个全新的屏幕。然而，UI图和状态图之间通常有非常紧密的相关性。
- en: Looking at the state diagram, you can easily see the legal state changes versus
    the illegal state changes. For example, it is legal to change the state from playing
    to paused, but you can't change the state from playing to credits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 观察状态图，你可以很容易地看到合法的状态变化与非法的状态变化。例如，从播放状态变为暂停状态是合法的，但你不能从播放状态变为信用状态。
- en: Having this structure in place will guide us as we implement all of the final
    polish features that we want to add to our game.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此结构到位的情况下，它将指导我们实现我们想要添加到游戏中的所有最终润色功能。
- en: Defining the new state
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义新状态
- en: 'The first step in expanding our game state machine is adding the required `enums`.
    Replace the `GameState enum` code with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们的游戏状态机的第一步是添加所需的`enums`。用以下代码替换`GameState enum`代码：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we implement the polish features covered in this chapter, we will implement
    code that uses these game states.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们实现本章中涵盖的润色功能，我们将实现使用这些游戏状态的代码。
- en: Implementing the state machine
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态机
- en: 'In order for our state machine to have any effect, we need to modify the code
    so that key decisions are made based on the game state. There are three functions
    that game state affects in a big way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的状态机产生任何效果，我们需要修改代码，使得关键决策基于游戏状态。有三个函数受到游戏状态的重大影响：
- en: '**Update**: Some game states update game objects, while other game states update
    only the UI or a particular sprite'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：一些游戏状态更新游戏对象，而其他游戏状态只更新UI或特定的精灵'
- en: '**Render**: Different game states render different items'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染**：不同的游戏状态渲染不同的项目'
- en: '**Input**: Some game states accept all input, while other game states only
    process UI input'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**：一些游戏状态接受所有输入，而其他游戏状态只处理UI输入'
- en: It should come as no surprise then that we will be changing the `Update`, `Render`,
    and `ProcessInput` functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将更改`Update`、`Render`和`ProcessInput`函数，这应该不会令人惊讶。
- en: 'First, let''s modify the `Update` function. Change the `Update` function in
    `RoboRacer2D.cpp` to match the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改`Update`函数。将`RoboRacer2D.cpp`中的`Update`函数修改为以下代码：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are now using a `switch` statement to handle each game state.
    This is a whole lot more readable than using `if` statements, and it keeps the
    code much more structured. If we need to add another game state, we just add another
    `case` to the `switch` statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在使用`switch`语句来处理每个游戏状态。这比使用`if`语句可读性要好得多，并且使代码结构更加清晰。如果我们需要添加另一个游戏状态，我们只需在`switch`语句中添加另一个`case`。
- en: Notice that each `case` has its code to run specific to that game state. Some
    lines of code are duplicated (almost every state has some input), but this is
    a small price to pay for clarity. `GS_Running` has the most work to do, while
    `GS_Loading` has the least work to do. We will be adding code to each switch as
    we add polish features.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个`case`都有其代码来运行特定于该游戏状态的代码。一些代码行是重复的（几乎每个状态都有一些输入），但这为了清晰度而付出的微小代价。`GS_Running`需要做最多的工作，而`GS_Loading`需要做最少的工作。随着我们添加润色功能，我们将在每个开关中添加代码。
- en: 'Now, let''s give the `Render` function an upgrade. Replace the `Render` function
    with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们升级`Render`函数。用以下代码替换`Render`函数：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we have some work that needs to be done regardless of the game
    state. We need to clear the OpenGL buffer, and set the matrix to identity. Then
    we decide which items to render based on the game state, and finally, we swap
    the buffers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要做一些无论游戏状态如何都需要完成的工作。我们需要清除OpenGL缓冲区，并将矩阵设置为单位矩阵。然后我们根据游戏状态决定要渲染哪些项目，最后交换缓冲区。
- en: If you look closely, `GS_Running` and `GS_Paused` render the same items. This
    is because the pause and render buttons are rendered over the top of the gameplay
    screen, so we still need to render the entire game even when we are paused. We
    will be adding code to each switch as we add polish features.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，`GS_Running`和`GS_Paused`渲染相同的项目。这是因为暂停和渲染按钮渲染在游戏屏幕的顶部，所以即使我们在暂停时，我们仍然需要渲染整个游戏。随着我们添加润色功能，我们将为每个开关添加代码。
- en: 'Finally, we need to apply our state machine to the `ProcessInput` function.
    As the function is so long, I am only showing the top lines of the function. Change
    all of the lines above the `uiTimer += p_deltaTime;` statement to the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的状态机应用到`ProcessInput`函数上。由于该函数非常长，我仅显示函数的上部行。将所有在`uiTimer += p_deltaTime;`语句之上的行更改为以下代码：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we get the latest command. Then, depending on the game state, we perform
    the following actions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取最新的命令。然后，根据游戏状态，我们执行以下操作：
- en: Ignore and return if we are still in the loading state
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们仍然处于加载状态，则忽略并返回
- en: Reset the command to only handle UI commands if the game state is menu, paused,
    next level, or game over
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果游戏状态是菜单、暂停、下一级或游戏结束，则将命令重置为仅处理UI命令
- en: Leave the command unchanged if we are in the running game state
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们处于运行游戏状态，则保持命令不变
- en: This is exactly what we did in the prior versions, except we only had two game
    states to deal with in the prior versions. Once the command is handled, we move
    on to the `uiTimer += p_deltaTime;` (everything after this line is unchanged from
    the prior versions).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在先前版本中做的，只是先前版本中我们只处理了两个游戏状态。一旦处理了命令，我们就继续到`uiTimer += p_deltaTime;`（此行之后的内容与先前版本相同）。
- en: Making a splash
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作启动画面
- en: A splash menu adds a touch of class to your game and also does a little bragging.
    Typically, the splash screen shows off your company logo. In fact, many game projects
    have multiple studios that work on them, so there are often multiple splash screens.
    We will use just one!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 启动菜单为你的游戏增添了一丝格调，同时也做了一点炫耀。通常，启动画面会展示你的公司标志。实际上，许多游戏项目由多个工作室共同制作，因此经常会有多个启动画面。我们将只使用一个！
- en: It is important to get the splash screen up and running as soon as possible,
    so we will do that before we perform any other loading. Part of the function of
    a splash screen is to give the player something pretty to look at while the rest
    of the game is loading.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽快让启动画面运行起来非常重要，所以我们将在执行任何其他加载之前先做这件事。启动画面的部分功能是在游戏的其他部分加载时，给玩家一些漂亮的东西来看。
- en: Creating the splash screen
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建启动画面
- en: It's up to you to create a splash screen that defines your game. For convenience,
    we have included one in the code resource package for this chapter called `splash.png`.
    Make sure you copy `splash.png` into your project. The only requirement for the
    splash image is that it is 800 x 600 pixels, the same resolution as our game screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个定义你游戏的启动画面取决于你。为了方便，我们在本章的代码资源包中包含了一个名为`splash.png`的启动画面。确保将`splash.png`复制到你的项目中。启动画面的唯一要求是它必须是800
    x 600像素，与我们的游戏屏幕分辨率相同。
- en: Defining the splash screen
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义启动画面
- en: 'As with all images in this game, we will implement the splash screen as a sprite.
    Declare the splash sprite at the top of `RoboRacer2D.cpp`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏中所有图像一样，我们将启动画面实现为一个精灵。在`RoboRacer2D.cpp`的顶部声明启动精灵：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also want to define some timers for the splash screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为启动画面定义一些计时器：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we want to define the splash screen separately, we will create a separate
    function just to load it. Create the `LoadSplash` function using the following
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望将启动画面单独定义，我们将创建一个单独的函数来加载它。使用以下代码创建`LoadSplash`函数：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are not going to make a significant change to the `StartGame` function.
    We are going to only load the splash screen, and defer loading the other game
    resources. This will get our splash screen up as soon as possible. Change the
    `StartGame` function so that it looks like the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对`StartGame`函数进行重大修改。我们只将加载启动画面，并推迟加载其他游戏资源。这将尽快让启动画面显示出来。将`StartGame`函数修改为以下代码：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we only load the splash resources and set a few variables here.
    We also set the splash timer so that it will show up for at least five seconds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里只加载启动画面资源并设置了一些变量。我们还设置了启动画面计时器，以确保它至少显示五秒钟。
- en: 'Next, modify the `GS_Splash` case in the `Update` function to look like the
    following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`Update`函数中的`GS_Splash`情况，使其看起来像以下代码：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code updates the splash timer. When the timer exceeds our threshold, then
    the game state changes to `GS_Menu`. We will define the code to load the next
    menu.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码更新启动画面计时器。当计时器超过我们的阈值时，游戏状态将变为`GS_Menu`。我们将定义加载下一个菜单的代码。
- en: 'Modify the `GS_Splash` case in the `Render` function to look like the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Render`函数中的`GS_Splash`情况，使其看起来像以下代码：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the splash sprite is only a static image, you may wonder why we update the
    splash sprite. While an update has no effect on our current code, consider a case
    where I wanted to implement a dynamic, animated splash screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于启动精灵只是一个静态图像，你可能想知道为什么我们要更新启动精灵。虽然更新对我们的当前代码没有影响，但考虑一下我想实现一个动态、动画启动画面的情况。
- en: Loading our resources
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载我们的资源
- en: 'If you have been paying attention, then you should realize that we removed
    the `LoadTextures` call from the `StartGame` function. Instead, we are going to
    load the textures in the `GameLoop` function. Change `GameLoop` so that it looks
    like the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在注意，你应该意识到我们从`StartGame`函数中移除了`LoadTextures`调用。相反，我们将在`GameLoop`函数中加载纹理。将`GameLoop`修改为以下代码：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you recall, `GameLoop` is called every frame. We need `GameLoop` to be running
    to display our splash screen, which we have already loaded. But on the first call
    to `GameLoop`, we haven't loaded our other resources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`GameLoop`每帧都会被调用。我们需要`GameLoop`运行以显示我们的启动屏幕，我们已经加载了它。但在第一次调用`GameLoop`时，我们还没有加载其他资源。
- en: We check to see whether our game state is `GS_Splash`. If it is, we call load
    textures, and immediately change the game state to `GS_Loading`. If we didn't
    change the game state, then the game would attempt to load the textures every
    frame, which would be a very bad thing! This is another practical example of why
    we define different game states in our state machine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查游戏状态是否为`GS_Splash`。如果是，我们调用加载纹理，并立即将游戏状态更改为`GS_Loading`。如果我们没有更改游戏状态，那么游戏将尝试在每一帧加载纹理，这将是非常糟糕的事情！这是我们在状态机中定义不同游戏状态的另一个实际例子。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a way, we haven't created a true splash screen. That is because our splash
    still depends on Windows and OpenGL initializing before the splash screen can
    even be loaded and rendered. True splash screens use a snippet of code that does
    not depend on all of this initialization so that they can load before everything
    else. Unfortunately, that level of detail is beyond the scope of our book. Sometimes,
    the splash screen will run on a separate thread so that it is independent of the
    startup code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们还没有创建一个真正的启动屏幕。这是因为我们的启动屏幕仍然依赖于Windows和OpenGL在启动屏幕可以加载和渲染之前进行初始化。真正的启动屏幕使用一段不依赖于所有这些初始化的代码片段，以便它们可以在其他所有内容之前加载。不幸的是，这个层面的细节超出了我们书籍的范围。有时，启动屏幕将在单独的线程上运行，以便它独立于启动代码。
- en: '![Loading our resources](img/8199OS_06_03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![加载我们的资源](img/8199OS_06_03.jpg)'
- en: When you run the game now, you should see the splash screen display, but then
    nothing else happens. This is because we changed the game state to `GS_Menu` in
    the `Update` function, and we have not coded for that game state yet! If you want
    to test your splash screen, change `m_gameState = GameState::GS_Menu` to `m_gameState
    = GameState::GS_Running` in the `Update` function. Just don't forget to change
    it back before you move on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行游戏时，你应该看到启动屏幕显示，但随后没有其他动作发生。这是因为我们在`Update`函数中将游戏状态更改为`GS_Menu`，而我们还没有为该游戏状态编写代码！如果你想测试你的启动屏幕，将`Update`函数中的`m_gameState
    = GameState::GS_Menu`更改为`m_gameState = GameState::GS_Running`。只是别忘了在继续之前将其改回。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The ability to change your game state allows you to reroute the flow of your
    game. This is very useful, for example, when you are trying to code a new game
    state but you aren't ready to run it in the game yet. Once the new game state
    is coded, then you can wire it in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 改变游戏状态的能力让你能够重新引导游戏流程。这在尝试编写新的游戏状态但尚未准备好在游戏中运行时非常有用。一旦新的游戏状态编写完成，你就可以将其连接到游戏中。
- en: What's on the menu?
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单上有什么？
- en: Main menus may have disappeared in many applications, but they are still alive
    and well in games. The main menu gives the player a chance to decide what to do
    once the game has loaded. We are going to create a simple menu that allows the
    player to start the game, display the credits, or exit the game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单在很多应用程序中可能已经消失了，但在游戏中它们仍然存在且运行良好。主菜单在游戏加载后给玩家一个决定做什么的机会。我们将创建一个简单的菜单，允许玩家开始游戏、显示信用信息或退出游戏。
- en: Creating the menu
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜单
- en: Our menu will be built out of two components. First, we will load an image to
    use as the background. Next, we will load additional images to use as UI buttons.
    Together, these images will create a screen that will allow the player to navigate
    our game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个组件构建菜单。首先，我们将加载一个图像作为背景。接下来，我们将加载额外的图像作为UI按钮。这些图像共同创建一个屏幕，允许玩家导航我们的游戏。
- en: 'We will start by defining a sprite to represent the menu. Add the following
    line of code to the variable declarations in `RoboRacer2D.cpp`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个精灵来表示菜单。将以下代码行添加到`RoboRacer2D.cpp`中的变量声明部分：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will instantiate the menu in the `LoadTextures` function. Add the
    following code to `LoadTextures`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`LoadTextures`函数中实例化菜单。将以下代码添加到`LoadTextures`：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure that you have downloaded the `menu.png` texture from the book website,
    or that you have created your own background at 800 by 600 pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经从书籍网站下载了`menu.png`纹理，或者你已经创建了自己的800x600像素的背景。
- en: 'Now, we must modify the `Update` and `Render` functions. Modify the `GS_Menu`
    case in `Update` to the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须修改`Update`和`Render`函数。将`Update`中的`GS_Menu`情况修改为以下代码：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, modify the `GS_Menu` case in the `Render` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`Render`函数中的`GS_Menu`情况：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run the game now, the splash screen should display for five seconds,
    followed by the menu screen.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，启动屏幕应该显示五秒钟，然后是菜单屏幕。
- en: Defining the menu buttons
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义菜单按钮
- en: Our next task is to add buttons to the menu screen that the player can click.
    These buttons will work similar to the pause and resume buttons that we have already
    created.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是向菜单屏幕添加玩家可以点击的按钮。这些按钮的工作方式将与我们已经创建的暂停和继续按钮类似。
- en: 'We will start by declaring variables for the buttons. Add the following declarations
    to the variables section in `RoboRacer2D.cpp`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为按钮声明变量。将以下声明添加到`RoboRacer2D.cpp`中的变量部分：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These three pointers will manage the three buttons on our main menu. Next,
    add the following code to `LoadTextures` to instantiate the buttons:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个指针将管理主菜单上的三个按钮。接下来，将以下代码添加到`LoadTextures`中以实例化按钮：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code is mostly the same as the code that we used to instantiate the pause
    and resume buttons. One small difference is that we set all three buttons to be
    visible. Our code already enforces that these buttons will not render unless we
    are in the game state `GS_Menu`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与我们用来实例化暂停和继续按钮的代码相同。唯一的小区别是我们将所有三个按钮都设置为可见。我们的代码已经强制这些按钮只有在游戏状态`GS_Menu`时才会渲染。
- en: We do, however, want to set the buttons as inactive. This way the `input` class
    will ignore them until we want them to be activated.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望将按钮设置为不活动状态。这样，`input`类就会忽略它们，直到我们想要激活它们。
- en: 'As with all of our objects, we now need to wire them into the `Update` and
    `Render` functions. Change the `GS_Menu` case in the `Update` function to the
    following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所有的对象一样，我们现在需要将它们连接到`Update`和`Render`函数。将`Update`函数中的`GS_Menu`情况更改为以下代码：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is where we set the buttons on our menu to be active. We want to guarantee
    that the buttons on the menu are active when we are in the game state `GS_Menu`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将菜单上的按钮设置为活动状态的地方。我们希望确保在游戏状态`GS_Menu`时菜单上的按钮是活动的。
- en: 'Next, change the `GS_Menu` case in the `Render` function to the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`Render`函数中的`GS_Menu`情况更改为以下代码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order for the buttons to actually do something, we need to add the following
    code to the `CM_UI` case in `ProcessInput`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让按钮真正做些事情，我们需要将以下代码添加到`ProcessInput`中的`CM_UI`情况：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we change the game state if the play button or credits button are
    clicked (if the exit button is clicked, we simply post the quit message). Notice
    that we have to do a little button management, setting the buttons on the menu
    to be inactive once we are no longer in the `GS_Menu` game state. This is because
    our input class checks the input for all buttons that are active. Leaving the
    buttons active would mean that they could still be clicked even though they are
    not being displayed on the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果点击了播放按钮或信用按钮（如果点击了退出按钮，我们只需发送退出消息）。注意，我们必须进行一些按钮管理，当我们不再处于`GS_Menu`游戏状态时，将菜单上的按钮设置为不活动状态。这是因为我们的输入类会检查所有活动的按钮。如果按钮保持活动状态，则意味着即使它们没有显示在屏幕上，仍然可以被点击。
- en: We don't have to set the buttons to be invisible. This is because changing the
    state will automatically stop these buttons from updating or rendering. The same
    is true of the menu screen. Once the game state is changed, it will not render
    or update. This is one of the big advantages of utilizing a state machine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必将按钮设置为不可见。这是因为改变状态将自动停止这些按钮的更新或渲染。菜单屏幕也是如此。一旦游戏状态改变，它将不会渲染或更新。这是利用状态机的重大优势之一。
- en: '![Defining the menu buttons](img/8199OS_06_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![定义菜单按钮](img/8199OS_06_04.jpg)'
- en: If you run the program right now, the main menu will display. If you click the
    play button, the game will start. If you click the exit button, the game will
    exit. We will implement the credit screen next.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，主菜单将显示。如果你点击播放按钮，游戏将开始。如果你点击退出按钮，游戏将退出。我们将接下来实现信用屏幕。
- en: Getting some credit
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得一些信用
- en: Everyone likes to get credit for their hard work! Most games will implement
    a credits screen that shows the name and function of each person involved in creating
    the game. For AAA titles, this list may be as long as a list for a movie. For
    smaller, independent games, this list might be three people.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢为自己的辛勤工作获得认可！大多数游戏都会实现一个信用屏幕，显示每个参与创建游戏的人的名字和职能。对于AAA级游戏，这个列表可能和电影列表一样长。对于小型独立游戏，这个列表可能只有三个人。
- en: Creating the credits screen
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建信用屏幕
- en: Similarly to the main menu, the credits screen will be based on a background
    image and a button that can be clicked. We will also need to add text to the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与主菜单类似，信用屏幕将基于背景图像和可点击的按钮。我们还需要在屏幕上添加文本。
- en: 'Let''s start by declaring a pointer for our screen. Add the following declaration
    to the variables section of `RoboRacer2D.cpp`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `RoboRacer2D.cpp` 的变量部分声明我们的屏幕指针开始。添加以下声明：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will instantiate the credits screen in `LoadTextures`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `LoadTextures` 中实例化信用屏幕：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we wire the credits screen into `Update`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将信用屏幕连接到 `Update`：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also update `Render`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了 `Render`：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Getting back to the main menu
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回主菜单
- en: 'We now need to add a button that allows us to get from the credits screen back
    to the main menu. We first declare the pointer in the variables declaration section:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个按钮，允许我们从信用屏幕返回主菜单。我们首先在变量声明部分声明指针：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then instantiate the button in `LoadTextures`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在 `LoadTextures` 中实例化按钮：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s add the button to `Update`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Update` 中添加按钮：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also update `Render`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了 `Render`：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly to the menu buttons, we now need to add code to the case `Input::Command::CM_UI:`
    case in `ProcessInput` to handle clicking on the menu button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与菜单按钮类似，我们现在需要在 `ProcessInput` 中的 `Input::Command::CM_UI:` 情况中添加代码来处理点击菜单按钮：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the menu button is clicked, we change the game state back to menu, and
    set the menu button to be inactive. Due to the code that we have already written,
    the menu screen will automatically display.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当菜单按钮被点击时，我们将游戏状态改回菜单，并将菜单按钮设置为不活动。由于我们已经编写的代码，菜单屏幕将自动显示。
- en: '![Getting back to the main menu](img/8199OS_06_05.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![返回主菜单](img/8199OS_06_05.jpg)'
- en: Working with fonts
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与字体一起工作
- en: Until now, we embedded any text that we needed inside of an existing texture.
    However, there are times when we may want to have the code decide what text to
    display. For example, on our credits screen, we don't want to make a graphic for
    each person's name who took part in creating the game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在现有的纹理中嵌入任何需要的文本。然而，有时我们可能希望代码决定要显示的文本。例如，在我们的信用屏幕上，我们不想为参与创建游戏的每个人的名字制作图形。
- en: Creating the font
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建字体
- en: 'We need a way to render text directly to the screen, and this means that we
    also need a way to define the font that we want to use when rendering the text.
    First, we need to add a global variable that services as a handle to our fonts.
    Add the following line to the variable declarations in the code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法将文本直接渲染到屏幕上，这意味着我们还需要一种方法来定义在渲染文本时想要使用的字体。首先，我们需要添加一个全局变量，作为我们字体的句柄。将以下行添加到代码中的变量声明部分：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need to add the following code to create the font:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加以下代码来创建字体：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code creates a font using three main elements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用三个主要元素创建字体。
- en: First, we use `glGenLists` to create 96 display lists to hold each letter of
    our font. A display list is basically a buffer that can hold rendering data. Next,
    we call `CreateFont` to create a Windows font. The parameters of the `CreateFont`
    function specify the type of font that we want to create. Finally, we use `wglUseFontBitmaps`
    to assign our new font to the font handle that we created earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `glGenLists` 创建 96 个显示列表来存储我们字体的每个字母。显示列表基本上是一个可以存储渲染数据的缓冲区。接下来，我们调用
    `CreateFont` 创建一个 Windows 字体。`CreateFont` 函数的参数指定了我们想要创建的字体的类型。最后，我们使用 `wglUseFontBitmaps`
    将我们创建的新字体分配给之前创建的字体句柄。
- en: One little twist is that we have to create a temporary `HFONT` object called
    `tempFont` with all the properties, then we assign `tempFont` to `newFont` and
    delete `tempFont`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小技巧是我们必须创建一个具有所有属性的临时 `HFONT` 对象，称为 `tempFont`，然后将 `tempFont` 分配给 `newFont`
    并删除 `tempFont`。
- en: 'We will want to delete the display lists when the program closes down, so add
    the following utility function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序关闭时，我们想要删除显示列表，所以添加以下实用函数：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code simply uses `glDeleteLists` to delete the display lists that we created
    to hold our font.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码简单地使用 `glDeleteLists` 删除我们创建来存储字体的显示列表。
- en: Drawing text
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制文本
- en: 'Now that we have a font, we need to have a function that will render text to
    the screen. Add the following function to the code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了字体，我们需要一个函数将文本渲染到屏幕上。将以下函数添加到代码中：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code takes a string and an *x* and *y* position, and draws the text at
    that position. It also takes `r`, `g`, and `b` parameters to define the text color:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码接受一个字符串和一个 *x* 和 *y* 位置，并在该位置绘制文本。它还接受 `r`、`g` 和 `b` 参数来定义文本颜色：
- en: '`glBindTexture`(`GL_TEXTURE_2D`, `0`): This tells OpenGL that we are going
    to be working with 2D textures (i.e. the fonts) `glColor3f(r, g, b)`: This sets
    the color of the font.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glRasterPos2f`: This is used to set the current draw position on the screen.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glPushAttrib(GL_LIST_BIT)`: This tells OpenGL that we are going to render
    using display lists.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glListBase`: This sets the current start of the list. We subtract 32 because
    the ASCII value for a space is 32, and we don''t use any characters with lower
    ASCII values.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glCallLists`: This is used to retrieve the lists for each character in the
    text.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glPopAttrib`: This returns the OpenGL attribute to its previous value.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we are ready to draw our credits text:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we set the position on the screen where we want to draw, then we use
    the `DrawText` function to actually perform the drawing. The first line adds me
    (a subtle indulgence), and the second line is for you!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Wiring in the font support
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a few more book keeping tasks to perform to get the font support to
    work. First, modify the `GameLoop` code, adding the highlighted line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will create our fonts when the game starts up.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, fill out the `GS_Credits` case of the `m_gameState` switch in the `Render`
    function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This draws the credits text when the game state changes to `GS_Credits`. Congratulations!
    You can finally get the credit that you deserve!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Level up!
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of the fun in games is trying to increase your score. Part of good game
    design is to make the game challenging to play, but not so challenging that the
    player cannot score or improve.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Most players also get better at a game as they play, so if the game difficulty
    does not increase, the player will eventually get bored because the player will
    no longer be challenged.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We will start by simply displaying the score on the screen so that the player
    can see how well they are doing. Then we will discuss techniques that are used
    to continually increase the difficulty of the game, thus steadily increasing the
    challenge.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the score
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already learned how to display text on the screen when we were creating the
    credits screen. Now, we will use the same techniques to display the score.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we already have a mechanism to keep track of the score. Every
    sprite has a value property. For pickups, we assign a positive value so that the
    player gains points for each pickup. For enemies, we assign a negative value so
    that the player loses points whenever they collide with an enemy. We store the
    current score in the value property of the player.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `RoboRacer2D.cpp` to create the `DrawScore` function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code works just like the `DrawCredits` function that we created earlier.
    First, we create a character string that holds the current score and a caption,
    then we use `DrawText` to render the text.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to wire this into the main game. Modify the `GS_Running` case
    of the `m_gameState` switch in the `Render` function with the highlighted line:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The score will display both when the game is running and when the game is paused.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Game progression
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to add progression to the game, we need to have certain thresholds
    established. For our game, we will set three thresholds:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Each level will last two minutes
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player receives less than five pickups during a level, the game will
    end, and the game over screen will be displayed
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player receives five or more pickups, then the level ends and the next
    level screen is displayed
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each level that the player successfully completes, we will make things
    a little more difficult. There are many ways that we could increase the difficulty
    of each level:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Increase the spawn time for pickups
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrease the speed of the robot
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep things simple, we will only do one of these. We will increase the spawn
    time threshold for pickups by .25 seconds for each level. With pickups spawning
    less often, the player will eventually receive too few pickups, and the game will
    end.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Defining game levels
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s set up the code for level progression. We will start by defining a timer
    to keep track of how much time has passed. Add the following declarations to `RoboRacer2D.cpp`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will initialize the variables in the `StartGame` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We are setting up a timer that will run for 120 seconds, or two minutes. At
    the end of two minutes the level will end and the spawn time for pickups will
    be incremented by .25 seconds. We will also check to see whether the player has
    received five pickups. If not, the game will be over.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the logic for the level progression, let''s add a new function called
    `NextLevel` by adding the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As stated previously, we check to see whether the number of pickups that the
    robot has is less than the pickup threshold. If so, we change the game state to
    `GS_GameOver`. Otherwise, we reset the level timer, reset the pickups received
    counter, increment the pickup spawn timer, and set the game state back to `GS_Running`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to add some code to update the level timer and check to see whether
    the level is over. Add the following code to the `GS_Running` case in the `Update`
    function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code updates the level timer. If the timer exceeds our threshold, then
    call `NextLevel` to see what happens next.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add two lines of code to `CheckCollisions` to count the
    number of pickups received by the player. Add the following highlighted line of
    code to `CheckCollisions`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Game stats
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be nice for the player to be able to see how they did between each
    level. Let''s add a function to display the player stats:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will now wire this into the next level screen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The next level screen
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the logic in place to detect the end of the level, it is time
    to implement our next level screen. By now, the process should be second nature,
    so let''s try an abbreviated approach:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a pointer to the screen:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instantiate the sprite in `LoadTextures`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Modify the `GS_NextLevel` case in the `Update` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Modify the `GS_NextLevel` case in the `Render` function to look like the following
    code::'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Render` 函数中的 `GS_NextLevel` 情况，使其看起来像以下代码：
- en: '[PRE51]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Continuing the game
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续游戏
- en: 'Now, we need to add a button that allows the player to continue the game. Again,
    you have done this so many times, so we will use a shorthand approach:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个按钮，允许玩家继续游戏。同样，你已经这样做了很多次，所以我们将使用一种简化的方法：
- en: 'Declare a pointer for the button:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明按钮指针：
- en: '[PRE52]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instantiate the button in `LoadTextures`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LoadTextures` 中实例化按钮：
- en: '[PRE53]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add this code to `Update`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到 `Update` 中：
- en: '[PRE54]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add this code to `Render`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到 `Render` 中：
- en: '[PRE55]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add this code to `ProcessInput`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到 `ProcessInput` 中：
- en: '[PRE56]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Clicking the continue button simply changes the game state back to `GS_Running`.
    The level calculations have already occurred when `NextLevel` was called.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 点击继续按钮只是将游戏状态改回 `GS_Running`。当调用 `NextLevel` 时，等级计算已经发生。
- en: Game over
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: As the saying goes, all good things must come to an end. If the player doesn't
    meet the pickup threshold, the game will end, and the game over screen will be
    displayed. The player can choose to replay the game or exit.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗话所说，所有美好的事物都必须结束。如果玩家没有达到拾取阈值，游戏将结束，并显示游戏结束界面。玩家可以选择重新玩游戏或退出。
- en: The game over screen
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束界面
- en: 'Our last screen is the game over screen. By now, the process should be second
    nature, so let''s try an abbreviated approach:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的屏幕是游戏结束界面。到现在，这个过程应该已经变得很自然，所以让我们尝试一种简化的方法：
- en: 'Declare a pointer to the screen:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明屏幕指针：
- en: '[PRE57]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Instantiate the sprite in `LoadTextures`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LoadTextures` 中实例化精灵：
- en: '[PRE58]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Change the `GS_GameOver` case in the `Update` function to look like the following
    code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Update` 函数中的 `GS_GameOver` 情况修改为以下代码：
- en: '[PRE59]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following code to `Render`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Render` 中：
- en: '[PRE60]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As a bonus, we will also draw the game stats on the game over screen.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，我们还将绘制游戏统计信息在游戏结束界面上。
- en: '![The game over screen](img/8199OS_06_09.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束界面](img/8199OS_06_09.jpg)'
- en: Replaying the game
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新玩游戏
- en: 'We need a way to reset the game to its initial state. So, let''s create a function
    to do this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来将游戏重置到其初始状态。所以，让我们创建一个函数来做这件事：
- en: '[PRE61]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we need to add a button that allows the player to replay the game. Again,
    as you have done this so many times, we will use a shorthand approach:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个按钮，允许玩家重新玩游戏。同样，由于你已经这样做了很多次，我们将使用一种简化的方法：
- en: 'Declare a pointer for the button:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明按钮指针：
- en: '[PRE62]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Instantiate the button in `LoadTextures`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LoadTextures` 中实例化按钮：
- en: '[PRE63]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add the following code to `Update`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Update` 中：
- en: '[PRE64]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following code to `Render`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Render` 中：
- en: '[PRE65]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the following code to `ProcessInput`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ProcessInput` 中：
- en: '[PRE66]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice how we are reusing the exit button in the `Update` function. Also, if
    the player wants to replay the game, we call the `RestartGame` function when the
    player clicks the replay button. This resets all of the game variables and allows
    the player to start all over.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在 `Update` 函数中重复使用退出按钮。此外，如果玩家想要重新玩游戏，当玩家点击重玩按钮时，我们将调用 `RestartGame` 函数。这将重置所有游戏变量，并允许玩家从头开始。
- en: '![Replaying the game](img/8199OS_06_07.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![重新玩游戏](img/8199OS_06_07.jpg)'
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered a lot of ground in this chapter. The focus of the chapter is to add
    all of the final elements to the game that make it a truly polished game. This
    involves adding a lot of screens and buttons, and to manage all of this, we introduced
    a more advanced state machine. The state machine acts like a traffic director,
    routing the game to the correct routines depending on the game state.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。本章的重点是向游戏中添加所有最终元素，使其成为一个真正精致的游戏。这涉及到添加很多屏幕和按钮，为了管理所有这些，我们引入了一个更高级的状态机。状态机就像交通指挥官，根据游戏状态将游戏路由到正确的例程。
- en: In the next chapter, we will add sound effects and music to our game!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的游戏添加音效和音乐！
