<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Decoupling Code via the Factory Method Pattern</h1>
            

            
                
<p class="calibre2">Every project and every game design is going to change. One of the goals of object-oriented programming is to program with that change in mind. This means writing flexible and reusable code so that, when changes happen, the project doesn't fall apart. Unfortunately, the requirements are never fully known and the vision of the designer is never 100% complete. The good news is that newly added features may interact with old features in unexpectedly fun ways, leading to unplanned features being created, which can make for a completely different, and more enjoyable, game.</p>
<p class="calibre2">In the worst-case scenario, the game design may not be fun at all, which can lead to drastic changes in game object types, object behaviors, and even the design of the entire game. In this case, we want to be able to rework our game to try new possibilities with the least amount of change to code. Changing code takes time to write, test, and debug, and any time new code is added, it has the possibility of causing bugs in older code.</p>
<p class="calibre2">Since we know that our design will change, we must plan for that change by following good design principles and utilizing design patterns to solve common problems. This includes using flexible designs such as the Component Object Model to avoid inheritance hierarchies. This includes using the State pattern and finite state machines to avoid complex <kbd class="calibre14">if</kbd> statements and cascading <kbd class="calibre14">if else</kbd> chains that lead to bugs any time a change occurs. This also includes things such as striving for low coupling and avoiding <em class="calibre12">hardcoding</em> anything.</p>
<p class="calibre2">We all know that as programmers, we should avoid <em class="calibre12">magic numbers</em>. We don't want to see seemingly random or odd numbers in our code. A hardcoded number isn't descriptive enough, which makes the code hard to read, maintain, and debug. If we need to change a magic number, we have to spend time searching our code for every time it appears. Unfortunately, these hardcoded values tend to change a lot during development. In the real world, gravity may be 9.8 m/s<sup class="calibre30">2</sup>, but in the game world, we may need to adjust it so the game is more fun, or possibly change it at runtime so the player can walk on the ceiling.</p>
<p class="calibre2">When we think about hard coding, we usually think about magic numbers. However, a call to the <kbd class="calibre14">new</kbd> operator using a concrete class type such as a new <kbd class="calibre14">ChaseAIComponent</kbd> may be readable, but it is just as likely to change as the value of gravity or the size of an array.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, you will be focusing on a common interface to create new objects without the need to call constructors directly. First, we will look at reasons why a <kbd class="calibre14">switch</kbd> statement can be harmful. Next we will look at a design principle that leads us to our final solution, a factory. Then we will look at few different ways to design our factories to make them flexible and reusable.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objective</h1>
            

            
                
<p class="calibre2">Over the course of this chapter, we will be looking at a few more important concepts and principles that can make our programs better. Here is an outline of what we will cover and your tasks for this chapter:</p>
<ul class="calibre17">
<li class="calibre18">Learning why using <kbd class="calibre14">switch</kbd> statements can be bad</li>
<li class="calibre18">Learning the Dependency Inversion Principle</li>
<li class="calibre18">Learning the Factory Method pattern</li>
<li class="calibre18">Building a Component, Stage, and Object Factory</li>
<li class="calibre18">Improve your Factories by using templates</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The trouble with switch statements</h1>
            

            
                
<p class="calibre2">When first learning to program, simply understanding the grammar of the language is very difficult. Often, new programmers focus on the syntax of a function call or <kbd class="calibre14">for</kbd> loop and they don't even think about making reusable, maintainable code. This is partly because they jump into the coding without planning anything out. This is true for games as well. Often, new programmers want to get straight to writing the game and they forget about things such as user interface and pause menus. Things such as the window resolution, enemy placement in the stages, and even where the mouse should be when clicking buttons will be hardcoded. Here is code from one of the authors' first games. This was a section in the <kbd class="calibre14">MainMenu</kbd> function that would switch the game into the Load state when the button was clicked. The variable <kbd class="calibre14">p</kbd> is the location of the mouse:</p>
<pre class="calibre23">
if ((p.x &gt; .15 * GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; <br class="title-page-name"/>    (p.x &lt; .42 * GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; <br class="title-page-name"/>    (p.y &gt; .58 * GetSystemMetrics(SM_CYSCREEN)) &amp;&amp; <br class="title-page-name"/>    (p.y &lt; .70 * GetSystemMetrics(SM_CYSCREEN))) <br class="title-page-name"/>  { <br class="title-page-name"/>    if (mousedown) <br class="title-page-name"/>    { <br class="title-page-name"/>      mGameState = TCodeRex::LOAD; <br class="title-page-name"/>      mGameLevel = L0; <br class="title-page-name"/>    } <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Code similar to this was repeated (without a loop) four times, because there were four buttons in the <kbd class="calibre14">MainMenu</kbd>. Of course, there were better (much better) ways to write this code. It is important to separate game stages from the <kbd class="calibre14">Graphics</kbd> class for one, and buttons can manage themselves if they are written correctly. However, the worst part of this old code base was how game stages were changed.</p>
<p class="calibre2">In that game, there was an <kbd class="calibre14">Update</kbd> function in the <kbd class="calibre14">Engine</kbd> class that contained a 507-line-long <kbd class="calibre14">switch</kbd> statement. This included a <kbd class="calibre14">switch</kbd> within a <kbd class="calibre14">switch</kbd> for situations where there needed to be a menu stage, but there were multiple menus to choose from. Here is some sample code from when a level needed to be loaded:</p>
<pre class="calibre23">
case TCodeRex::LOAD: <br class="title-page-name"/>{ <br class="title-page-name"/>StopGameMusic(); <br class="title-page-name"/>StopMenuMusic(); <br class="title-page-name"/>switch (mGameLevel) <br class="title-page-name"/>{ <br class="title-page-name"/>case TCodeRex::L0: <br class="title-page-name"/>{ <br class="title-page-name"/>  grafx.LoadScreen(mLoading); <br class="title-page-name"/>  mLoading = true; <br class="title-page-name"/>  if (ObjectMgr-&gt;LoadLevel(".\\Levels\\Level_00.txt")) <br class="title-page-name"/>  { <br class="title-page-name"/>    mPlayer1-&gt;SetPhysics().setPosition( <br class="title-page-name"/>    (Physics::real)ObjectMgr-&gt;PlayerX, <br class="title-page-name"/>    (Physics::real)ObjectMgr-&gt;PlayerY, 0.0f); <br class="title-page-name"/> <br class="title-page-name"/>    grafx.GetCamera().Move( <br class="title-page-name"/>      ObjectMgr-&gt;PlayerX - 500, <br class="title-page-name"/>      ObjectMgr-&gt;PlayerY - 500); <br class="title-page-name"/>    <br class="title-page-name"/>    ObjectMgr-&gt;AddToList(mPlayer1); <br class="title-page-name"/>    mPlayer1-&gt;SetHealth(100); <br class="title-page-name"/>    mBGTexture = grafx.GetTextureMgr().GetTile(49); <br class="title-page-name"/>    mplaying = true; <br class="title-page-name"/>    mGameState = TCodeRex::PLAY; <br class="title-page-name"/>  } <br class="title-page-name"/>    else <br class="title-page-name"/>      mGameState = TCodeRex::MENU; <br class="title-page-name"/>    break; <br class="title-page-name"/>}//end case TCODEREX::LOAD 
</pre>
<p class="calibre2">If you feel like that is hard to look at, you are right. For some reason, the stage-switching code was responsible for setting the player's health and position, moving the camera, setting the background texture, and going back to the menu if something failed to load.</p>
<p class="calibre2">The reason we are showing this is so you can see an example of really bad code. This <kbd class="calibre14">Engine</kbd> class was tightly coupled with the <kbd class="calibre14">graphics</kbd> class, the <kbd class="calibre14">physics</kbd> class, the <kbd class="calibre14">object manager</kbd> class, and the <kbd class="calibre14">player</kbd> class. If any of these classes changed or were removed, the code in the <kbd class="calibre14">Engine</kbd> class needed to change. Another problem is that there are many dependencies here, which means a change to any of the classes above will cause the code to be recompiled as well.</p>
<p class="calibre2">One of the authors was in a similar situation a few years later while working on an iPhone game as contract programmer. The original design called for only two stages, the main menu and the gameplay. Since the plan was so simple, code similar to what we saw above was used. This soon became a problem, because all game designs change even if the project is only three months long.</p>
<p class="calibre2">After one month, the game was completed to specification, including a level editor so the designer could create as many levels as were needed. The goal was to spend the rest of the time adding effects and polish to the game. However, every week, the producer and designer would come and say they needed a new menu or transition screen.</p>
<p class="calibre2">In the end, the game design called for an options menu, a level select menu, a credits screen, a celebration screen every 10 levels, and a congratulations screen after completing the game. The simple two-stage code that was originally written ended up being a hacked-together mess because of the fast development timeline and the constant addition of new features. One horrible line of code was similar to this:</p>
<pre class="calibre23">
if(levelCounter == 81) <br class="title-page-name"/>  ShowCongratsScreen(); 
</pre>
<p class="calibre2">This <em class="calibre12">worked</em> because there were 80 levels in the game and the <kbd class="calibre14">levelCounter</kbd> incremented after completing a level. After seeing game code like this, we hope you understand why it is important to plan for change to occur.</p>
<p class="calibre2">In <a href="part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 3</a>, <em class="calibre12">Creating Flexibility with the Component Object Model</em>, we saw how to create components for our game object so we can easily handle changes to our object design. This is an important step in creating flexible code; however, when we create an object in our stage, we still must use new to hardcode the concrete types that make up our object:</p>
<pre class="calibre23">
M5Object* pObj                = new M5Object(AT_Player); <br class="title-page-name"/>GfxComponent* pGfxComp        = new GfxComponent; <br class="title-page-name"/>PlayerInputComponent* pInput  = new PlayerInputComponent; <br class="title-page-name"/>ClampComponent* pClamp        = new ClampComponent; <br class="title-page-name"/>pObj-&gt;AddComponent(pGfxComp); <br class="title-page-name"/>pObj-&gt;AddComponent(pInput); <br class="title-page-name"/>pObj-&gt;AddComponent(pClamp ); <br class="title-page-name"/>//Set position, rotation, scale here <br class="title-page-name"/>//... <br class="title-page-name"/>M5ObjectManager::AddObject(pObj); 
</pre>
<p class="calibre2">This means that our derived <kbd class="calibre14">M5Stage</kbd> class is tightly coupled to the components of this object type, and really all object types that need to be created in this level. If the objects need different components, or any of the components are changed or removed, then our <kbd class="calibre14">Stage</kbd> class must be changed.</p>
<p class="calibre2">One way to <em class="calibre12">solve</em> this (as we saw in <a href="part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 3</a>, <em class="calibre12">Creating Flexibility with the Component Object Model</em>) is to put this code into our <kbd class="calibre14">M5ObjectManager</kbd> class. This way, our stages don't need to be constantly updated as our types are modified:</p>
<pre class="calibre23">
M5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>  switch(type) <br class="title-page-name"/>  { <br class="title-page-name"/>  case AT_Player:  <br class="title-page-name"/>    // Create player object <br class="title-page-name"/>    M5Object* pPlayer             = new M5Object(AT_Player); <br class="title-page-name"/> <br class="title-page-name"/>// Create the components we'd like to use <br class="title-page-name"/>GfxComponent* pGfx            = new GfxComponent; <br class="title-page-name"/>PlayerInputComponent* pInput  = new PlayerInputComponent; <br class="title-page-name"/>ClampComponent* pClamp        = new ClampComponent; <br class="title-page-name"/> <br class="title-page-name"/>// Attach them to our player <br class="title-page-name"/>pObj-&gt;AddComponent(pGfx); <br class="title-page-name"/>pObj-&gt;AddComponent(pInput); <br class="title-page-name"/>pObj-&gt;AddComponent(pClamp); <br class="title-page-name"/> <br class="title-page-name"/>   //Add this object to the M5ObjectManager <br class="title-page-name"/>   AddObject(pPlayer); <br class="title-page-name"/>   return pPlayer; <br class="title-page-name"/>  break; <br class="title-page-name"/>case AT_Bullet: <br class="title-page-name"/>  //...More Code here 
</pre>
<p class="calibre2">This solves the problem of needing to change our stages whenever an object is changed. However, we will still have to change our <kbd class="calibre14">switch</kbd> statement and the object manager if our objects or components change. Actually, except for this function, the Object Manager doesn't really care about any derived component types. It only needs to be dependent on the <kbd class="calibre14">M5Component</kbd> abstract class. If we can fix this function, we can completely decouple our derived component types from this class.</p>
<p class="calibre2">The solution to our problem is the same solution used to solve the stage management problem I faced years ago, <em class="calibre12">the Dependency Inversion Principle</em>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Dependency Inversion Principle</h1>
            

            
                
<p class="calibre2">The concept of avoiding <kbd class="calibre14">concreate</kbd> classes isn't new. Robert C. Martin defined this idea in <em class="calibre12">The C++ Report</em> in May 1996 in an article titled <em class="calibre12">The Dependency Inversion Principle</em>. It is the D in his SOLID design principles. The principle has two parts:</p>
<ul class="calibre17">
<li class="calibre18">High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
<li class="calibre18">Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
<p class="calibre2">While this may seem like a mouthful, the concept is actually very easy. Imagine we have a <kbd class="calibre14">StageManager</kbd> class that is responsible for initializing, updating, and shutting down all of the stages in our game. In this case, our <kbd class="calibre14">StageManager</kbd> is our high-level modules, and the stages are the low-level modules. The <kbd class="calibre14">StageManager</kbd> will control the creation and behavior of our low-level module, the stages. This principle says that our <kbd class="calibre14">StageManager</kbd> code shouldn't depend on derived stage classes, but should instead depend on an abstract stage class. To see why, let's look at an example of not following this principle.</p>
<p class="calibre2">Here our <kbd class="calibre14">StageManager</kbd> has a function called <kbd class="calibre14">Update</kbd>, which looks like this:</p>
<pre class="calibre23">
void StageManager::Update() <br class="title-page-name"/>{ <br class="title-page-name"/>  Level1 level1; <br class="title-page-name"/>  level1.StartGame(); <br class="title-page-name"/>  while(nothingChanged) <br class="title-page-name"/>    level1.PlayGame() <br class="title-page-name"/>  level1.EndGame(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Of course, this is just the first level of our game, so we will need to include code to update the main menu, and the second level of our game. Since these classes are unrelated, we will need a <kbd class="calibre14">switch</kbd> statement to make a choice between stages:</p>
<pre class="calibre23">
void StageManager::Update() <br class="title-page-name"/>{ <br class="title-page-name"/>  switch(currentStage) <br class="title-page-name"/>  { <br class="title-page-name"/>  case LEVEL1: <br class="title-page-name"/>  { <br class="title-page-name"/>    SpaceShooterLevel1 level1; <br class="title-page-name"/>    level1.StartLevel(); <br class="title-page-name"/>    while(currentStage == nextStage) <br class="title-page-name"/>      level1.PlayLevel() <br class="title-page-name"/>    level1.EndLevel(); <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>  case LEVEL2: <br class="title-page-name"/>  { <br class="title-page-name"/>    SpaceShooterLevel2 level2; <br class="title-page-name"/>    level2.StartGame(); <br class="title-page-name"/>    while(currentStage == nextStage) <br class="title-page-name"/>      level2.PlayLevel() <br class="title-page-name"/>    level2.EndLevel(); <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>  case MAIN_MENU: <br class="title-page-name"/>  { <br class="title-page-name"/>    SpaceShooterMainMenu mainMenu; <br class="title-page-name"/>    mainMenu.OpenMenu(); <br class="title-page-name"/>    while(currentStage == nextStage) <br class="title-page-name"/>      mainMenu.Show() <br class="title-page-name"/>    mainMenu.CloseMenu(); <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/>}//end switch <br class="title-page-name"/>}//end Update 
</pre>
<p class="calibre2">You can see that as we continue to add more and more levels, this code will get large very fast and it will quickly become impossible, or just really difficult to maintain. This is because we will need to go into this function and remember to update the <kbd class="calibre14">switch</kbd> statement every time a new stage is added to the game.</p>
<p class="calibre2">The first part of this section, tells us that that our <kbd class="calibre14">StageManager</kbd> class shouldn't depend on levels or menus, but should instead depend on a common abstraction. That means that we should create an abstract base class for all of our stages. The second part says that the abstraction shouldn't care whether the stage is a level or a menu. In fact, it shouldn't even care that we are making a stage for a space shooter game, a platformer, or a racing game. A major benefit of using this principle, besides having more flexible code, is that our <kbd class="calibre14">StageManager</kbd> class will no longer depend on anything in this specific game, so we can reuse it for our next project:</p>
<div><img class="alignnone11" src="img/00039.jpeg"/></div>
<p>StageManager depends on specific classes</p>
<pre class="calibre23">
//Stage.h <br class="title-page-name"/>class Stage <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~Stage(void) {}//Empty virtual destructor <br class="title-page-name"/>  virtual void Init(void)     = 0; <br class="title-page-name"/>  virtual void Update(void)   = 0; <br class="title-page-name"/>  virtual void Shutdown(void) = 0;  <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//StageManager.cpp <br class="title-page-name"/>void StageManager::Update() <br class="title-page-name"/>{ <br class="title-page-name"/>  //We will talk about how to get the current stage soon <br class="title-page-name"/>  Stage* pStage = GetCurrentStage(); <br class="title-page-name"/>  <br class="title-page-name"/>  //Once we have the correct Stage we can run our code <br class="title-page-name"/>  pStage-&gt;Init(); <br class="title-page-name"/> <br class="title-page-name"/>  while(currentStage == nextStage) <br class="title-page-name"/>    pStage-&gt;Update(); <br class="title-page-name"/> <br class="title-page-name"/>  pStage-&gt;Shutdown(); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/> <br class="title-page-name"/>//Example of a derived class <br class="title-page-name"/>//MainMenu.h <br class="title-page-name"/>class MainMenu : public Stage <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~MainMenu(void); <br class="title-page-name"/>  virtual void Init(void); <br class="title-page-name"/>  virtual void Update(void); <br class="title-page-name"/>  virtual void Shutdown(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  //Specific MainMenu data and functions here... <br class="title-page-name"/>}; 
</pre>
<div><img class="alignnone12" src="img/00040.jpeg"/></div>
<p>StageManager only depends on abstraction</p>
<p class="calibre2">Now the <kbd class="calibre14">Update</kbd> function of <kbd class="calibre14">StageManager</kbd> is much simpler. Since we are only dependent on the abstract class, our code no longer needs to change based on derived implementations. We have also simplified the interface of all stages. The functions of each stage no longer change based on the details of the class (menu, level, and so on); instead, they all share a common interface. As you can see, knowing about the Dependency Inversion Principle will not only make you a big hit at parties, it will also allow you to decouple your code base and reuse higher-level modules.</p>
<p class="calibre2">We still have the problem of selecting the correct derived class. We don't want to put a <kbd class="calibre14">switch</kbd> statement in the <kbd class="calibre14">Update</kbd> function of <kbd class="calibre14">StageManager</kbd>. If we do that, we will have dependency problems like before. Instead, we need a way to select the correct derived class while depending only on the base class.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Factory method pattern</h1>
            

            
                
<p class="calibre2">The Factory method pattern is exactly the design pattern we need to solve our problem. The purpose of this pattern is to have a way of creating the derived class that we want without needed to specify the <kbd class="calibre14">concreate</kbd> class in our high-level module. This is done by defining an interface for creating objects, but letting subclasses decide which class to instantiate.</p>
<p class="calibre2">In our case, we will create a <kbd class="calibre14">StageFactory</kbd> interface with a method called <kbd class="calibre14">Build</kbd> that will return a <kbd class="calibre14">Stage*</kbd>. We can then create subclasses such as <kbd class="calibre14">Level2Factory</kbd> to instantiate our derived classes. Our <kbd class="calibre14">StageManager</kbd> class now only needs to know about the <kbd class="calibre14">Stage</kbd> and <kbd class="calibre14">StageFactory</kbd> abstractions:</p>
<div><img class="alignnone13" src="img/00041.jpeg"/></div>
<p>Creating a Stage Factory</p>
<pre class="calibre23">
//StageManager.cpp <br class="title-page-name"/>void StageManager::Update() <br class="title-page-name"/>{ <br class="title-page-name"/><strong class="calibre1">Stage* pStage = m_stageFactory-&gt;Build();</strong> <br class="title-page-name"/> <br class="title-page-name"/>pStage-&gt;Init(); <br class="title-page-name"/> <br class="title-page-name"/>  while(currentStage == nextStage) <br class="title-page-name"/>    pStage-&gt;Update(); <br class="title-page-name"/> <br class="title-page-name"/>pStage-&gt;Shutdown(); <br class="title-page-name"/><strong class="calibre1">m_StageFactory-&gt;Destroy(pStage);//stage must be destroyed</strong> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Notice that we have moved the call to new from our <kbd class="calibre14">StageManager::Update</kbd> function into derived <kbd class="calibre14">StageFactory</kbd> methods. We have successfully decoupled our <kbd class="calibre14">StageManager</kbd> from our derived <kbd class="calibre14">Stage</kbd> classes. However, the call to <kbd class="calibre14">Build</kbd> represents the creation of only one derived <kbd class="calibre14">Stage</kbd> class. We still need a way to choose which derived <kbd class="calibre14">Stage</kbd> we want to use and which derived <kbd class="calibre14">StageFactory</kbd> we need to instantiate. We need a way to choose between different types of factories. Before we look at the solution that was used in the Mach5 Engine, let's look at an alternative Factory method, the Static Factory.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Static Factory</h1>
            

            
                
<p class="calibre2">The simplest way to implement a factory method the way we want is with either a global function or a static class function. We could define a function called <kbd class="calibre14">MakeStage</kbd> outside of <kbd class="calibre14">StateMananger</kbd> that is responsible for instantiating the correct derived type based on a parameter. In this case, we will use an <kbd class="calibre14">enum</kbd> called <kbd class="calibre14">StageType</kbd> to help us choose our correct type:</p>
<pre class="calibre23">
//MakeStage.cpp <br class="title-page-name"/>Stage* MakeStage(StageType type) <br class="title-page-name"/>{ <br class="title-page-name"/>  switch(type) <br class="title-page-name"/>  { <br class="title-page-name"/>    case ST_Level1: <br class="title-page-name"/>      return new Level1; <br class="title-page-name"/>    case ST_LEVEL2: <br class="title-page-name"/>      return new Level2; <br class="title-page-name"/>    case ST_MainMenu: <br class="title-page-name"/>      return new MainMenu; <br class="title-page-name"/>    default: <br class="title-page-name"/>      //Throw exception or assert <br class="title-page-name"/>  } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">If we use this style of factory, our <kbd class="calibre14">StageManager::Update</kbd> function will look like this:</p>
<pre class="calibre23">
void StageManager::Update() <br class="title-page-name"/>{ <br class="title-page-name"/>  Stage* pStage = MakeStage(currentStage); <br class="title-page-name"/>  <br class="title-page-name"/>  pStage-&gt;Init(); <br class="title-page-name"/> <br class="title-page-name"/>  while(currentStage == nextStage) <br class="title-page-name"/>    pStage-&gt;Update(); <br class="title-page-name"/> <br class="title-page-name"/>pStage-&gt;Shutdown(); <br class="title-page-name"/><strong class="calibre1">DestroyStage(pStage);//Clean up the stage when done</strong> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This version of the factory method works exactly as we want. We can now choose which derived <kbd class="calibre14">Stage</kbd> class is instantiated. We still have a switch statement that we must maintain, but at least our higher-level module is no longer dependent on derived classes. In the default case, where our <kbd class="calibre14">switch</kbd> statement can't match the correct type, we are left with the choice of using an assert to crash the program, throwing an exception and letting the client resolve the issue, or perhaps returning null, which still gives responsibility to the client.</p>
<p class="calibre2">The Static Factory successfully decouples our <kbd class="calibre14">StageManager</kbd> class from specific derived <kbd class="calibre14">Stage</kbd> classes, while allowing us to choose which stage will be instantiated at runtime. This is great, but as I said, this isn't how the Mach5 Engine implements <kbd class="calibre14">Stage</kbd> or component factories. Instead, Mach5 uses a more dynamic solution, so we will call it the Dynamic Factory.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Dynamic Factory</h1>
            

            
                
<p class="calibre2">While the Static Factory is simple enough for our purpose, the Mach5 Engine uses a different approach. This approach combines the polymorphic solution of the classic Factory method with the selection capability of the Static Factory. This new approach uses a searchable collection of derived <kbd class="calibre14">StageFactory</kbd> classes.</p>
<p class="calibre2">Remember that problem with the classic Factory method is that the method represents only one class to instantiate. This allows our code to be flexible because we don't depend on a derived <kbd class="calibre14">Stage</kbd> class or a call to the <kbd class="calibre14">new</kbd> operator. However, we still needed a way to get specific derived <kbd class="calibre14">StageFactory</kbd> instances.</p>
<p class="calibre2">In the Mach5 Engine, the names are changed a little. There is only one <kbd class="calibre14">StageFactory</kbd> class, which contains a collection of <kbd class="calibre14">M5StageBuilder</kbd> pointers (these are classic Factories), which implement a <kbd class="calibre14">Build</kbd> method. The design looks like this:</p>
<div><img class="alignnone14" src="img/00042.jpeg"/></div>
<p>Design of Dynamic Factory</p>
<p class="calibre2">The first class we want to see is the base <kbd class="calibre14">M5Stage</kbd> class:</p>
<pre class="calibre23">
class M5Stage <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~M5Stage(void) {} //Empty virtual destructor <br class="title-page-name"/>  virtual void Load(void)       = 0; <br class="title-page-name"/>  virtual void Init(void)       = 0; <br class="title-page-name"/>  virtual void Update(float dt) = 0; <br class="title-page-name"/>  virtual void Shutdown(void)   = 0; <br class="title-page-name"/>  virtual void Unload(void)     = 0; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">The base <kbd class="calibre14">M5Stage</kbd> class is a pretty simple abstract base class with a virtual destructor. The specific virtual functions in <kbd class="calibre14">M5Stage</kbd> aren't important for the details of the factory. We are simply showing the class here, because the <kbd class="calibre14">M5StageManager</kbd> and <kbd class="calibre14">M5StageFactory</kbd> will be using this abstraction.</p>
<p>C++ classes intended for polymorphic use, including abstract base classes, should always implement a virtual destructor, otherwise the correct derived class destructor cannot be called.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Creating our Stage Builders</h1>
            

            
                
<p class="calibre2">Next let's look at our base builder class. Notice that this is the same type of interface that would be used in the classic Factory method pattern. This abstraction declares a method that returns another abstraction, in this case <kbd class="calibre14">M5Stage</kbd>.</p>
<p class="calibre2">Just like before, we need to have an empty virtual destructor so when we use this class in a polymorphic way, the correct destructor will be called. Also like before, the other methods are marked as purely <kbd class="calibre14">virtual,</kbd> which disallows direct instantiation of this class. That means we cannot create an <kbd class="calibre14">M5StageBuilder</kbd> directly. We must derive from it, and implement the pure virtual methods:</p>
<pre class="calibre23">
class M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual ~M5StageBuilder() {} //Empty virtual destructor <br class="title-page-name"/>  virtual M5Stage* Build(void) = 0; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Even though the name is different, this is how the classic Factory method would be implemented. The Mach5 Engine calls this a <em class="calibre12">Builder</em> instead of a <em class="calibre12">Factory</em> but it is only a change in the name and not the functionality. The name of the <kbd class="calibre14">Build</kbd> method isn't important. Some programs will call the method <kbd class="calibre14">Create</kbd> or <kbd class="calibre14">Make</kbd>. Mach5 calls it <kbd class="calibre14">Build</kbd> but any of these names are fine.</p>
<p class="calibre2">No matter what the name is, a user creating a game with the Mach5 Engine would want to derive their own specific stage builders for the stages in their game. For this book, we have stages for a space shooter game called <kbd class="calibre14">AstroShot</kbd>. In order to make builders for these stages, we need to derive from <kbd class="calibre14">M5StageBuilder</kbd> and implement the <kbd class="calibre14">Build</kbd> method. For example, if we had <kbd class="calibre14">M5Stage</kbd> derived classes called <kbd class="calibre14">SplashStage</kbd> and <kbd class="calibre14">MainMenuStage</kbd>, we would create builders like this:</p>
<pre class="calibre23">
//SplashStageBuilder.h <br class="title-page-name"/>class SplashStageBuilder: public M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual M5Stage* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//SplashStageBuilder.cpp <br class="title-page-name"/>M5Stage* SplashStageBuilder::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>return new SplashStage; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>//MainMenuStageBuilder.h <br class="title-page-name"/>class MainMenuStageBuilder: public M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual M5Stage* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>// MainMenuStageBuilder.cpp <br class="title-page-name"/>M5Stage* MainMenuStageBuilder::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>return new MainMenuStage; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Note here that the use of the keyword <kbd class="calibre14">virtual</kbd> in the derived classes is completely optional. In the pre C++ 11 days, programmers would mark the function <kbd class="calibre14">virtual</kbd> as a form of documentation to other programmers. These days, you can add the override specifier to a virtual function so the compiler can issue an error if the function isn't a true override.</p>
<p class="calibre2">To some, this might seem a little tedious. In fact, the biggest complaint I hear from people first learning about object-oriented programming is that they feel like they waste a lot time creating many files with small classes in them. To them, it feels like a lot of work for very little pay-off.</p>
<p class="calibre2">I agree that programming this way can require lots of files and lots of little classes. However, I disagree with it being a waste of time. I think these arguments are a result of shortsighted thinking. They are only thinking of the time it takes to write the original code, but they aren't thinking about the time it will save when making changes to the design or the time it will take to test and debug.</p>
<p class="calibre2">It doesn't take much time to create new files. With an integrated development environment such as Visual Studio, it takes less than 10 seconds to create a source and header file. Writing small classes such as the builders above doesn't take much time either. In total, writing these two classes takes less than five minutes. Of course, this is more than directly writing new into a high-level module, but remember that the goal is to write code that can adapt to change in our game design.</p>
<p class="calibre2">These shortsighted arguments are similar to the complaints of new programmers learning to write functions. We have already discussed the benefits of writing functions and those same benefits apply here. We shouldn't think only of the time it takes to write the initial code. We need to factor in how long it will take to test and debug the code, how likely it is to introduce new bugs into old code, how long it will take to modify if our design changes a month or year from now, and if the design does change, how likely is it that modifying our code will introduce bugs.</p>
<p class="calibre2">It is important to understand that by using design patterns we are writing more code upfront, so that we can cut down on the time it takes to test, debug, integrate, maintain, and change our code in the future. It is important to understand that writing the original code is easy and cheap, while changing it later is much harder and more expensive. In this case, cheap and expensive could be referring to hours worked or money spent paying programmers.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The template builder</h1>
            

            
                
<p class="calibre2">Those worried about writing a lot of little classes are in luck. Most, if not all, of our builders will be the same except for the specific derived class they instantiate. That means we can use the power of C++ templates to create builders for us. Our templated builder will look like this:</p>
<pre class="calibre23">
//M5StageBuilder.h <br class="title-page-name"/>template &lt;typename T&gt; <br class="title-page-name"/>class M5StageTBuilder : public M5StageBuilder <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  virtual M5Stage* Build(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>template &lt;typename T&gt; <br class="title-page-name"/>M5Stage* M5StageTBuilder&lt;T&gt;::Build(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  return new T(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This code works great for most of our stages. The only time it doesn't work is when we need to do something more specific, such as call a non-default constructor, or a function specific to the derived stage.</p>
<p class="calibre2">Notice that the implementation of the <kbd class="calibre14">Build</kbd> function is also included in the <kbd class="calibre14">.h</kbd> file. This is because <kbd class="calibre14">template</kbd> functions are not the same as regular functions. They work as recipes so the compiler knows how to generate the function for the specific type. Each time we need to use this function, the compiler will need to know about the recipe. This allows the compiler to instantiate the function as opposed to requiring the user to explicitly instantiate the <kbd class="calibre14">Builder</kbd> classes they need before using them. So when we want to use this class, it will look something like this:</p>
<pre class="calibre23">
//SomeFile.cpp <br class="title-page-name"/>#include "M5StageBuilder.h" <br class="title-page-name"/>#include "MainMenuStage.h" <br class="title-page-name"/> <br class="title-page-name"/>void SomeFunction(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  //Creating the class needs the type <br class="title-page-name"/>  M5Builder* pBuilder = new M5StageTBuilder&lt; SplashStage &gt;(); <br class="title-page-name"/> <br class="title-page-name"/>  //But using the Build function doesn't need the type <br class="title-page-name"/>  M5Stage* pStage = pBuilder-&gt;Build(); <br class="title-page-name"/>} 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Creating the Dynamic Factory class</h1>
            

            
                
<p class="calibre2">So far, we have only created our builders, which are equivalent to the classic Factory method pattern. However, we haven't seen the Factory part of the Dynamic Factory. Let's look at how the Mach5 Engine implements the <kbd class="calibre14">StageFactory</kbd> class:</p>
<pre class="calibre23">
class M5StageFactory <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>~M5StageFactory(void); <br class="title-page-name"/>void     AddBuilder(M5StageTypes name, M5StageBuilder* builder); <br class="title-page-name"/>void     RemoveBuilder(M5StageTypes type); <br class="title-page-name"/>void     ClearBuilders(void); <br class="title-page-name"/>M5Stage* Build(M5StageTypes name); <br class="title-page-name"/>private: <br class="title-page-name"/>  typedef std::unordered_map&lt;M5StageTypes,<br class="title-page-name"/>     M5StageBuilder*&gt; BuilderMap; <br class="title-page-name"/>  typedef BuilderMap::iterator MapItor; <br class="title-page-name"/> <br class="title-page-name"/>  BuilderMap m_builderMap; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">As you can see, <kbd class="calibre14">M5StageFactory</kbd> isn't a very complicated class. Once you understand the design behind the patterns, implementing them is usually not very difficult. As for this class, it is only five methods and one member. The private section looks a little complicated because Mach5 prefers using a <kbd class="calibre14">typedef</kbd> for templated containers. Since the container is used in all of the private functions, let's look at the member before exploring the five methods.</p>
<p class="calibre2">Let's first look the <kbd class="calibre14">typedefs</kbd>:</p>
<pre class="calibre23">
typedef std::unordered_map&lt;M5StageTypes, M5StageBuilder*&gt; BuilderMap; 
</pre>
<p class="calibre2">Since we want a container of <kbd class="calibre14">M5StageBuilders</kbd>, we have a few choices. We could use an STL vector or list, but those containers are not ideal for searching because of the potential lack of efficiency if we have many builders. However, this is exactly what the STL map and <kbd class="calibre14">unordered_map</kbd> are perfect for. They allow us to save key/value pairs and later use the key to efficiently find the value, even if we had thousands of builders. We will use the <kbd class="calibre14">M5StageTypes</kbd><kbd class="calibre14">enum</kbd> as our key, and use a derived <kbd class="calibre14">M5StageBuilder*</kbd> as our value.</p>
<p>An STL map is implemented as a tree, while <kbd class="calibre26">unordered_map</kbd> is implemented as a hash table. In general, this means that the map will use less memory, but will be a little slower to search. <kbd class="calibre26">unordered_map</kbd> will use more memory but search much faster. In our games, we aren't likely to create thousands of stages, so the difference in speed isn't going to matter that much, especially since we won't be searching very often either. We choose the hash table because, on a PC, I am less concerned about memory and more concerned about speed. If you are interested in learning more, check out <a href="http://www.cplusplus.com/reference/" target="_blank" class="calibre24">http://www.cplusplus.com/reference/</a> for lots of information about the standard library.</p>
<p class="calibre2">We should also prefer to have as readable code as possible. Using a <kbd class="calibre14">typedef</kbd> will help others understand our code, because we only need to write the long <kbd class="calibre14">std::unordered_map&lt; M5StageTypes, M5StageBuilder*&gt;</kbd> code one time. After that, we can use the shorted name, in this case <kbd class="calibre14">BuilderMap</kbd>. This also gives us the ability to easily change containers if we later decide to use a map instead:</p>
<pre class="calibre23">
typedef BuilderMap::iterator MapItor; 
</pre>
<p class="calibre2">The next <kbd class="calibre14">typedef</kbd> gives us a shorted name for our <kbd class="calibre14">BuilderMap</kbd> iterators.</p>
<p>This is unnecessary with the C++ 11 auto keyword, but doesn't make our code less readable so we have chosen to use the <kbd class="calibre26">typedef</kbd>.</p>
<p class="calibre2">Finally, the actual member:</p>
<pre class="calibre23">
BuilderMap m_builderMap; 
</pre>
<p class="calibre2">This will be our container that maps <kbd class="calibre14">M5StageTypes</kbd> to <kbd class="calibre14">M5StageBuilder*</kbd>. We should make it private because we want all builders to be added and removed with the class methods so the data can be validated.</p>
<p class="calibre2">Now for the class methods. Let's start with the most important method of the factory:</p>
<pre class="calibre23">
M5Stage* M5StageFactory::Build(M5StageTypes type) <br class="title-page-name"/>{ <br class="title-page-name"/>  ArcheTypeItor itor = m_builderMap.find(type); <br class="title-page-name"/>if (itor == m_builderMap.end()) <br class="title-page-name"/>  return nullptr; <br class="title-page-name"/>else <br class="title-page-name"/>  return itor-&gt;second-&gt;Build(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre14">Build</kbd> method is where the <em class="calibre12">magic</em> happens, at least for the user. They pass in a stage type and we build the correct stage for them. Of course, we use the <kbd class="calibre14">find</kbd> method first to make sure the type has been added. If it can't be found, we use a debug assert to let the user know that this type wasn't added. In general, the <kbd class="calibre14">find</kbd> method is safer to use than the <kbd class="calibre14">operator[]</kbd> that exists in the map and unordered map. Using the <kbd class="calibre14">operator[]</kbd> will create and return a null value if the key doesn't exist. If that happened while trying to build, we would get a null pointer exception, which would crash the program without giving the user an explanation of why.</p>
<p class="calibre2">We have the choice of adding some default stage to the map, and building that if the correct type can't be found. However, there is a chance that the programmer won't notice that a mistake has been made. Instead, we have chosen to return a null pointer. The requires the user to check whether the builder is valid before using it, but also means that the code will crash if they don't fix the problem:</p>
<pre class="calibre23">
bool M5StageFactory::AddBuilder(M5StageTypes name, <br class="title-page-name"/>   M5StageBuilder* pBuilder) <br class="title-page-name"/>{ <br class="title-page-name"/>std::pair&lt;MapItor, bool&gt; itor = m_builderMap.insert(<br class="title-page-name"/>   std::make_pair(name, pBuilder)); <br class="title-page-name"/>  <br class="title-page-name"/>return itor.second; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre14">AddBuilder</kbd> method allows our user to associate an <kbd class="calibre14">M5StageTypes</kbd> value with a derived <kbd class="calibre14">M5StageBuilder</kbd>. In this case, our code doesn't know or care whether <kbd class="calibre14">pBuilder</kbd> is pointing to a templated class or not. All that matters is that it derives from <kbd class="calibre14">M5StageBuilder</kbd>.</p>
<p class="calibre2">Just as before, we should write our code to help the user find and fix bugs if they occur. We do that by testing the return value of the insert method. The <kbd class="calibre14">insert</kbd> method returns a pair in which the second element will tell us whether the insert was successful or not. Since a map and an <kbd class="calibre14">unordered_map</kbd> do not allow duplicates, we can test to make sure the user isn't associating an <kbd class="calibre14">M5StageTypes</kbd> value with two different builders. If the user tries to use an <kbd class="calibre14">enum</kbd> value twice, the second builder will not be inserted and false will be returned.</p>
<p>The STL versions of map and <kbd class="calibre26">unordered_map</kbd> do not allow duplicate items. If you wish to have duplicates, you can replace the container with <kbd class="calibre26">multimap</kbd> or <kbd class="calibre26">unordered_multimap</kbd>, which do allow duplicates. It wouldn't be useful to use the multi versions in this class, but they are good tools to know about.</p>
<pre class="calibre23">
void M5StageFactory::RemoveBuilder(M5StageTypes name) <br class="title-page-name"/>{ <br class="title-page-name"/>  BuilderMap::iterator itor = m_builderMap.find(name); <br class="title-page-name"/> <br class="title-page-name"/>if (itor == m_builderMap.end()) <br class="title-page-name"/>  return; <br class="title-page-name"/> <br class="title-page-name"/>  //First delete the builder <br class="title-page-name"/>  delete itor-&gt;second; <br class="title-page-name"/>  itor-&gt;second = 0;//See the note below <br class="title-page-name"/>  <br class="title-page-name"/>  //then erase the element <br class="title-page-name"/>  m_builderMap.erase(itor); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">By now, the pattern should feel routine. First we write code to make sure there are no errors, then we write the actual function code. In this function, we first check to make sure the user is removing a previously added builder. After we make sure the user didn't make a mistake, we then delete the builder and erase the iterator from the container.</p>
<p>Since we are immediately erasing the iterator after deleting the builder, it is unnecessary to set the pointer to <kbd class="calibre26">0</kbd>. However, I always set the pointer to <kbd class="calibre26">0</kbd>. This helps find bugs. For example, if I forgot to erase the iterator and tried to use this builder again, the program would crash, resulting from using the null pointer. If I didn't set the pointer to <kbd class="calibre26">0</kbd> but still tried to use it, I would instead get undefined behavior.</p>
<pre class="calibre23">
void M5StageFactory::ClearBuilders(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  MapItor itor = m_builderMap.begin(); <br class="title-page-name"/>  MapItor end  = m_builderMap.end(); <br class="title-page-name"/> <br class="title-page-name"/>  //Make sure to delete all builder pointers first <br class="title-page-name"/>  while (itor != end) <br class="title-page-name"/>  { <br class="title-page-name"/>    delete itor-&gt;second; <br class="title-page-name"/>    itor-&gt;second = 0; <br class="title-page-name"/>    ++itor; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  //Then clear the hash table <br class="title-page-name"/>  m_builderMap.clear(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Just as with the <kbd class="calibre14">RemoveAllComponents</kbd> from the <kbd class="calibre14">M5Object</kbd>, the purpose of <kbd class="calibre14">ClearBuilders</kbd> is to help the destructor of the class. Since this code needs to be written anyway (it would go in the destructor), we think it is better to factor it into a separate function that the user can call if they need:</p>
<pre class="calibre23">
M5StageFactory::~M5StageFactory(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  ClearBuilders(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Finally, we have our factory destructor. This just ensures that we don't have any memory leaks by calling the <kbd class="calibre14">ClearBuilders</kbd> function.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Using the Dynamic Factory</h1>
            

            
                
<p class="calibre2">Now that we have a completed <kbd class="calibre14">Factory</kbd> class, let's look at how we would use it. Since the goal of this class was to decouple our <kbd class="calibre14">M5StageManager</kbd> from our specific derived <kbd class="calibre14">M5Stage</kbd> classes, it makes sense that it will be used in the <kbd class="calibre14">M5StageManager</kbd> class:</p>
<pre class="calibre23">
class M5StageManager <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  //Lots of other stuff here... <br class="title-page-name"/>  static void AddStage(M5StageTypes type, M5StageBuilder* <br class="title-page-name"/>     builder); <br class="title-page-name"/>static void RemoveStage(M5StageTypes type); <br class="title-page-name"/>static void ClearStages(void); <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  //Lots of other stuff here <br class="title-page-name"/>  static M5StageFactory s_stageFactory; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Since the factory will be private in the <kbd class="calibre14">M5StageManager</kbd>, we will add interface functions so the user can control the factory without knowing the implementation. This allows us to change the details, without affecting the user.</p>
<p class="calibre2">Inside the <kbd class="calibre14">M5StageManager::Update</kbd> function, we will use the factory to get access to the current stage. Notice that this class is completely decoupled from any specific <kbd class="calibre14">M5Stage</kbd> derived classes. This give the user freedom to change the game design, including stage types, stage count, and stage names, without needing to modify the <kbd class="calibre14">M5StageManager</kbd> class.</p>
<p class="calibre2">In fact, that is the purpose of creating the Mach5 Engine the way we are. It can be used and reused in many game projects without changing the engine code. Here is a simplified version (pausing/restarting code has been omitted) of the <kbd class="calibre14">M5StageManager::Update</kbd> showing code relevant to the stages and factory:</p>
<pre class="calibre23">
void M5StageManager::Update(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  float frameTime = 0.0f; <br class="title-page-name"/>  /*Get the Current stage*/ <br class="title-page-name"/><strong class="calibre1">  M5Stage* pCurrentStage = s_stageFactory.Build(s_currStage);</strong> <br class="title-page-name"/> <br class="title-page-name"/>  /*Call the initialize function*/ <br class="title-page-name"/>  pStage-&gt;Init(); <br class="title-page-name"/> <br class="title-page-name"/>  /*Keep going until the stage has changed or we are quitting. */ <br class="title-page-name"/>  while ((s_currStage == s_nextStage) &amp;&amp; <br class="title-page-name"/>       !s_isQuitting                &amp;&amp; <br class="title-page-name"/>       !s_isRestarting) <br class="title-page-name"/>  { <br class="title-page-name"/>    /*Our main game loop*/ <br class="title-page-name"/>    s_timer.StartFrame();/*Save the start time of the frame*/ <br class="title-page-name"/>    M5Input::Reset(frameTime); <br class="title-page-name"/>    M5App::ProcessMessages(); <br class="title-page-name"/> <br class="title-page-name"/>    <strong class="calibre1">pStage-&gt;Update(frameTime);</strong> <br class="title-page-name"/> <br class="title-page-name"/>    M5ObjectManager::Update(frameTime); <br class="title-page-name"/>    M5Gfx::Update(); <br class="title-page-name"/>    frameTime = s_timer.EndFrame();/*Get the total frame time*/ <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  /*Make sure to Shut down the stage*/ <br class="title-page-name"/>  pStage-&gt;Shutdown(); <br class="title-page-name"/> <br class="title-page-name"/>  ChangeStage(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can see, the <kbd class="calibre14">M5StageManager</kbd> is completely decoupled from any derived <kbd class="calibre14">M5Stage</kbd> classes. This allows the user to change, add, or remove any stages during development without needing to modify the <kbd class="calibre14">M5StageManager</kbd> class. This also allows the <kbd class="calibre14">M5StageManager</kbd> and <kbd class="calibre14">M5StageFactory</kbd> classes to be reused in another game, shortening the development time of that project.</p>
<p class="calibre2">Now that we have seen the dynamic factory and how to use it, an important question should come to your mind: what are the benefits of the Dynamic Factory? Both the Static and Dynamic Factories allow us to decouple our code. Since they both offer that benefit and the Static Factory is much easier to implement, why should we bother spending time on the Dynamic Factory? Asking questions like these is always a good idea. In this case, I think there are two benefits to using the Dynamic Factory over the Static Factory.</p>
<p class="calibre2">The first benefit of the Dynamic Factory is that it is dynamic, meaning that we can load builders from a file at runtime or remove a stage if we will never use it again (<kbd class="calibre14">SplashStage</kbd>). Being dynamic allows us to swap out a builder at runtime. For example, depending on the difficulty the player selects, we can swap out a difficulty component on enemies. The code to these difficulty component builders could be put into the menu, and the rest of our game no longer needs to care about the difficulty, the levels just create enemies the same way, no matter what.</p>
<p class="calibre2">The second and more important benefit of creating the Dynamic Factory comes in the next step. Since we have successfully created a <kbd class="calibre14">StageFactory</kbd>, we should do the same thing for components and game objects. In the next section, we will take a look at creating these factories.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Creating a component and Object Factory</h1>
            

            
                
<p class="calibre2">Now that we have built a stage factory, building a component factory should be easy. Let's take a look at what a component and object factory would look like:</p>
<pre class="calibre23">
//Component Factory <br class="title-page-name"/>class M5ComponentFactory <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ~M5ComponentFactory(void); <br class="title-page-name"/>  void AddBuilder(M5ComponentTypes type, <br class="title-page-name"/>                   M5ComponentBuilder* builder); <br class="title-page-name"/>  void RemoveBuilder(M5ComponentTypes type); <br class="title-page-name"/>  M5Component* Build(M5ComponentTypes type); <br class="title-page-name"/>  void ClearBuilders(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  typedef std::unordered_map&lt;M5ComponentTypes, <br class="title-page-name"/>                              M5ComponentBuilder*&gt; BuilderMap; <br class="title-page-name"/>  typedef BuilderMap::iterator MapItor; <br class="title-page-name"/>  BuilderMap m_builderMap; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>//Object Factory <br class="title-page-name"/>class M5ObjectFactory <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ~ M5ObjectFactory (void); <br class="title-page-name"/>  void AddBuilder(M5ArcheTypes type, <br class="title-page-name"/>     M5ObjectBuilder* builder); <br class="title-page-name"/>  void RemoveBuilder(M5ArcheTypes type); <br class="title-page-name"/>  M5Object* Build(M5ArcheTypes type); <br class="title-page-name"/>  void ClearBuilders(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  typedef std::unordered_map&lt; M5ArcheTypes, <br class="title-page-name"/>     M5ObjectBuilder *&gt; BuilderMap; <br class="title-page-name"/>  typedef BuilderMap::iterator MapItor; <br class="title-page-name"/>  BuilderMap m_builderMap; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Looking at those classes, you will notice that they are almost identical to the <kbd class="calibre14">M5StageFactory</kbd> class. The only things that are different are the types involved. Instead of <kbd class="calibre14">M5StageTypes</kbd>, we use <kbd class="calibre14">M5ComponentTypes</kbd> or <kbd class="calibre14">M5ArcheTypes</kbd>. Instead of <kbd class="calibre14">M5StageBuilder</kbd>, we use <kbd class="calibre14">M5ComponentBuilder</kbd> or <kbd class="calibre14">M5ObjectBuilder</kbd>. Finally, instead of the <kbd class="calibre14">Build</kbd> method returning an <kbd class="calibre14">M5Stage*</kbd>, we return either an <kbd class="calibre14">M5Component*</kbd> or <kbd class="calibre14">M5Object*</kbd>.</p>
<p class="calibre2">If we were to implement these classes, the code would be identical as well. You might think that the <kbd class="calibre14">M5ObjectFactory</kbd> would be a little different since the <kbd class="calibre14">M5Object</kbd> isn't part of an inheritance hierarchy, but it actually doesn't matter. Even though the derived class builders are all doing different work, they are always just returning a single pointer type. The builders might be different, but the return type isn't.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Templated Factory</h1>
            

            
                
<p class="calibre2">Since we need to create different versions of the same algorithms using different type, we should again make use of C++ templates. This will allow us to write the code one time, and reuse it for any factory type we need.</p>
<p class="calibre2">First we need to factor out the types that are different. If you look at all three classes, you will see that three types are different. The enumeration type, the builder type, and the return type for the <kbd class="calibre14">Build</kbd> method is different in all three classes. If we make those template parameters, we can reuse the same code instead of recreating the same class three times. Here is how we should refactor our code:</p>
<pre class="calibre23">
//M5Factory.h <br class="title-page-name"/>template&lt;typename EnumType, <br class="title-page-name"/>         typename BuilderType, <br class="title-page-name"/>         typename ReturnType&gt; <br class="title-page-name"/>class M5Factory <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ~M5Factory(void); <br class="title-page-name"/>  void AddBuilder(EnumType type, BuilderType* pBuilder); <br class="title-page-name"/>  void RemoveBuilder(EnumType type); <br class="title-page-name"/>  ReturnType* Build(EnumType type); <br class="title-page-name"/>  void ClearBuilders(void); <br class="title-page-name"/>private: <br class="title-page-name"/>  typedef std::unordered_map&lt;EnumType, BuilderType*&gt; BuilderMap; <br class="title-page-name"/>  typedef typename BuilderMap::iterator MapItor; <br class="title-page-name"/>  BuilderMap m_builderMap; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Notice that our class is now a template class with three template parameters, <kbd class="calibre14">EnumType</kbd>, <kbd class="calibre14">BuilderType</kbd>, and <kbd class="calibre14">ReturnType</kbd>. Instead of any specific types such as <kbd class="calibre14">M5StageTypes</kbd>, we have used our template parameters. One change that confuses many people is this line:</p>
<pre class="calibre23">
typedef typename BuilderMap::iterator MapItor; 
</pre>
<p class="calibre2">In the original, non-templated <kbd class="calibre14">M5StageFactory</kbd> class, the compiler was able to look at the code <kbd class="calibre14">BuilderMap::iterator</kbd> and know for certain that iterator was a type inside <kbd class="calibre14">BuilderMap</kbd>. Now that we have a template class, the compiler can't be sure whether <kbd class="calibre14">BuilderMap::iterator</kbd> is a variable or a type, so we need to help the compiler by using the <kbd class="calibre14">typename</kbd> keyword to say that this is a type.</p>
<p class="calibre2">Since our factory is now a templated class, we should again put all functions implementations into the header file. In addition, each implementation must be marked as a template function. Here is an example of one of the <kbd class="calibre14">Build</kbd> methods:</p>
<pre class="calibre23">
//M5Factory.h <br class="title-page-name"/>template&lt;typename EnumType, <br class="title-page-name"/>         typename BuilderType, <br class="title-page-name"/>         typename ReturnType&gt; <br class="title-page-name"/>ReturnType* M5Factory&lt;EnumType, <br class="title-page-name"/>                      BuilderType, <br class="title-page-name"/>                      ReturnType&gt;::Build(EnumType type) <br class="title-page-name"/>{ <br class="title-page-name"/>MapItor itor = m_builderMap.find(type); <br class="title-page-name"/>M5DEBUG_ASSERT(itor != m_builderMap.end(), <br class="title-page-name"/>  "Trying to use a Builder that doesn't exist"); <br class="title-page-name"/>  return itor-&gt;second-&gt;Build(); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Except for the change in the function signature, the <kbd class="calibre14">Build</kbd> function is exactly the same. This is true of <kbd class="calibre14">AddBuilder</kbd>, <kbd class="calibre14">RemoveBuilder</kbd>, and all functions of the class. As I said, by making the Dynamic Factory a template class, we can reuse the same code for our stage factory, our component factory, and our object factory. Since that is the case, we won't spend time on making the template factory. However, we still need to see how to use this new class. Let's look at our <kbd class="calibre14">M5StageFactory</kbd> class:</p>
<pre class="calibre23">
class M5StageManager <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  //Same as before <br class="title-page-name"/>private: <br class="title-page-name"/>//static M5StageFactory s_stageFactory; //Our Old Code <br class="title-page-name"/>static M5Factory&lt;M5StageTypes, <br class="title-page-name"/>                 M5StageBuilder, <br class="title-page-name"/>                 M5Stage&gt; s_stageFactory;//Our new code <br class="title-page-name"/> <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">That is the only change we need to make to our <kbd class="calibre14">M5StageFactory</kbd>. Everything else will work the exact same way. The nice thing is that once we have our template factory completed, using a component factory is easy. Here is how we can use our component factory and object factory inside our <kbd class="calibre14">M5ObjectManager</kbd> class:</p>
<pre class="calibre23">
class M5ObjectManager <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  //See M5ObjectManager.h for details <br class="title-page-name"/>private: <br class="title-page-name"/>  static M5Factory&lt;M5ComponentTypes, <br class="title-page-name"/>                    M5ComponentBuilder, <br class="title-page-name"/>                    M5Component&gt; s_componentFactory; <br class="title-page-name"/>static M5Factory&lt;M5ArcheTypes, <br class="title-page-name"/>                    M5ObjectBuilder, <br class="title-page-name"/>                    M5Object&gt; s_ObjectFactory; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Reusing the code is simple once we have created the template version. We should have created that first, but most programmers have a hard time thinking about how to reuse a class until after the initial code has been written. I think it is easier and more natural to create the stage factory first, then refactor the code into a template class.</p>
<p class="calibre2">There is one more important thing to consider when using our factory: how to add our builders. For now, let's only consider the <kbd class="calibre14">M5Factory</kbd> inside the <kbd class="calibre14">M5StageManager</kbd> since we have seen that code already. Somewhere in our code, we must still instantiate our derived builders so we can add them to the <kbd class="calibre14">M5StageManager</kbd>. For example, we would need a function like this:</p>
<pre class="calibre23">
#include "M5StageManager.h" <br class="title-page-name"/>#include "M5StageTypes.h" <br class="title-page-name"/>#include "M5StageBuilder.h" <br class="title-page-name"/>#include "GamePlayStage.h" //Example Stage <br class="title-page-name"/>#include "SplashStage.h"   //Example Stage <br class="title-page-name"/> <br class="title-page-name"/> <br class="title-page-name"/>void RegisterStages(void) <br class="title-page-name"/>{ <br class="title-page-name"/>M5StageManager::AddStage(ST_GamePlayStage, <br class="title-page-name"/>   new M5StageTBuilder&lt; GamePlayStage &gt;() ); <br class="title-page-name"/>M5StageManager::AddStage(ST_SplashStage, <br class="title-page-name"/>   new M5StageTBuilder&lt; SplashStage &gt;() ); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can see, this function is dependent on all stages in our game and is likely to change as we change our design. Unfortunately, this is as far as we can decouple our code. At some point, we need to instantiate derived classes. Even though this is necessary, later we will look at how to minimize the work involved in maintaining this code. In the case of the Mach5 Engine, this code is auto generated with a Windows batch file before the code is compiled. By auto generating our file, we reduce the chance of forgetting to add a stage, and also minimize the work when our code changes.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Architecting versus over-architecting</h1>
            

            
                
<p class="calibre2">Over-architecting is the concept of spending time planning as well as writing code that includes completely unneeded and ultimately unused features. Since every project has a deadline, over-architecting means wasting time that could be better spent writing code that will be used.</p>
<p class="calibre2">In our effort to learn design patterns, we want to know not only how to use them, but also about when not to use them. When you are working on a project, you must always find the balance between writing flexible code and getting the project finished on time. It always takes more time to write flexible, reusable code, so you have to consider whether it is worth the extra time to write that code.</p>
<p class="calibre2">It would be great to spend time creating the ultimate graphics engine, or creating a content creation tool that can rival Unreal or Unity. However, if you strive to write perfect, flexible, 100% reusable code, you may never complete your game. You may end up writing a great particle system and have your designers only use 10% of the capabilities. This is why many companies choose to use a premade engine in the first place. Those companies don't want to spend time or money on creating a tool. They want to spend time making a game that is fun.</p>
<p class="calibre2">The opposite of this situation is just as bad. We don't want to write code that breaks whenever a change is introduced, or is impossible to use again. We can all imagine how ugly the code would be if an entire game was written in the standard <kbd class="calibre14">main</kbd> function. We might laugh at the thought of someone doing that, while at the same time hardcoding behavior with large if/else chains instead of using Finite State Machines.</p>
<p class="calibre2">Finding the balance between these two extremes is difficult. I already mentioned that besides writing the initial code, there are additional factors to consider. These include the time it takes to test and debug the code as well as time to modify code if and when change occurs.</p>
<p class="calibre2">Determining whether writing flexible code is worth the time also includes determining how likely that code is to change. This is why we are using Singleton classes for our core engines. These are unlikely to change during the project. Of course, if we need to support multiple graphics APIs, multiple platforms, or even a multithreaded environment, we might make a different decision. This is also why using the Component Object Model and Finite State Machines are very useful, since our game objects and their behavior are likely to change constantly.</p>
<p class="calibre2">In this case, we need to choose between using the Static Factory or the Dynamic Factory. The Static Factory is very simple to write and use. Since it is so simple, testing and debugging should be easy. It is likely to change, but those changes should be easy as well. However, when using the Static Factory, we must write, test, debug, and maintain code for at least three separate types in our game: the stages, components, and objects. These will change often during the development cycle. Each time a change occurs, you would need to go back and modify these functions.</p>
<p class="calibre2">The templated Dynamic Factory is a little more difficult to implement, especially if you aren't very familiar with using templates. However, the major benefit of using the templated Dynamic Factory is that we only need to write the code once, and we can use it for stages, components, and objects. In addition, we have the ability to add, remove, or change items in our factories at runtime. As I mentioned, this could mean changing archetype builders based on difficulty to create harder versions of the same archetype without needing new enumeration values. Finally, we have the option of using this code again in another project, which is unlikely if we stick with the Static Factory.</p>
<p class="calibre2">In the end, the <kbd class="calibre14">M5Factory.h</kbd> file that contains the templated Dynamic factory is only around 125 lines of code, with maybe 30% of that being comments and white space. It may be a little more difficult, but I don't think it is so difficult that someone should prefer the Static Factory.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we focused a lot on decoupling code. Since our game design is very likely to change, we want to make sure that our high-level modules don't depend on derived stages or components. That is why we should follow the Dependency Inversion Principle, which says the following:</p>
<ul class="calibre17">
<li class="calibre18">High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
<li class="calibre18">Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
<p class="calibre2">In simpler terms, this means that all our code should be built around the interfaces. We used the example of our <kbd class="calibre14">M5StageManager</kbd> not being dependent on derived <kbd class="calibre14">M5Stage</kbd> classes. Since we want to avoid class dependencies like this, we learned that we should also avoid <em class="calibre12">hard coding</em>, including using calls to the <kbd class="calibre14">new</kbd> operator. In order to avoid direct calls to the <kbd class="calibre14">new</kbd> operator, we learned about three ways to make Factories.</p>
<p class="calibre2">The first method was the classic Gang of Four Factory method, which says we should create a hierarchy of classes, each capable of instantiating a single class. This method helped us get to our final solution, but wasn't quite good enough, because we want to be able to select which derived class to instantiate via a string or an enum.</p>
<p class="calibre2">The second method we learned was the Static Factory Method, which uses a simple global or static function and a switch statement to allow us to select our desired derived class. This works great for our needs, but we decided to go one step further and create an even more flexible, reusable factory.</p>
<p class="calibre2">Finally, we learned about the Dynamic Factory, specifically the templated version of the Dynamic Factory, which combines both the classic Factory method and the Static Factory. The best part is that since we are using the power of C++ templates, we can reuse the code for stages and components, as well as objects.</p>
<p class="calibre2">Throughout this chapter, but especially in the last section, we discussed the balance between spending time writing flexible code versus over-architecting. Of course, one strong reason to study design patterns is to learn how to write great reusable code, but we always want to make sure it fits the project and fits within the project deadline.</p>
<p class="calibre2">The goal of this book is to help you understand when and where we should apply these patterns throughout a game. We already know how to create flexible game objects using components and Finite State Machines. Now that we know about the Dynamic factory, we have decoupled our stage and component creation from our core engine, making everything more reusable.</p>
<p class="calibre2">However, the ultimate goal is to make things so flexible that they can be changed from a text file or tool without the need to recompile anything. That is what we will learn how to do next.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>