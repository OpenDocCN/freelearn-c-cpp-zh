<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Rendering 2D Images and Videos with Texture Mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Rendering 2D Images and Videos with Texture Mapping</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with modern OpenGL (3.2 or higher)</li><li class="listitem" style="list-style-type: disc">Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows</li><li class="listitem" style="list-style-type: disc">Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux</li><li class="listitem" style="list-style-type: disc">Creating your first vertex and fragment shader using GLSL</li><li class="listitem" style="list-style-type: disc">Rendering 2D images with texture mapping</li><li class="listitem" style="list-style-type: disc">Real-time video rendering with filters</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Introduction</h1></div></div></div><p>In this chapter, we will introduce OpenGL techniques to visualize another important class of datasets: those involving images or videos. Such datasets are commonly encountered in many fields, including medical imaging applications. To enable the rendering of images, we will discuss fundamental OpenGL concepts for texture mapping and transition to more advanced techniques that require newer versions of OpenGL (OpenGL 3.2 or higher). To simplify our tasks, we will also employ several additional libraries, including <a id="id116" class="indexterm"/>
<span class="strong"><strong>OpenGL Extension Wrangler Library</strong></span> (<span class="strong"><strong>GLEW</strong></span>) for runtime OpenGL extension support, <span class="strong"><strong>Simple OpenGL Image Loader</strong></span> (<span class="strong"><strong>SOIL</strong></span>) to <a id="id117" class="indexterm"/>load different image formats, <span class="strong"><strong>OpenGL Mathematics</strong></span> (<span class="strong"><strong>GLM</strong></span>)<a id="id118" class="indexterm"/> for vector and matrix manipulation, as well as <span class="strong"><strong>OpenCV</strong></span> for image/video processing. To get started, we will first introduce the features of modern OpenGL 3.2 and higher.</p></div></div>
<div class="section" title="Getting started with modern OpenGL (3.2 or higher)"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Getting started with modern OpenGL (3.2 or higher)</h1></div></div></div><p>Continuous evolution <a id="id119" class="indexterm"/>of OpenGL APIs has led to the emergence of a modern standard. One of the biggest changes happened in 2008 with OpenGL version 3.0, in which a new context creation mechanism was introduced and most of the older functions, such as Begin/End primitive specifications, were marked as deprecated. The removal of these older standard features also implies a more flexible yet more powerful way of handling the graphics pipeline. In OpenGL 3.2 or higher, a core and a compatible profile were defined to differentiate the deprecated APIs from the current features. These profiles provide clear definitions for various features (core profile) while enabling backward compatibility (compatibility profile). In OpenGL 4.x, support for the latest graphics hardware that runs Direct3D 11 is provided, and a detailed comparison between OpenGL 3.x and OpenGL 4.x is available at <a class="ulink" href="http://www.g-truc.net/post-0269.html">http://www.g-truc.net/post-0269.html</a>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec82"/>Getting ready</h2></div></div></div><p>Starting from this chapter, we need compatible graphics cards with OpenGL 3.2 (or higher) support. Most graphics cards released before 2008 will most likely not be supported. For example, NVIDIA GeForce 100, 200, 300 series and higher support the OpenGL 3 standard. You are encouraged to consult the technical specifications of your graphics cards to confirm the compatibility (refer to <a class="ulink" href="https://developer.nvidia.com/opengl-driver">https://developer.nvidia.com/opengl-driver</a>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec83"/>How to do it...</h2></div></div></div><p>To enable OpenGL 3.2 support, we need to incorporate the following lines of code at the beginning of every program for initialization:</p><div class="informalexample"><pre class="programlisting">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec84"/>How it works...</h2></div></div></div><p>The <a id="id120" class="indexterm"/>
<code class="literal">glfwWindowHint</code> function <a id="id121" class="indexterm"/>defines a set of constraints for the creation of the GLFW windows context (refer to <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenGL</em></span>). The first two lines of code here define the current version of OpenGL that will be used (3.2 in this case). The third line enables forward compatibility, while the last line specifies that the core profile will be used.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec85"/>See also</h2></div></div></div><p>Detailed explanation of the differences between various OpenGL versions can be found at <a class="ulink" href="http://www.opengl.org/wiki/History_of_OpenGL">http://www.opengl.org/wiki/History_of_OpenGL</a>.</p></div></div>
<div class="section" title="Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows</h1></div></div></div><p>In this section, we <a id="id122" class="indexterm"/>will provide <a id="id123" class="indexterm"/>step-by-step instructions <a id="id124" class="indexterm"/>to set up several popular libraries that will be used extensively in this chapter (and in subsequent chapters), including<a id="id125" class="indexterm"/> the GLEW, GLM, SOIL, and OpenCV libraries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The GLEW library is an open-source OpenGL extension library.</li><li class="listitem" style="list-style-type: disc">The GLM library is a header-only C++ library that provides an easy-to-use set of common mathematical operations. It is built on the GLSL specifications and as it is a header-only library, it does not require tedious compilation steps.</li><li class="listitem" style="list-style-type: disc">The SOIL library is a simple C library that is used to load images in a variety of common formats (such as BMP, PNG, JPG, TGA, TIFF, and HDR) in OpenGL textures.</li><li class="listitem" style="list-style-type: disc">The OpenCV library is a very powerful open source computer vision library that we will use to simplify image and video processing in this chapter.</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Getting ready</h2></div></div></div><p>We will first need to download the prerequisite libraries from the following websites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLEW</strong></span> (glew-1.10.0): <a class="ulink" href="http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip">http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLM</strong></span> (glm-0.9.5.4): <a class="ulink" href="http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip">http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SOIL</strong></span>: <a class="ulink" href="http://www.lonesock.net/files/soil.zip">http://www.lonesock.net/files/soil.zip</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenCV</strong></span> (opencv-2.4.9): <a class="ulink" href="http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe">http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe</a></li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec87"/>How to do it...</h2></div></div></div><p>To use the precompiled package from GLEW, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Unzip the package.</li><li class="listitem">Copy the directory to <code class="literal">C:/Program Files (x86)</code>.</li><li class="listitem">Ensure that the <code class="literal">glew32.dll</code> file (<code class="literal">C:\Program Files (x86)\glew-1.10.0\bin\Release\Win32</code>) can be found at runtime by placing it either in the same <a id="id126" class="indexterm"/>folder as the executable or including the directory in the Windows system <code class="literal">PATH</code> environment variable (Navigate to <span class="strong"><strong>Control Panel</strong></span> | <span class="strong"><strong>System and Security</strong></span> | <span class="strong"><strong>System</strong></span> | <span class="strong"><strong>Advanced Systems Settings</strong></span> | <span class="strong"><strong>Environment Variables</strong></span>).</li></ol></div><p>To use <a id="id127" class="indexterm"/>the <a id="id128" class="indexterm"/>header-only <a id="id129" class="indexterm"/>GLM library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Unzip the package.</li><li class="listitem">Copy the directory to <code class="literal">C:/Program Files (x86)</code>.</li><li class="listitem">Include the desired header files in your source code. Here is an example:<div class="informalexample"><pre class="programlisting">#include &lt;glm/glm.hpp&gt;</pre></div></li></ol></div><p>To use the SOIL library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Unzip the package.</li><li class="listitem">Copy the directory to <code class="literal">C:/Program Files (x86)</code>.</li><li class="listitem">Generate the <code class="literal">SOIL.lib</code> file by opening the Visual Studio solution file (<code class="literal">C:\Program Files (x86)\Simple OpenGL Image Library\projects\VC9\SOIL.sln</code>) and compiling the project files. Copy this file from <code class="literal">C:\Program Files (x86)\Simple OpenGL Image Library\projects\VC9\Debug to C:\Program Files (x86)\Simple OpenGL Image Library\lib</code>.</li><li class="listitem">Include the header file in your source code:<div class="informalexample"><pre class="programlisting">#include &lt;SOIL.h&gt;</pre></div></li></ol></div><p>Finally, to install OpenCV, we recommend that you use prebuilt binaries to simplify the process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the prebuilt binaries from <a class="ulink" href="http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe">http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe</a> and extract the package.</li><li class="listitem">Copy the directory (the <code class="literal">opencv</code> folder) to <code class="literal">C:\Program Files (x86)</code>.</li><li class="listitem">Add this to the system <code class="literal">PATH</code> environment variable (Navigate to <span class="strong"><strong>Control Panel</strong></span> | <span class="strong"><strong>System and Security</strong></span> | <span class="strong"><strong>System</strong></span> | <span class="strong"><strong>Advanced Systems Settings</strong></span> | <span class="strong"><strong>Environment Variables</strong></span>) – <code class="literal">C:\Program Files (x86)\opencv\build\x86\vc12\bin</code>.</li><li class="listitem">Include the desired header files in your source code:<div class="informalexample"><pre class="programlisting">#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;</pre></div></li></ol></div><p>Now, we generate <a id="id130" class="indexterm"/>our Microsoft Visual Studio Solution files (the build environment) using <code class="literal">CMake</code>. We <a id="id131" class="indexterm"/>create the <code class="literal">CMakeList.txt</code> file within each project directory, which lists all the libraries and <a id="id132" class="indexterm"/>dependencies<a id="id133" class="indexterm"/> for the project. The following is a sample <code class="literal">CMakeList.txt</code> file for our first demo application:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.8)
set(CMAKE_CONFIGURATION_TYPES Debug Release)
set(PROGRAM_PATH "C:/Program Files \(x86\)")
set(OpenCV_DIR ${PROGRAM_PATH}/opencv/build)
project (code_simple)
#modify these path based on your configuration
#OpenCV
find_package(OpenCV REQUIRED )
INCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})
INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glm)
INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/include)
LINK_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/lib/Release)
INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/include)
LINK_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/lib)
INCLUDE_DIRECTORIES(${PROGRAM_PATH}/Simple\ OpenGL\ Image\ Library/src)
LINK_DIRECTORIES(${PROGRAM_PATH}/Simple\ OpenGL\ Image\ Library/lib)
add_subdirectory (../common common)
add_executable (main main.cpp)
target_link_libraries (main LINK_PUBLIC shader controls texture glew32s glfw3 opengl32 ${OpenCV_LIBS} SOIL)</pre></div><p>As you can see in the <code class="literal">CMakeList.txt</code> file, the various dependencies, including the OpenCV, SOIL, GLFW, and GLEW libraries, are all included.</p><p>Finally, we run the <code class="literal">CMake</code> program to generate the Microsoft Visual Studio Solution for the project (refer to <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenGL</em></span> for details). Note that the output path for the binary must match the project folder due to dependencies of the shader programs. The following is a screenshot of the <code class="literal">CMake</code> window after generating the first sample project called <code class="literal">code_simple</code>:</p><div class="mediaobject"><img src="graphics/9727OS_04_01.jpg" alt="How to do it..."/></div><p>We will <a id="id134" class="indexterm"/>repeat <a id="id135" class="indexterm"/>this step <a id="id136" class="indexterm"/>for each project we create, and the corresponding Microsoft Visual Studio Solution file <a id="id137" class="indexterm"/>will be generated accordingly (for example, <code class="literal">code_simple.sln</code> in this case). To compile the code, open <code class="literal">code_simple.sln</code> with Microsoft Visual Studio 2013 and build the project using the Build (press <span class="emphasis"><em>F7</em></span>) function as usual. Make sure that you set main as the start up project (by right-clicking on the <span class="emphasis"><em>main</em></span> project in the <span class="strong"><strong>Solution Explorer</strong></span> and left-clicking on the <span class="strong"><strong>Set as StartUp Project</strong></span> option) before running the program, as shown follows:</p><div class="mediaobject"><img src="graphics/9727OS_04_03.jpg" alt="How to do it..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec88"/>See also</h2></div></div></div><p>Further documentation on each of the libraries installed can be found here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLEW</strong></span>: <a class="ulink" href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLM</strong></span>: <a class="ulink" href="http://glm.g-truc.net/0.9.5/index.html">http://glm.g-truc.net/0.9.5/index.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SOIL</strong></span>: <a class="ulink" href="http://www.lonesock.net/soil.html">http://www.lonesock.net/soil.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenCV</strong></span>: <a class="ulink" href="http://opencv.org/">http://opencv.org/</a></li></ul></div></div></div>
<div class="section" title="Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux</h1></div></div></div><p>In this <a id="id138" class="indexterm"/>section, we will outline the steps required to set up the same libraries in Mac OS X and Linux.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Getting ready</h2></div></div></div><p>We will first need to <a id="id139" class="indexterm"/>download the prerequisite libraries from the following websites:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>GLEW</strong></span> (glew-1.10.0): <a class="ulink" href="https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz">https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz</a></li><li class="listitem"><span class="strong"><strong>GLM</strong></span> (glm-0.9.5.4): <a class="ulink" href="http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip">http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip</a></li><li class="listitem"><span class="strong"><strong>SOIL</strong></span>: <a class="ulink" href="http://www.lonesock.net/files/soil.zip">http://www.lonesock.net/files/soil.zip</a></li><li class="listitem"><span class="strong"><strong>OpenCV</strong></span> (opencv-2.4.9): <a class="ulink" href="http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip">http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip</a></li></ol></div><p>To simplify <a id="id140" class="indexterm"/>the <a id="id141" class="indexterm"/>installation process for Mac OS X or Ubuntu users, the use of MacPorts in Mac OS X or the <code class="literal">apt-get</code> command in Linux (as described in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenGL</em></span>) is highly recommended.</p><p>The following section assumes that the download directory is <code class="literal">~/opengl_dev</code> (refer to <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenGL</em></span>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec90"/>How to do it...</h2></div></div></div><p>There are two methods <a id="id142" class="indexterm"/>to install the prerequisite libraries. The first method uses precompiled binaries. These binary files are fetched from remote repository servers and the version updates of the library are controlled externally. An important advantage of this method is that it simplifies the installation, especially in terms of resolving dependencies. However, in a release environment, it is recommended that you disable the automatic updates and thus protect the binary from version skewing. The second method requires users to download and compile the source code directly with various customizations. This method is recommended for users who would like to control the installation process (such as the paths), and it also provides more flexibility in terms of tracking and fixing bugs.</p><p>For beginners or developers who are looking for rapid prototyping, we recommend that you use the first method as it will simplify the workflow and have short-term maintenance. On an Ubuntu or Debian system, we can install the various libraries using the <code class="literal">apt-get</code> command. To install all the prerequisite libraries and dependencies on Ubuntu, simply run the following commands in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install libglm-dev libglew1.6-dev libsoil-dev libopencv</strong></span>
</pre></div><p>Similarly, on Mac OS X, we can install GLEW, OpenCV, and GLM with MacPorts through command lines in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo port install opencv glm glew</strong></span>
</pre></div><p>However, the SOIL library<a id="id143" class="indexterm"/> is not currently supported by MacPorts, and thus, the installation has to be completed manually, as described in the following section.</p><p>For advanced <a id="id144" class="indexterm"/>users, we can install the latest packages by directly compiling from the source, and the upcoming steps are common among Mac OS as well as other Linux OS.</p><p>To compile the <a id="id145" class="indexterm"/>GLEW package, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract the <code class="literal">glew-1.10.0.tgz</code> package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tar xzvf glew-1.10.0.tgz</strong></span>
</pre></div></li><li class="listitem">Install GLEW in <code class="literal">/usr/include/GL</code> and <code class="literal">/usr/lib</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd glew-1.10.0</strong></span>
<span class="strong"><strong>make &amp;&amp; sudo make install </strong></span>
</pre></div></li></ol></div><p>To set up the header-only GLM library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract the unzip <code class="literal">glm-0.9.5.4.zip</code> package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>unzip glm-0.9.5.4.zip</strong></span>
</pre></div></li><li class="listitem">Copy the header-only GLM library directory (<code class="literal">~/opengl_dev/glm/glm</code>) to <code class="literal">/usr/include/glm</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo cp -r glm/glm/ /usr/include/glm</strong></span>
</pre></div></li></ol></div><p>To set up the SOIL library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract the unzip <code class="literal">soil.zip</code> package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>unzip soil.zip</strong></span>
</pre></div></li><li class="listitem">Edit <code class="literal">makefile</code> (inside the <code class="literal">projects/makefile</code> directory) and add <code class="literal">-arch x86_64</code> and <code class="literal">-arch i386</code> to <code class="literal">CXXFLAGS</code> to ensure proper support:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>CXXFLAGS =-arch x86_64 –arch i386 -O2 -s -Wall</strong></span>
</pre></div></li><li class="listitem">Compile the source code library:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd Simple\ OpenGL\ Image\ Library/projects/makefile</strong></span>
<span class="strong"><strong>mkdir obj</strong></span>
<span class="strong"><strong>make &amp;&amp; sudo make install</strong></span>
</pre></div></li></ol></div><p>To set up the OpenCV library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract the <code class="literal">opencv-2.4.9.zip</code> package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>unzip opencv-2.4.9.zip</strong></span>
</pre></div></li><li class="listitem">Build the OpenCV library using <code class="literal">CMake</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd opencv-2.4.9/</strong></span>
<span class="strong"><strong>mkdir build</strong></span>
<span class="strong"><strong>cd build</strong></span>
<span class="strong"><strong>cmake ../</strong></span>
<span class="strong"><strong>make &amp;&amp; sudo make install</strong></span>
</pre></div></li><li class="listitem">Configure the library path:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</strong></span>
<span class="strong"><strong>sudo ldconfig –v </strong></span>
</pre></div></li><li class="listitem">With the <a id="id146" class="indexterm"/>development <a id="id147" class="indexterm"/>environment fully configured, we <a id="id148" class="indexterm"/>can now create the compilation script (<code class="literal">Makefile</code>) within each project folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>CFILES = ../common/shader.cpp ../common/texture.cpp ../common/controls.cpp main.cpp </strong></span>
<span class="strong"><strong>CFLAGS = -O3 -c -Wall</strong></span>
<span class="strong"><strong>INCLUDES = -I/usr/include -I/usr/include/SOIL -I../common  `pkg-config --cflags glfw3` `pkg-config --cflags opencv`</strong></span>
<span class="strong"><strong>LIBS = -lm -L/usr/local/lib -lGLEW -lSOIL  `pkg-config --static --libs glfw3` `pkg-config --libs opencv`</strong></span>
<span class="strong"><strong>CC = g++</strong></span>
<span class="strong"><strong>OBJECTS=$(CFILES:.cpp=.o)</strong></span>
<span class="strong"><strong>EXECUTABLE=main</strong></span>
<span class="strong"><strong>all: $(CFILES) $(EXECUTABLE) </strong></span>
<span class="strong"><strong>$(EXECUTABLE): $(OBJECTS) </strong></span>
<span class="strong"><strong>  $(CC) $(INCLUDES) $(OBJECTS) -o $@ $(LIBS)</strong></span>
<span class="strong"><strong>.cpp.o:</strong></span>
<span class="strong"><strong>  $(CC) $(CFLAGS) $(INCLUDES) $&lt; -o $@</strong></span>

<span class="strong"><strong>clean:</strong></span>
<span class="strong"><strong>  rm -v -f *~ ../common/*.o *.o *.obj $(EXECUTABLE)</strong></span>
</pre></div></li></ol></div><p>To compile the code, we simply run the <code class="literal">make</code> command in the project directory and it generates the executable (<code class="literal">main</code>) automatically.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec91"/>See also</h2></div></div></div><p>Further documentation on each of the libraries installed can be found here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLEW</strong></span>: <a class="ulink" href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLM</strong></span>: <a class="ulink" href="http://glm.g-truc.net/0.9.5/index.html">http://glm.g-truc.net/0.9.5/index.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SOIL</strong></span>: <a class="ulink" href="http://www.lonesock.net/soil.html">http://www.lonesock.net/soil.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenCV</strong></span>: <a class="ulink" href="http://opencv.org/">http://opencv.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MacPorts</strong></span>: <a class="ulink" href="http://www.macports.org/">http://www.macports.org/</a></li></ul></div></div></div>
<div class="section" title="Creating your first vertex and fragment shader using GLSL"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Creating your first vertex and fragment shader using GLSL</h1></div></div></div><p>Before we <a id="id149" class="indexterm"/>can render images using OpenGL, we need to first understand the basics of the GLSL. In particular, the concept of shader programs is essential<a id="id150" class="indexterm"/> in GLSL. Shaders are simply programs that run on graphics processors (GPUs), and a set of shaders is compiled and linked to form a program. This concept emerges as a result of the increasing complexity of various common processing tasks in modern graphics hardware, such as vertex and fragment processing, which necessitates greater programmability of specialized processors. Accordingly, the vertex and fragment shader are two important types of shaders that we will cover here, and they run on the vertex processor and fragment processor, respectively. A simplified diagram illustrating the overall processing pipeline is shown as follows:</p><div class="mediaobject"><img src="graphics/9727OS_04_02.jpg" alt="Creating your first vertex and fragment shader using GLSL"/></div><p>The main purpose of the vertex shader is to perform the processing of a stream of vertex data. An important processing task involves the transformation of the position of each vertex from the 3D virtual space to a 2D coordinate for display on the screen. Vertex shaders can also manipulate the color and texture coordinates. Therefore, vertex shaders serve as an important component of the OpenGL pipeline to control movement, lighting, and color.</p><p>A fragment shader is primarily designed to compute the final color of an individual pixel (fragment). Oftentimes, we implement various image post-processing techniques, such as blurring or sharpening, at this stage; the end results are stored in the framebuffer, which will be displayed on screen.</p><p>For readers<a id="id151" class="indexterm"/> interested in understanding the rest of the pipeline, a detailed summary of these stages, such as the clipping, rasterization, and tessellation, can be found at <a class="ulink" href="https://www.opengl.org/wiki/Rendering_Pipeline_Overview">https://www.opengl.org/wiki/Rendering_Pipeline_Overview</a>. Additionally, a detailed documentation of GLSL can be found at <a class="ulink" href="https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf">https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf</a>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec92"/>Getting ready</h2></div></div></div><p>At this point, we <a id="id152" class="indexterm"/>should have all the prerequisite libraries, such as GLEW, GLM, and SOIL. With GLFW configured for the OpenGL core profile, we are now ready to implement the first simple example code, which takes advantage of the modern OpenGL pipeline.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec93"/>How to do it...</h2></div></div></div><p>To keep the code simple, we will divide the program into two components: the main program (<code class="literal">main.cpp</code>) and shader programs (<code class="literal">shader.cpp</code>, <code class="literal">shader.hpp</code>, <code class="literal">simple.vert</code>, and <code class="literal">simple.frag</code>). The main program performs the essential tasks to set up the simple demo, while the shader programs perform the specialized processing in the modern OpenGL pipeline. The complete sample code can be found in the <code class="literal">code_simple</code> folder.</p><p>First, let's take a look at the shader programs. We will create two extremely simple vertex and fragment shader programs (specified inside the <code class="literal">simple.vert</code> and <code class="literal">simple.frag</code> files) that are compiled and loaded by the program at runtime.</p><p>For the <code class="literal">simple.vert</code> file, enter the following lines of code:</p><div class="informalexample"><pre class="programlisting">#version 150 
in vec3 position;
in vec3 color_in;
out vec3 color;
void main() {
  color = color_in;
  gl_Position = vec4(position, 1.0);
}</pre></div><p>For the <code class="literal">simple.frag</code> file, enter the following lines of code:</p><div class="informalexample"><pre class="programlisting">#version 150 
in vec3 color;
out vec4 color_out;
void main() {
  color_out = vec4(Color, 1.0);
}</pre></div><p>First, let's define a function to compile and load the shader programs (<code class="literal">simple.frag</code> and <code class="literal">simple.vert</code>) called <code class="literal">LoadShaders</code> inside <code class="literal">shader.hpp</code>:</p><div class="informalexample"><pre class="programlisting">#ifndef SHADER_HPP
#define SHADER_HPP
GLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path);
#endif</pre></div><p>Next, we will <a id="id153" class="indexterm"/>create the <code class="literal">shader.cpp</code> file to implement the <code class="literal">LoadShaders</code> function and two helper functions to handle file I/O (<code class="literal">readSourceFile</code>) and <a id="id154" class="indexterm"/>the compilation of the shaders (<code class="literal">CompileShader</code>):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include prerequisite libraries and the <code class="literal">shader.hpp</code> header file:<div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include "shader.hpp"</pre></div></li><li class="listitem">Implement the <code class="literal">readSourceFile</code> function as follows:<div class="informalexample"><pre class="programlisting">std::string readSourceFile(const char *path){
  std::string code;
  std::ifstream file_stream(path, std::ios::in);
  if(file_stream.is_open()){
    std::string line = "";
    while(getline(file_stream, line))
    code += "\n" + line;
    file_stream.close();
    return code;
  }else{
    printf("Failed to open \"%s\".\n", path);
    return "";
  }
}</pre></div></li><li class="listitem">Implement the <code class="literal">CompileShader</code> function as follows:<div class="informalexample"><pre class="programlisting">void CompileShader(std::string program_code, GLuint shader_id){
  GLint result = GL_FALSE;
  int infolog_length;
  char const * program_code_pointer = program_code.c_str();
  glShaderSource(shader_id, 1, &amp;program_code_pointer , NULL);
  glCompileShader(shader_id);
  //check the shader for successful compile
  glGetShaderiv(shader_id, GL_COMPILE_STATUS, &amp;result);
  glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &amp;infolog_length);
  if ( infolog_length &gt; 0 ){
    std::vector&lt;char&gt; error_msg(infolog_length+1);
    glGetShaderInfoLog(shader_id, infolog_length, NULL, &amp;error_msg[0]);
    printf("%s\n", &amp;error_msg[0]);
  }
}</pre></div></li><li class="listitem">Now, let's <a id="id155" class="indexterm"/>implement<a id="id156" class="indexterm"/> the <code class="literal">LoadShaders</code> function. First, create the shader ID and read the shader code from two files specified by <code class="literal">vertex_file_path</code> and <code class="literal">fragment_file_path</code>:<div class="informalexample"><pre class="programlisting">GLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path){
  GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
  GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);
  std::string vertex_shader_code = readSourceFile(vertex_file_path);
  if(vertex_shader_code == ""){
    return 0; 
  }
  std::string fragment_shader_code = readSourceFile(fragment_file_path);
  if(fragment_shader_code == ""){
    return 0; 
  }</pre></div></li><li class="listitem">Compile the vertex shader and fragment shader programs:<div class="informalexample"><pre class="programlisting">  printf("Compiling Vertex shader : %s\n", vertex_file_path);
  CompileShader(vertex_shader_code, vertex_shader_id);
  printf("Compiling Fragment shader : %s\n",fragment_file_path);
  CompileShader(fragment_shader_code, fragment_shader_id);</pre></div></li><li class="listitem">Link the programs together, check for errors, and clean up:<div class="informalexample"><pre class="programlisting">  GLint result = GL_FALSE;
  int infolog_length;
  printf("Linking program\n");
  GLuint program_id = glCreateProgram();
  glAttachShader(program_id, vertex_shader_id);
  glAttachShader(program_id, fragment_shader_id);
  glLinkProgram(program_id);
  //check the program and ensure that the program is linked properly
  glGetProgramiv(program_id, GL_LINK_STATUS, &amp;result);
  glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &amp;infolog_length);
  if ( infolog_length &gt; 0 ){
    std::vector&lt;char&gt; program_error_msg(infolog_length+1);
    glGetProgramInfoLog(program_id, infolog_length, NULL, &amp;program_error_msg[0]);
    printf("%s\n", &amp;program_error_msg[0]);
  }else{
    printf("Linked Successfully\n");
  }

  //flag for delete, and will free all memories
  //when the attached program is deleted
  glDeleteShader(vertex_shader_id);
  glDeleteShader(fragment_shader_id);
  return program_id;
}</pre></div></li></ol></div><p>Finally, let's <a id="id157" class="indexterm"/>put <a id="id158" class="indexterm"/>everything together with the <code class="literal">main.cpp</code> file:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include prerequisite libraries and the shader program header file inside the common folder:<div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//GLFW and GLEW libraries
#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include "common/shader.hpp"</pre></div></li><li class="listitem">Create a global variable for the GLFW window:<div class="informalexample"><pre class="programlisting">//Global variables
GLFWwindow* window;</pre></div></li><li class="listitem">Start the main program with the initialization of the GLFW library:<div class="informalexample"><pre class="programlisting">int main(int argc, char **argv)
{
  //Initialize GLFW
  if(!glfwInit()){
    fprintf( stderr, "Failed to initialize GLFW\n" );
    exit(EXIT_FAILURE);
  }</pre></div></li><li class="listitem">Set up the GLFW window:<div class="informalexample"><pre class="programlisting">  //enable anti-aliasing 4x with GLFW
  glfwWindowHint(GLFW_SAMPLES, 4);
  /* specify the client API version that the created context must be compatible with. */
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
  //make the GLFW forward compatible
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
  //use the OpenGL Core 
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</pre></div></li><li class="listitem">Create<a id="id159" class="indexterm"/> the <a id="id160" class="indexterm"/>GLFW window object and make the context of the specified window current on the calling thread:<div class="informalexample"><pre class="programlisting">  window = glfwCreateWindow(640, 480, "Chapter 4 - GLSL", NULL, NULL);
  if(!window){
    fprintf( stderr, "Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\n" );
    glfwTerminate();
    exit(EXIT_FAILURE);
  }
  glfwMakeContextCurrent(window);
  glfwSwapInterval(1);</pre></div></li><li class="listitem">Initialize the GLEW library and include support for experimental drivers:<div class="informalexample"><pre class="programlisting">  glewExperimental = true; 
  if (glewInit() != GLEW_OK) {
    fprintf(stderr, "Final to Initialize GLEW\n");
    glfwTerminate();
    exit(EXIT_FAILURE);
  }</pre></div></li><li class="listitem">Set up the shader programs:<div class="informalexample"><pre class="programlisting">  GLuint program = LoadShaders("simple.vert", "simple.frag");
  glBindFragDataLocation(program, 0, "color_out");
  glUseProgram(program);</pre></div></li><li class="listitem">Set up Vertex Buffer Object (and color buffer) and copy the vertex data to it:<div class="informalexample"><pre class="programlisting">  GLuint vertex_buffer;
  GLuint color_buffer;
  glGenBuffers(1, &amp;vertex_buffer);
  glGenBuffers(1, &amp;color_buffer);
  const GLfloat vertices[] = {
    -1.0f, -1.0f, 0.0f,
    1.0f, -1.0f, 0.0f,
    1.0f, 1.0f, 0.0f,
    -1.0f, -1.0f, 0.0f,
    1.0f, 1.0f, 0.0f,
    -1.0f, 1.0f, 0.0f
  };
  const GLfloat colors[]={
    0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f,
    1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f,
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f
  };

  glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);</pre></div></li><li class="listitem">Specify<a id="id161" class="indexterm"/> the layout of the vertex<a id="id162" class="indexterm"/> data:<div class="informalexample"><pre class="programlisting">  GLint position_attrib = glGetAttribLocation(program, "position");
  glEnableVertexAttribArray(position_attrib);
  glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
  glVertexAttribPointer(position_attrib, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

  GLint color_attrib = glGetAttribLocation(program, "color_in");
  glEnableVertexAttribArray(color_attrib);
  glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
  glVertexAttribPointer(color_attrib, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);</pre></div></li><li class="listitem">Run the drawing program:<div class="informalexample"><pre class="programlisting">  while(!glfwWindowShouldClose(window)){
    // Clear the screen to black
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    // Draw a rectangle from the 2 triangles using 6 vertices
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glfwSwapBuffers(window);
    glfwPollEvents();
  }</pre></div></li><li class="listitem">Clean up and exit the program:<div class="informalexample"><pre class="programlisting">  //clean up the memories
  glDisableVertexAttribArray(position_attrib);
  glDisableVertexAttribArray(color_attrib);
  glDeleteBuffers(1, &amp;vertex_buffer);
  glDeleteBuffers(1, &amp;color_buffer);
  glDeleteVertexArrays(1, &amp;vertex_array);
  glDeleteProgram(program);
  // Close OpenGL window and terminate GLFW
  glfwDestroyWindow(window);
  glfwTerminate();
  exit(EXIT_SUCCESS);
}</pre></div></li></ol></div><p>Now we <a id="id163" class="indexterm"/>have <a id="id164" class="indexterm"/>created the first GLSL program by defining custom shaders:</p><div class="mediaobject"><img src="graphics/9727OS_04_04.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec94"/>How it works...</h2></div></div></div><p>As there are multiple components in this implementation, we will highlight the key features inside each component separately, organized in the same order as the previous section using the same file name for simplicity.</p><p>Inside <code class="literal">simple.vert</code>, we <a id="id165" class="indexterm"/>defined a simple vertex shader. In the first simple implementation, the vertex shader simply passes information forward to the rest of the rendering pipeline. First, we need to define the GLSL version that corresponds to the OpenGL 3.2 support, which is 1.50 (<code class="literal">#version 150</code>). The vertex shader takes two parameters: the position of the vertex (<code class="literal">in vec3 position</code>) and the color (<code class="literal">in vec3 color_in</code>). Note that only the color is defined explicitly in an output variable (<code class="literal">out vec3 color</code>) as <code class="literal">gl_Position</code> is a built-in variable. In general, variable names with the prefix <code class="literal">gl</code> should not be used inside shader programs in OpenGL as these are reserved for built-in variables. Notice that the final position, <code class="literal">gl_Position</code>, is expressed in homogeneous coordinates.</p><p>Inside <code class="literal">simple.frag</code>, we <a id="id166" class="indexterm"/>defined the fragment shader, which again passes the color information forward to the output framebuffer. Notice that the final output (<code class="literal">color_out</code>) is expressed in the RGBA format, where A is the alpha value (transparency).</p><p>Next, in <code class="literal">shader.cpp</code>, we created a framework to compile and link shader programs. The workflow shares some similarity with conventional code compilation in C/C++. Briefly, there are six major steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a shader object (<code class="literal">glCreateShader</code>).</li><li class="listitem">Read and set the shader source code (<code class="literal">glShaderSource</code>).</li><li class="listitem">Compile (<code class="literal">glCompileShader</code>).</li><li class="listitem">Create the final program ID (<code class="literal">glCreateProgram</code>).</li><li class="listitem">Attach a shader to the program ID (<code class="literal">glAttachShader</code>).</li><li class="listitem">Link everything together (<code class="literal">glLinkProgram</code>).</li></ol></div><p>Finally, in <code class="literal">main.cpp</code>, we set up a demo to illustrate the use of the compiled shader program. As described in the <span class="emphasis"><em>Getting Started with Modern OpenGL</em></span> section of this chapter, we need to use the <code class="literal">glfwWindowHint</code> function to properly create the GLFW window context in OpenGL 3.2. An interesting aspect to point out about this demo is that even though we defined only six vertices (three vertices for each of the two triangles drawn using the <code class="literal">glDrawArrays</code> function) and their corresponding colors, the final result is an interpolated color gradient.</p></div></div>
<div class="section" title="Rendering 2D images with texture mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Rendering 2D images with texture mapping</h1></div></div></div><p>Now <a id="id167" class="indexterm"/>that we have introduced the basics of GLSL using a simple example, we will incorporate further complexity to provide a complete framework that enables users to modify any part of the rendering pipeline in the future.</p><p>The code in this framework is divided into smaller modules to handle the shader programs (<code class="literal">shader.cpp</code> and <code class="literal">shader.hpp</code>), texture mapping (<code class="literal">texture.cpp</code> and <code class="literal">texture.hpp</code>), and user inputs (<code class="literal">controls.hpp</code> and <code class="literal">controls.hpp</code>). First, we will reuse the mechanism to load shader programs in OpenGL introduced previously and incorporate new shader programs for our purpose. Next, we will introduce the steps required for texture mapping. Finally, we will describe the main program, which integrates all<a id="id168" class="indexterm"/> the logical pieces and prepares the final demo. In this section, we will show how we can load an image and convert it into a texture object to be rendered in OpenGL. With this framework in mind, we will further demonstrate how to render a video in the next section.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Getting ready</h2></div></div></div><p>To avoid redundancy here, we will refer readers to the previous section for part of this demo (in particular, <code class="literal">shader.cpp</code> and <code class="literal">shader.hpp</code>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec96"/>How to do it...</h2></div></div></div><p>First, we aggregate all the common libraries used in our program into the <code class="literal">common.h</code> header file. The <code class="literal">common.h</code> file is then included in <code class="literal">shader.hpp</code>, <code class="literal">controls.hpp</code>, <code class="literal">texture.hpp</code>, and <code class="literal">main.cpp</code>:</p><div class="informalexample"><pre class="programlisting">#ifndef _COMMON_h
#define _COMMON_h
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
using namespace std; 
#endif</pre></div><p>We previously implemented a mechanism to load a fragment and vertex shader program from files, and we will reuse the code here (<code class="literal">shader.cpp</code> and <code class="literal">shader.hpp</code>). However, we will modify the actual vertex and shader programs as follows.</p><p>For the vertex shader (<code class="literal">transform.vert</code>), we will implement the following:</p><div class="informalexample"><pre class="programlisting">#version 150 
in vec2 UV;
out vec4 color;
uniform sampler2D textureSampler;
void main(){
  color = texture(textureSampler, UV).rgba;
}</pre></div><p>For the fragment shader (<code class="literal">texture.frag</code>), we will implement the following:</p><div class="informalexample"><pre class="programlisting">#version 150
in vec3 vertexPosition_modelspace;
in vec2 vertexUV;
out vec2 UV;
uniform mat4 MVP;
void main(){
  //position of the vertex in clip space
  gl_Position = MVP * vec4(vertexPosition_modelspace,1);
  UV = vertexUV;
}</pre></div><p>For the<a id="id169" class="indexterm"/> texture objects, in <code class="literal">texture.cpp</code>, we provide a mechanism to load images or video stream into the texture memory. We also take advantage of the SOIL library for simple image loading and the OpenCV library for more advanced video stream handling and filtering (refer to the next section).</p><p>In <code class="literal">texture.cpp</code>, we will implement the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the <code class="literal">texture.hpp</code> header and SOIL library header for simple image loading:<div class="informalexample"><pre class="programlisting">#include "texture.hpp"
#include &lt;SOIL.h&gt;</pre></div></li><li class="listitem">Define the initialization of texture objects and set up all parameters:<div class="informalexample"><pre class="programlisting">GLuint initializeTexture(const unsigned char *image_data, int width, int height, GLenum format){
  GLuint textureID=0;
  //create and bind one texture element
  glGenTextures(1, &amp;textureID);
  glBindTexture(GL_TEXTURE_2D, textureID);
  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
  /* Specify target texture. The parameters describe the format and type of the image data */
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, format, GL_UNSIGNED_BYTE, image_data);
  /* Set the wrap parameter for texture coordinate s &amp; t to GL_CLAMP, which clamps the coordinates within [0, 1] */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  /* Set the magnification method to linear and return weighted average of four texture elements closest to the center of the pixel */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  /* Choose the mipmap that most closely matches the size of the pixel being textured and use the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glGenerateMipmap(GL_TEXTURE_2D);
  return textureID;
}</pre></div></li><li class="listitem">Define the <a id="id170" class="indexterm"/>routine to update the texture memory:<div class="informalexample"><pre class="programlisting">void updateTexture(const unsigned char *image_data, int width, int height, GLenum format){
  // Update Texture
  glTexSubImage2D (GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, image_data);
  /* Sets the wrap parameter for texture coordinate s &amp; t to GL_CLAMP, which clamps the coordinates within [0, 1]. */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  /* Set the magnification method to linear and return weighted average of four texture elements closest to the center of the pixel */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  /* Choose the mipmap that most closely matches the size of the pixel being textured and use the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. */
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glGenerateMipmap(GL_TEXTURE_2D);
}</pre></div></li><li class="listitem">Finally, implement the texture-loading mechanism for images. The function takes the image path and automatically converts the image into various compatible formats for the texture object:<div class="informalexample"><pre class="programlisting">GLuint loadImageToTexture(const char * imagepath){
  int width, height, channels;
  GLuint textureID=0;
  //Load the images and convert them to RGBA format
  unsigned char* image = SOIL_load_image(imagepath, &amp;width, &amp;height, &amp;channels, SOIL_LOAD_RGBA);
  if(!image){
    printf("Failed to load image %s\n", imagepath);
    return textureID;
  }
  printf("Loaded Image: %d x %d - %d channels\n", width, height, channels);
  textureID=initializeTexture(image, width, height, GL_RGBA);
  SOIL_free_image_data(image);
  return textureID;
}</pre></div></li></ol></div><p>On the controller <a id="id171" class="indexterm"/>front, we capture the arrow keys and modify the camera model parameter in real time. This allows us to change the position and orientation of the camera as well as the angle of view. In <code class="literal">controls.cpp</code>, we implement the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the GLM library header and the <code class="literal">controls.hpp</code> header for the projection matrix and view matrix computations:<div class="informalexample"><pre class="programlisting">#define GLM_FORCE_RADIANS
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include "controls.hpp"</pre></div></li><li class="listitem">Define global variables (camera parameters as well as view and projection matrices) to be updated after each frame:<div class="informalexample"><pre class="programlisting">//initial position of the camera
glm::vec3 g_position = glm::vec3( 0, 0, 2 );
const float speed = 3.0f; // 3 units / second
float g_initial_fov = glm::pi&lt;float&gt;()*0.4f;
//the view matrix and projection matrix
glm::mat4 g_view_matrix;
glm::mat4 g_projection_matrix;</pre></div></li><li class="listitem">Create helper functions to return the most updated view matrix and projection matrix:<div class="informalexample"><pre class="programlisting">glm::mat4 getViewMatrix(){
  return g_view_matrix;
}
glm::mat4 getProjectionMatrix(){
  return g_projection_matrix;
}</pre></div></li><li class="listitem">Compute the view matrix and projection matrix based on the user input:<div class="informalexample"><pre class="programlisting">void computeViewProjectionMatrices(GLFWwindow* window){
  static double last_time = glfwGetTime();
  // Compute time difference between current and last frame
  double current_time = glfwGetTime();
  float delta_time = float(current_time - last_time);
  int width, height;
  glfwGetWindowSize(window, &amp;width, &amp;height);
  //direction vector for movement
  glm::vec3 direction(0, 0, -1);
  //up vector
  glm::vec3 up = glm::vec3(0,-1,0);
  if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS){
    g_position += direction * delta_time * speed;
  }
  else if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS){
    g_position -= direction * delta_time * speed;
  }
  else if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS){
    g_initial_fov -= 0.1 * delta_time * speed;
  }
  else if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS){
    g_initial_fov += 0.1 * delta_time * speed;
  }
  /* update projection matrix: Field of View, aspect ratio, display range : 0.1 unit &lt;-&gt; 100 units */
  g_projection_matrix = glm::perspective(g_initial_fov, (float)width/(float)height, 0.1f, 100.0f);

  // update the view matrix
  g_view_matrix = glm::lookAt(
    g_position,      // camera position
    g_position+direction, // viewing direction
    up         // up direction
  );
  last_time = current_time;
}</pre></div></li></ol></div><p>In <code class="literal">main.cpp</code>, we <a id="id172" class="indexterm"/>will use the various previously defined functions to complete the implementation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the GLFW and GLM libraries as well as our helper functions, which are stored in separate files inside a folder called the <code class="literal">common</code> folder:<div class="informalexample"><pre class="programlisting">#define GLM_FORCE_RADIANS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
using namespace glm;
#include &lt;common/shader.hpp&gt;
#include &lt;common/texture.hpp&gt;
#include &lt;common/controls.hpp&gt;
#include &lt;common/common.h&gt;</pre></div></li><li class="listitem">Define all global variables for the setup:<div class="informalexample"><pre class="programlisting">GLFWwindow* g_window;
const int WINDOWS_WIDTH = 1280;
const int WINDOWS_HEIGHT = 720;
float aspect_ratio = 3.0f/2.0f;
float z_offset = 2.0f;
float rotateY = 0.0f;
float rotateX = 0.0f;
//Our vertices
static const GLfloat g_vertex_buffer_data[] = {
  -aspect_ratio,-1.0f,z_offset,
  aspect_ratio,-1.0f,z_offset,
  aspect_ratio,1.0f,z_offset,
  -aspect_ratio,-1.0f,z_offset,
  aspect_ratio,1.0f,z_offset,
  -aspect_ratio,1.0f,z_offset
};
//UV map for the vertices
static const GLfloat g_uv_buffer_data[] = {
  1.0f, 0.0f,
  0.0f, 0.0f,
  0.0f, 1.0f,
  1.0f, 0.0f,
  0.0f, 1.0f,
  1.0f, 1.0f
};</pre></div></li><li class="listitem">Define<a id="id173" class="indexterm"/> the keyboard <code class="literal">callback</code> function:<div class="informalexample"><pre class="programlisting">static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
  if (action != GLFW_PRESS &amp;&amp; action != GLFW_REPEAT)
  return;
  switch (key)
  {
    case GLFW_KEY_ESCAPE:
      glfwSetWindowShouldClose(window, GL_TRUE);
      break;
    case GLFW_KEY_SPACE:
      rotateX=0;
      rotateY=0;
      break;
    case GLFW_KEY_Z:
      rotateX+=0.01;
      break;
    case GLFW_KEY_X:
      rotateX-=0.01;
      break;
    case GLFW_KEY_A:
      rotateY+=0.01;
      break;
    case GLFW_KEY_S:
      rotateY-=0.01;
      break;
    default:
      break;
  }
}</pre></div></li><li class="listitem">Initialize <a id="id174" class="indexterm"/>the GLFW library with the OpenGL core profile enabled:<div class="informalexample"><pre class="programlisting">int main(int argc, char **argv)
{
  //Initialize the GLFW
  if(!glfwInit()){
    fprintf( stderr, "Failed to initialize GLFW\n" );
    exit(EXIT_FAILURE);
  }

  //enable anti-alising 4x with GLFW
  glfwWindowHint(GLFW_SAMPLES, 4);
  //specify the client API version 
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
  //make the GLFW forward compatible
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
  //enable the OpenGL core profile for GLFW 
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</pre></div></li><li class="listitem">Set up the GLFW windows and keyboard input handlers:<div class="informalexample"><pre class="programlisting">  //create a GLFW windows object
  window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, "Chapter 4 - Texture Mapping", NULL, NULL);
  if(!window){
    fprintf( stderr, "Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\n" );
    glfwTerminate();
    exit(EXIT_FAILURE);
  }
  /* make the context of the specified window current for the calling thread */
  glfwMakeContextCurrent(window);
  glfwSwapInterval(1);
  glewExperimental = true; // Needed for core profile
  if (glewInit() != GLEW_OK) {
    fprintf(stderr, "Final to Initialize GLEW\n");
    glfwTerminate();
    exit(EXIT_FAILURE);
  }
  //keyboard input callback
  glfwSetInputMode(window,GLFW_STICKY_KEYS,GL_TRUE);
  glfwSetKeyCallback(window, key_callback);</pre></div></li><li class="listitem">Set a <a id="id175" class="indexterm"/>black background and enable alpha blending for various visual effects:<div class="informalexample"><pre class="programlisting">  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);</pre></div></li><li class="listitem">Load the vertex shader and fragment shader:<div class="informalexample"><pre class="programlisting">  GLuint program_id = LoadShaders( "transform.vert", "texture.frag" );</pre></div></li><li class="listitem">Load an image file into the texture object using the SOIL library:<div class="informalexample"><pre class="programlisting">  char *filepath;
  //load the texture from image with SOIL
  if(argc&lt;2){
    filepath = (char*)malloc(sizeof(char)*512);
    sprintf(filepath, "texture.png");
  }
  else{
    filepath = argv[1];
  }

  int width;
  int height;
  GLuint texture_id = loadImageToTexture(filepath, &amp;width, &amp;height);

  aspect_ratio = (float)width/(float)height;
  if(!texture_id){
    //if we get 0 with no texture
    glfwTerminate();
    exit(EXIT_FAILURE); 
  }</pre></div></li><li class="listitem">Get the <a id="id176" class="indexterm"/>locations of the specific variables in the shader programs:<div class="informalexample"><pre class="programlisting">  //get the location for our "MVP" uniform variable
  GLuint matrix_id = glGetUniformLocation(program_id, "MVP");
  //get a handler for our "myTextureSampler" uniform
  GLuint texture_sampler_id = glGetUniformLocation(program_id, "textureSampler");
  //attribute ID for the variables
  GLint attribute_vertex, attribute_uv;
  attribute_vertex = glGetAttribLocation(program_id, "vertexPosition_modelspace");
  attribute_uv = glGetAttribLocation(program_id, "vertexUV");</pre></div></li><li class="listitem">Define our <a id="id177" class="indexterm"/><span class="strong"><strong>Vertex Array Objects</strong></span> (<span class="strong"><strong>VAO</strong></span>):<div class="informalexample"><pre class="programlisting">  GLuint vertex_array_id;
  glGenVertexArrays(1, &amp;vertex_array_id);
  glBindVertexArray(vertex_array_id);</pre></div></li><li class="listitem">Define our VAO for vertices and UV mapping:<div class="informalexample"><pre class="programlisting">  //initialize the vertex buffer memory.
  GLuint vertex_buffer;
  glGenBuffers(1, &amp;vertex_buffer);
  glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW);
  //initialize the UV buffer memory
  GLuint uv_buffer;
  glGenBuffers(1, &amp;uv_buffer);
  glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_uv_buffer_data), g_uv_buffer_data, GL_STATIC_DRAW);</pre></div></li><li class="listitem">Use the shader program and bind all texture units and attribute buffers:<div class="informalexample"><pre class="programlisting">  glUseProgram(program_id);
  //binds our texture in Texture Unit 0
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, texture_id);
  glUniform1i(texture_sampler_id, 0);
  //1st attribute buffer: vertices for position
  glEnableVertexAttribArray(attribute_vertex);
  glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
  glVertexAttribPointer(attribute_vertex, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
  //2nd attribute buffer: UVs mapping
  glEnableVertexAttribArray(attribute_uv);
  glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
  glVertexAttribPointer(attribute_uv, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);</pre></div></li><li class="listitem">In the main loop, clear the screen and depth buffers:<div class="informalexample"><pre class="programlisting">  //time-stamping for performance measurement
  double previous_time = glfwGetTime(); 
  do{
    //clear the screen
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);</pre></div></li><li class="listitem">Compute<a id="id178" class="indexterm"/> the transforms and store the information in the shader variables:<div class="informalexample"><pre class="programlisting">    //compute the MVP matrix from keyboard and mouse input
    computeMatricesFromInputs(g_window);
    //obtain the View and Model Matrix for rendering
    glm::mat4 projection_matrix = getProjectionMatrix();
    glm::mat4 view_matrix = getViewMatrix();
    glm::mat4 model_matrix = glm::mat4(1.0);
    model_matrix = glm::rotate(model_matrix, glm::pi&lt;float&gt;() * rotateY, glm::vec3(0.0f, 1.0f, 0.0f));
    model_matrix = glm::rotate(model_matrix, glm::pi&lt;float&gt;() * rotateX, glm::vec3(1.0f, 0.0f, 0.0f));
    glm::mat4 mvp = projection_matrix * view_matrix * model_matrix;
    //send our transformation to the currently bound shader 
    //in the "MVP" uniform variable
    glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &amp;mvp[0][0]);</pre></div></li><li class="listitem">Draw the elements and flush the screen:<div class="informalexample"><pre class="programlisting">    glDrawArrays(GL_TRIANGLES, 0, 6); //draw a square
    //swap buffers
    glfwSwapBuffers(window);
    glfwPollEvents();</pre></div></li><li class="listitem">Finally, define the conditions to exit the <code class="literal">main</code> loop and clear all the memory to exit the program gracefully:<div class="informalexample"><pre class="programlisting">  } // Check if the ESC key was pressed or the window was closed
  while(!glfwWindowShouldClose(window) &amp;&amp; glfwGetKey(window, GLFW_KEY_ESCAPE )!=GLFW_PRESS);
  glDisableVertexAttribArray(attribute_vertex);
  glDisableVertexAttribArray(attribute_uv);
  // Clean up VBO and shader
  glDeleteBuffers(1, &amp;vertex_buffer);
  glDeleteBuffers(1, &amp;uv_buffer);
  glDeleteProgram(program_id);
  glDeleteTextures(1, &amp;texture_id);
  glDeleteVertexArrays(1, &amp;vertex_array_id);
  // Close OpenGL window and terminate GLFW
  glfwDestroyWindow(g_window);
  glfwTerminate();
  exit(EXIT_SUCCESS);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec97"/>How it works...</h2></div></div></div><p>To demonstrate <a id="id179" class="indexterm"/>the use of the framework for data visualization, we will apply it to the visualization of a histology slide (an H&amp;E cross-section of a skin sample), as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/9727OS_04_05.jpg" alt="How it works..."/></div><p>An important difference between this demo and the previous one is that here, we actually load an image into the texture memory (<code class="literal">texture.cpp</code>). To facilitate this task, we use the SOIL library call (<code class="literal">SOIL_load_image</code>) to load the histology image in the RGBA format (<code class="literal">GL_RGBA</code>) and the <code class="literal">glTexImage2D</code> function call to generate a texture image that can be read by shaders.</p><p>Another important <a id="id180" class="indexterm"/>difference is that we can now dynamically recompute the view (<code class="literal">g_view_matrix</code>) and projection (<code class="literal">g_projection_matrix</code>) matrices to enable an interactive and interesting visualization of an image in the 3D space. Note that the GLM library header is included to facilitate the matrix computations. Using the keyboard inputs (up, down, left, and right) defined in <code class="literal">controls.cpp</code> with the GLFW library calls, we can zoom in and out of the slide as well as adjust the view angle, which gives an interesting perspective of the histology image in the 3D virtual space. Here is a screenshot of the image viewed with a different perspective:</p><div class="mediaobject"><img src="graphics/9727OS_04_06.jpg" alt="How it works..."/></div><p>Yet another unique feature of the current OpenGL-based framework is illustrated by the following screenshot, which is generated with a new image filter implemented into the fragment shader that highlights the edges in the image. This shows the endless possibilities for the real-time interactive visualization and processing of 2D images using OpenGL rendering pipeline without compromising on CPU performance. The filter implemented here will be discussed in the next section.</p><div class="mediaobject"><img src="graphics/9727OS_04_07.jpg" alt="How it works..."/></div></div></div>
<div class="section" title="Real-time video rendering with filters"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Real-time video rendering with filters</h1></div></div></div><p>The GLSL shader <a id="id181" class="indexterm"/>provides a simple way to perform highly parallelized processing. On top of the texture mapping shown previously, we will demonstrate how to implement a simple video filter that postprocesses the end results of the buffer frame using the fragment shader. To illustrate this technique, we implement the Sobel Filter along with a heat map rendered using the OpenGL pipeline. The heat map function that was previously implemented in <a class="link" href="ch03.html" title="Chapter 3. Interactive 3D Data Visualization">Chapter 3</a>, <span class="emphasis"><em>Interactive 3D Data Visualization</em></span>, will now be directly ported to GLSL with very minor changes.</p><p>The Sobel operator is a simple image processing technique frequently used in computer vision algorithms such as edge detection. This operator can be defined as a convolution operation with a 3 x 3 kernel, shown as follows:</p><div class="mediaobject"><img src="graphics/9727OS_04_14.jpg" alt="Real-time video rendering with filters"/></div><p><span class="inlinemediaobject"><img src="graphics/9727OS_04_16.jpg" alt="Real-time video rendering with filters"/></span> and <span class="inlinemediaobject"><img src="graphics/9727OS_04_17.jpg" alt="Real-time video rendering with filters"/></span> are results of the horizontal and vertical derivatives of an image, respectively, from the convolution operation of image <span class="emphasis"><em>I</em></span> at the pixel location<span class="emphasis"><em> (x, y)</em></span>.</p><p>We can also perform a sum of squares operation to approximate the gradient magnitude of the image:</p><div class="mediaobject"><img src="graphics/9727OS_04_18.jpg" alt="Real-time video rendering with filters"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec98"/>Getting ready</h2></div></div></div><p>This demo<a id="id182" class="indexterm"/> builds on top of the previous section, where an image was rendered. In this section, we will demonstrate the rendering of an image sequence or a video with the use of OpenCV library calls to handle videos. Inside <code class="literal">common.h</code>, we will add the following lines to include the OpenCV libraries:</p><div class="informalexample"><pre class="programlisting">#include &lt;opencv2/opencv.hpp&gt;
using namespace cv;</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec99"/>How to do it...</h2></div></div></div><p>Now, let's complete the implementation as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, modify <code class="literal">main.cpp</code> to enable video processing using OpenCV. Essentially, instead of loading an image, feed the individual frames of a video into the same pipeline:<div class="informalexample"><pre class="programlisting">char *filepath;
if(argc&lt;2){
  filepath = (char*)malloc(sizeof(char)*512);
  sprintf(filepath, "video.mov");
}
else{
  filepath = argv[1];
}
//Handling Video input with OpenCV
VideoCapture cap(filepath); // open the default camera
Mat frame;
if (!cap.isOpened()){ // check if we succeeded
  printf("Cannot open files\n");
  glfwTerminate();
  exit(EXIT_FAILURE);
  }else{
    cap &gt;&gt; frame; // get a new frame from camera
    printf("Got Video, %d x %d\n",frame.size().width, frame.size().height);
  }
  cap &gt;&gt; frame; // get a new frame from camera
  GLuint texture_id = initializeTexture(frame.data, frame.size().width, frame.size().height, GL_BGR);
  aspect_ratio = (float)frame.size().width/ (float)frame.size().height;</pre></div></li><li class="listitem">Then, <a id="id183" class="indexterm"/>add the <code class="literal">update</code> function in the <code class="literal">main</code> loop to update the texture in every frame:<div class="informalexample"><pre class="programlisting">  /* get the video feed, reset to beginning if it reaches the end of the video */
  if(!cap.grab()){
    printf("End of Video, Resetting\n");
    cap.release();
    cap.open(filepath); // open the default camera
  }
  cap &gt;&gt; frame; // get a new frame from camera
  //update the texture with the new frame
  updateTexture(frame.data, frame.size().width, frame.size().height, GL_BGR);</pre></div></li><li class="listitem">Next, modify the fragment shader and rename it <code class="literal">texture_sobel.frag</code> (from <code class="literal">texture.frag</code>). In the <code class="literal">main</code> function, we will outline the overall processing (process the texture buffers with the Sobel filter and heat map renderer):<div class="informalexample"><pre class="programlisting">  void main(){
    //compute the results of Sobel filter
    float graylevel = sobel_filter();
    color = heatMap(graylevel, 0.1, 3.0);
  }</pre></div></li><li class="listitem">Now, implement the Sobel filter algorithm that takes the neighboring pixels to compute the result:<div class="informalexample"><pre class="programlisting">  float sobel_filter()
  {
    float dx = 1.0 / float(1280);
    float dy = 1.0 / float(720);
    
    float s00 = pixel_operator(-dx, dy);
    float s10 = pixel_operator(-dx, 0);
    float s20 = pixel_operator(-dx,-dy);
    float s01 = pixel_operator(0.0,dy);
    float s21 = pixel_operator(0.0, -dy);
    float s02 = pixel_operator(dx, dy);
    float s12 = pixel_operator(dx, 0.0);
    float s22 = pixel_operator(dx, -dy);
    float sx = s00 + 2 * s10 + s20 - (s02 + 2 * s12 + s22);
    float sy = s00 + 2 * s01 + s02 - (s20 + 2 * s21 + s22);
    float dist = sx * sx + sy * sy;
    return dist;
  }</pre></div></li><li class="listitem">Define the helper function that computes the brightness value:<div class="informalexample"><pre class="programlisting">  float rgb2gray(vec3 color ) {
    return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
  }</pre></div></li><li class="listitem">Create a <a id="id184" class="indexterm"/>helper function for the per-pixel operator operations:<div class="informalexample"><pre class="programlisting">  float pixel_operator(float dx, float dy){
    return rgb2gray(texture( textureSampler, UV + vec2(dx,dy)).rgb);
  }</pre></div></li><li class="listitem">Lastly, define the heat map renderer prototype and implement the algorithm for better visualization of the range of values:<div class="informalexample"><pre class="programlisting">  vec4 heatMap(float v, float vmin, float vmax){
    float dv;
    float r, g, b;
    if (v &lt; vmin)
      v = vmin;
    if (v &gt; vmax)
      v = vmax;
    dv = vmax - vmin;
    if(v == 0){
      return vec4(0.0, 0.0, 0.0, 1.0);
  }
  if (v &lt; (vmin + 0.25f * dv)) {
    r = 0.0f;
    g = 4.0f * (v - vmin) / dv;
  } else if (v &lt; (vmin + 0.5f * dv)) {
    r = 0.0f;
    b = 1.0f + 4.0f * (vmin + 0.25f * dv - v) / dv;
  } else if (v &lt; (vmin + 0.75f * dv)) {
    r = 4.0f * (v - vmin - 0.5f * dv) / dv;
    b = 0.0f;
  } else {
    g = 1.0f + 4.0f * (vmin + 0.75f * dv - v) / dv;
    b = 0.0f;
  }
  return vec4(r, g, b, 1.0);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How it works...</h2></div></div></div><p>This demo <a id="id185" class="indexterm"/>effectively opens up the possibility of rendering any image sequence with real-time processing using the OpenGL pipeline at the fragment shading stage. The following screenshot is an example that illustrates the use of this powerful OpenGL framework to display one frame of a video (showing the authors of the book) without the Sobel filter enabled:</p><div class="mediaobject"><img src="graphics/9727OS_04_08.jpg" alt="How it works..."/></div><p>Now, with the Sobel filter and heat map rendering enabled, we see an interesting way to visualize the world using real-time OpenGL texture mapping and processing using custom shaders:</p><div class="mediaobject"><img src="graphics/9727OS_04_09.jpg" alt="How it works..."/></div><p>Further<a id="id186" class="indexterm"/> fine-tuning of the threshold parameters and converting the result into grayscale (in the <code class="literal">texture_sobel.frag</code> file) leads to an aesthetically interesting output:</p><div class="informalexample"><pre class="programlisting">void main(){
  //compute the results of Sobel filter
  float graylevel = sobel_filter();
  color = vec4(graylevel, graylevel, graylevel, 1.0);
}</pre></div><div class="mediaobject"><img src="graphics/9727OS_04_10.jpg" alt="How it works..."/></div><p>In addition, we can<a id="id187" class="indexterm"/> blend these results with the original video feed to create filtered effects in real time by modifying the main function in the shader program (<code class="literal">texture_sobel.frag</code>):</p><div class="informalexample"><pre class="programlisting">void main(){
  //compute the results of Sobel filter
  float graylevel = sobel_filter();
  //process the right side of the image
    if(UV.x &gt; 0.5)
      color = heatMap(graylevel, 0.0, 3.0) + texture(textureSampler, UV);
      else
      color = vec4(graylevel, graylevel, graylevel, 1.0) + texture (textureSampler, UV);
}</pre></div><div class="mediaobject"><img src="graphics/9727OS_04_11.jpg" alt="How it works..."/></div><p>To illustrate the use <a id="id188" class="indexterm"/>of the exact same program to visualize imaging datasets, here is an example that shows a volumetric dataset of a human finger imaged with <a id="id189" class="indexterm"/>
<span class="strong"><strong>Optical Coherence Tomography</strong></span> (<span class="strong"><strong>OCT</strong></span>), simply by changing the input video's filename:</p><div class="mediaobject"><img src="graphics/9727OS_04_12.jpg" alt="How it works..."/></div><p>This screenshot represents one of 256 cross-sectional images of the nail bed in this volumetric <a id="id190" class="indexterm"/>OCT dataset (which is exported in a movie file format).</p><p>Here is another example that shows a volumetric dataset of a scar specimen<a id="id191" class="indexterm"/> imaged with <span class="strong"><strong>Polarization-Sensitive Optical Coherence Tomography</strong></span> (<span class="strong"><strong>PS-OCT</strong></span>), which provides label-free, intrinsic contrast to the scar region:</p><div class="mediaobject"><img src="graphics/9727OS_04_13.jpg" alt="How it works..."/></div><p>In this case, the volumetric PS-OCT dataset was rendered with the ImageJ 3D Viewer and converted into a movie file. The colors denote the <a id="id192" class="indexterm"/>
<span class="strong"><strong>Degree of Polarization</strong></span> (<span class="strong"><strong>DOP</strong></span>), which is a measure of the randomness of the polarization states of light (a low DOP in yellow/green and a high DOP in blue), in the skin. The scar region is characterized by a high DOP compared to the normal skin.</p><p>As we have demonstrated here, this program can be easily adopted (by changing the input video source) to display many types of datasets, such as endoscopy videos or other volumetric imaging datasets. The utility of OpenGL becomes apparent in demanding applications that require real-time processing of very large datasets.</p></div></div></body></html>