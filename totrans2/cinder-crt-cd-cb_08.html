<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Using 3D Graphics"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Using 3D Graphics</h1></div></div></div><p>In this chapter, we will learn how to work and draw with <a id="id468" class="indexterm"/>3D graphics. The recipes in this chapter will cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drawing 3D geometric primitives</li><li class="listitem" style="list-style-type: disc">Rotating, scaling, and translating</li><li class="listitem" style="list-style-type: disc">Drawing to an offscreen canvas</li><li class="listitem" style="list-style-type: disc">Drawing in 3D with the mouse</li><li class="listitem" style="list-style-type: disc">Adding lights</li><li class="listitem" style="list-style-type: disc">Picking in 3D</li><li class="listitem" style="list-style-type: disc">Creating a height map from an image</li><li class="listitem" style="list-style-type: disc">Creating a terrain with Perlin noise</li><li class="listitem" style="list-style-type: disc">Saving mesh data</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Introduction</h1></div></div></div><p>In this chapter, we will learn the basics of creating graphics in 3D. We will use OpenGL and some useful wrappers that Cinder includes on some advanced OpenGL features.</p></div></div>
<div class="section" title="Drawing 3D geometric primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Drawing 3D geometric primitives</h1></div></div></div><p>In this recipe, we will learn how<a id="id469" class="indexterm"/> to draw the following<a id="id470" class="indexterm"/> 3D geometric shapes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cube</li><li class="listitem" style="list-style-type: disc">Sphere</li><li class="listitem" style="list-style-type: disc">Line</li><li class="listitem" style="list-style-type: disc">Torus</li><li class="listitem" style="list-style-type: disc">Cylinder</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec207"/>Getting ready</h2></div></div></div><p>Include the necessary header<a id="id471" class="indexterm"/> to draw in OpenGL using Cinder commands and statements. Add the following code to the top of your source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Camera.h"

using namespace ci;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec208"/>How to do it…</h2></div></div></div><p>We will create several geometric primitives using Cinder's methods for drawing in 3D.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare the member variables with information of our primitives:<div class="informalexample"><pre class="programlisting">Vec3f mCubePos, mCubeSize;
Vec3f mSphereCenter;
float mSphereRadius; 
Vec3f mLineBegin, mLineEnd; 
Vec3f mTorusPos;
float mTorusOuterRadius, mTorusInnerRadius; 
Vec3f mCylinderPos;
float mCylinderBaseRadius, mCylinderTopRadius, mCylinderHeight;</pre></div></li><li class="listitem">Initialize the member variables with the position and sizes of the geometry. Add the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mCubePos = Vec3f( 100.0f, 300.0f, 100.0f );
mCubeSize = Vec3f( 100.0f, 100.0f, 100.0f );

mSphereCenter = Vec3f( 500, 250, 0.0f );
mSphereRadius = 100.0f;

mLineBegin = Vec3f( 200, 0, 200 );
mLineEnd = Vec3f( 500, 500, -200 );

mTorusPos = Vec3f( 300.0f, 100.0f, 0.0f );
mTorusOuterRadius = 100.0f;
mTorusInnerRadius = 20.0f;

mCylinderPos = Vec3f( 500.0f, 0.0f, -200.0f );
mCylinderBaseRadius = 50.0f;
mCylinderTopRadius = 80.0f;
mCylinderHeight = 100.0f;</pre></div></li><li class="listitem">Before we draw the shapes, let's also create a camera to rotate around our shapes to give us a better sense of perspective. Declare a <code class="literal">ci::CameraPersp</code> object:<div class="informalexample"><pre class="programlisting">CameraPerspmCamera;</pre></div></li><li class="listitem">Initialize it in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mCamera = CameraPersp( getWindowWidth(), getWindowHeight(), 60.0f );</pre></div></li><li class="listitem">In the <code class="literal">update</code> method,<a id="id472" class="indexterm"/> we will make the camera rotate around our scene. Add the following code in the <code class="literal">update</code> method:<div class="informalexample"><pre class="programlisting">Vec2f windowCenter = getWindowCenter();
floatcameraAngle = getElapsedSeconds();
floatcameraDist = 450.0f;
float x = sinf( cameraAngle ) * cameraDist + windowCenter.x;
float z = cosf( cameraAngle ) * cameraDist;
mCamera.setEyePoint( Vec3f( x, windowCenter.y, z ) );
mCamera.lookAt( Vec3f( windowCenter.x, windowCenter.y, 0.0f ) );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will clear the background with black and use <code class="literal">mCamera</code> to define the window's matrices. We will also enable OpenGL to read and write to the depth buffers. Add the following code in the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">  gl::clear( Color::black() ); 
  gl::setMatrices( mCamera );
  gl::enableDepthRead();
  gl::enableDepthWrite();</pre></div></li><li class="listitem">Cinder allows you to draw filled and stroked cubes, so let's draw a cube with a white fill and black stroke:<div class="informalexample"><pre class="programlisting">gl::color( Color::white() );
gl::drawCube( mCubePos, mCubeSize );
gl::color( Color::black() );
gl::drawStrokedCube( mCubePos, mCubeSize );</pre></div></li><li class="listitem">Let's define the drawing color again as white, and draw a sphere with <code class="literal">mSphereCenter</code> and <code class="literal">mSphereRadius</code> as the sphere's position and radius, and the number of segments as <code class="literal">30</code>.<div class="informalexample"><pre class="programlisting">gl::color( Color::white() );
gl::drawSphere( mSphereCenter, mSphereRadius, 30 );</pre></div></li><li class="listitem">Draw a line that begins at <code class="literal">mLineBegin</code> and ends at <code class="literal">mLineEnd</code>:<div class="informalexample"><pre class="programlisting">gl::drawLine( mLineBegin, mLineEnd );</pre></div></li><li class="listitem">Cinder draws a <a id="id473" class="indexterm"/><code class="literal">Torus</code> at the coordinates of the origin <code class="literal">[0,0]</code>. So, we will have to translate it to the desired position at <code class="literal">mTorusPos</code>. We will be using <code class="literal">mTorusOuterRadius</code> and <code class="literal">mTorusInnerRadius</code> to define the shape's inner and outer sizes:<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
gl::translate( mTorusPos );
gl::drawTorus( mTorusOutterRadius, mTorusInnerRadius );
gl::popMatrices();</pre></div></li><li class="listitem">Finally, Cinder will draw a cylinder at the origin <code class="literal">[0,0]</code>, so we will have to translate it to the position defined in <code class="literal">mCylinderPosition</code>. We will also be using <code class="literal">mCylinderBaseRadius</code> and <code class="literal">mCylinderTopRadius</code>, to set the cylinder's bottom and top sizes and <code class="literal">mCylinderHeight</code>, to set its height:<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
gl::translate( mCylinderPos );
gl::drawCylinder( mCylinderBaseRadius, mCylinderTopRadius, mCylinderHeight );
gl::popMatrices();</pre></div><div class="mediaobject"><img src="graphics/8703OS_8_1.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec209"/>How it works…</h2></div></div></div><p>Cinder's drawing<a id="id474" class="indexterm"/> methods use OpenGL calls internally to provide fast and easy drawing routines.</p><p>The method <code class="literal">ci::gl::color</code> sets the drawing color so that all shapes will be drawn with that color until another color is set by calling <code class="literal">ci::gl::color</code> again.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec210"/>See also</h2></div></div></div><p>To learn more about OpenGL transformations such as translation, scale, and rotation, please read the recipe <span class="emphasis"><em>Rotating, scaling, and translating</em></span>.</p></div></div>
<div class="section" title="Rotating, scaling, and translating"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Rotating, scaling, and translating</h1></div></div></div><p>In this recipe, we <a id="id475" class="indexterm"/>will learn how<a id="id476" class="indexterm"/> to transform our graphics using OpenGL transformations.<a id="id477" class="indexterm"/></p><p>We will draw a unit cube at <code class="literal">[0,0,0]</code>
<a id="id478" class="indexterm"/> coordinates and then we will translate it to the center of the window, apply rotation, and scale it to a more visible size.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec211"/>Getting ready</h2></div></div></div><p>Include the necessary files to draw with OpenGL and add the helpful <code class="literal">using</code> statements. Add the following code to the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec212"/>How to do it…</h2></div></div></div><p>We will apply rotation, translation, and scaling to alter the way our cube is rendered. We will use Cinder's wrappers for OpenGL.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's declare variables to store our values for the translation, rotation, and scale transformations:<div class="informalexample"><pre class="programlisting">    Vec3f mTranslation;
    Vec3f mScale;
    Vec3f mRotation;</pre></div></li><li class="listitem">To define the translation amount, let's translate half the window's width on the x axis and half the window's height on the y axis. This will bring anything we draw at <code class="literal">[0,0,0]</code> to the center of the window. Add the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mTranslation.x = getWindowWidth() / 2;
mTranslation.y = getWindowHeight() / 2;
mTranslation.z = 0.0f;</pre></div></li><li class="listitem">Let's set the scale factor to be <code class="literal">100</code> on the x axis, <code class="literal">200</code> on the y axis, and <code class="literal">100</code> on the z axis. Anything we draw will be 100 times bigger on the x and z axes and 200 times bigger on the y axis. Add the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mScale.x = 100.0f;
mScale.y = 200.0f;
mScale.z = 100.0f;</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, we will animate the rotation values by incrementing the rotation on the x and y axes.<div class="informalexample"><pre class="programlisting">mRotation.x += 1.0f;
mRotation.y += 1.0f;</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, let's begin <a id="id479" class="indexterm"/>by clearing the background with black, setting the windows matrices to allow for drawing in 3D, and enabling OpenGL to read and write the depth buffer:<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Let's add a new matrix to the stack and translate, scale, and rotate using the previously defined variables:<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
gl::translate( mTranslation );
gl::scale( mScale );
gl::rotate( mRotation );</pre></div></li><li class="listitem">Draw a unit quad at the origin <code class="literal">[0,0,0]</code> with a white fill and black stroke:<div class="informalexample"><pre class="programlisting">gl::color( Color::white() );
gl::drawCube( Vec3f(), Vec3f( 1.0f, 1.0f, 1.0f ) );
gl::color( Color::black() );
gl::drawStrokedCube( Vec3f(), Vec3f( 1.0f, 1.0f, 1.0f ) );</pre></div></li><li class="listitem">Finally, remove the previously added matrix:<div class="informalexample"><pre class="programlisting">gl::popMatrices();</pre></div><div class="mediaobject"><img src="graphics/8703OS_8_2.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec213"/>How it works…</h2></div></div></div><p>The calls to <code class="literal">ci::gl::enableDepthRead</code> and <code class="literal">ci::gl::enableDepthWrite</code> respectively, enable reading <a id="id480" class="indexterm"/>and writing to the depth buffer. The depth buffer is where the depth information is stored.</p><p>When reading and writing to the depth buffer is enabled, OpenGL will sort objects so that closer objects are drawn in front of farther objects. When reading and writing to the depth buffer, the disabled objects will be drawn in the order they where created.</p><p>The methods <code class="literal">ci::gl::translate</code>, <code class="literal">ci::gl::rotate</code>, and <code class="literal">ci::gl::scale</code> are wrappers of OpenGL commands for translating, rotating, and scaling, which allow you to pass Cinder types as parameters.</p><p>Transformations in OpenGL are applied by multiplying vertex coordinates with transformation matrices. When we call the method <code class="literal">ci::gl::pushMatrices</code>, we add a copy of the current transformation matrix to the matrix stack. Calls to <code class="literal">ci::gl::translate</code>, <code class="literal">ci::gl::rotate</code>, or <code class="literal">ci::gl::scale</code> will apply the correspondent transformations to the last matrix in the stack, which will be applied to whatever geometry is created after calling the transformation methods. A call to <code class="literal">ci::gl::popMatrix</code> <a id="id481" class="indexterm"/>will remove the last transformation matrix in the stack so that transformations added to the last matrix will no longer affect our geometry.</p></div></div>
<div class="section" title="Drawing to an offscreen canvas"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Drawing to an offscreen canvas</h1></div></div></div><p>In this recipe, we will learn<a id="id482" class="indexterm"/> how to draw in an offscreen canvas using the OpenGL <span class="strong"><strong>Frame Buffer Object</strong></span> (<span class="strong"><strong>FBO</strong></span>).<a id="id483" class="indexterm"/></p><p>We will draw in an FBO<a id="id484" class="indexterm"/> and draw it onscreen as well as texture a rotating cube.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec214"/>Getting ready </h2></div></div></div><p>Include the necessary files to work with OpenGL and the FBOs as well as the useful <code class="literal">include</code> directives.</p><p>Add the following code to the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/gl/Fbo.h"

using namespace ci;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec215"/>How to do it…</h2></div></div></div><p>We will use a <code class="literal">ci::gl::Fbo</code> object, a wrapper to an OpenGL FBO, to draw in an offscreen destination.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a <code class="literal">ci::gl::Fbo</code> object as well as a <code class="literal">ci::Vec3f</code> object to define the cube's rotation:<div class="informalexample"><pre class="programlisting">gl::FbomFbo;
Vec3f mCubeRotation;</pre></div></li><li class="listitem">Initialize <code class="literal">mFbo</code> with a size of 256 x 256 pixels by adding the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mFbo = gl::Fbo( 256, 256 );</pre></div></li><li class="listitem">Animate <code class="literal">mCubeRotation</code> in the <code class="literal">update</code> method:<div class="informalexample"><pre class="programlisting">mCubeRotation.x += 1.0f;
mCubeRotation.y += 1.0f;</pre></div></li><li class="listitem">Declare a method where we will draw to the FBO:<div class="informalexample"><pre class="programlisting">void drawToFbo();</pre></div></li><li class="listitem">In the <a id="id485" class="indexterm"/>implementation of <code class="literal">drawToFbo</code>, we will begin by creating a <code class="literal">ci::gl::SaveFramebufferBinding</code> object and then bind <code class="literal">mFbo</code>.<div class="informalexample"><pre class="programlisting">gl::SaveFramebufferBinding fboBindingSave;
mFbo.bindFramebuffer();</pre></div></li><li class="listitem">Now we will clear the background with a dark gray color and set the matrices using the FBO's width and height.<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0.3f, 0.3f, 0.3f ) );
gl::setMatricesWindowPersp( mFbo.getWidth(), mFbo.getHeight() );</pre></div></li><li class="listitem">Now we will draw a rotating color cube at the center of the FBO with size <code class="literal">100</code> and using <code class="literal">mCubeRotation</code> to rotate the cube.<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
Vec3f cubeTranslate( mFbo.getWidth() / 2, mFbo.getHeight() / 2, 0.0f );
gl::translate( cubeTranslate );
gl::rotate( mCubeRotation );
gl::drawColorCube( Vec3f(), Vec3f( 100, 100, 100 ) );
gl::popMatrices();</pre></div></li><li class="listitem">Let's move to the implementation of the <code class="literal">draw</code> method. Start by calling the method <code class="literal">drawToFbo</code>, clearing the background with black, setting the window's matrices, and enable reading and writing to the depth buffer. Add the following code in the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">drawToFbo();
gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div><p>Lets draw our Fbo at the top left corner of the window using mFbo texture:</p><div class="informalexample"><pre class="programlisting">gl::draw( mFbo.getTexture(), Rectf( 0.0f, 0.0f, 100.0f, 100.0f ) );</pre></div></li><li class="listitem">Enable and bind the texture of <code class="literal">mFbo</code>:<div class="informalexample"><pre class="programlisting">mFbo.getTexture().enableAndBind();</pre></div></li><li class="listitem">Draw a rotating<a id="id486" class="indexterm"/> cube at the center of the window using <code class="literal">mCubeRotation</code> to define its rotation:<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
Vec3f center( getWindowWidth() / 2, getWindowHeight() / 2, 0.0f );
gl::translate( center );
gl::rotate( mCubeRotation );
gl::drawCube( Vec3f(), Vec3f( 200.0f, 200.0f, 200.0f ) );
gl::popMatrices();</pre></div></li><li class="listitem">To finalize, unbind the texture of <code class="literal">mFbo</code>:<div class="informalexample"><pre class="programlisting">mFbo.unbindTexture();</pre></div><div class="mediaobject"><img src="graphics/8703OS_8_3.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec216"/>How it works…</h2></div></div></div><p>The class <code class="literal">ci::gl::Fbo</code> wraps an OpenGL FBO<span class="strong"><strong>.</strong></span></p><p>Frame Buffer Objects <a id="id487" class="indexterm"/>are OpenGL objects that contain a collection of buffers that can be used as rendering destinations. The OpenGL context provides a default frame buffer where rendering occurs. Frame Buffer Objects allow rendering to alternative, offscreen locations.</p><p>The FBO has a color texture where the graphics are stored, and it can be bound and drawn like a regular OpenGL texture.</p><p>On step 5, we created a <code class="literal">ci::gl::SaveFramebufferBinding</code> object, which is a helper class that restores the previous FBO state. When using OpenGL ES, this object will restore and bind the previously bound FBO (usually the <span class="emphasis"><em>screen</em></span> FBO) when it is destroyed.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec217"/>See also</h2></div></div></div><p>See the recipe <span class="emphasis"><em>Rotating, scaling, and translating</em></span> to learn more about OpenGL transformations.</p></div></div>
<div class="section" title="Drawing in 3D with the mouse"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Drawing in 3D with the mouse</h1></div></div></div><p>In this recipe, <a id="id488" class="indexterm"/>we will draw with the mouse on a 3D space. We will draw lines when dragging the mouse<a id="id489" class="indexterm"/> or rotate the scene in 3D when dragging and<a id="id490" class="indexterm"/> pressing the <span class="emphasis"><em>Shift</em></span> key simultaneously.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec218"/>Getting ready</h2></div></div></div><p>Include the necessary files to draw using OpenGL, as well as the files needed to use Cinder's perspective, Maya camera, and poly lines.</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Camera.h"
#include "cinder/MayaCamUI.h"
#include "cinder/PolyLine.h"</pre></div><p>Also, add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec219"/>How to do it…</h2></div></div></div><p>We will use <a id="id491" class="indexterm"/>the <code class="literal">ci::CameraPersp</code> and <code class="literal">ci::Ray</code> classes to convert the mouse coordinates to our rotated 3D scene.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a <code class="literal">ci::MayaCamUI</code> object and a <code class="literal">std::vector</code> object of <code class="literal">ci::PolyLine&lt;ci::Vec3f&gt;</code> to store the drawn lines:<div class="informalexample"><pre class="programlisting">MayaCamUI mCamera;
vector&lt;PolyLine&lt;Vec3f&gt; &gt; mLines;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method,<a id="id492" class="indexterm"/> we will create <code class="literal">ci::CameraPersp</code> and set it up so that the point of interest is the center of the window. We will also set the camera as the current camera of <code class="literal">mCamera:</code><div class="informalexample"><pre class="programlisting">CameraPersp cameraPersp( getWindowWidth(),getWindowHeight(), 60.0f );
Vec3f center( getWindowWidth() / 2, getWindowHeight() / 2,0.0f );
cameraPersp.setCenterOfInterestPoint( center );
mCamera.setCurrentCam( cameraPersp );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, let's clear the background with black and use our camera to set the window's matrices.<div class="informalexample"><pre class="programlisting">  gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatrices( mCamera.getCamera() );</pre></div></li><li class="listitem">Now let's iterate <code class="literal">mLines</code> and draw each <code class="literal">ci::PolyLine</code>. Add the following code to the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">for( vector&lt;PolyLine&lt;Vec3f&gt; &gt; ::iterator it = mLines.begin(); it != mLines.end(); ++it ){
gl::draw( *it );
    }</pre></div></li><li class="listitem">With our scene set up and the lines being drawn, we need to create the 3D perspective! Let's start by declaring a method to convert coordinates from the screen position to world position. Add the following method declaration:<div class="informalexample"><pre class="programlisting">    Vec3f screenToWorld( const Vec2f&amp;point ) const;</pre></div></li><li class="listitem">In the <code class="literal">screenToWorld</code> implementation, we need to generate a ray from <code class="literal">point</code> using the cameras perspective. Add the following code in <code class="literal">screenToWorld</code>:<div class="informalexample"><pre class="programlisting">float u = point.x / (float)getWindowWidth();
float v = point.y / (float)getWindowHeight();

const CameraPersp&amp; cameraPersp = mCamera.getCamera();

Ray ray = cameraPersp.generateRay( u, 1.0f - v, cameraPersp.getAspectRatio() );</pre></div></li><li class="listitem">Now we need to <a id="id493" class="indexterm"/>calculate where the ray will intersect with a perpendicular plane at the camera's center of interest and then return the intersection point. Add the following code in the <code class="literal">screenToWorld</code> implementation:<div class="informalexample"><pre class="programlisting">float result = 0.0f;
Vec3f planePos = cameraPersp.getCenterOfInterestPoint();
Vec3f normal = cameraPersp.getViewDirection();

ray.calcPlaneIntersection( planePos, normal, &amp;result );

Vec3f intersection= ray.calcPosition( result );
return intersection;</pre></div></li><li class="listitem">Let's use the <a id="id494" class="indexterm"/>previously defined method to draw with the mouse. Declare the <code class="literal">mouseDown</code> and <code class="literal">mouseDrag</code> event handlers:<div class="informalexample"><pre class="programlisting">void mouseDown( MouseEvent event );
void mouseDrag( MouseEvent event );</pre></div></li><li class="listitem">In the implementation of <code class="literal">mouseDown</code>, we will check if the <span class="emphasis"><em>Shift</em></span> key is being pressed. If it is, we will call the <code class="literal">mouseDown</code> method of <code class="literal">mCamera</code>, otherwise, we will add <code class="literal">ci::PolyLine&lt;ci::Vec3f&gt;</code> to <code class="literal">mLines</code>, calculate the world position of the mouse cursor using <code class="literal">screenToWorld</code>, and add it:<div class="informalexample"><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  if( event.isShiftDown() ){
  mCamera.mouseDown( event.getPos() );
    }
else {    
        mLines.push_back( PolyLine&lt;Vec3f&gt;() );
        Vec3f point = screenToWorld( event.getPos() );
        mLines.back().push_back( point );
    }
}</pre></div></li><li class="listitem">In the implementation of <code class="literal">mouseDrag</code>, we will check if the <span class="emphasis"><em>Shift</em></span> key<a id="id495" class="indexterm"/> is being pressed. If it is, we will call the <code class="literal">mouseDrag</code> method to <code class="literal">mCamera</code>, otherwise, we will calculate the world position of the mouse cursor and add it to last line in <code class="literal">mLines</code>.<div class="informalexample"><pre class="programlisting">void Pick3dApp::mouseDrag( MouseEvent event ){
    if( event.isShiftDown() ){
    mCamera.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );
    } else {
        Vec3f point = screenToWorld( event.getPos() );
        mLines.back().push_back( point );
    }
}</pre></div></li><li class="listitem">Build and run the application. Press and drag the mouse to draw a line. Press the <span class="emphasis"><em>Shift</em></span> key and press and drag the mouse to rotate the scene.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec220"/>How it works…</h2></div></div></div><p>We use <code class="literal">ci::MayaCamUI</code> to easily rotate our scene.</p><p>The <code class="literal">ci::Ray</code> class is a <a id="id496" class="indexterm"/>representation of a ray, containing an <a id="id497" class="indexterm"/>origin, direction, and an infinite length. It provides useful methods to calculate intersections between rays and triangles or planes.</p><p>To calculate the world position of the mouse cursor we calculated a ray going from the camera's eye position in the camera's view direction.</p><p>We then calculated the intersection of the ray with the plane at the center of the scene, perpendicular to the camera.</p><p>The calculated position is then added to a <code class="literal">ci::PolyLine&lt;ci::Vec3f&gt;</code> object to draw the lines.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec221"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more on how to use <code class="literal">ci::MayaCamUI</code>, please refer to the recipe <span class="emphasis"><em>Using MayaCamUI</em></span> from <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span>.</li><li class="listitem" style="list-style-type: disc">To learn how to draw in 2D, please read the recipe <span class="emphasis"><em>Drawing arbitrary shapes with the mouse</em></span> from <a class="link" href="ch07.html" title="Chapter 7. Using 2D Graphics">Chapter 7</a>, <span class="emphasis"><em>Using 2D Graphics</em></span>.</li></ul></div></div></div>
<div class="section" title="Adding lights"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Adding lights</h1></div></div></div><p>In this chapter, <a id="id498" class="indexterm"/>we will <a id="id499" class="indexterm"/>learn how to illuminate a 3D scene using OpenGL lights.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec222"/>Getting ready</h2></div></div></div><p>Include the necessary files<a id="id500" class="indexterm"/> to use OpenGL lights, materials, and draw. Add the following code to the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/gl/Light.h"
#include "cinder/gl/Material.h"</pre></div><p>Also add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec223"/>How to do it…</h2></div></div></div><p>We will use the default OpenGL light rendering methods to illuminate our scene. We will use the <code class="literal">ci::gl::Material</code> and <code class="literal">ci::gl::Light</code> classes, which are wrappers around the OpenGL functionality.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare <code class="literal">ci::gl::Material</code> to define the material properties of the objects being drawn and <code class="literal">ci::Vec3f</code> to define the lights position.<div class="informalexample"><pre class="programlisting">gl::Material mMaterial;
Vec3f mLightPos;</pre></div></li><li class="listitem">Let's set the materials <code class="literal">Ambient</code>, <code class="literal">Diffuse</code>, <code class="literal">Specular</code>, <code class="literal">Emission</code>, and <code class="literal">Shininess</code> properties by adding the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">mMaterial.setAmbient( Color::black() );
mMaterial.setDiffuse( Color( 1.0f, 0.0f, 0.0f ) );
mMaterial.setSpecular( Color::white() );
mMaterial.setEmission( Color::black() );
mMaterial.setShininess( 128.0f );</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, we will use the mouse to define the light position. Add the following code in the <code class="literal">update</code> method:<div class="informalexample"><pre class="programlisting">mLightPos.x = getMousePos().x;
mLightPos.y = getMousePos().y;
mLightPos.z = 200.0f;</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will begin by clearing the background, setting the window's matrices, and enabling reading and writing to the depth buffer.<div class="informalexample"><pre class="programlisting">gl::clear( Color::black() );
gl::setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );
gl::enableDepthWrite();
gl::enableDepthRead();</pre></div></li><li class="listitem">Let's create an OpenGL light using a <code class="literal">ci::gl::Light</code> object. We will define it as a <code class="literal">POINT</code> light and set its ID to <code class="literal">0</code>. We will also set its position to <code class="literal">mLightPos</code> and define its attenuation.<div class="informalexample"><pre class="programlisting">gl::Light light( gl::Light::POINT, 0 );
light.setPosition( mLightPos );
light.setAttenuation( 1.0f, 0.0f, 0.0f );</pre></div></li><li class="listitem">Let's enable OpenGL lighting, the previously created light, and apply the material.<div class="informalexample"><pre class="programlisting">glEnable( GL_LIGHTING );
light.enable();
mMaterial.apply();</pre></div></li><li class="listitem">Let's draw<a id="id501" class="indexterm"/> a rotating <code class="literal">Torus</code> at the center of the window and use the elapsed seconds to rotate it. Add the following code to the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">gl::pushMatrices();
gl::translate( getWindowCenter() );
float seconds = (float)getElapsedSeconds() * 100.0f;
glRotatef( seconds, 1.0f, 0.0f, 0.0f );
glRotatef( seconds, 0.0f, 1.0f, 0.0f );
gl::drawTorus( 100.0f, 40.0f, 30, 30 );
gl::popMatrices();</pre></div></li><li class="listitem">Finally, disable the light:<div class="informalexample"><pre class="programlisting">light.disable();</pre></div></li><li class="listitem">Build and run the application; you will see a red rotating torus. Move the mouse to change the lights position.<div class="mediaobject"><img src="graphics/8703OS_8_4.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec224"/>How it works…</h2></div></div></div><p>We are using the <code class="literal">ci::gl::Material</code> and <code class="literal">ci::gl::Light</code> objects, which are helper classes to define the properties of lights and <a id="id502" class="indexterm"/>materials.</p><p>The material properties defined in the <code class="literal">setup</code> method, work in the following ways:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Material Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Ambient<a id="id503" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>How an object can reflect light that comes in all directions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Diffuse<a id="id504" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>How an object reflects light that comes from a specific direction or position.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Specular<a id="id505" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>The light that an object will reflect as a result of diffuse lighting.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Emission<a id="id506" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Light emitted by the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Shininess<a id="id507" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>The angle that the object will reflect specular light. Has to be a value between 1 and 128.</p>
</td></tr></tbody></table></div><p>The material ambient, diffuse, and specular colors will multiply with the ambient, diffuse, and specular colors coming from the light source, which are all white by default.</p><p>It is possible to define <a id="id508" class="indexterm"/>three different types of lights. In the previous example, we defined our light source to be of type <code class="literal">ci::gl::Light::POINT</code>.</p><p>Here are the available types of light and their properties:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Light Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Properties</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::gl::Light::POINT</code>
<a id="id509" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Point light is the light coming from a specific position in space and illuminating in all directions.<a id="id510" class="indexterm"/></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::gl::Light::DIRECTION</code></p>
</td><td style="text-align: left" valign="top">
<p>Directional light simulates light coming from a position so far away that all light rays are parallel and arrive in the same direction.<a id="id511" class="indexterm"/></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::gl::Light::SPOTLIGHT</code></p>
</td><td style="text-align: left" valign="top">
<p>Spotlight is the light coming from a specific position in space and a specific direction.<a id="id512" class="indexterm"/></p>
</td></tr></tbody></table></div><p>We also defined the attenuation values. Lights in OpenGL allow for defining the values for the constant attenuation, linear attenuation, and quadratic attenuation. These define how the light becomes dimmer as the distance from the light source increases.</p><p>To illuminate geometry, it is necessary to calculate the normal for each vertex. All shapes created using Cinder's commands have their normal calculated for us, so we don't have to worry about that.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec225"/>There's more…</h2></div></div></div><p>It is also possible to define the ambient, diffuse, and specular colors coming from the light source. The values defined in these colors will multiply with the correspondent colors of the material.</p><p>Here are the <code class="literal">ci::gl::Light</code> methods that allow you to define the light colors:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Light</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">setAmbient( const Color&amp; color )</code>
<a id="id513" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Color of the ambient light.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">setDiffuse( const Color&amp; color )</code>
<a id="id514" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Color of the diffuse light.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">setSpecular( const Color&amp; color )</code>
<a id="id515" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Color of the specular light.</p>
</td></tr></tbody></table></div><p>It is possible to create more than one light source. The amount of lights is dependent on the implementation of the <a id="id516" class="indexterm"/>graphics card, but it is always at least <code class="literal">8</code>.</p><p>To create more light sources, simply create more <code class="literal">ci::gl::Light</code> objects and make sure each gets a unique ID.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec226"/>See also</h2></div></div></div><p>Please read the recipe <span class="emphasis"><em>Calculating vertex normals</em></span> to learn how to calculate the vertex normals for user created geometry.</p></div></div>
<div class="section" title="Picking in 3D"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Picking in 3D</h1></div></div></div><p>In this recipe, we will <a id="id517" class="indexterm"/>calculate the <a id="id518" class="indexterm"/>intersection of the mouse cursor with a 3D model.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec227"/>Getting ready </h2></div></div></div><p>Include the necessary files to draw using OpenGL, use textures and load images, load 3D models, define OpenGL lights and materials, and use Cinder's Maya camera.</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/gl/Texture.h"
#include "cinder/gl/Light.h"
#include "cinder/gl/Material.h"
#include "cinder/TriMesh.h"
#include "cinder/ImageIo.h"
#include "cinder/MayaCamUI.h"</pre></div><p>Also, add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div><p>We will use a 3D model, so place a file and its texture in the <code class="literal">assets</code> folder. For this example, we will be using a mesh file named <code class="literal">ducky.msh</code> and a texture named <code class="literal">ducky.png</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec228"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will use the <code class="literal">ci::CameraPersp</code> and <code class="literal">ci::Ray</code> classes to convert the mouse coordinates to our rotated 3D <a id="id519" class="indexterm"/>scene and calculate the intersection with a 3D model.</li><li class="listitem">Declare the members to define the 3D model and its intersection with the mouse, as well as a <code class="literal">ci::MayaCamUI</code> object for easy navigation, and a <code class="literal">ci::gl::Material</code> for lighting:<div class="informalexample"><pre class="programlisting">TriMesh mMesh;
gl::Texture mTexture;
MayaCamUI mCam;
bool mIntersects;
Vec3f mNormal, mHitPos;
AxisAlignedBox3f mMeshBounds;
gl::Material mMaterial;</pre></div></li><li class="listitem">Declare a method where we will calculate the intersection between a <code class="literal">ci::Ray</code> class and the triangles that make up <code class="literal">mMesh</code>.<div class="informalexample"><pre class="programlisting">void calcIntersectionWithMeshTriangles( const ci::Ray&amp; ray );</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, lets load the model and texture and calculate its bounding box:<div class="informalexample"><pre class="programlisting">mMesh.read( loadAsset( "ducky.msh" ) );
mTexture = loadImage( loadAsset( "ducky.png" ) );
mMeshBounds = mMesh.calcBoundingBox();</pre></div></li><li class="listitem">Let's define the camera and make it look as if it's at the center of the model. Add the following code in the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">CameraPersp cam;
Vec3f modelCenter = mMeshBounds.getCenter();
cam.setEyePoint( modelCenter + Vec3f( 0.0f, 0.0f, 20.0f ) );
cam.setCenterOfInterestPoint( modelCenter );
mCam.setCurrentCam( cam );</pre></div></li><li class="listitem">Finally, set up the material for the model's lighting.<div class="informalexample"><pre class="programlisting">mMaterial.setAmbient( Color::black() );
mMaterial.setDiffuse( Color::white() );
mMaterial.setEmission( Color::black() );</pre></div></li><li class="listitem">Declare the handlers for the <code class="literal">mouseDown</code> and <code class="literal">mouseDrag</code> events.<div class="informalexample"><pre class="programlisting">void mouseDown( MouseEvent event );
void mouseDrag( MouseEvent event );</pre></div></li><li class="listitem">Implement these<a id="id520" class="indexterm"/> methods by calling the necessary methods of <code class="literal">mCam</code>:<div class="informalexample"><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mCam.mouseDown( event.getPos() );
}

void MyApp::mouseDrag( MouseEvent event ){
  mCam.mouseDrag( event.getPos(), event.isLeftDown(), event.isMiddleDown(), event.isRightDown() );
}</pre></div></li><li class="listitem">Let's implement the <code class="literal">update</code> method and calculate the intersection between the mouse cursor and our model. Let's begin by getting the mouse position and then calculate <code class="literal">ci::Ray</code> emitting from our camera:<div class="informalexample"><pre class="programlisting">Vec2f mousePos = getMousePos();
float u = mousePos.x / (float)getWindowWidth();
float v = mousePos.y / (float)getWindowHeight();
CameraPersp cameraPersp = mCam.getCamera();
Ray ray = cameraPersp.generateRay( u, 1.0f - v, cameraPersp.getAspectRatio() );</pre></div></li><li class="listitem">Let's perform a fast test and check if the ray intersects with the model's bounding box. If the result is <code class="literal">true</code>, we will call the <code class="literal">calcIntersectionWithMeshTriangles</code> method.<a id="id521" class="indexterm"/><div class="informalexample"><pre class="programlisting">    if( mMeshBounds.intersects( ray ) == false ){
  mIntersects = false;
    } else {
  calcIntersectionWithMeshTriangles( ray );
    }</pre></div></li><li class="listitem">Let's implement the <code class="literal">calcIntersectionWithMeshTriangles</code> method. We will iterate over all the triangles of our model and calculate the nearest intersection and store its index.<div class="informalexample"><pre class="programlisting">float distance = 0.0f;
float resultDistance = 999999999.9f;
int resultIndex = -1;
int numTriangles = mMesh.getNumTriangles();
for( int i=0; i&lt;numTriangles; i++ ){
        Vec3f v1, v2, v3;
        mMesh.getTriangleVertices( i, &amp;v1, &amp;v2, &amp;v3 );
        if( ray.calcTriangleIntersection( v1, v2, v3, &amp;distance ) ){
        if( distance &lt;resultDistance ){
        resultDistance = distance;
        resultIndex = i;
            }
        }
    }</pre></div></li><li class="listitem">Let's check if there was any intersection and calculate its position and normal. If no intersection was<a id="id522" class="indexterm"/> found, we will simply set <code class="literal">mIntersects</code> to <code class="literal">false</code>.<div class="informalexample"><pre class="programlisting">if( resultIndex&gt; -1 ){
        mHitPos = ray.calcPosition( resultDistance );
        mIntersects = true;
        Vec3f v1, v2, v3;
        mMesh.getTriangleVertices( resultIndex, &amp;v1, &amp;v2, &amp;v3 );
        mNormal = ( v2 - v1 ).cross( v3 - v1 );
        mNormal.normalize();
    } else {
      mIntersects = false;
    }</pre></div></li><li class="listitem">With the intersection calculated, let's draw the model, intersection point, and normal. Start by clearing the background with black, setting the window's matrices using our camera, and enabling reading and writing to the depth buffer. Add the following code in the <code class="literal">draw</code> method:<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatrices( mCam.getCamera() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Now let's create a light and set its position as the camera's eye position. We'll also enable the light and apply the material.<div class="informalexample"><pre class="programlisting">gl::Light light( gl::Light::POINT, 0 );
light.setPosition( mCam.getCamera().getEyePoint() );
light.setAttenuation( 1.0f, 0.0f, 0.0f );
glEnable( GL_LIGHTING );
light.enable();
mMaterial.apply();</pre></div></li><li class="listitem">Now enable and bind the models texture, draw the model, and disable both texture and lighting.<div class="informalexample"><pre class="programlisting">mTexture.enableAndBind();
gl::draw( mMesh );
mTexture.unbind();
glDisable( GL_LIGHTING ); </pre></div></li><li class="listitem">Finally, we will <a id="id523" class="indexterm"/>check if <code class="literal">mIntersects</code> is <code class="literal">true</code> and draw a sphere at the intersection point and the normal vector.<div class="informalexample"><pre class="programlisting">if( mIntersects ){
  gl::color( Color::white() );
  gl::drawSphere( mHitPos, 0.2f );
  gl::drawVector( mHitPos, mHitPos + ( mNormal * 2.0f ) );
    }</pre></div><div class="mediaobject"><img src="graphics/8703OS_8_5.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec229"/>How it works…</h2></div></div></div><p>To calculate the intersection<a id="id524" class="indexterm"/> of the mouse with the model in 3D, we generated a ray from the mouse position towards the view direction of the camera.</p><p>For performance reasons, we first calculate if the ray intersects with the model's bounding box. In case there is an intersection with the model, we further calculate the intersection between the ray and each triangle that makes up the model. For every intersection found, we check its distance and calculate the intersection point and the normal of only the nearest intersection.</p></div></div>
<div class="section" title="Creating a height map from an image"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Creating a height map from an image</h1></div></div></div><p>In this recipe, we will learn <a id="id525" class="indexterm"/>how to create a point cloud based on an image selected by the user. We will create a grid of points where each point will correspond to a pixel. The x and y coordinates of each point will <a id="id526" class="indexterm"/>be equal <a id="id527" class="indexterm"/>to the pixel's position on the image, and the z coordinate will be calculated based on its color.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec230"/>Getting ready </h2></div></div></div><p>Include the necessary files to work with OpenGL, image surfaces, VBO meshes, and loading images.</p><p>Add the following code to the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Surface.h"
#include "cinder/gl/Vbo.h"
#include "cinder/MayaCamUI.h"
#include "cinder/ImageIo.h"</pre></div><p>Also, add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec231"/>How to do it…</h2></div></div></div><p>We will learn how to read pixel values from an image and create a point cloud.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare <code class="literal">ci::Surface32f</code> to store the image pixels, <code class="literal">ci::gl::VboMesh</code> that we will use as the point cloud, and <code class="literal">ci::MayaCamUI</code> for easy rotation of our scene.<div class="informalexample"><pre class="programlisting">Surface32f mImage;
gl::VboMesh mPointCloud;gl::VboMesh mPointCloud;
MayaCamUI mCam;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method,<a id="id528" class="indexterm"/> we will first open a file load dialog and then let the user select the image to use and check if it returns a valid path.<div class="informalexample"><pre class="programlisting">fs::path imagePath = getOpenFilePath( "", ImageIo::getLoadExtensions() );
if( imagePath.empty() == false ){</pre></div></li><li class="listitem">Next, let's load the<a id="id529" class="indexterm"/> image and initialize <code class="literal">mPointCloud</code>. We will set the <code class="literal">ci::gl::VboMesh::Layout</code> to have dynamic positions and colors so that we will be able to change them later.<div class="informalexample"><pre class="programlisting">mImage = loadImage( imagePath );
int numPixels = mImage.getWidth() * mImage.getHeight();
gl::VboMesh::Layout layout;
layout.setDynamicColorsRGB();
layout.setDynamicPositions();
mPointCloud = gl::VboMesh( numPixels, 0, layout, GL_POINTS );</pre></div></li><li class="listitem">Next, we'll iterate over the image's pixels and update the vertices in <code class="literal">mPointCloud</code>.<div class="informalexample"><pre class="programlisting">Surface32f::IterpixelIt = mImage.getIter();
gl::VboMesh::VertexItervertexIt( mPointCloud );
while( pixelIt.line() ){
  while( pixelIt.pixel() ){
                    Color color( pixelIt.r(), pixelIt.g(), pixelIt.b() );
    float height = color.get( CM_RGB ).length();
    float x = pixelIt.x();
    float y = mImage.getHeight() - pixelIt.y();
    float z = height * 100.0f;
    vertexIt.setPosition( x,y, z );
    vertexIt.setColorRGB( color );
                    ++vertexIt;
                }
            }</pre></div></li><li class="listitem">Now we will set up the camera so that it will rotate around the center of the point cloud and close the <code class="literal">if</code> statement we began on the second step.<div class="informalexample"><pre class="programlisting">        Vec3f center( (float)mImage.getWidth()/2.0f, (float)mImage.getHeight()/2.0f, 50.0f );
    CameraPersp camera( getWindowWidth(), getWindowHeight(), 60.0f );
    camera.setEyePoint( Vec3f( center.x, center.y, (float)mImage.getHeight() ) );
    camera.setCenterOfInterestPoint( center );
    mCam.setCurrentCam( camera );
    }</pre></div></li><li class="listitem">Let's<a id="id530" class="indexterm"/> declare and<a id="id531" class="indexterm"/> implement the necessary mouse event handlers to use <code class="literal">mCam</code>.<div class="informalexample"><pre class="programlisting">void mouseDown( MouseEvent event );	
void mouseDrag( MouseEvent event );</pre></div></li><li class="listitem">And implement them:<div class="informalexample"><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mCam.mouseDown( event.getPos() );
}

void MyApp::mouseDrag( MouseEvent event ){
  mCam.mouseDrag( event.getPos(), event.isLeft(), event.isMiddle(), event.isRight() );
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will begin by clearing the background, setting the window's matrices defined by <code class="literal">mCam</code>, and enable reading and writing the depth buffer.<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatrices( mCam.getCamera() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Finally, we will check if <code class="literal">mPointCloud</code> is a valid object and draw it.<div class="informalexample"><pre class="programlisting">if( mPointCloud ){
  gl::draw( mPointCloud );
    }</pre></div></li><li class="listitem">Build and run the application. You will be prompted with a dialog box to select an image file. Select it and you will see a point cloud representation of the image. Drag the mouse cursor to rotate the scene.<div class="mediaobject"><img src="graphics/8703OS_8_6.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec232"/>How it works…</h2></div></div></div><p>We started by <a id="id532" class="indexterm"/>loading an image into <code class="literal">ci::Surface32f.</code> This surface stores pixels as float numbers in the range from <code class="literal">0</code> to <code class="literal">1</code>.</p><p>We created a grid <a id="id533" class="indexterm"/>of points where the <code class="literal">x</code> and <code class="literal">y</code> coordinates represented the pixel's position on the image and the <code class="literal">z</code> coordinate was the length of the color's vector.</p><p>The point cloud is represented by a <code class="literal">ci::gl::VboMesh</code>, which is a mesh of vertices, normal, colors, and indexes with an underlying Vertex Buffer Object. It allows for optimized drawing of geometry.</p></div></div>
<div class="section" title="Creating a terrain with Perlin noise"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Creating a terrain with Perlin noise</h1></div></div></div><p>In this recipe, <a id="id534" class="indexterm"/>we will learn how to <a id="id535" class="indexterm"/>construct a surface in <a id="id536" class="indexterm"/>3D using<a id="id537" class="indexterm"/> <span class="strong"><strong>Perlin noise</strong></span> to create organic deformations that resemble a piece of terrain.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec233"/>Getting ready</h2></div></div></div><p>Include the necessary files to draw using OpenGL, Perlin noise, a Maya camera for navigation, and Cinder's math utilities. Add the following code to the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/Perlin.h"
#include "cinder/MayaCamUI.h"
#include "cinder/CinderMath.h"</pre></div><p>Also, add the following <code class="literal">using</code> statements:</p><div class="informalexample"><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec234"/>How to do it…</h2></div></div></div><p>We will create a grid of 3D points and use Perlin noise to calculate a smooth surface.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare <code class="literal">struct</code> to store the vertices of the terrain by adding the following code before the applications class declaration:<div class="informalexample"><pre class="programlisting">struct Vertice{
    Vec3f position;
    Color color;
};</pre></div></li><li class="listitem">Add the following members to the applications class declaration:<div class="informalexample"><pre class="programlisting">vector&lt; vector&lt;Vertice&gt; &gt; mTerrain;
int mNumRows, mNumLines;
MayaCamUI mCam;
Perlin mPerlin;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, define the number of rows and lines that will make up the terrain's grid. Also, define the gap distance between each point.<div class="informalexample"><pre class="programlisting">mNumRows = 50;
mNumLines = 50;
float gap = 5.0f;</pre></div></li><li class="listitem">Add the vertices to <code class="literal">mTerrain</code> by creating a grid of points laid on the <code class="literal">x</code> and <code class="literal">z</code> axis. We will use<a id="id538" class="indexterm"/> the<a id="id539" class="indexterm"/> values generated by <code class="literal">ci::Perlin</code> to calculate each points height. We will also use the height of the points to define their color:<div class="informalexample"><pre class="programlisting">   mTerrain.resize( mNumRows );
    for( int i=0; i&lt;mNumRows; i++ ){
        mTerrain[i].resize( mNumLines );
        for( int j=0; j&lt;mNumLines; j++ ){
            float x = (float)i * gap;
            float z = (float)j * gap;
            float y = mPerlin.noise( x*0.01f, z*0.01 ) * 100.0f;
            mTerrain[i][j].position = Vec3f( x, y, z );
            float colorVal = lmap( y, -100.0f, 100.0f, 0.0f, 1.0f );
            mTerrain[i][j].color = Color( colorVal, colorVal, colorVal );
        }
    }</pre></div></li><li class="listitem">Now let's define our camera so that it points to the center of the terrain.<div class="informalexample"><pre class="programlisting">float width = mNumRows * gap;
float height = mNumLines * gap;
Vec3f center( width/2.0f, height/2.0f, 0.0f );
Vec3f eye( center.x, center.y, 300.0f );
CameraPersp camera( getWindowWidth(), getWindowHeight(), 60.0f );
camera.setEyePoint( eye );
camera.setCenterOfInterestPoint( center );
mCam.setCurrentCam( camera );</pre></div></li><li class="listitem">Declare the mouse event handlers to use <code class="literal">mCam</code>.<div class="informalexample"><pre class="programlisting">Void mouseDown( MouseEvent event );
void mouseDrag( MouseEvent event );
        }</pre></div></li><li class="listitem">Now let's implement the mouse handlers.<div class="informalexample"><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mCam.mouseDown( event.getPos() );
}
void MyApp::mouseDrag( MouseEvent event ){
  mCam.mouseDrag( event.getPos(), event.isLeft(), event.isMiddle(), event.isRight() );
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, <a id="id540" class="indexterm"/>let's start by clearing the background, setting the matrices using <code class="literal">mCam</code>, and enabling reading and writing of the depth buffer.<div class="informalexample"><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatrices( mCam.getCamera() );
gl::enableDepthRead();
gl::enableDepthWrite();</pre></div></li><li class="listitem">Now enable OpenGL to use the <code class="literal">VERTEX</code> and <code class="literal">COLOR</code> arrays:<div class="informalexample"><pre class="programlisting">glEnableClientState( GL_VERTEX_ARRAY );
glEnableClientState( GL_COLOR_ARRAY );</pre></div></li><li class="listitem">We will<a id="id541" class="indexterm"/> use a nested <a id="id542" class="indexterm"/><code class="literal">for</code> loop to iterate over the terrain and draw each strip of terrain as <code class="literal">GL_TRIANGLE_STRIP</code>.<div class="informalexample"><pre class="programlisting">for( int i=0; i&lt;mNumRows-1; i++ ){
  vector&lt;Vec3f&gt; vertices;
  vector&lt;ColorA&gt; colors;
  for( int j=0; j&lt;mNumLines; j++ ){

    vertices.push_back( mTerrain[i][j].position );
    vertices.push_back( mTerrain[i+1][j].position );
    colors.push_back( mTerrain[i][j].color );
    colors.push_back( mTerrain[i+1][j].color );

            }
  glColor3f( 1.0f, 1.0f, 1.0f );
  glVertexPointer( 3, GL_FLOAT, 0, &amp;vertices[0] );
  glColorPointer( 4, GL_FLOAT, 0, &amp;colors[0] );
  glDrawArrays( GL_TRIANGLE_STRIP, 0, vertices.size() );
  }</pre></div><div class="mediaobject"><img src="graphics/8703OS_8_7.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec235"/>How it works…</h2></div></div></div><p>Perlin noise is a <a id="id543" class="indexterm"/>coherent random number generator capable of creating organic textures and transitions.</p><p>We used the values<a id="id544" class="indexterm"/> created by the <code class="literal">ci::Perlin</code> object to calculate the height of the vertices that make up the terrain and create smooth transitions between vertices.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec236"/>There's more…</h2></div></div></div><p>We can also animate our terrain by adding an increasing offset to the coordinates used to calculate the Perlin noise. Declare the following member variables in your class declaration:</p><div class="informalexample"><pre class="programlisting">float offsetX, offsetZ;</pre></div><p>In the <code class="literal">setup</code> method, <a id="id545" class="indexterm"/>initialize them.</p><div class="informalexample"><pre class="programlisting">offsetX = 0.0f;
offsetZ = 0.0f;</pre></div><p>In the <code class="literal">update</code> method animate each offset value by adding <code class="literal">0.01</code>.</p><div class="informalexample"><pre class="programlisting">offsetX += 0.01f;
offsetZ += 0.01f;</pre></div><p>Also in the <code class="literal">update</code>
<a id="id546" class="indexterm"/> method,<a id="id547" class="indexterm"/> we will iterate over all the vertices of <code class="literal">mTerrain</code>. For each vertex we will use its <code class="literal">x</code> and <code class="literal">z</code> coordinates to calculate the <code class="literal">Y</code> coordinate with <code class="literal">mPerlin noise</code>, but we will offset the coordinates.</p><div class="informalexample"><pre class="programlisting">  for( int i=0; i&lt;mNumRows; i++ ){
  for( int j=0; j&lt;mNumLines; j++ ){
  Vertice&amp; vertice = mTerrain[i][j];
  float x = vertice.position.x;
  float z = vertice.position.z;
  float y = mPerlin.noise( x*0.01f + offsetX, z*0.01f + offsetZ ) * 100.0f;
            vertice.position.y = y;
        }
    }</pre></div></div></div>
<div class="section" title="Saving mesh data"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Saving mesh data</h1></div></div></div><p>Provided that you are<a id="id548" class="indexterm"/> using a <code class="literal">TriMesh</code> class to store 3D geometry, we will show you how to save it in a file.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec237"/>Getting ready</h2></div></div></div><p>We are assuming<a id="id549" class="indexterm"/> that you are using a 3D model stored in <code class="literal">TriMesh</code> object. Sample application loading 3D geometry can be found in <code class="literal">Cinder samples</code> directory in the folder: <code class="literal">OBJLoaderDemo</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec238"/>How to do it…</h2></div></div></div><p>We will implement saving a 3D mesh data.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include necessary headers:<div class="informalexample"><pre class="programlisting">#include "cinder/ObjLoader.h"
#include "cinder/Utilities.h"</pre></div></li><li class="listitem">Implement your <code class="literal">keyDown</code> method as follows:<div class="informalexample"><pre class="programlisting">if( event.getChar() == 's' ) {
  fs::path path = getSaveFilePath(getDocumentsDirectory() / fs::path("mesh.trimesh") );
  if( ! path.empty() ) {
    mMesh.write( writeFile( path ) );
        }
}
  else if( event.getChar() == 'o' ) {
  fs::path path = getSaveFilePath(getDocumentsDirectory() / fs::path("mesh.obj") );
  if( ! path.empty() ) {
  ObjLoader::write( writeFile( path ), mMesh );
    }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec239"/>How it works…</h2></div></div></div><p>In Cinder we<a id="id550" class="indexterm"/> are using a <code class="literal">TriMesh</code> class to store 3D geometry. Using <code class="literal">TriMesh</code> we can store and manipulate geometry loaded from 3D model files or add each vertices with code.</p><p>Every time you hit the <span class="emphasis"><em>S</em></span> key<a id="id551" class="indexterm"/> on the keyboard, a saving dialog pops up to ask you where to save binary data of the <code class="literal">TriMesh</code> object. When you press the<a id="id552" class="indexterm"/> <span class="emphasis"><em>O</em></span> key, the OBJ format file will be saved into your <code class="literal">documents</code> folder. If you don't have to exchange data with other software, binary data saving and loading is usually faster.</p></div></div></body></html>