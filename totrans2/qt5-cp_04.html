<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch04" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 4. Controlling Camera and Taking Photos</h1></div></div></div><p class="calibre9">Through this chapter, you'll find how easy it is to access and control a camera with Qt. The example in this chapter also demonstrates how to utilize the status bar and menu bar. In addition to the traditional Qt Widget applications, there is a QML camera example, which does the same thing as Qt/C++ but in a more elegant way. The following topics, which are covered in this chapter, will extend your application:</p><div><ul class="itemizedlist"><li class="listitem">Accessing the camera in Qt</li><li class="listitem">Controlling the camera</li><li class="listitem">Displaying errors in the status bar</li><li class="listitem">Displaying the permanent widgets in the status bar</li><li class="listitem">Utilizing the menu bar</li><li class="listitem">Using <code class="literal">QFileDialog</code></li><li class="listitem">Using the QML Camera</li></ul></div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec28" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Accessing the camera in Qt</h1></div></div></div><p class="calibre9">Although we won't talk <a id="id166" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>about the technical details of how a camera works, the overview of the implementation of a camera in Qt will be covered. Support for a<a id="id167" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> camera is included in Qt Multimedia, which is a module that provides a rich set of QML types and C++ classes to handle multimedia content. Things such as audio playback, camera, and radio functionality are shown. To complement this, the Qt Multimedia Widgets module provides widget-based multimedia classes to make the work easier.</p><p class="calibre9">There are some classes to help us deal with the camera. For instance, <code class="literal">viewfinder</code> lets a user look through the camera to compose, and in many cases focus, the picture. In Qt/C++, you can use <code class="literal">QGraphicsView</code> along with <code class="literal">QGraphicsVideoItem</code> to do this job. <code class="literal">QGraphicsView</code> provides a widget to display the contents of <code class="literal">QGraphicsScene</code>. In this case, <code class="literal">QGraphicsVideoItem</code> is an item of the scene. This view-scene-item is the<a id="id168" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <strong class="calibre10">Graphics View Framework</strong>. For details on this concept, visit <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://doc.qt.io/qt-5/graphicsview.html">http://doc.qt.io/qt-5/graphicsview.html</a>. In this example, we use <code class="literal">QCameraViewfinder</code>, which is the dedicated <code class="literal">viewfinder</code> class and is simpler and more straightforward.</p><p class="calibre9">To capture a photo, we<a id="id169" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> need to use the <code class="literal">QCameraImageCapture</code> <a id="id170" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>class, which records the media content, while the focus and zoom are managed by the <code class="literal">QCameraFocus</code> class.</p><p class="calibre9">After all, <code class="literal">QCamera</code> plays a core role in this process. The <a id="id171" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">QCamera</code> class provides an interface to access the camera devices, including webcams and mobile device cameras. There is <a id="id172" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>another class, <code class="literal">QCameraInfo</code>, which can list all the available camera devices and choose which one to use. The following diagram will help you understand this:</p><div><img src="img/4615OS_04_01.jpg" alt="Accessing the camera in Qt" class="calibre47"/></div><p class="calibre9">To see a<a id="id173" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> demonstration, create a new Qt Widget Application project named <code class="literal">CameraDemo</code>. Edit the <code class="literal">CameraDemo.pro</code> file. Add multimedia <code class="literal">multimediawidgets</code> to QT by appending a line, as shown here, or add two modules to the predefined QT line:</p><div><pre class="programlisting">QT       += multimedia multimediawidgets</pre></div><p class="calibre9">After this modification, you need save the file and navigate to <strong class="calibre10">Build</strong> | <strong class="calibre10">Run qmake</strong> to load these new modules. Let's edit the <code class="literal">mainwindow.ui</code> file of <code class="literal">CameraDemo</code> to add some widgets to use the camera by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Remove the status and menu bars. They will be re-added in the next sections. For now, they're removed for a cleaner user interface.</li><li class="listitem1">Drag <strong class="calibre10">Widget</strong> into the frame.</li><li class="listitem1">Change its name to <code class="literal">viewfinder</code>.</li><li class="listitem1">Right-click on <code class="literal">viewfinder</code> and select <strong class="calibre10">Promote to …</strong>.</li><li class="listitem1">Fill in <code class="literal">QCameraViewfinder</code> in the <strong class="calibre10">Promoted class name</strong> field. Remember to tick the <strong class="calibre10">Global include</strong> checkbox because this is a predefined Qt class. Click on <strong class="calibre10">Add</strong>, and then on <strong class="calibre10">Promote</strong>.</li><li class="listitem1">Set <strong class="calibre10">MainWindow</strong> to <strong class="calibre10">Lay Out Horizontally</strong>.</li><li class="listitem1">Drag a <strong class="calibre10">Vertical</strong> layout on the right-hand side of <code class="literal">viewfinder</code>. Following this, components will be added to the layout.</li><li class="listitem1">Add <strong class="calibre10">Label</strong>, which is<a id="id174" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> used to display the captured image. Note that, here we don't use <code class="literal">QGraphicsView</code>, simply because <code class="literal">QLabel</code> is good enough for this purpose and is much easier.</li><li class="listitem1">Rename<a id="id175" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> it as <code class="literal">previewLabel</code> and clear its text.</li><li class="listitem1">Drag <strong class="calibre10">Combo Box</strong> just beneath <code class="literal">previewLabel</code>.</li><li class="listitem1">Rename it as <code class="literal">cameraComboBox</code> since it'll be used to display all the available camera devices.</li><li class="listitem1">Add a <strong class="calibre10">Push Button</strong> named <code class="literal">captureButton</code> below <code class="literal">ComboBox</code> in the <strong class="calibre10">Vertical</strong> layout to let the user click to take a photo. This button should have the text <code class="literal">Capture</code> on it.</li></ol></div><p class="calibre9">It should look like the following screenshot:</p><div><img src="img/4615OS_04_02.jpg" alt="Accessing the camera in Qt" class="calibre48"/></div><p class="calibre9">Now, go<a id="id176" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> back to<a id="id177" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <code class="literal">mainwindow.h</code> edit, as shown here:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
#include &lt;QCamera&gt;
#include &lt;QCameraInfo&gt;
#include &lt;QCameraImageCapture&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
  QList&lt;QCameraInfo&gt; camList;
  QCamera *camera;
  QCameraImageCapture *imgCapture;

private slots:
  void onCameraChanged(int);
  void onCaptureButtonClicked();
  void onImageCaptured(int, const QImage &amp;);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">As usual, in order to use the classes in the preceding code, we have to include them properly. In <a id="id178" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>addition to this, we use <code class="literal">camList</code>, which is a type of <code class="literal">QList&lt;QCameraInfo&gt;</code>, to store the available camera devices. Since QList is a template class, we have to pass the type of list element, which is <code class="literal">QCameraInfo</code> in this case, to the constructor.</p><p class="calibre9">These private<a id="id179" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> slots are responsible for the camera controls, namely, changing the camera device and clicking the capture button. Meanwhile, <code class="literal">onImageCaptured</code> is used to handle the <code class="literal">imageCaptured</code> signal of <code class="literal">QCameraImageCapture</code>.</p><p class="calibre9">The content of the <code class="literal">maindow.cpp</code> file is shown as follows:</p><div><pre class="programlisting">#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);

  camera = NULL;
  connect(ui-&gt;captureButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onCaptureButtonClicked);
  connect(ui-&gt;cameraComboBox, static_cast&lt;void (QComboBox::*) (int)&gt;(&amp;QComboBox::currentIndexChanged), this, &amp;MainWindow::onCameraChanged);

  camList = QCameraInfo::availableCameras();
  for (QList&lt;QCameraInfo&gt;::iterator it = camList.begin(); it != camList.end(); ++it) {
    ui-&gt;cameraComboBox-&gt;addItem(it-&gt;description());
  }
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::onCameraChanged(int idx)
{
  if (camera != NULL) {
    camera-&gt;stop();
  }

  camera = new QCamera(camList.at(idx), this);
  camera-&gt;setViewfinder(ui-&gt;viewfinder);
  camera-&gt;setCaptureMode(QCamera::CaptureStillImage);
  camera-&gt;start();
}

void MainWindow::onCaptureButtonClicked()
{
  imgCapture = new QCameraImageCapture(camera, this);
  connect(imgCapture, &amp;QCameraImageCapture::imageCaptured, this, &amp;MainWindow::onImageCaptured);
  camera-&gt;searchAndLock();
  imgCapture-&gt;setCaptureDestination(QCameraImageCapture::CaptureToFile);
  imgCapture-&gt;capture();
}

void MainWindow::onImageCaptured(int, const QImage &amp;img)
{
  QPixmap pix = QPixmap::fromImage(img).scaled(ui-&gt;previewLabel-&gt;size(), Qt::KeepAspectRatio);
  ui-&gt;previewLabel-&gt;setPixmap(pix);
  camera-&gt;unlock();
  imgCapture-&gt;deleteLater();
}</pre></div><p class="calibre9">Let's have a look<a id="id180" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> at the constructor first. We give <code class="literal">camera</code> a <code class="literal">NULL</code> address to mark that there is no camera allocated and/or active. This is explained later.</p><p class="calibre9">Since there <a id="id181" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>are overloaded signal functions for <code class="literal">QComboBox::currentIndexChanged</code>, you have to specify the signal that you want with <code class="literal">static_cast</code>. Otherwise, the compiler would complain and fail to compile. Only the new syntax statement of the signal and slot are affected, which means the old syntax statement, shown here, won't pose any errors:</p><div><pre class="programlisting">connect(ui-&gt;cameraComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(onCameraChanged(int)));</pre></div><p class="calibre9">However, as mentioned previously, the new syntax has many advantages and it's highly recommended that you replace the old one.</p><p class="calibre9">As we continue, we can fill in <code class="literal">camList</code> with the available cameras since <code class="literal">availableCameras</code> is a static member function of <code class="literal">QCameraInfo</code>, which returns a list of all available <a id="id182" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>cameras on the system. Also, you can pass an argument to specify the camera position, such as the front or back camera, which is pretty useful on mobile platforms.</p><p class="calibre9">Then, we add all<a id="id183" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the items in <code class="literal">camList</code> to our camera <code class="literal">combobox</code>. Here, it's the iterator that walks through the list and operates each one. Using iterators is very fast when dealing with a list, array, and so on. Qt supports this method, including both Java-style and STL-style iterators. In this case, we prefer and use STL-style iterators. The description function of <code class="literal">QCameraInfo</code> returns a human-readable description of the camera.</p><p class="calibre9">Now, let's go inside <code class="literal">onCameraChanged</code>. Before the construction of the camera, we need to check whether there is a camera present already. If there is, we stop the old camera. Then, we set up the <code class="literal">viewfinder</code> class using the <code class="literal">viewfinder</code> widget, which we did in the <strong class="calibre10">Design</strong> mode. After specifying the capture mode to <code class="literal">CaptureStillImage</code>, we can start the camera.</p><div><div><h3 class="title4"><a id="tip08" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">The camera cannot start again if it's not deallocated (stopped).</p></div></div><p class="calibre9">Consequently, it goes to the <code class="literal">onCaptureButtonClicked</code> slot. Similarly, the <code class="literal">imgCapture</code> object is constructed by passing the <code class="literal">camera</code> and <code class="literal">this</code> arguments as its <code class="literal">QCamera</code> target and <code class="literal">QObject</code> parent respectively. Then, we have to connect the <code class="literal">imageCaptured</code> signal to the <code class="literal">onImageCaptured</code> slot of <code class="literal">MainWindow</code>. Now, let <code class="literal">camera-&gt;searchAndLock()</code> lock all the camera settings. This <a id="id184" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function is in response to the shutter button being half pressed. Before taking a shot, we set the capture destination to the file. Although it can be set to a buffer using the <code class="literal">QCameraImageCapture::CaptureToBuffer</code> flag if needed, bear in mind that it's not supported on all platforms.</p><p class="calibre9">If everything goes well, an image will be captured by <code class="literal">camera</code> and the <code class="literal">imageCaptured</code> signal will be emitted. Then, the <code class="literal">onImageCaptured</code> slot function will be executed. Inside this function, we scale the captured image to the size of our <code class="literal">previewLabel</code>. Then, just set <code class="literal">QPixmap</code> for <code class="literal">previewLabel</code> and unlock <code class="literal">camera</code>. In the end, we call the <code class="literal">deleteLater()</code> function to safely delete the <code class="literal">imgCapture</code> instance.</p><div><div><h3 class="title4"><a id="note14" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">You should explicitly indicate <code class="literal">Qt::KeepAspectRatio</code>, otherwise it uses the default <code class="literal">Qt::IgnoreAspectRatio</code> flag.</p></div></div><p class="calibre9">Now, run the demo and see what you get.</p><div><img src="img/4615OS_04_03.jpg" alt="Accessing the camera in Qt" class="calibre49"/></div><p class="calibre9">Just as we did<a id="id185" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> in the previous chapters, feel free to change the window's title, application font, and <a id="id186" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>so on. These trivial tweaks won't be detailed anymore.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec29" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Controlling the camera</h1></div></div></div><p class="calibre9">The <code class="literal">QCameraFocus</code> class is<a id="id187" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> mentioned to control the zoom and focus of the camera. Speaking of <a id="id188" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>zoom, Qt supports both optical and digital zoom. As we all know, optical zoom offers a better quality than digital. Hence, optical zoom should take priority over digital.</p><p class="calibre9">Drag a horizontal slider and a label to <strong class="calibre10">MainWindow</strong> pane's <code class="literal">verticalLayout</code> just above the capture button. Name them <code class="literal">zoomSlider</code> and <code class="literal">zoomLabel</code>, respectively. Remember to change the text of <code class="literal">zoomLabel</code> to <code class="literal">Zoom</code> and <code class="literal">Horizontal</code> in <code class="literal">alignment</code> to <code class="literal">AlignHCenter</code>. Since Qt doesn't provide a floating point number slider, we simply multiply <code class="literal">10</code> to get an integer in the slider. Hence, change the <code class="literal">minimum</code> value of <code class="literal">zoomSlider</code> to <code class="literal">10</code>, which means zoom by 1.0.</p><p class="calibre9">Include <code class="literal">QCameraFocus</code> in <code class="literal">mainwindow.h</code> and add these two private members:</p><div><pre class="programlisting">QCameraFocus *cameraFocus;
qreal maximumOptZoom;</pre></div><div><div><h3 class="title4"><a id="tip09" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">Not every camera supports zoom. If it doesn't, the maximum zoom is 1.0, which applies to both optical and digital zoom.</p></div></div><p class="calibre9">There is a type<a id="id189" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> named <code class="literal">qreal</code>, which is basically a <code class="literal">double</code> value. It was <code class="literal">float</code> on the ARM platforms for performance concerns and <code class="literal">double</code> on others. However, Qt has used <code class="literal">double</code> on ARM by default since the Qt 5.2 version. Anyway, using <code class="literal">qreal</code> is recommended if the application is deployed on different hardware platforms.</p><p class="calibre9">A new slot also needs to be declared:</p><div><pre class="programlisting">void onZoomChanged(int);</pre></div><p class="calibre9">Now, connect <code class="literal">zoomSlider</code> in the <code class="literal">MainWindow</code> class' constructor:</p><div><pre class="programlisting">connect(ui-&gt;zoomSlider, &amp;QSlider::valueChanged, this, &amp;MainWindow::onZoomChanged);</pre></div><p class="calibre9">However, <code class="literal">QCameraFocus</code> can't be constructed explicitly. Instead, it can only be retrieved from the <code class="literal">QCamera</code> class. So, we get <code class="literal">cameraFocus</code> just after the construction of the <code class="literal">camera</code> argument inside <code class="literal">onCameraChanged</code>:</p><div><pre class="programlisting">cameraFocus = camera-&gt;focus();</pre></div><p class="calibre9">Then, set up <code class="literal">maximumOptZoom</code> and the <code class="literal">maximum</code> value of <code class="literal">zoomSlider</code>:</p><div><pre class="programlisting">maximumOptZoom = cameraFocus-&gt;maximumOpticalZoom();
ui-&gt;zoomSlider-&gt;setMaximum(maximumOptZoom * cameraFocus-&gt;maximumDigitalZoom() * 10);</pre></div><p class="calibre9">If the camera doesn't support zoom at all, the slider won't be able to slide. The definition of the <code class="literal">onZoomChanged</code> slot is shown in the following lines:</p><div><pre class="programlisting">void MainWindow::onZoomChanged(int z)
{
  qreal zoom = qreal(z) / 10.0;
  if (zoom &gt; maximumOptZoom) {
    cameraFocus-&gt;zoomTo(maximumOptZoom, zoom / maximumOptZoom);
  }
  else {
    cameraFocus-&gt;zoomTo(zoom, 1.0);
  }
}</pre></div><p class="calibre9">As you can see, the first parameter of <code class="literal">zoomTo</code> is the optical zoom factor while the other is the digital zoom<a id="id190" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> factor.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec30" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Displaying errors on the status bar</h1></div></div></div><p class="calibre9">First of all, there<a id="id191" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> could be errors during the whole camera process and it's a good practice to make the user aware of what the error is. It can be done by a pop-up dialog and/or status bar. You don't want to alert the user to every trivial error. Therefore, it'd be better to use a pop-up dialog only for critical errors, while displaying <a id="id192" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>non-critical errors and warnings on the status bar.</p><p class="calibre9">Qt began supporting the status bar a long time ago. The<a id="id193" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">QStatusBar</code> class is the one that provides a horizontal bar suitable for presenting status information. The status of the camera can be displayed as well and it'll be introduced in later topics.</p><p class="calibre9">To use the status bar, edit <code class="literal">mainwindow.ui</code>, right-click on <code class="literal">MainWindow</code>, and select <strong class="calibre10">Create Status Bar</strong> if it doesn't exist or was previously removed.</p><p class="calibre9">Then, we should declare two slots to handle the camera and image capture errors, respectively. Add these two lines to <code class="literal">private slots</code> in <code class="literal">mainwindow.h</code>:</p><div><pre class="programlisting">void onCameraError();
void onImageCaptureError(int, QCameraImageCapture::Error, const QString &amp;);</pre></div><p class="calibre9">The definitions in <code class="literal">mainwindow.cpp</code> are shown as follows:</p><div><pre class="programlisting">void MainWindow::onCameraError()
{
  ui-&gt;statusBar-&gt;showMessage(camera-&gt;errorString(), 5000);
}

void MainWindow::onImageCaptureError(int, QCameraImageCapture::Error, const QString &amp;err)
{
  ui-&gt;statusBar-&gt;showMessage(err, 5000);
  imgCapture-&gt;deleteLater();
}</pre></div><p class="calibre9">This simply makes <code class="literal">statusBar</code> show a temporary message for five seconds. Even if you pass zero to <code class="literal">showMessage</code>, it's still a temporary message. In later cases, it won't disappear after a given period; instead, it'll disappear if there is a new temporary message.</p><p class="calibre9">Since the signal error is different in <code class="literal">QCamera</code> from <code class="literal">QCameraImageCapture</code>, we use different slots to handle it. For <code class="literal">QCamera</code>, the <code class="literal">error</code> signal function has <code class="literal">QCamera::Error</code> as the only argument.</p><p class="calibre9">By contrast, <code class="literal">QCameraImageCapture::error</code> provides three arguments: <code class="literal">int</code>, <code class="literal">QCameraImageCapture::Error</code>, and a <code class="literal">const QString</code> reference. Therefore, we can make use of this signal by using its error <code class="literal">string</code> directly.</p><p class="calibre9">Don't forget to<a id="id194" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> connect the signals and slots. Here, inside the <code class="literal">onCameraChanged</code> function, just after the <code class="literal">camera</code> construction, connect the <code class="literal">camera</code> error and the <code class="literal">onCameraError</code> slot.</p><div><pre class="programlisting">connect(camera, static_cast&lt;void (QCamera::*) (QCamera::Error)&gt;(&amp;QCamera::error), this, &amp;MainWindow::onCameraError);</pre></div><p class="calibre9">As there is another<a id="id195" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> overloaded function called <code class="literal">error</code> in the <code class="literal">QCamera</code> class, we have to use <code class="literal">static_cast</code> to specify the signal function, as we did in <code class="literal">QComboBox</code>.</p><p class="calibre9">Similarly, add the <code class="literal">connect</code> statement after the <code class="literal">imgCapture</code> object's construction in the <code class="literal">onCaptureButtonClicked</code> function.</p><div><pre class="programlisting">connect(imgCapture, static_cast&lt;void (QCameraImageCapture::*) (int, QCameraImageCapture::Error, const QString &amp;)&gt;(&amp;QCameraImageCapture::error), this, &amp;MainWindow::onImageCaptureError);</pre></div><p class="calibre9">It is another overloaded <code class="literal">error</code> signal function. However, it's tedious because of three arguments.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec31" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Permanent widgets in the status bar</h1></div></div></div><p class="calibre9">Sometimes, we want<a id="id196" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> a sort of indicator inside the status bar to display real-time status, such as the camera status. This is inappropriate if it's<a id="id197" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> covered by temporary messages. In such a case, <code class="literal">QStatusBar</code> provides the <code class="literal">insertPermanentWidget</code> function to add a widget to the status bar permanently. It means that it won't be obscured by temporary messages and is located on the far right of the status bar.</p><p class="calibre9">Firstly, let's make a camera status widget. Add a new C++ class named <code class="literal">CameraStatusWidget</code> that inherits from <code class="literal">QWidget</code>, but use <code class="literal">QLabel</code> as the base class. We use <code class="literal">QLabel</code> as the base class because the status of the camera is displayed in text and is basically a customized label widget. The <code class="literal">camerastatuswidget.h</code> content is shown as follows:</p><div><pre class="programlisting">#ifndef CAMERASTATUSWIDGET_H
#define CAMERASTATUSWIDGET_H

#include &lt;QLabel&gt;
#include &lt;QCamera&gt;

class CameraStatusWidget : public QLabel
{
  Q_OBJECT
  public:
    explicit CameraStatusWidget(QWidget *parent = 0);

  public slots:
    void onCameraStatusChanged(QCamera::Status);
};

#endif // CAMERASTATUSWIDGET_H</pre></div><p class="calibre9">Besides the <code class="literal">#include &lt;QCamera&gt;</code>, we only add a declaration of the <code class="literal">onCameraStatusChanged</code> slot to<a id="id198" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> this header file. The relevant <code class="literal">camerastatuswidget.cpp</code> source<a id="id199" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> file is pasted as follows:</p><div><pre class="programlisting">#include "camerastatuswidget.h"

CameraStatusWidget::CameraStatusWidget(QWidget *parent) :
  QLabel(parent)
{
}

void CameraStatusWidget::onCameraStatusChanged(QCamera::Status s)
{
  QString status;
  switch (s) {
    case QCamera::ActiveStatus:
      status = QString("Active");
      break;
    case QCamera::StartingStatus:
      status = QString("Starting");
      break;
    case QCamera::StoppingStatus:
      status = QString("Stopping");
      break;
    case QCamera::StandbyStatus:
      status = QString("Standby");
      break;
    case QCamera::LoadedStatus:
      status = QString("Loaded");
      break;
    case QCamera::LoadingStatus:
      status = QString("Loading");
      break;
    case QCamera::UnloadingStatus:
      status = QString("Unloading");
      break;
    case QCamera::UnloadedStatus:
      status = QString("Unloaded");
      break;
    case QCamera::UnavailableStatus:
      status = QString("Unavailable");
      break;
    default:
      status = QString("Unknown");
  }
  this-&gt;setText(status);
}</pre></div><div><div><h3 class="title4"><a id="tip10" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">Always handle exceptions in the <code class="literal">switch</code> statements.</p></div></div><p class="calibre9">
<code class="literal">QCamera::Status</code> is an <code class="literal">enum</code> type. That's why we have to use a <code class="literal">switch</code> statement to <code class="literal">translate</code> the<a id="id200" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> status to <code class="literal">string</code>. Since we have our camera status widget now, it's time to add it to the status bar. Edit <code class="literal">mainwindow.h</code> and add a<a id="id201" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">CameraStatusWidget</code> pointer as follows:</p><div><pre class="programlisting">CameraStatusWidget *camStatusWid;</pre></div><p class="calibre9">Don't forget to include the <code class="literal">camerastatuswidget.h</code> header file. Then, set up <code class="literal">camStatusWid</code> just after <code class="literal">ui-&gt;setupUi(this)</code> by adding the following lines:</p><div><pre class="programlisting">camStatusWid = new CameraStatusWidget(ui-&gt;statusBar);
ui-&gt;statusBar-&gt;addPermanentWidget(camStatusWid);</pre></div><p class="calibre9">Navigate to the <code class="literal">onCameraChanged</code> function; we need to connect the <code class="literal">QCamera::statusChanged</code> signal. Just add the following line after construction of the camera:</p><div><pre class="programlisting">connect(camera, &amp;QCamera::statusChanged, camStatusWid, &amp;CameraStatusWidget::onCameraStatusChanged);</pre></div><p class="calibre9">Likewise, we can add current zoom to the status bar. In fact, for this small and easy-to-do widget, we don't need to create a new class. Instead, we'll use the existing <code class="literal">QLabel</code> class to achieve this by declaring a new member. In <code class="literal">mainwindow.h</code>, add a new private member:</p><div><pre class="programlisting">QLabel *zoomStatus;</pre></div><p class="calibre9">Meanwhile, construct and insert the <code class="literal">zoomStatus</code> into <code class="literal">statusBar</code> in the <code class="literal">MainWindow</code> class constructor in <code class="literal">mainwindow.cpp</code>:</p><div><pre class="programlisting">zoomStatus = new QLabel(QString::number(qreal(ui-&gt;zoomSlider-&gt;value()) / 10.0), this);
ui-&gt;statusBar-&gt;addPermanentWidget(zoomStatus);</pre></div><p class="calibre9">Here, we use a<a id="id202" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">number</code> function, which is a static public function of the <code class="literal">QString</code> class to convert a number (it can be <code class="literal">double</code> or <code class="literal">integer</code>) to <code class="literal">QString</code>. In order to update <code class="literal">zoomStatus</code> in time, append this line to the <code class="literal">onZoomChanged</code> function:</p><div><pre class="programlisting">zoomStatus-&gt;setText(QString::number(zoom));</pre></div><p class="calibre9">After these <a id="id203" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>modifications, the application will run as shown<a id="id204" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> in the following screenshot:</p><div><img src="img/4615OS_04_04.jpg" alt="Permanent widgets in the status bar" class="calibre49"/></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec32" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Utilizing the menu bar</h1></div></div></div><p class="calibre9">Now that you have<a id="id205" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> finished the bar at the bottom, it's time to begin the one on top—the menu bar. Similar to the status bar, right-click on <code class="literal">MainWindow</code> in the <strong class="calibre10">Design</strong> mode, and select <strong class="calibre10">Create Menu Bar</strong> if it doesn't exist or was previously removed.</p><p class="calibre9">Then, just follow the hints. Add a <strong class="calibre10">File</strong> menu containing the <strong class="calibre10">Exit</strong> action. Another menu could be <strong class="calibre10">About</strong>, which contains the <strong class="calibre10">About CameraDemo</strong> action. You should know that these actions are able to change in the <strong class="calibre10">Action Editor</strong> panel, which is in the same place as <strong class="calibre10">Signals &amp; Slots Editor</strong>.</p><div><img src="img/4615OS_04_05.jpg" alt="Utilizing the menu bar" class="calibre50"/></div><p class="calibre9">As shown in<a id="id206" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the following screenshot, the names of these actions are changed to <code class="literal">actionAbout</code> and <code class="literal">actionExit</code>, respectively. In addition to this, there is a shortcut, <em class="calibre14">Ctrl</em> + <em class="calibre14">Q,</em> for <code class="literal">actionExit</code>. Just double-click on the action and add shortcuts by pressing the shortcut you want. This is shown in the following screenshot:</p><div><img src="img/4615OS_04_06.jpg" alt="Utilizing the menu bar" class="calibre51"/></div><p class="calibre9">We already used <code class="literal">QMenu</code> and <code class="literal">QAction</code> in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch02.xhtml" title="Chapter 2. Building a Beautiful Cross-platform Clock">Chapter 2</a>, <em class="calibre14">Building a Beautiful Cross-platform Clock</em>. The difference here is that you use <code class="literal">QMenu</code> as the menu bar, and set it up it in <strong class="calibre10">Design</strong> mode instead of writing code. But why is it called <code class="literal">QAction</code>? This is because the user can trigger a command on the menu, tool bar, or keyboard shortcut. They expect the same behavior regardless of where it is. Therefore, it should be abstracted into an action, which can be<a id="id207" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> inserted into the menu or tool bar. You can set it to the checkable <code class="literal">QAction</code> option and use it as a simple <code class="literal">QCheckbox</code> option.</p><p class="calibre9">Let's finish <code class="literal">actionExit</code> first, since it's simpler than the other one. For <code class="literal">actionExit</code>, we only need one <code class="literal">connect</code> statement to make it work. Add the following statement to the <code class="literal">MainWindow</code> class constructor in the <code class="literal">mainwindow.cpp</code> file:</p><div><pre class="programlisting">connect(ui-&gt;actionExit, &amp;QAction::triggered, this, &amp;MainWindow::close);</pre></div><p class="calibre9">The <code class="literal">triggered</code> signal will be emitted by either a mouse click or a keyboard shortcut (if there is a shortcut). Since we connect it to the <code class="literal">close</code> slot of <code class="literal">MainWindow</code>, it'll close <code class="literal">MainWindow</code>, which results in exiting the entire application.</p><p class="calibre9">Meanwhile, we need to declare a slot to fulfill the connection with <code class="literal">actionAbout</code>. As usual, declare it in the <code class="literal">mainwindow.h</code> header file.</p><div><pre class="programlisting">void onAboutTriggered();</pre></div><p class="calibre9">You may think that we're going to create a new class just to show an <strong class="calibre10">About</strong> dialog. Well, we don't have to cook the <strong class="calibre10">About</strong> dialog ourselves because Qt has already done this for us. It's included<a id="id208" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> in <code class="literal">QMessageBox</code>, so you should include it with the following line:</p><div><pre class="programlisting">#include &lt;QMessageBox&gt;</pre></div><p class="calibre9">This is the definition of the slot:</p><div><pre class="programlisting">void MainWindow::onAboutTriggered()
{
  QMessageBox::about(this, QString("About"), QString("Camera Demonstration of Qt5"));
}</pre></div><div><div><h3 class="title4"><a id="note15" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">The<a id="id209" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">QMessageBox</code> class provides a modal dialog for informing or asking the user a question and receiving an answer.</p></div></div><p class="calibre9">Almost every kind of pop-up dialog can be found in <code class="literal">QMessageBox</code>. Here, we use the static <code class="literal">About</code> function<a id="id210" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to create an <strong class="calibre10">About</strong> dialog. It has three arguments. The first one is the parent <code class="literal">QObject</code> pointer, followed by the title and context. Remember to connect the signal and slot in the <code class="literal">MainWindow</code> class constructor.</p><div><pre class="programlisting">connect(ui-&gt;actionAbout, &amp;QAction::triggered, this, &amp;MainWindow::onAboutTriggered);</pre></div><p class="calibre9">If you compile and run the application again, try to trigger the <strong class="calibre10">About</strong> dialog, which would look similar to the following screenshot:</p><div><img src="img/4615OS_04_07.jpg" alt="Utilizing the menu bar" class="calibre52"/></div><div><div><h3 class="title4"><a id="note16" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">In addition to <code class="literal">About</code>, there are other useful static public members of <code class="literal">QMessageBox</code>. Most commonly, <code class="literal">critical</code>, <code class="literal">information</code>, <code class="literal">question</code>, and, <code class="literal">warning</code> are used to pop up a message box. Sometimes, you'll see an <strong class="calibre10">About Qt</strong> entry in the menu bar, which is to call the <code class="literal">aboutQt</code> function.</p></div></div><p class="calibre9">In fact, the <strong class="calibre10">About</strong> dialog will display an icon if it exists. There is an empty space since it lacks an icon. The<a id="id211" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> order of the search icons is shown as follows:</p><div><ul class="itemizedlist"><li class="listitem">This first icon will be <code class="literal">parent-&gt;icon()</code>, if it exists.</li><li class="listitem">The second icon will be the top-level widget, which contains <code class="literal">parent</code>.</li><li class="listitem">The third icon will be the active window.</li><li class="listitem">The fourth icon will be the <code class="literal">Information</code> icon.</li></ul></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec33" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Using QFileDialog</h1></div></div></div><p class="calibre9">The last step of taking a<a id="id212" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> photo is to save it to disk. At this point, the program saves an image to the file, but the location is determined by the camera backend. We can simply use a dialog, letting the user choose the directory and the filename of the photo. There is a <code class="literal">QFileDialog</code> class to help make the work easier. The easiest way to create a <code class="literal">QFileDialog</code> class is to use the static functions. Therefore, edit the <code class="literal">onCaptureButtonClicked</code> function in the <code class="literal">mainwindow.cpp</code> file.</p><div><pre class="programlisting">void MainWindow::onCaptureButtonClicked()
{
  imgCapture = new QCameraImageCapture(camera, this);
  connect(imgCapture, static_cast&lt;void (QCameraImageCapture::*) (int, QCameraImageCapture::Error, const QString &amp;)&gt;(&amp;QCameraImageCapture::error), this, &amp;MainWindow::onImageCaptureError);
  connect(imgCapture, &amp;QCameraImageCapture::imageCaptured, this, &amp;MainWindow::onImageCaptured);

  camera-&gt;searchAndLock();
  imgCapture-&gt;setCaptureDestination(QCameraImageCapture::CaptureToFile);
  QString location = QFileDialog::getSaveFileName(this, QString("Save Photo As"), QString(), "JPEG Image (*.jpg)");
  imgCapture-&gt;capture(location);
}</pre></div><p class="calibre9">Here, we're using the <code class="literal">getSaveFileName</code> static function to create a file dialog to return the file that the user selected. If the user clicks on <strong class="calibre10">Cancel</strong>, the <code class="literal">location</code> type would be an empty <code class="literal">QString</code> reference and the image will be stored in a default location. The file doesn't need to exist. In fact, if it exists, there will be an overwrite dialog. This function's prototype is pasted as follows:</p><div><pre class="programlisting">QString QFileDialog::getSaveFileName(QWidget * parent = 0, const QString &amp; caption = QString(), const QString &amp; dir = QString(), const QString &amp; filter = QString(), QString * selectedFilter = 0, Options options = 0)</pre></div><p class="calibre9">The first argument is the <code class="literal">QObject</code> parent, as usual. The second one is the dialog's title, followed by the default directory. The <code class="literal">filter</code> object is used to restrict the file type and it's possible to use multiple filters that are separated by two semicolons, <code class="literal">;;</code>. Here is an example:</p><div><pre class="programlisting">"JPEG (*.jpeg *.jpg);;PNG (*.png);;BMP (*.bmp)"</pre></div><p class="calibre9">Setting<a id="id213" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">selectedFilter</code> can change the default filter. Lastly, <code class="literal">Options</code> is used to define the behaviors of the file dialog. For more details, refer to the <code class="literal">QFileDialog</code> documentation.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec34" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>QML camera</h1></div></div></div><p class="calibre9">So far, we talked about how to access and control the camera in Qt/C++. Now it's time to see how QML does in this area. Although there are some limitations, you'll find it's much easier and more <a id="id214" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>elegant to do this in Qt Quick/QML because of the many packages that Qt has to offer.</p><p class="calibre9">Create a new Qt Quick application project. The <code class="literal">main.qml</code> content is shown as follows:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2
import QtMultimedia 5.3
import "qrc:/"

ApplicationWindow {
  visible: true
  width: 640
  height: 480
  title: qsTr("QML Camera Demo")

  Camera {
    id: camera

    imageCapture {
      onImageCaptured: {
        photoPreview.source = preview
        photoPreview.visible = true;
        previewTimer.running = true;
      }
    }
  }

  VideoOutput {
    id: viewfinder
    source: camera
    anchors.fill: parent
  }

  Image {
    id: photoPreview
    anchors.fill: viewfinder
  }

  Timer {
    id: previewTimer
    interval: 2000
    onTriggered: photoPreview.visible = false;
  }

  CaptureButton {
    anchors.right: parent.right
    anchors.verticalCenter: parent.verticalCenter
    diameter: 50
  }
}</pre></div><p class="calibre9">Let me walk you through this one.</p><p class="calibre9">
<code class="literal">Camera</code> and <code class="literal">VideoOutput</code> are provided by the <code class="literal">QtMultimedia</code> module. Similar to the Qt/C++ classes, the <code class="literal">Camera</code> type is identical to the <code class="literal">QCamera</code> class. The preview is dealt with differently when <code class="literal">VideoOutput</code> is used as <code class="literal">viewfinder</code>. An <code class="literal">image</code> object is used to display the <a id="id215" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>captured photo and it's only visible for 2 seconds each time a picture is taken. This <code class="literal">photoPreview</code> is controlled by the timer, <code class="literal">previewTimer</code>. In other words, the 2 seconds show up of <code class="literal">photoPreview</code> depends on this <code class="literal">previewTimer</code> timer. At the same time, the <code class="literal">camera</code> type's <code class="literal">imageCapture</code> will provide the <code class="literal">preview</code> image to <code class="literal">photoPreview</code> and turn on <code class="literal">previewTimer</code> once it captures a photo.</p><p class="calibre9">The last piece is <code class="literal">CaptureButton</code>, which is not provided by Qt but written in another file, <code class="literal">CaptureButton.qml</code>. Its content is shown in the following code:</p><div><pre class="programlisting">import QtQuick 2.3

Rectangle {
  property real diameter

  width: diameter
  height: diameter

  color: "blue"
  border.color: "grey"
  border.width: diameter / 5
  radius: diameter * 0.5

  MouseArea {
    anchors.fill: parent
    onClicked: camera.imageCapture.capture()
  }
}</pre></div><p class="calibre9">Since there is no circular shape provided by Qt Quick, we use this <code class="literal">Rectangle</code> object as a workaround<a id="id216" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to display it as a circle. Just like what we did in the previous chapter, define a <code class="literal">diameter</code> property to hold both <code class="literal">height</code> and <code class="literal">width</code>. The trick is the radius value. By setting it to half the diameter, this <code class="literal">Rectangle</code> object becomes circular. Last but not least, add <code class="literal">MouseArea</code> to respond to a user's click. It's a pity that <code class="literal">MouseArea</code> can't be circular, so just leave it and fill in the button.</p><p class="calibre9">Now you can run your application, and it should be something similar to this:</p><div><img src="img/4615OS_04_08.jpg" alt="QML camera" class="calibre21"/></div><p class="calibre9">It's not as powerful as the Qt/C++ demo. The first thing you probably notice is that you can't change the camera device. It's missing in the current version of Qt, but it should be supported in the future. In the meantime, the only solution to this is to write a C++ plugin while<a id="id217" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the main part is still written in QML. Since developing a C++ plugin for QML will be covered in a later chapter, we'll simply skip this part here.</p><p class="calibre9">We can make the file dialog in QML in an even more elegant way. Qt Quick provides commonly-used dialogs through the <code class="literal">QtQuick.Dialogs</code> module. Therefore, first import this module:</p><div><pre class="programlisting">import QtQuick.Dialogs 1.2</pre></div><p class="calibre9">What're we interested in is the <code class="literal">FileDialog</code> type, which provides a basic file chooser. It allows the user to select existing files and/or directories, or create new filenames. It uses the native platform file dialogs wherever possible. To use this type, add <code class="literal">FileDialog</code> inside <code class="literal">ApplicationWindow</code> in the <code class="literal">main.qml</code> file.</p><div><pre class="programlisting">FileDialog {
  id: saveDlg
  property string location

  title: "Save Photo As"
  selectExisting: false
  nameFilters: [ "JPEG (*.jpg)" ]
  onAccepted: {
    location = saveDlg.fileUrl
    camera.imageCapture.captureToLocation(location.slice(8))
  }
}</pre></div><p class="calibre9">The <code class="literal">string</code> type in QML is an extended version of the JavaScript <code class="literal">string</code> type. Wherever possible, you should avoid the <code class="literal">var</code> keyword and use the exact type, such as <code class="literal">int</code>, <code class="literal">double</code>, and <code class="literal">string</code>. According to the QML documentation, this will improve performance since the machine doesn't need to guess the data type. Here, we declare <code class="literal">location</code>, which is a <code class="literal">string</code> type, while the rest of its properties are similar to the dialog settings in Qt/C++, its <code class="literal">title</code> (caption), and <code class="literal">nameFilters</code>. You should set the <code class="literal">selectExisting</code> property to <code class="literal">false</code>, as it is <code class="literal">true</code> by default. Otherwise, it'll behave like an open file dialog.</p><p class="calibre9">Inside the <code class="literal">onAccepted</code> handler, pass the <code class="literal">fileUrl</code> value to <code class="literal">location</code> first. This handler is the response to the <code class="literal">accepted</code> signal, which is emitted if the user selects a file successfully. The <code class="literal">fileUrl</code> property will then be changed. It's in a URI format, which has an extra <code class="literal">file:///</code> prefix. In addition to this, there is currently an issue if we execute <code class="literal">slice</code> on <code class="literal">fileUrl</code> directly. So as a workaround, we use the explicitly declared <code class="literal">string location</code> to invoke the <a id="id218" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">slice</code> function. This is a JavaScript function, which will return a new <code class="literal">string</code> type that contains the extracted parts of a string. The <code class="literal">slice</code> method's prototype is <code class="literal">slice(start,end)</code> where <code class="literal">end</code> will be the end of the <code class="literal">string</code> type if it's omitted. Also, note that the character at the <code class="literal">start</code> position is included and the index starts from zero. After that, we simply call the <code class="literal">captureToLocation</code> function of <code class="literal">imageCapture</code> to store the image at the selected location.</p><p class="calibre9">In order to<a id="id219" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> make it work, we have to change the behavior of <code class="literal">CaptureButton</code>. Edit the <code class="literal">CaptureButton.qml</code> file and change <code class="literal">MouseArea</code>, as shown in the following lines:</p><div><pre class="programlisting">MouseArea {
  anchors.fill: parent
  onClicked: saveDlg.open()
  onPressed: parent.color = "black"
  onReleased: parent.color = "blue"
}</pre></div><p class="calibre9">In addition to this, to change the <code class="literal">onClicked</code> handler, we also add <code class="literal">onPressed</code> and <code class="literal">onReleased</code> to let it have the push effect. As you can see, the <code class="literal">open()</code> function will execute our <code class="literal">FileDialog</code>. On a desktop operating system, such as Windows, the platform file dialog is used as shown here:</p><div><img src="img/4615OS_04_09.jpg" alt="QML camera" class="calibre53"/></div><p class="calibre9">The inner <a id="id220" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>circle of <code class="literal">CaptureButton</code> will become black once it's pressed, and then go back to blue when the mouse is released. Although it's just a minor visual effect, it definitely improves the user experience.</p><div><blockquote class="blockquote"><p class="calibre17"><em class="calibre14">"Do not fail to commit an act of kindness just because it is small in scale."</em></p></blockquote></div><p class="calibre9">To complete this QML camera application, we need to add a zoom control as we did for the Qt/C++ camera. Add a new QML file named <code class="literal">ZoomControl.qml</code>, whose content is shown as follows:</p><div><pre class="programlisting">import QtQuick 2.3

Item {
  property real zoom: camera.opticalZoom * camera.digitalZoom

  function zoomControl() {
    if (zoom &gt; camera.maximumOpticalZoom) {
      camera.digitalZoom = zoom / camera.maximumOpticalZoom
      camera.opticalZoom = camera.maximumOpticalZoom
    }
    else {
      camera.digitalZoom = 1.0
      camera.opticalZoom = zoom
    }
  }

  Text {
    id: indicator
    anchors.fill: parent
    horizontalAlignment: Text.AlignHCenter
    verticalAlignment: Text.AlignVCenter
    color: "darkgrey"
    font.bold: true
    font.family: "Segoe"
    font.pointSize: 20
    style: Text.Raised
    styleColor: "black"
  }

  Timer {
    id: indicatorTimer
    interval: 2000
    onTriggered: indicator.visible = false
  }

  MouseArea {
    anchors.fill: parent
    onWheel: {
      if (wheel.angleDelta.y &gt; 0) {
        zoom += 1.0
        if (zoom &gt; camera.maximumOpticalZoom * camera.maximumOpticalZoom) {
          zoom -= 1.0
        }
        else {
          zoomControl()
        }
      }
      else {
        zoom -= 1.0
        if (zoom &lt; camera.maximumOpticalZoom * camera.maximumOpticalZoom) {
          zoom += 1.0
        }
        else {
          zoomControl()
        }
      }
      indicator.text = "X " + zoom.toString()
      indicator.visible = true
      indicatorTimer.running = true
    }
  }
}</pre></div><p class="calibre9">First, we declare <code class="literal">property</code> of the <code class="literal">real</code> type to store the current zoom, whose initial value is the<a id="id221" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> camera's current zoom, which is itself the multiplication of the current digital and optical zoom. This is followed by a JavaScript-style function, <code class="literal">zoomControl</code>. As mentioned before, you can use JavaScript in QML anywhere seamlessly. This function is identical to the Qt/C++ slot, <code class="literal">onZoomChanged</code>, in the previous topic.</p><p class="calibre9">Then, there is a <code class="literal">Text</code> element used to display the current <code class="literal">zoom</code> function on screen. These are just some visual customizations inside the <code class="literal">Text</code> element, which include centering in the parent by setting both the horizontal and vertical alignments.</p><p class="calibre9">What's next is a <code class="literal">Timer</code> element that controls the visibility of <code class="literal">Text</code>, similar to the controller of <code class="literal">photoPreview</code>.</p><p class="calibre9">The last but also the trickiest is <code class="literal">MouseArea</code>. We use the mouse wheel to control the zoom, so the handler that can get the wheel event is <code class="literal">onWheel</code>. The <code class="literal">wheel.angleDelta.y</code> is the wheel, which is rotated to a vertical orientation. If it's positive, it goes up; otherwise, it goes down. It zooms in with a positive value, and zooms out with negative one. You have to ensure that the new zoom is within the supported zoom range of <code class="literal">camera</code> before invoking the <code class="literal">zoomControl</code> function. After this, let the <code class="literal">Text</code> indicator display <code class="literal">zoom</code> and turn on <code class="literal">Timer</code> so that it's only visible for 2 seconds. You can also see that there is a built-in function for the <code class="literal">real</code> element to convert it to <code class="literal">string</code>, just like the <code class="literal">QString::number</code> function in Qt/C++.</p><p class="calibre9">After all this, edit <code class="literal">main.qml</code> and add <code class="literal">ZoomControl</code> to the application, as shown in the following code:</p><div><pre class="programlisting">ZoomControl {
  anchors.fill: viewfinder
}</pre></div><p class="calibre9">Be aware that <code class="literal">ZoomControl</code> should fill in <code class="literal">viewfinder</code> instead of <code class="literal">parent</code>; otherwise, it may get overlaid by other components, such as <code class="literal">viewfinder</code>.</p><p class="calibre9">Give this QML camera a test run and compare which one is better.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch04lvl1sec35" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">By the end of this chapter, you should be able to write applications that can access camera devices in either Qt/C++ or QML. What's more is that you should be able to utilize the status and menu bar in traditional desktop applications, which are historically important and continue to play a crucial role as interactive functional widgets. In addition to this, don't forget the file dialog and message box since they make your coding work easier. In the next chapter, we're going to talk about an advanced topic, plugins, which is a popular way to extend large applications.</p></div></div>



  </body></html>