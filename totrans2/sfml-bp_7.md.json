["```cpp\nclass Animation\n{\n  public:\n  Animation(sf::Texture* texture=nullptr);\n  ~Animation();\n\n  void setTexture(sf::Texture* texture);\n  sf::Texture* getTexture()const;\n\n  Animation& addFrame(const sf::IntRect& rect);\n  Animation& addFramesLine(int number_x,int number_y,int line);\n  Animation& addFramesColumn(int number_x,int number_y,int column);\n  size_t size()const;\n  const sf::IntRect& getRect(size_t index)const;\n\n  private:\n  friend class AnimatedSprite;\n  std::vector<sf::IntRect> _frames;\n  sf::Texture* _texture;\n};\n```", "```cpp\nAnimation::Animation(sf::Texture* texture) : _texture(texture){}\n\nAnimation::~Animation(){}\n\nvoid Animation::setTexture(sf::Texture* texture){ _texture = \n  texture;}\n\nsf::Texture* Animation::getTexture() const {return _texture;}\n\nsize_t Animation::size() const {return _frames.size();}\n\nconst sf::IntRect& Animation::getRect(size_t index) const {return \n  _frames[index];}\n\nAnimation& Animation::addFrame(const sf::IntRect& rect)\n{\n  _frames.emplace_back(rect);\n  return *this;\n}\n\nAnimation& Animation::addFramesLine(int number_x,int number_y,int \n  line)\n{\n  const sf::Vector2u size = _texture->getSize();\n  const float delta_x = size.x / float(number_x);\n  const float delta_y = size.y / float(number_y);\n\n  for(int i = 0;i<number_x;++i)\n      addFrame(sf::IntRect(i*delta_x,line*delta_y,delta_x,delta_y));\n  return *this;\n}\nAnimation& Animation::addFramesColumn(int number_x,int \n  number_y,int column)\n{\n  const sf::Vector2u size = _texture->getSize();\n  const float delta_x = size.x / float(number_x);\n  const float delta_y = size.y / float(number_y);\n  for(int i = 0;i<number_y;++i)\n      addFrame(sf::IntRect(column*delta_x,i*delta_y,delta_x,delta_y));\n  return *this;\n}\n```", "```cpp\nclass AnimatedSprite : public sf::Drawable, public sf::Transformable\n{\n  public:\n  AnimatedSprite(const AnimatedSprite&) = default;\n  AnimatedSprite& operator=(const AnimatedSprite&) = default;\n  AnimatedSprite(AnimatedSprite&&) = default;\n  AnimatedSprite& operator=(AnimatedSprite&&) = default;\n\n  using FuncType = std::function<void()>;\n  static FuncType defaultFunc;\n  FuncType onFinished;\n  enum Status {Stopped,Paused,Playing};\n\n  AnimatedSprite(Animation* animation = nullptr,Status status= Playing,const sf::Time& deltaTime = sf::seconds(0.15),bool loop = true,int repeat=0);\n\n  void setAnimation(Animation* animation);\n  Animation* getAnimation()const;\n\n  void setFrameTime(sf::Time deltaTime);\n  sf::Time getFrameTime()const;\n\n  void setLoop(bool loop);\n  bool getLoop()const;\n  void setRepeat(int nb);\n  int getRepeat()const;\n\n  void play();\n  void pause();\n  void stop();\n  Status getStatus()const;\n\n  void setFrame(size_t index);\n  void setColor(const sf::Color& color);\n  void update(const sf::Time& deltaTime);\n\n  private:\n  Animation* _animation;\n  sf::Time _delta;\n  sf::Time _elapsed;\n  bool _loop;\n  int _repeat;\n  Status _status;\n  size_t _currentFrame;\n  sf::Vertex _vertices[4];\n\n  void setFrame(size_t index,bool resetTime);\n  virtual void draw(sf::RenderTarget& target,sf::RenderStates states) const override;\n};\n```", "```cpp\nAnimatedSprite::AnimatedSprite(Animation* animation,Status status,const sf::Time& deltaTime,bool loop,int repeat) : onFinished(defaultFunc),_delta(deltaTime),_loop(loop), _repeat(repeat),_status(status)\n{\n  setAnimation(animation); \n}\n```", "```cpp\nvoid AnimatedSprite::setAnimation(Animation* animation)\n{\n  if(_animation != animation){\n    _animation = animation;\n    _elapsed = sf::Time::Zero;\n    _currentFrame = 0;\n    setFrame(0,true);\n  }\n}\n```", "```cpp\nAnimation* AnimatedSprite::getAnimation()const {return _animation;}\n\nvoid AnimatedSprite::setFrameTime(sf::Time deltaTime){_delta = deltaTime;}\n\nsf::Time AnimatedSprite::getFrameTime()const {return _delta;}\n\nvoid AnimatedSprite::setLoop(bool loop){_loop = loop;}\n\nbool AnimatedSprite::getLoop()const {  return _loop;}\n\nvoid AnimatedSprite::setRepeate(int nb) {_repeat = nb;}\n\nint AnimatedSprite::getRepeate()const{  return _repeat;}\n\nvoid AnimatedSprite::play() {_status = Playing;}\n\nvoid AnimatedSprite::pause() {_status = Paused;}\n\nvoid AnimatedSprite::stop()\n{\n  _status = Stopped;\n  _currentFrame = 0;\n  setFrame(0,true);\n}\n\nAnimatedSprite::Status AnimatedSprite::getStatus()const {return _status;}\n```", "```cpp\nvoid AnimatedSprite::setFrame(size_t index)\n{\n  assert(_animation);\n  _currentFrame = index % _animation->size();\n  setFrame(_currentFrame,true);\n}\n```", "```cpp\nvoid AnimatedSprite::setColor(const sf::Color& color)\n{\n  _vertices[0].color = color;\n  _vertices[1].color = color;\n  _vertices[2].color = color;\n  _vertices[3].color = color;\n}\n```", "```cpp\nvoid AnimatedSprite::update(const sf::Time& deltaTime)\n{\n  if(_status == Playing and _animation)\n  {\n    _elapsed += deltaTime;\n\n    if(_elapsed > _delta)\n    {//need to change frame\n      _elapsed -= _delta;\n      if(_currentFrame + 1 < _animation->size())\n          ++_currentFrame;\n      else\n      {//end of frame list\n        _currentFrame = 0;\n\n        if(not _loop)\n        {//can we make another loop an the frames?\n          --_repeat;\n          if(_repeat<=0)\n          { //no, so we stop\n                _status = Stopped;\n                onFinished();\n          }\n        }\n      }\n    }\n    //update the frame\n    setFrame(_currentFrame,false);\n  }\n}\n```", "```cpp\nvoid AnimatedSprite::setFrame(size_t index,bool resetTime)\n{\n  if(_animation)\n  {\n    sf::IntRect rect = _animation->getRect(index);\n    //update vertice position\n    _vertices[0].position = sf::Vector2f(0.f, 0.f);\n    _vertices[1].position = sf::Vector2f(0.f, static_cast<float>(rect.height));\n    _vertices[2].position = sf::Vector2f(static_cast<float>(rect.width), static_cast<float>(rect.height));\n    _vertices[3].position = sf::Vector2f(static_cast<float>(rect.width), 0.f);\n\n    //compute the texture coords\n    float left = static_cast<float>(rect.left);\n    float right = left + static_cast<float>(rect.width);\n    float top = static_cast<float>(rect.top);\n    float bottom = top + static_cast<float>(rect.height);\n\n    //set the texture coords\n    _vertices[0].texCoords = sf::Vector2f(left, top);\n    _vertices[1].texCoords = sf::Vector2f(left, bottom);\n    _vertices[2].texCoords = sf::Vector2f(right, bottom);\n    _vertices[3].texCoords = sf::Vector2f(right, top);\n  }\n  if(resetTime)\n  _elapsed = sf::Time::Zero;\n}\n```", "```cpp\nvoid AnimatedSprite::draw(sf::RenderTarget& target,sf::RenderStates states) const\n{\n  if (_animation and _animation->_texture)è\n  {\n    states.transform *= getTransform();\n    states.texture = _animation->_texture;\n    target.draw(_vertices, 4, sf::Quads, states);\n  }\n}\n```", "```cpp\nint main(int argc,char* argv[])\n{\n  //Creation of the window\n  sf::RenderWindow window(sf::VideoMode(600,800),\"Example \n    animation\");\n\n  //load of the texture image\n  ResourceManager<sf::Texture,int> textures;\n  textures.load(0,\"media/img/eye.png\");\n\n  //Creation of the different animations\n  Animation walkLeft(&textures.get(0));\n  walkLeft.addFramesLine(4,2,0);\n  Animation walkRight(&textures.get(0));\n  walkRight.addFramesLine(4,2,1);\n\n  //Creation of the animates sprite\n  AnimatedSprite sprite(&walkLeft,AnimatedSprite::Playing,sf::seconds(0.1));\n  //game loop\n  sf::Clock clock;\n  while (window.isOpen())\n  {\n    sf::Time delta = clock.restart();\n    sf::Event event;\n    while (window.pollEvent(event))\n    {\n      if (event.type == sf::Event::Closed) //close event\n      window.close();\n    }\n    float speed = 50; // the movement speed of the entity\n    if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) //move left\n    {\n      sprite.setAnimation(&walkLeft);\n      sprite.play();\n      sprite.move(-speed*delta.asSeconds(),0);\n    }\n    else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) \n      //move right     {\n      sprite.setAnimation(&walkRight);\n      sprite.play();\n      sprite.move(speed*delta.asSeconds(),0);\n    }\n    window.clear();\n    sprite.update(delta); //update the animate sprite for possible \n      frame change\n    window.draw(sprite); //display the animation\n    window.display();\n  }\n  return 0;\n}\n```", "```cpp\n    shape.setPointCount(6);\n    shape.setPoint(0,sf::Vector2f(0,(sin_15+sin_75)/2));\n    shape.setPoint(1,sf::Vector2f(sin_15,sin_15/2));\n    shape.setPoint(2,sf::Vector2f(sin_15+sin_75,0));\n    shape.setPoint(3,sf::Vector2f(sin_15+sin_75+sin_45,sin_45/2));\n    shape.setPoint(4,sf::Vector2f(sin_75+sin_45,(sin_75+sin_45)/2));\n    shape.setPoint(5,sf::Vector2f(sin_45,(sin_15+sin_75+sin_45)/2));\n    shape.setOrigin(height/2,height/4);\n    ```", "```cpp\ntemplate<typename CONTENT>\nclass Layer : public VLayer\n{\n  public:\n  Layer(const Layer&) = delete;\n  Layer& operator=(const Layer&) = delete;\n  Layer(const std::string& type,int z=0,bool isStatic=false);\n  virtual ~Layer(){};\n\n  CONTENT* add(const CONTENT& content,bool resort=true);\n  std::list<CONTENT*> getByCoords(const sf::Vector2i& coords,const VMap& map);\n  bool remove(const CONTENT* content_ptr,bool resort=true);\n  virtual void sort() override;\n\n  private:\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates states,const sf::FloatRect& viewport) override;\n  std::list<CONTENT> _content;\n};\n```", "```cpp\ntemplate<typename CONTENT>\nLayer<CONTENT>::Layer(const std::string& type,int z,bool isStatic) \n  : Vlayer(type,z,isStatic) {}\n\ntemplate<typename CONTENT>\nCONTENT* Layer<CONTENT>::add(const CONTENT& content,bool resort)\n{\n  _content.emplace_back(content);\n  CONTENT* res = &_content.back();\n  if(resort)\n      sort();\n  return res;\n}\n```", "```cpp\ntemplate<typename CONTENT>\nstd::list<CONTENT*> Layer<CONTENT>::getByCoords(const sf::Vector2i& coords,const VMap& map)\n{\n  std::list<CONTENT*> res;\n  const auto end = _content.end();\n  for(auto it = _content.begin();it != end;++it)\n  {\n    auto pos = it->getPosition();\n    sf::Vector2i c = map.mapPixelToCoords(pos.x,pos.y);\n    if(c == coords)\n        res.emplace_back(&(*it));\n  }\n  return res;\n}\n```", "```cpp\ntemplate<typename CONTENT>\nbool Layer<CONTENT>::remove(const CONTENT* content_ptr,bool resort)\n{\n  auto it = std::find_if(_content.begin(),_content.end(),[content_ptr](const CONTENT& content)->bool\n  {\n    return &content == content_ptr;\n  });\n  if(it != _content.end()) {\n    _content.erase(it);\n    if(resort)\n    sort();\n    return true;\n  }\n  return false;\n}\n```", "```cpp\ntemplate<typename CONTENT>\nvoid Layer<CONTENT>::sort()\n{\n  _content.sort([](const CONTENT& a,const CONTENT& b)->bool{\n    auto pos_a = a.getPosition();\n    auto pos_b = b.getPosition();\n    return (pos_a.y < pos_b.y) or (pos_a.y == pos_b.y and pos_a.x < pos_b.x);\n    });\n  }\n}\n```", "```cpp\ntemplate<typename CONTENT>\nvoid Layer<CONTENT>::draw(sf::RenderTarget& target, sf::RenderStates states,const sf::FloatRect& viewport)\n{\n  if(_isStatic)\n  {//a static layer\n    if(_lastViewport != viewport)\n    { //the view has change\n      sf::Vector2u size(viewport.width+0.5,viewport.height+0.5);\n      if(_renderTexture.getSize() != size)\n      {//the zoom has change\n        _renderTexture.create(size.x,size.y);\n        _sprite.setTexture(_renderTexture.getTexture(),true);\n      }\n      _renderTexture.setView(sf::View(viewport));\n      _renderTexture.clear();\n\n      auto end = _content.end();\n      for(auto it = _content.begin();it != end;++it)\n      {//loop on content\n      CONTENT& content = *it;\n      auto pos = content.getPosition();\n      if(viewport.contains(pos.x,pos.y))\n      {//content is visible on screen, so draw it\n        _renderTexture.draw(content);\n      }\n    }\n    _renderTexture.display();\n    _lastViewport = viewport;\n    _sprite.setPosition(viewport.left,viewport.top);\n  }\n  target.draw(_sprite,states);\n}\nelse\n{ //dynamic layer\n  auto end = _content.end();\n  for(auto it = _content.begin();it != end;++it)\n  {//loop on content\n    const CONTENT& content = *it;\n    auto pos = content.getPosition();\n    if(viewport.contains(pos.x,pos.y))\n    {//content is visible on screen, so draw it\n      target.draw(content,states);\n    }\n  }\n}\n```", "```cpp\nstd::vector<VLayer*> _layers;\n```", "```cpp\nvoid VMap::sortLayers()\n{\n  std::sort(_layers.begin(),_layers.end(),[](const VLayer* a, const VLayer* b)->bool{\n    return a->z() < b->z();\n  });\n  const size_t size = _layers.size();\n  for(size_t i=0;i<size;++i)\n    _layers[i]->sort();\n}\n```", "```cpp\nvoid VMap::draw(sf::RenderTarget& target, sf::RenderStates states,const sf::FloatRect& viewport) const\n{\n  sf::FloatRect delta_viewport(viewport.left - _tile_size,\n  viewport.top - _tile_size,\n  viewport.width + _tile_size*2,\n  viewport.height + _tile_size*2);\n  const size_t size = _layers.size();\n  for(size_t i=0;i<size;++i)\n    _layers[i]->draw(target,states,delta_viewport);\n}\n```", "```cpp\n{\n  \"geometry\" : {\n    \"name\" :\"HexaIso\", \"size\" : 50.0\n  },\n  \"layers\" : [{\n    \"content\" : \"tile\", \"z\" : 1, \"static\" : true,\n    \"data\" : [{\"img\" :\"media/img/ground.png\", \"x\" : 0, \"y\" : 0, \"width\" : 100, \"height\" : 100}]\n  },{\n    \"content\" : \"sprite\", \"z\" : 3,\n    \"data\" : [\n    {\"x\" : 44, \"y\" : 49, \"img\" : \"media/img/tree/bush4.png\"},\n    {\"x\" : 7, \"y\" : 91, \"img\" : \"media/img/tree/tree3.png\"},\n    {\"x\" : 65, \"y\" : 58, \"img\" : \"media/img/tree/tree1.png\"}\n    ]\n  }]\n}\n```", "```cpp\nstatic VMap* createMapFromFile(const std::string& filename);\nvirtual void loadFromJson(const utils::json::Object& root) = 0;\n```", "```cpp\nVMap* VMap::createMapFromFile(const std::string& filename)\n{\n  VMap* res = nullptr;\n  utils::json::Value* value = utils::json::Driver::parse_file(filename);\n  if(value)\n  {\n    utils::json::Object& root = *value;\n    utils::json::Object& geometry = root[\"geometry\"];\n    std::string geometry_name = geometry[\"name\"].as_string();\n    float size = geometry[\"size\"].as_float();\n    if(geometry_name == \"HexaIso\")\n    {\n      res = new Map<geometry::HexaIso>(size);\n      res->loadFromJson(root);\n    }\n    delete value;\n  }\n  return res;\n}\n```", "```cpp\nvoid Map<GEOMETRY>::loadFromJson(const utils::json::Object& root)\n{\n    const utils::json::Array& layers = root[\"layers\"];\n    for(const utils::json::Value& value : layers) //loop through the \nrs\n    {\n        const utils::json::Object& layer = value;\n        std::string content = layer[\"content\"].as_string(); //get the content type\n\n        int z = 0; //default value\n        try{\n            z = layer[\"z\"].as_int(); //load value\n        } catch(...){}\n\n        bool isStatic = false; //default value\n        try {\n            isStatic = layer[\"static\"].as_bool(); //load value\n        }catch(...){}\n\n        if(content == \"tile\") //is a layer or tile?\n        {\n            auto current_layer = new Layer<Tile<GEOMETRY>>(content,z,isStatic); //create the layer\n            const utils::json::Array& textures = layer[\"data\"];\n            for(const utils::json::Object& texture : textures) //loop through the textures\n            {\n                int tex_x = texture[\"x\"]; //get the tile position\n                int tex_y = texture[\"y\"];\n                int height = std::max<int>(0,texture[\"height\"].as_int()); //get the square size\n                int width = std::max<int>(0,texture[\"width\"].as_int());\n                std::string img = texture[\"img\"]; //get texture path\n\n                sf::Texture& tex = _textures.getOrLoad(img,img); //load the texture\n                tex.setRepeated(true);\n\n                for(int y=tex_y;y< tex_y + height;++y)//create the tiles\n                {\n                    for(int x=tex_x;x<tex_x + width;++x)\n                    {\n                        Tile<GEOMETRY> tile(x,y,_tileSize);\n                        tile.setTexture(&tex);\n                        tile.setTextureRect(GEOMETRY::getTextureRect(x,y,_tileSize));\n\n                        current_layer->add(std::move(tile),false);//add the new tile to the layer\n                    }\n                }\n            }\n            add(current_layer,false);//if it's a layer of images\n        }\n        else if(content == \"sprite\")\n        {\n            auto current_layer = new Layer<sf::Sprite>(content,z,isStatic);//create the layer\n            const utils::json::Array& data = layer[\"data\"].as_array();//loop on data\n\n            for(const utils::json::Value& value : data)\n            {\n                const utils::json::Object& obj = value;\n                int x = obj[\"x\"];//get the position\n                int y = obj[\"y\"];\n                float ox = 0.5;//default center value (bottom center)\n                float oy = 1;\n\n                try{//get value\n                    ox = obj[\"ox\"].as_float();\n                }catch(...){}\n\n                try{\n                    oy = obj[\"oy\"].as_float();\n                }catch(...){}\n\n                std::string img = obj[\"img\"];//get texture path\n\n                sf::Sprite spr(_textures.getOrLoad(img,img));//load texture\n                spr.setPosition(GEOMETRY::mapCoordsToPixel(x,y,_tileSize));\n\n                sf::FloatRect rec = spr.getLocalBounds();\n                spr.setOrigin(rec.width*ox,rec.height*oy);\n\n                current_layer->add(std::move(spr),false);//add the sprite\n\n            }\n            add(current_layer,false); //add the new layer to the map\n        }\n    }\n    sortLayers(); //finally sort the layers (recuively)\n}\n```", "```cpp\nvoid MapViewer::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  sf::View view = target.getView();\n  target.setView(_view);\n  _map.draw(target,states,sf::FloatRect(target.mapPixelToCoords(sf::Vector2i(0,0),_view),_view.getSize());\n  target.setView(view);\n}\n```", "```cpp\nint main(int argc,char* argv[])\n{\n  sf::RenderWindow window(sf::VideoMode(1600,900),\"Example Tile\");\n  sfutils::VMap* map = sfutils::VMap::createMapFromFile(\"./map.json\");\n  sfutils::MapViewer viewer(window,*map);\n  sf::Clock clock;\n  while (window.isOpen())\n  {\n    sf::Event event;\n    while (window.pollEvent(event))\n    {\n      if (event.type == sf::Event::Closed)   // Close window : exit\n      window.close();\n    }\n    window.clear();\n    viewer.processEvents();\n    viewer.update(clock.restart().asSeconds());\n    viewer.draw();\n    window.display();\n  }\n  return 0;\n}\n```", "```cpp\nstruct CompHp : Component<CompHp>\n{\n  explicit Hp(int hp) : _hp(hp){};\n  int _hp;\n};\n```", "```cpp\nstruct SysHp : sfutils::System<SysHp>\n{\n  virtual void update(sfutils::EntityManager& manager,const sf::Time& dt) override;\n};\n```", "```cpp\nEntityManager entities;\nstd::uint32_t id = entities.create();\nentities.addComponent<CompHp>(id,42); //the first argument is always the entity id\n```", "```cpp\nvoid SysHp::update(sfutils::EntityManager& manager,const sf::Time& dt)\n{\n  CompHp::Handle hp; //Handler is a kind of smart pointer which ensure access to valid data\n  auto view = manager.getByComponents(hp); //this object is a filter on all our entities by there components\n  auto end = view.end();\n  for(auto current = view.begin(); current != end;++current)\n  {\n    if(hp->_hp <= 0)\n    manager.remove(current->id());\n  }\n}\n```", "```cpp\nmanager.getComponent<CompHp>(current->id())\n```", "```cpp\nEntityManager entities;\nSystemManager systems(entities);\nsystems.add<SysHp>();\n```", "```cpp\nint main()\n{\n  EntityManager entities;\n  SystemManager systems(entities);\n  systems.add<SysHp>();\n\n  for(int i =0; i<10; ++i)\n  {//create entities\n    std::uint32_t id = entities.create();\n    entities.addComponent<CompHp>(id,i*10);\n  }\n  sf::Clock clock;\n  while(/* some criterion*/)\n  {//game loop\n    systems.updateAll(clock.restart());\n    entities.update();\n  }\n  return 0;\n}\n```", "```cpp\nstruct CompAIWalker : Component<CompAIWalker>\n{\n  explicit CompAIWalker(float speed);\n  const float _speed;\n  sf::Vector2i _pathToTake;\n};\n```", "```cpp\nstruct CompAIWarrior : Component<CompAIWarrior>\n{\n  explicit CompAIWarrior(int hitPoint,const sf::Time& timeDelta,int range);\n  const int _hitPoint;\n  const sf::Time _delta;\n  sf::Time _elapsed;\n  const int _range;\n};\n```", "```cpp\nstruct CompSkin : sfutils::Component<CompSkin,Entity>\n{\n  enum AnimationId : int{ Stand,Spawn, MoveLeft, MoveRight, HitLeft, HitRight};\n  sfutils::AnimatedSprite _sprite;\n  std::unordered_map<int,sfutils::Animation*> _animations;\n};\n```", "```cpp\nstruct SysAIWalker : sfutils::System<SysAIWalker,Entity>\n{\n  explicit SysAIWalker(Level& level);\n  virtual void update(sfutils::EntityManager<Entity>& manager,const sf::Time& dt) override;\n  Level& _level;\n};\n```", "```cpp\nSysAIWalker::SysAIWalker(Level& level) :_level(level) {}\nvoid SysAIWalker::update(EntityManager& manager,const sf::Time& \n  dt)\n{\n  CompAIWalker::Handle AI;\n  CompSkin::Handle skin;\n  auto view = manager.getByComponents(AI,skin);\n  auto end = view.end();\n  const float seconds = dt.asSeconds();\n\n  for(auto begin = view.begin();begin != end;++begin)\n  {\n    sf::Vector2f PosCurrent = skin->_sprite.getPosition();\n    sf::Vector2i CoordCurrent = \n      _level.mapPixelToCoords(PosCurrent);\n    sf::Vector2i CoordDest = AI->_pathToTake;\n    if(CoordDest != CoordCurrent) //need to move\n    {\n      sf::Vector2f PosDest = _level.mapCoordsToPixel(CoordDest);\n      //calculation of the direction to take\n      sf::Vector2f directon = PosDest - PosCurrent;\n      //calculation of the distance\n      const float distance = \n        std::sqrt((directon.x*directon.x)+(directon.y*directon.y));\n      const float frameDistance = AI->_speed * seconds;\n      if(distance > frameDistance)\n          skin->_sprite.setPosition(PosCurrent + \n        directon*(frameDistance/distance));\n      else\n      {\n        skin->_sprite.setPosition(PosDest);\n        AI->_pathToTake = CoordCurrent;\n      }\n\n      if(directon.x >0) //update skin direction\n          skin->_sprite.setAnimation(skin-\n        >_animations.at(CompSkin::MoveRight));\n      else\n          skin->_sprite.setAnimation(skin-\n        >_animations.at(CompSkin::MoveLeft));\n    }\n  }\n}\n```", "```cpp\nSysAIWarrior::SysAIWarrior(Level& level) : _level(level){}\nvoid SysAIWarrior::update(sfutils::EntityManager<Entity>& manager,const sf::Time& dt)\n{\n  CompAIWarrior::Handle AI;\n  CompTeam::Handle team;\n  CompSkin::Handle skin;\n  auto view = manager.getByComponents(AI,team,skin);\n  auto end = view.end();\n  for(auto begin = view.begin();begin != end;++begin)\n  {\n    AI->_elapsed += dt;\n    std::vector<Team*> teamEnemies = team->_team->getEnemies();\n\n    //if no enemies\n    if(teamEnemies.size() <=0)\n        continue;\n    std::uint32_t id = std::uint32_t(-1);\n\n    /* ….set id to the nearest enemy ... */\n\n    if(not manager.isValid(id))\n        continue;\n\n    //update path\n    Entity& enemy = manager.get(id);\n    const sf::Vector2f pos = enemy.component<CompSkin>()->_sprite.getPosition();\n    const sf::Vector2i coord = _level.mapPixelToCoords(pos);\n    const int distance = _level.getDistance(myPosition,coord);\n    if(distance <= range) //next me\n    {\n      //shoot it\n      if(AI->_elapsed >= AI->_delta)\n      {\n        AI->_elapsed = sf::Time::Zero;\n        CompHp::Handle hp = enemy.component<CompHp>();\n        hp->_hp -= AI->_hitPoint;\n        Entity& me = **begin;\n        if(enemy.onHitted != nullptr)\n        enemy.onHitted(enemy,coord,me,myPosition,_level);\n        if(me.onHit != nullptr)\n        me.onHit(me,myPosition,enemy,coord,_level);\n        //win some gold\n        if(hp->_hp <=0){\n            team->_team->addGold(hp->_maxHp/50);\n        }\n      }\n\n      //no need to move more\n      if(begin->has<CompAIWalker>())\n      begin->component<CompAIWalker>()->_pathToTake = myPosition;\n    }\n    else\n    {//too far\n        sf::Vector2i path = _level.getPath1(myPosition,coord);\n        //move closer\n        if(begin->has<CompAIWalker>())\n            begin->component<CompAIWalker>()->_pathToTake = path;\n  }\n}\n```"]