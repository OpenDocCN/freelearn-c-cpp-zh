<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. On the Level – Eskimo</h1></div></div></div><p class="calibre6">
<em class="calibre8">In our next game, we'll go over some important features most games require, but which are not directly related to gameplay. So we'll step over the architecture side of things and talk about reading and writing data, using scene transitions, and creating custom events that your whole application can listen to.</em>
</p><p class="calibre6">
<em class="calibre8">But, of course, I'll add a few gameplay ideas as well!</em>
</p><p class="calibre6">This time, you'll learn how to:</p><div><ul class="itemizedlist"><li class="listitem">Create scene transitions</li><li class="listitem">Load external data</li><li class="listitem">Save data using <code class="email">UserDefault</code></li><li class="listitem">Create your own game events with the dispatcher</li><li class="listitem">Use the accelerometer</li><li class="listitem">Reuse Box2D bodies</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec120" class="calibre1"/>The game – Eskimo</h1></div></div></div><p class="calibre6">Little<a id="id337" class="calibre1"/> Eskimo boy is late for supper. It is your mission, should you choose to accept it, to guide the little fella back to his igloo.</p><p class="calibre6">This is a Box2D game, and the controls are very simple. Tilt the device and the Eskimo will move. If you tap the screen, the Eskimo switches shape between a snow ball and a block of ice, each shape with its own physical characteristics and degrees of maneuverability. The ball has a higher friction, for instance, and the block of ice has none.</p><p class="calibre6">And the only way the Eskimo may reach his destination is by hitting the gravity switches spread out all over the screen.</p><p class="calibre6">Eskimo combines elements from an arcade game with elements of a puzzle game, as each level was planned with one perfect solution in mind as to how to take the little Eskimo home. Note, however, that multiple solutions are possible.</p><div><img src="img/00034.jpeg" alt="The game – Eskimo" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Download<a id="id338" class="calibre1"/> the <code class="email">4198_09_FINAL_PROJECT.zip</code> file and run the game when you have a chance. Once again, there is no need for extraneous typing as the logic used in the game is pretty much old news to you, and we'll go over the new bits in depth.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec115" class="calibre1"/>The game settings</h2></div></div></div><p class="calibre6">This is<a id="id339" class="calibre1"/> a portrait-only game and accelerometer-based, so it should not autorotate. It was designed for the regular iPhone and its screen resolution size is set to <code class="email">kResolutionShowAll</code>, so the screen settings are similar to the ones in our previous game.</p><p class="calibre6">Designing a <a id="id340" class="calibre1"/>game for the iPhone screen and using the <code class="email">kResolutionShowAll</code> parameter will result in the so-called <strong class="calibre7">letterbox</strong> view when playing the game in screens that do not match the iPhone's 1.5 ratio. This means you see borders around the game screen. Alternatively, you could use the <code class="email">kResolutionNoBorders</code> parameter, which<a id="id341" class="calibre1"/> results in a <strong class="calibre7">zoom-in</strong> effect, causing the game to play at full screen but the areas around the borders will be cropped.</p><p class="calibre6">The following screenshot illustrates these two cases:</p><div><img src="img/00035.jpeg" alt="The game settings" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">The one<a id="id342" class="calibre1"/> on the left is the game screen on the iPad, using <code class="email">kResolutionShowAll</code>. The one on the right uses <code class="email">kResolutionNoBorders</code>. Note how the screen is zoomed in and cropped on the second one. When using <code class="email">kResolutionNoBorders</code>, it's important to design your game so that no vital gameplay element appears too close to the borders as it may not be displayed.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec116" class="calibre1"/>Organizing the game</h2></div></div></div><p class="calibre6">Once<a id="id343" class="calibre1"/> again, there is a <code class="email">b2Sprite</code> class, and the <code class="email">Eskimo</code> and <code class="email">Platform</code> classes extend <code class="email">b2Sprite</code>. Then there are the regular <code class="email">Sprite</code> classes, <code class="email">GSwitch</code> (which stands for gravity switch) and <code class="email">Igloo</code>. The logic runs collision detection between these last two and <code class="email">Eskimo</code>, but I chose not to have them as sensor bodies because I wanted to show you that 2D collision logic for the Cocos2d-x elements can coexist with collision logic for the Box2D elements just fine.</p><p class="calibre6">But most importantly, this game now has three scenes. So far in this book, we've only used one scene per game. This game's scene objects will wrap <code class="email">MenuLayer</code>, <code class="email">LevelSelectLayer</code>, and <code class="email">GameLayer</code>. Here's a brief note on all three:</p><div><ul class="itemizedlist"><li class="listitem">In <code class="email">MenuLayer</code>, you<a id="id344" class="calibre1"/> have the option to play the game, which will take you to <code class="email">LevelSelectLayer</code> or to play a tutorial for the game, which will take you to <code class="email">GameLayer</code>.</li><li class="listitem">In <code class="email">LevelSelectLayer</code>, you may choose which available level you want to play, and that will take you to <code class="email">GameLayer</code>. Or you may go back to <code class="email">MenuLayer</code>.</li><li class="listitem">In <code class="email">GameLayer</code>, you play the game, and may go back to <code class="email">MenuLayer</code> upon game over.</li></ul></div><p class="calibre6">The following image illustrates all three scenes in the game:</p><div><img src="img/00036.jpeg" alt="Organizing the game" class="calibre9"/></div><p class="calibre10"> </p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec121" class="calibre1"/>Using scenes in Cocos2d-x</h1></div></div></div><p class="calibre6">Scenes <a id="id345" class="calibre1"/>are mini applications themselves. If you have experience as an Android developer, you may think of scenes as activities. Of all the classes based on node, the <code class="email">Scene</code> application is the most architecturally relevant, because the <code class="email">Director</code> class runs a scene, in effect running your application.</p><p class="calibre6">Part of the benefit of working with scenes is also part of the drawback: they are wholly independent and ignorant of each other. The need to share information between scenes will be a major factor when planning your game class structure.</p><p class="calibre6">Also, memory <a id="id346" class="calibre1"/>management may become an issue. A currently running scene will not give up its ghost until a new scene is up and running. So, when you use transition animations, keep in mind that for a few seconds, both scenes will exist in memory.</p><p class="calibre6">In Eskimo, I initialize scenes in two different ways. With <code class="email">MenuLayer</code> and <code class="email">LevelSelectLayer</code>, each time the user navigates to either one of these scenes, a new layer object is created (either a new <code class="email">MenuLayer</code> or a new <code class="email">LevelSelectLayer</code>).</p><p class="calibre6">
<code class="email">GameLayer</code>, however, is different. It is a singleton <code class="email">Layer</code> class that never stays out of memory after its first instantiation, therefore speeding up the time from level selection to the actual playing. This may not work for every game, however. As I mentioned earlier, when transitioning between scenes, both scenes stay in memory for a few seconds. But here we are adding to that problem by keeping one layer in memory the whole time. Eskimo, however, is not very big memory-wise. Note that we could still have the option of creating special conditions for when <code class="email">GameLayer</code> should be destroyed, and conditions when it should not.</p><p class="calibre6">So let me show you how to create scene transitions. First, with a <code class="email">Scene</code> class that creates a fresh copy of its <code class="email">Layer</code> each time it's created.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec122" class="calibre1"/>Time for action – creating a scene transition</h1></div></div></div><p class="calibre6">You<a id="id347" class="calibre1"/> have, of course, been using scenes all along.</p><div><ol class="orderedlist"><li class="listitem" value="1">Hidden in <code class="email">AppDelegate.cpp</code>, you've had lines like:<div><pre class="programlisting">auto scene = GameLayer::scene();
// run
director-&gt;runWithScene(scene);</pre></div></li><li class="listitem" value="2">So, in order to change scenes, all you need to do is tell the <code class="email">Director</code> class which scene you wish it to run. Cocos2d-x will then get rid of all the content in the current scene, if any (all their destructors will be called), and a new layer will be instantiated and wrapped inside the new <code class="email">Scene</code>.</li><li class="listitem" value="3">Breaking the steps down a little further, this is how you usually create a new scene for <code class="email">Director</code>:<div><pre class="programlisting">Scene* MenuLayer::scene()
{
    // 'scene' is an autorelease object
    auto scene = Scene::create();
    // add layer as a child to scene
    auto layer = new MenuLayer();
    scene-&gt;addChild(layer);
    layer-&gt;release();
    return scene;
}</pre></div></li><li class="listitem" value="4">The <a id="id348" class="calibre1"/>static <code class="email">MenuLayer::scene</code> method will create a blank scene, and then create a new instance of <code class="email">MenuLayer</code> and add it as a child to the new scene.</li><li class="listitem" value="5">Now you can tell <code class="email">Director</code> to run it as follows:<div><pre class="programlisting">Director::getInstance()-&gt;replaceScene(MenuLayer::scene());</pre></div></li><li class="listitem" value="6">The logic changes a little if you wish to use a transition effect. So, inside our <code class="email">MenuLayer.cpp</code> class, this is how we transition to <code class="email">LevelSelectLayer</code>:<div><pre class="programlisting">auto newScene = TransitionMoveInR::create(0.2f,  LevelSelectLayer::scene());
Director::getInstance()-&gt;replaceScene(newScene);</pre></div><p class="calibre13">The code just described creates a new transition object that will slide in the new scene from the right-hand side of the screen to lie on top of the current one. The transition will take <code class="email">0.2</code> seconds.</p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec117" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You created a scene transition animation with Cocos2d-x.</p><p class="calibre6">As I mentioned earlier, this form of scene change will cause a new instance of the new layer to be created each time, and destroyed each time it's replaced by a new scene. So, in our game, <code class="email">MenuLayer</code> and <code class="email">LevelSelectLayer</code> are instantiated and destroyed as many times as the user switches between them.</p><p class="calibre6">There is also the option to use <code class="email">pushScene</code> instead of <code class="email">replaceScene</code>. This creates a stack of <code class="email">scene</code> objects and keeps them all in memory. This stack can be navigated with <code class="email">popScene</code> and <code class="email">popToRootScene</code>.</p><p class="calibre6">Now let me show you how to do the same thing but with a singleton layer.</p><p class="calibre6">It should be no surprise to you by now that you will find many examples of these transition classes in the <code class="email">Tests</code>, project at <code class="email">tests/cpp-tests/Classes/TransitionsTest</code>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec123" class="calibre1"/>Time for action – creating transitions with a singleton Layer class</h1></div></div></div><p class="calibre6">We <a id="id349" class="calibre1"/>first need to make sure the layer in question can only be instantiated once.</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">scene</code> static method in <code class="email">GameLayer</code> looks like this:<div><pre class="programlisting">Scene* GameLayer::scene(int level, int levelsCompleted)
{
    // 'scene' is an autorelease object
    auto scene = Scene::create();
   // add layer as a child to scene
    scene-&gt;addChild(GameLayer::create(level, levelsCompleted));
   return scene;
}</pre></div><p class="calibre13">This layer receives two parameters when created: the game level it should load and the number of levels completed by the player. We create a new <code class="email">Scene</code> object and add <code class="email">GameLayer</code> as its child.</p></li><li class="listitem" value="2">But take a look at the static <code class="email">create</code> method in <code class="email">GameLayer</code>:<div><pre class="programlisting">GameLayer * GameLayer::create (int level, int levelsCompleted) {
    if (!_instance) {
        _instance = new GameLayer();
    } else {
        _instance-&gt;clearLayer();
    }
    _instance-&gt;setLevelsCompleted(levelsCompleted);
    _instance-&gt;loadLevel(level);
    _instance-&gt;scheduleUpdate();
    return _instance;
}</pre></div></li><li class="listitem" value="3">An <code class="email">_instance</code> static property is declared at the top of <code class="email">GameLayer.cpp</code> as follows:<div><pre class="programlisting">static GameLayer* _instance = nullptr;</pre></div><p class="calibre13">We can check, then, if the one instance of <code class="email">GameLayer</code> is currently in memory and instantiate it if necessary.</p></li><li class="listitem" value="4">The scene transition to <code class="email">GameLayer</code> will look, on the surface, to be exactly like the regular kind of transition. So, in <code class="email">LevelSelectLayer</code>, we have the following:<div><pre class="programlisting">auto newScene = TransitionMoveInR::create(0.2f,  GameLayer::scene(_firstIndex + i, _levelsCompleted));
Director::sharedDirector()-&gt;replaceScene(newScene);</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec118" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We have created a <code class="email">Scene</code> transition with a <code class="email">Layer</code> class that never gets destroyed, so we don't have to instantiate new platform and gravity switch sprites with each new level.</p><p class="calibre6">There are, of course, problems and limitations with this process. We cannot transition between the two <code class="email">GameLayer</code> objects, for instance, as we only ever have one of these objects.</p><p class="calibre6">There<a id="id350" class="calibre1"/> are also some special considerations when leaving <code class="email">GameLayer</code> and when getting back to it. For instance, we must make sure we have our main loop running when we get back to <code class="email">GameLayer</code>.</p><p class="calibre6">The only way to do that is by unscheduling it whenever leaving <code class="email">GameLayer</code> and scheduling it again when returning, as follows:</p><div><pre class="programlisting">//when leaving
unscheduleUpdate();
auto newScene = TransitionMoveInL::create(0.2f, MenuLayer::scene());
Director::sharedDirector()-&gt;replaceScene(newScene);

//when returning
_instance-&gt;scheduleUpdate();</pre></div><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre6">Again, architecturally speaking, there are even better options. Possibly the best one is creating your own game elements cache, or game manager, with object pools and everything that needs instantiating stored inside it. And then have this cache be a singleton that every scene can access. This is also the best way to share game-relevant data between scenes.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec124" class="calibre1"/>Loading external data from a .plist file</h1></div></div></div><p class="calibre6">Eskimo<a id="id351" class="calibre1"/> has only five game levels, plus a tutorial level (feel free to add more). The data for these levels exist inside a l<code class="email">evels.plist</code> file, stored inside the <code class="email">Resources</code> folder. A <code class="email">.plist</code> file is an XML-formatted data file, and as such can be created in any text editor. Xcode, however, offers a nice GUI to edit the files.</p><p class="calibre6">Let me show you how to create them inside Xcode.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec125" class="calibre1"/>Time for action – creating a .plist file</h1></div></div></div><p class="calibre6">You <a id="id352" class="calibre1"/>could, of course, create this in any text editor, but Xcode makes it extra easy to create and edit <code class="email">.plist</code> files.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside Xcode, go to <strong class="calibre7">New</strong> | <strong class="calibre7">File...</strong> and then select <strong class="calibre7">Resource</strong> and <strong class="calibre7">Property List</strong>. When asked where to save the file, choose any location you want.<div><img src="img/00037.jpeg" alt="Time for action – creating a .plist file" class="calibre9"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">You <a id="id353" class="calibre1"/>need to decide what the <strong class="calibre7">Root</strong> element of your <code class="email">.plist</code> file will be—either an <strong class="calibre7">Array</strong> or a <strong class="calibre7">Dictionary</strong> (the default) type. For Eskimo, the <strong class="calibre7">Root</strong> element is <strong class="calibre7">Array</strong> containing a series of dictionaries, each holding the data for a level in the game.</li><li class="listitem" value="3">By selecting the <strong class="calibre7">Root</strong> element, you get a plus sign indicator right next to the <strong class="calibre7">Type</strong> declaration. Clicking on this plus sign will add an element to <strong class="calibre7">Root</strong>. You can then pick the data type for this new item. The options are <strong class="calibre7">Boolean</strong>, <strong class="calibre7">Data</strong>, <strong class="calibre7">Date</strong>, <strong class="calibre7">Number</strong>, <strong class="calibre7">String</strong>, and again <strong class="calibre7">Array</strong> and <strong class="calibre7">Dictionary</strong>. The last two can contain subitems in the tree, just like the <strong class="calibre7">Root</strong> element.</li><li class="listitem" value="4">Keep adding elements to the tree, trying to match the items in the following screenshot:<div><img src="img/00038.jpeg" alt="Time for action – creating a .plist file" class="calibre9"/></div><p class="calibre14"> </p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec119" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You just<a id="id354" class="calibre1"/> created a property list file in Xcode. This is XML-structured data that Cocos2d-x can load and parse. You've used them already when loading particles and sprite sheet information.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec126" class="calibre1"/>Loading the level data</h1></div></div></div><p class="calibre6">In <a id="id355" class="calibre1"/>Eskimo, since I only have five levels, I chose to have one <code class="email">.plist</code> file that contains all levels. This may not be the best option in a larger game.</p><p class="calibre6">Although Apple devices will load and parse the <code class="email">.plist</code> files quickly, the same may not be true for other targets. So limit the size of your <code class="email">.plist</code> files by organizing the data into multiple files. You've probably seen games that divide their levels into multiple groups or packs. This is a simple way to create an extra preloading screen your game can use to parse level data. This can also be used as a means to keep file sizes to a minimum.</p><p class="calibre6">In Eskimo, we could have the <code class="email">.plist</code> files containing 10 levels each, for instance, and then 10 groups of these, totaling 100 levels.</p><p class="calibre6">So it's time <a id="id356" class="calibre1"/>to load our <code class="email">.plist</code> file and parse the data for our levels.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec127" class="calibre1"/>Time for action – retrieving data from the .plist file</h1></div></div></div><p class="calibre6">The<a id="id357" class="calibre1"/> level data is loaded in <code class="email">GameLayer</code>.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside the <code class="email">GameLayer</code> constructor, we load the data like this:<div><pre class="programlisting">_levels = FileUtils::getInstance()- &gt;getValueVectorFromFile("levels.plist");</pre></div><p class="calibre13">Cocos2d-x will take care of mapping <code class="email">FileUtils</code> to the correct target. There is <code class="email">FileUtils</code> for each platform that is supported by the framework and they all can be made to work with the <code class="email">.plist</code> format. Sweet! If the data in the <code class="email">.plist</code> file is an <strong class="calibre7">Array</strong>, you must convert it to <code class="email">ValueVector</code>; if it's <strong class="calibre7">Dictionary</strong>, you must convert it to a <code class="email">ValueMap</code>. We'll do that next when we load the data for a specific level.</p><div><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre6">If we divide the levels into multiple <code class="email">.plist</code> files, then we would need logic to refresh the <code class="email">_levels</code> array each time a new <code class="email">.plist</code> file is loaded.</p></div></li><li class="listitem" value="2">Inside the <code class="email">loadLevel</code> method, we load the data for the level like this:<div><pre class="programlisting">ValueMap levelData = _levels.at(_currentLevel).asValueMap();</pre></div><p class="calibre13">Here, the data in the <code class="email">.plist</code> file is <strong class="calibre7">Dictionary</strong>, so we must convert the data into a <code class="email">ValueMap</code>.</p><p class="calibre13">And that's it for the loading and parsing. Now we can proceed to retrieving data for our level.</p><p class="calibre13">Each level dictionary starts with the data regarding the level's gravity (a level may start with a different gravity value), the start point where the player should be placed, and the end point where the igloo should be placed.</p></li><li class="listitem" value="3">These values are retrieved like this in our code:<div><pre class="programlisting">_gravity = levelData.at("gravity").asInt();
switch (_gravity) {
    case kDirectionUp:
        _world-&gt;SetGravity(b2Vec2(0,FORCE_GRAVITY));
        break;
    case kDirectionDown:
        _world-&gt;SetGravity(b2Vec2(0,-FORCE_GRAVITY));
        break;
    case kDirectionLeft:
        _world-&gt;SetGravity(b2Vec2(-FORCE_GRAVITY, 0));
        break;
    case kDirectionRight:
        _world-&gt;SetGravity(b2Vec2(FORCE_GRAVITY, 0));
        break;
}

_player-&gt;setSpritePosition(Vec2(
    levelData.at("startx").asFloat() * TILE,
    levelData.at("starty").asFloat() * TILE
));

_igloo-&gt;initIgloo(_gravity, Vec2(
    levelData.at("endx").asFloat() * TILE,
    levelData.at("endy").asFloat() * TILE
));</pre></div></li><li class="listitem" value="4">Inside<a id="id358" class="calibre1"/> this same dictionary, we have an array for platforms and an array for gravity switches. These are retrieved like this:<div><pre class="programlisting">ValueVector platforms =  levelData.at("platforms").asValueVector();
ValueVector switches =  levelData.at("switches").asValueVector();</pre></div></li><li class="listitem" value="5">These arrays contain even more dictionaries containing data for the creation and placement of platforms and gravity switches in each level. This data is passed to the corresponding <code class="email">Platform</code> and <code class="email">GSwitch</code> classes, and boom—you've got yourself a level.<div><pre class="programlisting">for ( auto platformData : platforms){
   ValueMap data = platformData.asValueMap();
   platform-&gt;initPlatform ( data.at("width").asInt() * TILE,
                         data.at("angle").asFloat(),
                         Vec2(data.at("x").asFloat() * TILE,
                         data.at("y").asFloat() * TILE));
}

 for (int i = 0; i &lt; switches.size(); i++) {
        auto gswitch = _gSwitchPool.at(i);
        ValueMap data = switches.at(i).asValueMap();
        gswitch-&gt;initGSwitch(data.at("gravity").asInt(),
                    Vec2(data.at("x").asFloat() * TILE,
                    data.at("y").asFloat() * TILE));
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec120" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">Parsing and retrieving data from a property list file is a breeze with Cocos2d-x. You will always<a id="id359" class="calibre1"/> work with either an array of values or a dictionary of values and map these to a <code class="email">ValueVector</code> or <code class="email">ValueMap</code> respectively. </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec128" class="calibre1"/>Saving game data</h1></div></div></div><p class="calibre6">When<a id="id360" class="calibre1"/> planning your games, you may soon decide you wish to store data related to your application, such as highest score or user preferences. In Cocos2d-x, you can do this by simply accessing the <code class="email">UserDefault</code> singleton.</p><p class="calibre6">With <code class="email">UserDefault</code>, you can store integers, floats, doubles, strings, and Boolean with just one simple call per each data type, as follows:</p><div><pre class="programlisting">UserDefault::getInstance()-&gt;setIntegerForKey("levelsCompleted", _levelsCompleted);
UserDefault::getInstance()-&gt;flush();</pre></div><p class="calibre6">The other methods are <code class="email">setFloatForKey</code>, <code class="email">setDoubleForKey</code>, <code class="email">setStringForKey</code>, and <code class="email">setBoolForKey</code>. To retrieve data, you use their respective getters.</p><p class="calibre6">I'll show you next how to use that in our game.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec129" class="calibre1"/>Time for action – storing the completed levels</h1></div></div></div><p class="calibre6">Open <a id="id361" class="calibre1"/>the <code class="email">LevelSelectLayer</code> class.</p><div><ol class="orderedlist"><li class="listitem" value="1">This is how the number of levels completed is retrieved from inside the layer's constructor:<div><pre class="programlisting">_levelsCompleted = UserDefault::getInstance()- &gt;getIntegerForKey("levelsCompleted");</pre></div></li><li class="listitem" value="2">Initially, <code class="email">_levelsCompleted</code> will equal <code class="email">0</code> if no data is present. So we store level 1 as "unlocked". This is how that's done:<div><pre class="programlisting">if (_levelsCompleted == 0) {
    _levelsCompleted = 1;
    UserDefault::getInstance()-&gt;setIntegerForKey("levelsCompleted", 1);
    UserDefault::getInstance()-&gt;flush();
}</pre></div></li><li class="listitem" value="3">Then, whenever we start a new level, we update the number of levels completed if the new level number is larger than the value stored.<div><pre class="programlisting">if (_currentLevel &gt; _levelsCompleted) {
    _levelsCompleted = _currentLevel;
    UserDefault::getInstance()-&gt;setIntegerForKey("levelsCompleted", _levelsCompleted);
    UserDefault::getInstance()-&gt;flush();
}</pre></div><div><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre6">You don't have to flush the data (using <code class="email">flush</code>) each time you update every single bit in it. You can group multiple updates under one flush, or find a spot in your logic where you can safely flush updates before exiting the app. Nodes come with extremely helpful methods for this: <code class="email">onEnter</code>, <code class="email">onExit</code>, <code class="email">onEnterTransitionDidFinish</code>, and <code class="email">onExitTransitionDidStart</code>.</p></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec121" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">For <a id="id362" class="calibre1"/>small bits of data related to your game, settings, and preferences, <code class="email">UserDefault</code> is an excellent way to store information. Cocos2d-x once again will map this to whatever local storage is available in each target system.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec130" class="calibre1"/>Using events in your game</h1></div></div></div><p class="calibre6">Earlier <a id="id363" class="calibre1"/>versions of the framework used an Objective-C-inspired feature of notifications. But this particular API is already on its way to being deprecated. Instead, you should use the all-knowing <code class="email">Director</code> and its <code class="email">Dispatcher</code> (the same object we've been talking to when listening to touch events).</p><p class="calibre6">If you have ever worked with an MVC framework or developed a game AI system, you are probably<a id="id364" class="calibre1"/> familiar with a design pattern called the <strong class="calibre7">Observer Pattern</strong>. This consists of a central message dispatcher object other objects can subscribe to (observe) in order to listen to special messages, or order it to dispatch their own messages to other subscribers. In other words, it's an event model.</p><p class="calibre6">With Cocos2d-x, this is done very quickly and easily. Let me give you an example used in Eskimo.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec131" class="calibre1"/>Time for action – using the event dispatcher</h1></div></div></div><p class="calibre6">If we <a id="id365" class="calibre1"/>want the <code class="email">Platform</code> sprite to listen to the special notification <code class="email">NOTIFICATION_GRAVITY_SWITCH</code>, all we need to do is add <code class="email">Platform</code> as an observer.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside the <code class="email">Platform</code> class, in its constructor, you will find these lines:<div><pre class="programlisting">auto onGravityChanged = [=] (EventCustom * event) {
       if (this-&gt;isVisible()) {
            switchTexture();
        }
};
Director::getInstance()-&gt;getEventDispatcher()- addEventListenerWithSceneGraphPriority(EventListenerCustom::create  (GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged), this);</pre></div><p class="calibre13">And yes, it is one line of code! It is best to create a macro for both the dispatcher and the add listener code; so, something like this:</p><div><pre class="programlisting">#define EVENT_DISPATCHER Director::getInstance()- &gt;getEventDispatcher()
#define ADD_NOTIFICATION( __target__, __notification__,  __handler__) EVENT_DISPATCHER- addEventListenerWithSceneGraphPriority(EventListenerCustom::create  (__notification__, __handler__), __target__);</pre></div><p class="calibre13">This way the same line of code we used before would look like this:</p><div><pre class="programlisting">ADD_NOTIFICATION(this, GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged);</pre></div></li><li class="listitem" value="2">The<a id="id366" class="calibre1"/> message (or notification), <code class="email">NOTIFICATION_GRAVITY_SWITCH</code>, is created as a static string in <code class="email">GameLayer</code>:<div><pre class="programlisting">const char* GameLayer::NOTIFICATION_GRAVITY_SWITCH =  "NOTIFICATION_GRAVITY_SWITCH";</pre></div><p class="calibre13">The one-line call to the <code class="email">Director</code> class's dispatcher tells it that the <code class="email">Platform</code> objects will listen to this defined message, and when such a message is dispatched, every <code class="email">Platform</code> object will call the <code class="email">onGravityChanged</code> method. This method does not need to be a block as I showed here, but it is more readable to have the handler appear as close to the <code class="email">Add Listener</code> call as possible. So, simple blocks are a good way to organize listeners and their handlers.</p></li><li class="listitem" value="3">In the game, each gravity switch is color coded, and when the Eskimo hits a switch, the platform's texture changes to reflect the new gravity by switching to the color of the activated gravity switch. This is all done through a simple notification we dispatch inside <code class="email">GameLayer</code> when a collision with a <code class="email">GSwitch</code> object is detected inside the main loop. This is how we do that:<div><pre class="programlisting">Director::getInstance()-&gt;getEventDispatcher()- &gt;dispatchCustomEvent( GameLayer::NOTIFICATION_GRAVITY_SWITCH);</pre></div><p class="calibre13">Or, if you are using the macro, use this:</p><div><pre class="programlisting">EVENT_DISPATCHER-&gt;dispatchCustomEvent(  GameLayer::NOTIFICATION_GRAVITY_SWITCH);</pre></div></li><li class="listitem" value="4">You can also add a <code class="email">UserData</code> object in the custom event as a second parameter in the dispatch. This can be retrieved from the <code class="email">EventCustom *</code> event in the event handler, like this:<div><pre class="programlisting">event-&gt;getUserData();</pre></div></li><li class="listitem" value="5">When <code class="email">Platform</code> objects are destroyed, the <code class="email">Node</code> destructor will take care of removing the node as a listener.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec122" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You have<a id="id367" class="calibre1"/> just learned how to make your life as a developer much, much easier. Adding an application-wide event model to your game is such a powerful way to improve flow and interactivity between objects and it's so simple to use that I'm sure you'll soon implement this feature in all your games.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec132" class="calibre1"/>Using the accelerometer</h1></div></div></div><p class="calibre6">Now let's <a id="id368" class="calibre1"/>move to the few new topics related to gameplay, the first of which is the use of accelerometer data. Again, nothing could be simpler.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec133" class="calibre1"/>Time for action – reading accelerometer data</h1></div></div></div><p class="calibre6">Just as <a id="id369" class="calibre1"/>you do with <code class="email">touch</code> events, you need to tell the framework you want to read accelerometer data.</p><div><ol class="orderedlist"><li class="listitem" value="1">You tell the framework you wish to use the accelerometer with this one call inside any <code class="email">Layer</code> class:<div><pre class="programlisting">Device::setAccelerometerEnabled(true);</pre></div></li><li class="listitem" value="2">Then, just as you've done with <code class="email">touch</code> events, you subscribe to the <code class="email">accelerometer</code> events from the event dispatcher as follows:<div><pre class="programlisting">auto listenerAccelerometer =  
EventListenerAcceleration::create(CC_CALLBACK_2 (GameLayer::onAcceleration, this));
_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listenerAccelerometer,  this);</pre></div></li><li class="listitem" value="3">In Eskimo, the accelerometer data changes the value of a <code class="email">Point</code> vector called <code class="email">_acceleration</code>.<div><pre class="programlisting">void GameLayer::onAcceleration(Acceleration *acc, Event *event) {
    _acceleration = Vec2(acc-&gt;x * ACCELEROMETER_MULTIPLIER,
                        acc-&gt;y * ACCELEROMETER_MULTIPLIER);
}</pre></div><p class="calibre13">This value is then read inside the main loop and used to move the Eskimo. In the game, only one axis is updated at a time, depending on the current gravity. So you can only ever move the Eskimo on the <code class="email">X</code> axis or the <code class="email">Y</code> axis with the accelerometer data, but never both at the same time.</p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre6">Keep in mind that there is also a <code class="email">Z</code> axis value in the <code class="email">Acceleration</code> data. It might come in handy someday!</p></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec123" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">Yep. With <a id="id370" class="calibre1"/>a couple of lines, you added accelerometer controls to your game.</p><p class="calibre6">It is common practice to add extra filters to these accelerometer values, as results may vary between devices. These filters are ratios you apply to acceleration to keep values within a certain range. You can also find a variety of formulas for these ratios online. But these will depend on how sensitive you need the controls to be or how responsive.</p><p class="calibre6">And, in the game, we only update the Eskimo with the accelerometer data if the sprite is touching a platform. We can quickly ascertain that by checking whether or not the <code class="email">_player</code> body has a contact list, as follows:</p><div><pre class="programlisting">if (_player-&gt;getBody()-&gt;GetContactList()) </pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec134" class="calibre1"/>Reusing b2Bodies</h1></div></div></div><p class="calibre6">In Eskimo, we <a id="id371" class="calibre1"/>have a pool of <code class="email">b2Bodies</code> that are used inside the <code class="email">Platform</code> objects and we also change the shape of the little Eskimo whenever the player taps the screen. This is possible because Box2D makes it very easy to change the fixture data of a <code class="email">b2Body</code> fixture without having to destroy the actual body.</p><p class="calibre6">Let me show you how.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec135" class="calibre1"/>Time for action – changing a b2Body fixture</h1></div></div></div><p class="calibre6">All you<a id="id372" class="calibre1"/> have to do is make a call to <code class="email">body-&gt;DestroyFixture</code>. Not surprisingly, this should be done outside the simulation step.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside the methods <code class="email">makeCircleShape</code> and <code class="email">makeBoxShape</code> in the <code class="email">Eskimo</code> class, you will find these lines:<div><pre class="programlisting">if (_body-&gt;GetFixtureList() ) {
    _body-&gt;DestroyFixture(_body-&gt;GetFixtureList());
}</pre></div><p class="calibre13">Here we just state that if there is a fixture for this body, destroy it. We can then switch from a box to a circle fixture when the player taps the screen, but use the same body throughout.</p></li><li class="listitem" value="2">We use this feature with platforms too. Platforms inside the pool that are not being used in the current level are set to inactive as follows:<div><pre class="programlisting">_body-&gt;SetActive(false);</pre></div><p class="calibre13">This removes them from the simulation.</p></li><li class="listitem" value="3">And <a id="id373" class="calibre1"/>when they are reinitialized to be used in a level, we destroy their existing fixture, update it to match the data from the <code class="email">.plist</code> file, and set the body to active once again. This is how we do that:<div><pre class="programlisting">//Define shape
b2PolygonShape box;
box.SetAsBox(width * 0.5f /PTM_RATIO, PLATFORM_HEIGHT *  0.5f / PTM_RATIO);

//Define fixture
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;box;
fixtureDef.density = 1;
fixtureDef.restitution = 0;

//reutilize body from the pool: so destroy any existent fixture
if (_body-&gt;GetFixtureList()) {
    _body-&gt;DestroyFixture(_body-&gt;GetFixtureList());
}
_body-&gt;CreateFixture(&amp;fixtureDef);
_body-&gt;SetTransform(b2Vec2(position.x / PTM_RATIO, position.y /  PTM_RATIO), _DEGREES_TO_RADIANS(-angle));
_body-&gt;SetActive(true);</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec124" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">So, just as we've been doing with pools of sprites, we can apply the same logic to <code class="email">b2Bodies</code> and never instantiate anything inside the main loop.</p><p class="calibre6">Now, let's see how Android handles all this level-loading business.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec136" class="calibre1"/>Time for action – running the game in Android</h1></div></div></div><p class="calibre6">Time to<a id="id374" class="calibre1"/> deploy the game to Android.</p><div><ol class="orderedlist"><li class="listitem" value="1">Navigate to the <code class="email">proj.android</code> folder and open the file <code class="email">AndroidManifest.xml</code> in a text editor. Then go to the folder <code class="email">jni</code> and open the file <code class="email">Android.mk</code> in a text editor.</li><li class="listitem" value="2">In the <code class="email">AndroidManifest.xml</code> file, edit the following line in the <code class="email">activity</code> tag as follows:<div><pre class="programlisting">android:screenOrientation="portrait"   </pre></div></li><li class="listitem" value="3">Next, let's edit the make file, so open the <code class="email">Android.mk</code> file and edit the lines in <code class="email">LOCAL_SRC_FILES</code> to read:<div><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                   ../../Classes/b2Sprite.cpp \
                   ../../Classes/Eskimo.cpp \
                   ../../Classes/GSwitch.cpp \
                   ../../Classes/Igloo.cpp \
                   ../../Classes/Platform.cpp \
                   ../../Classes/LevelSelectLayer.cpp \
                   ../../Classes/MenuLayer.cpp \
                   ../../Classes/GameLayer.cpp</pre></div></li><li class="listitem" value="4">Now import the project into Eclipse and build it.</li><li class="listitem" value="5">You can now save it and run the game in your Android device.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec125" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">By <a id="id375" class="calibre1"/>now, you should be an expert at running your code in Android and hopefully your experience with Eclipse has been a good one.</p><p class="calibre6">And that's all folks!</p><p class="calibre6">Play the game. Check out the source code (which is chock-full of comments). Add some new levels and make the little Eskimo's life a living hell!</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec126" class="calibre1"/>Have a go hero</h2></div></div></div><p class="calibre6">The gameplay for Eskimo could be further improved with a few new ideas that would force the player to make more errors.</p><p class="calibre6">It is a common feature in these types of games to evaluate the degree of "completeness" in which a level was played. There could be a time limit for each level and pick-up items for the Eskimo, and the player could be evaluated at the end of each level and awarded a bronze, silver, or golden star based on his or her performance. And new groups of levels may only be unlocked if a certain number of golden stars were acquired.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec137" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">Yes, you have a cool idea for a game, great! But a lot of effort will go into structuring and optimizing it. Cocos2d-x can help with both sides of the job. </p><p class="calibre6">Yes, scenes can be a bit cumbersome depending on your needs, but they are undisputed memory managers. When <code class="email">Director</code> kills a scene, it kills it dead.</p><p class="calibre6">Loading external data can not only help with memory size, but also bring in more developers into your project, focusing specifically on level design and the external data files that create them.</p><p class="calibre6">And events can quickly become a must in the way you structure your games. Pretty soon, you will find yourself thinking in terms of events to handle game states and menu interactivity, among other things.</p><p class="calibre6">Now, let's move to a whole new language!</p></div></body></html>