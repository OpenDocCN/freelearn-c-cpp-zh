- en: Chapter 4. Control Freak
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 控制狂
- en: Most games are designed to be interactive. This means that the player must have
    some way to control what happens during the game. In the last chapter, you wrote
    code that displayed the robot and moved him across the screen. Now, you will control
    the robot!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都是设计成交互式的。这意味着玩家必须有一些方式来控制游戏中的发生的事情。在上一章中，你编写了显示机器人和在屏幕上移动它的代码。现在，你将控制机器人！
- en: 'This chapter will explain how to implement an input system to control the game''s
    character, and interact with the game. Topics will include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何实现一个输入系统来控制游戏角色，并与游戏交互。包括以下主题：
- en: '**Types of input**: There are many ways to interact with your game. Typically,
    games written for the PC depended on the mouse and keyboard. Direct touch input
    has now become the standard for mobile and tablet devices, and soon every PC will
    also have a touch-enabled display. We will cover the most common methods to receive
    input in your game.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入类型**：与你的游戏互动有许多方式。通常，为PC编写的游戏依赖于鼠标和键盘。直接触摸输入现在已成为移动和平板设备的标准，不久的将来，每台PC也将拥有触摸屏显示器。我们将介绍在游戏中接收输入的最常见方法。'
- en: '**Using the mouse and keyboard**: In this section, you will write code to receive
    input from the mouse and keyboard to control both the game and our friendly robot.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用鼠标和键盘**：在本节中，你将编写代码来接收鼠标和键盘的输入，以控制游戏和我们的友好机器人。'
- en: '**Creating the user interface**: In addition to controlling our robot, we also
    need a way to interact with the game. You will learn how to create an onscreen
    interface that allows you to control the game and choose the game options.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建用户界面**：除了控制我们的机器人外，我们还需要一种与游戏交互的方式。你将学习如何创建一个屏幕上的界面，允许你控制游戏和选择游戏选项。'
- en: '**Controlling the character**: We want our robot to be able to walk, run, jump,
    and play! You will learn how to use the mouse and keyboard to control how your
    robot moves about on the screen.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制角色**：我们希望我们的机器人能够行走、奔跑、跳跃和玩耍！你将学习如何使用鼠标和键盘来控制你的机器人在屏幕上的移动。'
- en: A penny for your input
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一便士作为你的输入
- en: It's likely that at some point in your life, you have been part of a conversation
    that seemed one-sided. The other party was talking and talking, and it didn't
    seem you could get a word in. After a while, such a conversation becomes quite
    boring!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能在你的生活中，你曾经参与过一场看似单方面的对话。另一方一直在说话，你似乎无法插话。过了一会儿，这样的对话变得相当无聊！
- en: The same would happen with a computer game that didn't allow any **input**.
    Input is a set of techniques that allows you to control the game. There are many
    ways to implement an input system, and we will cover them here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个不允许任何 **输入** 的电脑游戏也会发生同样的事情。输入是一组允许你控制游戏的技术。有许多方法可以实现输入系统，我们将在本章中介绍。
- en: The keyboard input
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘输入
- en: The most common form of input for most computers is the keyboard. Obviously,
    the keyboard can be used to enter text, but the keyboard can also be used to directly
    control the game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数计算机来说，最常见的形式是键盘。显然，键盘可以用来输入文本，但键盘也可以用来直接控制游戏。
- en: 'Some examples of this include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: Using the right arrow, left arrow, up arrow, and down arrow keys to control
    the character (we'll be using this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用右箭头、左箭头、上箭头和下箭头键来控制角色（我们将使用这种方法）
- en: Using the *W*, *A*, *S*, and *D* keys as to move the character (these keys almost
    form a cross on the keyboard, making them a good substitute to move up, left,
    down, and right, respectively)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *W*、*A*、*S* 和 *D* 键来移动角色（这些键几乎在键盘上形成一个十字，分别作为向上、向左、向下和向右移动的好替代）
- en: 'Using certain keys to perform predefined actions, such as:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用某些键执行预定义的操作，例如：
- en: Using the *Esc* key or *Q* to quit
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *Esc* 键或 *Q* 退出
- en: Using the Spacebar or *Enter key* to fire a projectile
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空格键或 *Enter 键* 发射投射物
- en: These are just a few examples. In fact, there are some games that seem to use
    every key on the keyboard!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是几个例子。实际上，有些游戏似乎使用了键盘上的每一个键！
- en: Using the mouse
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用鼠标
- en: 'The mouse has been around for a long time, so it makes sense that the mouse
    is used in many games. The mouse can be used in several ways:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标已经存在很长时间了，所以在许多游戏中使用鼠标是合理的。鼠标可以用几种方式使用：
- en: The left and right mouse buttons can perform specific actions.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左右鼠标按钮可以执行特定操作。
- en: The wheel can be pushed and used as a third button.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚轮可以推动并用作第三个按钮。
- en: The mouse wheel can be used to scroll.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标滚轮可以用来滚动。
- en: The position of the mouse pointer can be tracked and used in conjunction with
    any of the previous actions. We will use a combination of the left mouse button
    and the mouse pointer position to click onscreen buttons when we design our user
    interface.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以跟踪鼠标指针的位置，并将其与任何之前的行为结合使用。当我们设计用户界面时，我们将使用左鼠标按钮和鼠标指针位置的组合来点击屏幕上的按钮。
- en: Touch
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸
- en: 'More and more devices now respond to touch. Many input systems treat touch
    very similarly to the mouse:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的设备现在对触摸做出反应。许多输入系统将触摸处理得与鼠标非常相似：
- en: A single touch is equivalent to using the left mouse button
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个触摸相当于使用左鼠标按钮
- en: A single touch that is held is equivalent to using the right mouse button
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续的单个触摸相当于使用右鼠标按钮
- en: The position of the finger can be used in the same way as the mouse pointer
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针的位置可以像鼠标指针一样使用
- en: 'However, there are many features of touch that cannot be easily equated to
    the mouse. For example, most touch interfaces allow several touches to be handled
    simultaneously. This feature is known as multitouch. This has led to many standard
    gestures, including:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，触摸的许多功能并不能轻易地等同于鼠标。例如，大多数触摸界面允许同时处理多个触摸。这个特性被称为多点触控。这导致了许多标准手势，包括：
- en: The swipe or flick (moving one or more fingers quickly across the screen)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动或轻扫（将一个或多个手指快速在屏幕上移动）
- en: The pinch (moving two fingers together)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捏合（将两个手指合拢）
- en: The zoom (moving two fingers apart)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放（将两个手指分开）
- en: Unfortunately, we won't be implementing touch in this game because the target
    device for this book is the PC.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不会在这个游戏中实现触摸，因为本书的目标设备是PC。
- en: Other inputs
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他输入
- en: 'The advent of mobile devices was followed by an explosion of input techniques.
    Some of the more common ones include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备的出现随后是输入技术的爆炸式增长。其中一些更常见的包括：
- en: The accelerometer, which can be used to track the physical motion of the device
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计，可用于跟踪设备的物理运动
- en: Geolocation, which can be used to detect the physical location of the device
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理定位，可用于检测设备的物理位置
- en: The compass, which can be used to detect the orientation of the device
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指南针，可用于检测设备的方向
- en: The microphone, which can be used to accept voice input
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风，可用于接受语音输入
- en: There are many other input techniques, and there is a lot of overlap. For example,
    most PCs have a microphone. Again, while many games in the mobile market are taking
    advantage of these alternative input methods, our game will be limited to the
    keyboard and mouse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的输入技术，并且有很多重叠。例如，大多数PC都有一个麦克风。同样，虽然移动市场上的许多游戏正在利用这些替代输入方法，但我们的游戏将仅限于键盘和鼠标。
- en: Someone is listening
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有人正在监听
- en: Now, it's time to actually write some code to implement input for our game.
    It turns out that some rudimentary input has already been implemented. This is
    because Windows is an **event driven** operating system and is already looking
    for input to occur. From a simplistic point of view, the main task of Windows
    (or any modern operating system) is to listen for **events**, and then do something
    based on those events.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实际编写一些代码来实现我们游戏的输入了。结果证明，一些基本的输入已经被实现。这是因为Windows是一个**事件驱动**的操作系统，并且已经在寻找输入事件的发生。从简单的角度来看，Windows（或任何现代操作系统）的主要任务是监听**事件**，然后根据这些事件执行某些操作。
- en: So, whenever you hit a key on your keyboard, an event is triggered that wakes
    up Windows and says, "Hey, someone hit the keyboard!" Windows then passes that
    information to any programs that happen to be listening to keyboard events. The
    same occurs when you use the mouse.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论何时你在键盘上按下一个键，都会触发一个事件，唤醒Windows并说：“嘿，有人按了键盘！”Windows然后将该信息传递给任何可能正在监听键盘事件的程序。当你使用鼠标时，情况也是如此。
- en: The WndProc event listener
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WndProc事件监听器
- en: We have already told our program that we want it to listen to events. Open `RoboRacer.cpp`
    and locate the `WndProc` function. `WndProc` is part of the code that was created
    for us when use used the **Win32 Project template** to start our game. `WndProc`
    is known as a **callback function**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉我们的程序我们希望它监听事件。打开`RoboRacer.cpp`并定位到`WndProc`函数。`WndProc`是我们使用**Win32项目模板**开始游戏时为我们创建的代码的一部分。`WndProc`被称为**回调函数**。
- en: 'Here is how a callback function works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现回调函数的：
- en: 'First, the function name is registered with the operating system. In our case,
    this occurs in `CreateGLWindow`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将函数名称注册到操作系统中。在我们的例子中，这发生在`CreateGLWindow`中：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line tells our window class to register a function called `WndProc` as
    the event handler for our program.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, any events that are caught by Windows are passed to the `WndProc` function.
    The code in `WndProc` then decides which events to handle. Any events that aren't
    handled by `WndProc` are simply ignored by the program.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As `WndProc` was created for a typical Windows application, it contains some
    things that we don''t need, while there are some things that we can use:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The main work is done by `switch`, which handles various windows events (all
    prefixed by **WM**, which is an abbreviation for **Windows Message**):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The `WM_COMMAND` events can all be ignored. In a typical Windows application,
    you would create a menu and then assign various command events to be triggered
    when the user clicks on a command on the menu (for example, `IDM_ABOUT` to click
    on the **About** command). Games almost never use the standard Windows menu structure
    (and so, neither do we).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also ignore the `WM_PAINT` event. This event is triggered whenever the window
    containing the program needs to be redrawn. However, we are constantly redrawing
    our window using OpenGL via the `Render` function, so we don't need to add code
    to do that here.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are already handling the `WM_DESTROY` event. This event is triggered when
    you click the close icon (**X**) in the upper-right corner of the Windows. Our
    handler responds to this by posting its own message using `PostQuitMessage(0)`.
    This tells our program that it is time to quit.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the message queue
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed the Windows messaging system in [Chapter 1](ch01.html "Chapter 1. Building
    the Foundation"), *Building the Foundation* but this discussion warrants a recap.
    If you take a look at the `_wWinMain` function, you will see this block of code
    that sets up the main messaging loop:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The relevant part of this discussion is the call to `PeekMessage`. `PeekMessage`
    queries the message queue. In our case, if the `WM_QUIT` message has been posted
    (by `PostQuitMessage`), then done is set to `true` and the `while` loop exits,
    ending the game. As long as `WM_QUIT` has not been posted, the `while` loop will
    continue and `GameLoop` will be called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The event driven system is a great way to handle input and other actions for
    most programs, but it doesn't work well with games. Unlike games, most programs
    just sit around waiting for some kind of input to occur. For example, a word processing
    program waits for either a keystroke, a mouse button click, or a command to be
    issued. With this type of system, it makes sense to wake up the program every
    time an event happens so that the event can be processed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Games, on the other hand, do not sleep! Whether or not you are pressing a button,
    the game is still running. Furthermore, we need to be able to control the process
    so that an input is only processed when we are ready for it to be handled. For
    example, we don't want input to interrupt our render loop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Windows is currently rigged to handle input:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了当前Windows处理输入的方式：
- en: '![Handling the message queue](img/8199OS_04_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![处理消息队列](img/8199OS_04_01.jpg)'
- en: Handling mouse and keyboard inputs
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理鼠标和键盘输入
- en: We could expand `WndProc` to handle all of the input events. However, this is
    a terribly inefficient way to handle input, especially in a real-time program,
    such as a game. We will let Windows handle the case when the user closes the Window.
    For everything else, we are going to create our own input class that directly
    polls for input.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `WndProc` 扩展以处理所有输入事件。然而，这处理输入的方式非常低效，尤其是在实时程序中，如游戏。我们将让Windows处理用户关闭窗口的情况。对于其他所有情况，我们将创建自己的输入类，该类将直接轮询输入。
- en: 'There are many different ways to design an input system, and I am not going
    to presume that this is the best system. However, our input system accomplishes
    two important tasks:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计输入系统有许多不同的方法，我不会假设这是最好的系统。然而，我们的输入系统完成了两个重要的任务：
- en: We define a consistent input interface that handles both mouse and keyboard
    input
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个一致的输入接口，用于处理鼠标和键盘输入。
- en: We handle input by directly polling for mouse and keyboard events during each
    frame (instead of waiting for Windows to send them to us)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在每一帧中直接轮询鼠标和键盘事件来处理输入（而不是等待Windows将它们发送给我们）。
- en: Creating the Input class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输入类
- en: 'Create a new class called `Input`. Then add the following code into `Input.h`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Input` 的新类。然后，将以下代码添加到 `Input.h` 中：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As with all of our code, let''s take a close look to see how this is designed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所有的代码一样，让我们仔细看看这是如何设计的：
- en: We include `Windows.h` because we want access to the Windows API virtual key
    constants. These are constants that have been defined to represent special keys
    on the keyboard and mouse.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们包含 `Windows.h`，因为我们想要访问Windows API虚拟键常量。这些常量被定义为表示键盘和鼠标上的特殊键。 '
- en: We create the `Key` enum so that we can easily define values to poll the keys
    that we want to handle.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了 `Key` 枚举，以便我们可以轻松定义轮询我们想要处理的键的值。
- en: We create the `Command` enum so that we can easily map input to command actions
    that we want to support.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了 `Command` 枚举，以便我们可以轻松地将输入映射到我们想要支持的命令操作。
- en: We define a C++ macro named `KEYDOWN`. This greatly simplifies our future code
    (see the next step for details).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `KEYDOWN` 的C++宏，这极大地简化了我们的未来代码（详情见下一步）。
- en: The class only has one member variable, `m_command`, which will be used to hold
    the last action that was requested.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类只有一个成员变量，`m_command`，它将用于存储最后请求的操作。
- en: 'We define three member functions: the constructor, the destructor, `Update`,
    and `GetCommand`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了三个成员函数：构造函数、析构函数、`Update` 和 `GetCommand`。
- en: Virtual key codes
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟键码
- en: In order to understand how our input system works, you must first understand
    virtual key codes. There are a lot of keys on a keyboard. In addition to letters
    and numbers, there are special keys, including shift, control, escape, enter,
    arrow keys, and function keys. Coming up with a simple way to identify each key
    is quite a task!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们的输入系统是如何工作的，你必须首先了解虚拟键码。键盘上有许多键。除了字母和数字之外，还有特殊键，包括shift、control、escape、enter、箭头键和功能键。想出一个简单的方法来识别每个键是一项相当艰巨的任务！
- en: 'Windows uses two techniques to identify keys; for the normal keys (letters
    and numbers), each key is identified by the ASCII code of the value that is being
    tested. The following table shows the ASCII value for the keys that we use in
    our game:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Windows使用两种技术来识别键；对于普通键（字母和数字），每个键都通过正在测试的值的ASCII码来识别。以下表格显示了我们在游戏中使用的键的ASCII值：
- en: '| ASCII Value | Key |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| ASCII值 | 键 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 87 | *W* |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 87 | *W* |'
- en: '| 65 | *A* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 65 | *A* |'
- en: '| 83 | *S* |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 83 | *S* |'
- en: '| 68 | *D* |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 68 | *D* |'
- en: '| 81 | *Q* |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 81 | *Q* |'
- en: 'For special keys, Windows defines integer constants to make them easier to
    work with. These are known as virtual key codes. The following table shows the
    virtual key codes that we will work with in our game:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特殊键，Windows定义了整数常量，以便更容易地使用它们。这些被称为虚拟键码。以下表格显示了我们在游戏中将使用的虚拟键码：
- en: '| Virtual key code | Key |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟键码 | 键 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `VK_ESC` | *Esc* |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `VK_ESC` | *Esc* |'
- en: '| `VK_SPACE` | Spacebar |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `VK_SPACE` | 空格键 |'
- en: '| `VK_LEFT` | Left arrow |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `VK_LEFT` | 左箭头 |'
- en: '| `VK_RIGHT` | Right arrow |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `VK_RIGHT` | 向右箭头 |'
- en: '| `VK_UP` | Up arrow |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `VK_UP` | 向上箭头 |'
- en: '| `VK_DOWN` | Down arrow |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `VK_DOWN` | 向下箭头 |'
- en: '| `VK_RETURN` | *Enter* |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `VK_RETURN` | *Enter* |'
- en: '| `VK_LBUTTON` | Left mouse button |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `VK_LBUTTON` | 左鼠标按钮 |'
- en: '| `VK_RBUTTON` | Right mouse button |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `VK_RBUTTON` | 右鼠标按钮 |'
- en: Notice that there are even virtual key codes for the mouse buttons!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，甚至还有鼠标按钮的虚拟键码！
- en: Querying for input
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询输入
- en: 'The `GetAsyncKeyState` function is used to query the system for both keyboard
    and mouse input. Here is an example of that command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsyncKeyState`函数用于查询系统中的键盘和鼠标输入。以下是一个该命令的示例：'
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we pass in a virtual key code (or ASCII value), then we do a logical
    and with the hex value `8000` to strip out information that we don't need. If
    the result of this call is `true`, then the queried key is being pressed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们传递一个虚拟键码（或ASCII值），然后我们使用十六进制值`8000`进行逻辑与操作，以去除我们不需要的信息。如果这个调用的结果是`true`，那么被查询的键正在被按下。
- en: 'It''s a pretty awkward command to have to use over and over again! So, we create
    a C++ macro to make things simpler:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当尴尬的命令，需要反复使用！因此，我们创建一个C++宏来简化事情：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`KEYDOWN` executes the `GetAsyncKeyState` command. The macro accepts a key
    code as a parameter, and returns `true` if that key is being pressed or `false`
    if that key is not being pressed.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEYDOWN`执行`GetAsyncKeyState`命令。该宏接受一个键码作为参数，如果该键被按下则返回`true`，如果该键没有被按下则返回`false`。'
- en: Implementing the Input class
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现输入类
- en: 'All of the actual work is for our input system is done in the `Update` function,
    so let''s implement the `Input` class. Open `Input.cpp` and enter the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入系统的所有实际工作都是在`Update`函数中完成的，所以让我们实现`Input`类。打开`Input.cpp`并输入以下代码：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In a nutshell, the `Update` function queries all of the keys that we want to
    check simultaneously, and then maps those keys to one of the command enums that
    we have defined in the class header. The program then calls the class `GetCommand`
    method to determine the current action that has to be taken.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Update`函数查询我们想要同时检查的所有键，然后将这些键映射到我们在类头文件中定义的一个命令枚举。然后程序调用类的`GetCommand`方法来确定当前必须采取的操作。
- en: 'If you are really paying attention, then you may have realized that we only
    store a single command result into `m_command`, yet we are querying many keys.
    We can get away with this for two reasons:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的在注意听，那么你可能已经意识到我们只将单个命令结果存储到`m_command`中，但我们正在查询许多键。我们可以这样做的两个原因是：
- en: This is an infinitely simple input system with few demands
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个无限简单的输入系统，要求很少
- en: The computer cycles through the input at 60 frames per second, so the process
    of the player pressing and releasing keys is infinitely slow in comparison
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机以每秒60帧的速度循环输入，因此与玩家按键和释放按键的过程相比，这个过程是无限缓慢的。
- en: Basically, the last key detected will have its command stored in `m_command`,
    and that's good enough for us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，最后检测到的按键将它的命令存储在`m_command`中，这对我们来说已经足够好了。
- en: Also, notice that we set the initial command to `Input::Command::STOP`. As a
    result, if no key is currently being held down, then the `STOP` command will be
    the final value of `m_command`. The result of this is that if we are not pressing
    keys to make our robot move, then he will stop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们将初始命令设置为`Input::Command::STOP`。因此，如果没有按键当前被按下，则`STOP`命令将是`m_command`的最终值。结果是，如果我们没有按键来使我们的机器人移动，那么它将停止。
- en: Adding input to the game loop
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将输入添加到游戏循环
- en: Now that we have an input class, we will implement it in our game. We will handle
    input by adding it to `Update`. This gives us total control over when and how
    we handle input. We will only rely on the Windows event listener to tell us if
    the Window has been closed (so that we can still shut the game down properly).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入类，我们将在我们的游戏中实现它。我们将通过将其添加到`Update`中来处理输入。这使我们能够完全控制何时以及如何处理输入。我们只依赖Windows事件监听器来告诉我们窗口是否已被关闭（这样我们仍然可以正确地关闭游戏）。
- en: 'Open `RoboRacer.cpp` and modify the `Update` function so that it looks like
    the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RoboRacer.cpp`并修改`Update`函数，使其看起来像以下代码：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before now, our `Update` function only updated the game's sprites. If you recall,
    the sprite `Update` method modifies the position of the sprites. So, it makes
    sense to perform the input before we update the sprites. The `Update` method of
    the `Input` class queries the system for input, and then we run a `ProcessInput`
    to decide what to do.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们的`Update`函数只更新了游戏精灵。如果你还记得，精灵的`Update`方法会修改精灵的位置。因此，在更新精灵之前执行输入是有意义的。`Input`类的`Update`方法查询系统输入，然后我们运行`ProcessInput`来决定要做什么。
- en: Processing our input
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理我们的输入
- en: Just before we update all of our sprites, we need to process the input. Remember,
    the `Input` class `Update` method only queries the input and stores a command.
    It doesn't actually change anything. This is because the `Input` class does not
    have access to our sprites.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新所有精灵之前，我们需要处理输入。记住，`Input` 类的 `Update` 方法只查询输入并存储一个命令。它实际上并没有改变任何东西。这是因为
    `Input` 类无法访问我们的精灵。
- en: 'First, open `RoboRacer.cpp` and include the Input header file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `RoboRacer.cpp` 并包含 Input 头文件：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to add a variable to point to our `Input` class. Add the following
    line in the variable declarations section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个变量来指向我们的 `Input` 类。在变量声明部分添加以下行：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, modify `StartGame` to instantiate the `Input` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改 `StartGame` 以实例化 `Input` 类：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will create a function to process the input. Add the following function
    to `RoboRacer.cpp`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个函数来处理输入。将以下函数添加到 `RoboRacer.cpp`：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ProcessInput` is where the changes to our game actually take place. Although
    it seems like a lot of code, there are really only two things that are happening:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessInput` 是我们游戏实际发生更改的地方。尽管代码看起来很多，但实际上只发生了两件事：'
- en: We query the input system for the latest command using `inputManager->GetCommand()`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `inputManager->GetCommand()` 查询输入系统以获取最新的命令
- en: Based on that command we perform the required actions
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据该命令执行所需的操作
- en: 'The following table shows the commands that we have defined, followed by a
    description of how this affects the game:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们所定义的命令，以及这些命令如何影响游戏：
- en: '| Command | Actions |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 操作 |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CM_STOP` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `CM_STOP` |'
- en: Set the velocity of `player` to `0`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `player` 的速度设置为 `0`
- en: Set the background velocity to `0`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将背景速度设置为 `0`
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CM_LEFT` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `CM_LEFT` |'
- en: If `player` is currently moving right, deactivate the right sprite and make
    it invisible, and set the left sprite to the right sprite's position
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `player` 正在向右移动，则停用右侧精灵并使其不可见，并将左侧精灵设置为右侧精灵的位置
- en: Set `player` to the left sprite
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `player` 设置为左侧精灵
- en: Activate the left sprite and make it visible
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活左侧精灵并使其可见
- en: Set the velocity of the left sprite to `-50`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将左侧精灵的速度设置为 `-50`
- en: Set the velocity of the background to `50`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将背景速度设置为 `50`
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CM_RIGHT` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `CM_RIGHT` |'
- en: If `player` is currently moving left, deactivate the left sprite and make it
    invisible, and set the right sprite to the left sprite's position
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `player` 正在向左移动，则停用左侧精灵并使其不可见，并将右侧精灵设置为左侧精灵的位置
- en: Set `player` to the right sprite
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `player` 设置为右侧精灵
- en: Activate the right sprite and make it visible
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活右侧精灵并使其可见
- en: Set the velocity of the right sprite to `50`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将右侧精灵的速度设置为 `50`
- en: Set the velocity of the background to `-50`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将背景速度设置为 `-50`
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CM_UP` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `CM_UP` |'
- en: Call the sprite's `Jump` method with the parameter set to `UP`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数设置为 `UP` 调用精灵的 `Jump` 方法
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CM_DOWN` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `CM_DOWN` |'
- en: Call the sprite's `Jump` method with the parameter set to `DOWN`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数设置为 `DOWN` 调用精灵的 `Jump` 方法
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `CM_QUIT` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `CM_QUIT` |'
- en: Quit the game
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出游戏
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Changes to the Sprite class
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵类的更改
- en: 'Now that the robot can jump, we need to add a new method to the `Sprite` class
    to give the robot the ability to jump:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在机器人可以跳跃了，我们需要向 `Sprite` 类添加一个新的方法来赋予机器人跳跃的能力：
- en: 'First, we will add an enum to Sprite.h to track the sprite state:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 Sprite.h 中添加一个枚举来跟踪精灵状态：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need a new member variable to track if an element has been clicked.
    Add:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个新的成员变量来跟踪是否已点击元素。添加：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now go to the constructor in Sprite.cpp and add a line to initialize the new
    variable:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到 Sprite.cpp 的构造函数并添加一行以初始化新变量：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code to `Sprite.h`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Sprite.h`：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then add the following code to `Sprite.cpp`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下代码到 `Sprite.cpp`：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our robot is a little unique. When he jumps, he hovers at an elevated level
    until we tell him to come back down. The `Jump` method moves the robot `75` pixels
    higher when the player presses the up arrow, and moves him `75` pixels back down
    when the player presses the down arrow. However, we want to make sure that we
    don't allow a double-jump up or a double-jump down, so we check the current `y`
    position before we apply the change.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人有点独特。当他跳跃时，他会停留在提升的水平上，直到我们告诉他下来。`Jump` 方法在玩家按下上箭头时将机器人向上移动 `75` 像素，当玩家按下下箭头时将其向下移动
    `75` 像素。然而，我们想确保不允许双重跳跃向上或向下，因此我们在应用更改之前检查当前的 `y` 位置。
- en: 'Now that we are going to use input to control our robot, we no longer need
    to set the initial velocity as we did in the previous chapter. Locate the following
    two lines of code in LoadTextures and delete them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用输入来控制我们的机器人，我们不再需要像上一章那样设置初始速度。在 `LoadTextures` 中找到以下两行代码，并将它们删除：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the game. You should now be able to control the robot with the arrow keys,
    moving him left and right, up and down. Congratulations, you're a control freak!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏。现在你应该能够使用箭头键控制机器人，左右移动，上下移动。恭喜你，你已经成为了一个控制狂！
- en: Graphical User Interface
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面
- en: It is now time to turn our attention to the graphical user interface, or GUI.
    The GUI allows us to control other elements of the game, such as starting or stopping
    the game, or setting various options.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的注意力转向图形用户界面，或称 GUI。GUI 允许我们控制游戏的其他元素，例如开始或停止游戏，或设置各种选项。
- en: In this section, you will learn how to create buttons on the screen that can
    be clicked by the mouse. We'll keep it simple by adding a single button to pause
    the game. While we are at it, we will learn important lessons about game state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在屏幕上创建可以被鼠标点击的按钮。我们将通过添加一个用于暂停游戏的按钮来保持简单。在此过程中，我们还将学习有关游戏状态的重要课程。
- en: Creating a button
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建按钮
- en: A button is nothing more than a texture that is being displayed on the screen.
    However, we have to perform some special coding to detect whether or not the button
    is being clicked. We will add this functionality to the sprite class so that our
    buttons are being handled by the same class that handles other image in our game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮不过是在屏幕上显示的纹理。然而，我们必须执行一些特殊的编码来检测按钮是否被点击。我们将添加此功能到精灵类中，以便我们的按钮由处理我们游戏中其他图像的同一类处理。
- en: 'We will actually create two buttons: one to Pause and one to Resume. I have
    used a simple graphics program to create the following two buttons:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上将创建两个按钮：一个用于暂停，一个用于恢复。我使用了一个简单的图形程序创建了以下两个按钮：
- en: '![Creating a button](img/8199OS_04_02.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![创建按钮](img/8199OS_04_02.jpg)'
- en: I have saved these buttons as, you guessed it, `pause.png` and `resume.png`
    in the `resources` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些按钮保存为 `pause.png` 和 `resume.png`，在 `resources` 文件夹中。
- en: Enhancing the Input class
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强 Input 类
- en: In order to integrate UI into our existing `Input` class, we are going to have
    to add some additional features. We will add a dynamic array to the `Input` class
    to hold a list of UI elements that we need to check for input.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 UI 集成到我们现有的 `Input` 类中，我们不得不添加一些额外的功能。我们将在 `Input` 类中添加一个动态数组来保存我们需要检查输入的
    UI 元素列表。
- en: 'Start by adding the following line to the includes for `Input.h`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到 `Input.h` 的包含中：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We need to include the `Sprite` class so that we can work with sprites in the
    `Input` class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含 `Sprite` 类，以便在 `Input` 类中处理精灵。
- en: 'Next, we add a new command. Modify the `Command` enum so that it looks like
    the following list:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个新的命令。修改 `Command` 枚举，使其看起来像以下列表：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have added `CM_UI`, which will be set as the current command if any UI element
    is clicked.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `CM_UI`，如果任何 UI 元素被点击，它将被设置为当前命令。
- en: 'Now, we define a member variable to hold the list of UI elements. Add this
    line of code to the member variables in `Input.h`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个成员变量来保存 UI 元素列表。将以下行代码添加到 `Input.h` 的成员变量中：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`m_uiElements` will be a dynamic list of pointers to our elements, while `m_uiCount`
    will keep track of the number of elements in the list.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_uiElements` 将是我们元素的指针动态列表，而 `m_uiCount` 将跟踪列表中的元素数量。'
- en: 'The final change to `Input.h` is to add the following line in the public methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Input.h` 的最终修改是在公共方法中添加以下行：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding UI elements to the list
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 UI 元素添加到列表中
- en: We need to be able to add a list of elements to our `Input` class so that they
    can be checked during the input handling.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够将元素列表添加到我们的 `Input` 类中，以便在输入处理过程中进行检查。
- en: 'First, we have to allocate memory for our list of elements. Add the following
    lines to the `Input` constructor in `Input.cpp`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须为我们的元素列表分配内存。将以下行添加到 `Input.cpp` 中的 `Input` 构造函数中：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I could probably get cleverer than this, but for now, we will allocate enough
    memory to hold 10 UI elements. We then initialize `m_uiCount` to `0`. Now, we
    need to add the following method to `Input.cpp`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能可以比这更聪明，但到目前为止，我们将分配足够的内存来保存 10 个 UI 元素。然后我们将 `m_uiCount` 初始化为 `0`。现在，我们需要将以下方法添加到
    `Input.cpp` 中：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method allows us to add a UI element to our list (internally, each UI element
    is a pointer to a sprite). We add the element to the `m_uiElements` array at the
    current index and then increment `m_uiCount`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们将UI元素添加到我们的列表中（内部，每个UI元素都是一个指向精灵的指针）。我们将元素添加到当前的`m_uiElements`数组索引处，然后增加`m_uiCount`。
- en: Checking each UI element
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查每个UI元素
- en: Eventually, the Input class will contain a list of all UI elements that it is
    supposed to check. We will need to iterate through that list to see if any of
    the active elements have been clicked (if we want to ignore a particular element,
    we simply set its active flat to `false`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Input类将包含一个列表，其中包含它应该检查的所有UI元素。我们需要遍历这个列表，以查看是否有任何激活的元素被点击（如果我们想忽略特定的元素，我们只需将其激活标志设置为`false`）。
- en: 'Open `Input.cpp` and add the following code to `Update` above the existing
    code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Input.cpp`并在`Update`中添加以下代码（在现有代码之上）：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code iterates through each item in the `m_uiElements` array. If the element
    is active, then `CheckForClick` is called to see if this element has been clicked.
    If the element has been clicked, the `IsClicked` property of the element is set
    to `true` and `m_command` is set to `CM_UI`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历`m_uiElements`数组中的每个项目。如果元素是激活的，则调用`CheckForClick`来查看此元素是否被点击。如果元素被点击，则将元素的`IsClicked`属性设置为`true`，并将`m_command`设置为`CM_UI`。
- en: We put this code above the existing code because we want checking the UI to
    take priority over checking for game input. Notice in the preceding code that
    we exit the function if we find a UI element that has been clicked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此代码放在现有代码之上，因为我们希望检查UI的优先级高于检查游戏输入。注意在前面代码中，如果我们找到一个被点击的UI元素，我们会退出函数。
- en: Pushing your buttons
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按下你的按钮
- en: In order to see if an element has been clicked, we need to see if the left mouse
    button is down while the mouse pointer is inside the area bounded by the UI element.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一个元素是否被点击，我们需要检查当鼠标指针在UI元素定义的区域内部时，左鼠标按钮是否按下。
- en: 'First, open `Input.cpp` and add the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`Input.cpp`并添加以下代码：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is what we are doing:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们正在做的事情：
- en: We first make sure that the left mouse button is down.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先确保左鼠标按钮是按下的。
- en: We need to store the current position of the mouse. To do this, we create a
    `POINT` called `cursorPosition`, then pass that by reference into `GetCursorPos`.
    This will set `cursorPosition` to the current mouse position in screen coordinates.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要存储鼠标的当前位置。为此，我们创建一个名为`cursorPosition`的`POINT`，然后通过引用将其传递给`GetCursorPos`。这将把`cursorPosition`设置为屏幕坐标中的当前鼠标位置。
- en: We actually need the mouse position in client coordinates (the actual area that
    we have to work with, ignoring windows borders and fluff). To get this, we pass
    `cursorPosition` along with a handle to the current window into `ScreenToClient`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上我们需要客户端坐标中的鼠标位置（我们实际需要工作的区域，忽略窗口边框和杂项）。为了得到这个，我们将`cursorPosition`和当前窗口的句柄传递给`ScreenToClient`。
- en: Now that we have the `cursorPosition`, want to test to see if it is inside the
    rectangle that bounds our UI element. We calculate the left, right, top, and bottom
    coordinates of the sprite.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了`cursorPosition`，我们想要测试它是否在界定我们的UI元素的矩形内部。我们计算精灵的左、右、上和下坐标。
- en: Finally, we check to see if `cursorPosition` is within the boundaries of the
    UI element. If so, we return `true`; otherwise, we return `false`.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们检查`cursorPosition`是否在UI元素的边界内。如果是，我们返回`true`；否则，我们返回`false`。
- en: 'Ensure to add the following declaration to `Sprite.h`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将以下声明添加到`Sprite.h`中：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding our pauseButton
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加我们的暂停按钮
- en: We now need to add the code to our game to create and monitor our pause and
    resume buttons.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在我们的游戏中添加代码来创建和监控暂停和恢复按钮。
- en: 'First, we will add two variables for our two new sprites. Add the following
    two lines to the variable declaration block of `RoboRacer.cpp`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的两个新精灵添加两个变量。将以下两行添加到`RoboRacer.cpp`的变量声明块中：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, add the following lines to `LoadTextures` (just before the `return` statement):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下行添加到`LoadTextures`（在`return`语句之前）：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code sets up the pause and resume sprites exactly like we set up the other
    sprites in our game. Only the pause sprite is set to be active and visible.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置暂停和恢复精灵的方式与我们设置游戏中的其他精灵完全一样。只有暂停精灵被设置为激活和可见。
- en: 'You will notice one important addition: we add each sprite to the `Input` class
    with a call to `AddUiElement`. This adds the sprite to the list of UI elements
    that need to be checked for input.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到一个重要的添加：我们通过调用`AddUiElement`将每个精灵添加到`Input`类中。这会将精灵添加到需要检查输入的UI元素列表中。
- en: 'We must also add code to the `Update` function in `RoboRacer.cpp`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`RoboRacer.cpp`中的`Update`函数中添加代码：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, we must add code to the `Render` function in `RoboRacer.cpp` (just
    before the call to `SwapBuffers`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们必须在`RoboRacer.cpp`中的`Render`函数中添加代码（在调用`SwapBuffers`之前）：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's it! If you run the game now, you should see the new pause button in the
    upper-left corner. Unfortunately, it doesn't do anything yet (other than change
    the button from Pause to Resume. Before we can actually pause the game, we need
    to learn about state management.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你现在运行游戏，你应该会在左上角看到新的暂停按钮。不幸的是，它现在还没有做任何事情（除了将按钮从暂停改为恢复。在我们实际上能够暂停游戏之前，我们需要了解状态管理。
- en: State management
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理
- en: 'Think about it. If we want our game to pause, then we have to set some kind
    of flag that tells the game that we want it to take a break. We could set up a
    Boolean:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。如果我们想让我们的游戏暂停，那么我们必须设置某种类型的标志来告诉游戏我们想要它休息一下。我们可以设置一个布尔值：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We would set `m_isPaused` to `true` if the game is paused, and set it to `false`
    if the game is running.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏暂停，我们将`m_isPaused`设置为`true`，如果游戏正在运行，则将其设置为`false`。
- en: 'The problem with this approach is that there are a lot of special cases that
    we may run into in a real game. At any time the game might be:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，在实际游戏中可能会遇到很多特殊情况。在任何时候，游戏可能会是：
- en: Starting
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始
- en: Ending
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束
- en: Running
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Paused
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: These are just some example of **game states**. A game state is a particular
    mode that requires special handling. As there can be so many states, we usually
    create a state manager to keep track of the state we are currently in.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是**游戏状态**的一些示例。游戏状态是一种需要特殊处理的具体模式。由于可能有这么多状态，我们通常创建一个状态管理器来跟踪我们当前所处的状态。
- en: Creating a state manager
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建状态管理器
- en: 'The simplest version of a state manager begins with an enum that defines all
    of the game states. Open `RoboRacer.cpp` and add the following code just under
    the include statements:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理器的最简单版本是从一个枚举开始，该枚举定义了所有游戏状态。打开`RoboRacer.cpp`，并在包含语句下方添加以下代码：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then go to the variable declarations block and add the following line:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到变量声明块，并添加以下行：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To keep things simple, we are going to define two states: running and paused.
    A larger game will have many more states.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将定义两个状态：运行和暂停。大型游戏将有许多更多状态。
- en: Enums have a big advantage over Boolean variables. First, their purpose is generally
    clearer. Saying that the game state is `GS_Paused` or `GS_Running` is clearer
    than if we just had set a Boolean to `true` or `false`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举相对于布尔变量有一个很大的优点。首先，它们的目的通常更清晰。说游戏状态是`GS_Paused`或`GS_Running`比仅仅将布尔值设置为`true`或`false`要清晰得多。
- en: The other advantage is that enums can have more than two values. If we need
    to add another state to our game, it is as simple as adding another value to our
    `GameState` enum list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是枚举可以具有多个值。如果我们需要向我们的游戏添加另一个状态，只需向我们的`GameState`枚举列表中添加另一个值即可。
- en: 'Our game will start in the running state, so add the following line of code
    to the `StartGame` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将以运行状态开始，因此请将以下代码行添加到`StartGame`函数中：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pausing the game
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: Think about it for a minute. What do we want to do when the game is paused?
    We still want to see things on the screen, so that means that we still want to
    make all of our Render calls. However, we don't want things to change position
    or animate. We also don't want to process game input, though we do need to handle
    UI input.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。当游戏暂停时，我们想做什么？我们仍然想在屏幕上看到东西，这意味着我们仍然想调用所有的渲染调用。然而，我们不想让东西改变位置或动画。我们也不希望处理游戏输入，尽管我们需要处理UI输入。
- en: 'All of this should have you thinking about the update calls. We want to block
    updates to everything except the UI. Modify the `Update` function in `RoboRacer.cpp`
    so that it contains the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该让你思考更新调用。我们希望阻止除UI之外的所有更新的调用。修改`RoboRacer.cpp`中的`Update`函数，使其包含以下代码：
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that we will only process the sprite updates if the game state is `GS_Running`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只有在游戏状态为`GS_Running`时才会处理精灵更新。
- en: 'We are going to get ready to accept mouse input. First, we are going to setup
    a timer. Add the following code in the variable declarations of RoboRacer2d.cpp:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备接受鼠标输入。首先，我们将设置一个计时器。在`RoboRacer2d.cpp`的变量声明中添加以下代码：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then add the line of code below to StartGame:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下代码行添加到`StartGame`中：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The time will be used to add a small delay to mouse input. Without the delay,
    each click on the mouse would be registered several times instead of a single
    time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 时间将被用来为鼠标输入添加一小段延迟。如果没有延迟，鼠标的每次点击都会被记录多次，而不是一次。
- en: 'We still need to handle input, but not all input. Go to the `ProcessInput`
    function in `RoboRacer.cpp` and make the following changes:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理输入，但不是所有的输入。前往`RoboRacer.cpp`中的`ProcessInput`函数，并做出以下更改：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Take a look at the second line. It sets the command to `CM_UI` if the game is
    paused. This means that only UI commands will be processed while the game is paused.
    A hack? Perhaps, but it gets the job done!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第二行。如果游戏处于暂停状态，它将命令设置为`CM_UI`。这意味着在游戏暂停期间，只会处理UI命令。这是一种黑客行为吗？也许吧，但它完成了工作！
- en: We only have two more changes to make. When the pause button is clicked, we
    need to change the game state to `GS_Paused`, and when the resume button is clicked,
    we need to change the game state to `GS_Running`. Those changes have already been
    made in the `CS_UI` case in the preceding code!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做两个更改。当按下暂停按钮时，我们需要将游戏状态更改为`GS_Paused`，而当按下继续按钮时，我们需要将游戏状态更改为`GS_Running`。这些更改已经在前面代码中的`CS_UI`案例中完成！
- en: When you run the program now, you will see that the game pauses when you click
    the pause button. When you click the resume button, everything picks up again.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行程序时，你会看到当你点击暂停按钮时游戏会暂停。当你点击继续按钮时，一切都会重新开始。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Again, you have traveled far! We implemented a basic input class, then modified
    our sprite class to handle UI. This unified approach allows one class to handle
    sprites as game objects as well as sprites as part of the user interface. The
    same approach to see if a button has been pushed, can also be used for collision
    detection for a game object too. Then you learned how to create a state machine
    to handle the various states that the game may be in.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你已经走得很远了！我们实现了一个基本的输入类，然后修改了我们的精灵类以处理UI。这种统一的方法允许一个类既可以处理作为游戏对象的精灵，也可以处理作为用户界面一部分的精灵。检查按钮是否被按下的相同方法，也可以用于游戏对象的碰撞检测。然后你学习了如何创建状态机来处理游戏可能处于的各种状态。
- en: In the next chapter, we will learn to detect when game objects collide.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何检测游戏对象之间的碰撞。
