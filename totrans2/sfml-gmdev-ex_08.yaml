- en: Chapter 8. The More You Know – Common Game Programming Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move past the halfway point of this book, the bells and whistles in our
    games are going to get more and more advanced. To showcase them properly, the
    genre of our final project will be a classical 2D **Role Playing Game** with orthographic
    projection. With our code-base growing at a rapid rate, poor design quickly becomes
    tedious to maintain, or even unmanageable. As new features get added, we want
    expansion of code to be easy and not slow down the overall process. This is the
    area where game programming patterns shine the brightest.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: The design and implementation of the entity component system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-system communication using the observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of map layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's not waste any time and jump right into making our code base more robust!
  prefs: []
  type: TYPE_NORMAL
- en: Use of copyrighted resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once again, before beginning this chapter, we''d like to give credit where
    credit''s due. The graphics used for the third project of this book consist of
    but are not limited to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[LPC] Medieval fantasy character sprites* by *wulax* under CC-BY-SA 3.0 and
    GPL 3.0 licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lots of free 2D tiles and sprites* by *Hyptosis* under the CC-BY 3.0 license:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis](http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis)'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the licenses that apply to the use of these resources can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a programming pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming patterns, or design patterns, at they're more commonly referred
    to, are reusable and widely-implemented solutions to a given problem. That is
    not to say that these patterns exist as some sort of libraries out there, although
    there are libraries based on them. Instead, a programming pattern is more of an
    idea or a strategy. It is a well laid out plan on tackling a certain problem,
    the best possible answer to a given problematic situation, proven by time and
    experience, which is one of the the best reasons they should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few design patterns out there, as well as books, tutorials
    and even classes dedicated solely to understanding and implementing them. For
    our purposes, we''re going to be covering four: the entity component system, event
    queue, observer and factory patterns. We''ll be talking about each one separately,
    as they''re non overlapping in function, even though they can be working together.'
  prefs: []
  type: TYPE_NORMAL
- en: The entity component system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **entity component system** is a programming pattern, which allows entities
    to possess properties and functionality through the means of composition, as opposed
    to inheritance. The biggest benefits of using this pattern include stronger decoupling
    of logic, easier serialization and de-serialization of entities, better reusability
    of code and ease of creating new entities. It does, however, add a fair bit of
    complexity to your code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical implementation of this pattern consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities**: In most cases, entities are barely anything more than identifiers,
    slapped on a collection of components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: These are the building blocks of entities, that are nothing
    more than collections of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Systems**: These are specialized classes that deal with a very specific task
    and are responsible for holding all of the logic in this paradigm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to working with these three distinct types of elements, our entity
    component system is also going to need an entity manager to keep and manage all
    of the entity and component data, as well as the system manager, which will be
    responsible for updating each system, in addition to some other functionality
    we'll be covering soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to differentiate between different types of components and systems,
    we''re going to create a new header file, `ECS_Types.h`, which will be used to
    store this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition to component and system enumerations, we're also aliasing an unsigned
    integer to act as the component type and defining a macro `N_COMPONENT_TYPES`,
    which represents the maximum number of component types we can have.
  prefs: []
  type: TYPE_NORMAL
- en: What is a component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the entity component system paradigm, a **component** is the smallest,
    non-overlapping aspect of an entity, such as its position, velocity or a sprite.
    From the programming point of view, however, it is nothing more than a simple
    data structure, which has no real logic in it. Its only job is storing information
    about the feature of an entity it represents, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a component?](img/B04284_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to store components easily, they have to rely on principles of inheritance.
    Let''s take a look at a base component class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of our component base class will take in the type of the component
    it represents. One thing to note is the overloaded `>>` operator, which calls
    a purely virtual function `ReadIn`. This serves as a quick way to read component
    data in from a file. Because each component is unique, it defines its own version
    of the `ReadIn` method in order to load its data correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The position component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good example of putting the base component class to work is actually implementing
    the first and arguably most common type of component: **position**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of our component base class is invoked in the initializer list,
    with the component type being passed in as the only argument. Although there are
    better ways of assigning individual component types their own unique identifiers,
    it's better to start simple for clarity's sake.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component keeps track of three pieces of data: its current position, the
    position it was at during the previous cycle, and the current elevation of an
    entity, which is simply a value that represents how high the entity is in relation
    to the map.'
  prefs: []
  type: TYPE_NORMAL
- en: Much like any other component we will be covering later in the chapter, it offers
    a number of methods for modifying and obtaining its data members. While making
    its data members publically available is perfectly valid, offering helper methods
    reduces code redundancy and offers a familiar interface.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note the implementation of the `ReadIn` method. It uses a `stringstream`
    object as an argument and loads the relevant pieces of data from it.
  prefs: []
  type: TYPE_NORMAL
- en: The bitmask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a lightweight, easy-to-use as well as easy-to-expend data structure,
    representing the makeup of any given entity, as well as a set of requirements
    imposed by a system saves a lot of headaches. For us, that data structure is a
    **bitmask**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard template library provides its own version of a bitmask: the `std::bitset`.
    For educational purposes, we''re going to be implementing our own version of this
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know already, in binary, any and all numbers can be represented
    as a combination of zeroes and ones. However, who's to say that those two values
    have to be used only to represent a number? With some quick bitwise operator magic,
    any simple integer can be turned into a string of continuous flags that represent
    different aspects of an entity, such as which components it has, or types of components
    it needs to have in order to belong to a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bitmask](img/B04284_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only real difference in practice would be a lot more than eight flags available.
    Let''s get coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining the data type for our bitset, kindly provided by the `stdint.h`
    header. As the name implies, the `uint32_t` type is exactly 32 bits wide. Using
    this type, and not, let's say, a typical integer, eliminates the possibility of
    cross-platform differences. A regular integer could take up less or more memory,
    depending on the platform our code is executed on. Using specialized types from
    the `stdint.h` header ensures the exact same results, regardless of platform differences.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the `Bitmask` class consists of nothing but bitwise operations,
    which are an essential part of the C/C++ background. If you are not yet familiar
    with them, it's not the end of the world, however, it would be more beneficial
    to at least understand how they work before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Managing entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the building blocks of entities defined, it''s time to talk
    about storing and managing them. As mentioned previously, all an entity is at
    this point is a single identifier. Knowing that, we can begin shaping the way
    this data is going to be stored, beginning, as always, with the definition of
    data types to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first data type we'll be working with is the entity identifier, once again
    represented by an unsigned integer. Next, a container is needed to hold all of
    the components for an entity. A vector works just fine for this purpose. Following
    that, we define a pair, a bitmask and the component container, which will hold
    all of the information about the entity. The bitmask is used here in order to
    alleviate the need to iterate over containers searching for components, when it
    can be quickly queried for the same purpose. The last piece of the entity puzzle
    is mapping an entity identifier to all of its data, for which we'll be using the
    `unordered_map`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to generate different component types with as little code as possible,
    we'll be using our trusty lambda-expression factory method here as well. The last
    four lines of type definitions here make that possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having all of the data types defined allows us to finally take a look at the
    entity manager class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In a fairly predictable fashion, we have all of the methods that would exist
    in any other class that serves as a container. Two different versions of adding
    entities are provided, one based on a bitmask passed in as an argument, and the
    other for loading an entity configuration from a file. The method for obtaining
    a component from a specific entity is templated, reducing the amount of code that
    has to be written outside of this class in order to obtain the type of component
    that is desired. Let''s take a look at how it''s implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The entity argument passed into the method is evaluated first, in order to determine
    if one with the provided identifier exists. If it does, the bitmask of that entity
    is checked to verify that a component with the requested type is part of it. The
    component is then located in the vector and returned as the dynamically-cast type
    of the template.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the entity manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the class definition out of the way, we can start implementing its methods.
    As per usual, let''s address the constructor and destructor of the entity manager
    class first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes in a pointer to the `SystemManager` class, which we will
    be implementing shortly, as well as a pointer the `TextureManager`. In its initializer
    list, the `idCounter` data member is set to zero. This is simply a variable that
    will be used to keep track of the last identifier that was given to an entity.
    Additionally, both the system manager and the texture manager pointers are stored
    for later reference. The last purpose of the constructor is adding all of the
    different types of components to the component factory.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor simply invokes a `Purge` method, which will be used to clean
    up all of the dynamically allocated memory and clear all possible containers in
    this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the case of adding an entity based on the provided bitmask, a new entity
    pair is inserted into the entity container first. If the insertion was successful,
    a `for` loop iterates over all possible types of components and checks the mask
    for that type. The `AddComponent` method is then invoked, if the bitmask has the
    said type enabled.
  prefs: []
  type: TYPE_NORMAL
- en: After the component insertion, the system manager is notified of an entity being
    modified, or, in this case, inserted. The entity identifier, along with the bitmask
    of the said entity is passed into the `EntityModified` method of the system manager.
    An event is also created to alert the systems that this entity just spawned.
  prefs: []
  type: TYPE_NORMAL
- en: The identifier of the newly created entity is then returned. If the method failed
    to add an entity, -1 is returned instead, to signify an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an entity is every bit as easy, if not more so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the entity is successfully located in the entity container, the dynamically
    allocated memory of every single component it has is first freed, and the component
    is then removed from the vector. The entity itself is then erased from the entity
    container and the system manager is notified of its removal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding a component to an entity begins by verifying an entity with the provided
    identifier exists. If it does, and if there isn't already a component of that
    type added to the entity, the lambda-function container is queried for the desired
    type. Once the memory for the component is allocated, it's pushed into the component
    vector. The bitmask is then modified to reflect the changes made to the entity.
    The system manager is notified of those changes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Predictably, a very similar process takes place when removing the component
    from an entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After confirming that both the entity and component exist, the memory allocated
    for the component is freed and the component itself is erased. The bitmask also
    gets modified to reflect these changes. Much like before, the system manager needs
    to know if an entity was altered, so the `EntityModified` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fairly useful method to have for outside classes is one that checks if an
    entity has a certain type of component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This follows the same pattern as before by checking if an entity exists first,
    then checking its bitmask for a certain component type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s cleanup time. Correctly disposing of all allocated resources is left
    up to the `Purge` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The system manager is notified to remove all of its entities first. While iterating
    over all of the entities in storage, it frees up the memory of every single component.
    The component container is then cleared. Lastly, the entity container itself is
    cleared and the identification counter is set back to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With complex data structures such as entities, chances are the programmer will
    not be setting up and initializing every single component by hand. Setting up
    entities with any arrangement of components quickly and with as little repeated
    code as possible is very much the goal here. Luckily, a programming pattern exists
    to solve this particular problem. It is simply referred to as the **factory**
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The philosophy of use for this neat pattern is quite simple. There exists a
    class with some abstract method that takes in one or two arguments, pertaining
    to some vague identifying qualities. This class then generates, based on the information
    it was given, a class or a number of classes and returns a handle to them, effectively
    cutting out the part where data allocation or member initialization is done by
    hand. In other words, it is given a blueprint and produces a product based on
    it, hence the name "factory". This functionality was already achieved in a way
    by creating entities based on a bitmask, however, no actual data was initialized,
    only the defaults. Having a more pristine way of actually setting up these entities
    requires a more elaborate blueprint, so why not use text files? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This format would allow everything there is to an entity to be stored in plain
    text as a blueprint and loaded at any time to produce any number of entities with
    exactly the same qualities. Let''s take a look at how processing entity files
    could be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Loading entity files isn't much different from any other files we've processed
    in the past. For now, reading entity names hasn't yet been implemented. The attributes
    line is simply the numeric value that the bitmask has with the desired components
    enabled. Once that value is read in, we pass it in to the other version of `AddEntity`,
    in order to create it and have all of the components properly allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in the actual components is slightly more complicated. First, we must
    make sure that the entity has been created. This means that the "Attributes" line
    has to come before the individual component data in the entity file. If the entity
    ID is greater than -1, we proceed with reading in the component ID and obtaining
    the actual object based on it. The overloaded `>>` operator comes in handy here,
    since it greatly simplifies actually streaming in the component data.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, due to the nature of resource handling, the component type has to be
    checked in order to provide its instance with a pointer to the texture manager
    class, if it needs it. We haven't yet created such components, however one of
    them will be the sprite sheet component that will represent some entities.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the data side of this paradigm being accounted for, the last remaining
    component remains to be the **system**. As the name loosely implies, systems are
    responsible for handling all of the logic that takes place inside and between
    components. Things ranging from sprites being rendered to collision checks are
    all handled by their own, respective systems to ensure complete separation between
    non-overlapping parts of the game. At least, that's how it should play out in
    an ideal world. In reality, as hard as one tries to decouple and categorize logic
    or data, some things still remain loosely connected, which is just the nature
    of the beast. Information still has to be traded between systems, however. Certain
    functionality also needs to be invoked as a consequence of a totally unrelated
    system's actions. To put it simply, there needs to be a way for systems to talk
    to each other without them knowing anything about how the other one works.
  prefs: []
  type: TYPE_NORMAL
- en: Entity events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A fairly simplistic, and as it happens, necessary approach to handling inter-system
    relations is dispatching events. Every other system could be listening for those
    events and performing their own logic, completely separate from everything else,
    in response to a certain event taking place. Let''s take a look at a possible
    list of entity events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This should give you a pretty good idea of how system communication will take
    place. Let's say that an entity is moving in the left direction. The "movement
    system" starts dispatching events, saying that it's in motion. The "animation
    system" listens for those events, and when they're received, it proceeds to increase
    frames in the entity's sprite sheet. Keep in mind that all of these chunks of
    logic are still completely separate from one another. The "movement system" is
    not increasing the frames of the entity's sprite sheet. It's simply saying to
    all of the other systems "Hello, I am moving entity x to the left," while they
    listen and react. It sounds like we can benefit from the "event queue."
  prefs: []
  type: TYPE_NORMAL
- en: Entity event queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **event queue** is a programming pattern, which is used to decouple when
    an event is fired from when it''s actually processed. This illustration should
    capture the essence of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entity event queue](img/B04284_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A queue is what''s referred to as a First-In-First-Out data container. The
    data that is pushed onto it earliest is removed first. This serves our needs nicely.
    As the definition of the event queue states, its events are processed at a completely
    different time in relation to them being added. With that in mind, let''s start
    designing the `EventQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The event identifier is represented with an unsigned integer. In order to store
    the actual events, we'll be using, appropriately enough, a `queue` container.
    Adding an event to it is as simple as any other STL container. This class offers
    a method that can be used with while loops in order to simplify event processing.
    It returns a Boolean value in order to break the loop when the event queue is
    empty and its sole argument is taken by reference, in order to modify it each
    time the method is called. This is similar to the way SFML handles events.
  prefs: []
  type: TYPE_NORMAL
- en: The base system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to begin implementing our systems, they must first have a common base
    class, which not only provides a common interface that must be implemented, but
    also eliminates code redundancy. Much like most other classes we build, it will
    have its own data types defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The system identifier, just like the component identifier, is represented by
    an unsigned integer. All of the entity identifiers will be stored in a vector
    container, much like the requirement bitmasks. The reason we would ever want to
    have more than one requirement bitmask is to have the ability to define combinations
    of different types of components that could still belong to the same system. A
    good example of that would be different drawable types belonging to the same rendering
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the header of our system base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We want every single system to have its own update method, as well as its own
    version of event handling. Additionally, systems having access to their own manager
    is also desired. Everything else that is not system-specific, like checking requirement
    bitmasks, is handled by the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the base system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because all systems require a pointer to the system manager, there''s an issue
    of cross-inclusion. A forward declaration of it right before the class header
    and the inclusion of the system manager header in the implementation file takes
    care of the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to go down the list of methods to implement, starting with the constructor
    and destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each system has to have its own identifier, much like all of the components.
    That gets passed in the argument list to the constructor, along with a pointer
    to the system manager. Aside from setting the appropriate data members to these
    values in an initializer list, the constructor of a base system does nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor, following the typical fashion, invokes the `Purge` method to
    do the cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an entity to a system is fairly easy. If the identifier that was provided
    as an argument doesn''t already exist within the said system, it simply gets pushed
    into the vector. How does a system determine if it has an entity with such an
    identifier? Let''s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Utilizing the `std::find` function allows us to sum up this method in a single
    line. Removing an entity also takes advantage of a similar function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're using the `std::find_if` function, which takes a predicate
    as the third argument. A predicate is just another function that compares two
    elements together in order to find a match. In this case, we simply construct
    a lambda function that takes in an `EntityId` and returns a Boolean value, which
    will tell the find function whether a match was found. If it was, the entity is
    then removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each system has to make sure that an entity has all the required components
    in order to be added to it. That''s where this method comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It takes in a bitmask as an argument and utilizes the same `std::find_if` function
    in conjunction with a lambda to locate a match. Very few systems will even need
    to define more than one bitmask for its required components, however it's nice
    to have this functionality when the need for it arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, here''s the method for cleaning up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because there's no actual dynamic memory being allocated here, it's safe to
    just empty the container of all the entity identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Handling messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entity events, while useful for a lot of situations, aren't perfect for everything.
    For instance, carrying data between systems is impossible using the event queue.
    The events are also being delivered to every single system, which can be wasteful.
    Instead, why not have an additional method of communication that not only carries
    data around, but also allows systems to pick and choose what they want to receive?
    Entity component system messaging serves exactly that purpose, and there just
    so happens to be yet another programming pattern, which allows easy implementation
    of the message-subscription approach.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name entails, the **observer** pattern allows its users to pick and
    choose what they will be notified of. In other words, the observer will lay dormant
    after subscribing to information types it wishes to receive, and will only be
    notified if those types are encountered. Let''s take a look at a very basic implementation
    of the `Observer` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Observer` class is simply an interface, the inheritors of which must define
    a single method in order to use it. Although it looks simple, many features we
    desire in our game wouldn''t be possible without it. Let''s take a look at what
    these observers will be notified with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Aside from holding the information about the sender and receiver entities, as
    well as the message type, it employs a `union` in order to avoid inheritance.
    That essentially means that all of the data members within this union will be
    sharing the same space in memory, and only one of them can be valid at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is containing all possible observers in a `Communicator`
    class. For this, we''ll be using a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this class has relatively simple methods that simply deal with managing
    a vector container, let''s take a look at the full class definition head to toe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The basic methods for adding, removing and looking for an observer are all typical.
    One thing to note, however, is the `Broadcast` method, which simply invokes the
    `Notify` method of an observer and passes in a message to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, and definitely the least amount of code is responsible for actually putting
    the observer approach to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Because the base system class has virtual methods, it doesn't need to implement
    its own version of `Notify`. That will be the job for all the systems that inherit
    from this class.
  prefs: []
  type: TYPE_NORMAL
- en: The message handler class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have all of the pieces to build a cohesive messaging system. Let''s take
    a look at some data types that will be used to store message subscription information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each possible message type will have its own communicator that will broadcast
    the message to all of its observers. Using an `unordered_map` is perfect for expressing
    such a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message handler is a very simple class, so let''s take a look at its entire
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing and unsubscribing to message types is simply done by manipulating
    the unordered map data container. When a message is dispatched, the message type
    in the subscription container is queried. If it is found, the communicator's `Broadcast`
    method is invoked with the message passed in as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point you might be wondering what kind of messages we''ll be handling.
    Let''s take a gander at the `EntityMessages.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of a messaging system quickly becomes clear, even by simply reading
    the names of message types. Every one of them lends itself to either needing to
    contain extra data or only ever applying to a single system.
  prefs: []
  type: TYPE_NORMAL
- en: Managing systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we''ve arrived at the last stop on the entity component system route:
    handling systems themselves. Let''s quickly review our custom data types for this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first data type, `SystemContainer`, is really hard to misinterpret. An unordered
    map is used to link system identifiers to actual systems. The second type definition
    here is responsible for storage of entity events. It also uses an unordered map
    and links entity identifiers to `EventQueue` instances, that all hold events for
    a specific entity until they're processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to design the system manager class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, it needs to have methods for adding and handling events, updating
    and drawing the systems, notifying them of entity changes and removal requests,
    and obtaining them as well. The template method for getting a particular system
    is implemented this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Just like the entity manager's method of obtaining components, this method relies
    on the use of templates and dynamic casting in order to obtain a system in the
    correct form.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the system manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cross-inclusion peaks its ugly head once more, so we must combat it with forward
    declarations and inclusions of headers in the implementation files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, we can now start implementing the constructor and
    destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The constructor sets up a pointer to an entity manager class before initializing
    all of the systems it holds. The destructor performs its usual job of cleaning
    up the mess, which is entrusted to the `PurgeSystems` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the system manager needs to have a pointer to the entity manager and
    vice versa, the one that''s instantiated first will not simply be able to take
    a pointer to the other class in its constructor, hence the need for the `SetEntityManager`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With a class so broadly applied, it needs to provide getter methods for its
    data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that all systems have access to the message handler, as well as
    the entity handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of system access, they also must be able to add events to any entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using an `unordered_map` structure here really makes this method simple and
    neat. The entity identifier being the key, it's easy to access its individual
    event queue and add to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing we want those systems to tick, an update loop is in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, every single system''s update method is invoked and the elapsed time
    is passed in. The event handling takes place after all of the systems have been
    updated. Time to dissect that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We begin by iterating over the event queues of different entities. An event
    identifier variable is set up and used in a `while` loop by reference, in order
    to obtain information from the queue. Every system in the manager is iterated
    over and checked for having the entity of interest. If it does, the system's `HandleEvent`
    method is invoked and the relevant information is passed in. That, in a nutshell,
    concludes event management on a larger scale. Now every individual system only
    has to worry about which events it wants to handle and how it wants to respond
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to populate the dark void of the screen with entities, we''re going
    to need a `Draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For most needs, having a single system devoted to rendering entities more than
    suffices. Ergo, the renderer system is located in the system container and type-cast
    up from the base class. Its `Render` method is then invoked with relevant arguments,
    one of which is the current elevation that's being rendered. Drawing it this way
    allows the feel of "depth" to be achieved within our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'As entities are not static in their composure, systems must be aware of these
    changes and properly take in or dispose of them, given the circumstances. This
    specific method has already been brought up multiple times during the implementation
    of the entity manager class, so let''s take a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Upon any changes regarding entities taking place, the `EntityModified` method
    must be invoked with the identifier of the entity and its new bitmask passed in
    as arguments. Every system is then iterated over. Their respective `FitsRequirements`
    methods are invoked with the new bitmask as the argument. If the entity fits the
    requirements of a system and it doesn't belong to it, it is added. If, however,
    the entity does not fit these requirements but a system still has this entity,
    it's removed. The use of this simple concept allows entities to be dynamic in
    structure. Any given entity can lose or gain a component and immediately "transform"
    into something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removal of entities is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'All that needs to happen here is the `RemoveEntity` method of every system
    being invoked, which is quite similar to purging all entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting rid of all systems in the system manager is also a cake walk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because systems are dynamically allocated, the memory has to be freed for each
    of them. The system container is then simply cleared.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last method marks the completion of our system manager, as well as the
    core structure of the entity component system paradigm. All of the basic tools
    for shaping our game are now present, so let''s implement the first and most important
    system in the game: the renderer.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the rendering system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for entities to be drawn on screen, they must have a component that
    represents them visually. After some careful planning, one can deduce that an
    entity will probably not have just one possible choice for a graphical representation.
    For example, instead of a sprite sheet, an entity can be a simple shape with a
    single color fill. In order to make that happen, we need a common interface for
    drawable components. Let''s see what we can come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note here is that the constructor of this class also takes
    in a component type, and simply passes it to the base class. Since `C_Drawable`
    only has purely virtual methods, it can never be instantiated and will only be
    used as a mold to shape other drawable components. It requires all derived classes
    to implement a method for updating the drawable's position, obtaining its size
    and drawing it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The sprite sheet component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the base class set up, it''s time to take a look at creating the sprite
    sheet component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will, of course, be utilizing the `SpriteSheet` class we built
    in the past as one of its data members. We also want to hold on to the sprite
    sheet name in order to properly allocate resources after the time of de-serialization.
    Let''s begin implementing the sprite sheet component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So far, nothing is out of the ordinary. The constructor uses the initializer
    list to set up the component type and set the sprite sheet pointer to `NULL`,
    while the destructor takes care of de-allocating the memory that's taken up by
    said sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s handle reading in the component data, which only consists of the
    sprite sheet name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the nature of this particular drawable component, it needs access to
    the texture manager. In order to set up the sprite sheet properly, the `Create`
    method is introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As seen previously, this particular method is used to set up the sprite sheet
    component during entity loading. It first checks if the memory for the `m_spriteSheet`
    data member hasn't already been allocated. If it hasn't, a new `SpriteSheet` object
    is created with the texture manager pointer passed in as its sole argument. The
    rest of the code deals with the second, optional argument. The name of the texture
    can be passed to the `Create` method itself, or it can use the `m_sheetName` data
    member that has been read in from the entity file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, all of the virtual methods of the `C_Drawable` class must be implemented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: All of the work done on the `SpriteSheet` class in the past makes this pretty
    easy. One thing to note is that due to the nature of loading sprite sheet components,
    it may be wise to check if it has actually been allocated, before attempting to
    draw it.
  prefs: []
  type: TYPE_NORMAL
- en: The renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the simple part out of the way, let''s focus on creating our first system
    ever built, the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The header for all of the other systems will look very much like this one,
    with the exception of private methods, specific to the function that each individual
    system performs. Each system must implement its own `Update` and `HandleEvent`
    methods. Additionally, being an observer requires a unique implementation of the
    `Notify` method as well. Time to take a stab at implementing the renderer system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: After invoking the base system's constructor and passing in the appropriate
    type, along with a pointer to the system manager, the renderer sets up a bitmask
    of requirements an entity has to meet in order to belong to this system. As you
    can see, it only needs to have the position and sprite sheet components. Once
    the requirement bitmask is added to the system, it also subscribes to the `Direction_Changed`
    message type. This utilizes the observer pattern discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the update method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: During iteration over all of the entities that belong to this system, the position
    and drawable components are obtained through the entity manager. The drawable's
    position is then updated through the use of its `UpdatePosition` method. This
    method can obviously be expanded if additional drawable types are added in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s handle the appropriate events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the system encounters any events of entities spawning, changing their position
    or elevation, their drawable representations have to be re-sorted in order to
    assure the correct layering. The result of this is quite worth the trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The renderer](img/B04284_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for message handling here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Since messages are globally broadcasted to every system regardless of what entities
    they have, and the renderer only deals with a single message type that pertains
    to specific entities only, a check takes place in order to make sure the entity
    exists within the renderer system. The sole message type we care about so far
    is the direction being altered, in which case a private method is invoked to adjust
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s address the main purpose the renderer system exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entity is iterated over, much like any other system. The main difference
    here is the layer argument the method takes in. Because we want to have a map
    that has many different layers entities can be, for the lack of better term, "sandwiched"
    in, rendering elevation by elevation is necessary in order to maintain the correct
    draw order and offer the feeling of depth, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The renderer](img/B04284_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second half of the `Render` method is devoted to entity culling. First,
    a rectangle structure is created in order to represent the boundaries of a drawable.
    In the case of a sprite sheet, we know that its origin is set at the point of
    half its width and its full height. Using this information, the rectangle structure
    is properly set up and inspected for intersections with the view space, which
    essentially means the sprite is on screen and should be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Re-using code as much as possible makes life easier in the long run, hence
    the existence of many private methods amongst multiple systems, regarding modifications
    of entity components. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `SetSheetDirection` method simply fetches the sprite sheet component and
    changes its direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last feature we want to work on implementing is the render order of drawables
    in order to simulate depth. Drawing entities in a correct sequence requires them
    being sorted. This is where the `SortDrawables` method comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply invoke the `std::sort` function, with the last argument being
    the predicate lambda that we've already seen before. Elevation is given top priority
    when entity sprites are being sorted. Anything with a higher elevation will be
    drawn on top, while sprites on the same elevation are sorted based on their *Y*
    coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: With that, the rendering system is now complete! Putting all of the pieces together
    is the final step in employing the entity component system pattern in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the ECS to work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the part this paradigm plays in the overall structure of our application,
    we want the system manager and entity manager classes to be accessible to the
    majority of our code base. Having these objects be part of the shared context
    is the best way to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjusting the shared context means we have two extra classes to keep track
    of in `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes have to be properly initialized, which is done in `Game.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the entity manager is initialized in the initializer list. The system
    manager is then given a pointer to the entity manager, and both of these classes
    are added to the shared context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, some changes have to be made to the game state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The game state currently keeps track of the player''s entity identifier in
    addition to providing a new method for updating the camera, as well as moving
    the player, which will be set up as a callback like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: After the game map is loaded, the player entity identifier is obtained through
    the `Map` class, which stores this information during map loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is getting the camera to follow our hero. This can be accomplished
    by first calling our `UpdateCamera` method in the `Update` method of our game
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual `UpdateCamera` method itself is implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The player identifier first is verified of being a non-negative value, which
    would signify an error. The position component of the player entity is then obtained
    and used for updating the position of the current view. The rest of the code deals
    with adjusting the view to fit within the boundaries of the map, if it wanders
    outside of it. This is also where the system manager update method must be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing our game world also needs revising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'First, a `for` loop iterates over each layer that might be used in the game.
    The `Num_Layers` value is part of the `Sheet` enumeration, which is defined in
    the `Map` class header. We''ll be covering that shortly. The map `Draw` method
    now needs to know which layer to draw, as they''re not all drawn at the same time
    anymore. After the appropriate layer is rendered, all of the entities that occupy
    the same elevation are also rendered on screen, giving the impression of depth
    in the game, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting the ECS to work](img/B04284_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we need to define the callback method for moving a player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: A message of type `Move` is created and set up in order to hold the direction
    in its `m_int` data member. The receiver of the message is also set to be the
    player, and the message is dispatched through the system manager's message handler.
    This message will be handled by one of the systems we'll be building in a later
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change from our previous project is the number of directions an entity
    can move in. Given the format of our new entity spritesheets, let''s modify `Directions.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Since the direction is used as a way to offset numbers of rows in sprite sheets
    for obtaining correct animations, the values set here are important. This small
    change concludes building and setting up the core of our component entity system!
    All that's left now is adjusting the `Map` class to satisfy and complement the
    new, shiny features of our game.
  prefs: []
  type: TYPE_NORMAL
- en: The new and improved map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For as good as the second project of this book looked, a lot of things about
    it were fairly primitive. Among its other shortcomings, the map design lacked
    complexity due to its inability to support tile layers. Having a more complex
    scene requires tiles being able to layer over each other, in a manner best represented
    by this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new and improved map](img/B04284_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding layer support, as well as loading entity information after re-designing
    the way entities are handled requires some changes to be made to the map file
    format. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: While some map properties remain in place, things like gravity or background
    images have been removed, as it no longer suits the genre of the game we're making.
    The main changes here are the entity and tile lines.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an entity is as simple as providing the name of its entity file and
    a few pieces of data, relevant to maps, such as its position and elevation.
  prefs: []
  type: TYPE_NORMAL
- en: Tile loading is also slightly different now. In addition to its identifier and
    position, a tile now also requires having a layer, as well as a flag for solidity,
    which will be covered more in depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amongst some of the bigger changes, a new value inside the *Sheet* enumeration
    is defined. It represents the maximum possible number of layers in any given map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in order to allow individual solidity options, each tile now carries
    a solidity flag that can be turned on or off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with an extra piece of information, the tile layer, requires certain
    modifications to be made to the `GetTile` and `ConvertCoords` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note the `m_playerId` data member. It keeps track of what entity ID the player
    has been given after loading the map file.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Map class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to start implementing all of these changes! First, let''s take a
    look at the method used for obtaining map tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The biggest difference here is the check for accessing tiles that are out of
    boundaries of the map. The method itself takes an additional argument that represents
    the tile layer, which it then passes into the `ConvertCoords` method. Working
    with tile layers would require having a third dimension added to a 2D array of
    tiles. Since we''re storing all of this information in a one-dimensional array,
    some additional math has to be done in order to perform the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If you previously visualized the map as a 2D grid, it's now becoming a 3D cube,
    with the layer value representing its depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The desired functionality of the updated `Draw` method has been outlined quite
    clearly in the game state `Draw` method. Let''s implement that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Before we get into any actual rendering, we must make sure that the provided
    layer argument does not exceed the defined maximum. Aside from that, the only
    real difference here is that we're passing the layer argument into the `GetTile`
    method now. That's quite a simple adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the way tiles and entities are loaded has to be fixed. Let''s take
    a look at snippets from the `LoadMap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The majority of this code remains unchanged. Reading in the layer and solidity
    data has been added, as well as checking if the layer value is valid, together
    with the coordinate values. The entity side of things, however, is quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The name of an entity is read in first. If it's a player entity and it hasn't
    yet been set up based on the `m_playerId` data member, or if it's just any other
    entity, an attempt is made to add it. Upon successfully doing so, its name is
    checked once more in order to make sure the player entity identifier is caught
    and stored. The position component is then obtained and its data is read in directly
    from the map file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Map` class is finished, compiling and rendering our project and loading
    in a valid map should leave us with a few entities standing around peacefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting the Map class](img/B04284_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the invention of all the tools we need, we will next be working on adding
    the most common game elements to our final project and bringing it to life, not
    to mention actually flexing the backend functionality we built. Although this
    chapter has come to an end, this is by no means the last of us discovering and
    applying new programming patterns, should a need ever arise again to use one.
  prefs: []
  type: TYPE_NORMAL
- en: A good code-base is one that can handle new features and expansion of old ones
    with ease. The fruition of this chapter marks the point, at which the games we
    make are no longer bound to be simplistic due to design restrictions or inconvenient
    expansion. At this point, the question is no longer "How?", it's "Why not?" Seeing
    as you have made it this far, why not keep going? See you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
