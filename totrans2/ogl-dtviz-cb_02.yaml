- en: Chapter 2. OpenGL Primitives and 2D Data Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：OpenGL原语和二维数据可视化
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: OpenGL primitives
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL原语
- en: Creating a 2D plot using primitives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原语创建二维图表
- en: Real-time visualization of time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列的实时可视化
- en: 2D visualization of 3D/4D datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D/4D数据集的二维可视化
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we provided a sample code to render a triangle on the
    screen using OpenGL and the GLFW library. In this chapter, we will focus on the
    use of OpenGL primitives, such as points, lines, and triangles, to enable the
    basic 2D visualization of data, including time series such as an **electrocardiogram**
    (**ECG**). We will begin with an introduction to each primitive, along with sample
    code to allow readers to experiment with the OpenGL primitives with a minimal
    learning curve.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提供了一个示例代码，使用OpenGL和GLFW库在屏幕上渲染三角形。在本章中，我们将专注于使用OpenGL原语，如点、线和三角形，来实现数据的二维可视化，包括时间序列，如**心电图**（**ECG**）。我们将从介绍每个原语开始，并提供示例代码，以便读者可以以最小的学习曲线实验OpenGL原语。
- en: One can think of primitives as the fundamental building blocks to create graphics
    using OpenGL. These building blocks can be easily reused in many applications
    and are highly portable among different platforms. Frequently, programmers struggle
    with displaying their results in a visually appealing manner, and an enormous
    amount of time may be spent on performing simple drawing tasks on screen. In this
    chapter, we will introduce a rapid prototyping approach to 2D data visualization
    using OpenGL so that impressive graphics can be created with minimal efforts.
    Most importantly, the proposed framework is highly intuitive and reusable, and
    it can be extended to be used in more sophisticated applications. Once you have
    mastered the basics of the OpenGL language, you will be equipped with the skills
    to create impressive applications that harness the true potential of OpenGL for
    data visualization using modern graphics hardware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将原语视为使用OpenGL创建图形的基本构建块。这些构建块可以轻松地在许多应用程序中重用，并且在不同的平台之间具有高度的便携性。通常，程序员会为以视觉上吸引人的方式显示他们的结果而挣扎，并且可能会花费大量时间在屏幕上执行简单的绘图任务。在本章中，我们将介绍一种使用OpenGL进行二维数据可视化的快速原型设计方法，以便以最小的努力创建令人印象深刻的图形。最重要的是，所提出的框架非常直观且可重用，可以扩展用于更复杂的应用。一旦你掌握了OpenGL语言的基础，你将具备创建利用现代图形硬件OpenGL数据可视化真正潜力的令人印象深刻的技能。
- en: OpenGL primitives
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL原语
- en: 'In the simplest terms, primitives are just basic shapes that are drawn in OpenGL.
    In this section, we will provide a brief overview of the main geometric primitives
    that are supported by OpenGL and focus specifically on three commonly used primitives
    (which will also appear in our demo applications): points, lines, and triangles.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，原语只是OpenGL中绘制的基本形状。在本节中，我们将简要概述OpenGL支持的主要几何原语，并特别关注三种常用原语（这些原语也将出现在我们的演示应用中）：点、线和三角形。
- en: Drawing points
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制点
- en: 'We begin with a simple, yet very useful, building block for many visualization
    problems: a point primitive. A point can be in the form of ordered pairs in 2D,
    or it can be visualized in the 3D space.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从许多可视化问题的简单但非常有用的构建块开始：一个点原语。一个点可以是二维中的有序对，也可以在三维空间中可视化。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To simplify the workflow and improve the readability of the code, we first define
    a structure called `Vertex`, which encapsulates the fundamental elements such
    as the position and color of a vertex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化工作流程并提高代码的可读性，我们首先定义了一个名为`Vertex`的结构，它封装了基本元素，如顶点的位置和颜色。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we can treat every object and shape in terms of a set of vertices (with
    a specific color) in space. In this chapter, as our focus is on 2D visualization,
    the *z* positions of vertices are often manually set to `0.0f`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将每个对象和形状视为空间中一组顶点（具有特定颜色）。在本章中，由于我们的重点是二维可视化，顶点的*Z*位置通常手动设置为`0.0f`。
- en: 'We can create a vertex at the center of the screen (0, 0, 0) with a white color
    as an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个位于屏幕中心（0, 0, 0）的顶点，颜色为白色：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the color element consists of the red, green, blue, and alpha channels.
    These values range from 0.0 to 1.0\. The alpha channel allows us to create transparency
    (0: fully transparent; 1: fully opaque) so that objects can be blended together.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，颜色元素由红色、绿色、蓝色和alpha通道组成。这些值范围从0.0到1.0。alpha通道允许我们创建透明度（0：完全透明；1：完全不透明），以便对象可以混合在一起。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can first define a function called `drawPoint` to encapsulate the complexity
    of OpenGL primitive functions, illustrated as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先定义一个名为`drawPoint`的函数来封装OpenGL原始函数的复杂性，如下所示：
- en: 'Create a function called `drawPoint` to draw points which takes in two parameters
    (the vertex and size of the point):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`drawPoint`的函数来绘制点，该函数接受两个参数（顶点和点的大小）：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Specify the size of the point:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定点的大小：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set the beginning of the list of vertices to be specified and indicate the
    primitive type associated with the vertices (`GL_POINTS` in this case):'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要指定的顶点列表的起始位置，并指示与顶点关联的原始类型（在本例中为`GL_POINTS`）：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Set the color and the vertex position using the fields from the `Vertex` structure:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Vertex`结构中的字段设置颜色和顶点位置：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Set the end of the list:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置列表的结束：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition, we can define a function called `drawPointsDemo` to encapsulate
    the complexity further. This function draws a series of points with an increasing
    size:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还可以定义一个名为`drawPointsDemo`的函数来进一步封装复杂性。此函数绘制一系列大小递增的点：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, let''s integrate these two functions into a complete OpenGL demo program
    (refer to identical steps in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with OpenGL"), *Getting Started withOpenGL*):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将这些函数集成到一个完整的OpenGL演示程序中（参考[第1章](ch01.html "第1章. 开始使用OpenGL")中的相同步骤，*开始使用OpenGL*）：
- en: 'Create a source file called `main_point.cpp`, and then include the header file
    for the GLFW library and standard C++ libraries:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main_point.cpp`的源文件，然后包含GLFW库和标准C++库的头文件：
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the size of the window for display:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义显示的窗口大小：
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `Vertex` structure and function prototypes:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Vertex`结构和函数原型：
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implement the `drawPoint` and `drawPointsDemo` functions, as shown previously.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现之前显示的`drawPoint`和`drawPointsDemo`函数。
- en: 'Initialize GLFW and create a GLFW window object:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化GLFW并创建一个GLFW窗口对象：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable anti-aliasing and smoothing:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用抗锯齿和平滑处理：
- en: '[PRE12]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define a loop that terminates when the window is closed. Set up the viewport
    (using the size of the window) and clear the color buffer at the beginning of
    each iteration to update with new content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个循环，当窗口关闭时终止。在每个迭代开始时设置视口（使用窗口的大小）并清除颜色缓冲区以更新新内容：
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Set up the camera matrix for orthographic projection:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置用于正交投影的相机矩阵：
- en: '[PRE14]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Call the `drawPointsDemo` function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`drawPointsDemo`函数：
- en: '[PRE15]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Swap the front and back buffers of the window and process the event queue (such
    as keyboard inputs) to avoid lock-up:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换窗口的前后缓冲区并处理事件队列（如键盘输入）以避免锁定：
- en: '[PRE16]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Release the memory and terminate the GLFW library. Then, exit the application:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放内存并终止GLFW库。然后，退出应用程序：
- en: '[PRE17]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the result (with anti-aliasing disabled) showing a series of points
    with an increasing size (that is, the diameter of each point as specified by `glPointSize`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果（禁用抗锯齿）显示一系列大小递增的点（即，每个点的大小由`glPointSize`指定）：
- en: '![How to do it…](img/9727OS_02_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_02_01.jpg)'
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `glBegin` and `glEnd` functions delimit the list of vertices corresponding
    to a desired primitive (`GL_POINTS` in this demo). The `glBegin` function accepts
    a set of symbolic constants that represent different drawing methods, including
    `GL_POINTS`, `GL_LINES`, and `GL_TRIANGLES`, as discussed in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`glBegin`和`glEnd`函数定义了与所需原始类型（在本演示中为`GL_POINTS`）对应的顶点列表。`glBegin`函数接受一组符号常量，代表不同的绘图方法，包括`GL_POINTS`、`GL_LINES`和`GL_TRIANGLES`，如本章所述。'
- en: There are several ways to control the process of drawing points. First, we can
    set the diameter of each point (in pixels) with the `glPointSize` function. By
    default, a point has a diameter of 1 without anti-aliasing (a method to smooth
    sampling artifacts) enabled. Also, we can define the color of each point as well
    as the alpha channel (transparency) using the `glColor4f` function. The alpha
    channel allows us to overlay points and blend graphics elements. This is a powerful,
    yet very simple, technique used in graphics design and user interface design.
    Lastly, we define the position of the point in space with the `glVertex3f` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以控制绘制点的过程。首先，我们可以使用`glPointSize`函数设置每个点的直径（以像素为单位）。默认情况下，一个点没有启用抗锯齿（一种平滑采样伪影的方法）时，直径为1。此外，我们还可以使用`glColor4f`函数定义每个点的颜色以及alpha通道（透明度）。alpha通道允许我们叠加点和混合图形元素。这是一种强大而简单的技术，在图形设计和用户界面设计中得到广泛应用。最后，我们使用`glVertex3f`函数定义点在空间中的位置。
- en: 'In OpenGL, we can define the projection transformation in two different ways:
    orthographic projection or perspective projection. In 2D drawing, we often use
    orthographic projection which involves no perspective correction (for example,
    the object on screen will remain the same size regardless of its distance from
    the camera). In 3D drawing, we use perspective projection to create more realistic-looking
    scenes similar to how the human eye sees. In the code, we set up an orthographic
    projection with the `glOrtho` function. The `glOrtho` function takes these parameters:
    the coordinates of the vertical clipping plane, the coordinates of the horizontal
    clipping plane, and the distance of the nearer and farther depth clipping planes.
    These parameters determine the projection matrix, and the detailed documentation
    can be found in [https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，我们可以以两种不同的方式定义投影变换：正交投影或透视投影。在2D绘图时，我们通常使用正交投影，它不涉及透视校正（例如，屏幕上的对象将保持相同的大小，无论其与摄像机的距离如何）。在3D绘图时，我们使用透视投影来创建更逼真的场景，类似于人眼看到的场景。在代码中，我们使用`glOrtho`函数设置正交投影。`glOrtho`函数接受以下参数：垂直裁剪平面的坐标、水平裁剪平面的坐标以及近裁剪面和远裁剪面的距离。这些参数确定投影矩阵，详细文档可以在[https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html)找到。
- en: 'Anti-aliasing and smoothing are necessary to produce the polished look seen
    in modern graphics. Most graphics cards support native smoothing and in OpenGL,
    it can be enabled as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿和平滑处理是产生现代图形中看到的精致外观所必需的。大多数显卡支持原生平滑处理，在OpenGL中，可以通过以下方式启用：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the final result with anti-aliasing enabled, showing a series of circular
    points with an increasing size:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启用抗锯齿后的最终结果，显示了一系列大小递增的圆形点：
- en: '![How it works…](img/9727OS_02_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/9727OS_02_02.jpg)'
- en: Note that in the preceding diagram, the points are now rendered as circles instead
    of squares with the anti-aliasing feature enabled. Readers are encouraged to disable
    and enable the features of the preceding diagram to see the effects of the operation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图中，由于启用了抗锯齿功能，点现在被渲染为圆形而不是正方形。鼓励读者禁用和启用前面图的特性，以查看操作的效果。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this tutorial, we have focused on the C programming style due to its simplicity.
    In the upcoming chapters, we will migrate to an object-oriented programming style
    using C++. In addition, in this chapter, we focus on three basic primitives (and
    discuss the derivatives of these primitives where appropriate): `GL_POINTS`, `GL_LINES`,
    and `GL_TRIANGLES`. Here is a more extensive list of primitives supported by OpenGL
    (refer to [https://www.opengl.org/wiki/Primitive](https://www.opengl.org/wiki/Primitive)
    for more information):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们由于其简洁性而专注于C编程风格。在接下来的章节中，我们将迁移到使用C++的面向对象编程风格。此外，在本章中，我们关注三个基本原语（并在适当的地方讨论这些原语的导数）：`GL_POINTS`、`GL_LINES`和`GL_TRIANGLES`。以下是OpenGL支持的原语更详尽的列表（有关更多信息，请参阅[https://www.opengl.org/wiki/Primitive](https://www.opengl.org/wiki/Primitive)）：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Drawing line segments
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制线段
- en: One natural extension now is to connect a line between data points and then
    to connect the lines together to form a grid for plotting. In fact, OpenGL natively
    supports drawing line segments, and the process is very similar to that of drawing
    a point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的一个自然扩展是连接数据点之间的线，然后将这些线连接起来形成一个用于绘图的网格。实际上，OpenGL原生支持绘制线段，其过程与绘制点非常相似。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In OpenGL, we can simply define a line segment with a set of 2 vertices, and
    a line will be automatically formed between them by choosing `GL_LINES` as the
    symbolic constant in the `glBegin` statement.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，我们可以通过一组两个顶点简单地定义一个线段，并通过在 `glBegin` 语句中选择 `GL_LINES` 作为符号常量来自动在这两个顶点之间形成一条线。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we define a new line drawing function called `drawLineSegment` which
    users can test by simply replacing the `drawPointsDemo` function in the previous
    section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的线段绘制函数，称为 `drawLineSegment`，用户可以通过简单地替换前一部分中的 `drawPointsDemo`
    函数来测试它：
- en: 'Define the `drawLineSegment` function which takes in two vertices and the width
    of the line as inputs:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `drawLineSegment` 函数，它接受两个顶点和线的宽度作为输入：
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Set the width of the line:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置线的宽度：
- en: '[PRE21]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set the primitive type for line drawing:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置线段绘制的原语类型：
- en: '[PRE22]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set the vertices and the color of the line:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置线段的顶点和颜色：
- en: '[PRE23]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In addition, we define a new grid drawing function called `drawGrid`, built
    on top of the `drawLineSegment` function as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个新的网格绘制函数，称为 `drawGrid`，它基于 `drawLineSegment` 函数如下：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can execute the full demo by replacing the call for the `drawPointsDemo`
    function in the previous section with the following `drawLineDemo` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过替换前一部分中对 `drawPointsDemo` 函数的调用，使用以下 `drawLineDemo` 函数来执行完整的演示：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is a screenshot of the demo showing a grid with equal spacing and the
    *x* and *y* axes drawn with the line primitives:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张演示截图，显示了具有等间距的网格以及使用线原语绘制的 *x* 和 *y* 轴：
- en: '![How to do it…](img/9727OS_02_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9727OS_02_03.jpg)'
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: There are multiple ways of drawing line segments in OpenGL. We have demonstrated
    the use of `GL_LINES` which takes every consecutive pair of vertices in the list
    to form an independent line segment for each pair. On the other hand, if you would
    like to draw a line without gaps, you can use the `GL_LINE_STRIP` option, which
    connects all the vertices in a consecutive fashion. Finally, to form a closed
    loop sequence in which the endpoints of the lines are connected, you would use
    the `GL_LINE_LOOP` option.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中绘制线段有多种方式。我们已经展示了使用 `GL_LINES` 的用法，它将列表中的每个连续顶点对组合成独立的线段。另一方面，如果您想绘制没有间隙的线，可以使用
    `GL_LINE_STRIP` 选项，它以连续的方式连接所有顶点。最后，为了形成一个闭合的循环序列，其中线的端点被连接，您将使用 `GL_LINE_LOOP`
    选项。
- en: In addition, we can modify the width and the color of a line with the `glLineWidth`
    and `glColor4f` functions for each vertex, respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `glLineWidth` 和 `glColor4f` 函数分别修改每条线的宽度和颜色。
- en: Drawing triangles
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制三角形
- en: We will now move on to another very commonly used primitive, namely a triangle,
    which forms the basis for drawing all possible polygons.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转到另一个非常常用的原语，即三角形，它是绘制所有可能多边形的基础。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Similar to drawing a line segment, we can simply define a triangle with a set
    of 3 vertices, and line segments will be automatically formed by choosing `GL_TRIANGLES`
    as the symbolic constant in the `glBegin` statement.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与绘制线段类似，我们可以简单地通过一组三个顶点定义一个三角形，并通过在 `glBegin` 语句中选择 `GL_TRIANGLES` 作为符号常量来自动形成线段。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Finally, we define a new function called `drawTriangle`, which users can test
    by simply replacing the `drawPointsDemo` function. We will also reuse the `drawGrid`
    function from the previous section:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个新的函数，称为 `drawTriangle`，用户可以通过简单地替换 `drawPointsDemo` 函数来测试它。我们还将重用前一部分中的
    `drawGrid` 函数：
- en: 'Define the `drawTriangle` function, which takes in three vertices as the input:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `drawTriangle` 函数，它接受三个顶点作为输入：
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Set the primitive type to draw triangles:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绘图原语类型设置为绘制三角形：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set the vertices and the color of the triangle:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置三角形的顶点和颜色：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Execute the demo by replacing the call for the `drawPointsDemo` function in
    the full demo code with the following `drawTriangleDemo` function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用以下 `drawTriangleDemo` 函数替换完整演示代码中对 `drawPointsDemo` 函数的调用来执行演示：
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the final result with a triangle rendered with 60 percent transparency
    overlaid on top of the grid lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最终结果，三角形以60%的透明度叠加在网格线上渲染：
- en: '![How to do it…](img/9727OS_02_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9727OS_02_04.jpg)'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'While the process of drawing a triangle in OpenGL appears similar to previous
    examples, there are some subtle differences and further complexities that can
    be incorporated. There are three different modes in this primitive (`GL_TRIANGLES`,
    `GL_TRIANGLE_STRIP`, and `GL_TRIANGLE_FAN`), and each handles the vertices in
    a different manner. First, `GL_TRIANGLES` takes three vertices from a given list
    to create a triangle. The triangles are independently formed from each triplet
    of the vertices (that is, every three vertices are turned into a different triangle).
    On the other hand, `GL_TRIANGLE_STRIP` forms a triangle with the first three vertices,
    and each subsequent vertex forms a new triangle using the previous two vertices.
    Lastly, `GL_TRIANGLE_FAN` creates an arbitrarily complex convex polygon by creating
    triangles that have a common vertex in the center specified by the first vertex
    v_1, which forms a fan-shaped structure consisting of triangles. In other words,
    triangles will be generated in the grouping order specified as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在OpenGL中绘制三角形的流程看起来与之前的示例相似，但其中存在一些细微的差异和更复杂的方面可以融入。这个原始形状有三种不同的模式（`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`和`GL_TRIANGLE_FAN`），每种模式以不同的方式处理顶点。首先，`GL_TRIANGLES`从一个给定的列表中取出三个顶点来创建一个三角形。这些三角形独立地从每个顶点三元组形成（也就是说，每个三个顶点形成一个不同的三角形）。另一方面，`GL_TRIANGLE_STRIP`使用前三个顶点形成一个三角形，每个后续的顶点使用前两个顶点形成一个新的三角形。最后，`GL_TRIANGLE_FAN`通过创建具有中心顶点v_1的三角形来创建一个任意复杂的凸多边形，这个中心顶点由第一个顶点指定，形成一个由三角形组成的扇形结构。换句话说，三角形的生成顺序如下所示：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although a different color is set for each vertex, OpenGL handles color transition
    (linear interpolation) automatically, as shown in the triangle drawing in the
    previous example. The vertices are set to red, green, and blue, but the spectrum
    of colors can be clearly seen. Additionally, transparency can be set using the
    alpha channel, which enables us to clearly see the grid behind the triangle. With
    OpenGL, we can also add other elements, such as the advanced handling of color
    and shading, which will be discussed in the upcoming chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个顶点都设置了不同的颜色，但OpenGL会自动处理颜色过渡（线性插值），如前一个示例中的三角形绘制所示。顶点被设置为红色、绿色和蓝色，但颜色的光谱可以清晰地看到。此外，可以使用alpha通道设置透明度，这使得我们可以清楚地看到三角形后面的网格。使用OpenGL，我们还可以添加其他元素，例如高级的颜色和阴影处理，这些内容将在接下来的章节中讨论。
- en: Creating a 2D plot using primitives
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始形状创建2D图
- en: Creating a 2D plot is a common way of visualizing trends in datasets in many
    applications. With OpenGL, we can render such plots in a much more dynamic way
    compared to conventional approaches (such as basic MATLAB plots) as we can gain
    full control over the graphics shader for color manipulation and we can also provide
    real-time feedback to the system. These unique features allow users to create
    highly interactive systems, so that, for example, time series such as an electrocardiogram
    can be visualized with minimal effort.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建2D图是许多应用中可视化数据集中趋势的常见方式。与传统的做法（如基本的MATLAB绘图）相比，使用OpenGL可以以更动态的方式渲染此类图表，因为我们能够完全控制图形着色器进行颜色操作，我们还可以向系统提供实时反馈。这些独特的功能使用户能够创建高度交互的系统，例如，心电图等时间序列可以以最小的努力进行可视化。
- en: Here, we first demonstrate the visualization of a simple 2D dataset, namely
    a sinusoidal function in discrete time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先演示了简单2D数据集的可视化，即离散时间上的正弦函数。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This demo requires a number of functions (including the `drawPoint`, `drawLineSegment`,
    and `drawGrid` functions) implemented earlier. In addition, we will reuse the
    code structure introduced in the [Chapter 1](ch01.html "Chapter 1. Getting Started
    with OpenGL"), *Getting Started with OpenGL* to execute the demo.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示需要实现之前提到的多个函数（包括`drawPoint`、`drawLineSegment`和`drawGrid`函数）。此外，我们将重用[第1章](ch01.html
    "第1章. 使用OpenGL入门")中引入的代码结构，即*使用OpenGL入门*，以执行此演示。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We begin by generating a simulated data stream for a sinusoidal function over
    a time interval. In fact, the data stream can be any arbitrary signal or relationship:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先生成一个在时间间隔上正弦函数的模拟数据流。实际上，数据流可以是任何任意的信号或关系：
- en: 'Let''s define an additional structure called `Data` to simplify the interface:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个额外的结构体 `Data` 以简化接口：
- en: '[PRE31]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define a generic 2D data plotting function called `draw2DscatterPlot` with
    the input data stream and number of points as the input:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `draw2DscatterPlot` 的通用 2D 数据绘图函数，输入数据流和点数作为输入：
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Draw the *x* and *y* axes using the `drawLineSegment` function described earlier:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面描述的 `drawLineSegment` 函数绘制 *x* 和 *y* 轴：
- en: '[PRE33]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Draw the data points one by one with the `drawPoint` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `drawPoint` 函数逐个绘制数据点：
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a similar function called `draw2DlineSegments` to connect the dots together
    with the line segments so that both the curve and the data points can be shown
    simultaneously:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `draw2DlineSegments` 的类似函数，以便使用线段连接点，从而同时显示曲线和数据点：
- en: '[PRE35]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Integrate everything into a full demo by creating the grid, generating the
    simulated data points using a cosine function and plotting the data points:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建网格、使用余弦函数生成模拟数据点并绘制数据点，将所有内容集成到一个完整的演示中：
- en: '[PRE36]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, in the main program, include the `math.h` header file for the cosine
    function and add a new variable called `phase_shift` outside the loop to execute
    this demo. You can download the code package from Packt Publishing website for
    the complete demo code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在主程序中，包含 `math.h` 头文件以使用余弦函数，并在循环外部添加一个名为 `phase_shift` 的新变量来执行此演示。您可以从 Packt
    Publishing 网站下载代码包以获取完整的演示代码：
- en: '[PRE37]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The final result simulating a real-time input data stream with a sinusoidal
    shape is plotted on top of grid lines using a combination of basic primitives
    discussed in previous sections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前几节讨论的基本原语组合，将模拟的实时输入数据流（具有正弦形状）绘制在网格线上：
- en: '![How to do it…](img/9727OS_02_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9727OS_02_05.jpg)'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Using the simple toolkit we created earlier using basic OpenGL primitives, we
    plotted a sinusoidal function with the data points (sampled at a constant time
    interval) overlaid on top of the curve. The smooth curve consists of many individual
    line segments drawn using the `draw2DlineSegments` function, while the samples
    were plotted using the `drawPoint` function. This intuitive interface serves as
    the basis for the visualization of more interesting time series for real-world
    applications in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前使用基本 OpenGL 原语创建的简单工具包，我们绘制了一个正弦函数，数据点（以恒定的时间间隔采样）叠加在曲线上。平滑的曲线由使用 `draw2DlineSegments`
    函数绘制的许多单独线段组成，而样本则是使用 `drawPoint` 函数绘制的。这种直观的界面为下一节中更有趣的时序可视化提供了基础。
- en: Real-time visualization of time series
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的实时可视化
- en: In this section, we further demonstrate the versatility of our framework to
    plot general time series data for biomedical applications. In particular, we will
    display an ECG in real time. As a brief introduction, an ECG is a very commonly
    used diagnostic and monitoring tool to detect abnormalities in the heart. ECG
    surface recording essentially probes the electrical activities of the heart. For
    example, the biggest spike (called a QRS complex) typically corresponds to the
    depolarization of the ventricles of the heart (the highly muscular chambers of
    the heart that pump blood). A careful analysis of the ECGcan be a very powerful,
    noninvasive method for distinguishing many heart diseases clinically, including
    many forms of arrhythmia and heart attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们进一步展示了我们框架的通用性，以绘制生物医学应用中的通用时间序列数据。特别是，我们将实时显示 ECG。作为简要介绍，ECG 是一种非常常用的诊断和监测工具，用于检测心脏异常。ECG
    表面记录本质上探测心脏的电活动。例如，最大的峰值（称为 QRS 复合波）通常对应于心脏的室壁去极化（心脏中泵血的强肌肉室腔）。对 ECG 的仔细分析可以是一种非常强大、非侵入性的方法，用于在临床上区分许多心脏病，包括许多形式的心律失常和心脏病发作。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We begin by importing a computer-generated ECG data stream. The ECG data stream
    is stored in `data_ecg.h` (only a small portion of the data stream is provided
    here):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入一个计算机生成的 ECG 数据流。ECG 数据流存储在 `data_ecg.h` 中（这里只提供了数据流的一小部分）：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Use the following code to plot the ECG data by drawing line segments:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过绘制线段来绘制 ECG 数据：
- en: '[PRE39]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Display multiple ECG data streams (simulating recording from different leads):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示多个 ECG 数据流（模拟来自不同导联的记录）：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, in the main program, include the `data_ecg.h` header file and add
    the following lines of code to the loop. You can download the code package from
    the Packt Publishing website for the complete demo code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在主程序中，包含`data_ecg.h`头文件，并在循环中添加以下代码行。您可以从Packt Publishing网站下载完整的演示代码包：
- en: '[PRE41]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here are two snapshots of the real-time display across multiple ECG leads simulated
    at two different time points. If you execute the demo, you will see the ECG recording
    from multiple leads move across the screen as the data stream is processed for
    display.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个在不同时间点模拟的多个ECG导联的实时显示快照。如果您运行演示，您将看到来自多个导联的ECG记录随着数据流处理显示而移动穿过屏幕。
- en: '![How to do it…](img/9727OS_02_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![How to do it…](img/9727OS_02_06.jpg)'
- en: 'Here is the second snapshot at a later time point:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是稍后时间点的第二个快照：
- en: '![How to do it…](img/9727OS_02_07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![How to do it…](img/9727OS_02_07.jpg)'
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This demo shows the use of the `GL_LINE_STRIP` option, described previously,
    to plot an ECG time series. Instead of drawing individual and independent line
    segments (using the `GL_LINE` option), we draw a continuous stream of data by
    calling the `glVertex3f` function for each data point. Additionally, the time
    series animates through the screen and provides dynamic updates on an interactive
    frame with minimal impact on the CPU computation cycles.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示展示了之前描述的`GL_LINE_STRIP`选项的使用，用于绘制ECG时间序列。我们不是使用`GL_LINE`选项绘制单个独立的线段，而是通过为每个数据点调用`glVertex3f`函数来绘制连续的数据流。此外，时间序列通过屏幕动画，并在交互式帧上提供动态更新，对CPU计算周期的影响最小。
- en: 2D visualization of 3D/4D datasets
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D visualization of 3D/4D datasets
- en: 'We have now learned multiple methods to generate plots on screen using points
    and lines. In the last section, we will demonstrate how to visualize a million
    data points in a 3D dataset using OpenGL in real time. A common strategy to visualize
    a complex 3D dataset is to encode the third dimension (for example, the *z* dimension)
    in the form of a heat map with a desirable color scheme. As an example, we show
    a heat map of a 2D Gaussian function with its height *z*, encoded using a simple
    color scheme. In general, a 2-D Gaussian function, ![2D visualization of 3D/4D
    datasets](img/9727OS_02_10.jpg), is defined as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了多种在屏幕上使用点和线生成图表的方法。在最后一节中，我们将演示如何使用OpenGL实时可视化3D数据集中的百万个数据点。可视化复杂3D数据集的常见策略是将第三维（例如，*z*
    维度）编码为具有理想颜色方案的热图。作为一个例子，我们展示了一个2D高斯函数及其高度 *z* 的热图，使用简单的颜色方案编码。一般来说，一个二维高斯函数，![2D
    visualization of 3D/4D datasets](img/9727OS_02_10.jpg)，定义如下：
- en: '![2D visualization of 3D/4D datasets](img/9727OS_02_09.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![2D visualization of 3D/4D datasets](img/9727OS_02_09.jpg)'
- en: Here, *A* is the amplitude (![2D visualization of 3D/4D datasets](img/9727OS_02_9a.jpg))
    of the distribution centered at ![2D visualization of 3D/4D datasets](img/9727OS_02_11.jpg)
    and ![2D visualization of 3D/4D datasets](img/9727OS_02_12.jpg) are the standard
    deviations (spread) of the distribution in the *x* and *y* directions. To make
    this demo more interesting and more visually appealing, we vary the standard deviation
    or sigma term (equally in the *x* and *y* directions) over time. Indeed, we can
    apply the same method to visualize very complex 3D datasets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*A* 是分布中心在 ![2D visualization of 3D/4D datasets](img/9727OS_02_9a.jpg) 的振幅，![2D
    visualization of 3D/4D datasets](img/9727OS_02_11.jpg) 和 ![2D visualization of
    3D/4D datasets](img/9727OS_02_12.jpg) 是分布沿 *x* 和 *y* 方向的标准差（分散度）。为了使这个演示更加有趣和更具视觉吸引力，我们随时间变化标准差或sigma项（在
    *x* 和 *y* 方向上相等）。实际上，我们可以应用相同的方法来可视化非常复杂的3D数据集。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By now, you should be very familiar with the basic primitives described in previous
    sections. Here, we employ the `GL_POINTS` option to generate a dense grid of data
    points with different colors encoding the *z* dimension.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经非常熟悉前几节中描述的基本原语了。在这里，我们使用`GL_POINTS`选项生成具有不同颜色编码 *z* 维度的密集数据点网格。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: How to do it…
- en: 'Generate a million data points (1,000 x 1,000 grid) with a 2-D Gaussian function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用2-D高斯函数生成一百万个数据点（1,000 x 1,000网格）：
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Draw the data points using a heat map function for color visualization:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用热图函数绘制数据点以进行颜色可视化：
- en: '[PRE43]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, in the main program, include the `math.h` header file and add the
    following lines of code to the loop to vary the sigma term over time. You can
    download the example code from the Packt Publishing website for the complete demo
    code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在主程序中，包含`math.h`头文件，并在循环中添加以下代码行以随时间变化sigma项。您可以从Packt Publishing网站下载示例代码以获取完整的演示代码：
- en: '[PRE44]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here are four figures illustrating the effect of varying the sigma term of
    the 2-D Gaussian function over time (from 0.01 to 1):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了四个图表，说明了随时间变化（从0.01到1）调整二维高斯函数的sigma项的效果：
- en: '![How to do it…](img/9727OS_02_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/9727OS_02_08.jpg)'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have demonstrated how to visualize a Gaussian function using a simple heat
    map in which the maximum value is represented by red, while the minimum value
    is represented by blue. In total, a million data points (1,000 x 1,000) were plotted
    using vertices for each Gaussian function with a specific sigma term. This sigma
    term was varied from 0.01 to 1 to show a time-varying Gaussian distribution. To
    reduce the overhead, vertex buffers can be implemented in the future (we can perform
    the memory copy operation all at once and remove the `glVertex3f` calls). Similar
    techniques can be applied to the color channel as well.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用简单的热图来可视化高斯函数，其中最大值用红色表示，而最小值用蓝色表示。总共绘制了100万个数据点（1,000 x 1,000），每个高斯函数使用具有特定sigma项的顶点进行绘制。这个sigma项从0.01变化到1，以展示随时间变化的高斯分布。为了减少开销，未来可以实施顶点缓冲区（我们可以一次性执行内存复制操作并移除`glVertex3f`调用）。类似的技巧也可以应用于颜色通道。
- en: There's more…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The heat map we have described here provides a powerful visualization tool for
    complex 3D datasets seen in many scientific and biomedical applications. Indeed,
    we have actually extended our demo to the visualization of a 4D dataset, to be
    precise, since a time-varying 3D function; with the height encoded using a color
    map was displayed. This demo shows the many possibilities for displaying data
    in an interesting, dynamic way using just 2D techniques based on OpenGL primitives.
    In the next chapter, we will demonstrate the potential of OpenGL further by incorporating
    3D rendering and adding user inputs to enable the 3D, interactive visualization
    of more complex datasets.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的热图提供了一种强大的可视化工具，用于展示许多科学和生物医学应用中看到的复杂3D数据集。实际上，我们已经将我们的演示扩展到了4D数据集的可视化，更确切地说，是一个随时间变化的3D函数；使用颜色图编码高度值被显示出来。这个演示展示了仅使用基于OpenGL原语的2D技术以有趣、动态的方式展示数据的多重可能性。在下一章中，我们将通过结合3D渲染并添加用户输入来进一步展示OpenGL的潜力，从而实现更复杂数据集的3D交互式可视化。
