- en: Chapter 3. C Basics – Making You Stronger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C programming isn't that hard. But it requires enough work at the beginning.
    Fortunately, I'm with you and we have a very good friend since three chapters
    – our Arduino board. We will now go deep into the C language, and I'll do my best
    to be more concrete and not abstract.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and the next one are truly C language-oriented because the Arduino
    program design requires knowledge in programming logic statements. After these
    two chapters, you'll be able to read any code in this book; these strong basics
    will also help you in further projects, even those not related to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: I will also progressively introduce new concepts that we will use later, such
    as functions. Don't be afraid if you don't understand it that well, I like my
    students to hear some words progressively sometimes even without a proper definition
    at first, because it helps further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: So if I don't define it but talk about it, just relax, explanations are going
    to come further. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Approaching variables and types of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already used variables in the previous chapters' examples. Now, let's understand
    this concept better.
  prefs: []
  type: TYPE_NORMAL
- en: What is a variable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **variable** is a memory storage location bounded to a symbolic name. This
    reserved memory area can be filled or left empty. Basically, it is used to store
    different types of values. We used the variable `ledPin` in our previous examples,
    with the keyword `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Something very useful with variables is the fact that we can change their content
    (the value) at runtime; this is also why they are called variables, compared to
    constants that also store values, but that cannot be changed while the program
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: What is a type?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables (and constants) are associated with a type. A type, also called **data
    type**, defines the possible nature of data. It also offers a nice way to directly
    reserve a space with a defined size in memory. C has around 10 main types of data
    that can be extended as we are going to see here.
  prefs: []
  type: TYPE_NORMAL
- en: I'm deliberately only explaining the types we'll use a lot in Arduino programming.
    This fits with approximately 80 percent of other usual C data types and will be
    more than enough here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we are using a type when we declare a variable as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A space of a particular size (the size related to the `int` type) is reserved
    in memory, and, as you can see, if you only write that line, there is still no
    data stored in that variable. But keep in mind that a memory space is reserved,
    ready to be used to store values.
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Definition | Size in memory |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | This particular type is used only in *function* declarations and
    while defining pointers with unknown types. We''ll see that in the next chapter.
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | It stores `false` or `true`. | 1 byte (8 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | It stores single-quoted characters such as `''a''` as *numbers*,
    following the ASCII chart ([http://en.wikipedia.org/wiki/ASCII_chart](http://en.wikipedia.org/wiki/ASCII_chart)).It
    is a *signed* type and stores numbers from -128 to 127; it can be unsigned and
    then stores numbers from 0 to 255. | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | It stores numbers as *8-bit unsigned* data that means from 0 to
    255. | 8 bits |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | It stores numbers as *2-bytes signed* data which means from -32,768
    to 32,767 it can also be unsigned and then store numbers from 0 to 65,535. | 2
    bytes (16 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `word` | It stores numbers as *2-bytes unsigned* data exactly as *unsigned*
    `int` does. | 2 bytes (16 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | It stores numbers as *4-bytes signed* data, which means from -2,147,483,648
    to 2,147,483,647 and can be unsigned and then stores numbers from 0 to 4,294,967,295.
    | 4 bytes (32 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | It basically stores numbers with a decimal point from -3.4028235E
    + 38 to 3.4028235E + 38 as *4-bytes signed* data.Be careful of the required precision;
    they only have six to seven decimal digits and can give strange rounding results
    sometimes. | 4 bytes (32 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | It generally stores `float` values with a precision two times
    greater than the `float` value.Be careful, in the Arduino IDE and the board, the
    `double` implementation is exactly the same as `float`; that means with only six
    to seven decimal digits of precision. | 4 bytes (32 bit) |'
  prefs: []
  type: TYPE_TB
- en: '| Array | Array is an ordered structure of consecutive elements of the same
    type that can each be accessed with an index number. | number of elements x size
    of elements'' type |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | It stores text strings in an array of `char` where the last element
    is `null` that is a particular character (ASCII code 0). Be careful of the "s"
    in lower case at the beginning of `string`. | number of elements * 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | It is a particular structure of data, namely a class, that provides
    a nice way to use and work with strings of text.It comes with methods/functions
    to easily concatenate strings, split strings, and much more. Be careful of the
    capital "S" at the beginning of `String`. | available every time with the `length()`
    method |'
  prefs: []
  type: TYPE_TB
- en: The roll over/wrap concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you go beyond the possible bounds of a type, the variable rolls over to the
    other side of the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It happens in both directions, subtracting `1` from an `int` variable storing
    `-32768` results in `32767`. Keep that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and defining variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to describe how to declare then define variables and learn how
    to do both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Declaration of a variable is a statement in which you specify an *identifier*,
    a *type*, and eventually the variable's dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: An identifier is what we call the *name of the variable*. You know what the
    type is too. The dimensions are useful for arrays, for instance, but also for
    `String` (which are processed as arrays internally).
  prefs: []
  type: TYPE_NORMAL
- en: In C and all other strongly-typed languages such as Java and Python, we *must*
    declare variables before using them. Anyway, the compiler will complain in case
    you forget the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table contains some examples of variable definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `char` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `byte` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `int` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `word` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `long` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `float` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `double` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Array |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `string` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a variable is the act of assigning a value to the memory area previously
    reserved for that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's declare and define some variables of each type. I have put some explanations
    in the code's comments.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples you can use, but you'll see in each piece of code given
    in this book that different types of declaration and definition are used. You'll
    be okay with that as soon as we'll wire the board.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig a bit more into the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `String` type deserves a entire subchapter because it is a bit more than
    a type. Indeed, it is an object (in the sense of object-oriented programming).
  prefs: []
  type: TYPE_NORMAL
- en: Objects come with special properties and functions. Properties and functions
    are available natively because `String` is now a part of the Arduino core and
    can be seen as a pre-existing entity even if your IDE contains no line.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the framework takes care of things for you, providing you a type/object
    with powerful and already coded functions that are directly usable.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [http://arduino.cc/en/Reference/StringObject](http://arduino.cc/en/Reference/StringObject)
    in the Arduino website.
  prefs: []
  type: TYPE_NORMAL
- en: String definition is a construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about definition for variables, but objects have a similar concept
    called **construction**.
  prefs: []
  type: TYPE_NORMAL
- en: For `String` objects, I'm talking about *construction* instead of *definition*
    here but you can consider both terms equal. Declaring a `String` type in Arduino
    core involves an object constructor, which is an object-oriented programming concept;
    we don't have to handle it, fortunately, at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using indexes and search inside String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Strings` are arrays of `char` elements. This means we can access any element
    of a `String` type through their indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that indexes start at `0` and not at `1`. The `String` objects
    implement some functions for this particular purpose.
  prefs: []
  type: TYPE_NORMAL
- en: charAt()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering a `String` type is declared and defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement `myString.charAt(3)` returns the fourth element of the string
    that is: `l`. Notice the specific notation used here: we have the name of the
    `String` variable, a dot, then the name of the function (which is a method of
    the `String` object), and the parameter `3` which is passed to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `charAt()` function returns a character at a particular position inside
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.charAt(int);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` is an integer representing an index of the `String` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `char`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about other similar functions. You'll use them very often because,
    as we have already seen, communicating at a very low-level point of view includes
    parsing and processing data, which can very often be strings.
  prefs: []
  type: TYPE_NORMAL
- en: indexOf() and lastIndexOf()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider the same declaration/definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`myString.indexOf(''r'')` equals `8`. Indeed, `r` is at the ninth place of
    the value of the string`myString`. `indexOf(val)` and looks for the first occurrence
    of the value `val`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to begin your search from a particular point, you can specify a
    start point like that: `indexOf(val,start`), where `start` is the index from where
    the function begins to search for the character `val` in the string. As you have
    probably understood, the second argument of this function (`start`) can be omitted,
    the search starts from the first element of the string by default, which is `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `indexOf()` function returns the first occurrence of a string or character
    inside a string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.indexOf(val, from);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val` is the value to search for which can be a string or a character. `from`
    is the index to start the search from, which is an `int` type. This argument can
    be omitted. The search goes forward.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `int`'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `lastIndexOf(val,start)` looks for the last occurrence of `val`,
    searching **backwards** from `start`, or from the last element if you omit `start`.
  prefs: []
  type: TYPE_NORMAL
- en: The `lastIndexOf()` function returns the last occurrence of a string or character
    inside a string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Syntax**: `string.lastIndexOf(val, from);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val` is the value to search for which is a string or a character. `from` is
    the index to start the search from which is an `int` type. This argument can be
    omitted. The search goes backwards.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `int`'
  prefs: []
  type: TYPE_NORMAL
- en: startsWith() and endsWith()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `startsWith()` and `endsWith()` functions check whether a string starts
    or ends with, respectively, another string passed as an argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `startsWith()` function returns `true` if a string starts with the same
    characters as another string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.startsWith(string2);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string2` is the string pattern with which you want to test the string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `boolean`'
  prefs: []
  type: TYPE_NORMAL
- en: I guess, you have begun to understand right now. `endsWith()` works like that
    too, but compares the string pattern with the end of the string tested.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `endsWith()` function returns `true` if a string ends with the same characters
    as another string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.endsWith(string2);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string2` is the string pattern with which you want to test the string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `boolean`'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation, extraction, and replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding operations also introduce new C operators. I'm using them here
    with strings but you'll learn a bit more about them in a more global context further.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Concatenation of strings is an operation in which you take two strings and you
    glue them together. It results in a new string composed of the previous two strings.
    The order is important; you have to manage which string you want appended to the
    end of the other.
  prefs: []
  type: TYPE_NORMAL
- en: Concat()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arduino core comes with the `string.concat()` function, which is especially
    designed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `concat()` function appends one string to another (that is concatenate in
    a defined order).
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.concat(string2);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string2` is a string and is appended to the end of string. Remember that,
    the previous content of the string is overwritten as a result of the concatenation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `int` (the function returns `1` if the concatenation happens
    correctly).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the + operator on strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is another way to concatenate two strings. That one doesn''t use a function
    but an operator: `+`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is the same as the previous one. `+` is an operator that I''ll describe
    better a bit later. I''m giving you something more here: a condensed notation
    for the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Try it. You'll understand.
  prefs: []
  type: TYPE_NORMAL
- en: Extract and replace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: String manipulation and alteration can be done using some very useful functions
    extracting and replacing elements in the string.
  prefs: []
  type: TYPE_NORMAL
- en: substring() is the extractor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You want to extract a part of a string. Imagine if the Arduino board sends
    messages with a specific and defined communication protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<output number>.<value>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output number is coded with two characters every time, and the value with
    three (45 has to be written as 045). I often work like that and pop out these
    kind of messages from the serial port of my computer via the USB when I need to;
    for instance, send a command to light up a particular LED with a particular intensity.
    If I want to light the LED on the fourth output at 100/127, I send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Arduino *needs* to understand this message. Without going further with the communication
    protocol design, as that will be covered in [Chapter 7](ch07.html "Chapter 7. Talking
    over Serial"), *Talking Over Serial*, I want to introduce you to a new feature—splitting
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code splits the message received by Arduino into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `substring()` function extracts a part of a string from a start index (included)
    to another (not included).
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.substring(from, to);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`from` is the start index. The result includes the content of the `from` string
    element. `to` is the end index. The result doesn''t include the content of the
    `end` string element, it can be omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `String`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's push the concept of string extract and split it a bit further.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a string using a separator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's challenge ourselves a bit. Imagine I don't know or I'm not sure about
    the message format (two characters, a dot, and three characters, that we have
    just seen). This is a real life case; while learning to make things, we often
    meet strange cases where those *things* don't behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine I want to use the dot as a separator, because I'm very sure about it.
    How can I do that using the things that we have already learned? I'd need to extract
    characters. OK, I know `substring()` now!
  prefs: []
  type: TYPE_NORMAL
- en: But I also need an index to extract the content at a particular place. I also
    know how to find the index of an occurrence of a character in a string, using
    `indexOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, I find the split point index (the place in the string where the dot
    sits). Secondly, I use this result as the last element of my extracted substring.
    Don't worry, the last element isn't included, which means `currentOutputNumber`
    doesn't contain the dot.
  prefs: []
  type: TYPE_NORMAL
- en: At last, I'm using `splitPointIndex` one more time as the start of the second
    part of the string that I need to extract. And what? I add the integer `1` to
    it because, as you master `substring()` now and know, the element corresponding
    to the start index is always included by the `substring()` operation. We don't
    want that dot because it is only a separator. Right?
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you are a bit lost. Things will become clearer in the next subchapters
    and especially when we'll make Arduino process things, which will come a bit later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Replacements are often used when we want to convert a communication protocol
    to another. For instance, we need to replace a part of a string by another to
    prepare a further process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take our previous example. We now want to replace the dot by another character
    because we want to send the result to another process that only understands the
    space character as a separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, I put the content of the `receivedMessage` variable into another variable
    named `originalMessage` because I know the `replace()` function will definitely
    modify the processed string. Then I process `receivedMessage` with the `replace()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `replace()` function replaces a part of a string with another string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: `string.replace(substringToReplace, replacingSubstring);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`from` is the start index. The result includes the content of a `from` string
    element. `to` is the end index. The result doesn''t include the content of an
    `end` string element, it can be omitted. Remember that, the previous content of
    the string is overwritten as a result of the replacement (copy it to another string
    variable if you want to keep it).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Returns type**: `int` (the function returns `1` if the concatenation happens
    correctly).'
  prefs: []
  type: TYPE_NORMAL
- en: This function can, obviously, replace a character by another character of course.
    A string is an array of characters. It is not strange that one character can be
    processed as a string with only one element. Let's think about it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Other string functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other string processing functions I'd like to quickly quote here.
  prefs: []
  type: TYPE_NORMAL
- en: toCharArray()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function copies all the string's characters into a "real" character array,
    also named, for internal reasons, a buffer. You can check [http://arduino.cc/en/Reference/StringToCharArray](http://arduino.cc/en/Reference/StringToCharArray).
  prefs: []
  type: TYPE_NORMAL
- en: toLowerCase() and toUpperCase()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions replace the strings processed by them by the same string but
    with all characters in lowercase and uppercase respectively. You can check [http://arduino.cc/en/Reference/StringToLower](http://arduino.cc/en/Reference/StringToLower)
    and [http://arduino.cc/en/Reference/StringToUpperCase](http://arduino.cc/en/Reference/StringToUpperCase).
    Be careful, as it overwrites the string processed with the result of this process.
  prefs: []
  type: TYPE_NORMAL
- en: trim()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function removes all whitespace in your string. You can check [http://arduino.cc/en/Reference/StringTrim](http://arduino.cc/en/Reference/StringTrim).
    Again, be careful, as it overwrites the strings processed with the result of this
    process.
  prefs: []
  type: TYPE_NORMAL
- en: length()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I wanted to end with this functioin. This is the one you'll use a lot. It provides
    the length of a string as an integer. You can check [http://arduino.cc/en/Reference/StringLength](http://arduino.cc/en/Reference/StringLength).
  prefs: []
  type: TYPE_NORMAL
- en: Testing variables on the board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a piece of code that you can also find in the folder `Chapter03/VariablesVariations/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload this code to your board, then switch on the serial monitor. At last,
    reset the board by pushing the reset button and observe. The board writes directly
    to your serial monitor as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing variables on the board](img/7584_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The serial monitor showing you what your board is saying
  prefs: []
  type: TYPE_NORMAL
- en: Some explanations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All explanations will come progressively, but here is a small summary of what
    is happening right now.
  prefs: []
  type: TYPE_NORMAL
- en: I first declare my variables and then define some in `setup()`. I could have
    declared and defined them at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing your memory, `setup()` is executed only one time at the board startup.
    Then, the `loop()` function is executed infinitely, sequentially running each
    row of statement.
  prefs: []
  type: TYPE_NORMAL
- en: In `loop()`, I'm first testing `myBoolean`, introducing the `if()` conditional
    statement. We'll learn this in this chapter too.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I'll play a bit with the `char`, `int`, and `String` types, printing some
    variables, then modifying them and reprinting them.
  prefs: []
  type: TYPE_NORMAL
- en: The main point to note here is the `if()` and `else` structure. Look at it,
    then relax, answers will come very soon.
  prefs: []
  type: TYPE_NORMAL
- en: The scope concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope can be defined as a particular property of a variable (and functions,
    as we'll see further). Considering the source code, the scope of a variable is
    that part of the code where this variable is visible and usable.
  prefs: []
  type: TYPE_NORMAL
- en: A variable can be *global* and then is visible and usable everywhere in the
    source code. But a variable can also be *local*, declared inside a function, for
    instance, and that is visible only inside this particular function.
  prefs: []
  type: TYPE_NORMAL
- en: The scope property is *implicitly* set by the place of the variable's declaration
    in the code. You probably just understood that every variable could be declared
    globally. Usually, I follow my own *digital haiku*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let each part of your code know only variables that it has to know, no more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to minimize the scope of the variables is definitely a winning way.
    Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We could represent the code's scope as a box more or less imbricated.
  prefs: []
  type: TYPE_NORMAL
- en: '![The scope concept](img/7584_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code's scope seen as boxes
  prefs: []
  type: TYPE_NORMAL
- en: The external box represents the source code's highest level of scope. Everything
    declared at this level is visible and usable by all functions; it is the global
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Every other box represents a particular scope in itself. Every variable declared
    in one scope cannot be seen and used in higher scopes neither in the same level
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: This representation is very useful to my students who always need more visuals.
    We'll also use this metaphor while we talk about *libraries*, especially. What
    is declared in libraries can be used in our code if we include some specific headers
    at the beginning of the code, of course.
  prefs: []
  type: TYPE_NORMAL
- en: static, volatile, and const qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qualifiers** are the keywords that are used to change the processor''s behavior
    considering the *qualified* variable. In reality, the compiler will use these
    qualifiers to change characteristics of the considered variables in the binary
    firmware produced. We are going to learn about three qualifiers: `static`, `volatile`,
    and `const`.'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the `static` qualifier for a variable inside a function, this
    makes the variable persistent between two calls of the function. Declaring a variable
    inside a function makes the variable, implicitly, local to the function as we
    just learned. It means only the function can know and use the variable. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable is seen in the `myFunction` function only. But what happens after
    the first loop? The previous value is lost and as soon as `int aLocalVariable;`
    is executed, a new variable is set up, with a value of zero. Check out this new
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This variable is seen in the `myFunction` function only and, after adding an
    argument has modified it, we can play with its new value.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the variable is qualified as `static`. It means the variable is
    declared *only* the first time. This provides a useful way to keep trace of something
    and, at the same time, make the variable, containing this trace, local.
  prefs: []
  type: TYPE_NORMAL
- en: volatile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the `volatile` qualifier in a variable declaration statement, this
    variable is loaded from the RAM instead of the storage register memory space of
    the board. The difference is subtle and this qualifier is used in specific cases
    where your code itself doesn't have the control of something else executed on
    the processor. One example, among others, is the use of interrupts. We'll see
    that a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, your code runs normally, and some instructions are triggered not
    by this code, but by another process such as an external event. Indeed, our code
    doesn't know when and what **Interrupt Service Routine** (**ISR**) does, but it
    stops when something like that occurs, letting the CPU run ISR, then it continues.
    Loading the variable from the RAM prevents some possible inconsistencies of variable
    value.
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` qualifier means constant. Qualifying a variable with `const` makes
    it unvariable, which can sound weird.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to write a value to a `const` variable after its declaration/definition
    statement, the compiler gives an error. The scope''s concept applies here too;
    we can qualify a variable declared inside a function, or globally. This statement
    defines and declares the `masterMidiChannel` variable as a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is *no* semicolon after a `#define` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`#define` seems a bit less used as `const`, probably because it cannot be used
    for constant arrays. Whatever the case, `const` can always be used. Now, let''s
    move on and learn some new operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Operators, operator structures, and precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already met a lot of operators. Let's first check the arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators and types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arithmetic operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` (plus sign)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` (minus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` (asterisk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` (slash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` (percent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=` (equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I''m beginning with the last one: `=` **.** It is the **assignment** operator.
    We have already used it a lot to define a variable, which just means to assign
    a value to it. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the other operators, I''m going to distinguish two different cases in the
    following: character types, which include `char` and `String`, and numerical types.
    Operators can change their effect a bit according to the types of variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Character types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`char` and `String` can only be processed by `+`. As you may have guessed,
    `+` is the concatenation operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this code, concatenation of `myResultString` and `myString` results in the
    `Hello World` string.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With all numerical types (`int`, `word`, `long`, `float`, `double`), you can
    use the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` (addition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` (subtraction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` (multiplication)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` (division)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` (modulo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A basic example of multiplication is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As soon as you use a `float` or `double` type as one of the operand, the floating
    point calculation process will be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, the result of `OutputOscillatorAmplitude * multiplier`
    is a `float` value. Of course, division by zero is *prohibited*; the reason is
    math instead of C or Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modulo** is simply the remainder of the division of one integer by another
    one. We''ll use it a lot to keep variables into a controlled and chosen range.
    If you make a variable grow to infinite but manipulate its modulo by 7 for instance,
    the result will always be between 0 (when the growing variable will be a multiple
    of 7) and 6, constraining the growing variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Condensed notations and precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, there is a condensed way of writing an operation with
    these previously explained operators. Let's see two equivalent notations and explain
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These two pieces of code are equivalent. The first one teaches you about the
    precedence of operators. There is a table given in *Appendix B, Operator Precedence
    in C and C++* with all precedencies. Let's learn some right now.
  prefs: []
  type: TYPE_NORMAL
- en: '`+`, `-`, `*`, `/`, and `%` have a greater precedence over `=`. That means
    `myInt1 + myInt2` is calculated before the assignment operator, then, the result
    is assigned to `myInt1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is the condensed version. It is equivalent to the first version
    and thus, precedence applies here too. A little tricky example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to know that `+` has a higher precedence over `+=`. It means the order
    of operations is: first, `myInt2 + myInt2` then `myInt1 +` the result of the freshly
    made calculation `myInt2 + myInt2`. Then, the result of the second is assigned
    to `myInt1`. This means it is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Increment and decrement operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to point you to another condensed notation you''ll meet often: the double
    operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`++` is equivalent to `+=1`, `--` is equivalent to `-=1`. These are called
    *suffix increment* (`++`) and *suffix decrement* (`--`). They can also be used
    as *prefix*. `++` and `--` as prefixes have lower precedencies than their equivalent
    used as suffix but in both cases, the precedence is very much higher than `+`,
    `-`, `/`, `*`, and even `=` and `+=`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following is a condensed table I can give you with the most used cases.
    In each group, the operators have the same precedence. It drives the expression
    `myInt++ + 3` to be ambiguous. Here, the use of parenthesis helps to define which
    calculation will be made first.
  prefs: []
  type: TYPE_NORMAL
- en: '| Precedencies groups | Operators | Names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `++``--``()``[]` | Suffix incrementSuffix decrementFunction callArray
    element access |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `++``--` | Prefix incrementPrefix decrement |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `*``/``%` | MultiplicationDivisionModulo |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `+``-` | AdditionSubtraction |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | `=``+=``-=``*=``/=``%=` | AssignmentAssignment by sumAssignment by differenceAssignment
    by productAssignment by quotientAssignment by remainder |'
  prefs: []
  type: TYPE_TB
- en: 'I guess you begin to feel a bit better with operators, right? Let''s continue
    with a very important step: types conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Types manipulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you design a program, there is an important step consisting of choosing
    the right type for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the choice is constrained by external factors. This happens when,
    for instance, you use the Arduino with an external sensor able to send data coded
    as integers in 10 bits (210 = 1024 steps of resolution). Would you choose `byte`
    type knowing it only provides a way to store number from 0 to 255? Probably not!
    You'll choose `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have to choose it yourself. Imagine you have data coming to the
    board from a Max 6 framework patch on the computer via your serial connection
    (using USB). Because it is the most convenient, since you designed it like that,
    the patch pops out `float` numbers encapsulated into string messages to the board.
    After having parsed, cut those messages into pieces to extract the information
    you need (which is the `float` part), would you choose to store it into `int`?
  prefs: []
  type: TYPE_NORMAL
- en: That one is a bit more difficult to answer. It involves a *conversion* process.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit types conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type conversion is the process that changes an entity data type into another.
    Please notice I didn't talk about variable, but entity.
  prefs: []
  type: TYPE_NORMAL
- en: It is a consequence of C design that we can convert only the values stored in
    variables, others keep their type until their lives end, which is when the program's
    execution ends.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion can be *implicitly* done or *explicitly* made. To be sure everyone
    is with me here, I'll state that *implicitly means not visibly and consciously
    written*, compared to *explicitly that means specifically written in code*, here.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit type conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it is also called *coercion*. This happens when you don't specify
    anything for the compiler that has to make an automatic conversion following its
    own basic (but often smart enough) rules. The classic example is the conversion
    of a `float` value into an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: I'm using the assignment operator (`=`) to put the content of `myFloat` into
    `myInt`. It causes **truncation** of the `float` value, that is, the *removal
    of the decimal part*. You have definitely lost something if you continue to work
    only with the `myInt` variable instead of `myFloat`. It can be okay, but you have
    to keep it in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Another less classic example is the implicit conversion of `int` type to `float`.
    `int` doesn't have a decimal part. The implicit conversion to `float` won't produce
    something other than a decimal part that equals zero. This is the easy part.
  prefs: []
  type: TYPE_NORMAL
- en: 'But be careful, you could be surprised by the implicit conversion of `int`
    to `float`. Integers are encoded over 32 bits, but `float`, even if they are 32
    bits, have a *significand* (also called mantissa) encoded over 23 bits. If you
    don''t remember this precisely, it is okay. But I want you to remember this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implicit type conversion](img/7584_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strange results from int to float implicit conversion
  prefs: []
  type: TYPE_NORMAL
- en: 'I stored `123456789` into a `long int` type, which is totally legal (`long
    int` are 32-bits signed integers that are able to store integersfrom `-2147483648`
    to `2147483647`). After the assignment, I''m displaying the result that is: **123456792.00**.
    We expected `123456789.00` of course.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implicit types conversions rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`long int` to `float` can cause wrong results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `int` removes the decimal part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` to `float` rounds digit of double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long int` to `int` drops the encoded higher bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit type conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to have predictable results, every time you can convert types explicitly.
    There are six conversion functions included in the Arduino core:'
  prefs: []
  type: TYPE_NORMAL
- en: char()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: word()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: byte()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: long()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use them by passing the variable you want to convert as an argument of
    the function. For instance, `myFloat = float(myInt)`; where `myFloat` is a `float`
    type and `myInt` is an `int` type. Don't worry about the use, we'll use them a
    bit later in our firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'My rule about conversion: Take care of each type conversion you make. None
    should be obvious for you and it can cause an error in your logic, even if the
    syntax is totally correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values and Boolean operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to store entities into variables, convert values, and choose
    the right conversion method. We are now going to learn how to compare variable
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are six comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`==` (equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` (not equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` (less than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` (greater than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` (less than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` (greater than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a comparison expression in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: An expression like that does nothing, but it is legal. Comparing two elements
    produces a result and in this small example, it isn't used to trigger or make
    anything. `myInt1 > myFloat` is a comparison expression. The result is, obviously,
    `true` or `false`, I mean it is a `boolean` value. Here it is `false` because
    `4` is not greater than `5.76`. We can also combine comparison expressions together
    to create more complex expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining comparisons with Boolean operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three Boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` (and)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||` (or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!` (not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is time to remember some logic operations using three small tables. You can
    read those tables like column element + comparison operator + row element; the
    result of the operation is at the intersection of the column and the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary operator AND, also written as `&&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `&&` | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false |'
  prefs: []
  type: TYPE_TB
- en: 'Then the binary operator OR, also written as ||:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `&#124;&#124;` | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false |'
  prefs: []
  type: TYPE_TB
- en: 'Lastly, the unary operator NOT, also written as `!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | false | true |'
  prefs: []
  type: TYPE_TB
- en: For instance, true `&&` false = false, false `||` true = true. `&&` and `||`
    are *binary operators*, they can *compare* two expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`!` is a *unary operator* and can only work with one expression, negating it
    logically. `&&` is the logical AND. It is true when both expressions compared
    are true, false in all other cases. `||` is the logic OR. It is true when one
    expression at least is true, false when they are both false. It is the inclusive
    OR. `!` is the negation operator, the NOT. It basically inverts false and true
    into true and false.'
  prefs: []
  type: TYPE_NORMAL
- en: These different operations are really useful and necessary when you want to
    carry out some tests in your code. For instance, if you want to compare a variable
    to a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: Combining negation and comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering two expressions A and B:'
  prefs: []
  type: TYPE_NORMAL
- en: NOT(A `&&` B) = (NOT A `||` NOT B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NOT (A `||` B) = (NOT A `&&` NOT B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be more than useful when you''ll create conditions in your code. For
    instance, let''s consider two expressions with four variables a, b, c, and d:'
  prefs: []
  type: TYPE_NORMAL
- en: a `<` b
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c `>=` d
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is the meaning of `!`(a `<` b)? It is the negation of the expression,
    where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!`(a `<` b) equals (a `>=` b)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of *a strictly smaller than b* is *a greater than or equal to
    b*. In the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!`(c `>=` d) equals (c `<` d)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s combine a bit. Let''s negate the global expression:'
  prefs: []
  type: TYPE_NORMAL
- en: (a `<` b) `&&` (c `>=` d) and `!`((a `<` b) `&&` (c `>=` d)) equals (`!`(a `<`
    b) `||` `!`(c `>=` d)) equals (a `>=` b) `||` (c `<` d)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of combination introducing the *operators precedence*
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of my statements are equivalent. Precedence occurs here and we can now
    add these operators to the previous precedencies table (check *Appendix B, Operator
    Precedence in C and C++*). I''m adding the comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Precedencies groups | Operators | Names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `++``--``()``[]` | Suffix incrementSuffix decrementFunction callArray
    element access |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `++``--` | Prefix incrementPrefix decrement |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `*``/``%` | MultiplicationDivisionModulo |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `+``-` | AdditionSubtraction |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `<``<=``>``>=` | Less thanLess than or equal toGreater thanGreater than
    or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `==``!=` | Equal toNot equal to |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | `&&` | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | `&#124;&#124;` | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | `?:` | Ternary conditional |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | `=``+=``-=``*=``/=``%=` | AssignmentAssignment by sumAssignment by differenceAssignment
    by productAssignment by quotientAssignment by remainder |'
  prefs: []
  type: TYPE_TB
- en: As usual, I cheated a bit and added the precedence group 15 that contains a
    unique operator, the ternary conditional operator that we will see a bit later.
    Let's move to conditional structures.
  prefs: []
  type: TYPE_NORMAL
- en: Adding conditions in the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because I studied Biology and have a Master's diploma, I'm familiar with organic
    and living behaviors. I like to tell my students that the code, especially in
    interaction design fields of work, has to be alive. With Arduino, we often build
    machines that are able to "feel" the real world and interact with it by *acting*
    on it. This couldn't be done without *condition* statements. This type of statement
    is called a control structure. We used one conditional structure while we tested
    our big code including variables display and more.
  prefs: []
  type: TYPE_NORMAL
- en: if and else conditional structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the one we used without explaining. You just learned patience and zen.
    Things begin to come, right? Now, let''s explain it. This structure is very intuitive
    because it is very similar to any conditional pseudo code. Here is one:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the variable `a` is smaller than the value of variable `b`,
    switch on the LED. Else switch it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the real C code, where I simplify the part about the LED by giving a state
    of 1 or 0 depending on what I want to further do in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I guess it is clear enough. Here is the general syntax of this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Expression evaluation generally results in a Boolean value. But numerical values
    as a result of an expression in this structure can be okay too, even if a bit
    less explicit, which I, personally, don't like. An expression resulting in the
    numerical value `0` equals `false` in C in Arduino core, and equals `true` for
    any other values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being implicit often means making your code shorter and cuter. In my humble
    opinion, it also means to be very unhappy when you have to support and maintain
    a code several months later when it includes a bunch of implicit things without
    any comments.
  prefs: []
  type: TYPE_NORMAL
- en: I push my students to be explicit and verbose. We are not here to code things
    to a too small amount of memory, believe me. We are not talking about reducing
    a 3 megabytes code to 500 kilobytes but more about reducing a 200 kilobytes code
    to 198 kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining an if…else structure to another if…else structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the modified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `if` test is: if `a` is smaller than `b`. If it is `true`, we put
    the value `1` inside the variable `ledState`. If it is `false`, we go to the next
    statement `else`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `else` contains another test on `b`: is `b` greater than `0`? If it is,
    we put the value `0` inside the variable `ledState`. If it is `false`, we can
    go to the last case, the last `else`, and we put the value `1` inside the variable
    `ledState`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**One frequent error – missing some cases**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the `if`… `else` chain is so complicated and long that we may miss
    some case and no case is verified. Be clear and try to check the whole universe
    of cases and to code the conditions according to it.
  prefs: []
  type: TYPE_NORMAL
- en: A nice tip is to try to put all cases on paper and try to find the *holes*.
    I mean, where the part of the variable values are not matched by tests.
  prefs: []
  type: TYPE_NORMAL
- en: if…else structure with combined comparisons expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the previous example where I commented a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write it in the following way considering the comment I wrote previously
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It could be considered as a more condensed version where you have all statements
    for the switch on the LED in one place, same for switching it off.
  prefs: []
  type: TYPE_NORMAL
- en: Finding all cases for a conditional structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you want to test a temperature value. You have two specific limits/points
    at which you want the Arduino to react and, for instance, alert you by lighting
    an LED or whatever event to interact with the real world. For instance, the two
    limits are: 15-degree Celsius and 30-degree Celsius. How to be sure I have all
    my cases? The best way is to use a pen, a paper, and to draw a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding all cases for a conditional structure](img/7584_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking all possible T values
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: T < 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T > 15 but T <30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T > 30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we have three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: T< 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T >15 and T < 30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T > 30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens when T = 30 or T = 15? These are holes in our logic. Depending
    on how we designed our code, it could happen. Matching all cases would mean: include
    T = 15 and T = 30 cases too. We can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: I included these two cases into my comparisons. 15-degree Celsius is included
    in the second temperature interval and 30-degree Celsius in the last one. This
    is an example of how we can do it.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like you to remember to use a pen and a paper in this kind of cases. This
    will help you to design and especially make some breaks from the IDE that is,
    in designing steps, really good. Let's now explore a new conditional structure.
  prefs: []
  type: TYPE_NORMAL
- en: switch…case…break conditional structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we are going to see a new conditional structure. The standard syntax
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`var` is compared for equality to each case label. If `var` equals a particular
    `label` value, the statements in this case are executed until the next `break`.
    If there is no match and you have used the optional `default:` case, the statements
    of this case are executed. Without the `default:` case, nothing is done. `label`
    must be a value, not a character, not string. Let''s take a more concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Are you okay?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What I want to say is, when you want to compare a variable to many unique values,
    use `switch`…`case`…`break`, else use `if`…`else`.
  prefs: []
  type: TYPE_NORMAL
- en: When you have comparison intervals, `if`…`else` is more convenient because you
    can use `<` and `>` whereas in `switch`…`case`…`break` you cannot. Of course,
    we could combine both. But remember to keep your code as simple as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This strange notation is often totally unknown to my students. I used to say,
    "Hey! This is more C than Arduino" when they answer "That is why we have forgotten
    about it". Naughty students! This ternary operator takes three elements as input.
    The syntax is `(expression) ? val1 : val2`.'
  prefs: []
  type: TYPE_NORMAL
- en: The expression is tested. If it is `true`, this whole statement returns (or
    equals) `val1`, if it is `false`, it equals `val2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again imagine our Arduino, the temperature sensor, and only one limit which
    is 20 degree Celsius. I want to turn the LED blue if `T` is smaller than the limit,
    and red if `T` is greater or equal to 20 degree Celsius. Here is how we would
    use the two ternary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It can be a nice notation, especially if you don't need statement execution
    in each case but only variable assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Making smart loops for repetitive tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **loop** is a series of events repeating themselves in time. Basically, computers
    have been designed, at first, to make a lot of calculations repeatedly to save
    human''s time. Designing a loop to repeat tasks that have to be repeated seems
    a natural idea. C natively implements some ways to design loops. Arduino core
    naturally includes three loop structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do`…`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for loop structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop statement is quite easy to use. It is based on, at least, one
    counter starting from a particular value you define, and increments or decrements
    it until another defined value. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The counter is also named `index`. I''m showing you a real example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This basic example defines a loop that prints all integers from `0` to `99`.
    The declaration/definition of the integer type variable `i` is the first element
    of the `for` structure. Then, the condition describes in which case the statements
    included in this loop have to be executed. At last, the `i++` increment occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the increment element. It is defined with the increment as
    a suffix. It means here that the increment occurs after the end of the execution
    of the statements for a considered `i` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break the loop for the first two and last two `i` values and see what
    happens. Declaration of the integer variable `i` for the first and second iteration
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 0`, is `i` smaller than `100`? yes, `println(0)`, increment `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 1`, is `i` smaller than `100`? yes, `println(1)`, increment `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the last two iterations the value of `i` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 99`, is `i` smaller than `100`? yes, `println(99)`, increment `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 100`, is `i` smaller than `100`? no, stop the loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the index could be declared before the `for` structure, and only
    defined inside the `for` structure. We could also have declared and defined the
    variable before and we would have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This seems a bit strange, but totally legal in C and for the Arduino core too.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The scope of index**'
  prefs: []
  type: TYPE_NORMAL
- en: If the index has been declared inside the `for` loop parenthesis, its scope
    is only the `for` loop. This means that this variable is *not* known or *not*
    usable outside of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: It normally works like that for any variable declared inside the statements
    of a `for` loop. This isn't something to do, even if it is totally legal in C.
    Why not? Because it would mean you'd declare a variable each time the loop runs,
    which isn't really smart. It is better to declare it outside of the loop, one
    time, then to use it inside of it, whatever the purpose (index, or variable to
    work with inside statements).
  prefs: []
  type: TYPE_NORMAL
- en: Playing with increment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Increment can be something more complex than only using the increment operator.
  prefs: []
  type: TYPE_NORMAL
- en: More complex increments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, instead of writing `i++`, we could have written `i = i + 1`. We can
    also use other kind of operations like subtraction, multiplication, division,
    modulo, or combinations. Imagine that you want to print only odd numbers. Odd
    numbers are all of the form 2n + 1 where *n* is an integer. Here is the code to
    print odd numbers from 1 to 99:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'First values of `i` are: `1`, `3`, `5`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Decrements are negative increments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I just want to remix the previous code into something else in order to shake
    your mind a bit around increments and decrements. Here is another code making
    the same thing but printing odd numbers from `99` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: All right? Let's complicate things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Using imbricated for loops or two indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also possible to use more than one index in a `for` structure. Imagine
    we want to calculate a multiplication table until 10 x 10\. We have to define
    two integer variables from 1 to 10 (0 being trivial). These two indexes have to
    vary from 1 to 10\. We can begin by one loop with the index `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is for the first index. The second one is totally similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'How can I mix those? The answer is the same as the answer to the question:
    what is a multiplication table? I have to keep one index constant, and multiply
    it by the other one going from 1 to 10\. Then, I have to increment the first one
    and continue doing the same with the other and so on. Here is how to we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints all results of `x*y` where `x` and `y` are integers from 1
    to 10, one result on each line. Here are the first few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x = 1`, `y = 1`… print the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x = 1`, `y = 2`… print the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x = 1`, `y = 3`… print the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is incremented to `2` each time the inside `for` loop (the one with `y`)
    ends, then `x` is fixed to `2` and `y` grows until `x = 10` and `y = 10` where
    the `for` loop ends.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve it a bit, only for aesthetic purposes. It is also a pretext
    to tweak and play with the code to make you more comfortable with it. Often, multiplication
    tables are drawn as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using imbricated for loops or two indexes](img/7584_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Classic view of a multiplication table
  prefs: []
  type: TYPE_NORMAL
- en: We need to go to the next line each time one of the index (and only one) reaches
    the limit which is the value `10`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Check the code, each time `y` reaches `10`, a new line is created. The `for`
    loop is a powerful structure to repeat tasks. Let's check another structure.
  prefs: []
  type: TYPE_NORMAL
- en: while loop structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop structure is a bit simpler. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression is evaluated as a Boolean, `true` or `false`. While the expression
    is `true`, statements are executed, then as soon as it will be `false`, the loop
    will end. It obviously, often, requires declaration and definition outside of
    the `while` structure. Here is an example doing the same results than our first
    `for` loop printing all integers from 0 to 99:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, you *have* to take care of the increment or decrement explicitly inside
    your statements; I''ll say a few words on infinite loops a bit later. We could
    have condensed the code a bit more by doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop structure tests the expression before doing even executing
    the first statement. Let's check a similar structure doing that differently.
  prefs: []
  type: TYPE_NORMAL
- en: do…while loop structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do`…`while` loop structure is very similar to the `while` structure, but
    makes its expression evaluation at the end of the loop, which means after the
    statements execution. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example on the same model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It means that even if the first result of the expression evaluation is `false`,
    the statements will be executed on time. This is not the case with the `while`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to create loops driven by indexes that define precisely how these
    loops will live. But how can we stop a loop when an *external* event occurs? External
    is taken in the sense of external to the loop itself including its indexes. In
    that case, the loop's condition itself wouldn't include the external element.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have a process running 100 times in *normal* conditions. But
    we want to interrupt it, or modify it according to another variable that has a
    greater scope (declared outside of the loop, at least).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the `break` statement for making that possible for us. `break;` is
    the basic syntax. When `break` is executed, it exits the current loop, whatever
    it is, based on: `do`, `for`, and `while`. You already saw `break` when we talked
    about the `switch` conditional structure. Let''s illustrate that.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a LED. We want its intensity to grow from 0 to 100 percent then to go
    back to 0, every time. But we also want to use a nice distance sensor that resets
    this loop each time the distance between a user and the sensor is greater than
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is based on a real installation I made for a museum where a system has to
    make a LED blink smoothly when the user was far and to switch off the LED when
    the user was near, like a living system calling for users to meet it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I designed it very simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This whole loop was included inside the global `loop()` function in the Arduino
    board and the complete test about the distance was executed each time the `loop()`
    function occurs, waiting for users.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops are not your friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful of infinite loops. The problem isn't really the infinite state of
    loops, but the fact that a system, whatever it is including Arduino, which is
    running an infinite loop does only that! Nothing that is after the loop can be
    executed because the program won't go outside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you understand me correctly, `loop()`—the basic Arduino core function—is
    an infinite loop. But it is a controlled loop well designed and Arduino core based.
    It can (and is) interrupted when functions are called or other special events
    occur, letting us, users, design what we need inside of this loop. I used to call
    "the event's driver and listener" because it is the place where our main program
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to create infinitely looped processes. You can define a
    variable in `setup()`, making it grow in `loop()` and test it each time `loop()`
    runs in order to reset it to the initial value, for instance. It takes benefits
    of the already existing `loop()` loop. Here is this example in C for Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This `i` grows from `0` to `threshold – 1` then goes back to `0`, grows again,
    infinitely, taking benefits of `loop()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also other ways to run loops infinitely in a controlled manner that
    we''ll see a bit later in the more advanced part of the book, but you have been
    warned: take care of those infinite loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot of abstract things in this important chapter. From type to
    operator's precedencies, to conditional structure, now we are going to learn new
    structures and syntaxes that will help us make more efficient blocks of code and,
    especially, more reusable ones. We can now learn about functions. Let's dive into
    the next C/C++ knowledge chapters and we will be able to test our Arduino after
    that.
  prefs: []
  type: TYPE_NORMAL
