- en: Chapter 3. C Basics – Making You Stronger
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。C基础——让你变得更强大
- en: C programming isn't that hard. But it requires enough work at the beginning.
    Fortunately, I'm with you and we have a very good friend since three chapters
    – our Arduino board. We will now go deep into the C language, and I'll do my best
    to be more concrete and not abstract.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C语言编程并不那么难。但需要在开始时投入足够的工作。幸运的是，我和你在一起，我们有一个非常好的朋友，从第三章开始——我们的Arduino板。现在，我们将深入探讨C语言，我会尽我所能使其更加具体，而不是抽象。
- en: This chapter and the next one are truly C language-oriented because the Arduino
    program design requires knowledge in programming logic statements. After these
    two chapters, you'll be able to read any code in this book; these strong basics
    will also help you in further projects, even those not related to Arduino.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章真正是C语言导向的，因为Arduino程序设计需要编程逻辑语句的知识。在这两章之后，你将能够阅读这本书中的任何代码；这些坚实的基础也将帮助你进行进一步的项目，甚至那些与Arduino无关的项目。
- en: I will also progressively introduce new concepts that we will use later, such
    as functions. Don't be afraid if you don't understand it that well, I like my
    students to hear some words progressively sometimes even without a proper definition
    at first, because it helps further explanation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将逐步介绍我们以后会用到的新概念，例如函数。如果你不太理解，不要害怕，我有时喜欢我的学生逐步听到一些单词，甚至在没有适当定义的情况下，因为这有助于进一步的解释。
- en: So if I don't define it but talk about it, just relax, explanations are going
    to come further. Let's dive in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我没有定义它但提到了它，请放心，解释将在后面进行。让我们深入探讨。
- en: Approaching variables and types of data
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近变量和数据类型
- en: We already used variables in the previous chapters' examples. Now, let's understand
    this concept better.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节示例中使用了变量。现在，让我们更好地理解这个概念。
- en: What is a variable?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: A **variable** is a memory storage location bounded to a symbolic name. This
    reserved memory area can be filled or left empty. Basically, it is used to store
    different types of values. We used the variable `ledPin` in our previous examples,
    with the keyword `int`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量** 是一个与符号名称相关的内存存储位置。这个预留的内存区域可以被填充或留空。基本上，它用于存储不同类型的值。我们在之前的例子中使用了变量 `ledPin`，使用了关键字
    `int`。'
- en: Something very useful with variables is the fact that we can change their content
    (the value) at runtime; this is also why they are called variables, compared to
    constants that also store values, but that cannot be changed while the program
    is running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常有用的一点是我们可以在运行时更改它们的内容（值）；这也是为什么它们被称为变量，与常量相比，常量也存储值，但在程序运行时不能更改。
- en: What is a type?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是类型？
- en: Variables (and constants) are associated with a type. A type, also called **data
    type**, defines the possible nature of data. It also offers a nice way to directly
    reserve a space with a defined size in memory. C has around 10 main types of data
    that can be extended as we are going to see here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 变量（和常量）与类型相关联。类型，也称为 **数据类型**，定义了数据的可能性质。它还提供了一种直接在内存中预留定义大小的空间的好方法。C大约有10种主要的数据类型，我们可以像下面将要看到的那样进行扩展。
- en: I'm deliberately only explaining the types we'll use a lot in Arduino programming.
    This fits with approximately 80 percent of other usual C data types and will be
    more than enough here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意只解释我们在Arduino编程中会大量使用的类型。这大约符合80%的其他常用C数据类型，在这里将绰绰有余。
- en: 'Basically, we are using a type when we declare a variable as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当我们像这里所示那样声明变量时，我们正在使用一个类型：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A space of a particular size (the size related to the `int` type) is reserved
    in memory, and, as you can see, if you only write that line, there is still no
    data stored in that variable. But keep in mind that a memory space is reserved,
    ready to be used to store values.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定大小（与 `int` 类型相关的大小）的内存空间被预留，正如你所见，如果你只写这一行，该变量中仍然没有存储任何数据。但请记住，已经预留了内存空间，准备用来存储值。
- en: '| Type | Definition | Size in memory |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 定义 | 内存大小 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `void` | This particular type is used only in *function* declarations and
    while defining pointers with unknown types. We''ll see that in the next chapter.
    |   |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `void` | 这种特定类型仅在 *函数* 声明和定义未知类型的指针时使用。我们将在下一章中看到这一点。 |   |'
- en: '| `boolean` | It stores `false` or `true`. | 1 byte (8 bit) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 它存储 `false` 或 `true`。 | 1 字节（8 位）|'
- en: '| `char` | It stores single-quoted characters such as `''a''` as *numbers*,
    following the ASCII chart ([http://en.wikipedia.org/wiki/ASCII_chart](http://en.wikipedia.org/wiki/ASCII_chart)).It
    is a *signed* type and stores numbers from -128 to 127; it can be unsigned and
    then stores numbers from 0 to 255. | 1 byte |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 它以 *数字* 存储单引号字符，如 `''a''`，遵循 ASCII 表（[http://en.wikipedia.org/wiki/ASCII_chart](http://en.wikipedia.org/wiki/ASCII_chart)）。它是一个
    *有符号* 类型，存储从 -128 到 127 的数字；它可以是无符号的，然后存储从 0 到 255 的数字。 | 1 字节 |'
- en: '| `byte` | It stores numbers as *8-bit unsigned* data that means from 0 to
    255. | 8 bits |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 它以 *8 位无符号* 数据存储数字，这意味着从 0 到 255。 | 8 位 |'
- en: '| `int` | It stores numbers as *2-bytes signed* data which means from -32,768
    to 32,767 it can also be unsigned and then store numbers from 0 to 65,535. | 2
    bytes (16 bit) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 它以 *2 字节有符号* 数据存储数字，这意味着从 -32,768 到 32,767。它也可以是无符号的，然后存储从 0 到 65,535
    的数字。 | 2 字节 (16 位) |'
- en: '| `word` | It stores numbers as *2-bytes unsigned* data exactly as *unsigned*
    `int` does. | 2 bytes (16 bit) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `word` | 它以 *2 字节无符号* 数据存储数字，这与 *无符号* `int` 相同。 | 2 字节 (16 位) |'
- en: '| `long` | It stores numbers as *4-bytes signed* data, which means from -2,147,483,648
    to 2,147,483,647 and can be unsigned and then stores numbers from 0 to 4,294,967,295.
    | 4 bytes (32 bit) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 它以 *4 字节有符号* 数据存储数字，这意味着从 -2,147,483,648 到 2,147,483,647，并且可以是无符号的，然后存储从
    0 到 4,294,967,295 的数字。 | 4 字节 (32 位) |'
- en: '| `float` | It basically stores numbers with a decimal point from -3.4028235E
    + 38 to 3.4028235E + 38 as *4-bytes signed* data.Be careful of the required precision;
    they only have six to seven decimal digits and can give strange rounding results
    sometimes. | 4 bytes (32 bit) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 它基本上以 *4 字节有符号* 数据存储带有小数点的数字，范围从 -3.4028235E + 38 到 3.4028235E
    + 38。请注意所需的精度；它们只有六到七位小数，有时可能会给出奇怪的舍入结果。 | 4 字节 (32 位) |'
- en: '| `double` | It generally stores `float` values with a precision two times
    greater than the `float` value.Be careful, in the Arduino IDE and the board, the
    `double` implementation is exactly the same as `float`; that means with only six
    to seven decimal digits of precision. | 4 bytes (32 bit) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 它通常存储比 `float` 值精度高两倍的 `float` 值。请注意，在 Arduino IDE 和板上，`double`
    的实现与 `float` 完全相同；这意味着只有六到七位小数的精度。 | 4 字节 (32 位) |'
- en: '| Array | Array is an ordered structure of consecutive elements of the same
    type that can each be accessed with an index number. | number of elements x size
    of elements'' type |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 数组是有序的连续元素结构，这些元素类型相同，可以通过索引号访问。 | 元素数量 x 元素类型大小 |'
- en: '| `string` | It stores text strings in an array of `char` where the last element
    is `null` that is a particular character (ASCII code 0). Be careful of the "s"
    in lower case at the beginning of `string`. | number of elements * 1 byte |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 它在 `char` 数组中存储文本字符串，其中最后一个元素是 `null`，即一个特定的字符（ASCII 码 0）。请注意
    `string` 开头的 "s" 小写字母。 | 元素数量 * 1 字节 |'
- en: '| `String` | It is a particular structure of data, namely a class, that provides
    a nice way to use and work with strings of text.It comes with methods/functions
    to easily concatenate strings, split strings, and much more. Be careful of the
    capital "S" at the beginning of `String`. | available every time with the `length()`
    method |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 它是一种特定的数据结构，即类，提供了一种方便的方式来使用和操作文本字符串。它带有方法/函数，可以轻松地连接字符串、分割字符串等。请注意
    `String` 开头的 "S" 大写字母。 | 每次都可以使用 `length()` 方法获取 |'
- en: The roll over/wrap concept
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动/包装概念
- en: If you go beyond the possible bounds of a type, the variable rolls over to the
    other side of the boundary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您超出类型的可能范围，变量将滚动到边界另一侧。
- en: 'The following is an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It happens in both directions, subtracting `1` from an `int` variable storing
    `-32768` results in `32767`. Keep that in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两个方向上都可能发生，从存储 `-32768` 的 `int` 变量中减去 `1` 会得到 `32767`。请记住这一点。
- en: Declaring and defining variables
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和定义变量
- en: We are going to describe how to declare then define variables and learn how
    to do both at the same time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述如何声明和定义变量，并学习如何同时进行这两者。
- en: Declaring variables
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量
- en: Declaration of a variable is a statement in which you specify an *identifier*,
    a *type*, and eventually the variable's dimensions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的声明是一个语句，其中您指定一个 *标识符*、一个 *类型*，以及最终变量的维度。
- en: An identifier is what we call the *name of the variable*. You know what the
    type is too. The dimensions are useful for arrays, for instance, but also for
    `String` (which are processed as arrays internally).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是我们所说的 *变量名*。您也知道类型是什么。维度对于数组很有用，例如，但对于 `String`（它们在内部作为数组处理）也是如此。
- en: In C and all other strongly-typed languages such as Java and Python, we *must*
    declare variables before using them. Anyway, the compiler will complain in case
    you forget the declaration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和所有其他强类型语言，如 Java 和 Python 中，我们 *必须* 在使用变量之前声明它们。无论如何，如果你忘记了声明，编译器会报错。
- en: Defining variables
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义变量
- en: 'The following table contains some examples of variable definition:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含了一些变量定义的示例：
- en: '| Type | Example |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` |'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `char` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `char` |'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `byte` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `byte` |'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `int` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `int` |'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `word` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `word` |'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `long` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `long` |'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `float` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `float` |'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `double` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `double` |'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Array |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 数组 |'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `string` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `string` |'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Defining a variable is the act of assigning a value to the memory area previously
    reserved for that variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个变量是将值赋给之前为该变量预留的内存区域的行为。
- en: Let's declare and define some variables of each type. I have put some explanations
    in the code's comments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明并定义每种类型的变量。我在代码注释中添加了一些解释。
- en: Here are some examples you can use, but you'll see in each piece of code given
    in this book that different types of declaration and definition are used. You'll
    be okay with that as soon as we'll wire the board.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以使用的示例，但你会在本书给出的每一块代码中看到，使用了不同类型的声明和定义。一旦我们连接了电路板，你就可以接受这一点。
- en: Let's dig a bit more into the `String` type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 `String` 类型。
- en: String
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String
- en: The `String` type deserves a entire subchapter because it is a bit more than
    a type. Indeed, it is an object (in the sense of object-oriented programming).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类型值得一个单独的小节，因为它不仅仅是一个类型。实际上，它是一个对象（在面向对象编程的意义上）。'
- en: Objects come with special properties and functions. Properties and functions
    are available natively because `String` is now a part of the Arduino core and
    can be seen as a pre-existing entity even if your IDE contains no line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对象具有特殊的属性和函数。属性和函数是原生可用的，因为 `String` 现在是 Arduino 核心的一部分，即使你的 IDE 中没有一行代码，也可以将其视为一个预存在的实体。
- en: Again, the framework takes care of things for you, providing you a type/object
    with powerful and already coded functions that are directly usable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，框架会为你处理这些事情，提供一个具有强大且已编码函数的类型/对象，这些函数可以直接使用。
- en: Check out [http://arduino.cc/en/Reference/StringObject](http://arduino.cc/en/Reference/StringObject)
    in the Arduino website.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arduino 网站上查看 [http://arduino.cc/en/Reference/StringObject](http://arduino.cc/en/Reference/StringObject)。
- en: String definition is a construction
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String 定义是一种构造
- en: We talked about definition for variables, but objects have a similar concept
    called **construction**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了变量的定义，但对象有一个类似的概念，称为 **构造**。
- en: For `String` objects, I'm talking about *construction* instead of *definition*
    here but you can consider both terms equal. Declaring a `String` type in Arduino
    core involves an object constructor, which is an object-oriented programming concept;
    we don't have to handle it, fortunately, at this point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `String` 对象，我在这里谈论的是 *构造* 而不是 *定义*，但你可以将这两个术语视为等同。在 Arduino 核心中声明 `String`
    类型涉及对象构造函数，这是一个面向对象编程的概念；幸运的是，我们在这个阶段不必处理它。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using indexes and search inside String
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引和字符串内的搜索
- en: '`Strings` are arrays of `char` elements. This means we can access any element
    of a `String` type through their indexes.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 是 `char` 元素的数组。这意味着我们可以通过它们的索引访问 `String` 类型的任何元素。'
- en: Keep in mind that indexes start at `0` and not at `1`. The `String` objects
    implement some functions for this particular purpose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，索引从 `0` 开始，而不是从 `1` 开始。`String` 对象实现了针对此特定目的的一些函数。
- en: charAt()
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: charAt()
- en: 'Considering a `String` type is declared and defined as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `String` 类型如下声明和定义：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The statement `myString.charAt(3)` returns the fourth element of the string
    that is: `l`. Notice the specific notation used here: we have the name of the
    `String` variable, a dot, then the name of the function (which is a method of
    the `String` object), and the parameter `3` which is passed to the function.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `myString.charAt(3)` 返回字符串中的第四个元素，即：`l`。注意这里使用的特定记法：我们有 `String` 变量的名称，然后是一个点，接着是函数的名称（这是
    `String` 对象的方法），然后是传递给函数的参数 `3`。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `charAt()` function returns a character at a particular position inside
    a string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`charAt()` 函数返回字符串中特定位置的字符。'
- en: '**Syntax**: `string.charAt(int);`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`string.charAt(int);`'
- en: '`int` is an integer representing an index of the `String` value.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 是表示 `String` 值索引的整数。'
- en: '**Returns type**: `char`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**：`char`'
- en: Let's learn about other similar functions. You'll use them very often because,
    as we have already seen, communicating at a very low-level point of view includes
    parsing and processing data, which can very often be strings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解其他类似的功能。你会非常频繁地使用它们，因为我们已经看到，在非常低级别的观点中，通信包括解析和处理数据，这通常可以是字符串。
- en: indexOf() and lastIndexOf()
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`indexOf()` 和 `lastIndexOf()`'
- en: 'Let''s consider the same declaration/definition:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑相同的声明/定义：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`myString.indexOf(''r'')` equals `8`. Indeed, `r` is at the ninth place of
    the value of the string`myString`. `indexOf(val)` and looks for the first occurrence
    of the value `val`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`myString.indexOf(''r'')` 等于 `8`。确实，`r` 在字符串 `myString` 的值中的第九位。`indexOf(val)`
    和 `lastIndexOf(val)` 都是在查找值 `val` 的第一个出现位置。'
- en: 'If you want to begin your search from a particular point, you can specify a
    start point like that: `indexOf(val,start`), where `start` is the index from where
    the function begins to search for the character `val` in the string. As you have
    probably understood, the second argument of this function (`start`) can be omitted,
    the search starts from the first element of the string by default, which is `0`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从特定的点开始搜索，你可以指定一个起点，例如：`indexOf(val,start)`，其中 `start` 是函数开始搜索字符串中字符 `val`
    的索引。正如你可能已经理解的，这个函数的第二个参数（`start`）可以省略，默认情况下搜索从字符串的第一个元素开始，即 `0`。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `indexOf()` function returns the first occurrence of a string or character
    inside a string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()` 函数返回字符串中字符串或字符的第一个出现位置。'
- en: '**Syntax**: `string.indexOf(val, from);`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `string.indexOf(val, from);`'
- en: '`val` is the value to search for which can be a string or a character. `from`
    is the index to start the search from, which is an `int` type. This argument can
    be omitted. The search goes forward.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`val` 是要搜索的值，可以是字符串或字符。`from` 是搜索的起始索引，它是一个 `int` 类型。此参数可以省略。搜索是向前的。'
- en: '**Returns type**: `int`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**: `int`'
- en: Similarly, `lastIndexOf(val,start)` looks for the last occurrence of `val`,
    searching **backwards** from `start`, or from the last element if you omit `start`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`lastIndexOf(val,start)` 从 `start` 或从最后一个元素（如果你省略 `start`）开始向后查找 `val` 的最后一个出现位置。
- en: The `lastIndexOf()` function returns the last occurrence of a string or character
    inside a string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndexOf()` 函数返回字符串中字符串或字符的最后一个出现位置。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Syntax**: `string.lastIndexOf(val, from);`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `string.lastIndexOf(val, from);`'
- en: '`val` is the value to search for which is a string or a character. `from` is
    the index to start the search from which is an `int` type. This argument can be
    omitted. The search goes backwards.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`val` 是要搜索的值，它是一个字符串或字符。`from` 是搜索的起始索引，它是一个 `int` 类型。此参数可以省略。搜索是向后的。'
- en: '**Returns type**: `int`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**: `int`'
- en: startsWith() and endsWith()
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`startsWith()` 和 `endsWith()`'
- en: The `startsWith()` and `endsWith()` functions check whether a string starts
    or ends with, respectively, another string passed as an argument to the function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith()` 和 `endsWith()` 函数分别检查字符串是否以作为函数参数传递的另一个字符串开始或结束。'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `startsWith()` function returns `true` if a string starts with the same
    characters as another string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字符串以与另一个字符串相同的字符开始，则 `startsWith()` 函数返回 `true`。
- en: '**Syntax**: `string.startsWith(string2);`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `string.startsWith(string2);`'
- en: '`string2` is the string pattern with which you want to test the string.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`string2` 是你想要测试的字符串的模式。'
- en: '**Returns type**: `boolean`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**: `boolean`'
- en: I guess, you have begun to understand right now. `endsWith()` works like that
    too, but compares the string pattern with the end of the string tested.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，你现在已经开始理解了。`endsWith()` 也是这样工作的，但它比较字符串模式与测试字符串的末尾。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `endsWith()` function returns `true` if a string ends with the same characters
    as another string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`endsWith()` 函数如果字符串以与另一个字符串相同的字符结尾，则返回 `true`。'
- en: '**Syntax**: `string.endsWith(string2);`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `string.endsWith(string2);`'
- en: '`string2` is the string pattern with which you want to test the string.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`string2` 是你想要测试的字符串的模式。'
- en: '**Returns type**: `boolean`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**: `boolean`'
- en: Concatenation, extraction, and replacement
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接、提取和替换
- en: The preceding operations also introduce new C operators. I'm using them here
    with strings but you'll learn a bit more about them in a more global context further.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作也引入了新的C运算符。我在这里用字符串来使用它们，但你将在更广泛的环境中了解更多关于它们的信息。
- en: Concatenation
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: Concatenation of strings is an operation in which you take two strings and you
    glue them together. It results in a new string composed of the previous two strings.
    The order is important; you have to manage which string you want appended to the
    end of the other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接是一种操作，你取两个字符串并将它们粘合在一起。它产生一个新的字符串，由前两个字符串组成。顺序很重要；你必须管理你想要附加到另一个字符串末尾的字符串。
- en: Concat()
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Concat()
- en: Arduino core comes with the `string.concat()` function, which is especially
    designed for this purpose.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 核心提供了 `string.concat()` 函数，它专门为此目的设计。
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `concat()` function appends one string to another (that is concatenate in
    a defined order).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 函数将一个字符串附加到另一个字符串（即按定义的顺序连接）。'
- en: '**Syntax**: `string.concat(string2);`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`string.concat(string2);`'
- en: '`string2` is a string and is appended to the end of string. Remember that,
    the previous content of the string is overwritten as a result of the concatenation.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`string2` 是一个字符串，并将其附加到字符串的末尾。记住，由于连接，字符串的先前内容被覆盖。'
- en: '**Returns type**: `int` (the function returns `1` if the concatenation happens
    correctly).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**：`int`（如果连接发生正确，函数返回 `1`）。'
- en: Using the + operator on strings
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在字符串上使用 + 操作符
- en: 'There is another way to concatenate two strings. That one doesn''t use a function
    but an operator: `+`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接两个字符串的方法。这不是使用函数，而是使用操作符：`+`。
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code is the same as the previous one. `+` is an operator that I''ll describe
    better a bit later. I''m giving you something more here: a condensed notation
    for the `+` operator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的一样。`+` 是一个稍后我会更好地描述的操作符。我在这里给你提供了一些东西：`+` 操作符的缩写表示法：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This can also be written as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try it. You'll understand.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。你会理解的。
- en: Extract and replace
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取和替换
- en: String manipulation and alteration can be done using some very useful functions
    extracting and replacing elements in the string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一些非常有用的函数进行字符串操作和修改，提取和替换字符串中的元素。
- en: substring() is the extractor
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`substring()` 是提取器'
- en: 'You want to extract a part of a string. Imagine if the Arduino board sends
    messages with a specific and defined communication protocol:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你想提取字符串的一部分。想象一下，如果Arduino板通过特定的和定义良好的通信协议发送消息：
- en: '`<output number>.<value>`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`<output number>.<value>`'
- en: 'The output number is coded with two characters every time, and the value with
    three (45 has to be written as 045). I often work like that and pop out these
    kind of messages from the serial port of my computer via the USB when I need to;
    for instance, send a command to light up a particular LED with a particular intensity.
    If I want to light the LED on the fourth output at 100/127, I send:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数字每次用两个字符编码，值用三个字符（45必须写成045）。我经常这样工作，并在需要时从我的电脑的串行端口通过USB弹出这类消息；例如，发送一个命令以特定强度点亮特定的LED。如果我想在第四个输出上以100/127的强度点亮LED，我会发送：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Arduino *needs* to understand this message. Without going further with the communication
    protocol design, as that will be covered in [Chapter 7](ch07.html "Chapter 7. Talking
    over Serial"), *Talking Over Serial*, I want to introduce you to a new feature—splitting
    strings.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino *需要* 理解这条消息。在不进一步讨论通信协议设计的情况下，因为这将涵盖在[第7章](ch07.html "第7章。通过串行通信")——*通过串行通信*，我想向你介绍一个新功能——拆分字符串。
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This piece of code splits the message received by Arduino into two parts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将Arduino接收到的消息分成两部分。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `substring()` function extracts a part of a string from a start index (included)
    to another (not included).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 函数从起始索引（包含）到另一个索引（不包含）提取字符串的一部分。'
- en: '**Syntax**: `string.substring(from, to);`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`string.substring(from, to);`'
- en: '`from` is the start index. The result includes the content of the `from` string
    element. `to` is the end index. The result doesn''t include the content of the
    `end` string element, it can be omitted.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`from` 是起始索引。结果包括 `from` 字符串元素的内容。`to` 是结束索引。结果不包括 `end` 字符串元素的内容，它可以省略。'
- en: '**Returns type**: `String`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**：`String`'
- en: Let's push the concept of string extract and split it a bit further.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨字符串提取的概念并对其进行拆分。
- en: Splitting a string using a separator
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用分隔符拆分字符串
- en: Let's challenge ourselves a bit. Imagine I don't know or I'm not sure about
    the message format (two characters, a dot, and three characters, that we have
    just seen). This is a real life case; while learning to make things, we often
    meet strange cases where those *things* don't behave as expected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微挑战一下自己。想象一下，我不知道或者我不确定消息格式（两个字符，一个点，然后是三个字符，这是我们刚刚看到的）。这是一个真实生活中的案例；在学习制作东西的过程中，我们经常会遇到那些*东西*没有按预期表现的情况。
- en: Imagine I want to use the dot as a separator, because I'm very sure about it.
    How can I do that using the things that we have already learned? I'd need to extract
    characters. OK, I know `substring()` now!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想使用点作为分隔符，因为我非常确定。我该如何使用我们已经学过的东西来实现这一点？我需要提取字符。好吧，我现在知道了`substring()`函数！
- en: But I also need an index to extract the content at a particular place. I also
    know how to find the index of an occurrence of a character in a string, using
    `indexOf()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但我还需要一个索引来提取特定位置的内容。我也知道如何使用`indexOf()`在字符串中找到一个字符的索引。
- en: 'Here is how we do that:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就是这样做的：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Firstly, I find the split point index (the place in the string where the dot
    sits). Secondly, I use this result as the last element of my extracted substring.
    Don't worry, the last element isn't included, which means `currentOutputNumber`
    doesn't contain the dot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我找到分割点索引（字符串中点所在的位置）。其次，我将这个结果用作提取子字符串的最后一个元素。别担心，最后一个元素不包括在内，这意味着`currentOutputNumber`不包含点。
- en: At last, I'm using `splitPointIndex` one more time as the start of the second
    part of the string that I need to extract. And what? I add the integer `1` to
    it because, as you master `substring()` now and know, the element corresponding
    to the start index is always included by the `substring()` operation. We don't
    want that dot because it is only a separator. Right?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我再次使用`splitPointIndex`作为需要提取的字符串第二部分的起始位置。然后呢？我将整数`1`加到它上面，因为，正如你现在掌握的`substring()`函数所知，与起始索引对应的元素总是被`substring()`操作包括。我们不想那个点，因为它只是一个分隔符。对吧？
- en: Don't worry if you are a bit lost. Things will become clearer in the next subchapters
    and especially when we'll make Arduino process things, which will come a bit later
    in the book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在有点困惑，别担心。在下一章和特别是当我们开始用Arduino处理事情时，事情会变得更加清晰，这在书中稍后会出现。
- en: Replacement
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 替换
- en: Replacements are often used when we want to convert a communication protocol
    to another. For instance, we need to replace a part of a string by another to
    prepare a further process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将通信协议转换为另一个协议时，通常会使用替换操作。例如，我们需要替换字符串的一部分，以便为后续处理做准备。
- en: Let's take our previous example. We now want to replace the dot by another character
    because we want to send the result to another process that only understands the
    space character as a separator.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前的例子为例。现在我们想要将点替换为另一个字符，因为我们想将结果发送到另一个只理解空格字符作为分隔符的进程。
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Firstly, I put the content of the `receivedMessage` variable into another variable
    named `originalMessage` because I know the `replace()` function will definitely
    modify the processed string. Then I process `receivedMessage` with the `replace()`
    function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将`receivedMessage`变量的内容放入另一个名为`originalMessage`的变量中，因为我知道`replace()`函数肯定会修改处理后的字符串。然后我用`replace()`函数处理`receivedMessage`。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `replace()` function replaces a part of a string with another string.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`函数用另一个字符串替换字符串的一部分。'
- en: '**Syntax**: `string.replace(substringToReplace, replacingSubstring);`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`string.replace(substringToReplace, replacingSubstring);`'
- en: '`from` is the start index. The result includes the content of a `from` string
    element. `to` is the end index. The result doesn''t include the content of an
    `end` string element, it can be omitted. Remember that, the previous content of
    the string is overwritten as a result of the replacement (copy it to another string
    variable if you want to keep it).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`是起始索引。结果包括`from`字符串元素的内容。`to`是结束索引。结果不包括`end`字符串元素的内容，它可以省略。记住，替换操作会覆盖字符串的先前内容（如果你想要保留它，请将其复制到另一个字符串变量中）。'
- en: '**Returns type**: `int` (the function returns `1` if the concatenation happens
    correctly).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**：`int`（如果连接操作正确发生，函数返回`1`）。'
- en: This function can, obviously, replace a character by another character of course.
    A string is an array of characters. It is not strange that one character can be
    processed as a string with only one element. Let's think about it a bit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数显然可以替换一个字符为另一个字符。字符串是字符数组。一个字符可以作为一个只有一个元素的字符串进行处理并不奇怪。让我们稍微思考一下。
- en: Other string functions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他字符串函数
- en: There are some other string processing functions I'd like to quickly quote here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想快速引用一些其他字符串处理函数。
- en: toCharArray()
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`toCharArray()`'
- en: This function copies all the string's characters into a "real" character array,
    also named, for internal reasons, a buffer. You can check [http://arduino.cc/en/Reference/StringToCharArray](http://arduino.cc/en/Reference/StringToCharArray).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将字符串的所有字符复制到一个名为“缓冲区”的“真实”字符数组中，出于内部原因，也被称为缓冲区。您可以查看[http://arduino.cc/en/Reference/StringToCharArray](http://arduino.cc/en/Reference/StringToCharArray)。
- en: toLowerCase() and toUpperCase()
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`toLowerCase()` 和 `toUpperCase()`'
- en: These functions replace the strings processed by them by the same string but
    with all characters in lowercase and uppercase respectively. You can check [http://arduino.cc/en/Reference/StringToLower](http://arduino.cc/en/Reference/StringToLower)
    and [http://arduino.cc/en/Reference/StringToUpperCase](http://arduino.cc/en/Reference/StringToUpperCase).
    Be careful, as it overwrites the string processed with the result of this process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将它们处理的字符串替换为相同但所有字符均为小写和大写的字符串。您可以查看[http://arduino.cc/en/Reference/StringToLower](http://arduino.cc/en/Reference/StringToLower)
    和 [http://arduino.cc/en/Reference/StringToUpperCase](http://arduino.cc/en/Reference/StringToUpperCase)。请注意，因为它会覆盖经过此过程处理的字符串。
- en: trim()
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`trim()`'
- en: This function removes all whitespace in your string. You can check [http://arduino.cc/en/Reference/StringTrim](http://arduino.cc/en/Reference/StringTrim).
    Again, be careful, as it overwrites the strings processed with the result of this
    process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数会移除字符串中的所有空白字符。您可以查看[http://arduino.cc/en/Reference/StringTrim](http://arduino.cc/en/Reference/StringTrim)。再次提醒，请注意，因为它会覆盖经过此过程处理的字符串。
- en: length()
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`length()`'
- en: I wanted to end with this functioin. This is the one you'll use a lot. It provides
    the length of a string as an integer. You can check [http://arduino.cc/en/Reference/StringLength](http://arduino.cc/en/Reference/StringLength).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我想以这个函数结束。这是您将大量使用的函数。它以整数形式提供字符串的长度。您可以查看[http://arduino.cc/en/Reference/StringLength](http://arduino.cc/en/Reference/StringLength)。
- en: Testing variables on the board
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在板上测试变量
- en: 'The following is a piece of code that you can also find in the folder `Chapter03/VariablesVariations/`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段您也可以在文件夹 `Chapter03/VariablesVariations/` 中找到的代码：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Upload this code to your board, then switch on the serial monitor. At last,
    reset the board by pushing the reset button and observe. The board writes directly
    to your serial monitor as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码上传到您的板子，然后打开串行监视器。最后，通过按下复位按钮来复位板子并观察。板子会直接将内容写入您的串行监视器，如下面的截图所示：
- en: '![Testing variables on the board](img/7584_03_002.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![在板上测试变量](img/7584_03_002.jpg)'
- en: The serial monitor showing you what your board is saying
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 显示您板子所说内容的串行监视器
- en: Some explanations
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些解释
- en: All explanations will come progressively, but here is a small summary of what
    is happening right now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有解释将逐步进行，但这里是对当前发生情况的小结。
- en: I first declare my variables and then define some in `setup()`. I could have
    declared and defined them at the same time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先声明了我的变量，然后在 `setup()` 中定义了一些。我本可以在同一时间声明和定义它们。
- en: Refreshing your memory, `setup()` is executed only one time at the board startup.
    Then, the `loop()` function is executed infinitely, sequentially running each
    row of statement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过刷新记忆，`setup()` 只在板子启动时执行一次。然后，`loop()` 函数无限次地执行，依次运行每一行语句。
- en: In `loop()`, I'm first testing `myBoolean`, introducing the `if()` conditional
    statement. We'll learn this in this chapter too.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 中，我首先测试 `myBoolean`，引入 `if()` 条件语句。我们将在本章学习这一点。
- en: Then, I'll play a bit with the `char`, `int`, and `String` types, printing some
    variables, then modifying them and reprinting them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会对 `char`、`int` 和 `String` 类型进行一些操作，打印一些变量，然后修改它们并重新打印。
- en: The main point to note here is the `if()` and `else` structure. Look at it,
    then relax, answers will come very soon.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的主要点是 `if()` 和 `else` 结构。看看它，然后放松，答案很快就会到来。
- en: The scope concept
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围概念
- en: The scope can be defined as a particular property of a variable (and functions,
    as we'll see further). Considering the source code, the scope of a variable is
    that part of the code where this variable is visible and usable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以定义为变量的特定属性（以及函数，正如我们将看到的）。考虑到源代码，变量的范围是代码中该变量可见和可用的部分。
- en: A variable can be *global* and then is visible and usable everywhere in the
    source code. But a variable can also be *local*, declared inside a function, for
    instance, and that is visible only inside this particular function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量可以是*全局*的，然后在整个源代码中可见并可使用。但变量也可以是*局部*的，例如在函数内部声明，那么它只在这个特定函数内部可见。
- en: The scope property is *implicitly* set by the place of the variable's declaration
    in the code. You probably just understood that every variable could be declared
    globally. Usually, I follow my own *digital haiku*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域属性是通过变量声明在代码中的位置隐式设置的。你可能刚刚了解到每个变量都可以全局声明。通常，我遵循自己的*数字俳句*。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Let each part of your code know only variables that it has to know, no more.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码的每一部分只知道它必须知道的变量，不再多。
- en: 'Trying to minimize the scope of the variables is definitely a winning way.
    Check out the following example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量缩小变量的作用域绝对是一个获胜的方法。查看以下示例：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We could represent the code's scope as a box more or less imbricated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码的作用域表示为一个或多或少嵌套的框。
- en: '![The scope concept](img/7584_03_03.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![作用域概念](img/7584_03_03.jpg)'
- en: Code's scope seen as boxes
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的作用域被视为框
- en: The external box represents the source code's highest level of scope. Everything
    declared at this level is visible and usable by all functions; it is the global
    level.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 外部框代表源代码的最高作用域级别。在这个级别声明的所有声明都可以被所有函数看到和使用；它是全局级别。
- en: Every other box represents a particular scope in itself. Every variable declared
    in one scope cannot be seen and used in higher scopes neither in the same level
    ones.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个其他框代表一个特定的作用域。在一个作用域中声明的每个变量都不能在更高作用域中看到和使用，也不能在同一级别的其他作用域中。
- en: This representation is very useful to my students who always need more visuals.
    We'll also use this metaphor while we talk about *libraries*, especially. What
    is declared in libraries can be used in our code if we include some specific headers
    at the beginning of the code, of course.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示对我那些总是需要更多视觉的学生非常有用。当我们谈论*库*时，我们也会使用这个隐喻，特别是。库中声明的声明可以在我们的代码中使用，如果我们当然在代码开头包含一些特定的头文件。
- en: static, volatile, and const qualifiers
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态、易变和const限定符
- en: '**Qualifiers** are the keywords that are used to change the processor''s behavior
    considering the *qualified* variable. In reality, the compiler will use these
    qualifiers to change characteristics of the considered variables in the binary
    firmware produced. We are going to learn about three qualifiers: `static`, `volatile`,
    and `const`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**限定符**是用于根据*限定*变量改变处理器行为的关键字。实际上，编译器将使用这些限定符来改变生成的二进制固件中考虑的变量的特性。我们将学习三个限定符：`static`、`volatile`和`const`。'
- en: static
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态
- en: 'When you use the `static` qualifier for a variable inside a function, this
    makes the variable persistent between two calls of the function. Declaring a variable
    inside a function makes the variable, implicitly, local to the function as we
    just learned. It means only the function can know and use the variable. For instance:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数内部使用`static`限定符时，这会使变量在两次函数调用之间保持持久。在函数内部声明变量使变量隐式地成为函数的局部变量，正如我们刚刚学到的。这意味着只有函数才能知道和使用该变量。例如：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This variable is seen in the `myFunction` function only. But what happens after
    the first loop? The previous value is lost and as soon as `int aLocalVariable;`
    is executed, a new variable is set up, with a value of zero. Check out this new
    piece of code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量仅在`myFunction`函数中可见。但是第一次循环之后会发生什么？之前的值丢失了，一旦执行了`int aLocalVariable;`，就会设置一个新的变量，其值为零。查看以下新代码块：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This variable is seen in the `myFunction` function only and, after adding an
    argument has modified it, we can play with its new value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量仅在`myFunction`函数中可见，并且在添加参数后修改了它，我们可以玩弄其新值。
- en: In this case, the variable is qualified as `static`. It means the variable is
    declared *only* the first time. This provides a useful way to keep trace of something
    and, at the same time, make the variable, containing this trace, local.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量被限定为`static`。这意味着变量仅在第一次声明时存在。这提供了一种跟踪事物的有用方式，同时使包含此跟踪的变量局部化。
- en: volatile
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易变的
- en: When you use the `volatile` qualifier in a variable declaration statement, this
    variable is loaded from the RAM instead of the storage register memory space of
    the board. The difference is subtle and this qualifier is used in specific cases
    where your code itself doesn't have the control of something else executed on
    the processor. One example, among others, is the use of interrupts. We'll see
    that a bit later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在变量声明语句中使用`volatile`修饰符时，此变量将从RAM中加载，而不是从板上的存储寄存器内存空间中加载。这种差异很微妙，并且此修饰符在特定情况下使用，在这些情况下，你的代码本身无法控制处理器上执行的其他操作。其中一个例子，在其他例子中，是使用中断。我们稍后会看到这一点。
- en: Basically, your code runs normally, and some instructions are triggered not
    by this code, but by another process such as an external event. Indeed, our code
    doesn't know when and what **Interrupt Service Routine** (**ISR**) does, but it
    stops when something like that occurs, letting the CPU run ISR, then it continues.
    Loading the variable from the RAM prevents some possible inconsistencies of variable
    value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你的代码正常运行，一些指令不是由这段代码触发的，而是由另一个过程，如外部事件触发的。确实，我们的代码不知道何时以及**中断服务例程**（**ISR**）做什么，但它在发生类似情况时停止，让CPU运行ISR，然后继续。从RAM中加载变量可以防止变量值的一些可能的不一致性。
- en: const
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: const
- en: The `const` qualifier means constant. Qualifying a variable with `const` makes
    it unvariable, which can sound weird.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`修饰符表示常量。使用`const`修饰变量使其不可变，这听起来可能有些奇怪。'
- en: 'If you try to write a value to a `const` variable after its declaration/definition
    statement, the compiler gives an error. The scope''s concept applies here too;
    we can qualify a variable declared inside a function, or globally. This statement
    defines and declares the `masterMidiChannel` variable as a constant:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在声明/定义语句之后尝试向`const`变量写入值，编译器会给出错误。作用域的概念也适用于这里；我们可以在函数内部或全局范围内修饰变量。此语句定义并声明了`masterMidiChannel`变量为常量：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is equivalent to:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is *no* semicolon after a `#define` statement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#define`语句之后没有分号。
- en: '`#define` seems a bit less used as `const`, probably because it cannot be used
    for constant arrays. Whatever the case, `const` can always be used. Now, let''s
    move on and learn some new operators.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define`似乎比`const`用得少一些，可能是因为它不能用于常量数组。无论情况如何，`const`总是可以使用的。现在，让我们继续学习一些新的运算符。'
- en: Operators, operator structures, and precedence
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符、运算符结构和优先级
- en: We have already met a lot of operators. Let's first check the arithmetic operators.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了很多运算符。让我们首先检查一下算术运算符。
- en: Arithmetic operators and types
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符和类型
- en: 'Arithmetic operators are:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符包括：
- en: '`+` (plus sign)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` (加号)'
- en: '`-` (minus)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` (减法)'
- en: '`*` (asterisk)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` (星号)'
- en: '`/` (slash)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` (斜杠)'
- en: '`%` (percent)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%` (百分号)'
- en: '`=` (equal)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` (等于)'
- en: 'I''m beginning with the last one: `=` **.** It is the **assignment** operator.
    We have already used it a lot to define a variable, which just means to assign
    a value to it. For instance:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我从最后一个开始讲：`=` **.** 它是**赋值**运算符。我们已经多次使用它来定义变量，这仅仅意味着给它赋值。例如：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the other operators, I''m going to distinguish two different cases in the
    following: character types, which include `char` and `String`, and numerical types.
    Operators can change their effect a bit according to the types of variables.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他运算符，我将在以下内容中区分两种不同的情况：字符类型，包括`char`和`String`，以及数值类型。运算符可以根据变量的类型改变其效果。
- en: Character types
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类型
- en: '`char` and `String` can only be processed by `+`. As you may have guessed,
    `+` is the concatenation operator:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`和`String`只能通过`+`来处理。正如你可能已经猜到的，`+`是连接运算符：'
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this code, concatenation of `myResultString` and `myString` results in the
    `Hello World` string.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`myResultString`和`myString`的连接生成了`Hello World`字符串。
- en: Numerical types
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'With all numerical types (`int`, `word`, `long`, `float`, `double`), you can
    use the following operators:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有数值类型（`int`、`word`、`long`、`float`、`double`），你可以使用以下运算符：
- en: '`+` (addition)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` (加法)'
- en: '`-` (subtraction)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` (减号)'
- en: '`*` (multiplication)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` (乘法)'
- en: '`/` (division)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` (除法)'
- en: '`%` (modulo)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%` (取模)'
- en: 'A basic example of multiplication is shown as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个乘法的基本示例：
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As soon as you use a `float` or `double` type as one of the operand, the floating
    point calculation process will be used.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用`float`或`double`类型作为操作数之一，就会使用浮点计算过程。
- en: In the previous code, the result of `OutputOscillatorAmplitude * multiplier`
    is a `float` value. Of course, division by zero is *prohibited*; the reason is
    math instead of C or Arduino.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`OutputOscillatorAmplitude * multiplier` 的结果是 `float` 类型的值。当然，除以零是 *禁止的*；原因在于数学而不是C或Arduino。
- en: '**Modulo** is simply the remainder of the division of one integer by another
    one. We''ll use it a lot to keep variables into a controlled and chosen range.
    If you make a variable grow to infinite but manipulate its modulo by 7 for instance,
    the result will always be between 0 (when the growing variable will be a multiple
    of 7) and 6, constraining the growing variable.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**取模**是简单地将一个整数除以另一个整数的余数。我们将大量使用它来保持变量在受控和选择的范围内。如果您让一个变量无限增长，但通过例如7来操作它的模，结果将始终在0（当增长变量是7的倍数时）和6之间，从而约束增长变量。'
- en: Condensed notations and precedence
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化表示和优先级
- en: As you may have noticed, there is a condensed way of writing an operation with
    these previously explained operators. Let's see two equivalent notations and explain
    this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，使用之前解释过的运算符有一种简化的写法。让我们看看两种等价的表达式并解释这一点。
- en: 'Example 1:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Example 2:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These two pieces of code are equivalent. The first one teaches you about the
    precedence of operators. There is a table given in *Appendix B, Operator Precedence
    in C and C++* with all precedencies. Let's learn some right now.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这两段代码是等价的。第一段向您介绍了运算符的优先级。在 *附录B，C和C++运算符优先级* 中给出了所有优先级。让我们现在学习一些。
- en: '`+`, `-`, `*`, `/`, and `%` have a greater precedence over `=`. That means
    `myInt1 + myInt2` is calculated before the assignment operator, then, the result
    is assigned to `myInt1`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`, `-`, `*`, `/`, 和 `%` 的优先级高于 `=`。这意味着 `myInt1 + myInt2` 在赋值运算符之前计算，然后，结果被赋值给
    `myInt1`。'
- en: 'The second one is the condensed version. It is equivalent to the first version
    and thus, precedence applies here too. A little tricky example is shown as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是简化版本。它与第一个版本等价，因此这里也适用优先级。以下是一个有点棘手的示例：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You need to know that `+` has a higher precedence over `+=`. It means the order
    of operations is: first, `myInt2 + myInt2` then `myInt1 +` the result of the freshly
    made calculation `myInt2 + myInt2`. Then, the result of the second is assigned
    to `myInt1`. This means it is equivalent to:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道`+`的优先级高于`+=`。这意味着运算顺序是：首先，`myInt2 + myInt2`，然后是`myInt1 +`刚刚计算出的结果`myInt2
    + myInt2`。然后，第二个运算的结果被赋值给`myInt1`。这意味着它等价于：
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Increment and decrement operators
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量和减量运算符
- en: 'I want to point you to another condensed notation you''ll meet often: the double
    operator.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提醒您注意您经常会遇到的另一种简化表示：双重运算符。
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`++` is equivalent to `+=1`, `--` is equivalent to `-=1`. These are called
    *suffix increment* (`++`) and *suffix decrement* (`--`). They can also be used
    as *prefix*. `++` and `--` as prefixes have lower precedencies than their equivalent
    used as suffix but in both cases, the precedence is very much higher than `+`,
    `-`, `/`, `*`, and even `=` and `+=`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 等价于 `+=1`，`--` 等价于 `-=1`。这些被称为 *后缀增量* (`++`) 和 *后缀减量* (`--`)。它们也可以用作 *前缀*。作为前缀的
    `++` 和 `--` 的优先级低于它们作为后缀使用时的等效运算符，但在两种情况下，优先级都远高于 `+`, `-`, `/`, `*`，甚至 `=` 和
    `+=`。'
- en: The following is a condensed table I can give you with the most used cases.
    In each group, the operators have the same precedence. It drives the expression
    `myInt++ + 3` to be ambiguous. Here, the use of parenthesis helps to define which
    calculation will be made first.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个我可以为您提供的最常用情况的简化表格。在每组中，运算符具有相同的优先级。它使得表达式 `myInt++ + 3` 变得模糊不清。在这里，括号的使用有助于确定哪个计算将首先进行。
- en: '| Precedencies groups | Operators | Names |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 优先级组 | 运算符 | 名称 |'
- en: '| --- | --- | --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2 | `++``--``()``[]` | Suffix incrementSuffix decrementFunction callArray
    element access |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `++``--``()``[]` | 后缀增量后缀减量函数调用数组元素访问 |'
- en: '| 3 | `++``--` | Prefix incrementPrefix decrement |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `++``--` | 前缀增量前缀减量 |'
- en: '| 5 | `*``/``%` | MultiplicationDivisionModulo |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `*``/``%` | 乘法除法取模 |'
- en: '| 6 | `+``-` | AdditionSubtraction |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `+``-` | 加法减法 |'
- en: '| 16 | `=``+=``-=``*=``/=``%=` | AssignmentAssignment by sumAssignment by differenceAssignment
    by productAssignment by quotientAssignment by remainder |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 16 | `=``+=``-=``*=``/=``%=` | 赋值加法赋值减法赋值乘法赋值除法赋值取模 |'
- en: 'I guess you begin to feel a bit better with operators, right? Let''s continue
    with a very important step: types conversion.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我想您现在对运算符的感觉好一些了吧？让我们继续进行一个非常重要的步骤：类型转换。
- en: Types manipulations
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型操作
- en: When you design a program, there is an important step consisting of choosing
    the right type for each variable.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计一个程序时，有一个重要的步骤，就是为每个变量选择正确的类型。
- en: Choosing the right type
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的类型
- en: Sometimes, the choice is constrained by external factors. This happens when,
    for instance, you use the Arduino with an external sensor able to send data coded
    as integers in 10 bits (210 = 1024 steps of resolution). Would you choose `byte`
    type knowing it only provides a way to store number from 0 to 255? Probably not!
    You'll choose `int`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，选择会受到外部因素的影响。例如，当你使用Arduino与一个能够以10位整数编码数据的外部传感器时，这种情况就会发生（2^10 = 1024个分辨率步骤）。你知道`byte`类型只能存储从0到255的数字吗？你可能不会选择它！你会选择`int`。
- en: Sometimes you have to choose it yourself. Imagine you have data coming to the
    board from a Max 6 framework patch on the computer via your serial connection
    (using USB). Because it is the most convenient, since you designed it like that,
    the patch pops out `float` numbers encapsulated into string messages to the board.
    After having parsed, cut those messages into pieces to extract the information
    you need (which is the `float` part), would you choose to store it into `int`?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你必须自己做出选择。想象一下，你从电脑上的Max 6框架补丁通过串行连接（使用USB）将数据发送到板上。因为这是最方便的，既然你设计了它这样，补丁就会弹出封装在字符串消息中的`float`数字到板上。在解析后，将这些消息切割成片段以提取你需要的信息（即`float`部分），你会选择将其存储到`int`中吗？
- en: That one is a bit more difficult to answer. It involves a *conversion* process.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有点难以回答。它涉及到一个*转换*过程。
- en: Implicit and explicit types conversions
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式类型转换
- en: Type conversion is the process that changes an entity data type into another.
    Please notice I didn't talk about variable, but entity.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是将实体数据类型转换为另一个的过程。请注意，我没有提到变量，而是提到实体。
- en: It is a consequence of C design that we can convert only the values stored in
    variables, others keep their type until their lives end, which is when the program's
    execution ends.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C语言设计的结果，我们只能转换存储在变量中的值，其他值会保持它们的类型直到它们的生命周期结束，也就是程序执行结束的时候。
- en: Type conversion can be *implicitly* done or *explicitly* made. To be sure everyone
    is with me here, I'll state that *implicitly means not visibly and consciously
    written*, compared to *explicitly that means specifically written in code*, here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换可以是*隐式地*执行或*显式地*进行。为了确保每个人都跟我在一起，我会声明*隐式地意味着不是明显和有意识地写出来的*，与*显式地意味着在代码中明确写出来的*相对。
- en: Implicit type conversion
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式类型转换
- en: Sometimes, it is also called *coercion*. This happens when you don't specify
    anything for the compiler that has to make an automatic conversion following its
    own basic (but often smart enough) rules. The classic example is the conversion
    of a `float` value into an `int` value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，这也被称为*强制转换*。这发生在你没有为编译器指定任何内容，编译器必须根据它自己的基本（但通常足够智能）规则自动进行转换时。一个经典的例子是将`float`值转换为`int`值。
- en: '[PRE38]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I'm using the assignment operator (`=`) to put the content of `myFloat` into
    `myInt`. It causes **truncation** of the `float` value, that is, the *removal
    of the decimal part*. You have definitely lost something if you continue to work
    only with the `myInt` variable instead of `myFloat`. It can be okay, but you have
    to keep it in mind.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用赋值运算符（`=`）将`myFloat`的内容放入`myInt`。这会导致`float`值的**截断**，即*去除小数部分*。如果你继续只使用`myInt`变量而不是`myFloat`，你肯定已经丢失了一些东西。这可能没问题，但你必须记住这一点。
- en: Another less classic example is the implicit conversion of `int` type to `float`.
    `int` doesn't have a decimal part. The implicit conversion to `float` won't produce
    something other than a decimal part that equals zero. This is the easy part.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太经典的例子是`int`类型到`float`类型的隐式转换。`int`没有小数部分。隐式转换为`float`不会产生除了等于零的小数部分之外的其他东西。这是简单的一部分。
- en: 'But be careful, you could be surprised by the implicit conversion of `int`
    to `float`. Integers are encoded over 32 bits, but `float`, even if they are 32
    bits, have a *significand* (also called mantissa) encoded over 23 bits. If you
    don''t remember this precisely, it is okay. But I want you to remember this example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心，你可能会对`int`到`float`的隐式转换感到惊讶。整数是使用32位编码的，但即使`float`也是32位，它们的*尾数*（也称为尾数）是使用23位编码的。如果你没有精确地记住这一点，没关系。但我希望你能记住这个例子：
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of the code is shown as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下所示：
- en: '![Implicit type conversion](img/7584_03_004.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![隐式类型转换](img/7584_03_004.jpg)'
- en: Strange results from int to float implicit conversion
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从`int`到`float`隐式转换的奇怪结果
- en: 'I stored `123456789` into a `long int` type, which is totally legal (`long
    int` are 32-bits signed integers that are able to store integersfrom `-2147483648`
    to `2147483647`). After the assignment, I''m displaying the result that is: **123456792.00**.
    We expected `123456789.00` of course.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`123456789`存储到`long int`类型中，这是完全合法的（`long int`是32位有符号整数，能够存储从`-2147483648`到`2147483647`的整数）。赋值后，我显示的结果是：**123456792.00**。我们当然期望的是`123456789.00`。
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Implicit types conversions rules:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型转换规则：
- en: '`long int` to `float` can cause wrong results'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long int`到`float`可能会导致错误的结果'
- en: '`float` to `int` removes the decimal part'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`到`int`会移除小数部分'
- en: '`double` to `float` rounds digit of double'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`到`float`会四舍五入`double`的数字'
- en: '`long int` to `int` drops the encoded higher bits'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long int`到`int`会丢弃编码的高位比特'
- en: Explicit type conversion
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式类型转换
- en: 'If you want to have predictable results, every time you can convert types explicitly.
    There are six conversion functions included in the Arduino core:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要有可预测的结果，每次你都可以显式地转换类型。Arduino核心包含了六个转换函数：
- en: char()
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: char()
- en: int()
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int()
- en: float()
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: float()
- en: word()
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: word()
- en: byte()
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: byte()
- en: long()
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: long()
- en: We can use them by passing the variable you want to convert as an argument of
    the function. For instance, `myFloat = float(myInt)`; where `myFloat` is a `float`
    type and `myInt` is an `int` type. Don't worry about the use, we'll use them a
    bit later in our firmware.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将你想转换的变量作为函数的参数来使用它们。例如，`myFloat = float(myInt)`；其中`myFloat`是`float`类型，`myInt`是`int`类型。不用担心使用，我们会在我们的固件中稍后使用它们。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'My rule about conversion: Take care of each type conversion you make. None
    should be obvious for you and it can cause an error in your logic, even if the
    syntax is totally correct.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我的转换规则：注意你进行的每一个类型转换。对于你来说，它们都不应该是显而易见的，并且即使语法完全正确，它们也可能导致你的逻辑错误。
- en: Comparing values and Boolean operators
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较值和布尔运算符
- en: We now know how to store entities into variables, convert values, and choose
    the right conversion method. We are now going to learn how to compare variable
    values.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何将实体存储到变量中，转换值，并选择正确的转换方法。我们现在将学习如何比较变量的值。
- en: Comparison expressions
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较表达式
- en: 'There are six comparison operators:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个比较运算符：
- en: '`==` (equal)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` (等于)'
- en: '`!=` (not equal)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` (不等于)'
- en: '`<` (less than)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` (小于)'
- en: '`>` (greater than)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` (大于)'
- en: '`<=` (less than or equal to)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` (小于或等于)'
- en: '`>=` (greater than or equal to)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` (大于或等于)'
- en: 'The following is a comparison expression in code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码中的比较表达式：
- en: '[PRE40]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: An expression like that does nothing, but it is legal. Comparing two elements
    produces a result and in this small example, it isn't used to trigger or make
    anything. `myInt1 > myFloat` is a comparison expression. The result is, obviously,
    `true` or `false`, I mean it is a `boolean` value. Here it is `false` because
    `4` is not greater than `5.76`. We can also combine comparison expressions together
    to create more complex expressions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表达式没有任何作用，但它合法。比较两个元素会产生一个结果，在这个小例子中，它没有被用来触发或执行任何操作。`myInt1 > myFloat`是一个比较表达式。结果显然是`true`或`false`，我的意思是它是一个`boolean`值。这里它是`false`，因为`4`不大于`5.76`。我们也可以将比较表达式组合起来，以创建更复杂的表达式。
- en: Combining comparisons with Boolean operators
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布尔运算符组合比较
- en: 'There are three Boolean operators:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个布尔运算符：
- en: '`&&` (and)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&` (和)'
- en: '`||` (or)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||` (或)'
- en: '`!` (not)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` (非)'
- en: It is time to remember some logic operations using three small tables. You can
    read those tables like column element + comparison operator + row element; the
    result of the operation is at the intersection of the column and the row.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回忆一些使用三个小表的逻辑运算了。你可以像阅读列元素 + 比较运算符 + 行元素那样阅读这些表；运算的结果位于列和行的交叉点。
- en: 'The binary operator AND, also written as `&&`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '二元运算符AND，也写作`&&`:'
- en: '| `&&` | true | false |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | true | false |'
- en: '| true | true | false |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| true | true | false |'
- en: '| false | false | false |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false |'
- en: 'Then the binary operator OR, also written as ||:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '然后是二元运算符OR，也写作`||`:'
- en: '| `&#124;&#124;` | true | false |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | true | false |'
- en: '| true | true | true |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '| false | true | false |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| false | true | false |'
- en: 'Lastly, the unary operator NOT, also written as `!`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，一元运算符NOT，也写作`!`:'
- en: '|   | true | false |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|   | true | false |'
- en: '| `!` | false | true |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `!` | false | true |'
- en: For instance, true `&&` false = false, false `||` true = true. `&&` and `||`
    are *binary operators*, they can *compare* two expressions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，true `&&` false = false，false `||` true = true。`&&`和`||`是*二元运算符*，它们可以*比较*两个表达式。
- en: '`!` is a *unary operator* and can only work with one expression, negating it
    logically. `&&` is the logical AND. It is true when both expressions compared
    are true, false in all other cases. `||` is the logic OR. It is true when one
    expression at least is true, false when they are both false. It is the inclusive
    OR. `!` is the negation operator, the NOT. It basically inverts false and true
    into true and false.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`!` 是一个 *一元运算符*，只能与一个表达式一起使用，逻辑上取反。`&&` 是逻辑与。当比较的两个表达式都为真时为真，在其他所有情况下为假。`||`
    是逻辑或。当至少有一个表达式为真时为真，当它们都为假时为假。它是包含性或。`!` 是否定运算符，即 NOT。它基本上将假和真反转成真和假。'
- en: These different operations are really useful and necessary when you want to
    carry out some tests in your code. For instance, if you want to compare a variable
    to a specific value.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在代码中执行一些测试时，这些不同的操作非常有用且必要。例如，如果你想比较一个变量与特定值。
- en: Combining negation and comparisons
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合否定和比较
- en: 'Considering two expressions A and B:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个表达式 A 和 B：
- en: NOT(A `&&` B) = (NOT A `||` NOT B)
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT(A `&&` B) = (NOT A `||` NOT B)
- en: NOT (A `||` B) = (NOT A `&&` NOT B)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT (A `||` B) = (NOT A `&&` NOT B)
- en: 'This can be more than useful when you''ll create conditions in your code. For
    instance, let''s consider two expressions with four variables a, b, c, and d:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你创建代码中的条件时可能非常有用。例如，让我们考虑两个包含四个变量 a、b、c 和 d 的表达式：
- en: a `<` b
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a `<` b
- en: c `>=` d
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c `>=` d
- en: 'What is the meaning of `!`(a `<` b)? It is the negation of the expression,
    where:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`(a `<` b) 的意义是什么？它是表达式的否定，其中：'
- en: '`!`(a `<` b) equals (a `>=` b)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`(a `<` b) 等于 (a `>=` b)'
- en: 'The opposite of *a strictly smaller than b* is *a greater than or equal to
    b*. In the same way:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*a严格小于b* 的相反面是 *a大于或等于b*。同样地：'
- en: '`!`(c `>=` d) equals (c `<` d)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`(c `>=` d) 等于 (c `<` d)'
- en: 'Now, let''s combine a bit. Let''s negate the global expression:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们结合一下。让我们取全局表达式的反：
- en: (a `<` b) `&&` (c `>=` d) and `!`((a `<` b) `&&` (c `>=` d)) equals (`!`(a `<`
    b) `||` `!`(c `>=` d)) equals (a `>=` b) `||` (c `<` d)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: (a `<` b) `&&` (c `>=` d) 和 `!`((a `<` b) `&&` (c `>=` d)) 等于 (`!`(a `<` b)
    `||` `!`(c `>=` d)) 等于 (a `>=` b) `||` (c `<` d)
- en: 'Here is another example of combination introducing the *operators precedence*
    concept:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个组合示例，引入了 *运算符优先级* 的概念：
- en: '[PRE41]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Both of my statements are equivalent. Precedence occurs here and we can now
    add these operators to the previous precedencies table (check *Appendix B, Operator
    Precedence in C and C++*). I''m adding the comparison operator:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我的两个陈述是等价的。这里发生优先级，我们现在可以将这些运算符添加到之前的优先级表中（检查 *附录B，C和C++中的运算符优先级*）。我添加了比较运算符：
- en: '| Precedencies groups | Operators | Names |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 优先级组 | 运算符 | 名称 |'
- en: '| --- | --- | --- |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2 | `++``--``()``[]` | Suffix incrementSuffix decrementFunction callArray
    element access |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `++``--``()``[]` | 后缀增量后缀减量函数调用数组元素访问 |'
- en: '| 3 | `++``--` | Prefix incrementPrefix decrement |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `++``--` | 前缀增量前缀减量 |'
- en: '| 5 | `*``/``%` | MultiplicationDivisionModulo |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `*``/``%` | 乘除取模 |'
- en: '| 6 | `+``-` | AdditionSubtraction |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `+``-` | 加减 |'
- en: '| 8 | `<``<=``>``>=` | Less thanLess than or equal toGreater thanGreater than
    or equal to |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `<``<=``>``>=` | 小于小于等于大于大于等于 |'
- en: '| 9 | `==``!=` | Equal toNot equal to |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `==``!=` | 等于不等于 |'
- en: '| 13 | `&&` | Logical AND |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `&&` | 逻辑与 |'
- en: '| 14 | `&#124;&#124;` | Logical OR |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `&#124;&#124;` | 逻辑或 |'
- en: '| 15 | `?:` | Ternary conditional |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 15 | `?:` | 三元条件运算符 |'
- en: '| 16 | `=``+=``-=``*=``/=``%=` | AssignmentAssignment by sumAssignment by differenceAssignment
    by productAssignment by quotientAssignment by remainder |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 16 | `=``+=``-=``*=``/=``%=` | 赋值赋值加赋值减赋值乘赋值除赋值取余 |'
- en: As usual, I cheated a bit and added the precedence group 15 that contains a
    unique operator, the ternary conditional operator that we will see a bit later.
    Let's move to conditional structures.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我稍微作弊了一下，添加了包含唯一运算符的优先级组 15，即稍后我们将看到的三元条件运算符。让我们转到条件结构。
- en: Adding conditions in the code
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中添加条件
- en: Because I studied Biology and have a Master's diploma, I'm familiar with organic
    and living behaviors. I like to tell my students that the code, especially in
    interaction design fields of work, has to be alive. With Arduino, we often build
    machines that are able to "feel" the real world and interact with it by *acting*
    on it. This couldn't be done without *condition* statements. This type of statement
    is called a control structure. We used one conditional structure while we tested
    our big code including variables display and more.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在生物学方面有研究，并且有硕士学位，所以我熟悉有机和生物行为。我喜欢告诉我的学生，代码，尤其是在交互设计领域的工作中，必须是有生命的。使用Arduino，我们经常构建能够“感受”真实世界并通过*行动*与之交互的机器。没有*条件*语句是无法做到这一点的。这种语句被称为控制结构。当我们测试包括变量显示等的大代码时，我们使用了一个条件结构。
- en: if and else conditional structure
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if和else条件结构
- en: 'This is the one we used without explaining. You just learned patience and zen.
    Things begin to come, right? Now, let''s explain it. This structure is very intuitive
    because it is very similar to any conditional pseudo code. Here is one:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们没有解释的一个例子。你已经学会了耐心和禅。事情开始出现，对吧？现在，让我们来解释它。这个结构非常直观，因为它非常类似于任何条件伪代码。这里有一个：
- en: If the value of the variable `a` is smaller than the value of variable `b`,
    switch on the LED. Else switch it off.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量`a`的值小于变量`b`的值，则打开LED。否则关闭它。
- en: 'Now the real C code, where I simplify the part about the LED by giving a state
    of 1 or 0 depending on what I want to further do in the code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正的C代码，我在其中通过给出1或0的状态来简化LED的部分，这取决于我想要在代码中进一步做什么：
- en: '[PRE42]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I guess it is clear enough. Here is the general syntax of this structure:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这已经很清楚了。以下是这种结构的通用语法：
- en: '[PRE43]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Expression evaluation generally results in a Boolean value. But numerical values
    as a result of an expression in this structure can be okay too, even if a bit
    less explicit, which I, personally, don't like. An expression resulting in the
    numerical value `0` equals `false` in C in Arduino core, and equals `true` for
    any other values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式评估通常会产生布尔值。但在这个结构中，表达式的数值结果也可以是正确的，即使它不太明确，我个人不喜欢。在Arduino核心中，表达式的数值结果为`0`等于`false`，而对于任何其他值，都等于`true`。
- en: Note
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Being implicit often means making your code shorter and cuter. In my humble
    opinion, it also means to be very unhappy when you have to support and maintain
    a code several months later when it includes a bunch of implicit things without
    any comments.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式通常意味着使你的代码更短更简洁。根据我个人的看法，这也意味着几个月后当你不得不支持和维护包含大量隐式内容的代码时，你会非常不高兴。
- en: I push my students to be explicit and verbose. We are not here to code things
    to a too small amount of memory, believe me. We are not talking about reducing
    a 3 megabytes code to 500 kilobytes but more about reducing a 200 kilobytes code
    to 198 kilobytes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励我的学生要明确和详细。我们不是在这里为了将代码压缩到极小的内存中，相信我。我们不是在谈论将3兆字节的代码减少到500千字节，而是更多地减少到198千字节。
- en: Chaining an if…else structure to another if…else structure
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将if…else结构链接到另一个if…else结构
- en: 'The following is the modified example:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个修改后的示例：
- en: '[PRE44]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first `if` test is: if `a` is smaller than `b`. If it is `true`, we put
    the value `1` inside the variable `ledState`. If it is `false`, we go to the next
    statement `else`.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`测试是：如果`a`小于`b`。如果是`true`，我们将值`1`放入变量`ledState`中。如果是`false`，我们进入下一个语句`else`。
- en: 'This `else` contains another test on `b`: is `b` greater than `0`? If it is,
    we put the value `0` inside the variable `ledState`. If it is `false`, we can
    go to the last case, the last `else`, and we put the value `1` inside the variable
    `ledState`.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`else`包含对`b`的另一个测试：`b`是否大于`0`？如果是，我们将值`0`放入变量`ledState`中。如果是`false`，我们可以进入最后一个情况，最后一个`else`，并将值`1`放入变量`ledState`中。
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**One frequent error – missing some cases**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个常见的错误 - 缺少一些情况**'
- en: Sometimes, the `if`… `else` chain is so complicated and long that we may miss
    some case and no case is verified. Be clear and try to check the whole universe
    of cases and to code the conditions according to it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`if`…`else`链非常复杂和长，我们可能会错过一些情况，并且没有任何情况被验证。要明确，并尝试检查整个情况宇宙，并根据它编写条件。
- en: A nice tip is to try to put all cases on paper and try to find the *holes*.
    I mean, where the part of the variable values are not matched by tests.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的建议是尝试将所有情况都写在纸上，并尝试找到*漏洞*。我的意思是，变量的值部分没有通过测试。
- en: if…else structure with combined comparisons expressions
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有组合比较表达式的if…else结构
- en: 'The following is the previous example where I commented a bit more:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我之前例子中注释更多的一些代码：
- en: '[PRE45]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also write it in the following way considering the comment I wrote previously
    in the code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按照我之前在代码中写的注释来这样写：
- en: '[PRE46]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It could be considered as a more condensed version where you have all statements
    for the switch on the LED in one place, same for switching it off.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被认为是一个更紧凑的版本，其中所有关于LED开关的语句都在一个地方，同样适用于关闭它。
- en: Finding all cases for a conditional structure
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找条件结构的所有情况
- en: 'Suppose you want to test a temperature value. You have two specific limits/points
    at which you want the Arduino to react and, for instance, alert you by lighting
    an LED or whatever event to interact with the real world. For instance, the two
    limits are: 15-degree Celsius and 30-degree Celsius. How to be sure I have all
    my cases? The best way is to use a pen, a paper, and to draw a bit.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测试一个温度值。你有两个特定的限制/点，你希望Arduino做出反应，例如通过点亮LED或任何与真实世界交互的事件。例如，这两个限制是：15摄氏度和30摄氏度。如何确保我涵盖了所有情况？最好的方法是拿一支笔，一张纸，画一画。
- en: '![Finding all cases for a conditional structure](img/7584_03_05.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![寻找条件结构的所有情况](img/7584_03_05.jpg)'
- en: Checking all possible T values
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 检查所有可能的 T 值
- en: 'We have three parts:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个部分：
- en: T < 15
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T < 15
- en: T > 15 but T <30
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T > 15 但 T < 30
- en: T > 30
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T > 30
- en: 'So we have three cases:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个情况：
- en: T< 15
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T < 15
- en: T >15 and T < 30
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T > 15 且 T < 30
- en: T > 30
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T > 30
- en: 'What happens when T = 30 or T = 15? These are holes in our logic. Depending
    on how we designed our code, it could happen. Matching all cases would mean: include
    T = 15 and T = 30 cases too. We can do that as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当 T = 30 或 T = 15 时会发生什么？这些都是我们逻辑中的漏洞。根据我们如何设计我们的代码，这可能会发生。匹配所有情况意味着：包括 T =
    15 和 T = 30 的情况。我们可以这样做：
- en: '[PRE47]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I included these two cases into my comparisons. 15-degree Celsius is included
    in the second temperature interval and 30-degree Celsius in the last one. This
    is an example of how we can do it.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这两个情况包含在我的比较中。15摄氏度包含在第二个温度区间内，30摄氏度在最后一个区间内。这是一个我们如何做到的例子。
- en: I'd like you to remember to use a pen and a paper in this kind of cases. This
    will help you to design and especially make some breaks from the IDE that is,
    in designing steps, really good. Let's now explore a new conditional structure.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在这种情况下记得使用笔和纸。这有助于你设计和特别是在设计步骤中从IDE中跳出，这实际上是非常好的。现在让我们探索一个新的条件结构。
- en: switch…case…break conditional structure
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch…case…break 条件结构
- en: 'Here, we are going to see a new conditional structure. The standard syntax
    is shown as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一个新的条件结构。标准语法如下所示：
- en: '[PRE48]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`var` is compared for equality to each case label. If `var` equals a particular
    `label` value, the statements in this case are executed until the next `break`.
    If there is no match and you have used the optional `default:` case, the statements
    of this case are executed. Without the `default:` case, nothing is done. `label`
    must be a value, not a character, not string. Let''s take a more concrete example:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 与每个情况标签进行比较。如果 `var` 等于特定的 `label` 值，则执行此情况中的语句，直到下一个 `break`。如果没有匹配，并且你使用了可选的
    `default:` 情况，则执行此情况的语句。如果没有 `default:` 情况，则不执行任何操作。`label` 必须是一个值，而不是一个字符或字符串。让我们举一个更具体的例子：'
- en: '[PRE49]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This code is equivalent to:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于：
- en: '[PRE50]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Are you okay?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你好吗？
- en: Note
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What I want to say is, when you want to compare a variable to many unique values,
    use `switch`…`case`…`break`, else use `if`…`else`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要说的是，当你想要将一个变量与许多唯一值进行比较时，使用 `switch`…`case`…`break`，否则使用 `if`…`else`。
- en: When you have comparison intervals, `if`…`else` is more convenient because you
    can use `<` and `>` whereas in `switch`…`case`…`break` you cannot. Of course,
    we could combine both. But remember to keep your code as simple as you can.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有比较区间时，`if`…`else` 更方便，因为你可以使用 `<` 和 `>`，而在 `switch`…`case`…`break` 中则不能。当然，我们可以结合两者。但请记住，尽量保持你的代码尽可能简单。
- en: Ternary operator
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'This strange notation is often totally unknown to my students. I used to say,
    "Hey! This is more C than Arduino" when they answer "That is why we have forgotten
    about it". Naughty students! This ternary operator takes three elements as input.
    The syntax is `(expression) ? val1 : val2`.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '这种奇怪的符号通常对我的学生来说完全陌生。我过去常说，“嘿！这比Arduino更像是C语言”当他们回答“这就是我们忘记它的原因”时。淘气的学生！这个三元运算符接受三个输入元素。语法是
    `(expression) ? val1 : val2`。'
- en: The expression is tested. If it is `true`, this whole statement returns (or
    equals) `val1`, if it is `false`, it equals `val2`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式被测试。如果是 `true`，则整个语句返回（或等于）`val1`，如果是 `false`，则等于 `val2`。
- en: 'Again imagine our Arduino, the temperature sensor, and only one limit which
    is 20 degree Celsius. I want to turn the LED blue if `T` is smaller than the limit,
    and red if `T` is greater or equal to 20 degree Celsius. Here is how we would
    use the two ternary operators:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 再次想象我们的Arduino、温度传感器和唯一的限制是20摄氏度。我想如果`T`小于限制，就使LED变蓝，如果`T`大于或等于20摄氏度，就变红。以下是我们会如何使用两个三元运算符：
- en: '[PRE51]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It can be a nice notation, especially if you don't need statement execution
    in each case but only variable assignments.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一种很好的表示法，特别是如果你不需要在每个情况下执行语句，而只需要变量赋值的话。
- en: Making smart loops for repetitive tasks
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为重复性任务创建智能循环
- en: 'A **loop** is a series of events repeating themselves in time. Basically, computers
    have been designed, at first, to make a lot of calculations repeatedly to save
    human''s time. Designing a loop to repeat tasks that have to be repeated seems
    a natural idea. C natively implements some ways to design loops. Arduino core
    naturally includes three loop structures:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**是一系列在时间上重复的事件。基本上，计算机最初被设计出来是为了进行大量的重复计算以节省人类的时间。设计一个循环来重复必须重复的任务似乎是一个自然的想法。C语言原生实现了一些设计循环的方法。Arduino核心自然包括三种循环结构：'
- en: '`for`'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`do`…`while`'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do`…`while`'
- en: for loop structure
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`循环结构'
- en: 'The `for` loop statement is quite easy to use. It is based on, at least, one
    counter starting from a particular value you define, and increments or decrements
    it until another defined value. The syntax is:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环语句相当容易使用。它基于至少一个从你定义的特定值开始的计数器，并增加或减少它，直到另一个定义的值。其语法如下：'
- en: '[PRE52]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The counter is also named `index`. I''m showing you a real example here:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器也被称为`index`。我在这里给你一个真实示例：
- en: '[PRE53]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This basic example defines a loop that prints all integers from `0` to `99`.
    The declaration/definition of the integer type variable `i` is the first element
    of the `for` structure. Then, the condition describes in which case the statements
    included in this loop have to be executed. At last, the `i++` increment occurs.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本示例定义了一个循环，它打印从`0`到`99`的所有整数。整数类型变量`i`的声明/定义是`for`结构的第一个元素。然后，条件描述了在哪种情况下必须执行此循环中包含的语句。最后，执行`i++`增量。
- en: Pay attention to the increment element. It is defined with the increment as
    a suffix. It means here that the increment occurs after the end of the execution
    of the statements for a considered `i` value.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意增量元素。它是以增量作为后缀定义的。这意味着在这里，增量发生在考虑的`i`值执行语句之后。
- en: 'Let''s break the loop for the first two and last two `i` values and see what
    happens. Declaration of the integer variable `i` for the first and second iteration
    is shown as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们中断前两个和最后两个`i`值的循环，看看会发生什么。第一个和第二次迭代的整数变量`i`的声明如下所示：
- en: '`i = 0`, is `i` smaller than `100`? yes, `println(0)`, increment `i`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 0`，`i`小于`100`吗？是的，`println(0)`，增加`i`'
- en: '`i = 1`, is `i` smaller than `100`? yes, `println(1)`, increment `i`'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，`i`小于`100`吗？是的，`println(1)`，增加`i`'
- en: 'For the last two iterations the value of `i` is shown as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后两次迭代，`i`的值如下所示：
- en: '`i = 99`, is `i` smaller than `100`? yes, `println(99)`, increment `i`'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 99`，`i`小于`100`吗？是的，`println(99)`，增加`i`'
- en: '`i = 100`, is `i` smaller than `100`? no, stop the loop'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 100`，`i`小于`100`吗？不，停止循环'
- en: 'Of course, the index could be declared before the `for` structure, and only
    defined inside the `for` structure. We could also have declared and defined the
    variable before and we would have:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，索引可以在`for`结构之前声明，并在`for`结构内部定义。我们也可以在声明和定义变量之前进行，我们会有：
- en: '[PRE54]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This seems a bit strange, but totally legal in C and for the Arduino core too.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点奇怪，但在C语言和Arduino核心中都是合法的。
- en: Tip
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**The scope of index**'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引的作用域**'
- en: If the index has been declared inside the `for` loop parenthesis, its scope
    is only the `for` loop. This means that this variable is *not* known or *not*
    usable outside of the loop.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引已经在`for`循环括号内声明，其作用域仅限于`for`循环。这意味着这个变量在循环外部是*不可知*或*不可用*的。
- en: It normally works like that for any variable declared inside the statements
    of a `for` loop. This isn't something to do, even if it is totally legal in C.
    Why not? Because it would mean you'd declare a variable each time the loop runs,
    which isn't really smart. It is better to declare it outside of the loop, one
    time, then to use it inside of it, whatever the purpose (index, or variable to
    work with inside statements).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在`for`循环语句中声明的任何变量，通常都是这样工作的。这并不是什么需要做的事情，即使在C语言中这是完全合法的。为什么不是呢？因为这意味着你每次循环运行时都会声明一个变量，这并不真的聪明。最好是在循环外部声明一次，然后在循环内部使用它，无论目的（索引或要在语句内部使用的变量）是什么。
- en: Playing with increment
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转增量
- en: Increment can be something more complex than only using the increment operator.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 增量可以比仅使用增量运算符更复杂。
- en: More complex increments
  id: totrans-488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更复杂的增量
- en: 'First, instead of writing `i++`, we could have written `i = i + 1`. We can
    also use other kind of operations like subtraction, multiplication, division,
    modulo, or combinations. Imagine that you want to print only odd numbers. Odd
    numbers are all of the form 2n + 1 where *n* is an integer. Here is the code to
    print odd numbers from 1 to 99:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在不写`i++`的情况下写`i = i + 1`。我们还可以使用其他类型的操作，如减法、乘法、除法、取模，或者它们的组合。想象一下，你只想打印奇数。奇数都是形如`2n
    + 1`的形式，其中`n`是整数。以下是打印从`1`到`99`的奇数的代码：
- en: '[PRE55]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'First values of `i` are: `1`, `3`, `5`, and so on.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`的初始值是：`1`、`3`、`5`，依此类推。'
- en: Decrements are negative increments
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 减量是负的增量
- en: 'I just want to remix the previous code into something else in order to shake
    your mind a bit around increments and decrements. Here is another code making
    the same thing but printing odd numbers from `99` to `1`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是想将之前的代码重新组合成其他的东西，以激发你对增量和减量的思考。下面是另一段代码，做同样的事情，但打印从`99`到`1`的奇数：
- en: '[PRE56]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: All right? Let's complicate things a bit.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧？让我们稍微复杂化一下。
- en: Using imbricated for loops or two indexes
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用嵌套`for`循环或两个索引
- en: 'It is also possible to use more than one index in a `for` structure. Imagine
    we want to calculate a multiplication table until 10 x 10\. We have to define
    two integer variables from 1 to 10 (0 being trivial). These two indexes have to
    vary from 1 to 10\. We can begin by one loop with the index `x`:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`结构中也可以使用多个索引。想象一下，我们想要计算一个10 x 10的乘法表。我们必须定义两个从`1`到`10`的整数变量（0是平凡的）。这两个索引必须从`1`到`10`变化。我们可以从一个带有索引`x`的循环开始：
- en: '[PRE57]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is for the first index. The second one is totally similar:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个索引的情况。第二个索引完全相同：
- en: '[PRE58]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'How can I mix those? The answer is the same as the answer to the question:
    what is a multiplication table? I have to keep one index constant, and multiply
    it by the other one going from 1 to 10\. Then, I have to increment the first one
    and continue doing the same with the other and so on. Here is how to we do it:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我该如何混合这些？答案是和回答“乘法表是什么？”一样：我必须保持一个索引不变，然后将其与另一个从`1`到`10`的索引相乘。然后，我必须增加第一个索引，并继续用另一个索引重复同样的操作，依此类推。下面是如何做到这一点：
- en: '[PRE59]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This code prints all results of `x*y` where `x` and `y` are integers from 1
    to 10, one result on each line. Here are the first few steps:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了所有`x*y`的结果，其中`x`和`y`是从`1`到`10`的整数，每个结果占一行。以下是前几个步骤：
- en: '`x = 1`, `y = 1`… print the result'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x = 1`，`y = 1`… 打印结果'
- en: '`x = 1`, `y = 2`… print the result'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x = 1`，`y = 2`… 打印结果'
- en: '`x = 1`, `y = 3`… print the result'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x = 1`，`y = 3`… 打印结果'
- en: '`x` is incremented to `2` each time the inside `for` loop (the one with `y`)
    ends, then `x` is fixed to `2` and `y` grows until `x = 10` and `y = 10` where
    the `for` loop ends.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`每次内部`for`循环（带有`y`的那个）结束时都会增加至`2`，然后`x`固定为`2`，而`y`会增长直到`x = 10`和`y = 10`，此时`for`循环结束。'
- en: 'Let''s improve it a bit, only for aesthetic purposes. It is also a pretext
    to tweak and play with the code to make you more comfortable with it. Often, multiplication
    tables are drawn as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改进一下，只是为了美观。这也是一个调整和玩弄代码的理由，让你更熟悉它。通常，乘法表是这样绘制的：
- en: '![Using imbricated for loops or two indexes](img/7584_03_006.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![使用嵌套`for`循环或两个索引](img/7584_03_006.jpg)'
- en: Classic view of a multiplication table
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法表的经典视图
- en: We need to go to the next line each time one of the index (and only one) reaches
    the limit which is the value `10`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 每当其中一个索引（只有一个）达到限制值`10`时，我们需要转到下一行。
- en: '[PRE60]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Check the code, each time `y` reaches `10`, a new line is created. The `for`
    loop is a powerful structure to repeat tasks. Let's check another structure.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码，每次`y`达到`10`时，就会创建一个新的行。`for`循环是一个强大的重复任务的结构。让我们检查另一个结构。
- en: while loop structure
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环结构'
- en: 'The `while` loop structure is a bit simpler. Here is the syntax:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环结构稍微简单一些。以下是语法：'
- en: '[PRE61]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The expression is evaluated as a Boolean, `true` or `false`. While the expression
    is `true`, statements are executed, then as soon as it will be `false`, the loop
    will end. It obviously, often, requires declaration and definition outside of
    the `while` structure. Here is an example doing the same results than our first
    `for` loop printing all integers from 0 to 99:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式被评估为布尔值，`true`或`false`。当表达式为`true`时，执行语句，然后一旦它变为`false`，循环就会结束。显然，通常需要在`while`结构之外声明和定义。以下是一个例子，它产生了与我们的第一个`for`循环相同的结果，打印从0到99的所有整数：
- en: '[PRE62]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Indeed, you *have* to take care of the increment or decrement explicitly inside
    your statements; I''ll say a few words on infinite loops a bit later. We could
    have condensed the code a bit more by doing that:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你*必须*在你的语句中明确处理增量或减量；我稍后会谈谈无限循环。我们可以通过这样做来进一步压缩代码：
- en: '[PRE63]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `while` loop structure tests the expression before doing even executing
    the first statement. Let's check a similar structure doing that differently.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环结构在执行第一条语句之前测试表达式。让我们检查一个以不同方式执行类似结构的例子。'
- en: do…while loop structure
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do…while循环结构
- en: 'The `do`…`while` loop structure is very similar to the `while` structure, but
    makes its expression evaluation at the end of the loop, which means after the
    statements execution. Here is the syntax:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`do…while`循环结构与`while`结构非常相似，但它在循环的末尾评估表达式，这意味着在执行语句之后。以下是语法：'
- en: '[PRE64]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is an example on the same model:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个相同模型的例子：
- en: '[PRE65]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It means that even if the first result of the expression evaluation is `false`,
    the statements will be executed on time. This is not the case with the `while`
    structure.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使表达式评估的第一个结果是`false`，语句也会按时执行。这与`while`结构不同。
- en: Breaking the loops
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打破循环
- en: We learned how to create loops driven by indexes that define precisely how these
    loops will live. But how can we stop a loop when an *external* event occurs? External
    is taken in the sense of external to the loop itself including its indexes. In
    that case, the loop's condition itself wouldn't include the external element.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何创建由索引驱动的循环，这些索引精确地定义了这些循环将如何存在。但当我们遇到一个*外部*事件时，我们如何停止循环？外部是指循环本身及其索引之外。在这种情况下，循环的条件本身不会包含外部元素。
- en: Imagine that we have a process running 100 times in *normal* conditions. But
    we want to interrupt it, or modify it according to another variable that has a
    greater scope (declared outside of the loop, at least).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们在正常条件下运行一个过程100次。但我们要中断它，或者根据另一个具有更大作用域的变量（至少在循环外部声明）来修改它。
- en: 'Thanks to the `break` statement for making that possible for us. `break;` is
    the basic syntax. When `break` is executed, it exits the current loop, whatever
    it is, based on: `do`, `for`, and `while`. You already saw `break` when we talked
    about the `switch` conditional structure. Let''s illustrate that.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`break`语句，才使得这一点对我们来说成为可能。`break;`是基本语法。当执行`break`时，它会根据`do`、`for`和`while`退出当前循环。当我们在讨论`switch`条件结构时，你已经看到了`break`。让我们来举例说明。
- en: Imagine a LED. We want its intensity to grow from 0 to 100 percent then to go
    back to 0, every time. But we also want to use a nice distance sensor that resets
    this loop each time the distance between a user and the sensor is greater than
    a value.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个LED。我们希望它的强度从0增长到100%，然后回到0，每次都这样。但我们还希望使用一个很好的距离传感器，每次用户与传感器之间的距离大于某个值时，都会重置这个循环。
- en: Note
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is based on a real installation I made for a museum where a system has to
    make a LED blink smoothly when the user was far and to switch off the LED when
    the user was near, like a living system calling for users to meet it.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于我为一个博物馆安装的真实系统，该系统必须使用户远离时LED平滑闪烁，当用户靠近时关闭LED，就像一个活生生的系统在召唤用户来见面。
- en: 'I designed it very simply as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计得非常简单，如下所示：
- en: '[PRE66]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This whole loop was included inside the global `loop()` function in the Arduino
    board and the complete test about the distance was executed each time the `loop()`
    function occurs, waiting for users.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 整个循环都包含在Arduino板上的全局`loop()`函数中，并且每次`loop()`函数执行时，都会执行关于距离的完整测试，等待用户。
- en: Infinite loops are not your friends
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环不是你的朋友
- en: Be careful of infinite loops. The problem isn't really the infinite state of
    loops, but the fact that a system, whatever it is including Arduino, which is
    running an infinite loop does only that! Nothing that is after the loop can be
    executed because the program won't go outside the loop.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 注意无限循环。问题其实不在于循环的无限状态，而在于一个系统，无论它是Arduino还是其他什么，如果运行了无限循环，就只能做那件事！循环之后的任何代码都无法执行，因为程序不会跳出循环。
- en: If you understand me correctly, `loop()`—the basic Arduino core function—is
    an infinite loop. But it is a controlled loop well designed and Arduino core based.
    It can (and is) interrupted when functions are called or other special events
    occur, letting us, users, design what we need inside of this loop. I used to call
    "the event's driver and listener" because it is the place where our main program
    runs.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确理解了我的意思，`loop()`——这是Arduino核心的基本函数——是一个无限循环。但它是一个设计良好的、基于Arduino核心的受控循环。当调用函数或发生其他特殊事件时，它可以（并且确实可以）被中断，让我们用户在这个循环内部设计我们需要的功能。我过去把它称为“事件驱动器和监听器”，因为这是我们的主程序运行的地方。
- en: 'There are many ways to create infinitely looped processes. You can define a
    variable in `setup()`, making it grow in `loop()` and test it each time `loop()`
    runs in order to reset it to the initial value, for instance. It takes benefits
    of the already existing `loop()` loop. Here is this example in C for Arduino:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以创建无限循环的过程。你可以在 `setup()` 中定义一个变量，使其在 `loop()` 中增长，并在每次 `loop()` 运行时测试它，以便将其重置到初始值，例如。它利用了已经存在的
    `loop()` 循环。以下是一个Arduino的C语言示例：
- en: '[PRE67]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This `i` grows from `0` to `threshold – 1` then goes back to `0`, grows again,
    infinitely, taking benefits of `loop()`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `i` 从 `0` 增长到 `threshold – 1`，然后回到 `0`，再次增长，无限循环，利用了 `loop()` 函数。
- en: 'There are also other ways to run loops infinitely in a controlled manner that
    we''ll see a bit later in the more advanced part of the book, but you have been
    warned: take care of those infinite loops.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 也有其他方法可以在受控方式下无限运行循环，我们将在本书的更高级部分稍后看到，但你要注意：小心那些无限循环。
- en: Summary
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot of abstract things in this important chapter. From type to
    operator's precedencies, to conditional structure, now we are going to learn new
    structures and syntaxes that will help us make more efficient blocks of code and,
    especially, more reusable ones. We can now learn about functions. Let's dive into
    the next C/C++ knowledge chapters and we will be able to test our Arduino after
    that.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重要的章节中，我们学到了很多抽象的概念。从类型到运算符的优先级，再到条件结构，现在我们将学习新的结构和语法，这将帮助我们编写更高效的代码块，尤其是更可重用的代码块。我们现在可以学习函数了。让我们深入下一章C/C++知识，然后我们将在之后测试我们的Arduino。
