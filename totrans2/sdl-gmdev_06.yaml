- en: Chapter 6. Data-driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。数据驱动设计
- en: With the previous chapter adding the ability to create and handle game states,
    our framework has really begun to take shape. In this chapter, we will explore
    a new way to create our states and objects by removing the need to hardcode the
    creation of our objects at compile time. To do this we will parse through an external
    file, in our case an XML file, which lists all of the objects needed for our state.
    This will make our states generic as they can be completely different simply by
    loading up an alternate XML file. Taking `PlayState` as an example, when creating
    a new level we would need to create a new state with different objects and set
    up objects we want for that level. If we could instead load the objects from an
    external file, we could reuse the same `PlayState` and simply load the correct
    file depending on the current level we want. Keeping classes generic like this
    and loading external data to determine their state is called **Data-driven Design**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，通过添加创建和处理游戏状态的能力，我们的框架已经开始成形。在本章中，我们将探讨一种新的创建状态和对象的方法，即通过移除在编译时硬编码对象创建的需求。为此，我们将解析一个外部文件，在我们的例子中是一个
    XML 文件，该文件列出了我们状态所需的所有对象。这将使我们的状态变得通用，因为它们可以通过加载不同的 XML 文件而完全不同。以 `PlayState`
    为例，在创建新关卡时，我们需要创建一个新的状态，包含不同的对象，并设置我们想要在该关卡中使用的对象。如果我们能够从外部文件加载对象，我们就可以重用相同的 `PlayState`，并根据我们想要的当前关卡简单地加载正确的文件。保持类通用并加载外部数据以确定其状态被称为
    **数据驱动设计**。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Loading XML files using the **TinyXML** library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **TinyXML** 库加载 XML 文件
- en: Creating a **Distributed Factory**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 **分布式工厂**
- en: Loading objects dynamically using the factory and an XML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂和 XML 文件动态加载对象
- en: Parsing a state from an XML file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 XML 文件解析状态
- en: Fitting everything together into the framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切整合到框架中
- en: Loading XML files
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 XML 文件
- en: I have chosen to use XML files because they are so easy to parse. We are not
    going to write our own XML parser, rather we will use an open source library called
    TinyXML. TinyXML was written by *Lee Thomason* and is available under the zlib
    license from [http://sourceforge.net/projects/tinyxml/](http://sourceforge.net/projects/tinyxml/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用 XML 文件，因为它们非常容易解析。我们不会编写自己的 XML 解析器，而是将使用一个名为 TinyXML 的开源库。TinyXML 是由
    *Lee Thomason* 编写的，并且可以在 [http://sourceforge.net/projects/tinyxml/](http://sourceforge.net/projects/tinyxml/)
    下以 zlib 许可证获得。
- en: 'Once downloaded the only setup we need to do is to include a few of the files
    in our project:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，我们唯一需要做的设置就是将几个文件包含到我们的项目中：
- en: '`tinyxmlerror.cpp`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinyxmlerror.cpp`'
- en: '`tinyxmlparser.cpp`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinyxmlparser.cpp`'
- en: '`tinystr.cpp`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinystr.cpp`'
- en: '`tinystr.h`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinystr.h`'
- en: '`tinyxml.cpp`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinyxml.cpp`'
- en: '`tinyxml.h`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tinyxml.h`'
- en: 'Also, at the top of `tinyxml.h`, add this line of code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tinyxml.h` 的顶部添加以下代码行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By doing this we ensure that we are using the STL versions of the TinyXML functions.
    We can now go through a little of how an XML file is structured. It's actually
    fairly simple and we will only give a brief overview to help you get up to speed
    with how we will use it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保正在使用 TinyXML 函数的 STL 版本。现在我们可以简要地介绍一下 XML 文件的构成。实际上它相当简单，我们只提供一个简要概述，以帮助您了解我们将如何使用它。
- en: Basic XML structure
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本 XML 结构
- en: 'Here is a basic XML file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的 XML 文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first line of the file defines the format of the XML file. The second line
    is our `Root` element; everything else is a child of this element. The third line
    is the first child of the root element. Now let''s look at a slightly more complicated
    XML file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行定义了 XML 文件的格式。第二行是我们的 `Root` 元素；其他所有内容都是这个元素的子元素。第三行是根元素的第一个子元素。现在让我们看看一个稍微复杂一点的
    XML 文件：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see we have now added children to the first child element. You can
    nest as many children as you like. But without a good structure, your XML file
    may become very hard to read. If we were to parse the above file, here are the
    steps we would take:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在已经向第一个子元素添加了子元素。您可以嵌套任意多的子元素。但是如果没有良好的结构，您的 XML 文件可能非常难以阅读。如果我们解析上述文件，我们将采取以下步骤：
- en: Load the XML file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 XML 文件。
- en: Get the root element, `<ROOT>`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取根元素，`<ROOT>`。
- en: Get the first child of the root element, `<ELEMENTS>`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取根元素的第一个子元素，`<ELEMENTS>`。
- en: For each child, `<ELEMENT>` of `<ELEMENTS>`, get the content.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `<ELEMENTS>` 的每个子元素 `<ELEMENT>`，获取其内容。
- en: Close the file.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件。
- en: 'Another useful XML feature is the use of attributes. Here is an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 XML 功能是使用属性。以下是一个示例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have now stored the text we want in an attribute named `text`. When this
    file is parsed, we would now grab the `text` attribute for each element and store
    that instead of the content between the `<ELEMENT></ELEMENT>` tags. This is especially
    useful for us as we can use attributes to store lots of different values for our
    objects. So let''s look at something closer to what we will use in our game:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将想要存储的文本存储在一个名为`text`的属性中。当这个文件被解析时，我们会获取每个元素的`text`属性并将其存储，而不是存储`<ELEMENT></ELEMENT>`标签之间的内容。这对我们来说特别有用，因为我们可以使用属性来存储我们对象的大量不同值。所以让我们看看一些更接近我们将在游戏中使用的内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is slightly more complex. We define each state in its own element and within
    this element we have objects and textures with various attributes. These attributes
    can be loaded in to create the state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微复杂一些。我们为每个状态定义一个元素，在这个元素中，我们有具有各种属性的物体和纹理。这些属性可以加载到状态中。
- en: With this knowledge of XML you can easily create your own file structures if
    what we cover within this book is not to your needs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对XML的这些知识，你可以轻松地创建自己的文件结构，如果本书中涵盖的内容不符合你的需求。
- en: Implementing Object Factories
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对象工厂
- en: 'We are now armed with a little XML knowledge but before we move forward, we
    are going to take a look at Object Factories. An object factory is a class that
    is tasked with the creation of our objects. Essentially, we tell the factory the
    object we would like it to create and it goes ahead and creates a new instance
    of that object and then returns it. We can start by looking at a rudimentary implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一些XML知识，但在我们继续前进之前，我们将看看对象工厂。对象工厂是一个负责创建我们对象的类。本质上，我们告诉工厂我们想要它创建的对象，然后它就会创建该对象的新实例并返回它。我们可以从查看一个基本的实现开始：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is very simple. We pass in an ID for the object and the factory
    uses a big switch statement to look it up and return the correct object. Not a
    terrible solution but also not a particularly good one, as the factory will need
    to know about each type it needs to create and maintaining the switch statement
    for many different objects would be extremely tedious. Just as when we covered
    looping through game objects in [Chapter 3](ch03.html "Chapter 3. Working with
    Game Objects"), *Working with Game Objects*, we want this factory not to care
    about which type we ask for. It shouldn't need to know all of the specific types
    we want it to create. Luckily this is something that we can definitely achieve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们传入一个对象的ID，工厂使用一个大的switch语句来查找并返回正确的对象。这不是一个糟糕的解决方案，但也不是一个特别好的解决方案，因为工厂需要知道它需要创建的每个类型，并且维护许多不同对象的switch语句将会非常繁琐。就像我们在[第3章](ch03.html
    "第3章。与游戏对象一起工作")中介绍遍历游戏对象时一样，*与游戏对象一起工作*，我们希望这个工厂不关心我们要求的是什么类型。它不需要知道我们想要它创建的所有具体类型。幸运的是，这确实是我们能够实现的事情。
- en: Using Distributed Factories
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分布式工厂
- en: Through the use of Distributed Factories we can make a generic object factory
    that will create any of our types. Distributed factories allow us to dynamically
    maintain the types of objects we want our factory to create, rather than hard
    code them into a function (like in the preceding simple example). The approach
    we will take is to have the factory contain `std::map` that maps a string (the
    type of our object) to a small class called `Creator` whose only purpose is the
    creation of a specific object. We will register a new type with the factory using
    a function that takes a string (the ID) and a `Creator` class and adds them to
    the factory's map. We are going to start with the base class for all the `Creator`
    types. Create `GameObjectFactory.h` and declare this class at the top of the file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用分布式工厂，我们可以创建一个通用的对象工厂，它可以创建我们的任何类型。分布式工厂允许我们动态地维护我们想要工厂创建的对象类型，而不是将它们硬编码到一个函数中（就像前面的简单示例中那样）。我们将采取的方法是让工厂包含一个`std::map`，它将一个字符串（我们对象的类型）映射到一个名为`Creator`的小类。`Creator`的唯一目的是创建特定的对象。我们将使用一个函数将新类型注册到工厂中，该函数接受一个字符串（ID）和一个`Creator`类，并将它们添加到工厂的映射中。我们将从所有`Creator`类型的基类开始。创建`GameObjectFactory.h`并在文件顶部声明这个类。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now go ahead and create the rest of our factory and then go through it
    piece by piece.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建其余的工厂，然后逐个分析它。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is quite a small class but it is actually very powerful. We will cover
    each part separately starting with `std::map m_creators`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当小的类，但实际上非常强大。我们将分别介绍每个部分，从`std::map m_creators`开始。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This map holds the important elements of our factory, the functions of the
    class essentially either add or remove from this map. This becomes apparent when
    we look at the `registerType` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图包含了我们工厂的重要元素，类的功能本质上要么添加要么从这张地图中移除。当我们查看 `registerType` 函数时，这一点变得很明显：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function takes the ID we want to associate the object type with (as a
    string), and the creator object for that class. The function then attempts to
    find the type using the `std::mapfind` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受我们想要与对象类型关联的 ID（作为字符串），以及该类的创建者对象。然后函数尝试使用 `std::mapfind` 函数查找类型：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the type is found then it is already registered. The function then deletes
    the passed in pointer and returns `false`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到类型，则它已经注册。然后函数删除传入的指针并返回 `false`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the type is not already registered then it can be assigned to the map and
    then `true` is returned:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型尚未注册，则可以将其分配给地图，然后返回 `true`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the `registerType` function is actually very simple; it is
    just a way to add types to the map. The `create` function is very similar:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`registerType` 函数实际上非常简单；它只是将类型添加到地图的一种方式。`create` 函数非常相似：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function looks for the type in the same way as `registerType` does, but
    this time it checks whether the type was not found (as opposed to found). If the
    type is not found we return `0`, and if the type is found then we use the `Creator`
    object for that type to return a new instance of it as a pointer to `GameObject`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以与 `registerType` 相同的方式查找类型，但这次它检查类型是否未找到（而不是找到）。如果类型未找到，我们返回 `0`，如果类型找到，则我们使用该类型的
    `Creator` 对象返回一个新的实例，作为 `GameObject` 指针。
- en: It is worth noting that the `GameObjectFactory` class should probably be a singleton.
    We won't cover how to make it a singleton as this has been covered in the previous
    chapters. Try implementing it yourself or see how it is implemented in the source
    code download.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`GameObjectFactory` 类可能应该是一个单例。我们不会介绍如何将其变为单例，因为这在之前的章节中已经介绍过了。尝试自己实现它或查看源代码下载中的实现方式。
- en: Fitting the factory into the framework
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工厂集成到框架中
- en: 'With our factory now in place, we can start altering our `GameObject` classes
    to use it. Our first step is to ensure that we have a `Creator` class for each
    of our objects. Here is one for `Player`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了工厂，我们可以开始修改我们的 `GameObject` 类以使用它。我们的第一步是确保我们为每个对象都有一个 `Creator` 类。这里有一个
    `Player` 的示例：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This can be added to the bottom of the `Player.h` file. Any object we want the
    factory to create must have its own `Creator` implementation. Another addition
    we must make is to move `LoaderParams` from the constructor to their own function
    called `load`. This stops the need for us to pass the `LoaderParams` object to
    the factory itself. We will put the `load` function into the `GameObject` base
    class, as we want every object to have one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以添加到 `Player.h` 文件的底部。我们想要工厂创建的任何对象都必须有自己的 `Creator` 实现。我们必须做的另一个补充是将 `LoaderParams`
    从构造函数移动到它们自己的函数 `load` 中。这阻止了我们需要将 `LoaderParams` 对象传递给工厂本身。我们将 `load` 函数放入 `GameObject`
    基类中，因为我们希望每个对象都有一个。
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each of our derived classes will now need to implement this `load` function.
    The `SDLGameObject` class will now look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有派生类现在都需要实现这个 `load` 函数。`SDLGameObject` 类现在看起来像这样：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our objects that derive from `SDLGameObject` can use this `load` function as
    well; for example, here is the `Player::load` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `SDLGameObject` 派生的对象也可以使用这个 `load` 函数；例如，这里有一个 `Player::load` 函数：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This may seem a bit pointless but it actually saves us having to pass through
    `LoaderParams` everywhere. Without it, we would need to pass `LoaderParams` through
    the factory's `create` function which would then in turn pass it through to the
    `Creator` object. We have eliminated the need for this by having a specific function
    that handles parsing our loading values. This will make more sense once we start
    parsing our states from a file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点没有意义，但实际上它节省了我们不需要在各个地方传递 `LoaderParams`。如果没有它，我们就需要通过工厂的 `create` 函数传递
    `LoaderParams`，然后它再传递给 `Creator` 对象。我们通过有一个专门处理解析我们加载值的函数来消除了这种需求。一旦我们开始从文件中解析我们的状态，这将会更有意义。
- en: We have another issue which needs rectifying; we have two classes with extra
    parameters in their constructors (`MenuButton` and `AnimatedGraphic`). Both classes
    take an extra parameter as well as `LoaderParams`. To combat this we will add
    these values to `LoaderParams` and give them default values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个需要纠正的问题；我们有两个类在它们的构造函数中具有额外的参数（`MenuButton` 和 `AnimatedGraphic`）。这两个类都接受一个额外的参数以及
    `LoaderParams`。为了解决这个问题，我们将这些值添加到 `LoaderParams` 并赋予它们默认值。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In other words, if the parameter is not passed in, then the default values will
    be used (0 in both cases). Rather than passing in a function pointer as `MenuButton`
    did, we are using `callbackID` to decide which callback function to use within
    a state. We can now start using our factory and parsing our states from an XML
    file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果没有传递参数，则将使用默认值（两种情况下都是0）。与 `MenuButton` 传递函数指针的方式不同，我们正在使用 `callbackID`
    来决定在状态内使用哪个回调函数。现在我们可以开始使用我们的工厂并从XML文件解析状态。
- en: Parsing states from an XML file
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从XML文件解析状态
- en: 'The file we will be parsing is the following (`test.xml` in source code downloads):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解析的文件如下（源代码下载中的 `test.xml`）：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to create a new class that parses our states for us called `StateParser`.
    The `StateParser` class has no data members, it is to be used once in the `onEnter`
    function of a state and then discarded when it goes out of scope. Create a `StateParser.h`
    file and add the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类来为我们解析状态，称为 `StateParser`。`StateParser` 类没有数据成员，它应该在状态的 `onEnter`
    函数中使用一次，然后当它超出作用域时被丢弃。创建一个 `StateParser.h` 文件并添加以下代码：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have three functions here, one public and two private. The `parseState`
    function takes the filename of an XML file as a parameter, along with the current
    `stateID` value and a pointer to `std::vector` of `GameObject*` for that state.
    The `StateParser.cpp` file will define this function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有三个函数，一个公共的，两个私有的。`parseState` 函数接受一个XML文件的文件名作为参数，以及当前的 `stateID` 值和一个指向
    `std::vector` 的 `GameObject*` 指针，该指针对应于该状态。`StateParser.cpp` 文件将定义此函数：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is a lot of code in this function so it is worth covering in some depth.
    We will note the corresponding part of the XML file, along with the code we use,
    to obtain it. The first part of the function attempts to load the XML file that
    is passed into the function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中有很多代码，所以值得深入探讨。我们将注意XML文件中相应的部分，以及我们使用的代码，以获取它。函数的第一部分尝试加载传递给函数的XML文件：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It displays an error to let you know what happened if the XML loading fails.
    Next we must grab the root node of the XML file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果XML加载失败，它会显示一个错误来告诉你发生了什么。接下来，我们必须获取XML文件的根节点：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The rest of the nodes in the file are all children of this root node. We must
    now get the root node of the state we are currently parsing; let''s say we are
    looking for `MENU`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的其余节点都是这个根节点的子节点。现在我们必须获取我们正在解析的状态的根节点；比如说，我们正在寻找 `MENU`：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This piece of code goes through each direct child of the root node and checks
    if its name is the same as `stateID`. Once it finds the correct node it assigns
    it to `pStateRoot`. We now have the root node of the state we want to parse.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历根节点的每个直接子节点，并检查其名称是否与 `stateID` 相同。一旦找到正确的节点，它就将其分配给 `pStateRoot`。现在我们有了我们想要解析的状态的根节点。
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have a pointer to the root node of our state we can start to grab
    values from it. First we want to load the textures from the file so we look for
    the `<TEXTURE>` node using the children of the `pStateRoot` object we found before:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了状态根节点的指针，我们可以开始从中获取值。首先，我们想要从文件中加载纹理，所以我们使用之前找到的 `pStateRoot` 对象的子节点查找
    `<TEXTURE>` 节点：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the `<TEXTURE>` node is found, we can pass it into the private `parseTextures`
    function (which we will cover a little later).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到 `<TEXTURE>` 节点，我们可以将其传递给私有的 `parseTextures` 函数（我们稍后会介绍它）。
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function then moves onto searching for the `<OBJECT>` node and, once found,
    it passes it into the private `parseObjects` function. We also pass in the `pObjects`
    parameter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数继续搜索 `<OBJECT>` 节点，一旦找到，它就将其传递给私有的 `parseObjects` 函数。我们还传递了 `pObjects`
    参数：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point our state has been parsed. We can now cover the two private functions,
    starting with `parseTextures`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的状态已经解析完毕。现在我们可以介绍两个私有函数，从 `parseTextures` 开始。
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This function gets the `filename` and `ID` attributes from each of the texture
    values in this part of the XML:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从XML此部分的每个纹理值中获取 `filename` 和 `ID` 属性：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It then adds them to `TextureManager`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它们添加到 `TextureManager`。
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `parseObjects` function is quite a bit more complicated. It creates objects
    using our `GameObjectFactory` function and reads from this part of the XML file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseObjects`函数相当复杂。它使用我们的`GameObjectFactory`函数创建对象，并从XML文件的这部分读取：'
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `parseObjects` function is defined like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseObjects`函数的定义如下：'
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First we get any values we need from the current node. Since XML files are
    pure text, we cannot simply grab ints or floats from the file. TinyXML has functions
    with which you can pass in the value you want to be set and the attribute name.
    For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从当前节点获取所需的任何值。由于XML文件是纯文本，我们无法直接从文件中获取整数或浮点数。TinyXML有函数可以让你传入想要设置的值和属性名称。例如：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This sets the variable `x` to the value contained within attribute `"x"`. Next
    comes the creation of a `GameObject` ***** class using the factory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量`x`设置为属性`"x"`中包含的值。接下来是使用工厂创建一个`GameObject` ***** 类：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We pass in the value from the `type` attribute and use that to create the correct
    object from the factory. After this we must use the `load` function of `GameObject`
    to set our desired values using the values loaded from the XML file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`type`属性的值，并使用它从工厂创建正确的对象。之后，我们必须使用`GameObject`的`load`函数来设置从XML文件加载的值。
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And finally we push `pGameObject` into the `pObjects` array, which is actually
    a pointer to the current state's object vector.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`pGameObject`推入`pObjects`数组，这实际上是指向当前状态对象向量的指针。
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Loading the menu state from an XML file
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从XML文件加载菜单状态
- en: 'We now have most of our state loading code in place and can make use of this
    in the `MenuState` class. First we must do a little legwork and set up a new way
    of assigning the callbacks to our `MenuButton` objects, since this is not something
    we could pass in from an XML file. The approach we will take is to give any object
    that wants to make use of a callback an attribute named `callbackID` in the XML
    file. Other objects do not need this value and `LoaderParams` will use the default
    value of `0`. The `MenuButton` class will make use of this value and pull it from
    its `LoaderParams`, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了大部分状态加载代码，并可以在`MenuState`类中使用它。首先，我们必须做一些前期工作，并设置一种新的方法来分配回调到我们的`MenuButton`对象，因为这不是我们可以从XML文件传递进来的东西。我们将采取的方法是给任何想要使用回调的对象在XML文件中赋予一个名为`callbackID`的属性。其他对象不需要这个值，`LoaderParams`将使用默认值`0`。`MenuButton`类将使用这个值，并从它的`LoaderParams`中拉取它，如下所示：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `MenuButton` class will also need two other functions, one to set the callback
    function and another to return its callback ID:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuButton`类还需要两个其他函数，一个用于设置回调函数，另一个用于返回其回调ID：'
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next we must create a function to set callbacks. Any state that uses objects
    with callbacks will need an implementation of this function. The most likely states
    to have callbacks are menu states, so we will rename our `MenuState` class to
    `MainMenuState` and make `MenuState` an abstract class that extends from `GameState`.
    The class will declare a function that sets the callbacks for any items that need
    it and it will also have a vector of the `Callback` objects as a member; this
    will be used within the `setCallbacks` function for each state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个设置回调函数的函数。任何使用具有回调的对象的状态都需要这个函数的实现。最可能具有回调的状态是菜单状态，因此我们将我们的`MenuState`类重命名为`MainMenuState`，并将`MenuState`作为一个从`GameState`扩展的抽象类。该类将声明一个为任何需要它的项目设置回调的函数，并且它还将有一个`Callback`对象的向量作为成员；这将在每个状态的`setCallbacks`函数中使用。
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MainMenuState` class (previously `MenuState`) will now derive from this
    `MenuState` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainMenuState`类（之前称为`MenuState`）现在将从这个`MenuState`类派生。'
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Because `MainMenuState` now derives from `MenuState`, it must of course declare
    and define the `setCallbacks` function. We are now ready to use our state parsing
    to load the `MainMenuState` class. Our `onEnter` function will now look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MainMenuState`现在从`MenuState`派生，它当然必须声明和定义`setCallbacks`函数。我们现在可以使用我们的状态解析来加载`MainMenuState`类。我们的`onEnter`函数现在将看起来像这样：
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We create a state parser and then use it to parse the current state. We push
    any callbacks into the `m_callbacks` array inherited from `MenuState`. Now we
    need to define the `setCallbacks` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个状态解析器，然后使用它来解析当前状态。我们将任何回调函数推入从`MenuState`继承的`m_callbacks`数组中。现在我们需要定义`setCallbacks`函数：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use `dynamic_cast` to check whether the object is a `MenuButton` type; if
    it is then we do the actual cast and then use the objects `callbackID` as the
    index into the `callbacks` vector and assign the correct function. While this
    method of assigning callbacks could be seen as not very extendable and could possibly
    be better implemented, it does have a redeeming feature; it allows us to keep
    our callbacks inside the state they will need to be called from. This means that
    we won't need a huge header file with all of the callbacks in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `dynamic_cast` 来检查对象是否是 `MenuButton` 类型；如果是，我们就进行实际的转换，然后使用对象的 `callbackID`
    作为 `callbacks` 向量的索引，并分配正确的函数。虽然这种方法分配回调可能看起来不是很灵活，并且可能实现得更好，但它确实有一个优点；它允许我们将回调保留在它们需要被调用的状态中。这意味着我们不需要一个包含所有回调的大头文件。
- en: One last alteration we need is to add a list of texture IDs to each state so
    that we can clear all of the textures that were loaded for that state. Open up
    `GameState.h` and we will add a `protected` variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个更改是向每个状态添加一个纹理 ID 列表，这样我们就可以清除为该状态加载的所有纹理。打开 `GameState.h` 文件，我们将添加一个
    `protected` 变量。
- en: '[PRE44]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will pass this into the state parser in `onEnter` and then we can clear
    any used textures in the `onExit` function of each state, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `onEnter` 中的状态解析器中传递这个类型，然后我们可以在每个状态中的 `onExit` 函数中清除任何已使用的纹理，如下所示：
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Before we start running the game we need to register our `MenuButton` type with
    the `GameObjectFactory`. Open up `Game.cpp` and in the `Game::init` function we
    can register the type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始运行游戏之前，我们需要将我们的 `MenuButton` 类型注册到 `GameObjectFactory` 中。打开 `Game.cpp`
    文件，在 `Game::init` 函数中我们可以注册该类型。
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now run the game and see our fully data-driven `MainMenuState`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行游戏并看到我们的完全数据驱动的 `MainMenuState`。
- en: Loading other states from an XML file
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 XML 文件加载其他状态
- en: Our `MainMenuState` class now loads from an XML file. We need to make our other
    states do the same. We will only cover the code that has changed, so assume that
    everything else has remained the same when following through this section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MainMenuState` 类现在从 XML 文件加载。我们需要让我们的其他状态也这样做。我们将只涵盖已更改的代码，所以假设在阅读本节时其他内容保持不变。
- en: Loading the play state
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载游戏状态
- en: We will start with `PlayState.cpp` and its `onEnter` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `PlayState.cpp` 和它的 `onEnter` 函数开始。
- en: '[PRE47]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We must also add the new texture clearing code that we had in `MainMenuState`
    to the `onExit` function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `onExit` 函数中添加我们之前在 `MainMenuState` 中有的新纹理清除代码。
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These are the only alterations that we will need to do here but we must also
    update our XML file to have something to load in `PlayState`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在这里需要做的唯一更改，但我们还必须更新我们的 XML 文件，以便在 `PlayState` 中加载一些内容。
- en: '[PRE49]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our `Enemy` object will now need to set its initial velocity in its load function
    rather than the constructor, otherwise the `load` function would override it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Enemy` 对象现在需要在它的加载函数中设置其初始速度，而不是在构造函数中，否则 `load` 函数将覆盖它。
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally we must register these objects with the factory. We can do this in the
    `Game::init` function just like the `MenuButton` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将这些对象注册到工厂中。我们可以在 `Game::init` 函数中这样做，就像 `MenuButton` 对象一样。
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Loading the pause state
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载暂停状态
- en: Our `PauseState` class must now inherit from `MenuState` as we want it to contain
    callbacks. We must update the `PauseState.h` file to first inherit from `MenuState`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PauseState` 类现在必须从 `MenuState` 继承，因为我们希望它包含回调函数。我们必须更新 `PauseState.h` 文件，首先从
    `MenuState` 继承。
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We must also declare the `setCallbacks` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须声明 `setCallbacks` 函数。
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we must update the `PauseState.cpp` file, starting with the `onEnter` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须更新 `PauseState.cpp` 文件，从 `onEnter` 函数开始。
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `setCallbacks` function is exactly like `MainMenuState`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCallbacks` 函数与 `MainMenuState` 完全相同。'
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally we must add the texture clearing code to `onExit`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将纹理清除代码添加到 `onExit` 中。
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And then update our XML file to include this state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新我们的 XML 文件以包含此状态。
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Loading the game over state
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载游戏结束状态
- en: Our final state is `GameOverState`. Again this will be very similar to other
    states and we will only cover what has changed. Since we want `GameOverState`
    to handle callbacks it will now inherit from `MenuState`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个状态是 `GameOverState`。这与其他状态非常相似，我们只涵盖已更改的部分。由于我们希望 `GameOverState` 处理回调，它现在将从
    `MenuState` 继承。
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We will then declare the `setCallbacks` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将声明 `setCallbacks` 函数。
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `onEnter` function should be looking very familiar now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEnter` 函数现在应该看起来非常熟悉了。'
- en: '[PRE60]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The texture clearing method is the same as in the previous states, so we will
    leave you to implement that yourself. In fact `onExit` is looking so similar between
    states that it would be a good idea to make a generic implementation for it in
    `GameState` and just use that; again we will leave that to you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理清除方法与之前的状态相同，所以我们将其留给你自己实现。实际上，`onExit`在状态之间看起来非常相似，因此为`GameState`创建一个通用实现是一个好主意；我们再次将其留给你。
- en: You may have noticed the similarity between the `onEnter` functions. It would
    be great to have a default `onEnter` implementation but, unfortunately, due to
    the need to specify different callback functions, our callback implementation
    will not allow this and this is one of its main flaws.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`onEnter`函数之间的相似性。有一个默认的`onEnter`实现会很好，但不幸的是，由于需要指定不同的回调函数，我们的回调实现将不允许这样做，这也是其主要缺陷之一。
- en: Our `AnimatedGraphic` class will now need to grab the `animSpeed` value from
    `LoaderParams` in its `load` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AnimatedGraphic`类现在需要在它的`load`函数中从`LoaderParams`获取`animSpeed`值。
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will also have to register this type with `GameObjectFactory`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将此类型注册到`GameObjectFactory`。
- en: '[PRE62]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And finally we can update the XML file to include this state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新XML文件以包括此状态：
- en: '[PRE63]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We now have all of our states loading from the XML file and one of the biggest
    benefits of this is that you do not have to recompile the game when you change
    a value. Go ahead and change the XML file to move positions or even use different
    textures for objects; if the XML is saved then you can just run the game again
    and it will use the new values. This is a huge time saver for us and gives us
    complete control over a state without the need to recompile our game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所有的状态都是从XML文件中加载的，其中最大的好处之一是当你更改值时，你不需要重新编译游戏。你可以更改XML文件以移动位置或为对象使用不同的纹理；如果XML已保存，则只需再次运行游戏，它将使用新值。这对我们来说节省了大量时间，并使我们能够完全控制状态，而无需重新编译我们的游戏。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Loading data from external files is an extremely useful tool in programming
    games. This chapter enabled our game to do this and applied it to all of our existing
    states. We also covered how the use of factories enabled us to create objects
    dynamically at runtime. The next chapter will cover even more data-driven design
    as well as tile maps so that we can really decouple our game and allow it to use
    external sources rather than hardcoded values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部文件加载数据是编程游戏中的一个极其有用的工具。这一章节使我们的游戏能够实现这一点，并将其应用于我们现有的所有状态。我们还介绍了如何使用工厂在运行时动态创建对象。下一章将涵盖更多数据驱动的设计以及瓦片地图，这样我们就可以真正地将游戏解耦，并允许它使用外部源而不是硬编码的值。
