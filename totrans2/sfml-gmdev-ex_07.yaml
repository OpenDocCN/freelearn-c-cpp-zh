- en: Chapter 7. Rediscovering Fire – Common Game Design Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 重拾火焰 – 常见游戏设计元素
- en: Video games are getting more and more intricate every day. It seems that innovative
    ideas are on the rise, especially with the increasing popularity of indie games,
    such as *Minecraft* and *Super Meat Boy*. While the game ideas themselves are
    getting more and more abstract, at least on the outside, the rigid skeleton behind
    the pretty skin that keeps it standing and helps it retain shape is still taking
    the place of the lowest common denominator in the eyes of game developers. Even
    if the focus of the game centers around two unicorns who spend their free time
    smoking fairy dust and helping Dracula make muffins so that Neptune doesn't blow
    up, that concept coming to life is going to depend greatly on the underlying logic
    of the game before anything else. If there are no entities in the game, there
    are no unicorns. If the entities are simply bouncing around a black screen, the
    game is not engaging. These are the most common game design elements that any
    project must be able to fall back on, otherwise it is doomed to fail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏每天都在变得越来越复杂。似乎创新的想法正在兴起，尤其是在独立游戏（如 *Minecraft* 和 *Super Meat Boy*）越来越受欢迎的背景下。尽管游戏想法本身变得越来越抽象，至少在外观上，支撑着美丽皮肤并帮助其保持形状的刚性骨架仍然是游戏开发者眼中最低的共同点。即使游戏的焦点围绕着两只在空闲时间吸食仙女粉末并帮助德古拉制作松饼，以免海王星爆炸的独角兽，这个概念能否实现将极大地取决于游戏背后的底层逻辑。如果没有实体，就没有独角兽。如果实体只是在黑色屏幕上弹跳，游戏就不会吸引人。这些都是任何项目都必须能够依赖的常见游戏设计元素，否则它注定会失败。
- en: 'In this chapter, we will be covering the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Designing and implementing the game map class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现游戏地图类
- en: Populating the map by creating and managing entities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建和管理实体来填充地图
- en: Checking for and handling collisions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和处理碰撞
- en: Meshing all of our code together into a finished game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有代码合并成一个完整游戏
- en: The game map
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏地图
- en: 'The actual environment and surroundings a player explores are just as important
    as the rest of the game. Without the world being present, the player is simply
    left spinning in an empty void of the screen clear color. Designing a good interface
    to bring out various parts of the game, ranging from the level backdrop to numerous
    hazards our player has to face can be tricky. Let''s build a solid foundation
    for that right now, starting with defining what our map format is going to be
    like, as we take a look ahead to determine what we want to accomplish:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家实际探索的环境和周围环境与游戏的其他部分一样重要。如果没有世界存在，玩家就只能在一个空白的屏幕颜色中空转。设计一个良好的界面来展示游戏的不同部分，从关卡背景到玩家必须面对的众多危险，可能会很棘手。现在，让我们为这个坚实的基础打下基础，从定义我们的地图格式开始，同时展望我们想要实现的目标：
- en: '![The game map](img/B04284_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![游戏地图](img/B04284_07_01.jpg)'
- en: 'First, we want to specify a texture handle as the background. Then, we want
    to clearly define the map size and set up the gravity, which determines how fast
    entities fall to the ground. Additionally, we need to store the default friction,
    which determines how slippery the average tile is. The last property we want to
    store is the name of the next map that gets loaded when the end of the current
    map is reached. Here is a snippet from one of the maps that we will be working
    with, `Map1.map`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要指定一个纹理句柄作为背景。然后，我们想要明确定义地图大小并设置重力，这决定了实体落地的速度。此外，我们还需要存储默认的摩擦力，这决定了平均地砖有多滑。最后，我们想要存储的是当当前地图结束时将加载的下一个地图的名称。以下是我们将要工作的其中一个地图的片段，`Map1.map`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can tell, in addition to defining all of the things discussed, the map
    file also stores the player position, as well as different enemies and their spawn
    positions. The last but definitely not the least important part of it is tile
    storage and the indication of which tile is going to "warp" the player to the
    next stage when touched.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了定义所讨论的所有内容外，地图文件还存储了玩家位置，以及不同的敌人和它们的出生位置。其中最后但绝对不是最不重要的部分是地砖存储以及指示哪个地砖在被触摸时会将玩家“传送”到下一个阶段。
- en: What is a tile?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地砖是什么？
- en: 'The term "tile" keeps getting thrown around, but it hasn''t been defined yet.
    To put it simply, a tile is one of the many segments that make up the world. Tiles
    are blocks that create the game environment, whether it''s the grass you''re standing
    on or the spikes you''re falling onto. The map uses a tile sheet, which is fairly
    similar to a sprite sheet, in that it holds many different sprites at once. The
    main difference is how those sprites are obtained from the tile sheet. This is
    what the texture that is going to be used as a tile sheet looks like in our case:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “瓦片”这个词经常被提及，但还没有被定义。简单来说，瓦片是构成世界众多部分之一。瓦片是创建游戏环境的块，无论是你站立的草地还是你掉落的刺。地图使用瓦片图集，这与精灵图集非常相似，因为它一次可以持有许多不同的精灵。主要区别在于如何从瓦片图集中获取这些精灵。在我们的案例中，将要用作瓦片图集的纹理如下所示：
- en: '![What is a tile?](img/B04284_07_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![什么是瓦片？](img/B04284_07_02.jpg)'
- en: 'Each tile also has unique properties, which we will want to load from the `Tiles.cfg`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个瓦片还具有独特的属性，我们希望从`Tiles.cfg`文件中加载这些属性：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is quite simple and only contains the tile ID, name, both axes of friction,
    and a binary flag for the tile being deadly to touch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单，只包含瓦片ID、名称、两个摩擦轴和一个表示瓦片是否致命的二元标志。
- en: Building the game world
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏世界
- en: 'Since tiles are going to play such a huge role in our game design, it would
    be greatly helpful to have a separate data structure that all tile information
    can be localized to. A good place to start is by defining some constants of the
    tile size, as well as dimensions of the tile sheets that are going to be used.
    A simple enumeration can be quite helpful when storing this information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于瓦片在我们的游戏设计中将扮演如此重要的角色，因此拥有一个独立的数据结构，其中所有瓦片信息都可以本地化，将非常有帮助。一个不错的起点是定义一些瓦片大小的常量，以及将要使用的瓦片图集的尺寸。在存储此类信息时，一个简单的枚举可以非常有帮助：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we make it so all tiles are going to be 32 px wide and 32 px tall and
    every single tile sheet is going to be 256 px wide and 256 px tall. These constants,
    obviously, can be changed, but the idea here is to keep them the same during runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使所有瓦片都宽32 px，高32 px，并且每个瓦片图集都宽256 px，高256 px。显然，这些常量可以更改，但这里的想法是在运行时保持它们相同。
- en: 'To keep our code a little shorter, we can also benefit from a type alias for
    tile IDs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更短，我们还可以从类型别名中受益，用于瓦片ID：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The flyweight pattern
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 飞行员模式
- en: 'Each tile, obviously, has to have a sprite that represents its type graphically
    speaking. In order to draw a grass tile, we want to adjust the sprite to be cropped
    to only the grass tile in the tile sheet. Then, we set its position on the screen
    and draw it. Seems simple enough, but consider the following situation: you have
    a map that''s 1000x1000 tiles in size, and perhaps 25% of that map''s size is
    actual tiles that aren''t just air, which leaves you with the total amount of
    62,500 tiles to draw. Now imagine you''re storing a sprite with each tile. Granted,
    sprites are lightweight objects, but that''s still a huge waste of resources.
    This is where the flyweight pattern comes in.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个瓦片都必须有一个代表其类型的精灵。从图形上讲，为了绘制草瓦片，我们希望调整精灵以仅裁剪到瓦片图集中的草瓦片。然后，我们设置其在屏幕上的位置并绘制它。看起来很简单，但考虑以下情况：你有一个大小为1000x1000瓦片的地图，其中可能有25%的地图大小是实际瓦片，而不是空气，这让你有总共62,500个瓦片需要绘制。现在想象一下，你为每个瓦片存储一个精灵。当然，精灵是轻量级对象，但这仍然是一种巨大的资源浪费。这就是飞行员模式发挥作用的地方。
- en: 'Storing huge chunks of redundant data is obviously a waste, so why not just
    store one instance of each type and simply store a pointer to the type in the
    tile? That, in a nutshell, is the flyweight pattern. Let''s see it in action,
    by implementing a tile information structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 存储大量冗余数据显然是浪费，为什么不只存储每种类型的一个实例，并在瓦片中简单地存储对类型的指针呢？简而言之，这就是飞行员模式。让我们通过实现瓦片信息结构来观察它的实际应用：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `struct` essentially holds everything about every tile type that isn't
    unique. It stores the texture that it's using, as well as the sprite that will
    represent the tile. As you can see, in the constructor of this structure, we set
    the sprite to point to the tile sheet texture and then crop it based on its tile
    ID. This type of cropping is a little different than the one in the sprite sheet
    class, because now we only have the tile ID to work with, and we don't know which
    row the sprite is on. Using some basic math allows us to first figure out how
    many columns and rows the tile sheet has, by dividing our sheet dimensions by
    the tile size. In this case, a 256x256 px sized sprite sheet with tiles of 32x32
    px in size would have eight tiles per row and column. Obtaining the coordinate
    of a tile ID on an *x* axis can be done by using the modulus operator `%`. In
    a case of eight tiles per row, it would return values from 0 to 7, based on the
    ID. Figuring out the *y* coordinate is done simply by dividing the ID by the number
    of tiles per column. This gives us the top-left coordinate of the tile sprite
    in the tile sheet, so we finish the cropping by passing in the `Sheet::Tile_Size`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `struct` 实际上包含了关于每种瓦片类型所有非唯一信息。它存储了它所使用的纹理，以及将代表瓦片的精灵。正如你所见，在这个结构的构造函数中，我们将精灵设置为指向瓦片图纹理，然后根据其瓦片
    ID 进行裁剪。这种裁剪与精灵图类中的裁剪略有不同，因为我们现在只有瓦片 ID 可用，并不知道精灵位于哪一行。使用一些基本的数学知识，我们可以首先通过将我们的图尺寸除以瓦片大小来计算出瓦片图有多少列和行。在这种情况下，一个
    256x256 像素的精灵图，瓦片大小为 32x32 像素，每行和每列将有 8 个瓦片。通过使用取模运算符 `%` 可以获得瓦片 ID 在 *x* 轴上的坐标。在每行有
    8 个瓦片的情况下，它将返回从 0 到 7 的值，基于 ID。确定 *y* 坐标是通过将 ID 除以每列的瓦片数来完成的。这给了我们瓦片精灵在瓦片图中的左上角坐标，所以我们通过传递
    `Sheet::Tile_Size` 来完成裁剪。
- en: 'The `TileInfo` destructor simply frees the texture used for the tile sheet.
    The rest of the values stored in this structure will be initialized when the map
    is loaded. Now let''s define our tile structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileInfo` 析构函数仅释放用于瓦片图的纹理。在这个结构体中存储的其他值将在地图加载时初始化。现在让我们定义我们的瓦片结构：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the reason why the flyweight pattern is so powerful. The tile objects
    are incredibly lightweight, if they only store information that can be unique
    to each tile and not the tile type. The only flag we're interested in so far is
    if the tile is a warp, which means it loads the next level when the player is
    standing on it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么享乐模式如此强大的原因。如果瓦片对象只存储每个瓦片唯一的信息，而不是瓦片类型，那么它们将非常轻量级。到目前为止，我们唯一感兴趣的是瓦片是否是传送门，这意味着当玩家站在上面时，它会加载下一级。
- en: Designing the map class
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计地图类
- en: 'With tiles out of the way, we can move on to higher-level structures, such
    as the game map. Let''s begin by creating a few suitable types of containers that
    will hold the map information, as well as the tile type information:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完瓦片之后，我们可以继续处理更高级的结构，例如游戏地图。让我们首先创建一些合适的容器类型，这些容器将包含地图信息以及瓦片类型信息：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `TileMap` type is an `unordered_map` container, which holds pointers to
    `Tile` objects that are addressed by an unsigned integer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileMap` 类型是一个 `unordered_map` 容器，它包含指向 `Tile` 对象的指针，这些对象通过无符号整数进行寻址。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In cases where tile counts are known in advance, it would be prudent to use
    a container that will not change in size (such as `std::array` or a pre-allocated
    `std::vector`) in order to achieve continuous storage, and in turn, much faster
    access.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在已知瓦片数量预定的情形下，使用不会改变大小的容器（例如 `std::array` 或预分配的 `std::vector`）是明智的，以实现连续存储，从而实现更快的访问。
- en: But wait a minute! Aren't we working in two dimensions? How are we mapping the
    tiles to only one integer, if the coordinates are represented by two numbers?
    Well, with a little bit of mathematics, it's entirely possible to manipulate indices
    of two dimensions to be represented as a single number. This will be covered shortly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们不是在二维空间中工作吗？如果坐标由两个数字表示，我们如何将瓦片映射到只有一个整数上呢？好吧，通过一点数学知识，完全可以将两个维度的索引表示为一个单一的数字。这将在稍后进行说明。
- en: 'The `TileSet` data type represents the container of all different types of
    tiles, which are tied to a tile ID that''s represented by the unsigned integer.
    This brings us everything we need in order to write the map header file, which
    might look a little something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileSet` 数据类型代表所有不同类型瓦片的容器，这些瓦片与一个由无符号整数表示的瓦片 ID 相关联。这为我们编写地图头文件提供了所有需要的信息，这个头文件可能看起来像这样：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we define all the predictable methods, such as obtaining a tile at specific
    coordinates, getting various information from the class, and, of course, methods
    for updating and drawing the map. Let''s move on to the implementation of these
    methods, in order to talk about them more in depth:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义所有可预测的方法，例如在特定坐标获取瓦片、从类中获取各种信息，以及当然，更新和绘制地图的方法。让我们继续实现这些方法，以便更深入地讨论它们：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The map constructor initializes its data members to some default values and
    calls a private method in order to load different types of tiles from the `tiles.cfg`
    file. Fairly standard. Predictably enough, the destructor of this class does nothing
    out of the ordinary either:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 地图构造函数将其数据成员初始化为一些默认值，并调用一个私有方法以从`tiles.cfg`文件加载不同类型的瓦片。相当标准。足够可预测，这个类的析构函数也没有做任何特别的事情：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Obtaining tiles from the map is done by first converting the 2D coordinates
    provided as arguments to this method into a single number, and then locating the
    specific tile in an unordered map:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从地图中获取瓦片是通过首先将此方法提供的作为参数的2D坐标转换为单个数字，然后在无序映射中定位特定的瓦片：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The conversion of coordinates looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标转换看起来是这样的：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order for this to work, we must have the maximum size of the map defined,
    otherwise it will produce wrong results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法工作，我们必须定义地图的最大尺寸，否则它会产生错误的结果。
- en: 'Updating the map is another crucial part:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更新地图是另一个关键部分：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, it checks the `m_loadNextMap` flag. If it''s set to `true`, the map information
    gets purged and the next map is loaded, if the data member that holds its handle
    is set. If it isn''t, the application state is set to `GameOver`, which will be
    created later. This will simulate the player beating the game. Finally, we obtain
    the view space of the window and set our map background''s top-left corner to
    the view space''s left corner in order for the background to follow the camera.
    Let''s draw these changes on the screen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它检查`m_loadNextMap`标志。如果它设置为`true`，则清除地图信息并加载下一个地图，如果设置了持有其句柄的数据成员。如果没有设置，则将应用程序状态设置为`GameOver`，这将在稍后创建。这将模拟玩家通关游戏。最后，我们获取窗口的视图空间并将地图背景的左上角设置为视图空间的左角，以便背景跟随相机。让我们在屏幕上绘制这些更改：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A pointer to the render window is obtained through the share context and the
    background is drawn in the first two lines here. The next three lines serve a
    purpose, simply known by a name of culling. It is a technique that any good game
    programmer should utilize, where anything that's not currently within the view
    space of the screen should be left undrawn. Once again, consider the situation
    where you have a massive map of size 1000x1000\. Although modern hardware nowadays
    could draw that really fast, there's still no need to waste those clock-cycles
    when they could instead be used to perform a much better task, instead of bringing
    something to the screen that isn't even visible. If you are not culling anything
    in your game, it will eventually start taking serious performance hits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共享上下文获取渲染窗口的指针，并在前两行中绘制背景。接下来的三行有一个简单的名字，称为剔除。这是一种任何优秀的游戏程序员都应该利用的技术，其中任何当前不在屏幕视图空间内的东西都应该不被绘制。再次考虑这种情况，你有一个1000x1000大小的巨大地图。尽管现代硬件现在可以非常快地绘制，但仍然没有必要浪费这些时钟周期，当它们可以用来执行更好的任务时，而不是将一些甚至不可见的东西带到屏幕上。如果你在游戏中没有进行任何剔除，它最终将开始遭受严重的性能打击。
- en: The tile coordinates all the way from the top-left corner of the view space
    to its bottom-right corner are fed into a loop. First, they get evaluated to be
    positive. If they're negative, the way we calculate our 1D index for the map container
    will produce some mirroring artifacts, where the same map you see will be repeated
    over and over again if you go up or left far enough.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从视图空间的左上角到右下角的瓦片坐标被输入到一个循环中。首先，它们被评估为正数。如果它们是负数，我们计算地图容器1D索引的方式会产生一些镜像伪影，如果你向上或向左走得太远，你将看到相同的地图反复出现。
- en: A pointer to a tile is obtained by passing in the *x* and *y* coordinates from
    the loop. If it is a valid tile, we obtain its sprite from the pointer to the
    `TileInfo` structure. The position of the sprite is set to match the coordinates
    of the tile and the sprite is drawn on screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递循环中的*x*和*y*坐标，我们获得一个瓦片的指针。如果它是一个有效的瓦片，我们就从`TileInfo`结构的指针中获取其精灵。精灵的位置被设置为与瓦片的坐标匹配，并在屏幕上绘制精灵。
- en: 'Now for a way to erase the entire map:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个方法可以擦除整个地图：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to clearing the map container, you will notice that we're calling
    the `Purge` method of an entity manager. For now, ignore that line. Entities will
    be covered shortly. We must also not forget to free up the background texture
    when erasing the map.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了清除地图容器外，你还会注意到我们在调用实体管理器的`Purge`方法。现在先忽略那行。实体将在稍后讨论。我们也不应忘记在擦除地图时释放背景纹理。
- en: 'Emptying the container of different tile types is also a necessary part:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 清空不同瓦片类型的容器也是必要的部分：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will most likely only be called in the destructor, but it''s still nice
    to have a separate method. Speaking of different tile types, we need to load them
    in from a file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分很可能会在析构函数中被调用，但有一个单独的方法还是不错的。说到不同的瓦片类型，我们需要从文件中加载它们：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The tile ID gets loaded first, as the `tiles.cfg` format suggests. It gets checked
    for being out of bounds, and if it isn't, dynamic memory is allocated for the
    tile type, at which point all of its internal data members are initialized to
    the values from the string stream. If the tile information object cannot be inserted
    into the tile set container, there must be a duplicate entry, and the dynamic
    memory is de-allocated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先加载瓦片ID，正如`tiles.cfg`格式所建议的。它被检查是否越界，如果不是，就会为瓦片类型分配动态内存，此时所有内部数据成员都被初始化为字符串流中的值。如果瓦片信息对象无法插入到瓦片集容器中，那么必须有重复条目，此时动态内存将被释放。
- en: 'Now for the grand finale of the map – the loading method. Since the actual
    file loading code remains pretty much the same, let''s jump right to reading the
    contents of the map file, starting with tile entries:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是地图的压轴大戏——加载方法。由于实际的文件加载代码基本上保持不变，让我们直接跳到读取地图文件的内容，从瓦片条目开始：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first segment of the `TILE` line is loaded in, which is the tile ID. It
    is checked, as per usual, to be within the boundaries of positive numbers and
    *0*. If it is, the tile information of that specific tile ID is looked up in the
    tile set. Because we don't want empty tiles around our map, we only proceed if
    the tile information of the specific ID is located. Next, the tile coordinates
    are read in and checked for being within the boundaries of the map size. If they
    are, the memory for the tile is allocated and its tile information data member
    is set to point to the one located in the tile set. Lastly, we attempt to read
    in a string at the end of the `TILE` line and check if it says "WARP". That's
    the indication that touching a specific tile should load the next level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`TILE`行的第一部分被加载进来，这是瓦片ID。按照惯例，它被检查是否在正数和*0*的范围内。如果是，就会在瓦片集中查找该特定瓦片ID的瓦片信息。因为我们不希望地图周围有空白的瓦片，所以我们只有在找到特定ID的瓦片信息时才会继续进行。接下来，读取瓦片坐标并检查它们是否在地图大小的范围内。如果是，就会为瓦片分配内存，并将其瓦片信息数据成员设置为指向瓦片集中的那个。最后，我们尝试读取`TILE`行末尾的字符串并检查它是否说“WARP”。这是指接触特定瓦片应该加载下一级。'
- en: 'Now for the background of the map:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来说说地图的背景：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This one is quite straightforward. A texture handle gets loaded from the `BACKGROUND`
    line. If the handle is valid, the background sprite gets tied to the texture.
    There is a catch though. Let's say that the view of our window is larger than
    the texture of the background. That would result in empty areas all around the
    background, which looks horrendous. Repeating the texture might remedy the empty
    areas, but the specific backgrounds we're going to be working with don't tile
    well, so the best solution is to scale the sprite enough to fit the view space
    fully, whether it's larger or smaller. The factors of the scaling can be obtained
    by multiplying the size of the view by the size of the texture. If, for example,
    we have a view that's 800x600 px large and a texture of a size 400x300 px, the
    scale factor for both axes would be 2 and the background is scaled up to twice
    its size.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分相当直接。从`BACKGROUND`行加载一个纹理句柄。如果句柄有效，背景精灵就会与纹理绑定。但是有一个问题。假设我们窗口的视图比背景纹理大。这会导致背景周围出现空白区域，看起来非常糟糕。重复纹理可能会解决空白区域的问题，但我们将要处理的特定背景并不适合平铺，所以最好的解决方案是将精灵缩放到足够大，以完全适应视图空间，无论它更大还是更小。缩放因子的值可以通过将视图大小乘以纹理大小来获得。例如，如果我们有一个800x600像素大小的视图和一个400x300像素大小的纹理，两个轴的缩放因子都是2，背景被放大到原来的两倍大小。
- en: 'Next is the easy part of simply reading in some data members from a file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是简单地从文件中读取一些数据成员的部分：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s wrap this class up with a little helper method that will help us keep
    track of when the next map should be loaded:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个小助手方法来结束这个类，这个方法将帮助我们跟踪下一个地图何时应该被加载：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This concludes the map class implementation. The world now exists, but nobody
    is there to occupy it. Outrageous! Let's not insult our work and create some entities
    to explore the environments we conjure up.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了地图类（map class）的实现。现在世界已经存在，但没有人去占据它。真是荒谬！我们不要贬低我们的工作，让我们创建一些实体来探索我们创造的环境。
- en: The parent of all world objects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有世界对象的父类
- en: An entity is essentially just another word for a game object. It's an abstract
    class that acts as a parent to all of its derivatives, which include the player,
    enemies, and perhaps even items, depending on how you want to implement that.
    Having these entirely different concepts share the same roots allows the programmer
    to define types of behavior that are common to all of them. Moreover, it lets
    the game engine act upon them in the same manner, as they all share the same interface.
    For example, the enemy can be pushed, and so can the player. All enemies, items,
    and the player have to be affected by gravity as well. Having that common ancestry
    between these different types allows us to offload a lot of redundant code and
    focus on the aspects that are unique to each entity, instead of re-writing the
    same code over and over again.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实体实际上只是游戏对象（game object）的另一种说法。它是一个抽象类，作为所有其派生类的父类，包括玩家、敌人和可能的项目，具体取决于你如何实现。让这些完全不同的概念共享相同的根源，允许程序员定义适用于所有这些的共同行为类型。此外，它还允许游戏引擎以相同的方式对它们进行操作，因为它们都共享相同的接口。例如，敌人可以被推动，玩家也可以。所有敌人、项目和玩家都必须受到重力的影响。这些不同类型之间的共同血统使我们能够卸载大量冗余代码，并专注于每个实体的独特方面，而不是一遍又一遍地重写相同的代码。
- en: 'Let''s begin by defining what entity types we''re going to be dealing with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们将要处理哪些实体类型：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The base entity type is just the abstract class, which will not actually be
    instantiated. That leaves us with enemies and a player. Now to set up all the
    possible states an entity can have:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基类实体类型只是一个抽象类，实际上并不会被实例化。这让我们有了敌人和玩家。现在，让我们设置实体可能拥有的所有可能状态：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You have probably noticed that these states vaguely match the animations from
    the player sprite sheet. All character entities will be modeled this way.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些状态与玩家精灵图（sprite sheet）中的动画大致相符。所有角色实体都将以此方式建模。
- en: Creating the base entity class
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基类实体
- en: In cases where entities are built using inheritance, writing a basic parent
    class like this is fairly common. It has to provide any and all functionality
    that any given entity within the game should have.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用继承构建实体的情况下，编写这样一个基本父类（parent class）相当常见。它必须提供任何给定游戏内实体应有的所有功能。
- en: 'With all of the setting up out of the way, we can finally start shaping it
    like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有设置之后，我们终于可以开始这样塑造它：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Right off the bat, we set up the `EntityManager` class that we haven't written
    yet to be a friend class of the base entities. Because the code might be a little
    confusing, a barrage of comments was added to explain every data member of the
    class, so we're not going to touch on those too much until we encounter them during
    the implementation of the class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们就将尚未编写的`EntityManager`类设置为基类实体（base entities）的朋友类（friend class）。因为代码可能有点令人困惑，所以添加了一大堆注释来解释类的每个数据成员，所以我们不会过多地涉及这些内容，直到我们在类的实现过程中遇到它们。
- en: 'The three major properties of an entity include its position, velocity, and
    acceleration. The position of an entity is self explanatory. Its velocity represents
    how fast an entity is moving. Because all of the update methods in our application
    take in the delta time in seconds, the velocity is going to represent the number
    of pixels that an entity moves across per second. The last element of the major
    three is acceleration, which is responsible for how fast the entity''s velocity
    increases. It, too, is defined as the number of pixels per second that get added
    to the entity''s velocity. The sequence of events here is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的三个主要属性包括其位置、速度和加速度。实体的位置是自解释的。速度表示实体移动的速度。由于我们应用程序中的所有更新方法都接受以秒为单位的delta时间，所以速度将表示实体每秒移动的像素数。三个主要属性中的最后一个元素是加速度，它负责实体速度增加的速度。它也被定义为每秒添加到实体速度的像素数。这里的事件序列如下：
- en: The entity is accelerated and its acceleration adjusts its velocity.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体被加速，并且它的加速度调整其速度。
- en: The entity's position is re-calculated based on its velocity.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体的位置是根据其速度重新计算的。
- en: The velocity of an entity is damped by the friction coefficient.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体的速度会受到摩擦系数的阻尼。
- en: Collisions and bounding boxes
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞和边界框
- en: Before jumping into implementations, let's talk about one of the most commonly
    used elements in all games – collisions. Detecting and resolving a collision is
    what keeps the player from falling through the map or going outside the screen.
    It's also what determines if a player gets hurt if they get touched by the enemy.
    In a round-about way, we used a basic form of collision detection in order to
    determine which tiles we should render in the map class. How does one detect and
    resolve collisions? There are many ways to do so, but for our purposes, the most
    basic form of a bounding box collision will do just fine. Other types of collisions
    that incorporate different shapes, such as circles, can also be used, but may
    not be the most efficient or appropriate depending on the kind of game that's
    being built.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现之前，让我们谈谈所有游戏中最常用的元素之一——碰撞。检测和解决碰撞是防止玩家穿过地图或屏幕外部的关键。它还决定了玩家在受到敌人触碰时是否会受伤。以一种间接的方式，我们使用了一种基本的碰撞检测方法来确定在地图类中应该渲染哪些瓦片。如何检测和解决碰撞呢？有很多方法可以做到这一点，但就我们的目的而言，最基本的边界框碰撞就足够了。还可以使用其他类型的碰撞，例如圆形，但这可能取决于正在构建的游戏类型，可能不是最有效或最合适的方法。
- en: 'A bounding box, much like it sounds, is a box or a rectangle which represents
    the solid portion of an entity. Here''s a good example of a bounding box:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 边界框，正如其名，是一个盒子或矩形，代表实体的实体部分。以下是一个边界框的好例子：
- en: '![Collisions and bounding boxes](img/B04284_07_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞和边界框](img/B04284_07_03.jpg)'
- en: 'It isn''t visible like that, unless we create an actual `sf::RectangleShape`
    with the same position and size as the bounding box and render that, which is
    a useful way to debug your applications. In our base entity class, the bounding
    box named `m_AABB` is simply a `sf::FloatRect` type. The name "AABB" represents
    two pairs of different values it holds: the position and the size. Bounding box
    collision, also referred to as an AABB collision, is simply a situation where
    two bounding boxes intersect with one another. The rectangle data types in SFML
    provide us with a method that checks for intersections:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会像那样可见，除非我们创建一个与边界框具有相同位置和大小的实际 `sf::RectangleShape` 并进行渲染，这是一种调试应用程序的有用方法。在我们的基础实体类中，名为
    `m_AABB` 的边界框只是一个 `sf::FloatRect` 类型。名称 "AABB" 代表它持有的两个不同值对：位置和大小。边界框碰撞，也称为 AABB
    碰撞，简单来说就是两个边界框相互相交的情况。SFML 中的矩形数据类型为我们提供了一个检查交集的方法：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The term collision resolution simply means performing some sequence of actions
    in order to notify and move the colliding entities. In a case of collision with
    tiles, for example, the collision resolution means pushing the entity back just
    far enough so it isn't intersecting with the tile any more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突解决这个术语简单来说就是执行一系列动作来通知并移动发生碰撞的实体。例如，在碰撞到瓦片的情况下，冲突解决意味着将实体推回足够远，使其不再与瓦片相交。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code files of this project contain an additional class that allows debug
    information rendering to take place, as well as all of these bits of information
    already set up. Hitting the *O* key will toggle its visibility.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码文件包含一个额外的类，允许进行调试信息渲染，以及已经设置好的所有这些信息。按下 *O* 键可以切换其可见性。
- en: Implementing the base entity class
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基础实体类
- en: 'With all of that information out of the way, we can finally return to implementing
    the base entity class. As always, what better place is there to start than the
    constructor? Let''s take a look:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有这些信息之后，我们终于可以回到实现基础实体类的工作上了。一如既往，还有什么地方比构造函数更好的起点呢？让我们来看看：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It simply initializes all of its data members to default values. Notice that
    out of all the members it sets to zero, the friction actually gets set up for
    the *x* axis to be 0.8\. This is because we don't want the default behavior of
    the entity to be equal to that of a cow on ice, to put it frankly. Friction defines
    how much of the entity's velocity is lost to the environment. If it doesn't make
    too much sense now, don't worry. We're about to cover it in greater detail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将所有数据成员初始化为默认值。请注意，在它设置为零的所有成员中，摩擦系数实际上被设置为 *x* 轴为 0.8。这是因为我们不想实体的默认行为与冰上的牛一样，坦白说。摩擦系数定义了实体速度中有多少会损失到环境中。如果现在不太理解，不用担心。我们很快就会更详细地介绍它。
- en: 'Here we have all of the methods for modifying data members of the entity base
    class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含了修改实体基类数据成员的所有方法：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, modifying either the position or size of an entity results in
    a call of the internal method `UpdateAABB`. Simply put, it's responsible for updating
    the position of the bounding box. More information on that is coming soon.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，修改实体位置或大小都会调用内部方法 `UpdateAABB`。简单来说，它负责更新边界框的位置。更多相关信息即将揭晓。
- en: One interesting thing to note is in the `SetState` method. It does not allow
    the state to change if the current state is `Dying`. This is done in order to
    prevent some other event in the game to snap an entity out of death magically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的事情要注意的是在 `SetState` 方法中。如果当前状态是 `Dying`，则不允许状态改变。这样做是为了防止游戏中的某些其他事件神奇地将实体从死亡状态中拉出来。
- en: 'Now we have a more interesting chunk of code, responsible for moving an entity:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更有趣的代码块，负责移动实体：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we copy the current position to another data member: `m_positionOld`.
    It''s always good to keep track of this information, in case we need it later.
    Then, the position is adjusted by the offset provided through the arguments. The
    size of the map is obtained afterwards, in order to check the current position
    for being outside of the map. If it is on either axis, we simply reset its position
    to something that''s at the very edge of the out-of-bounds area. In the case of
    the entity being outside of the map on the *y* axis, its state is set to `Dying`.
    After all of that, the bounding box is updated in order to reflect the changes
    to the position of the entity sprite.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将当前位置复制到另一个数据成员：`m_positionOld`。保留这些信息总是好的，以防以后需要。然后，位置通过提供的偏移量进行调整。之后，获取地图的大小，以便检查当前位置是否超出地图范围。如果它在任一轴上，我们只需将其位置重置为边界外的边缘。如果实体在
    *y* 轴上超出地图范围，其状态被设置为 `Dying`。在所有这些之后，边界框被更新以反映实体精灵位置的变化。
- en: 'Now let''s work on adding to and managing the entity''s velocity:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来添加和管理实体的速度：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, it's fairly simple stuff. The velocity member is added to and
    then checked for being outside of the bounds of allowed maximum velocity. In the
    first check we're using absolute values, because velocity can be both positive
    and negative, which indicates the direction the entity's moving in. If the velocity
    is out of bounds, it gets reset to the maximum allowed value it can have.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这相当简单。将速度成员添加到一起，然后检查它是否超出允许的最大速度范围。在第一次检查中，我们使用绝对值，因为速度可以是正的也可以是负的，这表示实体移动的方向。如果速度超出范围，则将其重置为允许的最大值。
- en: 'Accelerating an entity, you could say, is as simple as adding one vector to
    another:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 说到加速实体，可以说，就像向另一个向量中添加一个向量一样简单：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Applying friction is no more complex than managing our velocity:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用摩擦并不比管理我们的速度更复杂：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It needs to check if the difference between the absolute values of both the
    velocity and the friction coefficient on that axis isn't less than zero, in order
    to prevent changing the direction of the entity's movement through friction, which
    would simply be weird. If it is less than zero, the velocity gets set back to
    zero. If it isn't, the velocity's sign is checked and friction in the proper direction
    is applied.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要检查该轴上速度和摩擦系数绝对值之差是否不小于零，以防止通过摩擦改变实体运动方向，这会显得很奇怪。如果是小于零，则将速度设置回零。如果不是，则检查速度的符号并应用适当方向的摩擦。
- en: 'In order for an entity to not be a static part of the backdrop, it needs to
    be updated:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实体不是背景的静态部分，它需要被更新：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Quite a bit is happening here. Let's take it step by step. First, an instance
    of the game map is obtained through the shared context. It is then used to obtain
    the gravity of the map, which was loaded from the map file. The entity's acceleration
    is then increased by the gravity on the *y* axis. By using the `AddVelocity` method
    and passing in the acceleration multiplied by delta time, the velocity is adjusted
    and the acceleration is set back to zero. Next, we must obtain the friction coefficient
    that the velocity will be damped by. The `m_referenceTile` data member, if it's
    not set to `nullptr`, is used first, in order to obtain the friction from a tile
    the entity's standing on. If it is set to `nullptr`, the entity must be in mid-air,
    so the default tile from the map is obtained to grab the friction values that
    were loaded from the map file. If that, for whatever reason, is also not set up,
    we default to the value set in the `EntityBase`'s constructor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。让我们一步一步来。首先，通过共享上下文获取游戏地图的一个实例。然后使用它来获取地图的重力，该重力是从地图文件中加载的。然后，实体的加速度通过
    *y* 轴的重力增加。通过使用 `AddVelocity` 方法并传递加速度乘以时间增量，调整速度并将加速度设置回零。接下来，我们必须获取速度将被阻尼的摩擦系数。如果
    `m_referenceTile` 数据成员没有被设置为 `nullptr`，则首先使用它，以从实体所站的瓦片中获取摩擦力。如果它被设置为 `nullptr`，则实体必须在空中，因此从地图中获取默认瓦片以获取从地图文件中加载的摩擦值。如果由于任何原因，这也没有设置，则默认为在
    `EntityBase` 构造函数中设置的值。
- en: Before we get to calculating friction, it's important to clarify that the `m_speed`
    data member is not set up or initialized in this class, aside from being set to
    a default value. The speed is how much an entity is accelerated when it's moving
    and it will be implemented in one of the derived classes of `EntityBase`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算摩擦力之前，重要的是要明确，除了被设置为默认值之外，`m_speed` 数据成员在这个类中既没有设置也没有初始化。速度是实体移动时加速的量，它将在
    `EntityBase` 的一个派生类中实现。
- en: If you recall from the constructor of this class, we set up the default friction
    to be 0.8f. That is not just an incredibly small value. We're using friction as
    a factor in order to determine how much of the entity's speed should be lost.
    Having said that, multiplying the speed by a friction coefficient and multiplying
    that by delta time yields us the velocity that is lost during this frame, which
    is then passed into the `ApplyFriction` method in order to manipulate the velocity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从该类的构造函数中回忆起来，我们设置了默认摩擦为 0.8f。这不仅仅是一个非常小的值。我们正在使用摩擦作为一个因素，以确定实体速度应该损失多少。话虽如此，将速度乘以摩擦系数，然后乘以时间增量，我们得到的是在此帧中损失的速度，然后将其传递到
    `ApplyFriction` 方法中以操纵速度。
- en: Finally, the change in position, called `deltaPos` is calculated by multiplying
    the velocity by delta time, and is passed into the `Move` method to adjust the
    entity's position in the world. The flags for collisions on both axes get reset
    to false and the entity calls its own private members for first obtaining and
    then resolving collisions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，位置的变化，称为 `deltaPos`，是通过将速度乘以时间增量来计算的，并将其传递到 `Move` 方法中以调整实体在世界中的位置。两个轴上的碰撞标志被重置为
    false，实体调用其自己的私有成员以首先获取然后解决碰撞。
- en: 'Let''s take a look at the method responsible for updating the bounding box:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看负责更新边界框的方法：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because the origin of the bounding box is left at the top-left corner and the
    entity's position is set to (width / 2, height), accounting for that is necessary
    if we want to have accurate collisions. The rectangle that represents the bounding
    box is reset to match the new position of the sprite.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边界框的起点被留在左上角，并且实体的位置被设置为 (width / 2, height)，如果我们想要精确的碰撞，那么考虑这一点是必要的。代表边界框的矩形被重置以匹配精灵的新位置。
- en: Entity-on-tile collisions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体与瓦片碰撞
- en: 'Before jumping into collision detection and resolution, let''s revisit the
    method SFML provides to check if two rectangles are intersecting:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入碰撞检测和解决之前，让我们回顾一下 SFML 提供的用于检查两个矩形是否相交的方法：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It doesn''t matter which rectangle we check, the intersecting method will still
    return true if they are intersecting. However, this method does take in an optional
    second argument, which is a reference of a rectangle class that will be filled
    with the information about the intersection itself. Consider the following illustration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们检查哪个矩形，如果它们相交，交点方法仍然会返回 true。然而，此方法确实接受一个可选的第二个参数，它是一个矩形类的引用，该引用将填充有关交点本身的信息。考虑以下插图：
- en: '![Entity-on-tile collisions](img/B04284_07_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![实体与瓦片碰撞](img/B04284_07_04.jpg)'
- en: 'We have two rectangles that are intersecting. The diagonal striped area represents
    the rectangle of intersection, which can be obtained by doing this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个相交的矩形。对角条纹区域表示交集的矩形，可以通过以下方式获得：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is important to us, because an entity could be colliding with more than
    one tile at a time. Knowing the depth of a collision is also a crucial part of
    resolving it. With that in mind, let''s define a structure to temporarily hold
    the collision information before it gets resolved:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说很重要，因为一个实体可能同时与多个瓦片发生碰撞。了解碰撞的深度也是解决碰撞的关键部分。考虑到这一点，让我们定义一个结构来临时存储碰撞信息，在它被解决之前：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we're creating a structure that holds a floating point number representing
    the area of collision, a rectangle that holds the boundary information of a tile
    the entity's colliding with, and a pointer to a `TileInfo` instance. You always
    want to resolve the biggest collisions first, and this information is going to
    help us do just that. The collision elements themselves are going to be stored
    in a vector this time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个结构，它包含一个表示碰撞面积的浮点数，一个包含实体碰撞的瓦片的边界信息的矩形，以及一个指向`TileInfo`实例的指针。你总是希望先解决最大的碰撞，这些信息将帮助我们做到这一点。这次，碰撞元素将存储在一个向量中。
- en: 'Next, we need a function that can compare two elements of our custom container
    in order to sort it, the blueprint of which in the header file of the `EntityBase`
    class looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数来比较我们自定义容器中的两个元素以便对其进行排序，其蓝图在`EntityBase`类的头文件中看起来像这样：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implementing this function is incredibly easy. The vector container simply
    uses a Boolean check to determine which one of the two elements it''s comparing
    is larger. We simply return true or false, based on which element is bigger. Because
    we''re sorting our container by the area size, the comparison is done between
    the first elements of the first pairs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个函数非常简单。向量容器简单地使用布尔检查来确定它正在比较的两个元素中哪一个更大。我们只需根据哪个元素更大返回true或false。因为我们按面积大小对容器进行排序，所以比较是在第一对的第一元素之间进行的：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now onto the interesting part, detecting the collisions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是有趣的部分，检测碰撞：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We begin by using the coordinates and size of the bounding box to obtain the
    coordinates of tiles it is potentially intersecting. This is illustrated better
    in the following image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用边界框的坐标和大小来获得它可能相交的瓦片的坐标。以下图像更好地说明了这一点：
- en: '![Entity-on-tile collisions](img/B04284_07_05.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![实体与瓦片碰撞](img/B04284_07_05.jpg)'
- en: The range of tile coordinates represented by the four integers is then fed into
    a double loop which checks if there is a tile occupying the space we're interested
    in. If a tile is returned from the `GetTile` method, the bounding box of the entity
    is definitely intersecting a tile, so a float rectangle that represents the bounding
    box of a tile is created. We also prepare another float rectangle to hold the
    data of the intersection and call the `intersects` method in order to obtain this
    information. The area of the intersection is calculated by multiplying its width
    and height, and the information about the collision is pushed into the collision
    container, along with a pointer to the `TileInfo` object that represents the type
    of tile the entity is colliding with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将由四个整数表示的瓦片坐标范围输入到一个双重循环中，该循环检查是否有瓦片占据了我们所感兴趣的空间。如果`GetTile`方法返回一个瓦片，那么实体的边界框肯定与一个瓦片相交，因此创建一个表示瓦片边界框的浮点矩形。我们还准备另一个浮点矩形来保存交集的数据，并调用`intersects`方法以获取这些信息。交集的面积通过乘以其宽度和高度来计算，碰撞信息以及表示实体碰撞的瓦片类型的`TileInfo`对象的指针被推入碰撞容器中。
- en: The last thing we do before wrapping up this method is check if the current
    tile the entity is colliding with is a warp tile and if the entity is a player.
    If both of these conditions are met, the next map is loaded.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这个方法之前，我们最后要检查实体正在碰撞的当前瓦片是否是扭曲瓦片，以及实体是否是玩家。如果这两个条件都满足，则加载下一个地图。
- en: 'Now that a list of collisions for an entity has been obtained, resolving them
    is the next step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经获得了一个实体的碰撞列表，下一步是解决它们：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we check if there are any collisions in the container. Sorting of all
    the elements happens next. The `std::sort` function is called and iterators to
    the beginning and end of the container are passed in, along with the name of the
    function that will do the comparisons between the elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查容器中是否有任何碰撞。接下来是对所有元素进行排序。调用`std::sort`函数，并传入容器的开始和结束迭代器，以及将用于元素之间比较的函数名称。
- en: The code proceeds to loop over all of the collisions stored in the container.
    There is another intersection check here between the bounding box of the entity
    and the tile. This is done because resolving a previous collision could have moved
    an entity in such a way that it is no longer colliding with the next tile in the
    container. If there still is a collision, distances from the center of the entity's
    bounding box to the center of the tile's bounding box are calculated. The first
    purpose these distances serve is illustrated in the next line, where their absolute
    values get compared. If the distance on the x axis is bigger than on the y axis,
    the resolution takes place on the x axis. Otherwise, it's resolved on the y axis.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接着遍历容器中存储的所有碰撞。这里在实体的边界框和瓦片的边界框之间还有一个交点检查。这样做是因为解决之前的碰撞可能会以某种方式移动实体，使其不再与容器中下一个瓦片发生碰撞。如果仍然存在碰撞，则计算实体边界框中心到瓦片边界框中心的距离。这些距离的第一个用途在下一条线中体现，其中它们的绝对值被比较。如果x轴上的距离大于y轴上的距离，则解决发生在x轴上。否则，它在y轴上解决。
- en: The second purpose of the distance calculation is determining which side of
    the tile the entity is on. If the distance is positive, the entity is on the right
    side of the tile, so it gets moved in the positive x direction. Otherwise, it
    gets moved in the negative x direction. The *resolve* variable takes in the amount
    of penetration between the tile and the entity, which is different based on the
    axis and the side of the collision.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 距离计算的第二个目的是确定实体位于瓦片的哪一侧。如果距离为正，则实体位于瓦片的右侧，因此它向正x方向移动。否则，它向负x方向移动。`resolve`变量接受瓦片和实体之间的穿透量，这取决于轴和碰撞的侧面。
- en: In the case of both axes, the entity is moved by calling its `Move` method and
    passing in the depth of penetration. Killing the entity's velocity on that axis
    is also important, in order to simulate the entity hitting a solid. Lastly, the
    flag for a collision on a specific axis is set to true.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个轴的情况下，通过调用其实体的`Move`方法并传入穿透深度来移动实体。在模拟实体撞击固体时，停止该轴上的实体速度也很重要。最后，将特定轴上的碰撞标志设置为true。
- en: 'If a collision is resolved on the y axis, in addition to all the same steps
    that are taken in a case of x axis collision resolution, we also check if the
    flag is set for a y axis collision. If it hasn''t been set yet, we change the
    `m_referenceTile` data member to point to the tile type of the current tile the
    entity is colliding with, which is followed by that flag getting set to true in
    order to keep the reference unchanged until the next time collisions are checked.
    This little snippet of code gives any entity the ability to behave differently
    based on which tile it''s standing on. For example, the entity can slide a lot
    more on ice tiles than on simple grass tiles, as illustrated here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果碰撞在y轴上解决，除了在x轴碰撞解决情况下采取的所有相同步骤外，我们还会检查是否设置了y轴碰撞标志。如果尚未设置，我们将`m_referenceTile`数据成员更改为指向实体正在与之碰撞的当前瓦片的瓦片类型，然后设置该标志为true，以保持引用不变，直到下一次检查碰撞。这段小代码片段使任何实体根据其站立在哪个瓦片上而表现出不同的行为。例如，实体在冰瓦片上可以比在简单的草瓦片上滑动更多，如图所示：
- en: '![Entity-on-tile collisions](img/B04284_07_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![实体在瓦片上的碰撞](img/B04284_07_06.jpg)'
- en: As the arrow points out, the friction coefficient of these tiles is different,
    which means we are in fact obtaining the information from the tiles directly below.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如箭头所示，这些瓦片的摩擦系数不同，这意味着我们实际上是从直接下面的瓦片获取信息。
- en: Entity storage and management
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体存储和管理
- en: 'Without proper management, these entities are just random classes scattered
    about in your memory with no rhyme or reason. In order to produce a robust way
    to create interactions between entities, they need to be babysat by a manager
    class. Before we begin designing it, let''s define some data types to contain
    the information we''re going to be working with:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有适当的管理，这些实体只是散布在内存中的随机类，没有任何规律。为了产生一种稳健的方式来创建实体之间的交互，它们需要由一个管理类来监护。在我们开始设计它之前，让我们定义一些数据类型来包含我们将要处理的信息：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `EntityContainer` type is, as the name suggests, a container of entities.
    It is once again powered by an `unordered_map`, which ties instances of entities
    to unsigned integers that serve as identifiers. The next type is a container of
    lambda functions that links entity types to code that can allocate memory and
    return instances of classes that inherit from the base entity class and serves
    as a factory. This behavior isn''t new to us, so let''s move on to defining the
    entity manager class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityContainer`类型，正如其名所示，是一个实体容器。它再次由一个`unordered_map`提供支持，将实体实例与作为标识符的无符号整数关联起来。下一个类型是lambda函数的容器，它将实体类型与可以分配内存并返回从基实体类继承的类实例的代码链接起来，充当工厂。这种行为对我们来说并不陌生，所以让我们继续定义实体管理器类：'
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Aside from the private template method for inserting lambda functions into the
    entity factory container, this looks like a relatively typical class. We have
    methods for updating and drawing entities, adding, finding and removing them and
    purging all of the data, as we tend to do. The presence of the private method
    called `ProcessRemovals` insists that we're using delayed removals of entities,
    much like we did in our state manager class. Let's take a closer look at how this
    class will operate by implementing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将lambda函数插入实体工厂容器的私有模板方法之外，这个类看起来相对典型。我们有更新和绘制实体、添加、查找和删除它们以及清除所有数据的方法，就像我们通常做的那样。存在名为`ProcessRemovals`的私有方法表明我们正在使用延迟删除实体，就像我们在状态管理器类中所做的那样。让我们通过实现它来更详细地了解这个类的运作方式。
- en: Implementing the entity manager
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体管理器的实现
- en: 'As always, a good place to start is the constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，一个好的开始是构造函数：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Some of its data members are initialized through an initializer list. The `m_idCounter`
    variable will be used to keep track of the highest ID that was given to an entity.
    Next, a private method is invoked for loading pairs of enemy names and their character
    definition files, which will be explained a little later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些数据成员通过初始化列表进行初始化。`m_idCounter`变量将用于跟踪分配给实体的最高ID。接下来，调用一个私有方法来加载敌人名称和它们的角色定义文件对，这将在稍后进行解释。
- en: 'Lastly, two entity types are registered: player and enemy. We don''t have their
    classes set up yet, but it''s coming soon, so we may as well just register them
    now.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注册了两种实体类型：玩家和敌人。我们还没有设置它们的类，但很快就会完成，所以现在我们可以先注册它们。
- en: The destructor of an entity manager simply invokes the `Purge` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 实体管理器的析构函数简单地调用`Purge`方法。
- en: 'Adding a new entity to the game is done by passing in an entity type along
    with its name to the `Add` method of the entity manager:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将实体类型及其名称传递给实体管理器的`Add`方法来向游戏中添加新实体：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The entity factory container is searched for the type that was provided as an
    argument. If that type is registered, the lambda function is invoked to allocate
    dynamic memory for the entity and the memory address is caught by a pointer variable
    to the `EntityBase` class – `entity`. The newly created entity is then inserted
    into the entity container and its ID is set up by using the `m_idCounter` data
    member. If the user provides an argument for the entity name, it gets set up as
    well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实体工厂容器会搜索提供的参数类型。如果该类型已注册，则会调用lambda函数来为实体分配动态内存，并通过指向`EntityBase`类的指针变量`entity`捕获内存地址。然后，新创建的实体被插入到实体容器中，并使用`m_idCounter`数据成员设置其ID。如果用户为实体名称提供了参数，它也会被设置。
- en: The entity type then gets checked. If it's an enemy, the enemy type container
    is searched in order to locate the path to a character definition file. If it's
    found, the entity is type-cast into an enemy instance and a `Load` method is called,
    to which the character file path is passed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来检查实体类型。如果是敌人，则会在敌人类型容器中搜索以找到角色定义文件的路径。如果找到，实体会被类型转换为敌人实例，并调用`Load`方法，将角色文件路径传递给它。
- en: Lastly, the ID counter is incremented and the entity ID that was just used gets
    returned to signify success. If the method failed at any point, it will instead
    return *-1*, signifying a failure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ID计数器递增，并返回刚刚使用的实体ID以表示成功。如果在任何点上方法失败，它将返回*-1*，表示失败。
- en: 'Having an entity manager is pointless if you can''t obtain the entities. That''s
    where the `Find` method comes in:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能获取实体，拥有实体管理器是没有意义的。这就是`Find`方法的作用：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our entity manager provides two versions of this method. The first version
    takes in an entity name and searches the container until an entity is found with
    that name, at which point it gets returned. The second version looks up entities
    based on a numerical identifier:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体管理器提供了这个方法的两个版本。第一个版本接受一个实体名称，并在容器中搜索直到找到一个具有该名称的实体，此时它被返回。第二个版本根据数值标识符查找实体：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because we map instances of entities to numerical values, this is easier, as
    we can simply call the `Find` method of our container in order to find the element
    we're looking for.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将实体实例映射到数值，这更容易，因为我们只需调用我们的容器中的`Find`方法来找到我们正在寻找的元素。
- en: 'Now let''s work on removing entities:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理移除实体：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the public method that takes in an entity ID and inserts it into a container,
    which will be used later to remove entities.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公共方法，它接受一个实体ID并将其插入到容器中，该容器将用于稍后移除实体。
- en: 'Updating all entities can be achieved as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 更新所有实体可以通过以下方式实现：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The manager iterates through all of its elements and invokes their respective
    `Update` methods by passing in the delta time it receives as an argument. After
    all of the entities are updated, a private method `EntityCollisionCheck` is invoked
    in order to check for and resolve collisions between entities. Then, we process
    the entity removals that were added by the `Remove` method implemented previously.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器遍历其所有元素，并通过传递作为参数接收的delta时间调用它们各自的`Update`方法。在所有实体更新完毕后，将调用一个私有方法`EntityCollisionCheck`来检查和解决实体之间的碰撞。然后，我们处理由之前实现的`Remove`方法添加的实体移除。
- en: 'Let''s take a look at how we can draw all of these entities:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何绘制所有这些实体：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After obtaining a pointer to the render window, we also get the view space of
    it in order to cull entities for efficiency reasons. Because both the view space
    and the bounding box of an entity are rectangles, we can simply check if they're
    intersecting in order to determine if an entity is within the view space, and
    if it is, it gets drawn.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到渲染窗口的指针后，我们也得到了它的视图空间，以便出于效率原因剪裁实体。因为实体的视图空间和边界框都是矩形，我们可以简单地检查它们是否相交，以确定实体是否在视图空间内，如果是的话，它就会被绘制。
- en: 'The entity manager needs to have a way to dispatch of all of its resources.
    This is where the `Purge` method comes in:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实体管理器需要有一种方式来分配其所有资源。这就是`Purge`方法发挥作用的地方：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Entities get iterated over and their dynamic memory is de-allocated – regular
    as clockwork. Now to process the entities that need to be removed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实体被迭代，它们的动态内存被释放——就像时钟一样规律。现在来处理需要被移除的实体：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we're iterating over the container that holds the IDs of entities that need
    to be removed, the entity container is checked for the existence of every ID that
    was added. If an entity with the ID does in fact exist, its memory is de-allocated
    and the element is popped from the entity container.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历包含需要移除的实体ID的容器时，会检查实体容器中是否存在每个添加的ID。如果确实存在具有该ID的实体，其内存将被释放，并且元素将从实体容器中弹出。
- en: 'Now for the interesting part – detecting entity-to-entity collisions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是更有趣的部分——检测实体之间的碰撞：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, the way we''re checking every entity against every other entity needs
    to be addressed. There are, of course, much better and more efficient ways to
    determine which entities to check without simply iterating over all of them, such
    as binary space partitioning. However, given the scope of our project, that would
    be overkill:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要解决的是我们如何检查每个实体与每个其他实体的问题。当然，有更好的、更有效的方法来确定要检查哪些实体，而不仅仅是遍历所有实体，例如二叉空间划分。然而，鉴于我们项目的范围，那将是过度设计：
- en: '|   | *"Premature optimization is the root of all evil (or at least most of
    it) in programming."* |   |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|   | *"过早优化是编程中所有邪恶（至少是大多数邪恶）的根源。"* |   |'
- en: '|   | --*Donald Knuth* |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|   | --*唐纳德·克努特* |'
- en: 'Having said that, we are going to be a bit smarter and not simply iterate over
    all of the entities twice. Because checking entity 0 against entity 1 is the same
    as checking entity 1 against 0, we can implement a much more efficient algorithm
    by using `std::next`, which creates an iterator that is one space ahead of the
    one fed to it, and use it in the second loop. This creates a check pattern that
    looks something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将变得更聪明一些，而不仅仅是简单地迭代所有实体两次。因为检查实体0与实体1相同于检查实体1与0，我们可以通过使用`std::next`来实现一个更高效的算法，它创建一个比提供的迭代器前移一个空间的迭代器，并在第二个循环中使用它。这创建了一个看起来像这样的检查模式：
- en: '![Implementing the entity manager](img/B04284_07_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![实现实体管理器](img/B04284_07_07.jpg)'
- en: That is about as much optimization as we need in the early stages of making
    a game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在游戏早期制作阶段需要的优化。
- en: 'When iterating over entities, the collision check method first makes sure that
    both iterators do not share the same entity ID, for some odd reason. Then, it''s
    simply a matter of checking for intersections between the bounding boxes of the
    two entities we''re interested in. If there is a collision, the methods for handling
    it are called in both instances, passing in the entity being collided with as
    an argument, along with false as the second argument, to let the entity know it''s
    a simple AABB collision. What does that mean? Well, generally, there are going
    to be two types of collisions between entities: regular bounding box collisions
    and attack collisions. Children of the `EntityBase` class, mainly the `Character`
    instances, will have to keep another bounding box in order to perform attacks,
    as illustrated here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历实体时，碰撞检查方法首先确保两个迭代器不共享相同的实体ID，出于某种奇怪的原因。然后，它只是简单地检查我们感兴趣的两个实体的边界框之间的交集。如果有碰撞，则在两个实例中调用处理碰撞的方法，传递被碰撞的实体作为参数，以及作为第二个参数的`false`，以让实体知道这是一个简单的AABB碰撞。那是什么意思呢？嗯，一般来说，实体之间会有两种类型的碰撞：常规边界框碰撞和攻击碰撞。`EntityBase`类的子类，主要是`Character`实例，将必须保持另一个边界框以执行攻击，如图所示：
- en: '![Implementing the entity manager](img/B04284_07_08.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![实现实体管理器](img/B04284_07_08.jpg)'
- en: Because this isn't terribly complicated to implement, we can continue implementing
    the entity manger until we implement the `Character` class shortly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这并不复杂，我们可以继续实现实体管理器，直到我们不久后实现`Character`类。
- en: Since only the `Character` class and any class that inherits from it is going
    to have an attack bounding box, it's necessary to first check if we're dealing
    with a `Character` instance by verifying the entity type. If an entity is of the
    type `Enemy` or `Player`, the `OnEntityCollision` method of the `Character` instance
    is invoked and receives the entity it's colliding with, as well as a Boolean constant
    of `true` this time, as arguments, to indicate an attack collision.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有`Character`类及其任何继承类将具有攻击边界框，因此有必要首先通过验证实体类型来检查我们是否正在处理一个`Character`实例。如果一个实体是`Enemy`或`Player`类型，则调用`Character`实例的`OnEntityCollision`方法，并传递与之碰撞的实体以及这次作为参数的布尔常量`true`，以指示攻击碰撞。
- en: 'We''re mostly done. Let''s write the method for loading different enemy types
    that can parse files like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上已经完成了。让我们编写加载不同敌人类型的方法的代码，这些敌人类型可以解析像这样的文件：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It''s quite a simple format. Let''s read it in:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的格式。让我们读取它：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There is nothing here you haven't seen before. The two string values get read
    in and stored in the enemy type container. This simple bit of code concludes our
    interest in the entity manager class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么是你以前没有见过的。两个字符串值被读取并存储在敌人类型容器中。这段简单的代码结束了我们对实体管理器类的兴趣。
- en: Using entities to build characters
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实体构建角色
- en: 'So far, we only have entities that define some abstract methods and provide
    the means of manipulating them, but nothing that can appear in the game world,
    be rendered, and walk around. At the same time, we don''t want to re-implement
    all of that functionality all over again in the player or enemy classes, which
    means we need an intermediate-level abstract class: `Character`. This class will
    provide all of the functionality that is shared between all entities that need
    to move around the world and be rendered. Let''s get on with designing:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有定义了一些抽象方法并提供操作它们的手段的实体，但没有可以在游戏世界中出现、渲染并四处走动的实体。同时，我们也不想在玩家或敌人类中重新实现所有这些功能，这意味着我们需要一个中间级别的抽象类：`Character`。这个类将提供所有需要在世界中移动并被渲染的实体之间共享的功能。让我们继续设计：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, let's talk about the public methods. Moving, jumping, attacking, and
    receiving damage are the common actions of every character-entity in the game.
    The character also has to be loaded in order to provide it with the correct graphics
    and properties that differ between each enemy type and the player. All classes
    derived from it have to implement their own version of handling collisions with
    other entities. Also, the `Update` method of the character class is made to be
    virtual, which allows any class inheriting from this one to either define its
    own update method or extend the existing one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈公共方法。移动、跳跃、攻击和受到伤害是游戏中每个角色-实体常见的动作。角色还必须被加载，以便提供正确的图形和属性，这些属性在每种敌人类型和玩家之间是不同的。所有从它派生的类都必须实现它们自己的处理与其他实体碰撞的版本。此外，角色类的`Update`方法被设置为虚拟的，这允许任何从该类继承的类定义自己的更新方法或扩展现有的方法。
- en: All characters will be using the sprite sheet class that we designed previously
    in order to support animations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有角色都将使用我们之前设计的精灵图集类来支持动画。
- en: Implementing the character class
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现角色类
- en: 'You know the drill by now. Here''s the constructor:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该知道了。这是构造函数：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The sprite sheet is created and set up by passing a pointer to the texture manager
    in its constructor. We also have a data member called `m_jumpVelocity`, which
    specifies how far the player can jump. Lastly, we set some arbitrary value to
    the `m_hitpoints` variable, which represents how many times an entity can be hit
    before it dies.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集是通过在构造函数中传递指向纹理管理器的指针来创建和设置的。我们还有一个名为`m_jumpVelocity`的数据成员，它指定了玩家可以跳多远。最后，我们给`m_hitpoints`变量设置了一个任意值，它代表了实体在被击中多少次后才会死亡。
- en: 'Let''s move on to the `Move` method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`Move`方法：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Regardless of the entity''s direction, the state of the entity is checked in
    order to make sure the entity isn''t dying. If it isn''t, the direction of the
    sprite sheet is set up and the character begins to accelerate on a relevant axis.
    Lastly, if the entity is currently in an idle state, it gets set to walking simply
    to play the walking animation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实体的方向如何，都会检查实体的状态，以确保实体没有死亡。如果没有死亡，就会设置精灵图集的方向，并且角色开始在相关轴上加速。最后，如果实体目前处于空闲状态，它会被设置为行走状态，以便播放行走动画：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A character should only be able to jump if it isn't dying, taking damage, or
    jumping already. When those conditions are met and the character is instructed
    to jump, its state is set to `Jumping` and it receives negative velocity on the
    y axis that makes it combat the gravity force and go up. The velocity has to be
    high enough in order to break the gravitational force of the level.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个角色只有在没有死亡、受到伤害或正在跳跃的情况下才能跳跃。当这些条件满足，并且角色被指示跳跃时，其状态被设置为`Jumping`，并在y轴上获得负速度，使其对抗重力并向上移动。速度必须足够高，才能打破该级别的重力。
- en: 'Attacking is fairly straightforward. Because the entity manager already does
    the collision checking for us, all that''s left to do is set the state if an entity
    isn''t dying, jumping, taking damage, or already attacking:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击相当直接。因为实体管理器已经为我们做了碰撞检测，所以剩下的只是设置状态，如果实体没有死亡、跳跃、受到伤害或正在攻击的话：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to bestow mortality onto our entities, they need to have a way to
    be hurt:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了赋予我们的实体生命，它们需要有受伤的方式：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This method inflicts damage to the character if it isn't already taking damage
    or dying. The damage value is either subtracted from the hit-points or the hitpoints
    variable is set to *0* in order to keep it from reaching the negatives. If the
    entity still has lives after the subtraction, its state is set to `HURT` in order
    to play the proper animation. Otherwise, the entity is sentenced to death by the
    programmer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角色尚未受到伤害或死亡，此方法会对角色造成伤害。伤害值要么从生命值中减去，要么将生命值变量设置为*0*，以防止其达到负值。如果减去伤害后实体仍有生命，其状态将被设置为`HURT`，以便播放正确的动画。否则，程序员将实体判处死刑。
- en: 'As previously mentioned, we want to be able to load our characters in from
    files like this one (`Player.char`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望能够从像这样的文件中加载我们的角色（`Player.char`）：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It contains all the basic bits and pieces of what makes up a character, like
    the sprite sheet handle and all of the other information discussed in earlier
    sections. The loading method for this type of file will not differ much from the
    ones we''ve already implemented:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了构成角色的所有基本组成部分，如精灵表句柄以及在前几节中讨论的所有其他信息。此类文件的加载方法与我们已实现的那些方法不会有太大差异：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Aside from the sprite sheet having to call a load method, the rest is simply
    loading in data members from a string stream.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了精灵表需要调用一个加载方法外，其余的只是从字符串流中加载数据成员。
- en: 'Just like the base entity and its bounding box, the character has to have a
    way to update the position of its attack area:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基础实体及其边界框一样，角色必须有一种方法来更新其攻击区域的位置：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: One subtle difference here is that the attack bounding box uses the position
    of the entity's bounding box, not its sprite position. Also, the way it's positioned
    is different based on the direction an entity is facing, due to the fact that
    the bounding box's position represents its top-left corner.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个细微差别是，攻击边界框使用的是实体边界框的位置，而不是其精灵位置。此外，其定位方式根据实体面对的方向而不同，因为边界框的位置代表其左上角。
- en: 'Now for the method that will make the biggest difference, visually speaking:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍将带来最大视觉差异的方法了：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'All it does is simply check the current state and the current animation. If
    the current animation does not match the current state, it gets set to something
    else. Note the use of the third argument in the `SetAnimation` method, which is
    a Boolean constant and represents animation looping. Certain animations do not
    need to loop, like the attack or hurt animation. The fact that they do not loop
    and are stopped when they reach the end frame gives us a hook to manipulate what
    happens in the game, simply based on the progress of a certain animation. Case
    in point – the `Update` method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是简单地检查当前状态和当前动画。如果当前动画与当前状态不匹配，它将被设置为其他内容。注意`SetAnimation`方法中的第三个参数的使用，它是一个布尔常量，代表动画循环。某些动画不需要循环，如攻击或受伤动画。它们不循环并在达到最后一帧时停止，这为我们提供了一个钩子，可以根据特定动画的进度来操纵游戏中的发生的事情。以`Update`方法为例：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, we invoke the update method of the entity's base class, because the character's
    state depends on it. Then, we check if the width and height of the attack bounding
    box aren't still at 0, which are the default values for them. If they aren't,
    it means the attack bounding box has been set up and can be updated. The rest
    of the update method pretty much just handles state transitions. If the entity
    isn't dying, attacking something, or taking damage, its current state is going
    to be determined by its velocity. In order to accurately depict an entity falling,
    we have to make the velocity on y axis take precedence over everything else. If
    the entity has no vertical velocity, it's checked for horizontal velocity instead
    and sets the state to `Walking` if the velocity is higher than the specified minimum.
    Using small values instead of absolute zero takes care of problems with animations
    being jittery sometimes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用实体基类的更新方法，因为角色的状态依赖于它。然后，我们检查攻击边界框的宽度和高度是否仍然为0，这是它们的默认值。如果不是，这意味着攻击边界框已经设置好，可以更新。更新方法的其余部分基本上只是处理状态转换。如果实体没有死亡、攻击某物或受到伤害，其当前状态将由其速度决定。为了准确地描绘实体下落，我们必须使y轴上的速度优先于其他所有因素。如果实体没有垂直速度，则检查水平速度，如果速度高于指定的最小值，则将状态设置为`Walking`。使用小值而不是绝对零值可以解决动画有时会抖动的问题。
- en: Because the attacking and taking damage states are not set to loop, the sprite
    sheet animation is checked in order to see if it is still playing. If it isn't,
    the state is switched back to idle. Lastly, if the entity is dying and the dying
    animation is finished playing, we call the `Remove` method of our entity manager
    in order to remove this entity from the world.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击和受到伤害的状态没有设置为循环，因此会检查精灵表动画，以查看它是否仍在播放。如果没有播放，状态会切换回空闲状态。最后，如果实体正在死亡并且死亡动画播放完毕，我们会调用实体管理器的
    `Remove` 方法，以便从世界中移除这个实体。
- en: The `Animate` method is called near the end of the update in order to reflect
    the state changes that may have taken place. Also, this is where the sprite sheet
    gets updated and has its position set to match the position of the entity.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animate` 方法在更新接近结束时被调用，以便反映可能发生的状态变化。此外，这也是精灵表更新并设置其位置以匹配实体位置的地方。'
- en: 'After all of that code, let''s end on something really simple – the `Draw`
    method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些代码之后，让我们以一个真正简单的东西结束——`Draw` 方法：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Since our sprite-sheet class takes care of drawing, all we need to do is pass
    a pointer of a render window to its `Draw` method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的精灵表类负责绘制，我们只需要传递渲染窗口的指针到其 `Draw` 方法。
- en: Creating the player
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建玩家
- en: 'Now we have a solid base for creating entities that are visually represented
    on screen. Let''s put that to good use and finally build our player class by starting
    with the header:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为在屏幕上可视化的实体创建了一个坚实的基础。让我们充分利用它，并从开始构建玩家类，从头文件开始：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is where things get easy. Because we essentially "outsourced" most of
    the common functionality to the base classes, all we''re left with now is player-specific
    logic. Notice the `React` method. Judging by its argument list, it''s obvious
    that we''re going to be using it as a callback for handling player input. Before
    we do that, however, we must register this method as one:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得简单起来。因为我们基本上将大部分通用功能外包给了基类，现在我们只剩下玩家特定的逻辑。注意 `React` 方法。根据其参数列表，很明显我们将将其用作处理玩家输入的回调。然而，在我们这样做之前，我们必须将此方法注册为：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'All we''re doing here is calling the `Load` method in order to set up the character
    values for our player and adding multiple callbacks to the same `React` method
    that will be used to process keyboard input. The type of the entity is also set
    to `Player`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是调用 `Load` 方法来设置玩家的角色值，并向将用于处理键盘输入的同一 `React` 方法添加多个回调。实体的类型也被设置为 `Player`：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The destructor, predictably enough, simply removes callbacks that we were using
    to move the player around.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数，不出所料，只是简单地移除了我们用来移动玩家的回调函数。
- en: 'The last method we are required to implement by the `Character` class is responsible
    for entity-on-entity collision:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过 `Character` 类实现的最后一个方法是负责实体之间的碰撞：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This method, as you remember from the entity manager portion of this chapter,
    is invoked when something is colliding with this particular entity. In a case
    of collision, the other colliding entity is passed in as an argument to this method
    together with a flag to determine if the entity is colliding with your bounding
    box or your attack region.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法，正如你从本章的实体管理部分所记得的，当某个实体与这个特定实体发生碰撞时会被调用。在碰撞的情况下，另一个发生碰撞的实体作为参数传递给这个方法，同时还有一个标志来确定实体是否与你的边界框或攻击区域发生碰撞。
- en: First, we make sure the player entity isn't dying. Afterwards, we check if it's
    the attack region that is colliding with another entity. If it is and the player
    is in the attack state, we check if the attack animation in the sprite sheet is
    currently "in action." If the current frame is within range of the beginning and
    end frames when the action is supposed to happen, the last check is made to determine
    if the entity is either a player or an enemy. Finally, if it is one or the other,
    the opponent gets hit with a pre-determined damage value, and based on its position
    will have some velocity added to it for a knock-back effect. That's about as basic
    a game design as it gets.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保玩家实体没有死亡。然后，我们检查是否是攻击区域与另一个实体发生碰撞。如果是，并且玩家处于攻击状态，我们检查精灵表中的攻击动画是否目前正在“进行中”。如果当前帧在动作应该发生时的开始和结束帧的范围内，最后的检查是确定实体是玩家还是敌人。最后，如果是其中之一，对手会受到预先确定的伤害值，并根据其位置添加一些速度以产生击退效果。这就是最基本的游戏设计。
- en: Adding enemies
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人
- en: 'In order to keep our player from walking the world lonely and un-attacked,
    we must add enemies to the game. Once again, let''s begin with the header file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的玩家不会在世界中孤独地行走且不受攻击，我们必须在游戏中添加敌人。再次，让我们从头文件开始：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It''s the same basic idea here as it was in the player class. This time, however,
    the enemy class needs to specify its own version of the `Update` method. It also
    has two private data members, one of which is a destination vector. It is a very
    simple attempt at adding basic artificial intelligence to the game. All it will
    do is keep track of a destination position, which the `Update` method will randomize
    every now and then to simulate wandering entities. Let''s implement this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本想法与玩家类中的相同。然而，这次敌人类需要指定它自己的`Update`方法版本。它还有两个私有数据成员，其中一个是一个目标向量。这是一个非常简单的尝试，为游戏添加基本的人工智能。它只会跟踪一个目标位置，而`Update`方法会不时随机化这个位置以模拟游荡的实体。让我们来实现它：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The constructor simply initializes a few data members to their default values,
    while the destructor remains unused. So far, so good!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是将一些数据成员初始化为其默认值，而析构函数仍然未使用。到目前为止，一切顺利！
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The entity collision method is fairly similar as well, except this time we make
    sure to act if the enemy's bounding box is colliding with another entity, not
    its attack region. Also, we ignore every single collision, unless it's colliding
    with a player entity, in which case the enemy's state is set to `Attacking` in
    order to display the attack animation. It inflicts damage of *1* point to the
    player and knocks them back just a little bit based on where the entity is. The
    sprite-sheet direction is also set based on the position of the enemy entity relative
    to what it's attacking.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实体碰撞方法也非常相似，但这次我们确保只有在敌人的边界框与另一个实体碰撞时才采取行动，而不是它的攻击区域。此外，我们忽略每一次碰撞，除非它与玩家实体碰撞，在这种情况下，敌人的状态被设置为`Attacking`以显示攻击动画。它对玩家造成*1*点的伤害，并根据实体的位置将其击退一小点。精灵图的方向也根据敌人实体相对于其攻击的位置来设置。
- en: 'Now, to update our enemy:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来更新我们的敌人：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Because this depends on the functionality of the `Character` class, we invoke
    its update method first before doing anything. Then the most basic simulation
    of A.I. begins by first checking if the entity has a destination. If it does not,
    a random number is generated between 1 and 1000\. It has a 1/1000 chance to have
    its destination set to be anywhere within 128 pixels of its current position.
    The direction is decided by another random number generation, except much smaller
    this time. The destination finally is set and gets checked for being outside the
    world boundaries.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这依赖于`Character`类的功能，我们在做任何事情之前首先调用它的更新方法。然后，最基础的AI模拟首先检查实体是否有目标。如果没有，则在1到1000之间生成一个随机数。它有1/1000的机会将其目标位置设置为当前位置128像素内的任何地方。方向由另一个随机数生成决定，但这次要小得多。目标最终被设置并检查是否超出世界边界。
- en: If, on the other hand, the entity does have a destination, the distance between
    it and its current position is checked. If it is above 16, the appropriate method
    for moving in a specific direction is called, based on which direction the destination
    point is in. We must also check for horizontal collisions, because an enemy entity
    could easily be assigned a destination that's beyond a tile it cannot cross. If
    that happens, the destination is simply taken away.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果实体确实有一个目标，则检查它与当前位置之间的距离。如果它大于16，则根据目标点所在的方向调用适当的移动方法。我们还必须检查水平碰撞，因为敌人实体可能会被分配一个它无法跨越的瓦片之外的目标。如果发生这种情况，目标就会被简单地移除。
- en: With that done, we now have wandering entities and a player that can be moved
    around the world! The only thing left to do in order to actually bring these entities
    into the game now is to load them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在有了游荡的实体和可以在世界中移动的玩家！现在要真正将这些实体引入游戏，唯一剩下的事情就是加载它们。
- en: Loading entities from the map file
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从地图文件加载实体
- en: 'If you recall from the section of this chapter that dealt with the issue of
    creating a map class, we haven''t finished implementing the loading method fully,
    because we had no entities yet. With that no longer being the case, let''s take
    a look at extending it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得本章中关于创建地图类的问题部分，我们还没有完全实现加载方法，因为我们当时还没有实体。既然这种情况已经不再存在，让我们来看看如何扩展它：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If the map encounters a `PLAYER` line, it simply attempts to add an entity of
    type `Player` and grabs its ID. If it's above or equal to 0, the entity creation
    was successful, meaning that we can read in the rest of the data from the map
    file, which happens to be the player position. After obtaining it, we set the
    player's position and make sure we keep track of the starting position in the
    map class itself too.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图遇到`PLAYER`行，它将尝试添加一个类型为`Player`的实体并获取其ID。如果它大于或等于0，则实体创建成功，这意味着我们可以从地图文件中读取其余的数据，这恰好是玩家位置。获取后，我们设置玩家的位置并确保在地图类本身中也跟踪起始位置。
- en: All of the above is true for the `ENEMY` line as well, except it also loads
    in the name of the entity, which is needed in order to load its character information
    from the file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述内容对于`ENEMY`行也是正确的，只是它还加载了实体的名称，这是从文件中加载其角色信息所必需的。
- en: 'Now our game is capable of loading entities from the map files and thus putting
    them into the game world like so:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏能够从地图文件中加载实体并将它们放入游戏世界，如下所示：
- en: '![Loading entities from the map file](img/B04284_07_09.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![从地图文件加载实体](img/B04284_07_09.jpg)'
- en: Final editions to our code base
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对代码库的最终修订
- en: In this last portion of the chapter, we will be covering small changes and additions/editions
    that have been made all over the code written in the previous chapters in order
    to make this possible, starting with the shared context, which is now moved into
    its own header file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将介绍为了实现这一点而做出的所有小改动和添加/修订，从共享上下文开始，现在它已经移动到了自己的头文件中。
- en: Changes to the shared context
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享上下文的变化
- en: 'Out of all of the extra classes we defined, some of them need to be accessible
    to the rest of the code-base. This is what the shared context structure looks
    like now:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义的所有额外类中，其中一些需要可供代码库的其余部分访问。这就是现在共享上下文结构的样子：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The last object in it is the debug overlay we briefly discussed while working
    on the base entity class, which helps us see what's going on in our game by providing
    overlay graphics for tiles that entities collide with, warp tiles, and spike tiles,
    giving us the visual representations of entity bounding boxes and so on. Because
    the debug code was not essential to this chapter, snippets of it did not get included
    here, but they're present in the code that comes with it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的最后一个对象是我们之前在处理基础实体类时简要讨论的调试覆盖层，它通过为实体碰撞的瓦片、扭曲瓦片和尖刺瓦片提供覆盖图形，帮助我们通过实体边界框等的视觉表示来查看游戏中的情况。由于调试代码对于本章不是必需的，因此没有将其片段包含在这里，但它们存在于附带的代码中。
- en: Putting all the pieces together
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有部件组合在一起
- en: 'Next, we need to put instances of the code we worked so hard on in the right
    places, starting with the entity manager class, which goes straight into the game
    class as a data member:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们辛苦工作的代码实例放在正确的位置，首先是实体管理器类，它直接作为数据成员进入游戏类：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The map class instance is kept around in the game state class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 地图类实例保留在游戏状态类中：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The main game state is also responsible for setting up its own view and zooming
    in just enough to make the game look more appealing and less prone to cause squinting,
    not to mention initializing and loading the map:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 主游戏状态还负责设置自己的视图并放大到足以使游戏看起来更有吸引力且不太可能导致眯眼，更不用说初始化和加载地图：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Because the map is dynamically allocated, it must be deleted in the `OnDestroy`
    method of the game state:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地图是动态分配的，必须在游戏状态的`OnDestroy`方法中删除它：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now onto the final piece of this puzzle – the game state update method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是拼图中最后一块——游戏状态更新方法：
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: First, we determine if the player is still alive in the game by searching for
    them by name. If the player isn't found, they must've died, so a re-spawn is in
    order. A new player entity is created and the starting coordinates of the map
    are passed to its `SetPosition` method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过按名称搜索玩家来确定玩家是否仍然存活于游戏中。如果找不到玩家，他们肯定已经死亡，因此需要重生。创建一个新的玩家实体并将地图的起始坐标传递给其`SetPosition`方法。
- en: Now comes the part where we manage how the view is scrolling. If the player
    entity exists, we set the view's centre to match the exact player position and
    use the shared context to obtain the render window, which will be using the updated
    view. Now, we have an issue of the screen leaving the boundaries of the map, which
    can be resolved by checking the top-left corner of the view space. If it's below
    or equal to zero, we set the view's centre on the x axis to a position that would
    put its top-left corner at the very edge of the screen, in order to prevent scrolling
    infinitely to the left. If, however, the view is outside of the map in the opposite
    direction, the view centre's x coordinate is set up so that the right side of
    it is also at the very edge of the map's boundaries.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是管理视图滚动方式的部分。如果玩家实体存在，我们将视图的中心设置为与玩家位置完全匹配，并使用共享上下文获取渲染窗口，该窗口将使用更新的视图。现在，我们遇到了屏幕离开地图边界的问题，这可以通过检查视图空间左上角来解决。如果它低于或等于零，我们将视图中心的x轴位置设置为将其左上角放置在屏幕边缘的位置，以防止无限地向左滚动。然而，如果视图在地图的相反方向外，视图中心的x坐标被设置为使其右侧也位于地图边界的最边缘。
- en: Finally, the game map, along with the entity manager, is updated right here,
    because we don't want the map updating or entities moving around if the current
    state is different.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，游戏地图以及实体管理器在这里进行了更新，因为我们不希望地图更新或实体移动，如果当前状态不同的话。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on making it past the halfway point of this book! All of the
    code that was written, the design decisions, accounting for efficiency, and trial
    and error has brought you to this point. While the game we built is fairly basic,
    its architecture is also quite robust and expandable, and that is no small feat.
    Although some things in it may not be perfect, you have also followed the golden
    rule of getting it working first, before refining it, and now you have quite a
    few game design patterns under your belt to start building more complex game applications,
    as well as a solid code-base to expand and improve.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了本书的一半！所有编写的代码、设计决策、考虑效率以及反复试验都把你带到了这个阶段。虽然我们构建的游戏相当基础，但其架构也非常稳健和可扩展，这可不是一件小事。尽管其中的一些事情可能并不完美，但你也已经遵循了先让它工作起来，然后再进行优化的黄金法则，现在你已经有了一些游戏设计模式，可以开始构建更复杂的应用程序，以及一个坚实的代码库来扩展和改进。
- en: 'With the conclusion of this chapter, the second project of the book is officially
    finished. We have solved some quite tricky problems, written thousands of lines
    of code, and broadened our understanding of the game development process beyond
    the stages of myopic, callow naïveté, but the real adventure is still ahead of
    us. We may not know where it will ultimately lead us, but one thing is for sure:
    now is not a time to stop. See you in the next chapter.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，本书的第二个项目正式完成。我们解决了一些相当棘手的问题，编写了数千行代码，并将我们对游戏开发过程的理解扩展到了狭隘、幼稚的幻想阶段之外。但真正的冒险还在前方等着我们。我们可能不知道它最终会引导我们走向何方，但有一点是肯定的：现在绝不是停下脚步的时候。下一章见。
