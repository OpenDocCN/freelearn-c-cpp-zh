["```cpp\nVkSamplerCreateInfo sampler_create_info = { \n  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, \n  nullptr, \n  0, \n  mag_filter, \n  min_filter, \n  mipmap_mode, \n  u_address_mode, \n  v_address_mode, \n  w_address_mode, \n  lod_bias, \n  anisotropy_enable, \n  max_anisotropy, \n  compare_enable, \n  compare_operator, \n  min_lod, \n  max_lod, \n  border_color, \n  unnormalized_coords \n};\n\n```", "```cpp\nVkResult result = vkCreateSampler( logical_device, &sampler_create_info, nullptr, &sampler ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create sampler.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n) uniform sampler <variable name>;\n\n```", "```cpp\nVkFormatProperties format_properties; \nvkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties ); \nif( !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) ) { \n  std::cout << \"Provided format is not supported for a sampled image.\" << std::endl; \n  return false; \n} \nif( linear_filtering && \n    !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) ) { \n  std::cout << \"Provided format is not supported for a linear image filtering.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( !CreateImage( logical_device, type, format, size, num_mipmaps, num_layers, VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_SAMPLED_BIT, false, sampled_image ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, sampled_image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !CreateImageView( logical_device, sampled_image, view_type, format, aspect, sampled_image_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n) uniform texture2D <variable name>;\n\n```", "```cpp\nif( !CreateSampler( logical_device, mag_filter, min_filter, mipmap_mode, u_address_mode, v_address_mode, w_address_mode, lod_bias, anisotropy_enable, max_anisotropy, compare_enable, compare_operator, min_lod, max_lod, border_color, unnormalized_coords, sampler ) ) { \n  return false; \n} \n\nbool linear_filtering = (mag_filter == VK_FILTER_LINEAR) || (min_filter == VK_FILTER_LINEAR) || (mipmap_mode == VK_SAMPLER_MIPMAP_MODE_LINEAR); \nif( !CreateSampledImage( physical_device, logical_device, type, format, size, num_mipmaps, num_layers, usage, view_type, aspect, linear_filtering, sampled_image, sampled_image_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n) uniform sampler2D <variable name>;\n\n```", "```cpp\nVkFormatProperties format_properties; \nvkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties ); \nif( !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT) ) { \n  std::cout << \"Provided format is not supported for a storage image.\" << std::endl; \n  return false; \n} \nif( atomic_operations && \n    !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT) ) { \n  std::cout << \"Provided format is not supported for atomic operations on storage images.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( !CreateImage( logical_device, type, format, size, num_mipmaps, num_layers, VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_STORAGE_BIT, false, storage_image ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, storage_image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !CreateImageView( logical_device, storage_image, view_type, format, aspect, storage_image_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n, r32f) uniform image2D <variable name>;\n\n```", "```cpp\nVkFormatProperties format_properties; \nvkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties ); \nif( !(format_properties.bufferFeatures & VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT) ) { \n  std::cout << \"Provided format is not supported for a uniform texel buffer.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( !CreateBuffer( logical_device, size, usage | VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, uniform_texel_buffer ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, uniform_texel_buffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !CreateBufferView( logical_device, uniform_texel_buffer, format, 0, VK_WHOLE_SIZE, uniform_texel_buffer_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n) uniform samplerBuffer <variable name>;\n\n```", "```cpp\nVkFormatProperties format_properties; \nvkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties ); \nif( !(format_properties.bufferFeatures & VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT) ) { \n  std::cout << \"Provided format is not supported for a uniform texel buffer.\" << std::endl; \n  return false; \n} \n\nif( atomic_operations && \n    !(format_properties.bufferFeatures & VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT) ) { \n  std::cout << \"Provided format is not supported for atomic operations on storage texel buffers.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( !CreateBuffer( logical_device, size, usage | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, storage_texel_buffer ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, storage_texel_buffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !CreateBufferView( logical_device, storage_texel_buffer, format, 0, VK_WHOLE_SIZE, storage_texel_buffer_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n, r32f) uniform imageBuffer <variable name>;\n\n```", "```cpp\nif( !CreateBuffer( logical_device, size, usage | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, uniform_buffer ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, uniform_buffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (set=m, binding=n) uniform <variable name> \n{ \n  vec4 <member 1 name>; \n  mat4 <member 2 name>; \n  // ... \n};\n\n```", "```cpp\nlayout (set=m, binding=n) buffer <variable name> \n{ \n  vec4 <member 1 name>; \n  mat4 <member 2 name>; \n  // ... \n};\n\n```", "```cpp\nVkFormatProperties format_properties; \nvkGetPhysicalDeviceFormatProperties( physical_device, format, &format_properties ); \nif( (aspect & VK_IMAGE_ASPECT_COLOR_BIT) && \n    !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) ) { \n  std::cout << \"Provided format is not supported for an input attachment.\" << std::endl; \n  return false; \n} \nif( (aspect & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_DEPTH_BIT)) && \n  !(format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) ) { \n  std::cout << \"Provided format is not supported for an input attachment.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( !CreateImage( logical_device, type, format, size, 1, 1, VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, false, input_attachment ) ) { \n  return false; \n} \n\nif( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, input_attachment, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { \n  return false; \n} \n\nif( !CreateImageView( logical_device, input_attachment, view_type, format, aspect, input_attachment_image_view ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nlayout (input_attachment_index=i, set=m, binding=n) uniform subpassInput <variable name>;\n\n```", "```cpp\nlayout (set=m, binding=n) // variable definition\n\n```", "```cpp\nVkDescriptorSetLayoutCreateInfo descriptor_set_layout_create_info = { \n  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(bindings.size()), \n  bindings.data() \n};\n\n```", "```cpp\nVkResult result = vkCreateDescriptorSetLayout( logical_device, &descriptor_set_layout_create_info, nullptr, &descriptor_set_layout ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a layout for descriptor sets.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkDescriptorPoolCreateInfo descriptor_pool_create_info = { \n  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, \n  nullptr, \n  free_individual_sets ? \n    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT : 0, \n  max_sets_count, \n  static_cast<uint32_t>(descriptor_types.size()), \n  descriptor_types.data() \n};\n\n```", "```cpp\nVkResult result = vkCreateDescriptorPool( logical_device, &descriptor_pool_create_info, nullptr, &descriptor_pool ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a descriptor pool.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkDescriptorSetAllocateInfo descriptor_set_allocate_info = { \n  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, \n  nullptr, \n  descriptor_pool, \n  static_cast<uint32_t>(descriptor_set_layouts.size()), \n  descriptor_set_layouts.data() \n};\n\n```", "```cpp\ndescriptor_sets.resize( descriptor_set_layouts.size() ); \n\nVkResult result = vkAllocateDescriptorSets( logical_device, &descriptor_set_allocate_info, descriptor_sets.data() ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not allocate descriptor sets.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct ImageDescriptorInfo { \n  VkDescriptorSet                     TargetDescriptorSet; \n  uint32_t                            TargetDescriptorBinding; \n  uint32_t                            TargetArrayElement; \n  VkDescriptorType                    TargetDescriptorType; \n  std::vector<VkDescriptorImageInfo>  ImageInfos; \n};\n\n```", "```cpp\nstruct BufferDescriptorInfo { \n  VkDescriptorSet                     TargetDescriptorSet; \n  uint32_t                            TargetDescriptorBinding; \n  uint32_t                            TargetArrayElement; \n  VkDescriptorType                    TargetDescriptorType; \n  std::vector<VkDescriptorBufferInfo> BufferInfos; \n};\n\n```", "```cpp\nstruct TexelBufferDescriptorInfo { \n  VkDescriptorSet                     TargetDescriptorSet; \n  uint32_t                            TargetDescriptorBinding; \n  uint32_t                            TargetArrayElement; \n  VkDescriptorType                    TargetDescriptorType; \n  std::vector<VkBufferView>           TexelBufferViews; \n};\n\n```", "```cpp\nstruct CopyDescriptorInfo { \n  VkDescriptorSet     TargetDescriptorSet; \n  uint32_t            TargetDescriptorBinding; \n  uint32_t            TargetArrayElement; \n  VkDescriptorSet     SourceDescriptorSet; \n  uint32_t            SourceDescriptorBinding; \n  uint32_t            SourceArrayElement; \n  uint32_t            DescriptorCount; \n};\n\n```", "```cpp\nstd::vector<VkWriteDescriptorSet> write_descriptors; \n\nfor( auto & image_descriptor : image_descriptor_infos ) { \n  write_descriptors.push_back( { \n    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, \n    nullptr, \n    image_descriptor.TargetDescriptorSet, \n    image_descriptor.TargetDescriptorBinding, \n    image_descriptor.TargetArrayElement, \n    static_cast<uint32_t>(image_descriptor.ImageInfos.size()), \n    image_descriptor.TargetDescriptorType, \n    image_descriptor.ImageInfos.data(), \n    nullptr, \n    nullptr \n  } ); \n} \n\nfor( auto & buffer_descriptor : buffer_descriptor_infos ) { \n  write_descriptors.push_back( { \n    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, \n    nullptr, \n    buffer_descriptor.TargetDescriptorSet, \n    buffer_descriptor.TargetDescriptorBinding, \n    buffer_descriptor.TargetArrayElement, \n    static_cast<uint32_t>(buffer_descriptor.BufferInfos.size()), \n    buffer_descriptor.TargetDescriptorType, \n    nullptr, \n    buffer_descriptor.BufferInfos.data(), \n    nullptr \n  } ); \n} \n\nfor( auto & texel_buffer_descriptor : texel_buffer_descriptor_infos ) { \n  write_descriptors.push_back( { \n    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, \n    nullptr, \n    texel_buffer_descriptor.TargetDescriptorSet, \n    texel_buffer_descriptor.TargetDescriptorBinding, \n    texel_buffer_descriptor.TargetArrayElement, \n    static_cast<uint32_t>(texel_buffer_descriptor.TexelBufferViews.size()), \n    texel_buffer_descriptor.TargetDescriptorType, \n    nullptr, \n    nullptr, \n    texel_buffer_descriptor.TexelBufferViews.data() \n  } ); \n}\n\n```", "```cpp\nstd::vector<VkCopyDescriptorSet> copy_descriptors; \n\nfor( auto & copy_descriptor : copy_descriptor_infos ) { \n  copy_descriptors.push_back( { \n    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, \n    nullptr, \n    copy_descriptor.SourceDescriptorSet, \n    copy_descriptor.SourceDescriptorBinding, \n    copy_descriptor.SourceArrayElement, \n    copy_descriptor.TargetDescriptorSet, \n    copy_descriptor.TargetDescriptorBinding, \n    copy_descriptor.TargetArrayElement, \n    copy_descriptor.DescriptorCount \n  } ); \n}\n\n```", "```cpp\nvkUpdateDescriptorSets( logical_device, static_cast<uint32_t>(write_descriptors.size()), write_descriptors.data(), static_cast<uint32_t>(copy_descriptors.size()), copy_descriptors.data() );\n\n```", "```cpp\n      vkCmdBindDescriptorSets( command_buffer, pipeline_type, \n      pipeline_layout, index_for_first_set, static_cast<uint32_t>\n      (descriptor_sets.size()), descriptor_sets.data(), \n      static_cast<uint32_t>(dynamic_offsets.size()), \n      dynamic_offsets.data() )\n\n```", "```cpp\nvkCmdBindDescriptorSets( command_buffer, pipeline_type, pipeline_layout, index_for_first_set, static_cast<uint32_t>(descriptor_sets.size()), descriptor_sets.data(), static_cast<uint32_t>(dynamic_offsets.size()), dynamic_offsets.data() )\n\n```", "```cpp\nif( !CreateCombinedImageSampler( physical_device, logical_device, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, sampled_image_size, 1, 1, VK_IMAGE_USAGE_TRANSFER_DST_BIT, \n  VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR, VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_REPEAT, \n  VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 0.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, false, \n  sampler, sampled_image, sampled_image_memory_object, sampled_image_view ) ) { \n  return false; \n} \n\nif( !CreateUniformBuffer( physical_device, logical_device, uniform_buffer_size, VK_BUFFER_USAGE_TRANSFER_DST_BIT, uniform_buffer, uniform_buffer_memory_object ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nif( !CreateDescriptorSetLayout( logical_device, bindings, descriptor_set_layout ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorPoolSize> descriptor_types = { \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  } \n}; \nif( !CreateDescriptorPool( logical_device, false, 1, descriptor_types, descriptor_pool ) ) { \n  return false; \n} \n\nif( !AllocateDescriptorSets( logical_device, descriptor_pool, { descriptor_set_layout }, descriptor_sets ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<ImageDescriptorInfo> image_descriptor_infos = { \n  { \n    descriptor_sets[0], \n    0, \n    0, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    { \n      { \n        sampler, \n        sampled_image_view, \n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n      } \n    } \n  } \n}; \n\nstd::vector<BufferDescriptorInfo> buffer_descriptor_infos = { \n  { \n    descriptor_sets[0], \n    1, \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    { \n      { \n        uniform_buffer, \n        0, \n        VK_WHOLE_SIZE \n      } \n    } \n  } \n}; \n\nUpdateDescriptorSets( logical_device, image_descriptor_infos, buffer_descriptor_infos, {}, {} ); \nreturn true;\n\n```", "```cpp\nVkResult result = vkFreeDescriptorSets( logical_device, descriptor_pool, static_cast<uint32_t>(descriptor_sets.size()), descriptor_sets.data() ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during freeing descriptor sets.\" << std::endl; \n  return false; \n} \n\ndescriptor_sets.clear(); \nreturn true;\n\n```", "```cpp\nVkResult result = vkResetDescriptorPool( logical_device, descriptor_pool, 0 ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during descriptor pool reset.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( VK_NULL_HANDLE != descriptor_pool ) { \n  vkDestroyDescriptorPool( logical_device, descriptor_pool, nullptr ); \n  descriptor_pool = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != descriptor_set_layout ) { \n  vkDestroyDescriptorSetLayout( logical_device, descriptor_set_layout, nullptr ); \n  descriptor_set_layout = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != sampler ) { \n  vkDestroySampler( logical_device, sampler, nullptr ); \n  sampler = VK_NULL_HANDLE; \n}\n\n```"]