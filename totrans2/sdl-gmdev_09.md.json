["```cpp\nclass CollisionManager\n{\npublic:\n\n  void checkPlayerEnemyCollision(Player* pPlayer, const \n  std::vector<GameObject*>&objects);\n};\n```", "```cpp\nstd::vector<TileLayer*>* m_pCollisionLayers;\n```", "```cpp\nvoid setCollisionLayers(std::vector<TileLayer*>* layers) { m_pCollisionLayers = layers; }\n```", "```cpp\npLevel->getPlayer()->setCollisionLayers(pLevel->getCollisionLayers());\n```", "```cpp\n// load the object\npGameObject->load(std::unique_ptr<LoaderParams>(new LoaderParams(x, y, width, height, textureID, numFrames,callbackID, animSpeed)));\n// set the collision layers\npGameObject->setCollisionLayers(pLevel->getCollisionLayers());\n```", "```cpp\nclass PlatformerObject : public GameObject\n{\npublic:\n\n  virtual ~PlatformerObject() {}\n\n  virtual void load(std::unique_ptr<LoaderParams> const &pParams);\n\n  virtual void draw();\n  virtual void update();\n\n  virtual void clean() {}\n  virtual void collision() {}\n\n  virtual std::string type() { return \"SDLGameObject\"; }\n\nprotected:\n\n  PlatformerObject();\n\n  bool checkCollideTile(Vector2D newPos);\n\n  void doDyingAnimation();\n\n  int m_bulletFiringSpeed;\n  int m_bulletCounter;\n  int m_moveSpeed;\n\n  // how long the death animation takes, along with a counter\n  int m_dyingTime;\n  int m_dyingCounter;\n\n  // has the explosion sound played?\n  bool m_bPlayedDeathSound;\n\n  bool m_bFlipped;\n\n  bool m_bMoveLeft;\n  bool m_bMoveRight;\n  bool m_bRunning;\n\n  bool m_bFalling;\n  bool m_bJumping;\n  bool m_bCanJump;\n\n  Vector2D m_lastSafePos;\n\n  int m_jumpHeight;\n};\n```", "```cpp\nbool PlatformerObject::checkCollideTile(Vector2D newPos)\n{\n  if(newPos.m_y + m_height>= TheGame::Instance()->getGameHeight() \n  - 32)\n  {\n    return false;\n  }\n  else\n  {\n    for(std::vector<TileLayer*>::iterator it = m_pCollisionLayers\n    ->begin(); it != m_pCollisionLayers->end(); ++it)\n    {\n      TileLayer* pTileLayer = (*it);\n      std::vector<std::vector<int>> tiles = pTileLayer\n      ->getTileIDs();\n\n      Vector2D layerPos = pTileLayer->getPosition();\n\n      int x, y, tileColumn, tileRow, tileid = 0;\n\n      x = layerPos.getX() / pTileLayer->getTileSize();\n      y = layerPos.getY() / pTileLayer->getTileSize();\n\n      Vector2D startPos = newPos;\n      startPos.m_x += 15;\n      startPos.m_y += 20;\n      Vector2D endPos(newPos.m_x + (m_width - 15), (newPos.m_y) + \n      m_height - 4);\n\n      for(int i = startPos.m_x; i < endPos.m_x; i++)\n      {\n        for(int j = startPos.m_y; j < endPos.m_y; j++)\n        {\n          tileColumn = i / pTileLayer->getTileSize();\n          tileRow = j / pTileLayer->getTileSize();\n\n          tileid = tiles[tileRow + y][tileColumn + x];\n\n          if(tileid != 0)\n          {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false; \n  }\n}\n```", "```cpp\nif(newPos.m_y + m_height >= TheGame::Instance()->getGameHeight() - 32)\n{\n  return false;\n}\n```", "```cpp\ntileid = tiles[tileRow + y][tileColumn + x];\n```", "```cpp\nclass Camera\n{\npublic:\n\n  static Camera* Instance()\n  {\n    if(s_pCamera == 0)\n    {\n      s_pCamera = new Camera();\n    }\n\n    return s_pCamera;\n  }\n\n  void update(Vector2D velocity);\n\n  void setTarget(Vector2D* target) { m_pTarget = target; }\n  void setPosition(const Vector2D& position) { m_position = \n  position; }\n\n  const Vector2D getPosition() const;\n\nprivate:\n\n  Camera();\n  ~Camera();\n\n  // the camera's target\n  Vector2D* m_pTarget;\n\n  // the camera's position\n  Vector2D m_position;\n\n  static Camera* s_pCamera;\n};\n\ntypedef Camera TheCamera;\n```", "```cpp\nconst Vector2DCamera::getPosition() const\n{\n{\n  if(m_pTarget != 0)\n  {\n    Vector2D pos(m_pTarget->m_x - (TheGame::Instance()\n    ->getGameWidth() / 2), 0);\n\n    if(pos.m_x< 0)\n    {\n      pos.m_x = 0;\n    }\n\n    return pos;\n  }\n\n  return m_position;\n}\n```", "```cpp\nTileLayer(int tileSize, int mapWidth, int mapHeight, const std::vector<Tileset>& tilesets);\n```", "```cpp\nvoid LevelParser::parseTileLayer(TiXmlElement* pTileElement, std::vector<Layer*> *pLayers, const std::vector<Tileset>* pTilesets, std::vector<TileLayer*> *pCollisionLayers)\n{\nTileLayer* pTileLayer = new TileLayer(m_tileSize, m_width, m_height, *pTilesets);\n```", "```cpp\nTileLayer::TileLayer(int tileSize, int mapWidth, int mapHeight, const std::vector<Tileset>& tilesets) : m_tileSize(tileSize), m_tilesets(tilesets), m_position(0,0), m_velocity(0,0)\n{\n  m_numColumns = mapWidth;\n  m_numRows = mapHeight;\n\n  m_mapWidth = mapWidth;\n}\n```", "```cpp\nvoid TileLayer::render()\n{\n  int x, y, x2, y2 = 0;\n\n  x = m_position.getX() / m_tileSize;\n  y = m_position.getY() / m_tileSize;\n\n  x2 = int(m_position.getX()) % m_tileSize;\n  y2 = int(m_position.getY()) % m_tileSize;\n\n  for(int i = 0; i < m_numRows; i++)\n  {\n    for(int j = 0; j < m_numColumns; j++)\n    {\n      int id = m_tileIDs[i + y][j + x];\n\n      if(id == 0)\n      {\n        continue;\n      }\n\n      // if outside the viewable area then skip the tile\n      if(((j * m_tileSize) - x2) - TheCamera::Instance()\n      ->getPosition().m_x < -m_tileSize || ((j * m_tileSize) - x2) \n      - TheCamera::Instance()->getPosition()\n      .m_x > TheGame::Instance()->getGameWidth())\n      {\n        continue;\n      }\n\n      Tileset tileset = getTilesetByID(id);\n\n      id--;\n\n      // draw the tile into position while offsetting its x \n      position by \n      // subtracting the camera position\n      TheTextureManager::Instance()->drawTile(tileset.name, \n      tileset.margin, tileset.spacing, ((j * m_tileSize) - x2) - \n      TheCamera::Instance()->getPosition().m_x, ((i * m_tileSize) \n      - y2), m_tileSize, m_tileSize, (id - (tileset.firstGridID - \n      1)) / tileset.numColumns, (id - (tileset.firstGridID - 1)) % \n      tileset.numColumns, TheGame::Instance()->getRenderer());\n    }\n  }\n\n```", "```cpp\nvoid Player::update()\n{\n  if(!m_bDying)\n  {\n    // fell off the edge\n    if(m_position.m_y + m_height >= 470)\n    {\n      collision();\n    }\n\n    // get the player input\n    handleInput();\n\n    if(m_bMoveLeft)\n    {\n      if(m_bRunning)\n      {\n        m_velocity.m_x = -5;\n      }\n      else\n      {\n        m_velocity.m_x = -2;\n      }\n    }\n    else if(m_bMoveRight)\n    {\n      if(m_bRunning)\n      {\n        m_velocity.m_x = 5;\n      }\n      else\n      {\n        m_velocity.m_x = 2;\n      }\n    }\n    else\n    {\n      m_velocity.m_x = 0;\n    }\n\n    // if we are higher than the jump height set jumping to false\n    if(m_position.m_y < m_lastSafePos.m_y - m_jumpHeight)\n    {\n      m_bJumping = false;\n    }\n\n    if(!m_bJumping)\n    {\n      m_velocity.m_y = 5;\n    }\n    else\n    {\n      m_velocity.m_y = -5;\n    }\n\n    handleMovement(m_velocity);\n  }\n  else\n  {\n    m_velocity.m_x = 0;\n    if(m_dyingCounter == m_dyingTime)\n    {\n      ressurect();\n    }\n    m_dyingCounter++;\n\n    m_velocity.m_y = 5;\n  }\n  handleAnimation();\n}\n```", "```cpp\nvoid Player::handleMovement(Vector2D velocity)\n{\n  // get the current position\n  Vector2D newPos = m_position;\n\n  // add velocity to the x position\n  newPos.m_x  = m_position.m_x + velocity.m_x;\n\n  // check if the new x position would collide with a tile\n  if(!checkCollideTile(newPos))\n  {\n    // no collision, add to the actual x position\n    m_position.m_x = newPos.m_x;\n  }\n  else\n  {\n    // collision, stop x movement\n    m_velocity.m_x = 0;\n  }\n\n  // get the current position after x movement\n  newPos = m_position;\n\n  // add velocity to y position\n  newPos.m_y += velocity.m_y;\n\n  // check if new y position would collide with a tile\n  if(!checkCollideTile(newPos))\n  {\n    // no collision, add to the actual x position\n    m_position.m_y = newPos.m_y;\n  }\n  else\n  {\n    // collision, stop y movement\n    m_velocity.m_y = 0;\n\n    //  we collided with the map which means we are safe on the \n    ground,\n    //  make this the last safe position\n    m_lastSafePos = m_position;\n\n    // move the safe pos slightly back or forward so when \n    resurrected we are safely on the ground after a fall\n    if(velocity.m_x > 0)\n    {\n      m_lastSafePos.m_x -= 32;\n    }\n    else if(velocity.m_x < 0)\n    {\n      m_lastSafePos.m_x += 32;\n\n    }\n\n    // allow the player to jump again\n    m_bCanJump = true;\n\n    // jumping is now false\n    m_bJumping = false;\n  }\n```", "```cpp\nvoid Player::handleInput()\n{\n  if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_RIGHT) && \n  m_position.m_x < ((*m_pCollisionLayers->begin())->getMapWidth() \n  * 32))\n  {\n    if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_A))\n    {\n      m_bRunning = true;\n    }\n    else\n    {\n      m_bRunning = false;\n    }\n\n    m_bMoveRight = true;\n    m_bMoveLeft = false;\n  }\n  else if(TheInputHandler::Instance()\n  ->isKeyDown(SDL_SCANCODE_LEFT) && m_position.m_x > 32)\n  {\n    if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_A))\n    {\n      m_bRunning = true;\n    }\n    else\n    {\n      m_bRunning = false;\n    }\n\n    m_bMoveRight = false;\n    m_bMoveLeft = true;\n  }\n  else\n  {\n    m_bMoveRight = false;\n    m_bMoveLeft = false;\n  }\n\n  if(TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_SPACE) \n  && m_bCanJump && !m_bPressedJump)\n  {\n    TheSoundManager::Instance()->playSound(\"jump\", 0);\n    if(!m_bPressedJump)\n    {\n      m_bJumping = true;\n      m_bCanJump = false;\n      m_lastSafePos = m_position;\n      m_bPressedJump = true;\n    }\n  }\n\n  if(!TheInputHandler::Instance()->isKeyDown(SDL_SCANCODE_SPACE) \n  && m_bCanJump)\n  {\n    m_bPressedJump = false;\n  }\n}\n```"]