- en: Chapter 2. I/O Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。I/O 操作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Using fixed length I/O buffers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定长度 I/O 缓冲区
- en: Using extensible stream-oriented I/O buffers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可扩展的流式 I/O 缓冲区
- en: Writing to a TCP socket synchronously
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步写入 TCP 套接字
- en: Reading from a TCP socket synchronously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步从 TCP 套接字读取
- en: Writing to a TCP socket asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步写入 TCP 套接字
- en: Reading from a TCP socket asynchronously
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步从 TCP 套接字读取
- en: Canceling asynchronous operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: Shutting down and closing a socket
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭和断开套接字
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: I/O operations are the key operations in the networking infrastructure of any
    distributed application. They are directly involved in the process of data exchange.
    Input operations are used to receive data from remote applications, whereas output
    operations allow sending data to them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 操作是任何分布式应用程序网络基础设施中的关键操作。它们直接参与数据交换的过程。输入操作用于从远程应用程序接收数据，而输出操作允许向它们发送数据。
- en: In this chapter, we will see several recipes that show how to perform I/O operations
    and other operations related to them. In addition to this, we'll see how to use
    some classes provided by Boost.Asio, which are used in conjunction with I/O operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到几个示例，展示如何执行 I/O 操作以及与之相关的其他操作。此外，我们还将了解如何使用 Boost.Asio 提供的一些类，这些类与
    I/O 操作一起使用。
- en: The following is the short summary and introduction to the topics discussed
    in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对本章讨论的主题的简要总结和介绍。
- en: I/O buffers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 缓冲区
- en: Network programming is all about organizing inter-process communication over
    a computer network. **Communication** in this context implies exchanging data
    between two or more processes. From the perspective of a process that participates
    in such communication, the process performs I/O operations, sending data to and
    receiving it from other participating processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程主要涉及在计算机网络中组织进程间通信。在此上下文中，“通信”意味着在两个或更多进程之间交换数据。从参与此类通信的进程的角度来看，该进程执行 I/O
    操作，向其他参与进程发送数据并从它们那里接收数据。
- en: Like any other type of I/O, the network I/O involves using memory buffers, which
    are contiguous blocks of memory allocated in the process's address space used
    to store the data. When doing any sort of input operation (for example, reading
    some data from a file, a pipe, or a remote computer over the network), the data
    arrives at the process and must be stored somewhere in its address space so that
    it is available for further processing. That is, when the buffer comes in handy.
    Before performing an input operation, the buffer is allocated and then used as
    a data destination point during the operation. When the input operation is completed,
    the buffer contains input data, which can be processed by the application. Likewise,
    before performing the output operation, the data must be prepared and put into
    an output buffer, which is then used in the output operation, where it plays the
    role of the data source.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他类型的 I/O 一样，网络 I/O 涉及使用内存缓冲区，这些缓冲区是在进程的地址空间中分配的连续内存块，用于存储数据。在进行任何类型的输入操作（例如，从文件、管道或通过网络远程计算机读取一些数据）时，数据到达进程，必须在它的地址空间中的某个地方存储，以便它可用于进一步处理。也就是说，当缓冲区派上用场时。在进行输入操作之前，缓冲区被分配，然后在操作期间用作数据目标点。当输入操作完成时，缓冲区包含输入数据，可以被应用程序处理。同样，在进行输出操作之前，数据必须准备并放入输出缓冲区，然后在输出操作中使用，它扮演数据源的角色。
- en: Apparently, the buffers are essential ingredients of any application that performs
    any type of I/O, including the network I/O. That's why it is critical for the
    developer who develops a distributed application to know how to allocate and prepare
    the I/O buffers to use them in the I/O operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，缓冲区是任何执行任何类型 I/O 的应用程序的基本组成部分，包括网络 I/O。这就是为什么对于开发分布式应用程序的开发人员来说，了解如何分配和准备
    I/O 缓冲区以在 I/O 操作中使用它们至关重要。
- en: Synchronous and asynchronous I/O operations
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和异步 I/O 操作
- en: 'Boost.Asio supports two types of I/O operations: synchronous and asynchronous.
    Synchronous operations block the thread of execution invoking them and unblock
    only when the operation is finished. Hence, the name of this type of operation:
    synchronous.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 支持两种类型的 I/O 操作：同步和异步。同步操作阻塞调用它们的执行线程，并且只有在操作完成时才会解除阻塞。因此，这种类型操作的名称是同步。
- en: The second type is an asynchronous operation. When an asynchronous operation
    is initiated, it is associated with a callback function or functor, which is invoked
    by the Boost.Asio library when the operation is finished. These types of I/O operations
    provide great flexibility, but may significantly complicate the code. The initiation
    of the operation is simple and doesn't block the thread of execution, which allows
    us to use the thread to run other tasks, while the asynchronous operation is being
    run in the background.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型是异步操作。当异步操作被启动时，它与一个回调函数或函数对象相关联，当操作完成时，由 Boost.Asio 库调用。这些类型的 I/O 操作提供了极大的灵活性，但可能会显著复杂化代码。操作的启动简单，不会阻塞执行线程，这允许我们在异步操作在后台运行的同时使用线程来运行其他任务。
- en: The Boost.Asio library is implemented as a framework, which exploits an **inversion
    of control** approach. After one or more asynchronous operations are initiated,
    the application hands over one of its threads of execution to the library, and
    the latter uses this thread to run the event loop and invoke the callbacks provided
    by the application to notify it about the completion of the previously initiated
    asynchronous operation. The results of asynchronous operations are passed to the
    callback as arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 库被实现为一个框架，它利用了**控制反转**的方法。在启动一个或多个异步操作之后，应用程序将其执行线程之一交给库，然后库使用此线程来运行事件循环并调用应用程序提供的回调来通知它关于先前启动的异步操作完成的详细信息。异步操作的结果作为参数传递给回调。
- en: Additional operations
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他操作
- en: In addition to this, we are going to consider such operations as canceling asynchronous
    operations, shutting down, and closing a socket.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将考虑取消异步操作、关闭和关闭套接字等操作。
- en: The ability to cancel a previously initiated asynchronous operation is very
    important. It allows the application to state that the previously initiated operation
    is not relevant anymore, which may save the application's resources (both CPU
    and memory), that otherwise (in case, the operation would continue its execution
    even after it was known that nobody is interested in it anymore) would be unavoidably
    wasted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 取消先前启动的异步操作的能力非常重要。它允许应用程序声明先前启动的操作不再相关，这可能会节省应用程序的资源（CPU 和内存），否则（如果操作继续执行，即使已知没有人再对其感兴趣）将不可避免地浪费。
- en: Shutting down the socket is useful if there is a need for one part of the distributed
    application to inform the other part that the whole message has been sent, when
    the application layer protocol does not provide us with other means to indicate
    the message boundary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭套接字在需要分布式应用程序的一部分通知另一部分整个消息已发送时很有用，当应用层协议没有提供其他方法来指示消息边界时。
- en: As with any other operating system resource, a socket should be returned back
    to the operating system when it is not needed anymore by the application. A closing
    operation allows us to do so.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他操作系统资源一样，当应用程序不再需要套接字时，应将其返回给操作系统。关闭操作允许我们这样做。
- en: Using fixed length I/O buffers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用固定长度 I/O 缓冲区
- en: Fixed length I/O buffers are usually used with I/O operations and play the role
    of either a data source or destination when the size of the message to be sent
    or received is known. For example, this can be a constant array of chars allocated
    on a stack, which contain a string that represents the request to be sent to the
    server. Or, this can be a writable buffer allocated in the free memory, which
    is used as a data destination point, when reading data from a socket.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 固定长度的 I/O 缓冲区通常用于 I/O 操作，并在已知要发送或接收的消息大小时扮演数据源或目标的角色。例如，这可以是一个在栈上分配的固定长度的字符数组，其中包含要发送到服务器的请求字符串。或者，这可以是一个在空闲内存中分配的可写缓冲区，用作从套接字读取数据的数据目标点。
- en: In this recipe, we'll see how to represent fixed length buffers so that they
    can be used with Boost.Asio I/O operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何表示固定长度缓冲区，以便它们可以与 Boost.Asio I/O 操作一起使用。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In Boost.Asio, a fixed length buffer is represented by one of the two classes:
    `asio::mutable_buffer` or `asio::const_buffer`. Both these classes represent a
    contiguous block of memory that is specified by the address of the first byte
    of the block and its size in bytes. As the names of these classes suggest, `asio::mutable_buffer`
    represents a writable buffer, whereas `asio::const_buffer` represents a read-only
    one.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost.Asio 中，固定长度的缓冲区由以下两个类之一表示：`asio::mutable_buffer` 或 `asio::const_buffer`。这两个类都表示一个连续的内存块，该内存块由块的第一个字节的地址及其字节大小指定。正如这些类的名称所暗示的，`asio::mutable_buffer`
    表示可写缓冲区，而 `asio::const_buffer` 表示只读缓冲区。
- en: However, neither the `asio::mutable_buffer` nor `asio::const_buffer` classes
    are used in Boost.Asio I/O functions and methods directly. Instead, the `MutableBufferSequence`
    and `ConstBufferSequence` concepts are introduced.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Boost.Asio 的 I/O 函数和方法中，既不直接使用 `asio::mutable_buffer` 也不使用 `asio::const_buffer`
    类。相反，引入了 `MutableBufferSequence` 和 `ConstBufferSequence` 概念。
- en: The `MutableBufferSequence` concept specifies an object that represents a collection
    of the `asio::mutable_buffer` objects. Correspondingly, the `ConstBufferSequence`
    concept specifies an object that represents a collection of the `asio::const_buffer`
    objects. Boost.Asio functions and methods that perform I/O operations accept objects
    that satisfy the requirements of either the `MutableBufferSequence` or `ConstBufferSequence`
    concept as their arguments that represent buffers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableBufferSequence` 概念指定了一个表示 `asio::mutable_buffer` 对象集合的对象。相应地，`ConstBufferSequence`
    概念指定了一个表示 `asio::const_buffer` 对象集合的对象。Boost.Asio 的函数和方法在执行 I/O 操作时接受满足 `MutableBufferSequence`
    或 `ConstBufferSequence` 概念要求的对象作为其参数，以表示缓冲区。'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete specification of the `MutableBufferSequence` and `ConstBufferSequence`
    concepts are available in the Boost.Asio documentation section, which can be found
    at the following links:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableBufferSequence` 和 `ConstBufferSequence` 概念的完整规范可在 Boost.Asio 文档部分找到，该部分可通过以下链接访问：'
- en: Refer to [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html)
    for `MutableBufferSequence`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/MutableBufferSequence.html)
    了解 `MutableBufferSequence`
- en: Refer to [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html)
    for `ConstBufferSequence`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ConstBufferSequence.html)
    了解 `ConstBufferSequence`
- en: Although in most use cases, a single buffer is involved in a single I/O operation,
    in some specific circumstances (for example, in a memory-constrained environment),
    a developer may want to use a composite buffer that comprises multiple smaller
    simple buffers distributed over the process's address space. Boost.Asio I/O functions
    and methods are designed to work with composite buffers that are represented as
    a collection of buffers that fulfill the requirements of either the `MutableBufferSequence`
    or `ConstBufferSequence` concept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数使用情况下，单个 I/O 操作只涉及单个缓冲区，但在某些特定情况下（例如，在内存受限的环境中），开发者可能希望使用由多个较小的简单缓冲区组成的复合缓冲区，这些缓冲区分布在进程的地址空间中。Boost.Asio
    的 I/O 函数和方法旨在与表示为满足 `MutableBufferSequence` 或 `ConstBufferSequence` 概念要求的缓冲区集合的复合缓冲区一起工作。
- en: For instance, an object of the `std::vector<asio::mutable_buffer>` class satisfies
    the requirements of the `MutableBufferSequence` concept, and therefore, it can
    be used to represent a composite buffer in I/O-related functions and methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::vector<asio::mutable_buffer>` 类的对象满足 `MutableBufferSequence` 概念的要求，因此它可以用于在
    I/O 相关函数和方法中表示复合缓冲区。
- en: So, now we know that if we have a buffer that is represented as an object of
    the `asio::mutable_buffer` or `asio::const_buffer` class, we still can't use it
    with I/O-related functions or methods provided by Boost.Asio. The buffer must
    be represented as an object, satisfying the requirements of either the `MutableBufferSequence`
    or `ConstBufferSequence` concept, respectively. To do this, we for example could
    create a collection of buffer objects consisting of a single buffer by instantiating
    an object of the `std::vector<asio::mutable_buffer>` class and placing our buffer
    object into it. Now that the buffer is part of the collection, satisfying the
    `MutableBufferSequence` requirements can be used in I/O operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道，如果我们有一个表示为 `asio::mutable_buffer` 或 `asio::const_buffer` 类对象的缓冲区，我们仍然不能使用
    Boost.Asio 提供的与 I/O 相关的函数或方法。缓冲区必须表示为一个对象，满足 `MutableBufferSequence` 或 `ConstBufferSequence`
    概念的要求。为此，例如，我们可以通过实例化 `std::vector<asio::mutable_buffer>` 类的对象并将我们的缓冲区对象放入其中来创建一个由单个缓冲区组成的缓冲区对象集合。现在，缓冲区成为集合的一部分，满足
    `MutableBufferSequence` 要求可以在 I/O 操作中使用。
- en: However, although this method is fine to create composite buffers consisting
    of two or more simple buffers, it looks overly complex when it comes to such simple
    tasks as representing a single simple buffer so that it can be used with Boost.Asio
    I/O functions or methods. Fortunately, Boost.Asio provides us with a way to simplify
    the usage of single buffers with I/O-related functions and methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这种方法可以很好地创建由两个或更多简单缓冲区组成的复合缓冲区，但在处理像表示单个简单缓冲区这样的简单任务时，它看起来过于复杂，以便可以使用 Boost.Asio
    I/O 函数或方法。幸运的是，Boost.Asio 为我们提供了一种简化单个缓冲区与 I/O 相关函数和方法使用的方法。
- en: The `asio::buffer()` free function has 28 overloads that accept a variety of
    representations of a buffer and return an object of either the `asio::mutable_buffers_1`
    or `asio::const_buffers_1` classes. If the buffer argument passed to the `asio::buffer()`
    function is a read-only type, the function returns an object of the `asio::const_buffers_1`
    class; otherwise, an object of the `asio::mutable_buffers_1` class is returned.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::buffer()` 自由函数有 28 个重载，接受各种缓冲区表示形式，并返回 `asio::mutable_buffers_1` 或 `asio::const_buffers_1`
    类的对象。如果传递给 `asio::buffer()` 函数的缓冲区参数是只读类型，则函数返回 `asio::const_buffers_1` 类的对象；否则，返回
    `asio::mutable_buffers_1` 类的对象。'
- en: The `asio::mutable_buffers_1` and `asio::const_buffers_1` classes are *adapters*
    of the `asio::mutable_buffer` and `asio::const_buffer` classes, respectively.
    They provide an interface and behavior that satisfy the requirements of the `MutableBufferSequence`
    and `ConstBufferSequence` concepts, which allows us to pass these adapters as
    arguments to Boost.Asio I/O functions and methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::mutable_buffers_1` 和 `asio::const_buffers_1` 类分别是 `asio::mutable_buffer`
    和 `asio::const_buffer` 类的适配器。它们提供了一个满足 `MutableBufferSequence` 和 `ConstBufferSequence`
    概念要求的接口和行为，这使得我们可以将这些适配器作为参数传递给 Boost.Asio I/O 函数和方法。'
- en: Let's consider two algorithms and corresponding code samples that describe how
    to prepare a memory buffer that can be used with Boost.Asio I/O operations. The
    first algorithm deals with buffers intended to be used for an output operation
    and the second one is used for an input operation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个算法和相应的代码示例，描述了如何准备一个内存缓冲区，该缓冲区可以用于 Boost.Asio I/O 操作。第一个算法处理用于输出操作的缓冲区，第二个算法用于输入操作。
- en: Preparing a buffer for an output operation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备缓冲区以进行输出操作
- en: 'The following algorithm and corresponding code sample describes how to prepare
    a buffer that can be used with the Boost.Asio socket''s method that performs an
    output operation such as `asio::ip::tcp::socket::send()` or the `asio::write()`free
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法和相应的代码示例描述了如何准备一个可以用于执行输出操作（如 `asio::ip::tcp::socket::send()` 或 `asio::write()`
    自由函数）的 Boost.Asio 套接字方法的缓冲区：
- en: Allocate a buffer. Note that this step does not involve any functionality or
    data types from Boost.Asio.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个缓冲区。请注意，此步骤不涉及任何来自 Boost.Asio 的功能或数据类型。
- en: Fill the buffer with the data that is to be used as the output.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用要作为输出使用的数据填充缓冲区。
- en: Represent the buffer as an object that satisfies the `ConstBufferSequence` concept's
    requirements.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓冲区表示为一个满足 `ConstBufferSequence` 概念要求的对象。
- en: The buffer is ready to be used with Boost.Asio output methods and functions.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区已准备好与 Boost.Asio 输出方法和函数一起使用。
- en: 'Let''s say we want to send a string `Hello` to the remote application. Before
    we send the data using Boost.Asio, we need to properly represent the buffer. This
    is how we do this in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想向远程应用程序发送字符串 `Hello`。在我们使用 Boost.Asio 发送数据之前，我们需要正确地表示缓冲区。以下是如何在以下代码中做到这一点的示例：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Preparing a buffer for an input operation
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备输入操作的缓冲区
- en: 'The following algorithm and corresponding code sample describes how to prepare
    the buffer that can be used with the Boost.Asios socket''s method that performs
    an input operation such as `asio::ip::tcp::socket::receive()` or the `asio::read()`free
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法和相应的代码示例描述了如何准备可以用于执行输入操作（如 `asio::ip::tcp::socket::receive()` 或 `asio::read()`
    自由函数）的 Boost.Asio 套接字方法的缓冲区：
- en: Allocate a buffer. The size of the buffer must be big enough to fit the block
    of data to be received. Note that this step does not involve any functionalities
    or data types from Boost.Asio.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个缓冲区。缓冲区的大小必须足够大，以便容纳要接收的数据块。请注意，这一步不涉及任何来自 Boost.Asio 的功能或数据类型。
- en: Represent the buffer using an object that satisfies the `MutableBufferSequence`
    concept's requirements.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用满足 `MutableBufferSequence` 概念要求的对象来表示缓冲区。
- en: The buffer is ready to be used with Boost.Asio input methods and functions.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区已准备好，可以与 Boost.Asio 输入方法和函数一起使用。
- en: 'Let''s say we want to receive a block of data from the server. To do this,
    we first need to prepare a buffer where the data will be stored. This is how we
    do this in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从服务器接收一块数据。为了做到这一点，我们首先需要准备一个缓冲区，数据将存储在其中。以下是如何在以下代码中做到这一点的示例：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Both the samples look quite simple and straightforward; however, they contain
    some subtleties, which are important to understand so that we can properly use
    buffers with Boost.Asio. In this section, we'll see how each sample works in detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例看起来都很简单直接；然而，它们包含一些细微之处，这些细微之处对于正确使用 Boost.Asio 的缓冲区非常重要。在本节中，我们将详细了解每个示例的工作原理。
- en: Preparing a buffer for an output operation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备输出操作的缓冲区
- en: Let's consider the first code sample that demonstrates how to prepare a buffer
    that can be used with Boost.Asio output methods and functions. The `main()`entry
    point function starts with instantiating the object of the `std::string` class.
    Because we want to send a string of text, `std::string` is a good candidate to
    store this kind of data. In the next line, the string object is assigned a value
    of `Hello`. This is where the buffer is allocated and filled with data. This line
    implements steps 1 and 2 of the algorithm.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第一个代码示例，它展示了如何准备一个可以与 Boost.Asio 输出方法和函数一起使用的缓冲区。`main()` 入口函数从实例化 `std::string`
    类的对象开始。因为我们想发送一段文本字符串，所以 `std::string` 是存储这类数据的良好选择。在下一行，字符串对象被赋予值 `Hello`。这就是缓冲区分配并填充数据的地方。这一行实现了算法的步骤
    1 和 2。
- en: 'Next, before the buffer can be used with Boost.Asio I/O methods and functions,
    it must be properly represented. To better understand why this is needed, let''s
    take a look at one of the Boost.Asio output functions. Here is the declaration
    of the `send()`method of the Boost.Asio class that represents a TCP socket:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在缓冲区可以与 Boost.Asio I/O 方法和函数一起使用之前，必须对其进行适当的表示。为了更好地理解为什么需要这样做，让我们看看一个 Boost.Asio
    输出函数的例子。以下是代表 TCP 套接字的 Boost.Asio 类的 `send()` 方法的声明：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, this is a template method, and it accepts an object that satisfies
    the requirements of the `ConstBufferSeqenece` concept as its argument that represents
    the buffer. A suitable object is a composite object that represents a collection
    of objects of the `asio::const_buffer` class and provides a typical collection
    interface that supports an iteration over its elements. For example, an object
    of the `std::vector<asio::const_buffer>` class is suitable for being used as the
    argument of the `send()` method, but objects of the `std::string` or `asio::const_bufer`
    class are not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个模板方法，它接受一个满足 `ConstBufferSequence` 概念要求的对象作为其参数，该参数代表缓冲区。一个合适的对象是一个复合对象，它代表
    `asio::const_buffer` 类对象的集合，并提供支持对其元素进行迭代的典型集合接口。例如，`std::vector<asio::const_buffer>`
    类的对象适合用作 `send()` 方法的参数，但 `std::string` 或 `asio::const_bufer` 类的对象则不适合。
- en: 'In order to use our `std::string` object with the `send()`method of the class
    that represents a TCP socket, we can do something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的 `std::string` 对象与代表 TCP 套接字的类的 `send()` 方法，我们可以这样做：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The object named `buffer_sequence` in the preceding snippet satisfies the `ConstBufferSequence`
    concept''s requirements, and therefore, it can be used as an argument for the
    `send()` method of the socket object. However, this approach is very complex.
    Instead, we use the `asio::buffer()`function provided by Boost.Asio to obtain
    *adaptor* objects, which we can directly use in I/O operations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中名为 `buffer_sequence` 的对象满足 `ConstBufferSequence` 概念的要求，因此它可以作为套接字对象
    `send()` 方法的参数。然而，这种方法非常复杂。相反，我们使用 Boost.Asio 提供的 `asio::buffer()` 函数来获取 *适配器*
    对象，我们可以在 I/O 操作中直接使用它们：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the adaptor object is instantiated, it can be used with Boost.Asio output
    operations to represent the output buffer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在适配器对象实例化后，它可以与 Boost.Asio 输出操作一起使用，以表示输出缓冲区。
- en: Preparing a buffer for an input operation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为输入操作准备缓冲区
- en: The second code sample is very similar to the first one. The main difference
    is that the buffer is allocated but is not filled with data because its purpose
    is different. This time, the buffer is intended to receive the data from a remote
    application during the input operation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码示例与第一个非常相似。主要区别在于缓冲区已分配但未填充数据，因为其目的不同。这次，缓冲区旨在在输入操作期间从远程应用程序接收数据。
- en: With an output buffer, an input buffer must be properly represented so that
    it can be used with Boost.Asio I/O methods and functions. However, in this case,
    the buffer must be represented as an object that meets the requirements of the
    `MutableBufferSequence` concept. Contrary to `ConstBufferSequence`, this concept
    represents the collection of *mutable* buffers, that is, those that can be written
    to. Here, we use the `buffer()` function, which helps us create the required representation
    of the buffer. The object of the `mutable_buffers_1` adaptor class represents
    a single mutable buffer and meets the `MutableBufferSequence` concept's requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输出缓冲区时，必须正确表示输入缓冲区，以便可以使用 Boost.Asio I/O 方法和函数。然而，在这种情况下，该缓冲区必须表示为一个满足 `MutableBufferSequence`
    概念要求的对象。与 `ConstBufferSequence` 相反，这个概念表示可变缓冲区的集合，即可以写入的缓冲区。在这里，我们使用 `buffer()`
    函数，它帮助我们创建所需的缓冲区表示。`mutable_buffers_1` 适配器类对象表示单个可变缓冲区，并满足 `MutableBufferSequence`
    概念的要求。
- en: In the first step, the buffer is allocated. In this case, the buffer is an array
    of chars allocated in the free memory. In the next step, the adaptor object is
    instantiated that can be used with both the input and output operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，分配了缓冲区。在这种情况下，缓冲区是在空闲内存中分配的字符数组。在下一步中，实例化了适配器对象，它可以用于输入和输出操作。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Buffer ownership**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲区所有权**'
- en: It's important to note that neither the classes that represent the buffers nor
    the adaptor classes provided by Boost.Asio that we've considered (namely, `asio::mutable_buffer`,
    `asio::const_buffer`, `asio::mutable_buffers_1`, and `asio::const_buffers_1`)
    take ownership of the underlying raw buffer. These classes only provide the interface
    to the buffer and don't control its lifetime.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，代表缓冲区的类以及我们考虑的由 Boost.Asio 提供的适配器类（即 `asio::mutable_buffer`、`asio::const_buffer`、`asio::mutable_buffers_1`
    和 `asio::const_buffers_1`）都不拥有底层原始缓冲区的所有权。这些类仅提供对缓冲区的接口，并不控制其生命周期。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing to a TCP socket synchronously* recipe demonstrates how to write
    data to the socket from a fixed-length buffer
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向 TCP 套接字同步写入* 配方演示了如何从固定长度缓冲区向套接字写入数据。'
- en: The *Reading from a TCP socket synchronously* recipe demonstrates how to read
    data from the socket to a fixed-length buffer
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 TCP 套接字同步读取* 配方演示了如何从套接字读取数据到固定长度缓冲区。'
- en: The *Using composite buffers for scatter/gather operations* recipe in [Chapter
    6](ch06.html "Chapter 6. Other Topics"), *Other Topics*, provides more information
    on composite buffers and demonstrates how to use them
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html "第 6 章。其他主题") 中 *使用复合缓冲区进行分散/收集操作* 的配方提供了有关复合缓冲区的更多信息，并演示了如何使用它们。'
- en: Using extensible stream-oriented I/O buffers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可扩展的流式 I/O 缓冲区
- en: Extensible buffers are those buffers that dynamically increase their size when
    new data is written to them. They are usually used to read data from sockets when
    the size of the incoming message is unknown.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展缓冲区是当向其写入新数据时动态增加其大小的缓冲区。它们通常用于从套接字读取数据，当传入消息的大小未知时。
- en: Some application layer protocols do not define the exact size of the message.
    Instead, the boundary of the message is represented by a specific sequence of
    symbols at the end of the message itself or by a transport protocol service message
    **end of file** (**EOF**) issued by the sender after it finishes sending the message.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用层协议没有定义消息的确切大小。相反，消息的边界由消息末尾的特定符号序列表示，或者由发送者在完成消息发送后发出的传输协议服务消息**文件结束**（**EOF**）表示。
- en: For example, according to the HTTP protocol, the header section of the request
    and response messages don't have a fixed length and its boundary is represented
    by a sequence of four ASCII symbols, `<CR><LF><CR><LF>`, which is part of the
    message. In such cases, dynamically extensible buffers and functions that can
    work with them, which are provided by the Boost.Asio library, are very useful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，根据HTTP协议，请求和响应消息的头部部分没有固定长度，其边界由四个ASCII符号序列表示，即`<CR><LF><CR><LF>`，这是消息的一部分。在这种情况下，动态可扩展的缓冲区和可以与它们一起工作的函数，这些函数由Boost.Asio库提供，非常有用。
- en: In this recipe, we will see how to instantiate extensible buffers and how to
    read and write data to and from them. To see how these buffers can be used with
    I/O-related methods and functions provided by Boost.Asio, refer to the corresponding
    recipes dedicated to I/O operations listed in the *See also* section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何实例化可扩展的缓冲区以及如何向这些缓冲区读写数据。要了解这些缓冲区如何与Boost.Asio提供的I/O相关方法和函数一起使用，请参阅*另请参阅*部分中列出的专门针对I/O操作的相应菜谱。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Extensible stream-oriented buffers are represented in Boost.Asio with the `asio::streambuf`
    class, which is a `typedef` for `asio::basic_streambuf`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的流式缓冲区在Boost.Asio中由`asio::streambuf`类表示，它是`asio::basic_streambuf`的`typedef`：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `asio::basic_streambuf<>` class is inherited from `std::streambuf`, which
    means that it can be used as a stream buffer for STL stream classes. In addition
    to this, several I/O functions provided by Boost.Asio deal with buffers that are
    represented as objects of this class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::basic_streambuf<>`类是从`std::streambuf`继承的，这意味着它可以作为STL流类的流缓冲区使用。除了这一点之外，Boost.Asio提供的几个I/O函数处理表示为该类对象的缓冲区。'
- en: We can work with an object of the `asio::streambuf` class just like we would
    work with any stream buffer class that is inherited from the `std::streambuf`
    class. For example, we can assign this object to a stream (for example, `std::istream`,
    `std::ostream`, or `std::iostream`, depending on our needs), and then, use stream's
    `operator<<()` and `operator>>()` operators to write and read data to and from
    the stream.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理从`std::streambuf`类继承的任何流缓冲区类一样处理`asio::streambuf`类的对象。例如，我们可以将此对象分配给一个流（例如，`std::istream`、`std::ostream`或`std::iostream`，具体取决于我们的需求），然后使用流的`operator<<()`和`operator>>()`运算符向流写入和从流读取数据。
- en: 'Let''s consider a sample application in which an object of `asio::streambuf`
    is instantiated, some data is written to it, and then the data is read back from
    the buffer to an object of the `std::string` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例应用程序，其中实例化了一个`asio::streambuf`对象，向其中写入了一些数据，然后从缓冲区将数据读取回一个`std::string`类对象：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this sample does not contain any network I/O operations because it
    focuses on the `asio::streambuf` class itself and its operations rather than on
    how to use this class with I/O operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个示例不包含任何网络I/O操作，因为它专注于`asio::streambuf`类本身及其操作，而不是如何使用这个类进行I/O操作。
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `main()` application entry point function begins with instantiating an object
    of the `asio::streambuf` class named `buf`. Next, the output stream object of
    the `std::ostream` class is instantiated. The `buf` object is used as a *stream
    buffer* for the output stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`应用程序入口点函数从实例化一个名为`buf`的`asio::streambuf`类对象开始。接下来，实例化`std::ostream`类的输出流对象。`buf`对象被用作输出流的*流缓冲区*。'
- en: In the next line, the `Message1\nMessage2` sample data string is written to
    the output stream object, which in turn redirects the data to the `buf` stream
    buffer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，将`Message1\nMessage2`样本数据字符串写入输出流对象，该对象随后将数据重定向到`buf`流缓冲区。
- en: Usually, in a typical client or server application, the data will be written
    to the `buf` stream buffer by the Boost.Asio input function such as `asio::read()`,
    which accepts a stream buffer object as an argument and reads data from the socket
    to that buffer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在典型的客户端或服务器应用程序中，数据将通过Boost.Asio输入函数（如`asio::read()`）写入`buf`流缓冲区，该函数接受一个流缓冲区对象作为参数，并从套接字读取数据到该缓冲区。
- en: Now, we want to read the data back from the stream buffer. To do this, we allocate
    an input stream and pass the `buf` object as a stream buffer argument to its constructor.
    After this, we allocate a string object named `message1`, and then, use the `std::getline`
    function to read part of the string currently stored in the `buf` stream buffer
    until the delimiter symbol, `\n`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要从流缓冲区中读取数据。为此，我们分配一个输入流，并将`buf`对象作为流缓冲区参数传递给其构造函数。之后，我们分配一个名为`message1`的字符串对象，然后使用`std::getline`函数读取`buf`流缓冲区中当前存储的字符串的一部分，直到分隔符符号`\n`。
- en: As a result, the `string1` object contains the `Message1` string and the `buf`
    stream buffer contains the rest of the initial string after the delimiter symbol,
    that is, `Message2`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`string1`对象包含`Message1`字符串，而`buf`流缓冲区包含分隔符符号之后的初始字符串的其余部分，即`Message2`。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reading from a TCP socket asynchronously* recipe demonstrates how to read
    data from the socket to an extensible stream-oriented buffer
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步从TCP套接字读取*配方演示了如何将数据从套接字读取到可扩展的流式缓冲区'
- en: Writing to a TCP socket synchronously
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步写入TCP套接字
- en: Writing to a TCP socket is an output operation that is used to send data to
    the remote application connected to this socket. Synchronous writing is the simplest
    way to send the data using a socket provided by Boost.Asio. The methods and functions
    that perform synchronous writing to the socket block the thread of execution and
    do not return until the data (at least some amount of data) is written to the
    socket or an error occurs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 向TCP套接字写入是一个输出操作，用于将数据发送到连接到此套接字的远程应用程序。使用Boost.Asio提供的套接字进行同步写入是最简单的方式。执行同步写入到套接字的方法会阻塞执行线程，直到数据（至少一些数据）被写入套接字或发生错误才会返回。
- en: In this recipe, we will see how to write data to a TCP socket synchronously.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将了解如何同步地将数据写入TCP套接字。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The most basic way to write to the socket provided by the Boost.Asio library
    is to use the `write_some()` method of the `asio::ip::tcp::socket` class. Here
    is the declaration of one of the method''s overloads:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost.Asio库提供的套接字的最基本方式是使用`asio::ip::tcp::socket`类的`write_some()`方法。以下是该方法重载之一的声明：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method accepts an object that represents a composite buffer as an argument,
    and as its name suggests, writes *some* amount of data from the buffer to the
    socket. If the method succeeds, the return value indicates the number of bytes
    written. The point to emphasize here is that the method may *not* send all the
    data provided to it through the `buffers` argument. The method only guarantees
    that at least one byte will be written if an error does not occur. This means
    that, in a general case, in order to write all the data from the buffer to the
    socket, we may need to call this method several times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个表示复合缓冲区的对象作为参数，正如其名称所暗示的，从缓冲区写入*一些*数据到套接字。如果方法成功，返回值指示写入的字节数。这里要强调的是，该方法可能*不会*发送通过`buffers`参数提供的所有数据。该方法仅保证在没有错误发生的情况下至少写入一个字节。这意味着，在一般情况下，为了将缓冲区中的所有数据写入套接字，我们可能需要多次调用此方法。
- en: 'The following algorithm describes the steps required to synchronously write
    data to a TCP socket in a distributed application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在分布式应用程序中同步写入TCP套接字所需的步骤：
- en: In a client application, allocate, open, and connect an active TCP socket. In
    a server application, obtain a connected active TCP socket by accepting a connection
    request using an acceptor socket.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，分配、打开和连接一个活动TCP套接字。在服务器应用程序中，通过使用接受器套接字接受连接请求来获取一个已连接的活动TCP套接字。
- en: Allocate the buffer and fill it with data that is to be written to the socket.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配缓冲区并填充要写入套接字的数据。
- en: In a loop, call the socket's `write_some()` method as many times as it is needed
    to send all the data available in the buffer.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，根据需要多次调用套接字的`write_some()`方法，以发送缓冲区中所有可用的数据。
- en: 'The following code sample demonstrates a client application, which operates
    according to the algorithm:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了一个客户端应用程序，它根据该算法操作：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although in the presented code sample, writing to the socket is performed in
    the context of an application that acts as a client, the same approach can be
    used to write to the socket in a server application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所提供的代码示例中，写入套接字是在充当客户端的应用程序上下文中执行的，但可以使用相同的方法在服务器应用程序中写入套接字。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `main()`application entry point function is quite simple. It allocates a
    socket, opens, and synchronously connects it to a remote application. Then, the
    `writeToSocket()` function is called and the socket object is passed to it as
    an argument. In addition to this, the `main()`function contains a `try-catch`
    block intended to catch and handle exceptions that may be thrown by Boost.Asio
    methods and functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`应用程序入口点函数相当简单。它分配一个套接字，打开，并将其同步连接到远程应用程序。然后，调用`writeToSocket()`函数，并将套接字对象作为参数传递给它。此外，`main()`函数包含一个`try-catch`块，旨在捕获和处理Boost.Asio方法和函数可能抛出的异常。'
- en: The interesting part in the sample is the `writeToSocket()`function that performs
    synchronous writing to the socket. It accepts a reference to the socket object
    as an argument. Its precondition is that the socket passed to it is already connected;
    otherwise, the function fails.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 样本中有趣的部分是执行同步写入套接字的`writeToSocket()`函数。它接受一个套接字对象的引用作为参数。它的前提条件是传递给它的套接字已经连接；否则，函数将失败。
- en: The function begins with allocating and filling the buffer. In this sample,
    we use an ASCII string as data that is to be written to the socket, and, therefore,
    we allocate an object of the `std::string` class and assign it a value of `Hello`,
    which we will use as a dummy message that will be written to the socket.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始于分配和填充缓冲区。在这个示例中，我们使用ASCII字符串作为要写入套接字的数据，因此我们分配了一个`std::string`类的对象，并给它赋值为`Hello`，我们将使用这个作为将要写入套接字的占位符消息。
- en: Then, the variable named `total_bytes_written` is defined and its value is set
    to `0`. This variable is used as a counter that stores the count of bytes already
    written to the socket.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义了一个名为`total_bytes_written`的变量，并将其值设置为`0`。这个变量用作计数器，用于存储已经写入套接字的字节数。
- en: 'Next, the loop is run in which the socket''s `write_some()` method is called.
    Except for the degenerate case when the buffer is empty (that is, the `buf.length()`
    method returns a value of `0`), at least one iteration of the loop is executed
    and the `write_some()` method is called at least once. Let''s take a closer look
    at the loop:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行一个循环，在该循环中调用套接字的`write_some()`方法。除了缓冲区为空的情况（即`buf.length()`方法返回值为`0`）之外，至少执行一次循环迭代，并且至少调用一次`write_some()`方法。让我们更仔细地看看这个循环：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The termination condition evaluates to `true` when the value of the `total_bytes_written`
    variable is equal to the size of the buffer, that is, when all the bytes available
    in the buffer have been written to the socket. In each iteration of the loop,
    the value of the `total_bytes_written` variable is increased by the value returned
    by the `write_some()` method, which is equal to the number of bytes written during
    this method call.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当`total_bytes_written`变量的值等于缓冲区的大小时，终止条件评估为`true`，即当缓冲区中可用的所有字节都已被写入套接字时。在循环的每次迭代中，`total_bytes_written`变量的值都会增加`write_some()`方法返回的值，这个值等于在此方法调用期间写入的字节数。
- en: Each time the `write_some()` method is called, the argument passed to it is
    adjusted. The start byte of the buffer is shifted by the value of `total_bytes_written`
    as compared to the original buffer (because the previous bytes have already been
    sent by preceding calls to the `write_some()` method) and the size of the buffer
    is decreased by the same value, correspondingly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`write_some()`方法时，传递给它的参数都会调整。与原始缓冲区相比，缓冲区的起始字节根据`total_bytes_written`的值进行偏移（因为前面的`write_some()`方法调用已经发送了前面的字节），并且缓冲区的大小相应地减少相同的值。
- en: After the loop terminates, all the data from the buffer is written to the socket
    and the `writeToSocket()` function returns.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环终止后，缓冲区中的所有数据都被写入套接字，并且`writeToSocket()`函数返回。
- en: It's worth noting that the amount of bytes written to the socket during a single
    call to the `write_some()` method depends on several factors. In the general case,
    it is not known to the developer; and therefore, it should not be accounted for.
    A demonstrated solution is independent of this value and calls the `write_some()`
    method as many times as needed to write all the data available in the buffer to
    the socket.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在单次调用 `write_some()` 方法期间写入套接字的字节数取决于几个因素。在一般情况下，开发者并不知道这一点；因此，不应将其计入考虑。一个演示的解决方案与此值无关，并且根据需要多次调用
    `write_some()` 方法，将缓冲区中所有可用的数据写入套接字。
- en: Alternative – the send() method
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 - send() 方法
- en: The `asio::ip::tcp::socket` class contains another method to synchronously write
    data to the socket named `send()`. There are three overloads of this method. One
    of them is equivalent to the `write_some()` method, as described earlier. It has
    exactly the same signature and provides exactly the same functionality. These
    methods are synonyms in a sense.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::socket` 类包含另一个同步将数据写入套接字的方法，名为 `send()`。此方法有三个重载。其中之一与前面描述的
    `write_some()` 方法等效。它具有完全相同的签名，并提供了完全相同的功能。在某种意义上，这些方法是同义词。'
- en: 'The second overload accepts one additional argument as compared to the `write_some()`
    method. Let''s take a look at it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重载与 `write_some()` 方法相比接受一个额外的参数。让我们看看它：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This additional argument is named `flags`. It can be used to specify a bit mask,
    representing flags that control the operation. Because these flags are used quite
    rarely, we won't consider them in this book. Refer to the Boost.Asio documentation
    to find out more information on this topic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的参数被命名为 `flags`。它可以用来指定一个位掩码，表示控制操作的标志。因为这些标志使用得相当少，所以我们不会在本书中考虑它们。有关此主题的更多信息，请参阅
    Boost.Asio 文档。
- en: The third overload is equivalent to the second one, but it doesn't throw exceptions
    in case of a failure. Instead, the error information is returned by means of an
    additional method's output argument of the `boost::system::error_code` type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个重载与第二个重载等效，但在失败的情况下不会抛出异常。相反，错误信息通过一个额外的 `boost::system::error_code` 类型的方法输出参数返回。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Writing to a socket using the socket's `write_some()` method seems very complex
    for such a simple operation. Even if we want to send a small message that consists
    of several bytes, we must use a loop, a variable to keep track of how many bytes
    have already been written, and properly construct a buffer for each iteration
    of the loop. This approach is error-prone and makes the code more difficult to
    understand.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字的 `write_some()` 方法向套接字写入数据对于这样一个简单的操作来说似乎非常复杂。即使我们只想发送由几个字节组成的小消息，我们也必须使用循环、一个变量来跟踪已经写入的字节数，并在循环的每次迭代中正确构造一个缓冲区。这种方法容易出错，并使代码更难以理解。
- en: 'Fortunately, Boost.Asio provides a free function, which simplifies writing
    to a socket. This function is called `asio::write()`. Let''s take a look at one
    of its overloads:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Boost.Asio 提供了一个免费函数，简化了向套接字写入的过程。这个函数被称为 `asio::write()`。让我们看看它的一种重载形式：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function accepts two arguments. The first of them named `s` is a reference
    to an object that satisfies the requirements of the `SyncWriteStream` concept.
    For a complete list of the requirements, refer to the corresponding Boost.Asio
    documentation section at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html).
    The object of the `asio::ip::tcp::socket` class that represents a TCP socket satisfies
    these requirements and, therefore, can be used as the first argument of the function.
    The second argument named `buffers` represents the buffer (simple or composite)
    and contains data that is to be written to the socket.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数。第一个参数名为 `s` 是一个满足 `SyncWriteStream` 概念要求的对象的引用。关于要求列表的完整信息，请参阅相应的
    Boost.Asio 文档部分，链接为 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncWriteStream.html)。表示
    TCP 套接字的 `asio::ip::tcp::socket` 类的对象满足这些要求，因此可以用作函数的第一个参数。第二个参数名为 `buffers` 表示缓冲区（简单或复合），并包含要写入套接字的数据。
- en: In contrast to the socket object's `write_some()` method, which writes *some*
    amount of data from the buffer to the socket, the `asio::write()` function writes
    all the data available in the buffer. This simplifies writing to the socket and
    makes the code shorter and cleaner.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与套接字对象的`write_some()`方法不同，后者从缓冲区写入*一些*数据到套接字，`asio::write()`函数将缓冲区中所有可用的数据写入套接字。这简化了套接字的写入操作，并使代码更短更干净。
- en: 'This is how our `writeToSocket()` function from a previous sample would look
    like if we used the `asio::write()` function instead of the socket object''s `write_some()`
    method to write data to the socket:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`asio::write()`函数而不是套接字对象的`write_some()`方法来向套接字写入数据，那么我们之前示例中的`writeToSocket()`函数将看起来是这样的：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `asio::write()` function is implemented in a similar way as the original
    `writeToSocket()` function is implemented by means of several calls to the socket
    object's `write_some()` method in a loop.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::write()`函数的实现方式与原始的`writeToSocket()`函数通过在循环中对套接字对象的`write_some()`方法进行多次调用而实现的方式相似。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `asio::write()` function has seven more overloads on the top of
    the one we just considered. Some of them may be very useful in specific cases.
    Refer to the Boost.Asio documentation to find out more about this function at
    [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asio::write()`函数在刚刚考虑的函数之上还有七个重载。其中一些可能在特定情况下非常有用。请参阅Boost.Asio文档以了解更多关于此函数的信息，请参阅[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/write.html)。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing a synchronous TCP client* recipe in [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    demonstrates how to implement a synchronous TCP client that performs synchronous
    writing to send request messages to the server
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。实现客户端应用程序")的*实现同步TCP客户端*配方中，*实现客户端应用程序*展示了如何实现一个同步TCP客户端，该客户端执行同步写入以向服务器发送请求消息
- en: The *Implementing a synchronous iterative TCP server* recipe in [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    demonstrates how to implement a synchronous TCP server that performs synchronous
    writing to send response messages to the client
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。实现服务器应用程序")的*实现同步迭代TCP服务器*配方中，*实现服务器应用程序*展示了如何实现一个同步TCP服务器，该服务器执行同步写入以向客户端发送响应消息
- en: Reading from a TCP socket synchronously
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从TCP套接字中同步读取
- en: Reading from a TCP socket is an input operation that is used to receive data
    sent by the remote application connected to this socket. Synchronous reading is
    the simplest way to receive the data using a socket provided by Boost.Asio. The
    methods and functions that perform synchronous reading from the socket blocks
    the thread of execution and doesn't return until the data (at least some amount
    of data) is read from the socket or an error occurs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从TCP套接字中读取是一个输入操作，用于接收连接到此套接字的远程应用程序发送的数据。同步读取是使用Boost.Asio提供的套接字接收数据的简单方法。执行同步读取的方法和函数会阻塞执行线程，直到从套接字中读取数据（至少一些数据）或发生错误才会返回。
- en: In this recipe, we will see how to read data from a TCP socket synchronously.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何从TCP套接字中同步读取数据。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The most basic way to read data from the socket provided by the Boost.Asio
    library is the `read_some()` method of the `asio::ip::tcp::socket` class. Let''s
    take a look at one of the method''s overloads:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost.Asio库提供的套接字读取数据的最基本方式是`asio::ip::tcp::socket`类的`read_some()`方法。让我们看看这个方法的一个重载版本：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method accepts an object that represents a writable buffer (single or composite)
    as an argument, and as its name suggests, reads *some* amount of data from the
    socket to the buffer. If the method succeeds, the return value indicates the number
    of bytes read. It's important to note that there is no way to control how many
    bytes the method will read. The method only guarantees that at least one byte
    will be read if an error does not occur. This means that, in a general case, in
    order to read a certain amount of data from the socket, we may need to call the
    method several times.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个表示可写缓冲区（单个或组合）的对象作为参数，正如其名称所暗示的，从套接字读取一定量的数据到缓冲区。如果方法成功，返回值表示读取的字节数。需要注意的是，无法控制方法将读取多少字节。该方法仅保证如果没有发生错误，至少会读取一个字节。这意味着，在一般情况下，为了从套接字读取一定量的数据，我们可能需要多次调用该方法。
- en: 'The following algorithm describes the steps required to synchronously read
    data from a TCP socket in a distributed application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在分布式应用程序中同步从TCP套接字读取数据所需的步骤：
- en: In a client application, allocate, open, and connect an active TCP socket. In
    a server application, obtain a connected active TCP socket by accepting a connection
    request using an acceptor socket.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，分配、打开并连接一个活动TCP套接字。在服务器应用程序中，通过使用接受器套接字接受连接请求来获取一个已连接的活动TCP套接字。
- en: Allocate the buffer of a sufficient size to fit in the expected message to be
    read.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个足够大的缓冲区，以便能够容纳要读取的预期消息。
- en: In a loop, call the socket's `read_some()` method as many times as it is needed
    to read the message.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，根据需要多次调用套接字的`read_some()`方法来读取消息。
- en: 'The following code sample demonstrates a client application, which operates
    according to the algorithm:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了一个客户端应用程序，该应用程序按照以下算法操作：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although in the presented code sample, reading from a socket is performed in
    the context of an application that acts as a client, the same approach can be
    used to read data from the socket in a server application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所提供的代码示例中，从套接字读取是在充当客户端的应用程序上下文中执行的，但同样的方法也可以用于在服务器应用程序中从套接字读取数据。
- en: How it works…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `main()`application entry point function is quite simple. First, it allocates
    a TCP socket, opens, and synchronously connects it to a remote application. Then,
    the `readFromSocket()` function is called and the socket object is passed to it
    as an argument. In addition to this, the `main()` function contains a `try-catch`
    block intended to catch and handle exceptions that may be thrown by Boost.Asio
    methods and functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`应用程序入口点函数相当简单。首先，它分配一个TCP套接字，打开并同步将其连接到远程应用程序。然后，调用`readFromSocket()`函数，并将套接字对象作为参数传递给它。此外，`main()`函数包含一个`try-catch`块，旨在捕获和处理Boost.Asio方法和函数可能抛出的异常。'
- en: The interesting part in the sample is the `readFromSocket()` function that performs
    synchronous reading from the socket. It accepts a reference to the socket object
    as an input argument. Its precondition is that the socket passed to it as an argument
    must be connected; otherwise, the function fails.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 样本中的有趣部分是`readFromSocket()`函数，它执行从套接字的同步读取。它接受套接字对象的引用作为输入参数。它的前提是传递给它的作为参数的套接字必须是连接的；否则，函数将失败。
- en: The function begins with allocating a buffer named `buf`. The size of the buffer
    is chosen to be 7 bytes. This is because in our sample, we expect to receive exactly
    a 7 bytes long message from a remote application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时分配一个名为`buf`的缓冲区。缓冲区的大小被选择为7字节。这是因为在我们这个示例中，我们期望从远程应用程序接收一个正好7字节长的消息。
- en: Then, a variable named `total_bytes_read` is defined and its value is set to
    `0`. This variable is used as a counter that keeps the count of the total number
    of bytes read from the socket.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义一个名为`total_bytes_read`的变量，并将其值设置为`0`。该变量用作计数器，用于记录从套接字读取的总字节数。
- en: 'Next, the loop is run in which the socket''s `read_some()` method is called.
    Let''s take a closer look at the loop:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行循环，在其中调用套接字的`read_some()`方法。让我们更详细地看看这个循环：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The termination condition evaluates to `true` when the value of the `total_bytes_read`
    variable is equal to the size of the expected message, that is, when the whole
    message has been read from the socket. In each iteration of the loop, the value
    of the `total_bytes_read` variable is increased by the value returned by the `read_some()`
    method, which is equal to the number of bytes read during this method call.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `total_bytes_read` 变量的值等于预期消息的大小，即整个消息已从套接字中读取时，终止条件评估为 `true`。在循环的每次迭代中，`total_bytes_read`
    变量的值会增加 `read_some()` 方法返回的值，该值等于在此方法调用期间读取的字节数。
- en: Each time the `read_some()` method is called, the input buffer passed to it
    is adjusted. The start byte of the buffer is shifted by the value of `total_bytes_read`
    as compared to the original buffer (because the preceding part of the buffer has
    already been filled with data read from the socket during preceding calls to the
    `read_some()` method) and the size of the buffer is decreased by the same value,
    correspondingly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `read_some()` 方法时，传递给它的输入缓冲区都会进行调整。与原始缓冲区相比，缓冲区的起始字节会根据 `total_bytes_read`
    的值进行偏移（因为缓冲区的先前部分已经在前几次调用 `read_some()` 方法时用从套接字读取的数据填充），并且缓冲区的大小相应地减少相同的值。
- en: After the loop terminates, all the data expected to be read from the socket
    is now in the buffer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，现在缓冲区中包含了从套接字中预期读取的所有数据。
- en: The `readFromSocket()` function ends with instantiating an object of the `std::string`
    class from the received buffer and returning it to the caller.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFromSocket()` 函数以从接收到的缓冲区中实例化 `std::string` 类的对象并返回给调用者结束。'
- en: It's worth noting that the amount of bytes read from the socket during a single
    call to the `read_some()` method depends on several factors. In a general case,
    it is not known to the developer; and, therefore, it should not be accounted for.
    The proposed solution is independent of this value and calls the `read_some()`
    method as many times as needed to read all the data from the socket.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在单次调用 `read_some()` 方法时，从套接字中读取的字节数取决于多个因素。在一般情况下，这并不为开发者所知；因此，不应将其考虑在内。所提出的解决方案与此值无关，并且根据需要多次调用
    `read_some()` 方法以从套接字中读取所有数据。
- en: Alternative – the receive() method
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案 – `receive()` 方法
- en: The `asio::ip::tcp::socket` class contains another method to read data from
    the socket synchronously called `receive()`. There are three overloads of this
    method. One of them is equivalent to the `read_some()` method, as described earlier.
    It has exactly the same signature and provides exactly the same functionality.
    These methods are synonyms in a sense.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::socket` 类包含另一个从套接字同步读取数据的方法，称为 `receive()`。此方法有三个重载。其中之一与前面描述的
    `read_some()` 方法等效。它具有完全相同的签名，并提供了完全相同的功能。在某种意义上，这些方法是同义词。'
- en: 'The second overload accepts one additional argument as compared to the `read_some()`
    method. Let''s take a look at it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `read_some()` 方法相比，第二个重载方法多接受一个额外的参数。让我们来看看它：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This additional argument is named `flags`. It can be used to specify a bit mask,
    representing flags that control the operation. Because these flags are rarely
    used, we won't consider them in this book. Refer to the Boost.Asio documentation
    to find out more about this topic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的参数被命名为 `flags`。它可以用来指定一个位掩码，表示控制操作的标志。因为这些标志很少使用，所以我们不会在本书中考虑它们。有关此主题的更多信息，请参阅
    Boost.Asio 文档。
- en: The third overload is equivalent to the second one, but it doesn't throw exceptions
    in case of a failure. Instead, the error information is returned by means of an
    additional output argument of the `boost::system::error_code` type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个重载与第二个重载等效，但在失败的情况下不会抛出异常。相反，错误信息通过 `boost::system::error_code` 类型的额外输出参数返回。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Reading from a socket using the socket's `read_some()` method seems very complex
    for such a simple operation. This approach requires us to use a loop, a variable
    to keep track of how many bytes have already been read, and properly construct
    a buffer for each iteration of the loop. This approach is error-prone and makes
    the code more difficult to understand and maintain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字的 `read_some()` 方法从套接字读取数据对于这样一个简单的操作来说似乎非常复杂。这种方法要求我们使用循环、一个变量来跟踪已经读取的字节数，并且为循环的每次迭代正确构造一个缓冲区。这种方法容易出错，并使代码更难以理解和维护。
- en: Fortunately, Boost.Asio provides a family of free functions that simplify synchronous
    reading of data from a socket in different contexts. There are three such functions,
    each having several overloads, that provide a rich functionality that facilitates
    reading data from a socket.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Boost.Asio 提供了一系列免费函数，这些函数在不同的上下文中简化了从套接字同步读取数据。有三个这样的函数，每个函数都有几个重载版本，提供了丰富的功能，有助于从套接字读取数据。
- en: The asio::read() function
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The asio::read() function
- en: 'The `asio::read()` function is the simplest one out of the three. Let''s take
    a look at the declaration of one of its overloads:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read()` 函数是三个函数中最简单的一个。让我们看看其中一个重载的声明：'
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function accepts two arguments. The first of them named `s` is a reference
    to an object that satisfies the requirements of the `SyncReadStream` concept.
    For a complete list of the requirements, refer to the corresponding Boost.Asio
    documentation section available at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html).
    The object of the `asio::ip::tcp::socket` class that represents a TCP socket satisfies
    these requirements and, therefore, can be used as the first argument of the function.
    The second argument named `buffers` represents a buffer (simple or composite)
    to which the data will be read from the socket.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数。第一个参数名为 `s`，是一个满足 `SyncReadStream` 概念要求的对象的引用。关于要求完整列表，请参阅在 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html)
    可用的相应 Boost.Asio 文档部分。表示 TCP 套接字的 `asio::ip::tcp::socket` 类的对象满足这些要求，因此可以用作函数的第一个参数。第二个参数名为
    `buffers`，表示一个缓冲区（简单或复合），数据将从套接字读取到该缓冲区。
- en: In contrast to the socket's `read_some()` method, which reads *some* amount
    of data from the socket to the buffer, the `asio::read()` function, during a single
    call, reads data from the socket until the buffer passed to it as an argument
    is filled or an error occurs. This simplifies reading from the socket and makes
    the code shorter and cleaner.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与从套接字读取到缓冲区的“某些”数据量的 `read_some()` 方法相比，`asio::read()` 函数在单次调用期间从套接字读取数据，直到传递给它的作为参数的缓冲区被填满或发生错误。这简化了从套接字读取的过程，并使代码更短更整洁。
- en: 'This is how our `readFromSocket()` function from the previous sample would
    look like if we used the `asio::read()` function instead of the socket object''s
    `read_some()` method to read data from the socket:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `asio::read()` 函数而不是套接字对象的 `read_some()` 方法来从套接字读取数据，那么前面的示例中的 `readFromSocket()`
    函数将看起来像这样：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding sample, a call to the `asio::read()` function will block the
    thread of execution until exactly 7 bytes are read or an error occurs. The benefits
    of this approach over the socket's `read_some()` method are obvious.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，对 `asio::read()` 函数的调用将阻塞执行线程，直到恰好读取了 7 个字节或发生错误。与套接字的 `read_some()`
    方法相比，这种方法的优势是显而易见的。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `asio::read()` function has several overloads, which provide flexibility
    in specific contexts. Refer to the corresponding section of the Boost.Asio documentation
    to find out more about this function at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read()` 函数有几个重载版本，在特定上下文中提供了灵活性。有关此函数的更多信息，请参阅 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read.html)
    的相应 Boost.Asio 文档部分。'
- en: The asio::read_until() function
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: asio::read_until() 函数
- en: 'The `asio::read_until()` function provides a way to read data from a socket
    until a specified pattern is encountered in the data. There are eight overloads
    of this function. Let''s consider one of them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read_until()` 函数提供了一种从套接字读取数据的方法，直到在数据中遇到指定的模式。该函数有八个重载版本。让我们考虑其中之一：'
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function accepts three arguments. The first of them named `s` is a reference
    to an object that satisfies the requirements of the `SyncReadStream` concept.
    For a complete list of the requirements, refer to the corresponding Boost.Asio
    documentation section at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html).
    The object of the `asio::ip::tcp::socket` class that represents a TCP socket satisfies
    these requirements and, therefore, can be used as the first argument of the function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受三个参数。第一个参数名为 `s` 是一个满足 `SyncReadStream` 概念要求的对象的引用。有关要求列表的完整信息，请参阅相应的 Boost.Asio
    文档部分，链接为 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/SyncReadStream.html)。`asio::ip::tcp::socket`
    类的对象代表一个 TCP 套接字，它满足这些要求，因此可以用作函数的第一个参数。
- en: The second argument named `b` represents a stream-oriented extensible buffer
    in which the data will be read. The last argument named `delim` specifies a delimiter
    character.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数名为 `b` 代表一个面向流的可扩展缓冲区，数据将从中读取。最后一个参数名为 `delim` 指定一个分隔符字符。
- en: The `asio::read_until()` function will read data from the `s` socket to the
    buffer `b` until it encounters a character specified by the `delim` argument in
    the read portion of the data. When the specified character is encountered, the
    function returns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read_until()` 函数将从 `s` 套接字读取数据到缓冲区 `b`，直到遇到由 `delim` 参数指定的字符，该字符位于数据的读取部分。当遇到指定的字符时，函数返回。'
- en: It's important to note that the `asio::read_until()` function is implemented
    so that it reads the data from the socket by blocks of variable sizes (internally
    it uses the socket's `read_some()` method to read the data). When the function
    returns, the buffer `b` may contain some symbols after the delimiter symbol. This
    may happen if the remote application sends some more data after the delimiter
    symbol (for example, it may send two messages in a row, each having a delimiter
    symbol in the end). In other words, when the `asio::read_until()` function returns
    successfully, it is guaranteed that the buffer `b` contains at least one delimiter
    symbol but may contain more. It is the developer's responsibility to parse the
    data in the buffer and handle the situation when it contains data after the delimiter
    symbol.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`asio::read_until()` 函数的实现方式是按变量大小的块从套接字读取数据（内部使用套接字的 `read_some()` 方法读取数据）。当函数返回时，缓冲区
    `b` 可能包含分隔符符号之后的某些符号。这可能发生在远程应用程序在分隔符符号之后发送更多数据的情况下（例如，它可能连续发送两条消息，每条消息的末尾都有一个分隔符符号）。换句话说，当
    `asio::read_until()` 函数成功返回时，可以保证缓冲区 `b` 至少包含一个分隔符符号，但可能包含更多。解析缓冲区中的数据并处理包含分隔符符号之后数据的情形是开发者的责任。
- en: 'This is how we will implement our `readFromSocket()` function if we want to
    read all the data from a socket until a specific symbol is encountered. Let''s
    assume the message delimiter to be a new line ASCII symbol, `\n`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从套接字读取所有数据直到遇到特定符号，我们将这样实现我们的 `readFromSocket()` 函数。假设消息分隔符为换行 ASCII 符号，`\n`：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example is quite simple and straightforward. Because `buf` may contain
    more symbols after the delimiter symbol, we use the `std::getline()` function
    to extract the messages of interest before the delimiter symbol and put them into
    the `message` string object, which is then returned to the caller.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例相当简单直接。因为 `buf` 可能包含分隔符符号之后的更多符号，我们使用 `std::getline()` 函数提取分隔符符号之前感兴趣的消息，并将它们放入
    `message` 字符串对象中，然后将其返回给调用者。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `read_until()` function has several overloads, which provide more sophisticated
    ways to specify termination conditions, such as string delimiters, regular expressions,
    or functors. Refer to the corresponding Boost.Asio documentation section to find
    out more about this topic at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_until()` 函数有几个重载版本，提供了更复杂的方式来指定终止条件，例如字符串分隔符、正则表达式或函数对象。有关此主题的更多信息，请参阅相应的
    Boost.Asio 文档部分，链接为 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_until.html)。'
- en: The asio::read_at() function
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: asio::read_at() 函数
- en: The `asio::read_at()` function provides a way to read data from a socket, starting
    at a particular offset. Because this function is rarely used, it is beyond the
    scope of this book. Refer to the corresponding Boost.Asio documentation section
    for more details about this function and its overloads at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read_at()` 函数提供了一种从套接字读取数据的方法，从特定的偏移量开始。由于此函数很少使用，它超出了本书的范围。有关此函数及其重载的更多详细信息，请参阅相应的
    Boost.Asio 文档部分，链接为 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/read_at.html)。'
- en: The `asio::read()`, `asio::read_until()`, and `asio::read_at()` functions are
    implemented in a similar way to how the original `readFromSocket()` function in
    our sample is implemented by means of several calls to the socket object's `read_some()`
    method in a loop until the termination condition is satisfied or an error occurs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::read()`、`asio::read_until()` 和 `asio::read_at()` 函数的实现方式与我们的示例中通过在循环中对套接字对象的
    `read_some()` 方法进行多次调用直到满足终止条件或发生错误来实现的原始 `readFromSocket()` 函数类似。'
- en: See also
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using extensible stream-oriented I/O buffers* recipe demonstrates how to
    write and read data to and from the `asio::streambuf` buffer
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用可扩展的流式 I/O 缓冲区* 菜单展示了如何向 `asio::streambuf` 缓冲区写入和读取数据'
- en: The *Implementing a synchronous TCP client* recipe in [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    demonstrates how to implement a synchronous TCP client that performs synchronous
    reading from a socket to receive response messages sent by the server
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。实现客户端应用程序") 的 *实现客户端应用程序* 菜单中，*实现同步 TCP 客户端* 菜单演示了如何实现一个同步
    TCP 客户端，该客户端从套接字同步读取以接收服务器发送的响应消息
- en: The *Implementing a synchronous iterative TCP server* recipe in [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    demonstrates how to implement a synchronous TCP server that performs synchronous
    reading to receive request messages from the client
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。实现服务器应用程序") 的 *实现服务器应用程序* 菜单中，*实现同步迭代 TCP 服务器* 菜单演示了如何实现一个同步
    TCP 服务器，该服务器执行同步读取以接收客户端发送的请求消息
- en: Writing to a TCP socket asynchronously
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步写入 TCP 套接字
- en: Asynchronous writing is a flexible and efficient way to send data to a remote
    application. In this recipe, we will see how to write data to a TCP socket asynchronously.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 异步写入是一种灵活且高效地向远程应用程序发送数据的方式。在本菜谱中，我们将看到如何异步写入 TCP 套接字。
- en: How to do it…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The most basic tool used to asynchronously write data to the socket provided
    by the Boost.Asio library is the `async_write_some()` method of the `asio::ip::tcp::socket`
    class. Let''s take a look at one of the method''s overloads:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost.Asio 库提供的套接字上异步写入数据的最基本工具是 `asio::ip::tcp::socket` 类的 `async_write_some()`
    方法。让我们看看该方法的一个重载：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method initiates the write operation and returns immediately. It accepts
    an object that represents a buffer that contains the data to be written to the
    socket as its first argument. The second argument is a callback, which will be
    called by Boost.Asio when an initiated operation is completed. This argument can
    be a function pointer, functor, or any other object that satisfies the requirements
    of the `WriteHandler` concept. The complete list of the requirements can be found
    in the corresponding section of the Boost.Asio documentation at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法启动写入操作并立即返回。它接受一个表示要写入套接字的数据的缓冲区的对象作为其第一个参数。第二个参数是一个回调，当启动的操作完成时，Boost.Asio
    将调用它。此参数可以是函数指针、仿函数或满足 `WriteHandler` 概念要求的任何其他对象。完整的要求列表可以在 Boost.Asio 文档的相应部分找到，链接为
    [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/WriteHandler.html)。
- en: 'The callback should have the following signature:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 回调应具有以下签名：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `ec` is an argument that indicates an error code if one occurs, and the
    `bytes_transferred` argument indicates how many bytes have been written to the
    socket during the corresponding asynchronous operation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ec` 是一个参数，如果发生错误，则表示错误代码，而 `bytes_transferred` 参数表示在相应的异步操作期间写入套接字的字节数。
- en: As the `async_write_some()` method's name suggests, it initiates an operation
    that is intended to write *some* amount of data from the buffer to the socket.
    This method guarantees that at least one byte will be written during the corresponding
    asynchronous operation if an error does not occur. This means that, in a general
    case, in order to write all the data available in the buffer to the socket, we
    may need to perform this asynchronous operation several times.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如`async_write_some()`方法的名字所暗示的，它启动一个操作，目的是从缓冲区向套接字写入*一些*数据。此方法保证在相应的异步操作中如果没有发生错误，至少将写入一个字节。这意味着，在一般情况下，为了将缓冲区中所有可用的数据写入套接字，我们可能需要执行此异步操作多次。
- en: Now that we know how the key method works, let's see how to implement an application
    that performs asynchronous writing to the socket.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了关键方法是如何工作的，让我们看看如何实现一个执行异步套接字写入的应用程序。
- en: 'The following algorithm describes the steps required to perform and implement
    an application, which writes data to a TCP socket asynchronously. Note that this
    algorithm provides a *possible* way to implement such an application. Boost.Asio
    is quite flexible and allows us to organize and structure the application by writing
    data to a socket asynchronously in many different ways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了执行和实现写入TCP套接字异步数据的应用程序所需的步骤。请注意，此算法提供了一个*可能*实现此类应用程序的方法。Boost.Asio非常灵活，允许我们通过以多种不同的方式异步写入套接字数据来组织和结构化应用程序：
- en: Define a data structure that contains a pointer to a socket object, a buffer,
    and a variable used as a counter of bytes written.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含指向套接字对象的指针、缓冲区和用作已写入字节数计数器的变量的数据结构。
- en: Define a callback function that will be called when the asynchronous writing
    operation is completed.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个回调函数，当异步写入操作完成时将被调用。
- en: In a client application, allocate and open an active TCP socket and connect
    it to a remote application. In a server application, obtain a connected active
    TCP socket by accepting a connection request.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，分配并打开一个活跃的TCP套接字并将其连接到远程应用程序。在服务器应用程序中，通过接受连接请求来获取一个已连接的活跃TCP套接字。
- en: Allocate a buffer and fill it with data that is to be written to the socket.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个缓冲区并填充要写入套接字的数据。
- en: Initiate an asynchronous writing operation by calling the socket's `async_write_some()`
    method. Specify a function defined in step 2 as a callback.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的`async_write_some()`方法来启动异步写入操作。指定在第2步中定义的函数作为回调。
- en: Call the `run()` method on an object of the `asio::io_service` class.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`asio::io_service`类的对象上调用`run()`方法。
- en: In a callback, increase the counter of bytes written. If the number of bytes
    written is less than the total amount of bytes to be written, initiate a new asynchronous
    writing operation to write the next portion of the data.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调中增加已写入字节数的计数器。如果已写入的字节数少于要写入的总字节数，则启动一个新的异步写入操作来写入数据的下一部分。
- en: Let's implement a sample client application that performs asynchronous writing
    in accordance with the preceding algorithm.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个示例客户端应用程序，该应用程序根据前面的算法执行异步写入。
- en: 'We begin with adding the `include` and `using` directives:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加`include`和`using`指令开始：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, according to step 1 of the algorithm, we define a data structure that
    contains a pointer to the socket object, a buffer that contains data to be written,
    and a counter variable that contains the number of bytes already written:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据算法的第1步，我们定义一个包含指向套接字对象的指针、包含要写入的数据的缓冲区以及包含已写入字节数的计数器变量的数据结构：
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In step 2, we define a callback function, which will be called when the asynchronous
    operation is completed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们定义了一个回调函数，当异步操作完成时将被调用：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s skip step 3 for now and implement steps 4 and 5 in a separate function.
    Let''s call this function `writeToSocket()`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们先跳过第3步，并在一个单独的函数中实现第4步和第5步。让我们把这个函数叫做`writeToSocket()`：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we come back to step 3 and implement it in the `main()`application entry
    point function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到第3步，并在`main()`应用程序入口点函数中实现它：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now, let's track the application's execution path to better understand how it
    works.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们追踪应用程序的执行路径，以便更好地理解它是如何工作的。
- en: The application is run by a single thread, in the context of which the application's
    `main()` entry point function is called. Note that Boost.Asio may create additional
    threads for some internal operations, but it guarantees that no application code
    is executed in the context of those threads.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由单个线程运行，在此上下文中调用应用程序的`main()`入口点函数。请注意，Boost.Asio可能会为某些内部操作创建额外的线程，但它保证不会在这些线程的上下文中执行任何应用程序代码。
- en: The `main()` function allocates, opens, and synchronously connects a socket
    to a remote application and then calls the `writeToSocket()` function by passing
    a pointer to the socket object. This function initiates an asynchronous write
    operation and returns. We'll consider this function in a moment. The `main()`
    function continues with calling the `run()` method on the object of the `asio::io_service`
    class, where Boost.Asio *captures* the thread of execution and uses it to call
    the callback functions associated with asynchronous operations when they get completed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数分配、打开并同步地将套接字连接到远程应用程序，然后通过传递套接字对象的指针调用`writeToSocket()`函数。此函数启动异步写入操作并返回。我们稍后将考虑此函数。`main()`函数继续调用`asio::io_service`类对象的`run()`方法，其中Boost.Asio捕获执行线程，并在异步操作完成时使用它来调用相关的回调函数。'
- en: The `asio::os_service::run()` method blocks, as long as, at least one pending
    asynchronous operation. When the last callback of the last pending asynchronous
    operation is completed, this method returns.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::os_service::run()`方法在至少有一个挂起的异步操作时阻塞。当最后一个挂起的异步操作的最后一个回调完成时，此方法返回。'
- en: Now, let's come back to the `writeToSocket()` function and analyze its behavior.
    It begins with allocating an instance of the `Session` data structure in the free
    memory. Then, it allocates and fills the buffer with the data to be written to
    the socket. After this, a pointer to the socket object and the buffer are stored
    in the `Session` object. Because the socket's `async_write_some()` method may
    not write all the data to the socket in one go, we may need to initiate another
    asynchronous write operation in a callback function. That's why we need the `Session`
    object and we allocate it in the free memory and not on the stack; it must *live*
    until the callback function is called.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`writeToSocket()`函数并分析其行为。它首先在空闲内存中分配`Session`数据结构的一个实例。然后，它分配并填充缓冲区，以包含要写入套接字的数据。之后，将套接字对象的指针和缓冲区存储在`Session`对象中。由于套接字的`async_write_some()`方法可能不会一次性将所有数据写入套接字，我们可能需要在回调函数中启动另一个异步写入操作。这就是为什么我们需要`Session`对象，并且我们将其分配在空闲内存中而不是栈上；它必须*存活*直到回调函数被调用。
- en: 'Finally, we initiate the asynchronous operation, calling the socket object''s
    `async_write_some()` method. The invocation of this method is somewhat complex,
    and, therefore, let''s consider this in more detail:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动异步操作，调用套接字对象的`async_write_some()`方法。此方法的调用相对复杂，因此让我们更详细地考虑这一点：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first argument is a buffer that contains data to be written to the socket.
    Because the operation is asynchronous, this buffer may be accessed by Boost.Asio
    at any moment between operation initiation and when the callback is called. This
    means that the buffer must stay intact and must be available until the callback
    is called. We guarantee this by storing the buffer in a `Session` object, which
    in turn is stored in the free memory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是包含要写入套接字的数据的缓冲区。由于操作是异步的，Boost.Asio可能在操作启动和回调调用之间的任何时刻访问此缓冲区。这意味着缓冲区必须保持完整，并且必须在回调调用之前可用。我们通过将缓冲区存储在`Session`对象中，而`Session`对象又存储在空闲内存中，来保证这一点。
- en: The second argument is a callback that is to be invoked when the asynchronous
    operation is completed. Boost.Asio defines a callback as a *concept*, which can
    be a function or a functor, that accepts two arguments. The first argument of
    the callback specifies an error that occurs while the operation is being executed,
    if any. The second argument specifies the number of bytes written by the operation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是在异步操作完成后要调用的回调。Boost.Asio将回调定义为一种*概念*，它可以是一个函数或函数对象，接受两个参数。回调的第一个参数指定在操作执行过程中发生的错误（如果有）。第二个参数指定操作写入的字节数。
- en: Because we want to pass an additional argument to our callback function, a pointer
    to the corresponding `Session` object, which acts as a context for the operation,
    we use the `std::bind()` function to construct a function object to which we attach
    a pointer to the `Session` object as the third argument. The function object is
    then passed as a callback argument to the socket object's `async_write_some()`
    method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想向回调函数传递一个额外的参数，即指向相应 `Session` 对象的指针，该对象作为操作的上下文，所以我们使用 `std::bind()` 函数构建一个函数对象，并将指向
    `Session` 对象的指针作为第三个参数附加到该对象上。然后，将这个函数对象作为回调参数传递给套接字对象的 `async_write_some()` 方法。
- en: Because it is asynchronous, the `async_write_some()` method doesn't block the
    thread of execution. It initiates the writing operation and returns.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是异步的，`async_write_some()` 方法不会阻塞执行线程。它启动写入操作并返回。
- en: The actual writing operation is executed behind the scenes by the Boost.Asio
    library and underlying operating system, and when the operation is complete or
    an error occurs, the callback is invoked.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的写入操作由 Boost.Asio 库和底层操作系统在幕后执行，当操作完成或发生错误时，会调用回调函数。
- en: 'When invoked, the callback function named, literally, `callback` in our sample
    application begins with checking whether the operation succeeded or an error occurred.
    In the latter case, the error information is output to the standard output stream
    and the function returns. Otherwise, the counter of the total written bytes is
    increased by the number of bytes written as a result of an operation. Then, we
    check whether the total number of bytes written to the socket is equal to the
    size of the buffer. If these values are equal, this means that all the data has
    been written to the socket and there is no more work to do. The callback function
    returns. However, if there is still data in the buffer that is to be written,
    a new asynchronous write operation is initiated:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，名为 `callback` 的回调函数（在我们的示例应用程序中直接称为 `callback`）首先检查操作是否成功或发生错误。在后一种情况下，错误信息会被输出到标准输出流，并且函数返回。否则，总写入字节数会增加由操作产生的字节数。然后，我们检查写入套接字的总字节数是否等于缓冲区的大小。如果这些值相等，这意味着所有数据都已写入套接字，没有更多的工作要做。回调函数返回。然而，如果缓冲区中仍有要写入的数据，则会启动一个新的异步写入操作：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note how the beginning of the buffer is shifted by the number of bytes already
    written, and how the size of the buffer is decreased by the same value, correspondingly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缓冲区开始部分是如何根据已写入的字节数进行偏移的，以及缓冲区大小相应地减少了多少。
- en: As a callback, we specify the same `callback()` function using the `std::bind()`
    function to attach an additional argument—the `Session` object, just like we did
    when we initiated the first asynchronous operation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回调，我们使用 `std::bind()` 函数指定相同的 `callback()` 函数，并附加一个额外的参数——`Session` 对象，就像我们在启动第一个异步操作时做的那样。
- en: The cycles of initiation of an asynchronous writing operation and consequent
    callback invocation repeat until all the data from the buffer is written to the
    socket or an error occurs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 异步写入操作的启动和后续回调调用的周期会重复，直到缓冲区中的所有数据都写入套接字或发生错误。
- en: When the `callback` function returns without initiating a new asynchronous operation,
    the `asio::io_service::run()` method, called in the `main()` function, unblocks
    the thread of execution and returns. The `main()` function returns as well. This
    is when the application exits.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `callback` 函数返回而不启动新的异步操作时，在 `main()` 函数中调用的 `asio::io_service::run()` 方法会解除执行线程的阻塞并返回。`main()`
    函数也会返回。这时，应用程序退出。
- en: There's more...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Although the `async_write_some()` method described in the previous sample allows
    asynchronously writing data to the socket, the solution based on it is somewhat
    complex and error-prone. Fortunately, Boost.Asio provides a more convenient way
    to asynchronously write data to a socket using the free function `asio::async_write()`.
    Let''s consider one of its overloads:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面示例中描述的 `async_write_some()` 方法允许异步地将数据写入套接字，但基于它的解决方案相对复杂且容易出错。幸运的是，Boost.Asio
    提供了一种更方便的方法，使用自由函数 `asio::async_write()` 来异步写入套接字数据。让我们考虑它的一个重载版本：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is very similar to the socket's `async_write_some()` method. Its
    first argument is an object that satisfies the requirements of the `AsyncWriteStream`
    concept. For the complete list of the requirements, refer to the corresponding
    Boost.Asio documentation section at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html).
    The object of the `asio::ip::tcp::socket` class satisfies these requirements and,
    therefore, can be used with this function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与套接字的`async_write_some()`方法非常相似。其第一个参数是一个满足`AsyncWriteStream`概念要求的对象。关于要求完整列表，请参阅相应的Boost.Asio文档部分，[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncWriteStream.html)。`asio::ip::tcp::socket`类的对象满足这些要求，因此可以与该函数一起使用。
- en: The second and the third arguments of the `asio::async_write()` function are
    similar to the first and second arguments of the `async_write_some()` method of
    a TCP socket object described in the previous sample. These arguments are buffers
    that contain data that is to be written and functions or objects that represent
    a callback, which will be called when the operation is completed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::async_write()`函数的第二个和第三个参数与前面示例中描述的TCP套接字对象的`async_write_some()`方法的第一个和第二个参数类似。这些参数是包含要写入的数据的缓冲区，以及表示回调的函数或对象，当操作完成时将被调用。'
- en: In contrast to the socket's `async_write_some()` method, which initiates the
    operation that writes *some* amount of data from the buffer to the socket, the
    `asio::async_write()` function initiates the operation, which writes all the data
    available in the buffer. In this case, the callback is called only when all the
    data available in the buffer is written to the socket or when an error occurs.
    This simplifies writing to the socket and makes the code shorter and cleaner.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与套接字的`async_write_some()`方法不同，后者启动从缓冲区到套接字的写入操作，写入*一些*数据量，而`asio::async_write()`函数启动的操作则是写入缓冲区中所有可用的数据。在这种情况下，回调函数仅在缓冲区中所有数据都写入套接字或发生错误时被调用。这简化了套接字的写入操作，并使代码更短更整洁。
- en: If we change our previous sample so that it uses the `asio::async_write()` function
    instead of the socket object's `async_write_some()` method to write data to the
    socket asynchronously, our application becomes significantly simpler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的示例修改为使用`asio::async_write()`函数而不是套接字对象的`async_write_some()`方法来异步写入套接字数据，那么我们的应用程序将变得更加简单。
- en: 'Firstly, we don''t need to keep track of the number of bytes written to the
    socket, so therefore, the `Session` structure becomes smaller:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不需要跟踪写入套接字字节数，因此，`Session`结构变得更小：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Secondly, we know that when the callback function is invoked, it means that
    either all the data from the buffer has been written to the socket or an error
    has occurred. This makes the callback function much simpler:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们知道当回调函数被调用时，这意味着缓冲区中的所有数据都已写入套接字或发生了错误。这使得回调函数变得更加简单：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `asio::async_write()` function is implemented by means of zero or more calls
    to the socket object's `async_write_some()` method. This is similar to how the
    `writeToSocket()` function in our initial sample is implemented.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::async_write()`函数是通过零个或多个对套接字对象的`async_write_some()`方法的调用实现的。这类似于我们初始示例中的`writeToSocket()`函数的实现。'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `asio::async_write()` function has three more overloads, providing
    additional functionalities. Some of them may be very useful in specific circumstances.
    Refer to the Boost.Asio documentation to find out more about this function at
    [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asio::async_write()`函数有三个额外的重载，提供了额外的功能。在某些特定情况下，其中一些可能非常有用。有关此函数的更多信息，请参阅Boost.Asio文档，[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_write.html)。
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing to a TCP socket synchronously* recipe describes how to write data
    to a TCP socket synchronously
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步写入TCP套接字*配方描述了如何同步地将数据写入TCP套接字'
- en: The *Implementing an asynchronous TCP client* recipe in [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    demonstrates how to implement an asynchronous TCP client that performs asynchronous
    writing to a TCP socket to send request messages to the server
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3章*实现客户端应用程序*中的*实现异步TCP客户端*配方（ch03.html "第3章。实现客户端应用程序"），展示了如何实现一个异步TCP客户端，该客户端执行异步写入TCP套接字以向服务器发送请求消息。
- en: The *Implementing an asynchronous TCP server* recipe in [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    demonstrates how to implement an asynchronous TCP server that performs asynchronous
    writing to a TCP socket to send response messages to the client
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4章*实现服务器应用程序*中的*实现异步TCP服务器*配方（ch04.html "第4章。实现服务器应用程序"），展示了如何实现一个异步TCP服务器，该服务器执行异步写入TCP套接字以向客户端发送响应消息。
- en: Reading from a TCP socket asynchronously
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步从TCP套接字读取
- en: Asynchronous reading is a flexible and efficient way to receive data from a
    remote application. In this recipe, we will see how to read data from a TCP socket
    asynchronously.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 异步读取是一种灵活且高效地从远程应用程序接收数据的方式。在本配方中，我们将了解如何从TCP套接字异步读取数据。
- en: How to do it…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The most basic tool used to asynchronously read data from a TCP socket provided
    by the Boost.Asio library is the `async_read_some()` method of the `asio::ip::tcp::socket`
    class. Here is one of the method''s overloads:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio库提供的用于异步从TCP套接字读取数据的最基本工具是`asio::ip::tcp::socket`类的`async_read_some()`方法。以下是该方法的一个重载示例：
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method initiates an asynchronous read operation and returns immediately.
    It accepts an object that represents a mutable buffer as its first argument to
    which the data will be read from the socket. The second argument is a callback
    that is called by Boost.Asio when the operation is completed. This argument can
    be a function pointer, a functor, or any other object that satisfies the requirements
    of the `ReadHandler` concept. The complete list of the requirements can be found
    in the corresponding section of the Boost.Asio documentation at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法启动一个异步读取操作并立即返回。它接受一个表示可变缓冲区的对象作为其第一个参数，数据将从套接字读取到该对象中。第二个参数是Boost.Asio在操作完成时调用的回调。此参数可以是函数指针、仿函数或满足`ReadHandler`概念要求的任何其他对象。完整的要求列表可以在Boost.Asio文档的相应部分中找到，请参阅[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ReadHandler.html)。
- en: 'The callback should have the following signature:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 回调应具有以下签名：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `ec` is an argument that notifies an error code if one occurs, and the
    `bytes_transferred` argument indicates how many bytes have been read from the
    socket during the corresponding asynchronous operation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ec`是一个参数，如果发生错误，则通知错误代码，而`bytes_transferred`参数指示在相应的异步操作期间从套接字中读取了多少字节。
- en: As the `async_read_some()` method's name suggests, it initiates an operation
    that is intended to read *some* amount of data from the socket to the buffer.
    This method guarantees that at least one byte will be read during the corresponding
    asynchronous operation if an error does not occur. This means that, in a general
    case, in order to read all the data from the socket, we may need to perform this
    asynchronous operation several times.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如`async_read_some()`方法的名字所暗示的，它启动一个操作，目的是从套接字到缓冲区读取*一些*数据。如果未发生错误，此方法保证在相应的异步操作期间至少读取一个字节。这意味着，在一般情况下，为了从套接字读取所有数据，我们可能需要执行此异步操作多次。
- en: Now that we know how the key method works, let's see how to implement an application
    that performs asynchronous reading from the socket.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了关键方法的工作原理，让我们看看如何实现一个从套接字执行异步读取的应用程序。
- en: 'The following algorithm describes the steps required to implement an application,
    which reads data from a socket asynchronously. Note that this algorithm provides
    a *possible* way to implement such an application. Boost.Asio is quite flexible
    and allows us to organize and structure the application by reading data from a
    socket asynchronously in different ways:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了实现一个从套接字异步读取数据的应用程序所需的步骤。请注意，此算法提供了一个*可能*的实现此类应用程序的方法。Boost.Asio非常灵活，允许我们通过以不同方式从套接字异步读取数据来组织和结构化应用程序：
- en: Define a data structure that contains a pointer to a socket object, a buffer,
    a variable that defines the size of the buffer, and a variable used as a counter
    of bytes read.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含指向套接字对象的指针、一个缓冲区、一个定义缓冲区大小的变量以及一个用作读取的字节数计数器的变量的数据结构。
- en: Define a callback function that will be called when an asynchronous reading
    operation is completed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个回调函数，当异步读取操作完成时将被调用。
- en: In a client application, allocate and open an active TCP socket, and then, connect
    it to a remote application. In a server application, obtain a connected active
    TCP socket by accepting a connection request.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，分配并打开一个活动TCP套接字，然后将其连接到远程应用程序。在服务器应用程序中，通过接受连接请求来获取一个已连接的活动TCP套接字。
- en: Allocate a buffer big enough for the expected message to fit in.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个足够大的缓冲区，以便预期的消息可以容纳。
- en: Initiate an asynchronous reading operation by calling the socket's `async_read_some()`
    method, specifying a function defined in step 2 as a callback.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的`async_read_some()`方法并指定步骤2中定义的函数作为回调来启动异步读取操作。
- en: Call the `run()` method on an object of the `asio::io_service` class.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`asio::io_service`类的对象上调用`run()`方法。
- en: In a callback, increase the counter of bytes read. If the number of bytes read
    is less than the total amount of bytes to be read (that is, the size of an expected
    message), initiate a new asynchronous reading operation to read the next portion
    of data.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调中，增加读取的字节数计数器。如果读取的字节数少于要读取的总字节数（即预期消息的大小），则启动一个新的异步读取操作以读取下一部分数据。
- en: Let's implement a sample client application which will perform asynchronous
    reading in accordance with the preceding algorithm.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个示例客户端应用程序，该程序将根据前面的算法执行异步读取。
- en: 'We begin with adding the `include` and `using` directives:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加`include`和`using`指令开始：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, according to step 1, we define a data structure that contains a pointer
    to the socket object named `sock`, a pointer to the buffer named `buf`, a variable
    named `buf_size` that contains the size of the buffer, and a `total_bytes_read`
    variable that contains the number of bytes already read:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据步骤1，我们定义一个包含名为`sock`的套接字对象指针、名为`buf`的缓冲区指针、名为`buf_size`的变量（包含缓冲区大小）以及包含已读取的字节数的`total_bytes_read`变量的数据结构：
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In step 2, we define a callback function, which will be called when asynchronous
    operation is completed:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们定义了一个回调函数，当异步操作完成时将被调用：
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s skip step 3 for now and implement steps 4 and 5 in a separate function.
    Let''s name this function `readFromSocket()`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时跳过步骤3，并在一个单独的函数中实现步骤4和5。让我们把这个函数命名为`readFromSocket()`：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we come back to step 3 and implement it in the application''s `main()`
    entry point function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到步骤3，并在应用程序的`main()`入口点函数中实现它：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now, let's track the application's execution path to better understand how it
    works.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跟踪应用程序的执行路径，以便更好地理解它是如何工作的。
- en: The application is run by a single thread; in the context of which the application's
    `main()` entry point function is called. Note that Boost.Asio may create additional
    threads for some internal operations, but it guarantees that no application code
    is called in the context of those threads.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由单个线程运行；在这个上下文中，调用应用程序的`main()`入口点函数。请注意，Boost.Asio可能会为某些内部操作创建额外的线程，但它保证不会在那些线程的上下文中调用应用程序代码。
- en: The `main()` function begins with allocating, opening, and connecting a socket
    to a remote application. Then, it calls the `readFromSocket()` function and passes
    a pointer to the socket object as an argument. The `readFromSocket()` function
    initiates an asynchronous reading operation and returns. We'll consider this function
    in a moment. The `main()` function continues with calling the `run()` method on
    the object of the `asio::io_service` class, where Boost.Asio *captures* the thread
    of execution and uses it to call the callback functions associated with asynchronous
    operations when they get completed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数开始于分配、打开并将套接字连接到远程应用程序。然后，它调用`readFromSocket()`函数，并将套接字对象的指针作为参数传递。`readFromSocket()`函数启动一个异步读取操作并返回。我们稍后将考虑这个函数。`main()`函数继续调用`asio::io_service`类的对象的`run()`方法，其中Boost.Asio捕获执行线程，并在异步操作完成时使用它来调用相关的回调函数。'
- en: The `asio::io_service::run()` method blocks as long as there is at least one
    pending asynchronous operation. When the last callback of the last pending operation
    is completed, this method returns.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::io_service::run()` 方法会阻塞，直到至少有一个挂起的异步操作。当最后一个挂起的操作的最后一个回调完成时，此方法返回。'
- en: Now, let's come back to the `readFromSocket()` function and analyze its behavior.
    It begins with allocating an instance of the `Session` data structure in the free
    memory. Then, it allocates a buffer and stores a pointer to it in a previously
    allocated instance of the `Session` data structure. A pointer to the socket object
    and the size of the buffer are stored in the `Session` data structure as well.
    Because the socket's `async_read_some()` method may not read all the data in one
    go, we may need to initiate another asynchronous reading operation in the callback
    function. This is why we need the `Session` data structure and why we allocate
    it in the free memory and not on a stack. This structure and all the objects that
    reside in it must *live* at least until the callback is invoked.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `readFromSocket()` 函数并分析其行为。它首先在空闲内存中分配 `Session` 数据结构的一个实例。然后，它分配一个缓冲区并将指向它的指针存储在先前分配的
    `Session` 数据结构实例中。将套接字对象的指针和缓冲区的大小存储在 `Session` 数据结构中。因为套接字的 `async_read_some()`
    方法可能不会一次性读取所有数据，我们可能需要在回调函数中启动另一个异步读取操作。这就是为什么我们需要 `Session` 数据结构，以及为什么我们在空闲内存中而不是在栈上分配它的原因。这个结构和其中驻留的所有对象至少必须持续到回调被调用。
- en: 'Finally, we initiate the asynchronous operation, calling the socket object''s
    `async_read_some()` method. The invocation of this method is somewhat complex;
    therefore, let''s take a look at it in more detail:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动异步操作，调用套接字对象的 `async_read_some()` 方法。这个方法的调用有些复杂；因此，让我们更详细地看看它：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first argument is the buffer to which the data will be read. Because the
    operation is asynchronous, this buffer may be accessed by Boost.Asio at any moment
    between the operation initiation and when the callback is invoked. This means
    that the buffer must stay intact and be available until the callback is invoked.
    We guarantee this by allocating the buffer in the free memory and storing it in
    the `Session` data structure, which in turn is allocated in the free memory as
    well.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要读取数据的缓冲区。由于操作是异步的，Boost.Asio 可能在任何时刻（从操作启动到回调被调用之间）访问这个缓冲区。这意味着缓冲区必须保持完整并在回调被调用之前可用。我们通过在空闲内存中分配缓冲区并将其存储在
    `Session` 数据结构中来保证这一点，而 `Session` 数据结构本身也是在空闲内存中分配的。
- en: The second argument is a callback that is to be invoked when the asynchronous
    operation is completed. Boost.Asio defines a callback as a concept, which can
    be a function or a functor, that accepts two arguments. The first argument of
    the callback specifies an error that occurs while the operation is being executed,
    if any. The second argument specifies the number of bytes read by the operation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个在异步操作完成后要调用的回调函数。Boost.Asio 将回调定义为一种概念，它可以是一个函数或仿函数，接受两个参数。回调的第一个参数指定在操作执行过程中发生的错误（如果有）。第二个参数指定操作读取的字节数。
- en: Because we want to pass an additional argument to our callback function, a pointer
    to the corresponding `Session` object, which serves as a context for the operation—we
    use the `std::bind()` function to construct a function object to which we attach
    a pointer to the `Session` object as the third argument. The function object is
    then passed as a callback argument to the socket object's `async_write_some()`
    method.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想向我们的回调函数传递一个额外的参数，即指向相应 `Session` 对象的指针，该对象作为操作的上下文——我们使用 `std::bind()`
    函数来构造一个函数对象，我们将指向 `Session` 对象的指针作为第三个参数附加到该函数对象上。然后，将这个函数对象作为回调参数传递给套接字对象的 `async_write_some()`
    方法。
- en: Because it is asynchronous, the `async_write_some()` method doesn't block the
    thread of execution. It initiates the reading operation and returns.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是异步的，所以 `async_write_some()` 方法不会阻塞执行线程。它启动读取操作然后返回。
- en: The actual reading operation is executed behind the scenes by the Boost.Asio
    library and underlying operating system, and when the operation is completed or
    an error occurs, the callback is invoked.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的读取操作由 Boost.Asio 库和底层操作系统在幕后执行，当操作完成或发生错误时，会调用回调。
- en: 'When invoked, the callback function named, literally, `callback` in our sample
    application begins with checking whether the operation succeeded or an error occurred.
    In the latter case, the error information is output to the standard output stream
    and the function returns. Otherwise, the counter of the total read bytes is increased
    by the number of bytes read as a result of the operation. Then, we check whether
    the total number of bytes read from the socket is equal to the size of the buffer.
    If these values are equal, it means that the buffer is full and there is no more
    work to do. The callback function returns. However, if there is still some space
    in the buffer, we need to continue with reading; therefore, we initiate a new
    asynchronous reading operation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，名为 `callback` 的回调函数（在我们的示例应用程序中直接称为 `callback`）首先检查操作是否成功或发生错误。在后一种情况下，错误信息会被输出到标准输出流，并且函数返回。否则，总读取字节数会增加操作结果读取的字节数。然后，我们检查从套接字读取的总字节数是否等于缓冲区的大小。如果这两个值相等，这意味着缓冲区已满，没有更多工作要做。回调函数返回。然而，如果缓冲区中仍有空间，我们需要继续读取；因此，我们启动一个新的异步读取操作：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the beginning of the buffer is shifted by the number of bytes already
    read and the size of the buffer is decreased by the same value, respectively.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，缓冲区的开始位置会根据已读取的字节数进行偏移，并且缓冲区的大小会相应减少。
- en: As a callback, we specify the same `callback` function using the `std::bind()`
    function to attach an additional argument—the `Session` object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回调，我们使用 `std::bind()` 函数指定相同的 `callback` 函数，以附加一个额外的参数——`Session` 对象。
- en: The cycles of initiation of an asynchronous reading operation and consequent
    callback invocation repeat until the buffer is full or an error occurs.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 异步读取操作启动和后续回调调用的周期会一直重复，直到缓冲区满或发生错误。
- en: When the `callback` function returns without initiating a new asynchronous operation,
    the `asio::io_service::run()` method, called in the `main()` function, unblocks
    the thread of execution and returns. The `main()` function returns as well. This
    is when the application exits.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `callback` 函数返回而不启动新的异步操作时，在 `main()` 函数中调用的 `asio::io_service::run()` 方法将执行线程解锁并返回。此时，`main()`
    函数也会返回。这就是应用程序退出的时刻。
- en: There's more...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Although the `async_read_some()` method, as described in the previous sample,
    allows asynchronously reading data from the socket, the solution based on it is
    somewhat complex and error-prone. Fortunately, Boost.Asio provides a more convenient
    way to asynchronously read data from a socket: the free function `asio::async_read()`.
    Let''s consider one of its overloads:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面示例中描述的 `async_read_some()` 方法允许异步从套接字读取数据，但基于它的解决方案相对复杂且容易出错。幸运的是，Boost.Asio
    提供了一种更方便的方式异步从套接字读取数据：免费函数 `asio::async_read()`。让我们考虑其重载之一：
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function is very similar to the socket's `async_read_some()` method. Its
    first argument is an object that satisfies the requirements of the `AsyncReadStream`
    concept. For the complete list of the requirements, refer to the corresponding
    Boost.Asio documentation section at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html).
    The object of the `asio::ip::tcp::socket` class satisfies these requirements and,
    therefore, can be used with this function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与套接字的 `async_read_some()` 方法非常相似。它的第一个参数是一个满足 `AsyncReadStream` 概念要求的对象。关于要求的完整列表，请参阅相应的
    Boost.Asio 文档部分，链接为 [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/AsyncReadStream.html)。`asio::ip::tcp::socket`
    类的对象满足这些要求，因此可以与该函数一起使用。
- en: The second and third arguments of the `asio::async_read()` function are similar
    to the first and second arguments of the `async_read_some()` method of a TCP socket
    object described in the previous sample. These arguments are buffers used as data
    destination points and functions or objects that represent a callback, which will
    be called when the operation is completed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::async_read()` 函数的第二个和第三个参数与前面示例中描述的 TCP 套接字对象的 `async_read_some()` 方法的第一个和第二个参数类似。这些参数用作数据目的点的缓冲区以及表示回调的函数或对象，当操作完成时将被调用。'
- en: In contrast to the socket's `async_read_some()` method, which initiates the
    operation, that reads *some* amount of data from the socket to the buffer, the
    `asio::async_read()` function initiates the operation that reads the data from
    the socket until the buffer passed to it as an argument is full. In this case,
    the callback is called when the amount of data read is equal to the size of the
    provided buffer or when an error occurs. This simplifies reading from the socket
    and makes the code shorter and cleaner.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与`async_read_some()`方法不同，后者启动操作，从套接字读取*一些*数据到缓冲区，`asio::async_read()`函数启动的操作是从套接字读取数据，直到作为参数传递给它的缓冲区满为止。在这种情况下，当读取的数据量等于提供的缓冲区大小时，或者当发生错误时，会调用回调函数。这简化了从套接字读取的过程，并使代码更短更整洁。
- en: If we change our previous sample so that it uses the `asio::async_read()` function
    instead of the socket object's `async_read_some()` method to read data from the
    socket asynchronously, our application becomes significantly simpler.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的示例修改为使用`asio::async_read()`函数而不是套接字对象的`async_read_some()`方法来异步从套接字读取数据，那么我们的应用程序将变得更加简单。
- en: 'Firstly, we don''t need to keep track of the number of bytes read from the
    socket; therefore, the `Session` structure becomes smaller:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不需要跟踪从套接字读取的字节数；因此，`Session`结构变得更小：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Secondly, we know that when the callback function is invoked, it means that
    either an expected amount of data has been read from the socket or an error has
    occurred. This makes the callback function much simpler:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们知道当回调函数被调用时，这意味着要么已从套接字读取了预期数量的数据，要么发生了错误。这使得回调函数变得更加简单：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `asio::async_read()` function is implemented by means of zero or more calls
    to the socket object's `async_read_some()` method. This is similar to how the
    `readFromSocket()` function in our initial sample is implemented.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::async_read()`函数是通过零个或多个调用套接字对象的`async_read_some()`方法实现的。这与我们初始示例中的`readFromSocket()`函数的实现方式相似。'
- en: Note
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `asio::async_read()` function has three more overloads, providing
    additional functionalities. Some of them may be very useful in specific circumstances.
    Refer to the Boost.Asio documentation to find out about this at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asio::async_read()`函数有三个额外的重载，提供了额外的功能。在某些特定情况下，其中一些可能非常有用。请参阅Boost.Asio文档了解详情，链接为[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read.html)。
- en: See also
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reading from a TCP socket synchronously* recipe describes how to read data
    from a TCP socket synchronously
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从TCP套接字同步读取*配方描述了如何从TCP套接字同步读取数据'
- en: The *Implementing an asynchronous TCP client* recipe in [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    demonstrates how to implement an asynchronous TCP client that performs asynchronous
    reading from a TCP socket to receive response messages sent by the server
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。实现客户端应用程序")的*实现异步TCP客户端*配方中，*实现客户端应用程序*，展示了如何实现一个异步TCP客户端，该客户端从TCP套接字异步读取以接收服务器发送的响应消息
- en: The *Implementing an asynchronous TCP server* recipe in [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    demonstrates how to implement an asynchronous TCP server that performs asynchronous
    reading from a TCP socket to receive request messages from the client
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。实现服务器应用程序")的*实现异步TCP服务器*配方中，*实现服务器应用程序*，展示了如何实现一个异步TCP服务器，该服务器从TCP套接字异步读取以接收客户端发送的请求消息
- en: Canceling asynchronous operations
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: Sometimes, after an asynchronous operation has been initiated and has not yet
    completed, the conditions in the application may change so that the initiated
    operation becomes irrelevant or outdated and nobody is interested in the completion
    of the operation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在异步操作已启动但尚未完成时，应用程序中的条件可能会发生变化，使得启动的操作变得无关紧要或过时，没有人对操作完成感兴趣。
- en: In addition to this, if an initiated asynchronous operation is a reaction to
    a user command, the user may change their mind while the operation is being executed.
    The user may want to discard the previous issued command and may want to issue
    a different one or decide to exit from the application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果启动的异步操作是对用户命令的反应，那么在操作执行过程中，用户可能会改变主意。用户可能想要取消之前发出的命令，并可能想要发出不同的命令或决定退出应用程序。
- en: Consider a situation where a user types a website address in a typical web browser's
    address bar and hits the *Enter* key. The browser immediately initiates a DNS
    name resolution operation. When the DNS name is resolved and the corresponding
    IP address is obtained, it initiates the connection operation to connect to the
    corresponding web server. When a connection is established, the browser initiates
    an asynchronous write operation to send a request to the server. Finally, when
    the request is sent, the browser starts waiting for the response message. Depending
    on the responsiveness of the server application, the volume of the data transmitted
    over the network, the state of the network, and other factors, all these operations
    may take a substantial amount of time. And the user while waiting for the requested
    web page to be loaded, may change their mind, and before the page gets loaded,
    the user may type another website address in the address bar and hit *Enter*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，用户在典型的网络浏览器地址栏中输入一个网站地址并按下*Enter*键。浏览器立即启动DNS名称解析操作。当DNS名称解析并获取相应的IP地址后，它启动连接操作以连接到相应的Web服务器。当建立连接后，浏览器启动异步写入操作以向服务器发送请求。最后，当请求发送后，浏览器开始等待响应消息。根据服务器应用程序的响应速度、通过网络传输的数据量、网络状态和其他因素，所有这些操作可能需要相当长的时间。而在等待请求的网页加载时，用户可能会改变主意，在页面加载完成之前，用户可能在地址栏中输入另一个网站地址并按下*Enter*。
- en: Another (extreme) situation is where a client application sends a request to
    the server application and starts waiting for the response message, but the server
    application while processing the client's request, gets into a deadlock due to
    bugs in it. In this case, the user would have to wait forever for the response
    message and would never get it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个（极端）的情况是，客户端应用程序向服务器应用程序发送请求并开始等待响应消息，但服务器应用程序在处理客户端请求时，由于自身中的错误而陷入死锁。在这种情况下，用户将不得不永远等待响应消息，并且永远不会收到它。
- en: In both the cases, the user of the client application would benefit from having
    the ability to cancel the operation they initiated before it completes. In general,
    it is a good practice to provide the user with the ability to cancel an operation
    that may take a noticeable amount of time. Because the network communication operations
    fall into a class of operations that may last for unpredictably long periods of
    time, it is important to support the cancelation of operations in distributed
    applications that communicate over the network.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，客户端应用程序的用户将受益于在操作完成之前取消他们启动的操作的能力。一般来说，提供一个用户可以取消可能需要明显时间的操作的能力是一个好的实践。因为网络通信操作可能持续不可预测的长时间，所以在通过网络通信的分布式应用程序中支持操作的取消非常重要。
- en: One of the benefits of asynchronous operations provided by the Boost.Asio library
    is that they can be canceled at any moment after the initiation. In this recipe,
    we'll see how to cancel asynchronous operations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio库提供的异步操作的一个好处是它们可以在启动后的任何时刻取消。在这个菜谱中，我们将看到如何取消异步操作。
- en: How to do it…
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'The following algorithm provides the steps required to initiate and cancel
    asynchronous operations with Boost.Asio:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法提供了使用Boost.Asio初始化和取消异步操作的步骤：
- en: If the application is intended to run on Windows XP or Windows Server 2003,
    define flags that enable asynchronous operation canceling on these versions of
    Windows.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序旨在在Windows XP或Windows Server 2003上运行，则定义启用这些Windows版本的异步操作取消的标志。
- en: Allocate and open a TCP or UDP socket. It may be an active or passive (acceptor)
    socket in the client or server application.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配并打开一个TCP或UDP套接字。它可能是客户端或服务器应用程序中的活动套接字或被动（接受者）套接字。
- en: Define a callback function or functor for an asynchronous operation. If needed,
    in this callback, implement a branch of code that handles the situation when the
    operation has been canceled.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于异步操作的回调函数或仿函数。如果需要，在这个回调中实现一段代码分支，用于处理操作被取消的情况。
- en: Initiate one or more asynchronous operations and specify a function or an object
    defined in step 4 as a callback.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个或多个异步操作，并指定步骤4中定义的函数或对象作为回调。
- en: Spawn an additional thread and use it to run the Boost.Asio event loop.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个额外的线程并使用它来运行Boost.Asio事件循环。
- en: Call the `cancel()` method on the socket object to cancel all the outstanding
    asynchronous operations associated with this socket.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在套接字对象上调用`cancel()`方法以取消与此套接字相关联的所有挂起的异步操作。
- en: Let's consider the implementation of the client application designed in accordance
    with the presented algorithm in which an asynchronous *connection* operation is
    first initiated and then canceled.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个客户端应用程序的实现，该应用程序按照所提出的算法设计，首先启动一个异步*连接*操作，然后取消该操作。
- en: According to step 1, to compile and run our code on Windows XP or Windows Server
    2003, we need to define some flags that control the behavior of the Boost.Asio
    library with regard to which mechanisms of the underlying OS to exploit.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 根据步骤1，为了在Windows XP或Windows Server 2003上编译和运行我们的代码，我们需要定义一些标志来控制Boost.Asio库对底层OS机制的使用行为。
- en: By default, when it is compiled for Windows, Boost.Asio uses the I/O completion
    port framework to run operations asynchronously. On Windows XP and Windows Server
    2003, this framework has some issues and limitations with regard to the cancelation
    of an operation. Therefore, Boost.Asio requires developers to explicitly notify
    that they want to enable the asynchronous operation canceling functionality despite
    of the known issues, when targeting the application in versions of Windows in
    question. To do this, the `BOOST_ASIO_ENABLE_CANCELIO` macro must be defined before
    Boost.Asio headers are included. Otherwise, if this macro is not defined, while
    the source code of the application contains calls to asynchronous operations,
    cancelation methods and functions, the compilation will always fail.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当编译为Windows版本时，Boost.Asio使用I/O完成端口框架来异步运行操作。在Windows XP和Windows Server
    2003上，该框架在操作取消方面存在一些问题和限制。因此，Boost.Asio要求开发者明确通知他们希望在目标Windows版本的应用程序中启用异步操作取消功能，尽管已知存在这些问题。为此，必须在包含Boost.Asio头文件之前定义`BOOST_ASIO_ENABLE_CANCELIO`宏。否则，如果未定义此宏，而应用程序的源代码包含对异步操作、取消方法和函数的调用，则编译将始终失败。
- en: In other words, it is mandatory to define the `BOOST_ASIO_ENABLE_CANCELIO` macro,
    when targeting Windows XP or Windows Server 2003, and the application needs to
    cancel asynchronous operations.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当目标Windows XP或Windows Server 2003时，必须定义`BOOST_ASIO_ENABLE_CANCELIO`宏，并且应用程序需要取消异步操作。
- en: To get rid of issues and limitations imposed by the usage of the I/O completion
    port framework on Windows XP and Windows Server 2003, we can prevent Boost.Asio
    from using this framework by defining another macro named `BOOST_ASIO_DISABLE_IOCP`
    before including Boost.Asio headers. With this macro defined, Boost.Asio doesn't
    use the I/O completion port framework on Windows; and therefore, problems related
    to asynchronous operations canceling disappear. However, the benefits of scalability
    and efficiency of the I/O completion ports framework disappear too.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除Windows XP和Windows Server 2003上使用I/O完成端口框架带来的问题和限制，我们可以在包含Boost.Asio头文件之前定义另一个名为`BOOST_ASIO_DISABLE_IOCP`的宏。定义此宏后，Boost.Asio在Windows上不使用I/O完成端口框架；因此，与异步操作取消相关的问题消失。然而，I/O完成端口框架的可扩展性和效率优势也随之消失。
- en: Note that the mentioned issues and limitations related to asynchronous operation
    canceling do not exist on Windows Vista and Windows Server 2008 and later. Therefore,
    when targeting these versions of Windows, canceling works fine, and there is no
    need to disable the I/O completion port framework usage unless there is another
    reason to do so. Refer to the `asio::ip::tcp::cancel()` method's documentation
    section for more details on this issue at [http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与异步操作取消相关的所述问题和限制在Windows Vista和Windows Server 2008及以后的版本中不存在。因此，当目标这些版本的Windows时，取消操作可以正常工作，除非有其他原因需要禁用I/O完成端口框架的使用。有关此问题的更多详细信息，请参阅`asio::ip::tcp::cancel()`方法的文档部分，链接为[http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html)。
- en: In our sample, we will consider how to construct a cross-platform application
    that, when targeted at Windows during compilation, can be run on any Windows version,
    starting from Windows XP or Windows Server 2003\. Therefore, we define both the
    `BOOST_ASIO_DISABLE_IOCP` and `BOOST_ASIO_ENABLE_CANCELIO` macros.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将考虑如何构建一个跨平台应用程序，当在编译时针对Windows，可以从Windows XP或Windows Server 2003开始运行。因此，我们定义了`BOOST_ASIO_DISABLE_IOCP`和`BOOST_ASIO_ENABLE_CANCELIO`宏。
- en: To determine the target operating system at compile time, we use the `Boost.Predef`
    library. This library provides us with macro definitions that allow us to identify
    parameters of the environment in which the code is compiled as the target operating
    system family and its version, processor architecture, compiler, and many others.
    Refer to the Boost.Asio documentation section for more details on this library
    at [http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html](http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在编译时确定目标操作系统，我们使用`Boost.Predef`库。这个库为我们提供了宏定义，允许我们识别代码编译环境的参数，作为目标操作系统家族及其版本、处理器架构、编译器等。有关此库的更多详细信息，请参阅Boost.Asio文档部分，[http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html](http://www.boost.org/doc/libs/1_58_0/libs/predef/doc/html/index.html)。
- en: 'To use the `Boost.Predef` library, we include the following header file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Boost.Predef`库，我们需要包含以下头文件：
- en: '[PRE45]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we check whether the code is being compiled for Windows XP or Windows
    Server 2003, and if it is, we define the `BOOST_ASIO_DISABLE_IOCP` and `BOOST_ASIO_ENABLE_CANCELIO`
    macros:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查代码是否正在为Windows XP或Windows Server 2003编译，如果是，我们定义`BOOST_ASIO_DISABLE_IOCP`和`BOOST_ASIO_ENABLE_CANCELIO`宏：
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we include the common Boost.Asio header and standard library `<thread>`
    header. We will need the latter because we''ll spawn additional threads in our
    application. In addition to this, we specify a `using` directive to make the names
    of Boost.Asio classes and functions shorter and more convenient to use:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包含常见的Boost.Asio头文件和标准库`<thread>`头文件。我们还需要后者，因为我们在应用程序中会创建额外的线程。此外，我们指定一个`using`指令，使Boost.Asio类和函数的名称更短，更方便使用：
- en: '[PRE47]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we define the application''s `main()` entry point function, which contains
    all the functionalities of the application:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义应用程序的`main()`入口点函数，它包含应用程序的所有功能：
- en: '[PRE48]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now, let's analyze how the application works.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析应用程序的工作原理。
- en: Our sample client application consists of a single function, which is the application's
    `main()` entry point function. This function begins with allocating and opening
    a TCP socket according to step 2 of the algorithm.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例客户端应用程序由一个单一的功能组成，即应用程序的`main()`入口点函数。此函数从根据算法的第2步分配和打开TCP套接字开始。
- en: Next, the asynchronous connection operation is initiated on the socket. The
    callback provided to the method is implemented as a lambda function. This corresponds
    to steps 3 and 4 of the algorithm. Note how the fact that the operation was canceled
    is determined in the callback function. When an asynchronous operation is canceled,
    the callback is invoked and its argument that specifies the error code contains
    an OS dependent error code defined in Boost.Asio as `asio::error::operation_aborted`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在套接字上启动异步连接操作。提供给方法的回调实现为一个lambda函数。这对应于算法的第3步和第4步。注意，在回调函数中确定操作是否被取消。当异步操作被取消时，回调被调用，其参数指定了错误代码，包含在Boost.Asio中定义的与操作系统相关的错误代码`asio::error::operation_aborted`。
- en: Then, we spawn a thread named `worker_thread`, which will be used to run the
    Boost.Asio event loop. In the context of this thread, the callback function will
    be invoked by the library. The entry point function of the `worker_thread` thread
    is quite simple. It contains a `try-catch` block and a call to the `asio::io_service`
    object's `run()` method. This corresponds to step 5 of the algorithm.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`worker_thread`的线程，该线程将用于运行Boost.Asio事件循环。在这个线程的上下文中，回调函数将由库调用。`worker_thread`线程的入口点函数相当简单。它包含一个`try-catch`块和对`asio::io_service`对象`run()`方法的调用。这对应于算法的第5步。
- en: After the worker thread is spawned, the main thread is put to sleep for 2 seconds.
    This is to allow the connection operation to progress a bit and emulate what could
    be a delay between the two commands issued by the user in the real application;
    for example, a web browser.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建工作线程之后，主线程将休眠2秒钟。这是为了让连接操作有更多的时间进行，并模拟实际应用程序中用户发出的两个命令之间的延迟；例如，一个网页浏览器。
- en: According to the last step 6 of the algorithm, we call the socket object's `cancel()`
    method to cancel the initiated connection operation. At this point, if the operation
    has not yet finished, it will be canceled and the corresponding callback will
    be invoked with an argument that specifies the error code containing the `asio::error::operation_aborted`
    value to notify that the operation was canceled. However, if the operation has
    already finished, calling the `cancel()` method has no effect.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 根据算法的最后一步6，我们调用套接字对象的`cancel()`方法来取消已启动的连接操作。此时，如果操作尚未完成，它将被取消，并且相应的回调将使用一个指定包含`asio::error::operation_aborted`值的错误代码的参数来调用，以通知操作已被取消。然而，如果操作已经完成，调用`cancel()`方法将没有效果。
- en: When the callback function returns, the worker thread exits the event loop because
    there are no more outstanding asynchronous operations to be executed. As a result,
    the thread exits its entry point function. This leads to the main thread running
    to its completion as well. Eventually, the application exits.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调函数返回时，工作线程会退出事件循环，因为没有更多的挂起异步操作需要执行。因此，线程会退出其入口点函数。这导致主线程运行到完成。最终，应用程序退出。
- en: There's more...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In the previous sample, we considered the canceling of an asynchronous connection
    operation associated with an active TCP socket. However, any operation associated
    with both the TCP and UDP sockets can be canceled in a similar way. The `cancel()`
    method should be called on the corresponding socket object after the operation
    has been initiated.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们考虑了与活动TCP套接字相关联的异步连接操作的取消。然而，任何与TCP和UDP套接字都相关联的操作都可以以类似的方式取消。在操作启动后，应在相应的套接字对象上调用`cancel()`方法。
- en: In addition to this, the `async_resolve()` method of the `asio::ip::tcp::resolver`
    or `asio::ip::udp::resolver` class used to asynchronously resolve a DNS name can
    be canceled by calling the resolver object's `cancel()` method.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`asio::ip::tcp::resolver`或`asio::ip::udp::resolver`类的`async_resolve()`方法，用于异步解析DNS名称，可以通过调用解析器对象的`cancel()`方法来取消。
- en: All asynchronous operations initiated by the corresponding free functions provided
    by Boost.Asio can be canceled as well by calling the `cancel()` method on an object
    that was passed to the free function as the first argument. This object can represent
    either a socket (active or passive) or a resolver.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由Boost.Asio提供的相应免费函数启动的异步操作也可以通过在传递给免费函数的第一个参数的对象上调用`cancel()`方法来取消。此对象可以代表套接字（活动或被动）或解析器。
- en: See also
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing an asynchronous TCP client* recipe in [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    demonstrates how to construct a more complex client application that supports
    the asynchronous operation cancelation functionality
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3章的*实现异步TCP客户端*配方中，*实现客户端应用程序*，演示了如何构建一个支持异步操作取消功能的更复杂的客户端应用程序。
- en: '[Chapter 1](ch01.html "Chapter 1. The Basics"), *The Basics*, contains recipes
    that demonstrate how to synchronously connect a socket and resolve a DNS name'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1章*基础知识*中的配方演示了如何同步连接套接字和解析DNS名称。
- en: Shutting down and closing a socket
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭和关闭套接字
- en: In some distributed applications that communicate over the TCP protocol, there
    is a need to transfer messages that do not have a fixed size and specific byte
    sequence, marking its boundary. This means that the receiving side, while reading
    the message from the socket, cannot determine where the message ends by analyzing
    the message itself with either its size or its content.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些使用TCP协议进行通信的分布式应用程序中，需要传输没有固定大小和特定字节序列的消息，并标记其边界。这意味着接收方在从套接字读取消息时，无法通过分析消息本身的大小或内容来确定消息的结束位置。
- en: One approach to solve this problem is to structure each message in such a way
    that it consists of a logical header section and a logical body section. The header
    section has a fixed size and structure and specifies the size of the body section.
    This allows the receiving side to first read and parse the header, find out the
    size of the message body, and then properly read the rest of the message.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是将每条消息结构化为一个逻辑头部分和一个逻辑体部分。头部分具有固定的大小和结构，并指定体部分的大小。这允许接收方首先读取并解析头部分，找出消息体的大小，然后正确读取消息的其余部分。
- en: This approach is quite simple and is widely used. However, it brings some redundancy
    and additional computation overhead, which may be unacceptable in some circumstances.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当简单，并且被广泛使用。然而，它带来了一些冗余和额外的计算开销，这在某些情况下可能是不可以接受的。
- en: Another approach can be applied when an application uses a separate socket for
    each message sent to its peer, which is a quite popular practice. The idea of
    this approach is to **shut down** the send part of the socket by the message sender
    after the message is written to the socket. This results in a special service
    message being sent to the receiver, informing the receiver that the message is
    over and the sender will not send anything else using the current connection.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序为发送给对等方的每条消息使用单独的套接字时，可以采用另一种方法，这是一种相当流行的做法。这种方法的想法是在消息写入套接字后，由消息发送者**关闭**套接字的发送部分。这会导致发送一个特殊的服务消息给接收者，告知接收者消息已结束，发送者将不会使用当前连接发送任何其他内容。
- en: The second approach provides many more benefits than the first one and, because
    it is part of the TCP protocol software, it is readily available to the developer
    for usage.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法比第一种方法提供了更多的好处，并且因为它属于TCP协议软件的一部分，所以它对开发者来说很容易使用。
- en: Another operation on a socket, that is, **closing** may seem similar to shutting
    down, but it is actually very different from it. Closing a socket assumes returning
    the socket and all the other resources associated with it back to the operating
    system. Just like memory, a process or a thread, a file handle or a mutex, a socket
    is a resource of an operating system. And like any other resource, a socket should
    be returned back to the operating system after it has been allocated, used, and
    is not needed by the application anymore. Otherwise, a resource leak may occur,
    which may eventually lead to the exhaustion of the resource and to the application's
    fault or instability of the whole operating system.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字上的另一种操作，即**关闭**，看起来可能类似于关闭，但实际上它与关闭操作非常不同。关闭套接字意味着将套接字及其所有其他相关资源返回给操作系统。就像内存、进程或线程、文件句柄或互斥锁一样，套接字是操作系统的资源。并且像任何其他资源一样，套接字在分配、使用且不再由应用程序需要后，应返回给操作系统。否则，可能会发生资源泄漏，这最终可能导致资源耗尽，并导致应用程序故障或整个操作系统的不稳定。
- en: Serious issues that may occur when sockets are not closed make closing a very
    important operation.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字未关闭时可能出现的严重问题使得关闭操作变得非常重要。
- en: The main difference between shutting down and closing a TCP socket is that closing
    interrupts the connection if one is established and, eventually, deallocates the
    socket and returns it back to the operating system, while shutting down only disables
    writing, reading, or both the operations on the socket and sends a service message
    to the peer application notifying about this fact. Shutting down a socket never
    results in deallocating the socket.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭TCP套接字与关闭套接字之间的主要区别在于，如果已经建立了连接，关闭操作会中断连接，并最终释放套接字并将其返回给操作系统，而关闭操作仅禁用套接字的写入、读取或两者操作，并向对等应用程序发送一个服务消息来通知这一事实。关闭套接字永远不会导致释放套接字。
- en: In this recipe, we'll see how to shut down and close a TCP socket.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何关闭和关闭TCP套接字。
- en: How to do it…
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we''ll consider a distributed application that consists of two parts:
    a client and a server to better understand how a socket shut down operation can
    be used to make an application layer protocol more efficient and clear when the
    communication between parts of distributed applications is based on binary messages
    of random sizes.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将考虑一个由两部分组成的分布式应用程序：客户端和服务器，以便更好地理解如何使用套接字关闭操作来使基于分布式应用程序部分之间基于随机大小的二进制消息的应用层协议更加高效和清晰。
- en: For simplicity, all operations in both the client and server applications are
    synchronous.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，客户端和服务器应用程序中的所有操作都是同步的。
- en: The client application
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端应用程序
- en: The purpose of the client application is to allocate the socket and connect
    it to the server application. After the connection is established, the application
    should prepare and send a request message notifying its boundary by shutting down
    the socket after writing the message to it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序的目的是分配套接字并将其连接到服务器应用程序。在建立连接后，应用程序应准备并发送一个请求消息，通过在消息写入后关闭套接字来通知其边界。
- en: After the request is sent, the client application should read the response.
    The size of the response is unknown; therefore, the reading should be performed
    until the server closes its socket to notify the response boundary.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求发送后，客户端应用程序应读取响应。响应的大小是未知的；因此，读取应一直进行，直到服务器关闭其套接字以通知响应边界。
- en: 'We begin the client application by specifying the `include` and `using` directives:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定`include`和`using`指令开始客户端应用程序：
- en: '[PRE49]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we define a function that accepts a reference to the socket object connected
    to the server and performs the communication with the server using this socket.
    Let''s name this function `communicate()`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数，该函数接受一个指向连接到服务器的套接字对象的引用，并使用此套接字与服务器进行通信。让我们称这个函数为`communicate()`：
- en: '[PRE50]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we define an application''s `main()` entry point function. This function
    allocates and connects the socket, and then calls the `communicate()` function
    defined in the previous step:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个应用程序的`main()`入口点函数。此函数分配和连接套接字，然后调用之前步骤中定义的`communicate()`函数：
- en: '[PRE51]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The server application
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器应用程序
- en: The server application is intended to allocate an acceptor socket and passively
    wait for a connection request. When the connection request arrives, it should
    accept it and read the data from the socket connected to the client until the
    client application shuts down the socket on its side. Having received the request
    message, the server application should send the response message notifying its
    boundary by shutting down the socket.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序旨在分配一个接受器套接字并被动等待连接请求。当连接请求到达时，它应接受该请求并从连接到客户端的套接字读取数据，直到客户端应用程序在其端关闭套接字。在收到请求消息后，服务器应用程序应通过关闭套接字来发送响应消息并通知其边界。
- en: 'We begin the client application by specifying `include` and `using` directives:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定`include`和`using`指令开始客户端应用程序：
- en: '[PRE52]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we define a function that accepts a reference to the socket object connected
    to the client application and performs the communication with the client using
    this socket. Let''s name this function `processRequest()`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数，该函数接受一个指向连接到客户端应用程序的套接字对象的引用，并使用此套接字与客户端进行通信。让我们称这个函数为`processRequest()`：
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we define the application''s `main()` entry point function. This function
    allocates an acceptor socket and waits for the incoming connection requests. When
    the connection request arrives, it obtains an active socket that is connected
    to the client application and calls the `processRequest()` function defined in
    the previous step by passing a connected socket object to it:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义应用程序的`main()`入口点函数。此函数分配一个接受器套接字并等待传入的连接请求。当连接请求到达时，它获取一个连接到客户端应用程序的活动套接字，并通过传递一个连接套接字对象到其中调用之前步骤中定义的`processRequest()`函数：
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Closing a socket
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭套接字
- en: In order to close an allocated socket, the `close()` method should be called
    on the corresponding object of the `asio::ip::tcp::socket` class. However, usually,
    there is no need to do it explicitly because the destructor of the socket object
    closes the socket if one was not closed explicitly.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了关闭一个分配的套接字，应在`asio::ip::tcp::socket`类的相应对象上调用`close()`方法。然而，通常不需要显式执行此操作，因为如果未显式关闭，套接字对象的析构函数会关闭套接字。
- en: How it works…
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The server application is first started. In its `main()` entry point function,
    an acceptor socket is allocated, opened, bound to port `3333`, and starts waiting
    for the incoming connection request from the client.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序首先启动。在其`main()`入口点函数中，分配了一个接受器套接字，打开它，并将其绑定到端口`3333`，然后开始等待来自客户端的传入连接请求。
- en: Then, the client application is started. In its `main()` entry point function,
    an active socket is allocated, opened, and connected to the server. After the
    connection is established, the `communicate()` function is called. In this function,
    all the interesting things take place.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动客户端应用程序。在其`main()`入口点函数中，分配了一个活动套接字，打开它，并将其连接到服务器。在建立连接后，调用`communicate()`函数。在这个函数中，所有有趣的事情都发生了。
- en: 'The client application writes a request message to the socket and then calls
    the socket''s `shutdown()` method, passing an `asio::socket_base::shutdown_send`
    constant as an argument. This call shuts down the send part of the socket. At
    this point, writing to the socket is disabled, and there is no way to restore
    the socket state to make it writable again:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序向套接字写入请求消息，然后调用套接字的`shutdown()`方法，并将`asio::socket_base::shutdown_send`常量作为参数传递。这个调用关闭了套接字的发送部分。此时，向套接字写入被禁用，且无法恢复套接字状态使其再次可写：
- en: '[PRE55]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Shutting down the socket in the client application is seen in the server application
    as a protocol service message that arrives to the server, notifying the fact that
    the peer application has shut down the socket. Boost.Asio delivers this message
    to the application code by means of an error code returned by the `asio::read()`
    function. The Boost.Asio library defines this code as `asio::error::eof`. The
    server application uses this error code to find out when the client finishes sending
    the request message.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序中关闭套接字被视为服务器应用程序中到达服务器的协议服务消息，通知对等应用程序已关闭套接字。Boost.Asio通过`asio::read()`函数返回的错误代码将此消息传递给应用程序代码。Boost.Asio库将此代码定义为`asio::error::eof`。服务器应用程序使用此错误代码来确定客户端何时完成发送请求消息。
- en: When the server application receives a full request message, the server and
    client exchange their roles. Now, the server writes the data, namely, the response
    message to the socket on its side, and the client application reads this message
    on its side. When the server finishes writing the response message to the socket,
    it shuts down the send part of its socket to imply that the whole message has
    been sent to its peer.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器应用程序接收到完整的请求消息时，服务器和客户端交换它们的角色。现在，服务器在其端向套接字写入数据，即响应消息，客户端应用程序在其端读取此消息。当服务器完成将响应消息写入套接字后，它关闭其套接字的发送部分，以表示整个消息已发送到其对等方。
- en: 'Meanwhile, the client application is blocked in the `asio::read()` function
    and reads the response sent by the server until the function returns with the
    error code equal to `asio::error::eof`, which implies that the server has finished
    sending the response message. When the `asio::read()` function returns with this
    error code, the client *knows* that it has read the whole response message, and
    it can then start processing it:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，客户端应用程序在`asio::read()`函数中被阻塞，读取服务器发送的响应，直到函数返回错误代码等于`asio::error::eof`，这表示服务器已发送完响应消息。当`asio::read()`函数返回此错误代码时，客户端*知道*它已读取整个响应消息，然后可以开始处理它：
- en: '[PRE56]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that after the client has shut down its socket's send part, it can still
    read data from the socket because the receive part of the socket stays open independently
    from the send part.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在客户端关闭其套接字的发送部分后，它仍然可以从套接字读取数据，因为套接字的接收部分独立于发送部分保持打开状态。
- en: See also
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing to a TCP socket synchronously* recipe demonstrates how to write
    data to a TCP socket synchronously
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步写入TCP套接字*配方演示了如何同步地将数据写入TCP套接字。'
- en: The *Reading from a TCP socket synchronously* recipe demonstrates how to read
    data from a TCP socket synchronously
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步从TCP套接字读取*配方演示了如何同步地从TCP套接字读取数据。'
- en: The *Implementing the HTTP client application* and *Implementing the HTTP server
    application* recipes in [Chapter 5](ch05.html "Chapter 5. HTTP and SSL/TLS"),
    *HTTP and SSL/TLS*, demonstrate how a socket shut down is used in the implementation
    of the HTTP protocol
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。HTTP和SSL/TLS")中的*实现HTTP客户端应用程序*和*实现HTTP服务器应用程序*配方演示了在实现HTTP协议中如何使用套接字关闭。'
