<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Qt Quick</h1></div></div></div><div><blockquote class="blockquote"><p><em>In the previous chapter, we introduced you to the basics of Qt Quick and QML. By now, you should be fluent enough with the syntax and understand the basic concepts of how Qt Quick works. In this chapter, we will show you how to make your games stand out from the crowd by introducing different kinds of animations that make your applications feel more like the real world. You will also learn to treat Qt Quick objects as separate entities programmable using state machines. A large section of this chapter is devoted to making your games prettier by using OpenGL effects and particle systems. Another significant part of this chapter will introduce how to implement a number of important gaming concepts using Qt Quick. All this is going to be shown with the building of a simple 2D action game using the presented concepts.</em></p></blockquote></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec158"/>Bringing life into static user interfaces</h1></div></div></div><p>What we have <a id="id804" class="indexterm"/>described so far can be called anything but "fluid." Let's change that now by learning how to add some dynamics into the user interfaces we create. Thus far, books cannot contain moving pictures, so most things we describe here you will have to test yourself by running the provided Qt Quick code.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec214"/>Animating elements</h2></div></div></div><p>Qt Quick <a id="id805" class="indexterm"/>provides a very extensive framework for creating animations. By that, we don't mean only moving items around. We define an animation as <em>changing an arbitrary value over time</em>. So, what can we animate? Of course, we can animate item geometry. But we can also animate rotation, scale, other numeric values, and even colors. But let's not stop here. Qt Quick also lets you animate the parent-child hierarchy of items or anchor assignments. Almost anything that can be represented by an item property can be animated.</p><p>Moreover, the changes are rarely linear—if you kick a ball in the air, it first gains height quickly because its initial speed was large. However, the ball is a physical object being pulled down by the Earth's gravity, which slows the climb down until the ball stops and then starts falling down, accelerating until it hits the ground. Depending on the properties of both the ground and ball, the object can bounce off the surface into the air again with <a id="id806" class="indexterm"/>less momentum, repeating the spring-like motion until eventually it fades away, leaving the ball on the ground. Qt Quick lets you model all that using easing curves that can be assigned to animations.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec51"/>Generic animations</h3></div></div></div><p>Qt Quick provides a <a id="id807" class="indexterm"/>number of animation types derived from a generic <code class="literal">Animation</code> element that you will never use directly. The type exists only to provide an API common to different animation types.</p><p>Let's take a closer look at the animation framework by looking at a family of animation types derived from the most common animation type—<code class="literal">PropertyAnimation</code>. As the name implies, they provide the means to animate values of object properties. Despite the fact that you can use the <code class="literal">PropertyAnimation</code> element directly, it is usually more convenient to use one of its subclasses that are specialized in dealing with peculiarities of different data types.</p><p>The most basic property animation type is <code class="literal">NumberAnimation</code>, which lets you animate all kinds of numeric values of both integral and real numbers. The simplest way of using it is to declare an animation, tell it to animate a specific property in a specific object, and then set the length of the animation and the starting and ending value for the property:</p><div><pre class="programlisting">import QtQuick 2.0

Item {
  id: root
  width: 600; height: width
  Rectangle {
    id: rect
    color: "red"; width: 50; height: width
  }
<strong>  NumberAnimation {</strong>
<strong>    target: rect</strong>
<strong>    property: "x"</strong>
<strong>    from: 0; to: 550</strong>
<strong>    duration: 3000</strong>
<strong>    running: true</strong>
<strong>  }</strong>
}</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec159"/>Time for action – scene for an action game</h1></div></div></div><p>Create a new Qt <a id="id808" class="indexterm"/>Quick UI project. In the project directory, make a subdirectory called <code class="literal">images</code> and from the game project that we have created using Graphics View copy <code class="literal">grass.png</code>, <code class="literal">sky.png</code>, and <code class="literal">trees.png</code>. Then, put the following code into the QML document:</p><div><pre class="programlisting">import QtQuick 2.1

Image {
  id: root
  property int dayLength: 60000 // 1 minute
  source: "images/sky.png"

  Item {
    id: sun
    x: 140
    y: root.height-170
    Rectangle {
      id: sunVisual
      width: 40
      height: width
      radius: width/2
      color: "yellow"
      anchors.centerIn: parent
    }
  }
  Image {
    source: "images/trees.png"
    x: -200
    anchors.bottom: parent.bottom
  }
  Image {
    source: "images/grass.png"
    anchors.bottom: parent.bottom
  }
}</pre></div><p>When you run the <a id="id809" class="indexterm"/>project now, you will see a screen similar to this one:</p><div><img src="img/8874OS_10_01.jpg" alt="Time for action – scene for an action game"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec215"/>
<em>What just happened?</em>
</h2></div></div></div><p>We set up a very simple scene consisting of three images stacked up to form a landscape. Between the background layer (the sky) and the foreground (trees), we placed a yellow circle representing the sun. Since we are going to be moving the sun around in a moment, we anchored the center of the object to an empty item without physical dimensions so that we can set the sun's position relative to its center. We also equipped the scene with a <code class="literal">dayLength</code> property, which is going to hold information about the length of one day of game time. By default, we <a id="id810" class="indexterm"/>set it to 60 seconds so that things happen really fast and we can see the animation's progress without waiting. After all things are set correctly, the length of the day can be balanced to fit our needs.</p><p>The graphical design lets us easily manipulate the sun while keeping it behind the tree line. Notice how the stacking order is implicitly determined by the order of elements in the document.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec160"/>Time for action – animating the sun's horizontal movement</h1></div></div></div><p>The <a id="id811" class="indexterm"/>everyday cruise of the sun in the sky starts in the east and continues west to hide beneath the horizon in the evening. Let's try to replicate this horizontal movement by adding animation to our <code class="literal">sun</code> object.</p><p>Open the QML document of our last project. Inside the <code class="literal">root</code> item add the following declaration:</p><div><pre class="programlisting">NumberAnimation {
  target: sun
  property: "x"
  from: 0
  to: root.width
  duration: dayLength
  running: true
}</pre></div><p>Running the program with such modifications will produce a run with a horizontal movement of the sun. The following image is a composition of a number of frames of the run:</p><div><img src="img/8874OS_10_02.jpg" alt="Time for action – animating the sun's horizontal movement"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec216"/>
<em>What just happened?</em>
</h2></div></div></div><p>We introduced a <code class="literal">NumberAnimation</code> element that is set to animate the <code class="literal">x</code> property of the <code class="literal">sun</code> object. The animation starts at <code class="literal">0</code> and lasts until <code class="literal">x</code> reaches the <code class="literal">root</code> item's width (which is the right edge of the scene). The movement lasts for <code class="literal">dayLength</code> miliseconds. The <code class="literal">running</code> property of the animation is set to <code class="literal">true</code> to enable the animation. Since we didn't specify otherwise, the motion is linear.</p><p>You might be <a id="id812" class="indexterm"/>thinking that the animation runs in the wrong direction—"west" is on the left and "east" is on the right, yes? That's true, however, only if the observer faces north. If that were the case for our scene, we wouldn't be seeing the sun at all—at noon, it crosses the south direction.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec52"/>Composing animations</h2></div></div></div><p>The animation <a id="id813" class="indexterm"/>we made in the last section looks okay but is not very realistic. The sun should rise in the morning, reach its peak sometime before noon, and then sometime later start setting toward the evening, when it should cross the horizon and hide beneath the landscape.</p><p>To achieve such an effect, we could add two more animations for the <code class="literal">y</code> property of the sun. The first animation would start right at the beginning and decrease the vertical position of the sun (remember that the vertical geometry axis points down, so decreasing the vertical position means the object goes up). The animation would be complete at one third of the day length. We would then need a way to wait for some time and then start a second animation that would pull the object down toward the ground. Starting and stopping the animation is easy—we can either call the <code class="literal">start()</code> and <code class="literal">stop()</code> functions on the animation item or directly alter the value of the <code class="literal">running</code> property. Each <code class="literal">Animation</code> object emits <code class="literal">started()</code> and <code class="literal">stopped()</code> signals. The delay can be implemented by using a timer. We could provide a signal handler for the stopped signal of the first animation to trigger a timer to start the other one like this:</p><div><pre class="programlisting">NumberAnimation {
  id: sunGoesUpAnim
  // …
  onStopped: sunGoesDownAnimTimer.start()
}
Timer {
  id: sunGoesDownAnimTimer
  interval: dayLength/3
  onTriggered: sunGoesDownAnim.start()
}</pre></div><p>Even ignoring any side problems this would bring (for example, how to stop the animation without starting the second one), such an approach couldn't be called "declarative," could it?</p><p>Fortunately, similar to what we had in C++, Qt Quick lets us form animation groups that run either parallel <a id="id814" class="indexterm"/>to each other or in sequence. There are the <code class="literal">SequentialAnimation</code> and <code class="literal">ParallelAnimation</code> types where you can declare any number of child animation elements forming the group. To run two animations in parallel, we could declare the following hierarchy of elements:</p><div><pre class="programlisting">ParallelAnimation {
  id: parallelAnimationGroup

  NumberAnimation {
    target: obj1; property: "prop1"
    from: 0; to: 100
    duration: 1500
  }
  NumberAnimation {
    target: obj2; property: "prop2"
    from: 150; to: 0
    duration: 1500
  }
  running: true
}</pre></div><p>The same technique can be used to synchronize a larger group of animations, even if each component has a different duration:</p><div><pre class="programlisting">SequentialAnimation {
  id: sequentialAnimationGroup

  ParallelAnimation {
    id: parallelAnimationGroup

    NumberAnimation {
      id: A1
      target: obj2; property: "prop2"
      from: 150; to: 0
      duration: 1000
    }
    NumberAnimation {
      id: A2
      target: obj1; property: "prop1"
      from: 0; to: 100
      duration: 2000
    }
  }
  PropertyAnimation {
    id: A3
    target: obj1; property: "prop1"
    from: 100; to: 300
    duration: 1500
  }
  running: true
}</pre></div><p>The group presented in the snippet consists of three animations. The first two animations are executed together as they form a parallel subgroup. One member of the group runs twice as long as the other. Only after the whole subgroup completes is the third animation started. This can <a id="id815" class="indexterm"/>be visualized using a UML activity diagram where the size of each activity is proportional to the duration of that activity:</p><div><img src="img/8874OS_10_03.jpg" alt="Composing animations"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec161"/>Time for action – making the sun rise and set</h1></div></div></div><p>Let's add <a id="id816" class="indexterm"/>vertical movement (animation of the <code class="literal">y</code> property) to our sun by adding a sequence of animations to the QML document. As our new animations are going to be running in parallel to the horizontal animation, we could enclose animations for both directions within a single <code class="literal">ParallelAnimation</code> group. It would work, but in our opinion this would unnecessarily clutter the document. Another way of specifying parallel animations is to declare them as separate hierarchies of elements, making each animation independent of the other, and that is what we are going to do here.</p><p>Open our document from the last exercise and right under the previous animation, place the following code:</p><div><pre class="programlisting">SequentialAnimation {
  NumberAnimation {
    target: sun
    property: "y"
    from: root.height+sunVisual.height
    to: root.height-270
    duration: dayLength/3
  }
  PauseAnimation { duration: dayLength/3 }
  NumberAnimation {
    target: sun
    property: "y"
    from: root.height-270
    to: root.height+sunVisual.height
    duration: dayLength/3
  }
running: true
}</pre></div><p>Running the <a id="id817" class="indexterm"/>program will result in the light source rising in the morning and setting in the evening. However, the trajectory of the move seems somewhat awkward.</p><div><img src="img/8874OS_10_04.jpg" alt="Time for action – making the sun rise and set"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec217"/>
<em>What just happened?</em>
</h2></div></div></div><p>We declared a sequential animation group consisting of three animations, each taking 1/3 of the day length. The first member of the group makes the sun go up. The second member, which is an instance of a new element type—<code class="literal">PauseAnimation</code>—introduces a delay equal to its duration. This in turn lets the third component start its work in the afternoon to pull the sun down toward the horizon.</p><p>The problem with such a declaration is that the sun moves in a horribly angular way, as can be seen in the image.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec53"/>Non-linear animations</h2></div></div></div><p>The reason for the <a id="id818" class="indexterm"/>described problem is that our animations are linear. As we noted in the beginning of this chapter, linear animations rarely occur in nature, which usually makes their use yield a very unrealistic result.</p><p>We also said earlier that Qt Quick allows us to use easing curves to perform animations along non-linear paths. There are a large number of curves offered. Here is a diagram listing available non-linear easing curves:</p><div><img src="img/8874OS_10_05.jpg" alt="Non-linear animations"/></div><p>You can use any of the curves on an element of the type <code class="literal">PropertyAnimation</code> or one derived from it (for example, <code class="literal">NumberAnimation</code>). This is done by using the <code class="literal">easing</code> property group, where you can set the <code class="literal">type</code> of the curve. Different curve types may further be tweaked by setting a number of properties in the <code class="literal">easing</code> property group, such as <code class="literal">amplitude</code> (for bounce and elastic curves), <code class="literal">overshoot</code> (for back curves), or <code class="literal">period </code>(for elastic curves).</p><p>Declaring an animation along an <code class="literal">InOutBounce</code> path is very easy:</p><div><pre class="programlisting">NumberAnimation {
  target: obj; property: prop;
  from: startValue; to: endValue;
<strong>  easing.type: Easing.InOutBounce</strong>
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec162"/>Time for action – improving the path of the sun</h1></div></div></div><p>The task at <a id="id819" class="indexterm"/>hand is going to be to improve the animation of the sun so that it behaves in a more realistic way. We will do this by adjusting the animations so that the object moves over a curved path.</p><p>In our QML document, replace the previous vertical animation with the following one:</p><div><pre class="programlisting">SequentialAnimation {
  NumberAnimation {
    target: sun
    property: "y"
    from: root.height+sunVisual.height
    to: root.height-270
    duration: dayLength/2
    easing.type: Easing.OutCubic
  }
  NumberAnimation {
    target: sun
    property: "y"
    to: root.height+sunVisual.height
    duration: dayLength/2
    easing.type: Easing.InCubic
  }

  running: true
}</pre></div><div><img src="img/8874OS_10_06.jpg" alt="Time for action – improving the path of the sun"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec218"/>
<em>What just happened?</em>
</h2></div></div></div><p>The sequence of three animations (two linear ones and a pause) was replaced by another sequence of two animations that follow a path determined by a cubic function. This makes our sun rise pretty fast and then slow down to an amount almost unnoticeable near the moment when the sun approaches noon. When the first animation is finished, the second one reverses the motion, making the sun descend very slowly and then increase its velocity as dusk approaches. As a result, the further the sun is away from the ground, the slower it seems to move. At the same time, the horizontal animation remains linear as the speed of Earth in its motion around the Sun is practically constant. When we combine the horizontal and <a id="id820" class="indexterm"/>vertical animations, we get a path that looks very similar to what we can observe in the real world.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec54"/>Property value sources</h2></div></div></div><p>From a QML <a id="id821" class="indexterm"/>perspective, animation and element types derived from it are something called <em>property value source</em>. This <a id="id822" class="indexterm"/>means they can be attached to a property and generate values for it. What is important is that it allows us to use animations using a much simpler syntax. Instead of explicitly declaring the target and property of an animation, one can attach the animation to a named property of the parent object.</p><p>To do this, instead of specifying <code class="literal">target</code> and <code class="literal">property</code> for <code class="literal">Animation</code>, use the <code class="literal">on</code> keyword followed by the name of a property name for which the animation is to be a value source. For example, to animate the <code class="literal">rotation</code> property of an object with a <code class="literal">NumberAnimation</code> object, the following code can be used:</p><div><pre class="programlisting">NumberAnimation on rotation {
  from: 0
  to: 360
  duration: 500
}</pre></div><p>It is valid to specify more than one property value source for the same property of an object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec163"/>Time for action – adjusting the sun's color</h1></div></div></div><p>If you look at the <a id="id823" class="indexterm"/>sun at dusk or dawn, you will see that it is not yellow, but rather becomes red the closer it is to the horizon. Let's teach our object representing the sun to do the same by providing a property value source for it.</p><p>Open the QML document, find the declaration for the <code class="literal">sunVisual</code> object, and extend it with the highlighted part:</p><div><pre class="programlisting">Rectangle {
  id: sunVisual
  // ...
<strong>  SequentialAnimation on color {</strong>
<strong>    ColorAnimation {</strong>
<strong>      from: "red"</strong>
<strong>      to: "yellow"</strong>
<strong>      duration: 0.2*dayLength/2</strong>
<strong>    }</strong>
<strong>    PauseAnimation { duration: 2*0.8*dayLength/2 }</strong>
<strong>    ColorAnimation {</strong>
<strong>      to: "red"</strong>
<strong>      duration: 0.2*dayLength/2</strong>
<strong>    }</strong>
<strong>    running: true</strong>
<strong>  }</strong>
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec219"/>
<em>What just happened?</em>
</h2></div></div></div><p>An animation was attached to the <code class="literal">color</code> property of our rectangle modeling the visual aspects of the sun. The animation consists of three parts. First, we perform a transition from red to yellow using the <code class="literal">ColorAnimation</code> object. This is an <code class="literal">Animation</code> subtype dedicated to modifying colors. Since the rectangle color is not a number, using the <code class="literal">NumberAnimation</code> <a id="id824" class="indexterm"/>object would not have worked as the type cannot interpolate color values. Therefore, we either have to use the <code class="literal">PropertyAnimation</code> or <code class="literal">ColorAnimation</code> object. The duration for the animation is set to 20 percent of half the day length so that the yellow color is obtained very quickly. The second component is a <code class="literal">PauseAnimation</code> object to provide a delay before the third component is executed, which gradually changes the color back to red. For the last component, we do not provide a value for the <code class="literal">from</code> property. This causes the animation to be initiated with the value of the property current to the time when the animation is executed (in this case, the sun should be yellow).</p><p>Notice that we only had to specify the property name for the top-level animation. This particular element is what serves as the property value source, and all descendant animation objects "inherit" the target property from that property value source.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec164"/>Time for action – furnishing sun animation</h1></div></div></div><p>The animation <a id="id825" class="indexterm"/>of the sun looks almost perfect right now. We can still improve it, though. If you look into the sky in the early morning and then again at noon, you will notice that the sun appears much bigger during sunrise or sunset compared to its size in zenith. We can simulate that effect by scaling the object.</p><p>In our scene document, add another sequential animation that operates on the <code class="literal">scale</code> property of the sun:</p><div><pre class="programlisting">SequentialAnimation on scale {
  NumberAnimation {
    from: 1.6; to: 0.8
    duration: dayLength/2
    easing.type: Easing.OutCubic
  }
  NumberAnimation {
    from: 0.8; to: 1.6
    duration: dayLength/2
    easing.type: Easing.InCubic
  }
}</pre></div><div><img src="img/8874OS_10_07.jpg" alt="Time for action – furnishing sun animation"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec220"/>
<em>What just happened?</em>
</h2></div></div></div><p>In this section, we just followed the path set for an earlier declaration—the vertical movement of the stellar body influences its perceived size; therefore, it seems like a good decision to bind the two animations together. Notice that instead of specifying a new property value source for the scale, we might have modified the original animation and made the scale <a id="id826" class="indexterm"/>animation parallel to that operate on the <code class="literal">y</code> property:</p><div><pre class="programlisting">SequentialAnimation {
  ParallelAnimation {
    NumberAnimation {
      target: sun
      property: "y"
      from: root.height+sunVisual.height
      to: root.height-270
      duration: dayLength/2
      easing.type: Easing.OutCubic
    }
    NumberAnimation {
      target: sun
      property: "scale"
      from: 1.6; to: 0.8
      duration: dayLength/2
      easing.type: Easing.OutCubic
    }
  // …</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec221"/>Have a go hero – animating the sun's rays</h2></div></div></div><p>By now, you <a id="id827" class="indexterm"/>should be an animation expert. If you want to try your skills, here is a task for you. The following code can be applied to the <code class="literal">sun</code> object and will display very simple red rays emitted from the sun:</p><div><pre class="programlisting">Item {
  id: sunRays
  property int count: 10
  width: sunVisual.width
  height: width
  anchors.centerIn: parent
  z: -1
  Repeater {
    model: sunRays.count
    Rectangle {
      color: "red"
      rotation: index*360/sunRays.count
      anchors.fill: parent
    }
  }
}</pre></div><div><img src="img/8874OS_10_08.jpg" alt="Have a go hero – animating the sun's rays"/></div><p>The goal is to animate the rays so that the overall effect looks good and fits the tune like style of the scene. Try <a id="id828" class="indexterm"/>different animations—rotations, size changes, and colors. Apply them to different elements—all rays at once (for example, using the <code class="literal">sunRays</code> identifier) or only particular rectangles generated by the repeater.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec55"/>Behaviors</h2></div></div></div><p>In the previous <a id="id829" class="indexterm"/>chapter, we implemented a dashboard for a racing game where we had a number of clocks with needles. We could set values for each clock (for example, car speed) and a respective needle would immediately set itself to the given value. But such an approach is unrealistic—in the real world, changes of a value happen over time. In our example, the car accelerates from 10 mph to 50 mph by going through 11 mph, 12 mph and so on, until after some time it reaches the desired value. We call this the <em>behavior</em> of a value—it is essentially a model that tells how the parameter reaches its destined value. Defining such models is a perfect use case for declarative programming. Fortunately, QML exposes a <code class="literal">Behavior</code> element that lets us model behaviors of property changes in Qt Quick.</p><p>The <code class="literal">Behavior</code> <a id="id830" class="indexterm"/>elements let us associate an animation with a given property so that, every time the property value is to be changed, it is done by running the given animation instead of by making an immediate change to the property value:</p><div><pre class="programlisting">import QtQuick 2.0

Item {
  width: 600; height: width
  Item {
    id: empty
    x: parent.width/2; y: parent.height/2
    Rectangle {
      id: rect
      width: 100; height: width; color: "red"
      anchors.centerIn: parent
    }
  }
  MouseArea {
    anchors.fill: parent
    onClicked: { empty.x = mouse.x; empty.y = mouse.y }
  }
}</pre></div><p>The preceding code implements a simple scene with a red rectangle anchored to an empty item. Whenever the user clicks somewhere within the scene, the empty item is moved there, dragging along the rectangle. Let's see how to use the <code class="literal">Behavior</code> element to smoothly change the position of the empty item. The <code class="literal">Behavior</code> element is a property value source just like the <code class="literal">Animation</code> element itself; thus, it is easiest to use on the on-property syntax:</p><div><pre class="programlisting">Item {
  id: rect
  x: parent.width/2; y: parent.height/2
  Rectangle {
    width: 100; height: width; color: "red"
    anchors.centerIn: parent
  }
<strong>  Behavior on x { NumberAnimation { } }</strong>
<strong>  Behavior on y { NumberAnimation { } }</strong>
}</pre></div><p>By adding the two marked declarations, we define behaviors for properties <code class="literal">x</code> and <code class="literal">y</code> that follow animations defined by <code class="literal">NumberAnimation</code>. We do not include start or end values for the animation as these will depend on the initial and final value for the property. We also don't set the property name in the animation because by default, the property for which the behavior is defined will be used. As a result, we get a linear animation of a <a id="id831" class="indexterm"/>numerical property from the original value to the destined value over the default duration.</p><div><div><h3 class="title"><a id="tip78"/>Tip</h3><p>Using linear animations for real world objects rarely looks good. Usually, you will get much better results if you set an easing curve for the animation so that it starts slowly and then gains speed and decelerates just before it is finished.</p></div></div><p>Animations that you set on behaviors can be as complex as you want:</p><div><pre class="programlisting">Behavior on x {
  SequentialAnimation {
    PropertyAction {
  target: rect; property: "color"; value: "yellow"
}
ParallelAnimation {
  NumberAnimation { easing.type: Easing.InOutQuad; duration: 1000
}

      SequentialAnimation {
        NumberAnimation {
          target: rect; property: "scale"
          from: 1.0; to: 1.5; duration: 500
        }
        NumberAnimation {
          target: rect; property: "scale"
          from: 1.5; to: 1.0; duration: 500
        }
      }
    }
    PropertyAction { target: rect; property: "color"; value: "red" }
  }
}</pre></div><p>The behavioral model declared in the last piece of code performs a sequential animation. It first changes the color of the rectangle to yellow using the <code class="literal">PropertyAction</code> element, which performs an immediate update of a property value (we will talk about this more a bit later). The color will be set back to red after, as the last step of the model. In the meantime, a parallel animation is performed. One of its components is a <code class="literal">NumberAnimation</code> class that executes the actual animation of the <code class="literal">x</code> property of <code class="literal">empty</code> (since the target and property of the animation are not explicitly set). The second component is a sequential animation of the <code class="literal">scale</code> property of the rectangle, which first scales the item up by 50 percent during the first half of the animation and then scales it back down in the second half of the animation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec165"/>Time for action – animating the car dashboard</h1></div></div></div><p>Let's employ the <a id="id832" class="indexterm"/>knowledge we just learned to improve our car dashboard so that it shows some realism in the way the clocks update their values.</p><p>Open the dashboard project and navigate to the <code class="literal">dashboard.qml</code> file. Find the declaration of the <code class="literal">Needle</code> object, which is responsible for visualizing the speed of the vehicle. Add the following declaration to the object:</p><div><pre class="programlisting">Behavior on rotation {
  SmoothedAnimation { velocity: 50 }
}</pre></div><p>Repeat the process for the left clock. Set the velocity of the animation to <code class="literal">100</code>. Build and run the project. See how the needles behave when you modify the parameter values in spinboxes. Adjust the <code class="literal">velocity</code> of each animation until you get a realistic result.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec222"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have set the property value sources on needle rotations that are triggered whenever a new value for the property is requested. Instead of immediately accepting the new value, the <code class="literal">Behavior</code> element intercepts the request and starts the <code class="literal">SmoothedAnimation</code> class to gradually reach the requested value. The <code class="literal">SmoothedAnimation</code> class is an animation type that animates numeric properties. The speed of the animation is not determined by its duration, but instead a <code class="literal">velocity</code> property is set. This property dictates how fast a value is to be changed. However, the animation is using a non-linear path—it first starts slowly, then accelerates to the given velocity and near the end of the animation, decelerates in a smooth fashion. This yields an animation that is attractive and realistic and at the same time, is of shorter or longer duration, depending on the distance between the starting and ending values.</p><div><div><h3 class="title"><a id="tip79"/>Tip</h3><p>You can implement custom property value sources by subclassing <code class="literal">QQmlPropertyValueSource</code> and registering the class in the QML engine.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec223"/>States and transitions</h2></div></div></div><p>When you look <a id="id833" class="indexterm"/>at real world objects, it is often very easy to define their behavior by <a id="id834" class="indexterm"/>extracting a number of states the object may take and describing each of the states separately. A lamp can be turned either on or off. When it is "on" it is emitting light of a given color, but it is not doing that when in the "off" state. Dynamics of the object can be defined by describing what happens if the object leaves one of the states and enters another one. Considering our lamp example, if you turn the lamp on, it doesn't momentarily start emitting light with its full power, but rather the brightness of the light gradually increases to reach its final power after a very short period.</p><p>Qt Quick supports <em>state-driven</em> development by letting us declare states and transitions between them for items. The model fits the declarative nature of Qt Quick very well.</p><p>By default, each item has <a id="id835" class="indexterm"/>a single anonymous state and all properties you define <a id="id836" class="indexterm"/>take values of the expressions you bind or assign to them imperatively based on different conditions. Instead of this, a set of states can be defined for the object and for each of the state properties of the object itself; in addition, the objects defined within it can be programmed with different values or expressions. Our example lamp definition could be similar to:</p><div><pre class="programlisting">Item {
  id: lamp
  property bool lampOn: false
  Rectangle {
    id: lightsource
    anchors.fill: parent
    color: transparent
  }
}</pre></div><p>We could, of course, bind the <code class="literal">color</code> property of <code class="literal">lightsource</code> to <code class="literal">lamp.lampOn ? "yellow" : "transparent"</code>, but instead we can define an "on" state for the lamp and use a <code class="literal">PropertyChanges</code> element to modify the rectangle color:</p><div><pre class="programlisting">Item {
  id: lamp
  property bool lampOn: false
  // …
  states: State {
    name: "on"
    PropertyChanges {
      target: lightsource
      color: "yellow"
    }
  }
}</pre></div><p>Each item has a <code class="literal">state</code> property that you can read to get the current state, but you can also write to it to trigger transition to a given state. By default, the <code class="literal">state</code> property is set to an empty string that represents the anonymous state. Note that with the preceding definition, the item has two states—the "on" state and the anonymous state (which in this case is used when the lamp is off). Remember that state names have to be unique as the <code class="literal">name</code> parameter is what identifies a state in Qt Quick.</p><p>To enter a state, we can, of course, use an event handler fired when the value of the <code class="literal">lampOn</code> parameter is modified:</p><div><pre class="programlisting">onLampOnChanged: state = lampOn ? "on" : ""</pre></div><p>Such imperative code works, but it can be replaced with a declarative definition in the state itself:</p><div><pre class="programlisting">State {
  name: "on"
<strong>  when: lamp.lampOn</strong>
  PropertyChanges {
    target: lightsource
    color: "yellow"
  }
}</pre></div><p>Whenever the expression bound to the <code class="literal">when</code> property evaluates to <code class="literal">true</code>, the state becomes active. If the expression becomes <code class="literal">false</code>, the object will return to the default state or will enter a state for which its own <code class="literal">when</code> property evaluates to <code class="literal">true</code>.</p><p>To define more than one <a id="id837" class="indexterm"/>custom state, it is enough to assign a list of state definitions to the <code class="literal">states</code> property:</p><div><pre class="programlisting">states: [
  State {
    name: "on"
    when: lamp.lampOn
  },
  State {
    name: "off"
    when: !lamp.lampOn
  }
]</pre></div><p>The <code class="literal">PropertyChanges</code> element is the most often used change in a state definition, but it is not the only one. In <a id="id838" class="indexterm"/>exactly the same way that the <code class="literal">ParentChange</code> element can assign a different parent to an item and the <code class="literal">AnchorChange</code> element can update anchor definitions, it is also possible to run a script when a state is entered using the <code class="literal">StateChangeScript</code> element. All these element types are used by declaring their instances as children in a <code class="literal">State</code> object.</p><p>The second part of the state machine framework is defining how an object transits from one state to another. Similar to the <code class="literal">states</code> property, all items have a <code class="literal">transitions</code> property, which takes a list of definitions represented by the <code class="literal">Transition</code> objects and provides information about animations that should be played when a particular transition takes place.</p><p>A transition is identified by three attributes—the source state, the destination state, and a set of animations. Both the source state name (set to the <code class="literal">from</code> property) and the target state name (set to the <code class="literal">to</code> property) can be empty, in which case they should be interpreted as "any". If a <code class="literal">Transition</code> exists that matches the current state change, its animations will be executed. A more concrete transition definition (which is one where <code class="literal">from</code> and/or <code class="literal">to</code> are explicitly set) has precedence over a more generic one.</p><p>Suppose that we want to <a id="id839" class="indexterm"/>animate the opacity of the lamp rectangle from <code class="literal">0</code> to <code class="literal">1</code> when the lamp <a id="id840" class="indexterm"/>is switched on. We can do it as an alternative to manipulating the color. Let's update the lamp definition:</p><div><pre class="programlisting">Item {
  id: lamp
  property bool lampOn: false
  Rectangle {
    id: lightsource
    anchors.fill: parent
<strong>    color: "yellow"</strong>
<strong>    opacity: 0</strong>
  }
  states: State {
    name: "on"
    when: lamp.lampOn
    PropertyChanges {
      target: lightsource
      <strong>opacity: 1</strong>
    }
  }
  <strong>transitions: Transition {</strong>
<strong>    NumberAnimation { duration: 100 }</strong>
<strong>  }</strong>
}</pre></div><p>The transition is triggered for any source and any target state—it will be active when the lamp goes from the anonymous to the "on" state, as well as in the opposite direction. It defines a single <code class="literal">NumberAnimation</code> element that lasts for 100 miliseconds. The animation does not define the target object nor the property it works on; thus, it will be executed for any property and any object that needs updating as part of the transition—in the case of the lamp, it will only be the <code class="literal">opacity</code> property of the <code class="literal">lightsource</code> object.</p><p>If more than one animation is defined in a transition, all animations will run in parallel. If you need a sequential animation, you need to explicitly use a <code class="literal">SequentialAnimation</code> element:</p><div><pre class="programlisting">Transition {
  SequentialAnimation {
    NumberAnimation { target: lightsource; property: "opacity"; duration: 200 }
    ScriptAction { script: console.log("Transition has ended") }
  }
}</pre></div><div><div><h3 class="title"><a id="tip80"/>Tip</h3><p>States are a feature of <a id="id841" class="indexterm"/>all <code class="literal">Item</code> types as well as its descendent types. It <a id="id842" class="indexterm"/>is, however, possible to use states with elements not derived from the <code class="literal">Item</code> object by using a <code class="literal">StateGroup</code> element, which is a self-contained functionality of states and transitions with exactly the same interface as what is described here regarding <code class="literal">Item</code> objects.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec56"/>More animation types</h3></div></div></div><p>The animation types <a id="id843" class="indexterm"/>we discussed earlier are used for modifying values of types that can be described using physical metrics (position, sizes, colors, angles). But there are more types available.</p><p>The first group of special animations consists of the <code class="literal">AnchorAnimation</code> and <code class="literal">ParentAnimation</code> elements.</p><p>The <code class="literal">AnchorAnimation</code> element is useful if a state change should cause a change to defined anchors for an item. Without it, the item would immediately snap into its place. By using the <code class="literal">AnchorAnimation</code> element, we trigger all anchor changes to be gradually animated.</p><p>The <code class="literal">ParentAnimation</code> element, on the other hand, makes it possible to define animations that should be present when an item receives a new parent. This usually causes an item to be moved to a different position in the scene. By using the <code class="literal">ParentAnimation</code> element in a state transition, we can define how the item gets into its target position. The element can contain any number of child animation elements that are going to be run in parallel during a <code class="literal">ParentChange</code> element.</p><p>The second special group of animations is action animations—<code class="literal">PropertyAction</code> and <code class="literal">ScriptAction</code>. These animation types are not stretched in time, but rather perform a given one-time action.</p><p>The <code class="literal">PropertyAction</code> element is a special kind of animation that performs an immediate update of a property to a given value. It is usually used as part of a more complex animation to modify a property that is not animated. It makes sense to use it if a property needs to have a certain value during an animation.</p><p>The <code class="literal">ScriptAction</code> is an element that allows the execution of an imperative piece of code during an animation (usually at its beginning or end).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec166"/>Quick game programming</h1></div></div></div><p>Here, we will go <a id="id844" class="indexterm"/>through the process of creating a platform game using Qt Quick. It will be a game similar to Benjamin the Elephant from <a class="link" href="ch06.html" title="Chapter 6. Graphics View">Chapter 6</a>, <em>Graphics View</em>. The player will control a character that will be walking through the landscape and collecting coins. The coins will randomly be appearing in the world. The character can access highly placed coins by jumping. The more the character jumps, the more tired he gets and the slower he begins to move and has to rest to regain speed. To make the game more difficult, at times moving obstacles will be generated. When the character bumps into any of them, he gets more and more tired. When the fatigue exceeds a certain level, the character dies and the game ends.</p><p>Throughout this chapter as well as the previous one, we prepared a number of pieces we will be reusing for this game. The layered scene that was arranged when you learned about animations will serve as our game scene. The animated sun is going to represent the passing of time. When the sun sets, the time runs out and the game ends. The heartbeat diagram will be used to represent the character's level of fatigue—the more tired the character gets, the faster his heart beats.</p><p>There are many ways this <a id="id845" class="indexterm"/>game can be implemented and we want to give you a level of freedom, so this is not going to be a step-by-step guide on how to implement a complete game. At some points, we will be telling you to employ some skills you have already learned to perform some task without telling you how to do it. At others, we will provide broad descriptions and complete solutions.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec224"/>Game loops</h2></div></div></div><p>Most games revolve around some kind of game loop. It is usually some kind of function that is repeatedly <a id="id846" class="indexterm"/>called at constant intervals and its task is to progress the game—process input events, move objects around, calculate and execute actions, check win conditions, and so on. Such an approach is very imperative and usually results in a very complex function that needs to know everything about everybody (This kind of anti-pattern is sometimes called <a id="id847" class="indexterm"/>a <em>god object</em> pattern). In QML (which powers the Qt Quick framework), we aim to separate responsibilities and declare well-defined behaviors for particular objects. Therefore, although it is possible to set up a timer which will periodically call a game loop function, this is not the best possible approach in a declarative world.</p><p>Instead, we suggest using a natural time-flow mechanism already present in Qt Quick—one that controls the consistency of animations. Remember how we defined the sun's travel across the sky at the beginning of this chapter? Instead of setting up a timer and moving the object by a calculated number of pixels, we created an animation, defined a total running time for it, and let Qt take care of updating the object. This has the great benefit of neglecting delays in function execution. If you used a timer and some external event introduced a significant delay before the timeout function was run, the animation would start lagging behind. When Qt Quick animations are used, the framework compensates for such delays, skipping some of the frame updates to ensure that the requested animation duration is respected. Thanks to that, you will not have to take care of it all by yourself.</p><p>To overcome the second difficult aspect of a game loop—the god anti-pattern—we suggest encapsulating the logic of each item directly in the item itself the using states and transitions framework we introduced earlier. If you define an object using a natural time flow describing all states it can enter during its lifetime and actions causing transitions between states, you will be able to just plop the object with its included behavior wherever it is needed and thus easily reuse such definitions in different games, reducing the amount of work necessary to make the object fit into the game.</p><p>As for input event <a id="id848" class="indexterm"/>processing, a usual approach in games is to read input events and call functions responsible for actions associated with particular events:</p><div><pre class="programlisting">void Scene::keyEvent(QKeyEvent *ke) {
  switch(ke-&gt;key()) {
  case Qt::Key_Right: player-&gt;goRight(); break;
  case Qt::Key_Left:  player-&gt;goLeft();  break;
  case Qt::Key_Space: player-&gt;jump();    break;
  // ...
  }
}</pre></div><p>This, however, has its drawbacks, one of which is the need to check events at even periods of time. This might be hard and certainly is not a declarative approach.</p><p>We already know that Qt Quick handles keyboard input via the <code class="literal">Keys</code> attached property. It is possible to craft QML code similar to the one just presented, but the problem with such an approach is that the faster the player taps keys on the keyboard, the more frequently the character will move, jump, or shoot. It isn't hard if it is done properly, though.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec167"/>Time for action – character navigation</h1></div></div></div><p>Create a new <a id="id849" class="indexterm"/>QML document and call it <code class="literal">Player.qml</code>. In the document, place the following declarations:</p><div><pre class="programlisting">Item {
  id: player
  y: parent.height
  focus: true
  
  Keys.onRightPressed: x = Math.min(x+20, parent.width)
  Keys.onLeftPressed: x = Math.max(0, x-20)
  Keys.onUpPressed: jump()

  function jump() { jumpAnim.start() }

  Image {
    source: "elephant.png"
    anchors.bottom: parent.bottom
    anchors.horizontalCenter: parent.horizontalCenter
  }
  Behavior on x { NumberAnimation { duration: 100 } }
  SequentialAnimation on y {
    id: jumpAnim
    running: false
    NumberAnimation { to: player.parent.height-50; easing.type: Easing.OutQuad }
    NumberAnimation { to: player.parent.height; easing.type: Easing.InQuad }
  }
}</pre></div><p>Next, open the <a id="id850" class="indexterm"/>document containing the main scene definition and declare the player character near the end of the document after all the background layers are declared:</p><div><pre class="programlisting">Player {
  id: player
  x:40
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec225"/>
<em>What just happened?</em>
</h2></div></div></div><p>The player itself is an empty item with a keyboard focus that handles presses of the right, left, and up arrow keys, causing them to manipulate the <code class="literal">x</code> and <code class="literal">y</code> coordinates of the player. The <code class="literal">x</code> property has a <code class="literal">Behavior</code> element set so that the player moves smoothly within the scene. Finally, anchored to the player item is the actual visualization of the player—our elephant friend.</p><p>When the right or left arrow keys are pressed, a new position for the character will be calculated and applied. Thanks to the <code class="literal">Behavior</code> element, the item will travel gradually (during one second) to the new position. Keeping the key pressed will trigger auto-repeat and the handler will be called again. In a similar fashion, when the spacebar is pressed, it will activate a prepared sequential animation that will lift the character up by 50 pixels and then move it down again to the initial position.</p><p>This approach works but we can do better. Let's try something different.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec168"/>Time for action – another approach to character navigation</h1></div></div></div><p>Replace the <a id="id851" class="indexterm"/>previous key handlers with the following code:</p><div><pre class="programlisting">QtObject {
  id: flags
  readonly property int speed: 20
  property int horizontal: 0 
}
Keys.onRightPressed: { recalculateDurations(); flags.horizontal = 1 }
Keys.onLeftPressed: {
  if(flags.horizontal != 0) return 
  recalculateDurations()
  flags.horizontal = -1 
}
Keys.onUpPressed: jump()
Keys.onReleased: {
  if(event.key == Qt.Key_Right) flags.horizontal = 0
  if(event.key == Qt.Key_Left &amp;&amp; flags.horizontal &lt; 0) flags.horizontal = 0
}

function recalculateDurations() {
  xAnimRight.duration = (xAnimRight.to-x)*1000/flags.speed
  xAnimLeft.duration  = (x-xAnimLeft.to)*1000/flags.speed
}
NumberAnimation on x {
  id: xAnimRight
  running: flags.horizontal &gt; 0
  to: parent.width
}
NumberAnimation on x {
  id: xAnimLeft
  running: flags.horizontal &lt; 0
  to: 0
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec226"/>
<em>What just happened?</em>
</h2></div></div></div><p>Instead of performing actions immediately, upon pressing a key, we are now setting flags (in a private object) for which direction the character should be moving in. In our situation, the right <a id="id852" class="indexterm"/>direction has priority over the left direction. Setting a flag triggers an animation that tries to move the character toward an edge of the scene. Releasing the button will clear the flag and stop the animation. Before the animation is started, we are calling the <code class="literal">recalculateDurations()</code> function, which checks how long the animation should last for the character to move at the desired speed.</p><div><div><h3 class="title"><a id="tip81"/>Tip</h3><p>If you want to replace keyboard-based input with something else, for example, accelerometer or custom buttons, the same principle can be applied. When using an accelerometer, you can even control the speed of the player by measuring how much the device is tilted. You can addtionally store the tilt in the <code class="literal">flags.horizontal</code> parameter and make use of that variable in the <code class="literal">recalculateDurations()</code> function.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec227"/>Have a go hero – polishing the animation</h2></div></div></div><p>What we have done is <a id="id853" class="indexterm"/>sufficient for many applications. However, you can try controlling the movement even more. As a challenge, try modifying the system in such a way that during a jump, inertia keeps the current horizontal direction and speed of movement of the character until the end of the jump. If the player releases the right or left keys during a jump, the character will stop only after the jump is complete.</p><p>Despite trying to do everything in a declarative fashion, some actions will still require imperative code. If some action is to be executed periodically, you can use the <code class="literal">Timer</code> parameter to execute a function on demand. Let's go through the process of implementing such patterns together.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec169"/>Time for action – generating coins</h1></div></div></div><p>The goal of the <a id="id854" class="indexterm"/>game we are trying to implement is to collect coins. We will spawn coins now and then in random locations of the scene.</p><p>Create a new QML Document and call it <code class="literal">Coin.qml</code>. In the editor, enter the following code:</p><div><pre class="programlisting">Item {
  id: coin

  Rectangle {
    id: coinVisual
    color: "yellow"
    border.color: Qt.darker(color)
    border.width: 2
    width: 30; height: width
    radius: width/2
    anchors.centerIn: parent

    transform: Rotation {
      axis.y: 1

      NumberAnimation on angle {
        from: 0; to: 360
        loops: Animation.Infinite
        running: true
      }
    }
    Text {
      color: coinVisual.border.color
      anchors.centerIn: parent
      text: "1"
    }
  }
}</pre></div><p>Next, open the document <a id="id855" class="indexterm"/>where the scene is defined and enter the following code somewhere in the scene definition:</p><div><pre class="programlisting">Component {
  id: coinGenerator
  Coin {}
}

Timer {
  id: coinTimer
  interval: 1000
  repeat: true

  onTriggered: {
    var cx = Math.floor(Math.random() * scene.width)
    var cy = Math.floor(Math.random() * scene.height/3) 
             + scene.height/2
    coinGenerator.createObject(scene, { x: cx, y: cy});
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec228"/>
<em>What just happened?</em>
</h2></div></div></div><p>First, we defined a new element type, <code class="literal">Coin</code>, consisting of a yellow circle with a number centered over an empty item. The rectangle has an animation applied that rotates the item around a vertical axis, resulting in a pseudo three-dimensional effect.</p><p>Next, a component able to create instances of a <code class="literal">Coin</code> element is placed in the scene. Then, a <code class="literal">Timer</code> element is declared that fires every second and spawns a new coin at a random location of the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec229"/>Sprite animation</h2></div></div></div><p>The player character, as <a id="id856" class="indexterm"/>well as any other component of the game, should be animated. If the component is implemented using simple Qt Quick shapes, it is quite easy to do by changing the item's properties fluently, by way of using property animations (like we did with the <code class="literal">Coin</code> object). Things get more difficult if a component is complex enough that it is easier to draw it in a graphics program and use an image in the game instead of trying to recreate the object using Qt Quick items. Then, one needs a number of <a id="id857" class="indexterm"/>images—one for every frame of animation. Images would have to keep replacing one another to make a convincing animation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec170"/>Time for action – implementing simple character animation</h1></div></div></div><p>Let's try to <a id="id858" class="indexterm"/>make the player character animated in a simple way. In materials that come with this book, you will find a number of images with different walking phases for Benjamin the Elephant. You can use them or you can draw or download some other images to be used in place of those provided by us.</p><p>Put all images in one directory (for example, <code class="literal">images</code>) and rename them so that they follow a pattern that contains the base animation name followed by a frame number, for example, <code class="literal">walking_01</code>, <code class="literal">walking_02</code>, <code class="literal">walking_03</code>, and so on.</p><p>Next, open the <code class="literal">Player.qml</code> document and replace the image element showing "<code class="literal">elephant.png</code>" with the following code:</p><div><pre class="programlisting">Image {
  property int currentFrame: 1
  property int frameCount: 10
  source: "images/walking_"+currentFrame+".png"
  mirror: player.facingLeft

  anchors.bottom: parent.bottom
  anchors.horizontalCenter: parent.horizontalCenter
  Animation on currentFrame {
    from: 1
    to: frameCount
    loops: Animation.Infinite
    duration: frameCount*40
    running: player.walking
  }
}</pre></div><p>In the root element of <code class="literal">Player.qml</code>, add the following properties:</p><div><pre class="programlisting">property bool walking: flags.horizontal != 0
property bool facingLeft: flags.horizontal &lt; 0</pre></div><p>Start the program and use the arrow keys to see Benjamin move.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec230"/>
<em>What just happened?</em>
</h2></div></div></div><p>A number of images were prepared following a common naming pattern containing a number. All the images have the same size. This allows us to replace one image with another just by changing the value of the <code class="literal">source</code> property to point to a different image. To make it easier, we introduced a property called the <code class="literal">currentFrame</code> element that contains the index of the image to be displayed. We used the <code class="literal">currentFrame</code> element in a string forming an expression bound to the <code class="literal">source</code> element of the image. To make substituting frames easy, a <code class="literal">NumberAnimation</code> element was declared to modify values of the <code class="literal">currentFrame</code> element in a loop from <code class="literal">1</code> to the number of animation frames available (represented by the <code class="literal">frameCount</code> property), so that each frame is shown for 40 miliseconds. The <a id="id859" class="indexterm"/>animation is playing if the <code class="literal">walking</code> property evaluates to <code class="literal">true</code> (based on the value of the <code class="literal">flags.horizontal</code> element in the player object). Finally, we use the <code class="literal">mirror</code> property of the <code class="literal">Image</code> parameter to flip the image if the character is walking left.</p><p>The preceding approach works, but is not perfect. The complexity of the declaration following this pattern grows much faster than required when we want to make movement animation more complex (for example, if we want to introduce jumping). This is not the only problem, though. Loading images does not happen instantly. The first time a particular image is to be used, the animation can stall for a moment while the graphics get loaded, which might ruin the user experience. Lastly, it is simply messy to have a bunch of pictures here and there for every image animation.</p><p>A solution to this is to use <a id="id860" class="indexterm"/>
<strong>sprites</strong>—geometrical animated objects consisting of small images combined into one larger image for better performance. Qt Quick supports sprites through its sprite engine that handles loading sequences of images from a sprite field, animating them and transitioning between different sprites.</p><p>In Qt Quick, a sprite is an image of any type supported by Qt that contains an image strip with all frames of the animation. Subsequent frames should form a contiguous line flowing from left to right and from top to bottom of the image. However, they do not have to start in the top-left corner of the containing image, nor do they have to end in its bottom-right corner—a single file can contain many sprites. A sprite is defined by providing the size of a single frame in pixels and a frame count. Optionally, one can specify an offset from the top-left corner where the first frame of the sprite is to be read from. The following diagram can be helpful in visualizing the scheme:</p><div><img src="img/8874OS_10_09.jpg" alt="What just happened?"/></div><p>QML offers a <code class="literal">Sprite</code> element type with a <code class="literal">source</code> property pointing to the URL of the container image, a <code class="literal">frameWidth</code> and <code class="literal">frameHeight</code> element determining the size of each frame, and a <code class="literal">frameCount</code> element defining the number of frames in the sprite. Offsetting the image can be achieved by setting values of the <code class="literal">frameX</code> and <code class="literal">frameY</code> properties. In addition to this, some additional properties are present; the most important three are <code class="literal">frameRate</code>, <code class="literal">frameDuration,</code> and <code class="literal">duration</code>. All these serve to determine the pace of the animation. If the <code class="literal">frameRate</code> element is defined, it is interpreted as a number of frames to cycle <a id="id861" class="indexterm"/>through per second. If this property is not defined, then the <code class="literal">frameDuration</code> element kicks in and is treated as a period of time in which to display a single frame (thus, it is directly an inverse of the <code class="literal">frameRate</code> element). If this property is not defined, as well, the <code class="literal">duration</code> element is used, which carries the duration of the whole animation. You can set any of the three properties, and precedence rules (<code class="literal">frameRate</code>, <code class="literal">frameDuration</code>, <code class="literal">duration</code>) will determine which of them are going to be applied.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec171"/>Time for action – animating characters using sprites</h1></div></div></div><p>Let's wait <a id="id862" class="indexterm"/>no further. The task at hand is to replace the manual animation from the previous exercise with a sprite-based animation.</p><p>Open the <a id="id863" class="indexterm"/>
<code class="literal">Player.qml</code> document, remove the whole image element responsible for displaying the player character: </p><div><pre class="programlisting">AnimatedSprite {
  id: sprite
  source: "images/walking.png"
  frameX: 560
  frameY: 0
  frameWidth: 80
  frameHeight: 52
  frameCount: 7
  frameRate: 10
  interpolate: true
  width: frameWidth
  height: frameHeight

  running: player.walking
  anchors.bottom: parent.bottom
  anchors.horizontalCenter: parent.horizontalCenter

  transform: Scale {
    origin.x: sprite.width/2
    xScale: player.facingLeft ? -1 : 1
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec231"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have <a id="id864" class="indexterm"/>replaced the previous static image with an ever-changing source with a different item. As the <code class="literal">Sprite</code> parameter is not an <code class="literal">Item</code> element but rather a data definition of a sprite, we cannot use it in place of the <code class="literal">Image</code> element. Instead, we will use the <code class="literal">AnimatedSprite</code> element, which is an item that can display a single animated sprite defined inline. It even has the same set of properties as the <code class="literal">Sprite</code> parameter. We defined a sprite embedded in <code class="literal">images/walking.png</code> with a width of <code class="literal">80</code> and a height of <code class="literal">52</code> pixels. The sprite consists of seven frames that should be displayed at a rate of 10 frames per second. The <code class="literal">running</code> property is set up similar to the original <code class="literal">Animation</code> element. As the <code class="literal">AnimatedSprite</code> element does not have a <code class="literal">mirror</code> property, we emulate it by applying a scale transformation that flips the item horizontally if the <code class="literal">player.facingLeft</code> element evaluates to <code class="literal">true</code>. Additionally, we set the <code class="literal">interpolate</code> <a id="id865" class="indexterm"/>property to <code class="literal">true</code>, which makes the sprite engine calculate smoother transitions between frames.</p><p>The result we are left with is similar to an earlier attempt, so if these two are similar then why bother using sprites? In many situations, you want more complex animation than just a single frame sequence. What if we want to animate the way Benjamin jumps in addition to him walking? Embedding more manual animations, although possible, would explode the number of internal variables required to keep the state of the object. Fortunately, the Qt Quick sprite engine can deal with that. The <code class="literal">AnimatedSprite</code> element we used provides just a subset of features of the whole framework. By substituting the item with the <code class="literal">SpriteSequence</code> element we gain access to the full power of sprites. In talking about <code class="literal">Sprite</code>, we didn't tell you about one additional property of the object, a property called <code class="literal">to</code> that contains a map of probabilities of transitioning from the current sprite to another one. By stating which sprites the current one migrates to, we create a state machine with weighted transitions to other sprites, as well as cycling back to the current state.</p><p>Transitioning to another sprite is triggered by setting the <code class="literal">goalSprite</code> property on the <code class="literal">SpriteSequence</code> object. This will cause the sprite engine to traverse the graph until it reaches the requested state. It is a great way to fluently switch from one animation to another by going through a number of intermediate states.</p><p>Instead of asking the sprite machine to gracefully transit to a given state, one can ask it to force an immediate change by calling the <code class="literal">SpriteSequence</code> class's <code class="literal">jumpTo()</code> method and feeding it with the name of the sprite that should start playing.</p><p>The last thing that <a id="id866" class="indexterm"/>needs to be clarified is how to <a id="id867" class="indexterm"/>actually attach the sprite state machine to the <code class="literal">SpriteSequence</code> class. It is very easy; just assign an array of the <code class="literal">Sprite</code> objects to the <code class="literal">sprites</code> property.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec172"/>Time for action – adding jumping with sprite transitions</h1></div></div></div><p>Let's <a id="id868" class="indexterm"/>replace the <code class="literal">AnimatedSprite</code> class with the <code class="literal">SpriteSequence</code> class in the Bejamin the Elephant animation, adding a sprite to be played during the jumping phase.</p><p>Open the <code class="literal">Player.qml</code> file and replace the <code class="literal">AnimatedSprite</code> object with the following code:</p><div><pre class="programlisting">SpriteSequence {
  id: sprite
  width: 80
  height: 52
  anchors.bottom: parent.bottom
  anchors.horizontalCenter: parent.horizontalCenter
  currentSprite: "still"
  running: true

  Sprite {
    name: "still"
    source: "images/walking.png"
    frameCount: 1
    frameWidth: 80
    frameHeight: 52
    frameDuration: 100
    to: {"still": 1, "walking": 0, "jumping": 0}
  }
  Sprite {
    name: "walking"
    source: "images/walking.png"
    frameCount: 7
    frameWidth: 80
    frameHeight: 52
    frameRate: 10
    to: {"walking": 1, "still": 0, "jumping": 0}
  }
  Sprite {
    name: "jumping"
    source: "images/jumping.png"
    frameCount: 11
    frameWidth: 80
    frameHeight: 70
    frameRate: 4
    to: { "still" : 1 }
  }

  transform: Scale {
    origin.x: sprite.width/2
    xScale: player.facingLeft ? -1 : 1
  }
}</pre></div><p>Next, extend <a id="id869" class="indexterm"/>the <code class="literal">jumpAnim</code> object by adding the highlighted changes:</p><div><pre class="programlisting">SequentialAnimation {
  id: jumpAnim
  running: false
<strong>  ScriptAction { script: sprite.goalSprite = "jumping" }</strong>
  NumberAnimation {
    target: player; property: "y"
    to: player.parent.height-50; easing.type: Easing.OutQuad 
  }
  NumberAnimation {
    target: player; property: "y"
    to: player.parent.height; easing.type: Easing.InQuad 
  }
<strong>  ScriptAction {</strong>
<strong>    script: { sprite.goalSprite = ""; sprite.jumpTo("still"); } </strong>
<strong>  }</strong>
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec232"/>
<em>What just happened?</em>
</h2></div></div></div><p>
<code class="literal">The SpriteSequence</code> element we have introduced has its <code class="literal">Item</code> elements-related properties set up in the same way as when the <code class="literal">AnimatedSprite</code> element was used. Apart from that, a sprite called "still" was explicitly set as the current one. We defined a number of <code class="literal">Sprite</code> objects as children of the <code class="literal">SpriteSequence</code> element. This is equivalent to assigning those sprites to the <code class="literal">sprites</code> property of the object. The complete state machine that was declared is presented in the following diagram:</p><div><img src="img/8874OS_10_10.jpg" alt="What just happened?"/></div><p>A sprite called "still" has just a single frame representing a situation when Benjamin doesn't move. The <a id="id870" class="indexterm"/>sprite keeps spinning in the same state due to the weighted transition back to the "still" state. The two remaining transitions from that state have their weights set to <code class="literal">0</code>, which means they will never trigger spontaneously, but they can be invoked by setting the <code class="literal">goalSprite</code> property to a sprite that can be reached by activating one of those transitions.</p><p>The sequential animation was extended to trigger sprite changes when the elephant lifts into the air.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec233"/>Have a go hero – making Benjamin wiggle his tail in anticipation</h2></div></div></div><p>To practice sprite <a id="id871" class="indexterm"/>transitions, your goal is to extend the state machine of Benjamin's <code class="literal">SpriteSequence</code> element to make him wiggle his tail when the elephant is standing still. You can find the appropriate sprite in the materials that come included with this book. The sprite field is called <code class="literal">wiggling.png</code>. Implement the functionality by making it probable that Benjamin spontaneously goes from the "still" state to "wiggling". Pay attention to ensure the animal stops wiggling and starts walking the moment the player activates the right or left arrow keys.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec234"/>Parallax scrolling</h2></div></div></div><p>We already <a id="id872" class="indexterm"/>discussed the useful technique of parallax scrolling in <a class="link" href="ch06.html" title="Chapter 6. Graphics View">Chapter 6</a>, <em>Graphics View</em>. Just to recapitulate, it gives the impression of depth for 2D games by moving multiple layers of background at a different speed depending on the assumed distance of the layer from the viewer. We will now see how easy it is to apply the same technique in Qt Quick.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec173"/>Time for action – revisiting parallax scrolling</h1></div></div></div><p>We will <a id="id873" class="indexterm"/>implement parallax scrolling with a set of layers that move in the direction opposite to the one the player is moving in. Therefore, we will need a definition of the scene and a moving layer.</p><p>Create a new QML Document (Qt Quick 2). Call it <code class="literal">ParallaxScene.qml</code>. The scene will encompass the whole game "level" and will expose the position of the player to the moving layers. Put the following code in the file:</p><div><pre class="programlisting">import QtQuick 2.2

Item {
  id: root
  property int currentPos
  x: -currentPos*(root.width-root.parent.width)/width
}</pre></div><p>Then, create another QML Document (Qt Quick 2) and call it <code class="literal">ParallaxLayer.qml</code>. Make it contain the following definition:</p><div><pre class="programlisting">import QtQuick 2.2

Item {
  property real factor: 0
  x: factor &gt; 0 ? -parent.currentPos/factor - parent.x : 0
}</pre></div><p>Now, let's use the two new element types in the main QML document. We'll take elements from the earlier scene definition and make them into different parallax layers—the sky, the trees, and the grass:</p><div><pre class="programlisting">Rectangle {
  id: view
  
  width: 600
  height: 380

  ParallaxScene {
    id: scene
    width: 1500; height: 380
    anchors.bottom: parent.bottom
    currentPos: player.x

    ParallaxLayer {
      factor: 7.5
      width: sky.width; height: sky.height
      anchors.bottom: parent.bottom
      Image { id: sky; source: "sky.png" }
    }
    ParallaxLayer {
      factor: 2.5
      width: trees.width; height: trees.height
      anchors.bottom: parent.bottom
      Image { id: trees; source: "trees.png" }
    }
    ParallaxLayer {
      factor: 0
      width: grass.width; height: grass.height
      anchors.bottom: parent.bottom
      Image { id: grass; source: "grass.png" }
    }

    Item {
      id: player
      // ...
    }
  }
}</pre></div><div><img src="img/8874OS_10_11.jpg" alt="Time for action – revisiting parallax scrolling"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec235"/>
<em>What just happened?</em>
</h2></div></div></div><p>The <code class="literal">ParallaxScene</code> element we implemented is a moving plane. Its horizontal offset depends on the <a id="id874" class="indexterm"/>character's current position and the size of the view. The range of scroll of the scene is determined by the difference between the scene size and the view size—it says how much scrolling we have to do when the character moves from the left edge to the right edge of the scene so that it is in view all the time. If we multiply that by the distance of the character from the left edge of the scene expressed as a fraction of the scene width, we will get the needed scene offset in the view (or otherwise speaking, a projection offset of the scene).</p><p>The second type—<code class="literal">ParallaxLayer</code> is also a moving plane. It defines a distance factor that represents the relative distance (depth) of the layer behind the foreground, which influences how fast the plane should be scrolled compared to the foreground (scene). The value of <code class="literal">0</code> means that the layer should be moving with exactly the same speed as the foreground layer. The larger the value, the slower the layer moves compared to the character. The offset value is calculated by dividing the character's position in the scene by the factor. Since the foreground layer is also moving, we have to take it into consideration when calculating the offset for each parallax layer. Thus, we subtract the horizontal position of the scene to get the actual layer offset.</p><p>Having the layers <a id="id875" class="indexterm"/>logically defined, we can add them to the scene. Each layer has a physical representation, in our case, static images containing textures of the sky, trees, and grass. Each layer is defined separately and can live its own life, containing static and animated elements that have no influence on remaining layers. If we wanted to render a sun moving from east to west, we would put it on the sky layer and animate it from one edge of the layer to the other with a long duration.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec236"/>Have a go hero – vertical parallax sliding</h2></div></div></div><p>As an additional <a id="id876" class="indexterm"/>exercise, you might want to implement vertical parallax sliding in addition to a horizontal one. Just make your scene bigger and have it expose the vertical scroll position in addition to the horizontal one reported by the <code class="literal">currentPos</code> element. Then, just repeat all the calculations for the <code class="literal">y</code> property of each layer and you should be done in no time. Remember that distance factors for <code class="literal">x</code> and <code class="literal">y</code> might be different.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec237"/>Collision detection</h2></div></div></div><p>There is no built-in <a id="id877" class="indexterm"/>support for collision detection in Qt Quick, but there are three ways of providing such support. First, you can use a ready collision system available in a number of 2D physics engines such as Box2D. Secondly, you can implement a simple collision system yourself in C++. Lastly, you can do collision checking directly in JavaScript by comparing object coordinates and bounding boxes.</p><p>Our game is very simple; therefore, we will use the last approach. If we had a larger number of moving objects involved in our game, then we would probably choose the second approach. The first approach is best if you have an object of non-rectangular shapes that can rotate and bounce off other objects. In this case, having a physics engine at hand becomes <a id="id878" class="indexterm"/>really useful.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec174"/>Time for action – collecting coins</h1></div></div></div><p>From Qt Creator's <a id="id879" class="indexterm"/>menu, access <strong>File</strong> | <strong>New File or Project</strong>. From <strong>Qt Files And Classes</strong>, choose the JS File template. Call the file "<code class="literal">collisions.js</code>". Put the following content into the document:</p><div><pre class="programlisting">pragma library

function boundingBox(object1) {
  var cR = object1.childrenRect
  var mapped = object1.mapToItem(object1.parent, cR.x, cR.y, cR.width, cR.height)
  return Qt.rect(mapped.x, mapped.y, mapped.width, mapped.height)
}

function intersect(object1, object2) {
  var r1 = boundingBox(object1)
  var r2 = boundingBox(object2)
  return (r1.x &lt;= r2.x+r2.width  &amp;&amp; // r1.left &lt;= r2.right
  r2.x &lt;= r1.x+r1.width  &amp;&amp; // r2.left &lt;= r1.right
  r1.y &lt;= r2.y+r2.height &amp;&amp; // r1.top &lt;= r2.bottom
  r2.y &lt;= r1.y+r1.height)   // r2.top &lt;= r1.bottom
}</pre></div><p>Create another JS File and call it "<code class="literal">coins.js</code>". Enter the following:</p><div><pre class="programlisting">import "collisions.js"

var coins = []

coins.collisionsWith = function(player) {
  var collisions = []
  for(var index = 0; index &lt; length; ++index) {
    var obj = this[index]
    if(intersect(player, obj)) collisions.push(obj)
  }
  return collisions
}
coins.remove = function(obj) {
  var arr = isArray(obj) ? obj : [ obj ]
  var L = arr.length
  var idx, needle
  while(L &amp;&amp; this.length) {
    var needle = arr[--L]
    idx = this.indexOf(needle)
    if(idx != -1) { this.splice(idx, 1) }
  }
  return this
}</pre></div><p>Finally, open the main document and add the following <code class="literal">import</code> statement:</p><div><pre class="programlisting">import "coins.js"</pre></div><p>In the player <a id="id880" class="indexterm"/>object, define the <code class="literal">checkCollisions()</code> function:</p><div><pre class="programlisting">function checkCollisions() {
  var result = coins.collisionsWith(player)
  if(result.length == 0) return
  result.forEach(function(coin) { coin.hit() })
  coins.remove(result) // prevent the coin from being hit again
}</pre></div><p>Lastly, in the same player object, trigger collision detection by handling the position changes of the player:</p><div><pre class="programlisting">onXChanged: { checkCollisions() }
onYChanged: { checkCollisions() }</pre></div><p>In the <code class="literal">Coin.qml</code> file, define an animation and a <code class="literal">hit()</code> function:</p><div><pre class="programlisting">SequentialAnimation {
  id: hitAnim
  running: false
  NumberAnimation {
    target: coin
    property: "opacity"
    from: 1; to: 0
    duration: 250
  }
  ScriptAction {
    script: coin.destroy()  
  }
}

function hit() {
  hitAnim.start()
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec238"/>
<em>What just happened?</em>
</h2></div></div></div><p>The file <code class="literal">collisions.js</code> contains functions used to do collision checking. The first line of the file is a pragma statement noting that this document only contains functions and does not contain any mutable object. This is so that we can add a <code class="literal">.pragma library</code> statement, which marks the document as a library that can be shared between documents that import it. This aids in reduced memory consumption and improved speed as the engine doesn't have to reparse and execute the document each time it is imported.</p><p>The functions defined in the library are really simple. The first one returns a bounding rectangle of an object based on its coordinates and the size of its children. It assumes that the top-level item is empty and contains children that represent the visual aspect of the object. Children coordinates are mapped using the <code class="literal">mapToItem</code> element so that the rectangle returned is expressed in the parent item coordinates. The second function does a trivial checking of intersection between two bounding rectangles and returns <code class="literal">true</code> if they intersect and <code class="literal">false</code> otherwise.</p><p>The second document keeps a definition of an array of coins. It adds two methods to the array object. The first one—<code class="literal">collisionsWith</code>—performs a collision check between any of the items in the array and the given object using functions defined in <code class="literal">collisions.js</code>. That's why we import the library at the start of the document. The method returns another array that contains objects intersecting the <code class="literal">player</code> argument. The other method, called <code class="literal">remove</code>, takes an object or an array of objects and removes them from <code class="literal">coins</code>.</p><p>The document is not a library; therefore, each document that imports <code class="literal">coins.js</code> would get its own separate copy of the object. Thus, we need to ensure that <code class="literal">coins.js</code> is imported only once in the game so that all references to the objects defined in that document relate to the same instance of the object in our program memory.</p><p>Our main document <a id="id881" class="indexterm"/>imports <code class="literal">coins.js</code>, which creates the array for storing coin objects and makes its auxiliary functions available. This allows the defined <code class="literal">checkCollisions()</code> function to retrieve the list of coins colliding with the player. For each coin that collides with the player, we execute a <code class="literal">hit()</code> method; as a last step, all colliding coins are removed from the array. Since coins are stationary, collision can only occur when the player character enters an area occupied by a coin. Therefore, it is enough to trigger collision detection when the position of the player character changes—we use the <code class="literal">onXChanged</code> and <code class="literal">onYChanged</code> handlers.</p><p>As hitting a coin results in removing it from the array, we lose a reference to the object. The <code class="literal">hit()</code> method has to initiate removal of the object from the scene. A minimalistic implementation of this function would be to just call the <code class="literal">destroy()</code> function on the object, but we do more—the removal can be made smoother by running a fade-out animation on the coin. As a last step, the animation can destroy the object.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec57"/>Notes on collision detection</h2></div></div></div><p>The number of <a id="id882" class="indexterm"/>objects we track on the scene is really small, and we simplify the shape of each object to a rectangle. This lets us get away with checking collisions in JavaScript. For a larger amount of moving objects, custom shapes, and handling rotations, it is much better to have a collision system based on C++. The level of complexity of <a id="id883" class="indexterm"/>such a system depends on your needs.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec239"/>Eye candy</h2></div></div></div><p>A game should not just be based upon an interesting idea; it should not only work fluently on a range of devices and give entertainment to those people playing it. It should also look nice and behave nicely. Whether one is choosing from a number of similar implementations of the same game or wants to spend money on another similarly priced and entertaining game, there is a good chance the game she or he chooses will be the one that looks the best—having a lot of <a id="id884" class="indexterm"/>animations, graphics, and flashy content. We already learned a number of techniques to make a game more pleasing to the eye, such as using animations or GLSL shaders. Here, we will show you a number of other techniques that can make your Qt Quick applications more attractive.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec58"/>Auto-scaling user interfaces</h3></div></div></div><p>The first <a id="id885" class="indexterm"/>extension you might implement is making your game auto-adjust to the device resolution it is running on. There are basically two ways to accomplish this. The first is to center the user interface in the window (or screen) and if it doesn't fit, enable scrolling. The other approach is to scale the interface to always fit the window (or screen). Which to choose depends on a number of factors, the most important of which is whether your UI is good enough when upscaled. If the interface consists of text and non-image primitives (basically rectangles) or if it includes images but only vector ones or those with very high resolution, then it is probably fine to try and scale the user interface. Otherwise, if you use a lot of low resolution bitmap images, you will have to choose one particular size for the UI (optionally allowing it to downscale since the quality degradation should be less significant in this direction if you enable anti-aliasing).</p><p>Whether you choose to scale or to center and scroll, the basic approach is the same—you put your UI item in another item so that you have fine control over the UI geometry regardless of what happens to the top-level window. Taking the centered approach is quite easy—just anchor the UI to the center of the parent. To enable scrolling, wrap the UI in the <code class="literal">Flickable</code> item and constrain its size if the size of the window is not big enough to fit the whole user interface:</p><div><pre class="programlisting">Item {
  id: window

  Flickable {
    id: uiFlickable
    anchors.centerIn: parent
    contentWidth: ui.width; contentHeight: ui.height

    width: parent.width &gt;= contentWidth ? contentWidth : parent.width
    height: parent.height &gt;= contentHeight ? contentHeight : parent.height

    UI { id: ui }
  }
}</pre></div><p>You should probably decorate the top-level item with a nice background if the UI item does not occupy the full area of its parent.</p><p>Scaling seems more complicated, but with Qt Quick it is really easy. Again, you have two choices—either stretch or scale. Stretching is as easy as executing the <code class="literal">anchors.fill: parent</code> command, which effectively forces the UI to recalculate the geometry of all its items but possibly allows us to use the space more efficiently. It is, in general, very time-consuming for the developer to provide expressions for calculating the geometry of each and every element <a id="id886" class="indexterm"/>in the user interface as the size of the view changes. This is usually not worth the effort. A simpler approach is to just scale the UI item to fit the window, which will implicitly scale the contained items. In such an event, their size can be calculated relative to the base size of the main view of the user interface. For this to work, you need to calculate the scale that is to be applied to the user interface to make it fill the whole space available. The item has a scale of 1 when its effective width equals its implicit width and its effective height equals its implicit height. If the window is larger, we want to scale the item up until it reaches the size of the window. Therefore, the window's width divided by the item's implicit width will be the item's scale in the horizontal direction. This is shown in the following diagram:</p><div><img src="img/8874OS_10_12.jpg" alt="Auto-scaling user interfaces"/></div><p>The same can be applied to the vertical direction, but if the UI has a different aspect ratio than the window, its horizontal and vertical scale factors will be different. For the UI to look nice, we have to take the lower of the two values—to only scale up as much as the direction with less space allows, leaving a gap in the other direction:</p><div><pre class="programlisting">Item {
  id: window

  UI {
    id: ui

    anchors.centerIn: parent
    scale: Math.min(parent.width/width, parent.height/height)
  }
}</pre></div><p>Again, it might be a good idea to put some background on the window item to fill in the gaps.</p><p>What if you want to <a id="id887" class="indexterm"/>save some margin between the user interface and the window? You could, of course, take that into consideration when calculating the scale (<code class="literal">(window.width-2*margin)/width</code>, and so on) but there is an easier way—simply put an additional item inside the window, leaving an appropriate margin, and put the user interface item in that additional item and scale it up to the additional item's size:</p><div><pre class="programlisting">Item {
  id: window
 <strong> Item {</strong>
<strong>    anchors { fill: parent; margins: 10 }</strong>
    UI {
      id: ui

      anchors.centerIn: parent
      scale: Math.min(parent.width/width, parent.height/height)
    }
<strong>  }</strong>
}</pre></div><p>When you scale elements a lot, you should consider enabling anti-aliasing for items that can lose quality when rendered in a size different than their native size (for example, images). This is done very easily in Qt Quick as each <code class="literal">Item</code> instance has a property called <code class="literal">antialiasing</code> which, when enabled, will cause the rendering backend to try to reduce distortions caused by the aliasing effect. Remember that this comes at the cost of increased rendering complexity, so try to find a balance between quality and efficiency, especially on low-end hardware. You might provide an option to the user to globally enable or disable anti-aliasing for all game objects or to gradually adjust quality settings for different object types.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec59"/>Graphical effects</h3></div></div></div><p>The basic two <a id="id888" class="indexterm"/>predefined items in Qt Quick are rectangle and image. One can use them in a variety of creative ways and make them more pleasant-looking by applying GLSL shaders. However, implementing a shader program from scratch is cumbersome and requires in-depth knowledge of the shader language. Luckily, a number of common effects are already implemented and ready to use in the form of the <code class="literal">QtGraphicalEffects</code> module.</p><p>To add a subtle black shadow to our canvas-based heartbeat element defined in the <code class="literal">HeartBeat.qml</code> file, use a code similar to the following that makes use of the <code class="literal">DropShadow</code> effect:</p><div><pre class="programlisting">import QtQuick 2.0
import QtGraphicalEffects 1.0

Item {
  width: 1000; height: 600
  HeartBeat { id: hb; anchors.centerIn: parent; visible: false }
  DropShadow {
    source: hb
    anchors.fill: hb
    horizontalOffset: 3
    verticalOffset: 3
    radius: 8
    samples: 16
    color: "black"
  }
}</pre></div><p>To apply a shadow effect, you need an existing item as the source of the effect. In our case, we are using an instance of the <code class="literal">HeartBeat</code> class centered in a top-level item. Then, the shadow effect is defined and its geometry follows that of its source by using the <code class="literal">anchors.fill</code> element. Just as the <code class="literal">DropShadow</code> class renders the original item as well as the shadow, the original item can be hidden by setting its <code class="literal">visible</code> property to <code class="literal">false</code>.</p><div><img src="img/8874OS_10_14.jpg" alt="Graphical effects"/></div><p>Most of the <code class="literal">DropShadow</code> class's properties are self-explanatory, but two properties—<code class="literal">radius</code> and <code class="literal">samples</code>—require some additional explanation. The shadow is drawn as a blurred monochromatic copy of the original item offset by a given position. The two mentioned properties control the amount of blur and its quality—the more samples used for blurring, the better the effect, but also the more demanding the computation that needs to be performed.</p><p>Speaking of blur, the <a id="id889" class="indexterm"/>plain blurring effect is also available in the graphics effects module through the <code class="literal">GaussianBlur</code> element type. To apply a blur instead of a shadow to the last example, simply replace the occurrence of the <code class="literal">DropShadow</code> class with the following code:</p><div><pre class="programlisting">GaussianBlur {
  source: hb
  anchors.fill: hb
  radius: 12
  samples: 20
  transparentBorder: true
}</pre></div><div><img src="img/8874OS_10_15.jpg" alt="Graphical effects"/></div><p>Here, you can see two earlier mentioned properties as well as a vaguely named <code class="literal">transparentBorder</code> one. Enabling <a id="id890" class="indexterm"/>this property fixes some artifacts on the edges of the blur and in general, you'll want to keep it that way.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec240"/>Have a go hero – the blur parallax scrolled game view</h2></div></div></div><p>The <code class="literal">blur</code> <a id="id891" class="indexterm"/>property is a very nice effect that can be used in many situations. For example, you could try to implement a feature within our elephant game whereby, when the user pauses the game (for example, by pressing the<em> P</em> key on the keyboard), the view gets blurred. Make the effect smooth by applying an animation to the effect's <code class="literal">radius</code> property.</p><p>Another interesting effect is <code class="literal">Glow</code>. It renders a colored and blurred copy of the source element. An example use case for games is highlighting some parts of the user interface—you can direct the user's attention to the element (for example, button or badge) by making the element flash periodically:</p><div><pre class="programlisting">Badge {
  id: importantBadge
}
Glow {
  source: importantBadge
  anchors.fill: source
  samples: 16
  color: "red"

  SequentialAnimation on radius {
    loops: Animation.Infinite
    running: true

    NumberAnimation { from: 0; to: 10; duration: 2000 }
    PauseAnimation  { duration: 1000 }
    NumberAnimation { from: 10; to: 0; duration: 2000 }
    PauseAnimation  { duration: 1000 }
  }
}</pre></div><p>The complete module contains 20 different effects. We cannot describe each effect in detail here. Nevertheless, you can learn about it yourself. If you clone the module's source git repository (found under <a class="ulink" href="http://git://code.qt.io/qt/qtgraphicaleffects.git">git://code.qt.io/qt/qtgraphicaleffects.git</a>) in the <code class="literal">tests/manual/testbed</code> subdirectory of the cloned repository, you will find a nice application for testing existing effects. To run the tool, open the <code class="literal">testBed.qml</code> file with <code class="literal">qmlscene</code>.</p><div><img src="img/8874OS_10_16.jpg" alt="Have a go hero – the blur parallax scrolled game view"/></div><div><div><h3 class="title"><a id="tip82"/>Tip</h3><p>You can also <a id="id892" class="indexterm"/>access a complete list of effects and their short descriptions by navigating to the <strong>GraphicalEffects</strong> help page in the documentation.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec60"/>Particle systems</h3></div></div></div><p>A commonly <a id="id893" class="indexterm"/>used visual effect in systems such as games is generating a large number of small, usually short-lived, often fast-moving, fuzzy objects such as stars, sparks, fumes, dust, snow, splinters, falling leaves, or the like. Placing these as regular items within a scene would greatly degrade performance. Instead, a special engine is used which keeps a registry of such objects and tracks (simulates) their logical attributes without having physical entities in the scene. Such objects, called <a id="id894" class="indexterm"/>particles, are rendered upon request in the scene using very efficient algorithms. This allows us to use a large number of particles without having a negative impact on the rest of the scene.</p><p>Qt Quick provides a particle system in the <code class="literal">QtQuick.Particles</code> import. The <code class="literal">ParticleSystem</code> element provides the core for the simulation, which uses the <code class="literal">Emitter</code> elements to spawn particles. They are then rendered according to definitions in a <code class="literal">ParticlePainter</code> element. Simulated entities can be manipulated using the <code class="literal">Affector</code> objects, which can modify the trajectory or life span of particles.</p><p>Let's start with a simple example. The following code snippet declares the simplest possible particle system:</p><div><pre class="programlisting">import QtQuick 2.0
import QtQuick.Particles 2.0

ParticleSystem {
  id: particleSystem
  width: 360; height: 360

  Emitter { anchors.fill: parent }
  ImageParticle { source: "star.png" }
}</pre></div><p>The result can <a id="id895" class="indexterm"/>be observed in the following image:</p><div><img src="img/8874OS_10_17.jpg" alt="Particle systems"/></div><p>Let's analyze the code. After importing <code class="literal">QtQuick.Particles 2.0</code>, a <code class="literal">ParticleSystem</code> item is instantiated that defines the domain of the particle system. We define two objects within that system. The first object is the <code class="literal">Emitter</code> and defines an area where particles will be spawned. The area is set to encompass the whole domain. The second object is an object of the <code class="literal">ImageParticle</code> type, which is a <code class="literal">ParticlePainter</code> subclass. It determines that particles should be rendered as instances of a given image. By default, the <code class="literal">Emitter</code> object spawns 10 particles per second, each of which lives for one second and then dies and is removed from the scene. In the code presented, the <code class="literal">Emitter</code> and <code class="literal">ImageParticle</code> objects are direct children of the <code class="literal">ParticleSystem</code> class; however, this doesn't have to be the case. The particle system can be explicitly specified by setting the <code class="literal">system</code> property.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec61"/>Tuning the emitter</h3></div></div></div><p>You can control the <a id="id896" class="indexterm"/>amount of particles being emitted by setting the <code class="literal">emitRate</code> property of the emitter. Another property called the <code class="literal">lifeSpan</code> determines how many milliseconds it takes before a particle dies. To introduce some random behavior, you can use the <code class="literal">lifeSpanVariation</code> property to set a maximum amount of time (in milliseconds) the life span can be altered by the system (in both directions). Increasing the emission rate and life span of particles can lead to a situation in which a very large number of particles have to be managed (and possibly rendered). This can degrade performance; thus, an upper limit of particles that can concurrently be alive can be set through the <code class="literal">maximumEmitted</code> property:</p><div><pre class="programlisting">ParticleSystem {
  id: particleSystem
  width: 360; height: 360

  Emitter {
    anchors.fill: parent
    emitRate: 350
    lifeSpan: 1500
    lifeSpanVariation: 400 // effective: 1100-1900 ms
  }
  ImageParticle { source: "star.png" }
}</pre></div><div><img src="img/8874OS_10_18.jpg" alt="Tuning the emitter"/></div><p>Tweaking the life <a id="id897" class="indexterm"/>span of particles makes the system more diverse. To strengthen the effect, you can also manipulate the size of each particle through the <code class="literal">size</code> and <code class="literal">sizeVariation</code> properties:</p><div><pre class="programlisting">ParticleSystem {
  id: particleSystem
  width: 360; height: 360

  Emitter {
    anchors.fill: parent
    emitRate: 50
    size: 12
    sizeVariation: 6
    endSize: 2
  }
  ImageParticle { source: "star.png" }
}</pre></div><div><img src="img/8874OS_10_19.jpg" alt="Tuning the emitter"/></div><p>The range of functionality presented thus far should be enough to create many nice-looking and useful particle systems. The limitation so far has been that particles are emitted from the whole area of the emitter, which is a regular <code class="literal">QQuickItem</code> and thus is rectangular. This doesn't have to be the case, though. The <code class="literal">Emitter</code> element contains a <code class="literal">shape</code> property, which is a way to declare the area that is to be giving birth to particles. The <code class="literal">QtQuick.Particles</code> parameter defines three types of custom shape that can be used— <code class="literal">EllipseShape</code>, <code class="literal">LineShape</code>, and <code class="literal">MaskShape</code>. The first two are very simple, defining either an <a id="id898" class="indexterm"/>empty or filled ellipse inscribed in the item or a line crossing one of the two diagonals of the item. The <code class="literal">MaskShape</code> element is more interesting as it makes it possible to use an image as a shape for the <code class="literal">Emitter</code> element.</p><div><pre class="programlisting">ParticleSystem {
  id: particleSystem
  width: 360; height: 360

  Emitter {
    anchors.fill: parent
    emitRate: 1600
    shape: MaskShape { source: "star.png" }
  }
  ImageParticle { source: "star.png" }
}</pre></div><div><img src="img/8874OS_10_20.jpg" alt="Tuning the emitter"/></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec62"/>Rendering particles</h3></div></div></div><p>Thus far, we have <a id="id899" class="indexterm"/>used a bare <code class="literal">ImageParticle</code> element to render particles. It is only one of three <code class="literal">ParticlePainters</code> available, with the others being <code class="literal">ItemParticle</code> and <code class="literal">CustomParticle</code>. But before we move on to other renderers, let's focus on tweaking the <code class="literal">ImageParticle</code> element to obtain some interesting effects.</p><p>The <code class="literal">ImageParticle</code> element renders each logical particle as an image. The image can be manipulated separately for each particle by changing its color and rotation, deforming its shape, or using it as a sprite animation.</p><p>To influence the color of particles, you can use any of the large number of dedicated properties—<code class="literal">alpha</code>, <code class="literal">color</code>, <code class="literal">alphaVariation</code>, <code class="literal">colorVariation</code>, <code class="literal">redVariation</code>, <code class="literal">greenVariation</code>, and <code class="literal">blueVariation</code>. The first two properties define the base value for respective attributes and the remaining properties set the maximum deviation of a respective parameter from the base value. In the case of opacity, there is only one type of variation you can use but when defining the color, you can either set different values for each of the red, green, and blue channels or you can use the global <code class="literal">colorVariation</code> property, which is similar to setting the same value for all three channels. Allowed values are any between the range of 0 (no deviation allowed) to 1.0 (100% in either direction).</p><div><img src="img/8874OS_10_21.jpg" alt="Rendering particles"/></div><p>The properties mentioned are stationary—the particle obeys the constant value during its whole life. The <code class="literal">ImageParticle</code> element also exposes two properties, letting you control the color of particles relative to their age. First of all, there is a property called <code class="literal">entryEffect</code> that defines what happens with the particle at its birth and death. The default value is <code class="literal">Fade</code>, which makes particles fade in from 0 opacity at the start of their life and fades them back to 0 just before they die. You have already experienced this effect in all earlier particle animations we demonstrated. Other values for the property are <code class="literal">None</code> and <code class="literal">Scale</code>. The first one is obvious—there is no entry effect associated with particles. The second one scales particles from 0 at their birth and scales them back to 0 at the end of their life.</p><p>The other time-related property is <code class="literal">colorTable</code>. You can feed it with a URL of an image to be used as a one-dimensional texture determining the color of each particle over its life. At the beginning, the particle gets color-defined by the left edge of the image and then progresses <a id="id900" class="indexterm"/>right in a linear fashion. It is most common to set an image here containing a color gradient to achieve smooth transitions between colors.</p><p>The second parameter that can be altered is the rotation of a particle. Here, we can also either use properties that define constant values for rotation (<code class="literal">rotation</code> and <code class="literal">rotationVariation</code>) specified in degrees or modify the rotation of particles in time with <code class="literal">rotationVelocity</code> and <code class="literal">rotationVelocityVariation</code>. The velocity defines the pace or rotation in degrees per second.</p><p>Particles can also be deformed. The properties <code class="literal">xVector</code> and <code class="literal">yVector</code> allow binding vectors, which define distortions in horizontal and vertical axes. We will describe how to set the vectors in the next section. Last but not least, using the <code class="literal">sprites</code> property you can define a list of sprites that will be used to render particles. This works in a similar fashion to <code class="literal">SpriteAnimation</code>, described in an earlier section of this chapter.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec63"/>Making particles move</h3></div></div></div><p>Apart from fading <a id="id901" class="indexterm"/>and rotating, the particle systems we have seen so far were very static. While this is useful for making star fields, it is not useful at all for explosions, sparks, or even falling snow. This is because particles are mostly about movement. Here, we will show you two aspects of making your particles fly.</p><p>The first aspect is modeling how the particles are born. By that, we mean the physical conditions of the object creating the particles. During an explosion, matter is pushed away from the epicenter with a very large force that causes air and small objects to rush outwards at an extremely high speed. Fumes from a rocket engine are ejected with high velocities in the direction opposite to that of the propelled craft. A moving comet draws along a braid of dust and gases put into motion by the inertia.</p><p>All these conditions can be modeled by setting the velocity or acceleration of the particles. These two metrics are described by vectors determining the direction and amount (magnitude or length) of the given quantity. In Qt Quick, such vectors are represented by an element type called <code class="literal">StochasticDirection</code>, where the tail of the vector is attached to the object and the position of the head is calculated by the <code class="literal">StochasticDirection</code> instance. Since we have no means of setting attributes on particles because we have no objects representing them, those two attributes—<code class="literal">velocity</code> and <code class="literal">acceleration</code>—are applied to emitters spawning the particles. Because you can have many emitters in a single particle system, you can set different velocities and accelerations for particles of different origins.</p><p>There are four types of direction elements representing different sources of information about the direction. First, there is <code class="literal">CumulativeDirection</code>, which acts as a container for other direction types and works like a sum of directions contained within.</p><p>Then, there is <code class="literal">PointDirection</code>, where you can specify <code class="literal">x</code> and <code class="literal">y</code> coordinates of a point where the head of the vector should be attached. To avoid the unrealistic effect of all particles heading in the same direction, you can specify <code class="literal">xVariation</code> and <code class="literal">yVariation</code> to introduce allowed deviation from a given point.</p><div><img src="img/8874OS_10_22.jpg" alt="Making particles move"/></div><p>The third type is the most popular stochastic direction type—<code class="literal">AngleDirection</code>, which directly specifies the <a id="id902" class="indexterm"/>angle (in degrees clockwise from straight right) and magnitude (in pixels per second) of the vector. The angle can vary from the base by <code class="literal">angleVariation</code> and similarly, <code class="literal">magnitudeVariation</code> can be used to introduce variation to the length of the vector:</p><div><img src="img/8874OS_10_23.jpg" alt="Making particles move"/></div><p>The last type is similar to the previous one. The <code class="literal">TargetDirection</code> vector can be used to point the vector toward the center of a given Qt Quick item (set with the <code class="literal">targetItem</code> property). The length of the vector is calculated by giving the <code class="literal">magnitude</code> and <code class="literal">magnitudeVariation</code>, and both can be interpreted as pixels per second or multiples of distance between the source and target points (depending on the value of the <code class="literal">proportionalMagnitude</code> property):</p><div><img src="img/8874OS_10_24.jpg" alt="Making particles move"/></div><p>Let's get back to <a id="id903" class="indexterm"/>setting particle velocity. We can use the <code class="literal">AngleDirection</code> vector to specify that particles should be moving left, spreading at a maximum of 45 degrees:</p><div><pre class="programlisting">Emitter {
  anchors.centerIn: parent
  width: 50; height: 50
  emitRate: 50

  velocity: AngleDirection {
    angleVariation: 45
    angle: 180
    magnitude: 200
  }
}</pre></div><div><img src="img/8874OS_10_25.jpg" alt="Making particles move"/></div><p>Setting acceleration works the same way. You can even set both the initial velocity and the acceleration each <a id="id904" class="indexterm"/>particle should have. It is very easy to shoot the particles in the left direction and start pulling them down:</p><div><pre class="programlisting">Emitter {
  anchors.right: parent.right
  anchors.verticalCenter: parent.verticalCenter
  emitRate: 15
  lifeSpan: 5000

  velocity: AngleDirection {
    angle: 180
    magnitude: 200
  }
  acceleration: AngleDirection {
    angle: 90 // local left = global down
    magnitude: 100
  }
}</pre></div><div><img src="img/8874OS_10_26.jpg" alt="Making particles move"/></div><p>The <code class="literal">Emitter</code> element has one more nice property that is useful in the context of moving particles. Setting the <code class="literal">velocityFromMovement</code> parameter to a value different than <code class="literal">0</code> makes any movement of the <code class="literal">Emitter</code> element apply to the velocity of the particles. The direction of the <a id="id905" class="indexterm"/>additional vector matches the direction of the emitter's movement, and the magnitude is set to the speed of the emitter multiplied by the value set to <code class="literal">velocityFromMovement</code>. It is a great way to generate fumes ejected from a rocket engine:</p><div><pre class="programlisting">Item {
  Image {
    id: image
    source: "rocket.png"
  }
  Emitter {
    anchors.right: image.right
    anchors.verticalCenter: image.verticalCenter
    emitRate: 500
    lifeSpan: 3000
    lifeSpanVariation: 1000
    velocityFromMovement: -20

    velocity: AngleDirection {
      magnitude: 100
      angleVariation: 40
    }
  }
  NumberAnimation on x {
    ...
  }
}</pre></div><div><img src="img/8874OS_10_27.jpg" alt="Making particles move"/></div><p>The second way of addressing the behavior of particles is to influence their attributes after they are born—in any particular moment of their life. This can be done using affectors. These are items inheriting affector, which can modify some attributes of particles currently <a id="id906" class="indexterm"/>traveling though the area of the affector. One of the simplest affectors is <code class="literal">Age</code>. It can advance particles to a point in their lifetime where they only have <code class="literal">lifeLeft</code> milliseconds of their life left.</p><div><pre class="programlisting">Age {
  once: true
  lifeLeft: 500
  shape: EllipseShape { fill: true }
  anchors.fill: parent
}</pre></div><p>Setting <code class="literal">once</code> to <code class="literal">true</code> makes each affector influence a given particle only once. Otherwise, each particle can have its attributes modified many times.</p><p>Another affector type is Gravity, which can accelerate particles in a given angle. Friction can slow particles down, and attractor will affect the particle's position, velocity, or acceleration so that it starts traveling toward a given point. Wander is great for simulating snowflakes or butterflies flying in pseudo-random directions.</p><p>There are also other <a id="id907" class="indexterm"/>affector types available, but we will not go into their details here. We would like to warn you, however, against using affectors too often—they can severely degrade performance.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec175"/>Time for action – vanishing coins spawning particles</h1></div></div></div><p>It is time <a id="id908" class="indexterm"/>now to practice our freshly acquired skills. The task is to add a particle effect to the game when the player collects coins. The coin will explode into a sprinkle of colorful stars when collected.</p><p>Start by declaring a particle system as filling the game scene, along with the particle painter definition:</p><div><pre class="programlisting">ParticleSystem {
  id: coinParticles
  anchors.fill: parent // scene is the parent

  ImageParticle {
    source: "particle.png"
    colorVariation: 1
    rotationVariation: 180
    rotationVelocityVariation: 10
  }
}</pre></div><p>Next, modify the definition of Coin to include an emitter:</p><div><pre class="programlisting">Emitter {
  id: emitter
  system: coinParticles
  emitRate: 0
  lifeSpan: 500
  lifeSpanVariation: 100
  velocity: AngleDirection { angleVariation: 180; magnitude: 10 }
  acceleration: AngleDirection { angle: 270; magnitude: 2 }
}</pre></div><p>Finally, the hit function has to be updated:</p><div><pre class="programlisting">function hit() {
  emitter.burst(50)
  hitAnim.start()
}</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec241"/>
<em>What just happened?</em>
</h2></div></div></div><p>In this exercise, we defined a simple particle system that fills the whole scene. We defined a simple image painter for the particles where we allow particles to take on all the colors and start in all possible rotations. We used a star pixmap as our particle template.</p><p>Then, an <code class="literal">Emitter</code> <a id="id909" class="indexterm"/>object is attached to every coin. Its <code class="literal">emitRate</code> is set to <code class="literal">0</code>, which means it does not emit any particles on its own. We set a varying life span on particles and let them fly in all directions by setting their initial velocity with an angle variation of 180 degrees in both directions (giving a total of 360 degrees). By setting an acceleration, we give the particles a tendency to travel toward the bottom edge of the scene.</p><p>In the hit function, we call a <code class="literal">burst()</code> function on the emitter, which makes it give instant birth to a given number of particles.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec176"/>Summary</h1></div></div></div><p>In this chapter, we have shown you how to extend your QML skills to make your applications dynamic and attractive. We've gone through the process of recreating and improving a game created earlier in C++ to familiarize you with such concepts as collision detection, state-driven objects, and time-based game loops. We also presented you with a tool in the form of <code class="literal">ShaderEffect</code>, which can serve as a means to create stunning graphics without compromising performance, and we taught you to use a particle system.</p><p>Of course, Qt Quick is much richer than all this, but we had to stop somewhere. The set of skills we have hopefully passed on to you should be enough to develop many great games. However, many of the elements have more properties than we have described here. Whenever you want to extend your skills, you can check the reference manual to see if the element type has more interesting attributes.</p><p>This concludes our book on game programming using Qt. We have taught you the general basics of Qt, described its widget realm to you, and introduced you to the fascinating world of Qt Quick. Widgets (including graphics view) and Qt Quick are the two paths you can take when creating games using the Qt framework. We have also shown you ways of merging the two approaches by making use of any OpenGL skills you might have, going beyond what Qt already offers today. At this point, you should start playing around and experimenting, and if at any point you feel lost or simply lack the information on how to do something, the very helpful Qt reference manual should be the first resource you direct yourself to.</p><p>Good luck and have lots of fun!</p></div></body></html>