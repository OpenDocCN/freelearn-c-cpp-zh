- en: Chapter 8. Interactive Real-time Data Visualization on Mobile Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 移动设备上的交互式实时数据可视化
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Visualizing real-time data from built-in Inertial Measurement Units (IMUs)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化内置惯性测量单元（IMUs）的实时数据
- en: Part I – handling multi-touch interface and motion sensor inputs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分 – 处理多点触控界面和运动传感器输入
- en: Part II – interactive, real-time data visualization with mobile GPUs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分 – 使用移动GPU进行交互式、实时数据可视化
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will demonstrate how to visualize data interactively using
    built-in motion sensors called **Inertial Measurement Units** (**IMUs**) and the
    multi-touch interface on mobile devices. We will further explore the use of shader
    programs to accelerate computationally intensive operations to enable real-time
    visualization of 3D data with mobile graphics hardware. We will assume familiarity
    with the basic framework for building an Android-based OpenGL ES 3.0 application
    introduced in the previous chapter and add significantly more complexity in the
    implementation in this chapter to achieve interactive, real-time 3D visualization
    of a Gaussian function using both motion sensors and the multi-touch gesture interface.
    The final demo is designed to work on any Android-based mobile device with proper
    sensor hardware support.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何使用内置的运动传感器，称为**惯性测量单元**（**IMUs**）以及移动设备上的多点触控界面，来交互式地可视化数据。我们将进一步探讨使用着色器程序来加速计算密集型操作，以便使用移动图形硬件实时可视化3D数据。我们假设读者熟悉前一章中介绍的基于Android的OpenGL
    ES 3.0应用程序的基本框架，并在本章的实现中添加了显著更多的复杂性，以实现使用运动传感器和多点触控手势界面进行交互式、实时3D可视化高斯函数。最终的演示设计为适用于任何具有适当传感器硬件支持的基于Android的移动设备。
- en: Here, we will first introduce how to extract data directly from the IMUs and
    plot the real-time data stream acquired on an Android device. We will divide the
    final demo into two parts given its complexity. In part I, we will demonstrate
    how to handle the multi-touch interface and motion sensor inputs on the Java side.
    In part II, we will demonstrate how to implement the shader program in OpenGL
    ES 3.0 and other components of the native code to finish our interactive demo.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将首先介绍如何直接从IMUs提取数据并绘制在Android设备上获取的实时数据流。鉴于其复杂性，我们将最终演示分为两部分。在第一部分中，我们将演示如何在Java端处理多点触控界面和运动传感器输入。在第二部分中，我们将演示如何在OpenGL
    ES 3.0中实现着色器程序以及原生代码的其他组件，以完成我们的交互式演示。
- en: Visualizing real-time data from built-in Inertial Measurement Units (IMUs)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化内置惯性测量单元（IMUs）的实时数据
- en: Many modern mobile devices now integrate a plethora of built-in sensors including
    various motion and position sensors (such as an accelerometer, gyroscope, and
    magnetometer/digital compass) to enable novel forms of user interaction (such
    as complex gesture and motion control) as well as other environmental sensors,
    which can measure environmental conditions (such as an ambient light sensor and
    proximity sensor) to enable smart wearable applications. The Android Sensor Framework
    provides a comprehensive interface to access many types of sensors, which can
    be either hardware-based (physical sensors) or software-based (virtual sensors
    that derive inputs from hardware sensors). In general, there are three major categories
    of sensors—motion sensors, position sensors, and environmental sensors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代移动设备现在集成了大量的内置传感器，包括各种运动和位置传感器（如加速度计、陀螺仪和磁力计/数字罗盘）以实现新的用户交互形式（如复杂的手势和运动控制）以及其他环境传感器，这些传感器可以测量环境条件（如环境光传感器和接近传感器），以实现智能可穿戴应用。Android传感器框架提供了一个全面的接口来访问许多类型的传感器，这些传感器可以是基于硬件的（物理传感器）或基于软件的（从硬件传感器获取输入的虚拟传感器）。一般来说，有三大类传感器——运动传感器、位置传感器和环境传感器。
- en: 'In this section, we will demonstrate how to utilize the Android Sensor Framework
    to communicate with the sensors available on your device, register sensor event
    listeners to monitor changes in the sensors, and acquire raw sensor data for display
    on your mobile device. To create this demo, we will implement the Java code and
    native code using the same framework design introduced in the previous chapter.
    The following block diagram illustrates the core functions and the relationship
    among the classes that will be implemented in this demo:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何利用Android传感器框架与设备上的传感器进行通信，注册传感器事件监听器以监控传感器变化，并获取原始传感器数据以在您的移动设备上显示。为了创建此演示，我们将使用上一章中介绍的相同框架设计实现Java代码和本地代码。以下框图说明了演示中的核心功能和将要实现的类之间的关系：
- en: '![Visualizing real-time data from built-in Inertial Measurement Units (IMUs)](img/9727OS_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![可视化内置惯性测量单元（IMU）的实时数据](img/9727OS_08_01.jpg)'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This demo requires an Android device with OpenGL ES 3.0 support as well as
    physical sensor hardware support. Unfortunately, at the moment these functions
    cannot be simulated with an emulator shipped with the Android SDK. Specifically,
    an Android mobile device with the following set of sensors, which are now commonly
    available, would be required to run this demo: an accelerometer, gyroscope, and
    magnetometer (digital compass).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示需要一个支持OpenGL ES 3.0的Android设备和物理传感器硬件支持。不幸的是，目前这些函数无法使用Android SDK提供的模拟器进行模拟。具体来说，需要一个具有以下传感器集的Android移动设备来运行此演示：加速度计、陀螺仪和磁力计（数字指南针）。
- en: In addition, we assume that the Android SDK and Android NDK are configured as
    discussed in [Chapter 7](ch07.html "Chapter 7. An Introduction to Real-time Graphics
    Rendering on a Mobile Platform using OpenGL ES 3.0"), *An I* *ntroduction to Real-time
    Graphics Rendering on a Mobile Platform using OpenGL ES 3.0*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们假设Android SDK和Android NDK已按照[第7章](ch07.html "第7章。在移动平台上使用OpenGL ES 3.0进行实时图形渲染的介绍")中讨论的配置进行配置，*《在移动平台上使用OpenGL
    ES 3.0进行实时图形渲染的介绍》*。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, we will create the core Java source files similar to the previous chapter.
    Since the majority of the code is similar, we will only discuss the new and significant
    elements that are introduced in the current code. The rest of the code is abbreviated
    with the "…" notation. Please download the complete source code from the official
    Packt Publishing website.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建与上一章类似的Java核心源文件。由于大部分代码是相似的，我们只讨论当前代码中引入的新和重要元素。其余代码使用“…”符号省略。请从官方Packt
    Publishing网站下载完整的源代码。
- en: 'In the `GL3JNIActivity.java` file, we first integrate Android Sensor Manager,
    which allows us to read and parse sensor data. The following steps are required
    to complete the integration:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GL3JNIActivity.java`文件中，我们首先集成Android传感器管理器，这使得我们可以读取和解析传感器数据。以下步骤是完成集成的必要步骤：
- en: 'Import the classes for the Android Sensor Manager:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Android传感器管理器的类：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the `SensorEventListener` interface to interact with the sensors:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`SensorEventListener`接口以与传感器交互：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `SensorManager` and the `Sensor` variables to handle the data from
    the accelerometer, gyroscope, and magnetometer:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`SensorManager`和`Sensor`变量以处理加速度计、陀螺仪和磁力计的数据：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize the `SensorManager` as well as all other sensor services:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`SensorManager`以及所有其他传感器服务：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Register the callback functions and start listening to these events:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册回调函数并开始监听这些事件：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Handle the `sensor` events. The `onSensorChanged` and `onAccuracyChanged` functions
    capture any changes detected and the `SensorEvent` variable holds all the information
    about the sensor type, time-stamp, accuracy, and so on:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`sensor`事件。`onSensorChanged`和`onAccuracyChanged`函数捕获检测到的任何变化，而`SensorEvent`变量包含有关传感器类型、时间戳、精度等信息：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next implement the `GL3JNIView` class, which handles OpenGL rendering, in the
    `GL3JNIView.java` source file inside the `src/com/android/gl3jni/` directory.
    Since this implementation is identical to content in the [Chapter 7](ch07.html
    "Chapter 7. An Introduction to Real-time Graphics Rendering on a Mobile Platform
    using OpenGL ES 3.0"), *An Introduction to Real-time Graphics Rendering on a Mobile
    Platform using OpenGL ES 3.0*, we will not discuss it again here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `src/com/android/gl3jni/` 目录中的 `GL3JNIView.java` 源文件中实现 `GL3JNIView` 类，该类处理OpenGL渲染。由于此实现与前一章内容相同，即
    [第7章](ch07.html "第7章. 在移动平台上使用OpenGL ES 3.0进行实时图形渲染的介绍")，*在移动平台上使用OpenGL ES 3.0进行实时图形渲染的介绍*，我们在此不再讨论：
- en: 'Finally, integrate all the new features in the `GL3JNILib` class, which handles
    native library loading and calling, in the `GL3JNILib.java` file inside the `src/com/android/gl3jni`
    directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `GL3JNILib` 类中所有新功能集成到处理原生库加载和调用的 `GL3JNILib.java` 文件中，该文件位于 `src/com/android/gl3jni`
    目录内：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, on the JNI/C++ side, create a class called `Sensor` for managing the data
    buffer for each sensor, including the accelerometer, gyroscope, and magnetometer
    (digital compass). First, create a header file for the `Sensor` class called `Sensor.h`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JNI/C++端，创建一个名为 `Sensor` 的类来管理每个传感器的数据缓冲区，包括加速度计、陀螺仪和磁力计（数字罗盘）。首先，为 `Sensor`
    类创建一个名为 `Sensor.h` 的头文件：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, implement the `Sensor` class in the `Sensor.cpp` file with the following
    steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Sensor.cpp` 文件中实现 `Sensor` 类，步骤如下：
- en: 'Implement the constructor and destructor for the `Sensor` class. Set the default
    size of the buffer to `256`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Sensor` 类的构造函数和析构函数。将缓冲区的默认大小设置为 `256`：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the initialization function, which sets all default parameters, and allocate
    and deallocate memory at runtime:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加初始化函数，设置所有默认参数，并在运行时分配和释放内存：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `createBuffers` function for memory allocation:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现内存分配的 `createBuffers` 函数：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `free_all` function for deallocating memory:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `free_all` 函数以释放内存：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create routines for appending data to the data buffer of each sensor:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将数据追加到每个传感器数据缓冲区的例程：
- en: '[PRE12]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create routines for returning the pointer to the memory buffer of each sensor:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建返回每个传感器内存缓冲区指针的例程：
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement methods for displaying/plotting the data stream properly from each
    sensor (for example, determining the maximum value of the data stream from each
    sensor to scale the data properly):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现正确显示/绘制每个传感器数据流的函数（例如，确定每个传感器数据流的最大值以正确缩放数据）：
- en: '[PRE14]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we describe the implementation of the OpenGL ES 3.0 native code to
    complete the demo application (`main_sensor.cpp`). The code is built upon the
    structure introduced in the previous chapter, so only new changes and modifications
    will be described in the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述了OpenGL ES 3.0原生代码的实现，以完成演示应用程序（`main_sensor.cpp`）。该代码基于前一章中介绍的结构构建，因此以下步骤中仅描述新的更改和修改：
- en: In the project directory, create a file named `main_sensor.cpp` and store it
    inside the `jni` directory.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中创建一个名为 `main_sensor.cpp` 的文件，并将其存储在 `jni` 目录内。
- en: 'Include all necessary header files, including `Sensor.h` at the beginning of
    the file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头包含所有必要的头文件，包括 `Sensor.h`：
- en: '[PRE15]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Declare shader program handlers and variables for handling sensor data:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明着色器程序处理程序和变量，用于处理传感器数据：
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the shader program code for both the vertex shader and fragment shader
    to render points and lines:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于渲染点和线的顶点着色器和片段着色器的着色器程序代码：
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set up all attribute variables in the `setupGraphics` function. These variables
    will be used to communicate with the shader programs:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setupGraphics` 函数中设置所有属性变量。这些变量将用于与着色器程序通信：
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a function for drawing 2D plots to display real-time sensor data:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于绘制2D图表的函数，以显示实时传感器数据：
- en: '[PRE19]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set up the rendering function which draws the various 2D time series with the
    data stream from the sensors:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置渲染函数，用于绘制来自传感器的数据流的各种2D时间序列：
- en: '[PRE20]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the JNI prototypes that connect to the Java side. These calls are the
    interfaces for communicating between the Java code and C/C++ native code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义连接到Java端的JNI原型。这些调用是Java代码和C/C++原生代码之间通信的接口：
- en: '[PRE21]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we need to compile and install the Android application with the same
    instructions as outlined in the previous chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要按照前一章中概述的相同说明编译和安装Android应用程序：
- en: 'The following screenshots show the real-time sensor data stream from the accelerometer,
    gyroscope, and digital compass (top panel, middle panel, and bottom panel, respectively)
    on our Android device. Red, green, and blue are used to differentiate the channels
    from each sensor data stream. For example, the red plot in the top panel represents
    the acceleration value of the device along the *x* axis (the blue plot for the
    *y* axis and the green plot for the *z* axis). In the first example, we rotated
    the phone freely at various orientations and the plots show the corresponding
    changes in the sensor values. The visualizer also provides an auto-scale function,
    which automatically computes the maximum values to rescale the plots accordingly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的Android设备上加速度计、陀螺仪和数字罗盘（分别位于顶部面板、中间面板和底部面板）的实时传感器数据流。红色、绿色和蓝色用于区分来自每个传感器数据流的通道。例如，顶部面板中的红色曲线表示设备沿*x*轴的加速度值（*y*轴的蓝色曲线和*z*轴的绿色曲线）。在第一个例子中，我们自由旋转手机，以各种方向进行旋转，曲线显示了传感器值的相应变化。可视化器还提供了一个自动缩放功能，该功能自动计算最大值以相应地缩放曲线：
- en: '![How to do it…](img/9727OS_08_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_02.jpg)'
- en: Next, we positioned the phone on a stationary surface and we plotted the values
    of the sensors. Instead of observing constant values over time, the time series
    plots show that there are some very small changes (jittering) in the sensor values
    due to sensor noise. Depending on the application, you will often need to apply
    filtering techniques to ensure that the user experience is jitter-free. One simple
    solution is to apply a low-pass filter to smooth out any high-frequency noise.
    More details on the implementation of such filters can be found at [http://developer.android.com/guide/topics/sensors/sensors_motion.html](http://developer.android.com/guide/topics/sensors/sensors_motion.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将手机放置在静止的表面上，并绘制了传感器的值。与观察随时间保持恒定的值不同，时间序列图显示由于传感器噪声，传感器值存在一些非常小的变化（抖动）。根据应用的不同，你通常会需要应用滤波技术以确保用户体验无抖动。一个简单的解决方案是应用低通滤波器以平滑掉任何高频噪声。关于此类滤波器实现的更多详细信息，请参阅[http://developer.android.com/guide/topics/sensors/sensors_motion.html](http://developer.android.com/guide/topics/sensors/sensors_motion.html)。
- en: '![How to do it…](img/9727OS_08_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_03.jpg)'
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Android Sensor Framework allows users to access the raw data from various
    types of sensors on a mobile device. This framework is part of the `android.hardware`
    package and the sensor package includes a set of classes and interfaces for sensor-specific
    features.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Android传感器框架允许用户访问移动设备上各种类型传感器的原始数据。此框架是`android.hardware`包的一部分，传感器包包括一组用于特定传感器功能的类和接口。
- en: The `SensorManager` class provides an interface and methods for accessing and
    listing the available sensors from the device. Some common hardware sensors include
    the accelerometer, gyroscope, proximity sensor, and the magnetometer (digital
    compass). These sensors are represented by constant variables (such as `TYPE_ACCELEROMETER`
    for the accelerometer, `TYPE_MAGNETIC_FIELD` for the magnetometer, and `TYPE_GYROSCOPE`
    for the gyroscope) and the `getDefaultSensor` function returns an instance of
    the `Sensor` object based on the type requested.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SensorManager`类提供了一种接口和方法，用于访问和列出设备上可用的传感器。一些常见的硬件传感器包括加速度计、陀螺仪、接近传感器和磁力计（数字罗盘）。这些传感器由常量变量（如加速度计的`TYPE_ACCELEROMETER`，磁力计的`TYPE_MAGNETIC_FIELD`，陀螺仪的`TYPE_GYROSCOPE`）表示，而`getDefaultSensor`函数根据请求的类型返回`Sensor`对象的一个实例。'
- en: To enable data streaming, we must register the sensor to the `SensorEventListener`
    class such that the raw data is reported back to the application upon updates.
    The `registerListener` function then creates the callback to handle updates to
    the sensor value or sensor accuracy. The `SensorEvent` variable stores the name
    of the sensor, the timestamp and accuracy of the event, as well as the raw data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用数据流，我们必须将传感器注册到`SensorEventListener`类，以便在更新时将原始数据报告回应用程序。然后`registerListener`函数创建回调以处理传感器值或传感器精度的更新。`SensorEvent`变量存储了传感器名称、事件的戳记和精度，以及原始数据。
- en: The raw data stream from each sensor is reported back with the `onSensorChange`
    function. Since sensor data may be acquired and streamed at a high rate, it is
    important that we do not block callback function calls or perform any computationally
    intensive processes within the `onSensorChange` function. In addition, it is a
    good practice to reduce the data rate of the sensor based on your application
    requirements. In our case, we set the sensor to run at the optimal rate for gaming
    purposes by passing the constant preset variable `SENSOR_DELAY_GAME` to the `registerListener`
    function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传感器的原始数据流通过`onSensorChange`函数返回。由于传感器数据可能以高频率获取和流式传输，因此我们确保不在`onSensorChange`函数中阻塞回调函数调用或执行任何计算密集型过程非常重要。此外，根据您的应用需求降低传感器数据速率是一种良好的实践。在我们的案例中，我们通过将常量预设变量`SENSOR_DELAY_GAME`传递给`registerListener`函数，将传感器设置为以游戏目的的最优速率运行。
- en: The `GL3JNILib` class then handles all the data passing to the native code using
    the new functions. For simplicity, we have created separate functions for each
    sensor type, which makes it easier for the reader to understand the data flow
    for each sensor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`GL3JNILib`类使用新函数处理所有数据传递到本地代码。为了简化，我们为每种传感器类型创建了单独的函数，这使得读者更容易理解每种传感器的数据流。
- en: At this point, we have created the interfaces that redirect data to the native
    side. However, to plot the sensor data on the screen, we need to create a simple
    buffering mechanism that stores the data points over some period of time. We have
    created a custom `Sensor` class in C++ to handle data creation, updates, and processing
    needed to manage these interactions. The implementation of the class is straightforward,
    and we preset the buffer size to store 256 data points by default.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经创建了将数据重定向到本地端的接口。然而，为了在屏幕上绘制传感器数据，我们需要创建一个简单的缓冲机制，以便在一段时间内存储数据点。我们使用C++创建了一个自定义的`Sensor`类来处理数据创建、更新和处理，以管理这些交互。类的实现非常直接，我们默认预设缓冲区大小为存储256个数据点。
- en: On the OpenGL ES side, we create the 2D plot by appending the data stream to
    our vertex buffer. The scale of the data stream is adjusted dynamically based
    on the current values to ensure that the values fit on the screen. Notice that
    we have also performed all data scaling and translation on the vertex shader to
    reduce any overhead in the CPU computation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES方面，我们通过将数据流附加到我们的顶点缓冲区来创建2D图表。数据流的刻度根据当前值动态调整，以确保值适合屏幕。请注意，我们还在顶点着色器中执行了所有数据缩放和转换，以减少CPU计算中的任何开销。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on the Android Sensor Framework, consult the documentation
    online at [http://developer.android.com/guide/topics/sensors/sensors_overview.html](http://developer.android.com/guide/topics/sensors/sensors_overview.html).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Android传感器框架的信息，请查阅在线文档[http://developer.android.com/guide/topics/sensors/sensors_overview.html](http://developer.android.com/guide/topics/sensors/sensors_overview.html)。
- en: Part I – handling multi-touch interface and motion sensor inputs
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分 – 处理多触控界面和运动传感器输入
- en: 'Now that we have introduced the basics of handling sensor inputs, we will develop
    an interactive, sensor-based data visualization tool. In addition to using motion
    sensors, we will introduce a multi-touch interface for user interaction. The following
    is a preview of the final application, integrating all the elements in this chapter:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了处理传感器输入的基础知识，我们将开发一个基于传感器的交互式数据可视化工具。除了使用运动传感器外，我们还将引入多触控界面以供用户交互。以下是对最终应用的预览，整合了本章的所有元素：
- en: '![Part I – handling multi-touch interface and motion sensor inputs](img/9727OS_08_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![第一部分 – 处理多触控界面和运动传感器输入](img/9727OS_08_06.jpg)'
- en: 'In this section, we will focus solely on the Java side of the implementation
    and the native code will be described in part II. The following class diagram
    illustrates the various components of the Java code (part I) that provide the
    basic interface for user interaction on the mobile device and demonstrates how
    the native code (part II) completes the entire implementation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于实现中的Java部分，而本地代码将在第二部分中描述。以下类图说明了Java代码（第一部分）的各个组件，这些组件为移动设备上的用户交互提供了基本接口，并展示了本地代码（第二部分）如何完成整个实现：
- en: '![Part I – handling multi-touch interface and motion sensor inputs](img/9727OS_08_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![第一部分 – 处理多触控界面和运动传感器输入](img/9727OS_08_04.jpg)'
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: First, we will create the core Java source files that are essential to an Android
    application. These files serve as a wrapper for our OpenGL ES 3.0 native code.
    The code structure is based on the `gl3jni` package described in the previous
    section. Here we will highlight the major changes made to the code and discuss
    the interaction of these new components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建对 Android 应用程序至关重要的核心 Java 源文件。这些文件作为我们 OpenGL ES 3.0 原生代码的包装器。代码结构基于前一小节中描述的
    `gl3jni` 包。在这里，我们将突出显示对代码所做的主要更改，并讨论这些新组件的交互：
- en: 'In the project directory, modify the `GL3JNIActivity` class in the `GL3JNIActivity.java`
    file within the `src/com/android/gl3jni` directory. Instead of using the raw sensor
    data, we will utilize the Android sensor fusion algorithm, which intelligently
    combines all sensor data to recover the orientation of the device as a rotation
    vector. The steps to enable this feature are described as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中，修改 `src/com/android/gl3jni` 目录下的 `GL3JNIActivity.java` 文件中的 `GL3JNIActivity`
    类。我们不再使用原始的传感器数据，而是将利用 Android 传感器融合算法，该算法智能地结合所有传感器数据以恢复设备的方向作为旋转向量。启用此功能的步骤如下所述：
- en: 'In the `GL3JNIActivity` class, add the new variables for handling the rotation
    matrix and vector:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GL3JNIActivity` 类中，添加用于处理旋转矩阵和向量的新变量：
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Initialize the `Sensor` variable with the `TYPE_ROTATION_VECTOR` type, which
    returns the device orientation as a rotation vector/matrix:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `TYPE_ROTATION_VECTOR` 类型初始化 `Sensor` 变量，该类型返回设备方向作为旋转向量/矩阵：
- en: '[PRE23]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Register the Sensor Manager object and set the sensor response rate to `SENSOR_DELAY_GAME`,
    which is used for gaming or real-time applications:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册传感器管理器对象并将传感器响应速率设置为 `SENSOR_DELAY_GAME`，该速率用于游戏或实时应用程序：
- en: '[PRE24]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Retrieve the device orientation and save the event data as a rotation matrix.
    Then convert the rotation matrix into Euler angles that are passed to the native
    code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取设备方向并将事件数据保存为旋转矩阵。然后将旋转矩阵转换为欧拉角，传递给原生代码：
- en: '[PRE25]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, modify the `GL3JNIView` class, which handles OpenGL rendering, in the
    `GL3JNIView.java` file inside the `src/com/android/gl3jni/` directory. To make
    the application interactive, we also integrate the touch-based gesture detector
    that handles multi-touch events. Particularly, we add the `ScaleGestureDetector`
    class that enables the pinch gesture for scaling the 3D plot. To implement this
    feature, we make the following modifications to the `GL3JNIView.java` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 `GL3JNIView` 类，该类在 `src/com/android/gl3jni/` 目录下的 `GL3JNIView.java` 文件中处理
    OpenGL 渲染。为了使应用程序交互式，我们还集成了基于触摸的手势检测器，该检测器处理多触点事件。特别是，我们添加了 `ScaleGestureDetector`
    类，它允许缩放手势来缩放 3D 图形。为了实现此功能，我们对 `GL3JNIView.java` 文件进行了以下修改：
- en: 'Import the `MotionEvent` and `ScaleGestureDetector` classes:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `MotionEvent` 和 `ScaleGestureDetector` 类：
- en: '[PRE26]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a `ScaleGestureDetector` variable and initialize with `ScaleListener`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ScaleGestureDetector` 变量并使用 `ScaleListener` 初始化：
- en: '[PRE27]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Pass the motion event to the gesture detector when a touch screen event occurs
    (`onTouchEvent`):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当触摸屏事件发生时 (`onTouchEvent`)，将运动事件传递给手势检测器：
- en: '[PRE28]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement `SimpleOnScaleGestureListener` and handle the callback (`onScale`)
    on pinch gesture events:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `SimpleOnScaleGestureListener` 并处理捏合手势事件中的回调 (`onScale`)：
- en: '[PRE29]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, in the `GL3JNILib` class, we implement the functions to handle native
    library loading and calling in the `GL3JNILib.java` file inside the `src/com/android/gl3jni`
    directory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `src/com/android/gl3jni` 目录下的 `GL3JNILib.java` 文件中，我们在 `GL3JNILib` 类中实现处理原生库加载和调用的函数：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Similar to the previous demo, we will use the Android Sensor Framework to handle
    the sensor inputs. Notice that, in this demo, we specify `TYPE_ROTATION_VECTOR`
    for the sensor type inside the `getDefaultSensor` function in `GL3JNIActivity.java`,
    which allows us to detect the device orientation. This is a software type sensor
    in which all IMUs data (from the accelerometer, gyroscope, and magnetometer) are
    fused together to create the rotation vector. The device orientation data is first
    stored in the rotation matrix `mRotationMatrix` using the `getRotationMatrixFromVector`
    function and the azimuth, pitch, and roll angles (rotation around the *x*, *y*,
    and *z* axes, respectively) are retrieved using the `getOrientation` function.
    Finally, we pass the three orientation angles to the native code portion of the
    implementation using the `GL3JNILib.addRotData` call. This allows us to control
    3D graphics based on the device's orientation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的演示类似，我们将使用Android传感器框架来处理传感器输入。请注意，在这个演示中，我们在`GL3JNIActivity.java`文件中的`getDefaultSensor`函数内部指定了传感器类型为`TYPE_ROTATION_VECTOR`，这允许我们检测设备方向。这是一个软件类型传感器，其中所有IMU数据（从加速度计、陀螺仪和磁力计）都被融合在一起以创建旋转向量。设备方向数据首先使用`getRotationMatrixFromVector`函数存储在旋转矩阵`mRotationMatrix`中，然后使用`getOrientation`函数检索方位角、俯仰角和翻滚角（分别绕*x*、*y*和*z*轴旋转）。最后，我们通过`GL3JNILib.addRotData`调用将三个方向角传递到实现的原生代码部分。这允许我们根据设备的方向来控制3D图形。
- en: Next we will explain how the multi-touch interface works. Inside the `GL3JNIView`
    class, you will notice that we have created an instance (`mScaleDetector`) of
    a new class called `ScaleGestureDetector`. The `ScaleGestureDetector` class detects
    scaling transformation gestures (pinching with two fingers) using the `MotionEvent`
    class from the multi-touch screen. The algorithm returns the scale factor that
    can be redirected to the OpenGL pipeline to update the graphics in real time.
    The `SimpleOnScaleGestureListener` class provides a callback function for the
    `onScale` event and we pass the scale factor (`mScaleFactor`) to the native code
    using the `GL3JNILib.setScale` call.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释多点触控界面是如何工作的。在`GL3JNIView`类中，您会注意到我们创建了一个名为`ScaleGestureDetector`的新类的实例（`mScaleDetector`）。`ScaleGestureDetector`类使用多点触控屏幕的`MotionEvent`类检测缩放变换手势（用两个手指捏合）。该算法返回可以重定向到OpenGL管道的缩放因子，以实时更新图形。`SimpleOnScaleGestureListener`类提供了一个`onScale`事件的回调函数，我们通过`GL3JNILib.setScale`调用将缩放因子（`mScaleFactor`）传递到原生代码。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For further information on the Android multi-touch interface, see the detailed
    documentation at [http://developer.android.com/training/gestures/index.html](http://developer.android.com/training/gestures/index.html).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Android多点触控界面的更多信息，请参阅[http://developer.android.com/training/gestures/index.html](http://developer.android.com/training/gestures/index.html)的详细文档。
- en: Part II – interactive, real-time data visualization with mobile GPUs
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 使用移动GPU进行交互式、实时数据可视化
- en: Now we will complete our demo with the native code implementation to create
    our highly interactive Android-based data visualization application with OpenGL
    ES 3.0 as well as the Android sensor and gesture control interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用原生代码实现来完成我们的演示，创建一个基于Android的数据可视化应用程序，该程序使用OpenGL ES 3.0以及Android传感器和手势控制界面。
- en: 'The following class diagram highlights what remains to be implemented on the
    C/C++ side:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图突出了在C/C++方面还需要实现的内容：
- en: '![Part II – interactive, real-time data visualization with mobile GPUs](img/9727OS_08_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![第二部分 – 使用移动GPU进行交互式、实时数据可视化](img/9727OS_08_05.jpg)'
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we describe the implementation of the OpenGL ES 3.0 native code to complete
    the demo application. We will preserve the same code structure from [Chapter 7](ch07.html
    "Chapter 7. An Introduction to Real-time Graphics Rendering on a Mobile Platform
    using OpenGL ES 3.0"), *An Introduction to Real-time Graphics Rendering on a Mobile
    Platform using OpenGL ES 3.0*. In the following steps, only the new codes are
    highlighted, and all changes are implemented in the `main.cpp` file inside the
    `jni` folder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了完成演示应用程序的OpenGL ES 3.0原生代码的实现。我们将保留与[第7章](ch07.html "第7章。在移动平台上使用OpenGL
    ES 3.0进行实时图形渲染的介绍")相同的代码结构，*在移动平台上使用OpenGL ES 3.0进行实时图形渲染的介绍*。在以下步骤中，仅突出显示新代码，所有更改都在`jni`文件夹内的`main.cpp`文件中实现：
- en: 'Include all necessary header files, including `JNI`, OpenGL ES 3.0, and the
    `GLM` library:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含所有必要的头文件，包括`JNI`、OpenGL ES 3.0和`GLM`库：
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare the shader program variables:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明着色程序变量：
- en: '[PRE32]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Declare variables for setting up the camera as well as other relevant variables
    such as the rotation angles and grid:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明用于设置相机以及其他相关变量（如旋转角度和网格）的变量：
- en: '[PRE33]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the shader program code for both the vertex shader and fragment shader.
    Note the similarity in the heat map generation code between this implementation
    in OpenGL ES 3.0 and an earlier implementation in standard OpenGL (see chapters
    4-6):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义顶点着色器和片段着色器的着色器程序代码。注意在OpenGL ES 3.0的此实现和标准OpenGL早期实现（见第4-6章）之间热图生成代码的相似性：
- en: '[PRE34]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Initialize the grid pattern for data visualization:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据可视化的网格模式：
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Set the rotation angles that are used to control the model viewing angles.
    These angles (device orientation) are passed from the Java side:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置用于控制模型观察角度的旋转角度。这些角度（设备方向）从Java端传递过来：
- en: '[PRE36]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compute the projection and view matrices based on camera parameters:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据相机参数计算投影和视图矩阵：
- en: '[PRE37]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a function for handling the initialization of all attribute variables
    for the shader program and other one-time setups, such as the memory allocation
    and initialization for the grid:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来处理着色程序和其他一次性设置（如网格的内存分配和初始化）中所有属性变量的初始化：
- en: '[PRE38]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set up the rendering function for the 3D plot of the Gaussian function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置高斯函数3D绘图的渲染函数：
- en: '[PRE39]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the JNI prototypes that connect to the Java side. These calls are the
    interfaces for communicating between the Java code and C/C++ native code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义连接到Java端的JNI原型。这些调用是Java代码和C/C++本地代码之间通信的接口：
- en: '[PRE40]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set up the internal function calls with the helper functions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用辅助函数设置内部函数调用：
- en: '[PRE41]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, in terms of the compilation steps, modify the build files `Android.mk`
    and `Application.mk` accordingly as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在编译步骤方面，根据以下内容相应地修改`Android.mk`和`Application.mk`构建文件：
- en: 'Add in the GLM path to the `LOCAL_C_INCLUDES` variable in `Android.mk`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Android.mk`中将GLM路径添加到`LOCAL_C_INCLUDES`变量中：
- en: '[PRE42]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add in `gnustl_static` to the `APP_STL` variable to use GNU STL as a static
    library. This allows for all runtime supports from C++, which is needed by the
    GLM library. See more at [http://www.kandroid.org/ndk/docs/CPLUSPLUS-SUPPORT.html](http://www.kandroid.org/ndk/docs/CPLUSPLUS-SUPPORT.html):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gnustl_static`添加到`APP_STL`变量中，以使用GNU STL作为静态库。这允许C++的所有运行时支持，这是GLM库所需的。更多信息请参阅[http://www.kandroid.org/ndk/docs/CPLUSPLUS-SUPPORT.html](http://www.kandroid.org/ndk/docs/CPLUSPLUS-SUPPORT.html)：
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the compilation script (this is similar to what we did in the previous
    chapter). Please note that the `ANDROID_SDK_PATH` and `ANDROID_NDK_PATH` variables
    should be changed to the correct directories based on the local environment setup:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行编译脚本（这与我们在上一章中做的是类似的）。请注意，`ANDROID_SDK_PATH`和`ANDROID_NDK_PATH`变量应根据本地环境设置更改为正确的目录：
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Install the **Android Application Package** (**APK**) on the Android phone,
    using the following commands in the terminal:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android手机上安装**Android应用包**（**APK**），使用以下终端命令：
- en: '[PRE45]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The final results of our implementation are shown next. By changing the orientation
    of the phone, the Gaussian function can be viewed from different angles. This
    provides a very intuitive way to visualize 3D datasets. Here is a photo showing
    the Gaussian function when the device is oriented parallel to the ground:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的最终结果如下。通过改变手机的方向，可以从不同的角度查看高斯函数。这提供了一种非常直观的方式来可视化3D数据集。以下是当设备方向平行于地面时高斯函数的照片：
- en: '![How to do it…](img/9727OS_08_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_07.jpg)'
- en: 'Finally, we test our multi-touch gesture interface by pinching on the touch
    screen with 2 fingers. This provides an intuitive way to zoom into and out of
    the 3D data. Here is the first photo that shows the close-up view after zooming
    into the data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在触摸屏上用两根手指捏合来测试我们的多指手势界面。这提供了一种直观的方式来缩放3D数据。以下是放大数据后的近距离视图的第一张照片：
- en: '![How to do it…](img/9727OS_08_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_08.jpg)'
- en: 'Here is another photo that shows what the data looks like when you zoom out
    by pinching your fingers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一张照片，展示了通过捏合手指缩小视图时数据的外观：
- en: '![How to do it…](img/9727OS_08_09.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_09.jpg)'
- en: 'Finally, here is a screenshot of the demo application that shows a Gaussian
    distribution in 3D rendered in real-time with our OpenGL ES 3.0 shader program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一张演示应用程序的截图，展示了使用我们的OpenGL ES 3.0着色器程序实时渲染的3D高斯分布：
- en: '![How to do it…](img/9727OS_08_10.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/9727OS_08_10.jpg)'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the second part of the demo, we demonstrated the use of a shader program
    written in OpenGL ES 3.0 to perform all the simulation and heat map-based 3D rendering
    steps to visualize a Gaussian distribution on a mobile GPU. Importantly, the shader
    code in OpenGL ES 3.0 is very similar to the code written in standard OpenGL 3.2
    and above (see chapters 4 to 6). However, we recommend that you consult the specification
    to ensure that a particular feature of interest co-exists in both versions. More
    details on the OpenGL ES 3.0 specifications can be found at [https://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.0.pdf](https://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.0.pdf).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示的第二部分，我们展示了使用 OpenGL ES 3.0 编写的着色程序来执行所有模拟和基于热图的三维渲染步骤，以在移动 GPU 上可视化高斯分布。重要的是，OpenGL
    ES 3.0 中的着色器代码与标准 OpenGL 3.2 及以上版本中编写的代码非常相似（参见第 4 到 6 章）。然而，我们建议您查阅规范以确保感兴趣的特性在两个版本中都存在。有关
    OpenGL ES 3.0 规范的更多详细信息，请参阅[https://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.0.pdf](https://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.0.pdf)。
- en: The hardware-accelerated portion of the code is programmed within the vertex
    shader program and stored inside the `g_vshader_code` variable; then the fragment
    shade program passes the processed color information onto the screen's color buffer.
    The vertex program handles the computation related to the simulation (in our case,
    we have a Gaussian function with a time-varying sigma value as demonstrated in
    [Chapter 3](ch03.html "Chapter 3. Interactive 3D Data Visualization"), *Interactive
    3D Data Visualization*) in the graphics hardware. We pass in the sigma value as
    a uniform variable and it is used to compute the surface height. In addition,
    we also compute the heat map color value within the shader program based on the
    height value. With this approach, we have significantly improved the speed of
    the graphic rendering step by completely eliminating the use of the CPU cycles
    on these numerous floating point operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的硬件加速部分在顶点着色程序中编程，并存储在 `g_vshader_code` 变量中；然后片段着色程序将处理后的颜色信息传递到屏幕的颜色缓冲区。顶点程序处理与模拟相关的计算（在我们的案例中，我们有一个具有时间变化的标准差值的高斯函数，如第
    3 章中所示[Chapter 3](ch03.html "Chapter 3. Interactive 3D Data Visualization")，*交互式三维数据可视化*），在图形硬件中进行。我们将标准差值作为统一变量传递，并用于计算表面高度。此外，我们还在着色程序中根据高度值计算热图颜色值。通过这种方法，我们通过完全消除这些大量浮点运算的
    CPU 循环使用，显著提高了图形渲染步骤的速度。
- en: In addition, we have included the GLM library used in previous chapters into
    the Android platform by adding the headers as well as the GLM path in the build
    script `Android.mk`. The GLM library handles the view and projection matrix computation
    and also allows us to migrate most of our previous work, such as setting up 3D
    rendering, to the Android platform.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将上一章中使用的 GLM 库集成到 Android 平台，通过在构建脚本 `Android.mk` 中添加头文件以及 GLM 路径来实现。GLM
    库负责处理视图和投影矩阵的计算，并允许我们将大部分之前的工作，例如设置 3D 渲染，迁移到 Android 平台。
- en: Finally, our Android-based application also utilizes the inputs from the multi-touch
    screen interface and the device orientation derived from the motion sensor data.
    These values are passed through the JNI directly to the shader program as uniform
    variables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的基于 Android 的应用程序还利用了来自多点触控屏幕界面的输入以及来自运动传感器数据的设备方向。这些值直接通过 JNI 作为统一变量传递到着色程序中。
