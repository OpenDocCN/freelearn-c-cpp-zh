<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 3.  Make It Rain! - Building a Particle System"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/><span class="koboSpan" id="kobo.1.1">Chapter 3.  Make It Rain! </span><span class="koboSpan" id="kobo.1.2">- Building a Particle System </span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having the right amount of interactivity in any given game is incredibly important. </span><span class="koboSpan" id="kobo.2.2">Whether it amuses the player by having their consequences start chain reactions that eventually impact their state, or it simply means that the controls and input management feel just right, one cannot deny that this is one of the few things that can either make or break a game. </span><span class="koboSpan" id="kobo.2.3">While the latter is quite important, it's not the smooth navigation of menus that draw most gamers in, which is why in this chapter we are going to be focusing on environmental interactions, as well as stylization through the means of particle systems.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we're going to be covering the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Benefits of the </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">Structure of Arrays</span></strong></span><span class="koboSpan" id="kobo.6.1"> storage pattern</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Architecture and implementation of a flexible particle system</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Creation of different types of generator and updater objects that allow a wide variety of effects to be created</span></li></ul></div><p><span class="koboSpan" id="kobo.9.1">There is quite a bit to learn, so let us not waste any time and dive right in!</span></p><div class="section" title="Use of copyrighted resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/><span class="koboSpan" id="kobo.10.1">Use of copyrighted resources</span></h1></div></div></div><p><span class="koboSpan" id="kobo.11.1">As always, let us begin by acknowledging all of the generous artists out there, who make all of this possible by providing assets under incredibly flexible licenses:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">misc png</span></em></span><span class="koboSpan" id="kobo.13.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">dbszabo1</span></em></span><span class="koboSpan" id="kobo.15.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">CC0</span></strong></span><span class="koboSpan" id="kobo.17.1"> license (public domain): </span><a class="ulink" href="http://dbszabo1.deviantart.com/art/misc-png-316228902"><span class="koboSpan" id="kobo.18.1">http://dbszabo1.deviantart.com/art/misc-png-316228902</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Jillcreation-overlay-cloud</span></em></span><span class="koboSpan" id="kobo.20.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.21.1">Juan Story</span></em></span><span class="koboSpan" id="kobo.22.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">CC0</span></strong></span><span class="koboSpan" id="kobo.24.1"> license (public domain): </span><a class="ulink" href="http://www.effecthub.com/item/5358"><span class="koboSpan" id="kobo.25.1">http://www.effecthub.com/item/5358</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.26.1">[LPC] Leaf Recolor</span></em></span><span class="koboSpan" id="kobo.27.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">William.Thompsonj</span></em></span><span class="koboSpan" id="kobo.29.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">CC-BY-SA 3.0</span></strong></span><span class="koboSpan" id="kobo.31.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">GPL 3.0</span></strong></span><span class="koboSpan" id="kobo.33.1"> licenses: </span><a class="ulink" href="http://opengameart.org/content/lpc-leaf-recolor"><span class="koboSpan" id="kobo.34.1">http://opengameart.org/content/lpc-leaf-recolor</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Particle system basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/><span class="koboSpan" id="kobo.1.1">Particle system basics</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There are quite a few things we first need to cover in order to get to the more meaty parts of implementing the particle system. </span><span class="koboSpan" id="kobo.2.2">Understanding certain concepts is key to making our system work as intended, starting with the way data is stored.</span></p><div class="section" title="Array of structs versus struct of arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/><span class="koboSpan" id="kobo.3.1">Array of structs versus struct of arrays</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">It may be tempting at first to simply stick all of the data a particle has into a single class, give it some custom methods for handling certain situations, and store all of these objects in some generic container, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.5.1"><img src="graphics/image_03_001.jpg" alt="Array of structs versus struct of arrays"/></span></div><p><span class="koboSpan" id="kobo.6.1">While it's certainly easier this way, it doesn't help with performance at all. </span><span class="koboSpan" id="kobo.6.2">Keep in mind that we're probably going to be dealing with thousands, if not tens of thousands of instances of particles, all of which need to be updated in a variety of different ways. </span><span class="koboSpan" id="kobo.6.3">A simple update loop that works with particles may end up making the cache look like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.7.1"><img src="graphics/image_03_002.jpg" alt="Array of structs versus struct of arrays"/></span></div><p><span class="koboSpan" id="kobo.8.1">This is terrible as far as performance is concerned, because if we only need to work with positions, that means all of the additional space in the cache that could be used to store positions of other particles now holds useless data that will not be used at all, at least not now. </span><span class="koboSpan" id="kobo.8.2">In turn, when it's time to update another particle and its position is requested, it will most likely not be found inside the cache, resulting in a cache miss and time wasted.</span></p><p><span class="koboSpan" id="kobo.9.1">A much better scenario would look like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.10.1"><img src="graphics/image_03_003.jpg" alt="Array of structs versus struct of arrays"/></span></div><p><span class="koboSpan" id="kobo.11.1">This is much better in terms of performance, as all of the data that exists in the cache is guaranteed to be used. </span><span class="koboSpan" id="kobo.11.2">How do we achieve such a result? </span><span class="koboSpan" id="kobo.11.3">By storing different particle properties in their own containers, where the memory is ensured to be contiguous, as shown here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">struct S{ 
  int m_x[50]; 
  int m_y[50]; 
  std::string m_name[50]; 
  ... 
</span><span class="koboSpan" id="kobo.12.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.13.1">Storage, however, isn't everything. </span><span class="koboSpan" id="kobo.13.2">We must also make sure that whenever we are working with structures such as this, only the relevant and necessary data is being used. </span><span class="koboSpan" id="kobo.13.3">That part, however, will be addressed later down the line.</span></p></div><div class="section" title="Storing particles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/><span class="koboSpan" id="kobo.14.1">Storing particles</span></h2></div></div></div><p><span class="koboSpan" id="kobo.15.1">With the key concept out of the way, let us take a look at how particles can be stored using the </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">SoA</span></strong></span><span class="koboSpan" id="kobo.17.1"> pattern:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">class ParticleContainer { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.18.2">const static size_t Max_Particles = 3000; 
  sf::Vector3f m_position[Max_Particles]; 
  sf::Vector3f m_velocity[Max_Particles]; 
  sf::Vector3f m_acceleration[Max_Particles]; 
  sf::Vector2f m_startSize[Max_Particles]; 
  sf::Vector2f m_currentSize[Max_Particles]; 
  sf::Vector2f m_finalSize[Max_Particles]; 
  sf::Color m_startColor[Max_Particles]; 
  sf::Color m_currentColor[Max_Particles]; 
  sf::Color m_finalColor[Max_Particles]; 
  std::string m_texture[Max_Particles]; 
  sf::RectangleShape m_drawable[Max_Particles]; 
  float m_startRotation[Max_Particles]; 
  float m_currentRotation[Max_Particles]; 
  float m_finalRotation[Max_Particles]; 
  float m_lifespan[Max_Particles]; 
  float m_maxLifespan[Max_Particles]; 
  bool m_gravity[Max_Particles]; 
  bool m_addBlend[Max_Particles]; 
  bool m_alive[Max_Particles]; 
 
  size_t m_countAlive; 
  TextureManager* m_textureManager; 
protected: 
  ... 
</span><span class="koboSpan" id="kobo.18.3">}; 
</span></pre><p><span class="koboSpan" id="kobo.19.1">There are a couple of ways particle properties can be stored and accounted for. </span><span class="koboSpan" id="kobo.19.2">Here, we're using C-style arrays along with a static constant that denotes their sizes. </span><span class="koboSpan" id="kobo.19.3">All of these properties, as well as their purposes, will be covered in later segments of the chapter.</span></p><p><span class="koboSpan" id="kobo.20.1">A few extra things that are beneficial to keep track of here are the count of particles that are still alive and a pointer to the texture manager, since some of these suckers may be using textures that need to be grabbed and released. </span><span class="koboSpan" id="kobo.20.2">They are, of course, set up properly inside the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.21.1">ParticleContainer(TextureManager* l_textureManager) 
  : m_textureManager(l_textureManager), m_countAlive(0) 
{ Reset(); } 
 
~ParticleContainer(){ 
  for (size_t i = 0; i &lt; Max_Particles; ++i){ 
    if (m_texture[i].empty()) { continue; } 
    m_textureManager-&gt;ReleaseResource(m_texture[i]); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.22.1">The destructor of this container class has a fairly simple job. </span><span class="koboSpan" id="kobo.22.2">All it needs to do, in order to not leave any loose ends, is loop through every particle stored and check if it is using a texture, which is just a string identifier. </span><span class="koboSpan" id="kobo.22.3">If it is, the texture is released.</span></p><p><span class="koboSpan" id="kobo.23.1">Another fairly important task that was left up to the constructor is resetting all of the allocated memory for the particles. </span><span class="koboSpan" id="kobo.23.2">This is left to the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Reset()</span></code><span class="koboSpan" id="kobo.25.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">void Reset(){ 
  for (size_t i = 0; i &lt; Max_Particles; ++i) { ResetParticle(i); } 
  m_countAlive = 0; 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">The </span><code class="literal"><span class="koboSpan" id="kobo.28.1">ResetParticle</span></code><span class="koboSpan" id="kobo.29.1"> private method is invoked for each single particle in the list. </span><span class="koboSpan" id="kobo.29.2">It is responsible for actually zeroing all of the data out to make sure the next particle that gets the same identifier will not possess certain properties carried over from the previous particle that owned it.</span></p><p><span class="koboSpan" id="kobo.30.1">In order to actually manage the SoA structure efficiently, we're going to be using these two key methods for enabling and disabling a particular ID:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">void Enable(size_t l_id){ 
  if (m_countAlive &gt;= Max_Particles) { return; } 
  m_alive[l_id] = true; 
  Swap(l_id, m_countAlive); 
  ++m_countAlive; 
} 
 
void Disable(size_t l_id){ 
  if (!m_countAlive) { return; } 
  ResetParticle(l_id); 
  Swap(l_id, m_countAlive - 1); 
  --m_countAlive; 
} 
</span></pre><p><span class="koboSpan" id="kobo.32.1">A sanity check is performed first in order to make sure we're not enabling any particles if the maximum amount already exists, or disabling any if there are no active ones. </span><span class="koboSpan" id="kobo.32.2">Enabling a particle simply requires its </span><span class="emphasis"><em><span class="koboSpan" id="kobo.33.1">alive</span></em></span><span class="koboSpan" id="kobo.34.1"> flag to be set to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.35.1">true</span></em></span><span class="koboSpan" id="kobo.36.1">, while disabling calls for a complete reset. </span><span class="koboSpan" id="kobo.36.2">All of the data stored at </span><code class="literal"><span class="koboSpan" id="kobo.37.1">l_id</span></code><span class="koboSpan" id="kobo.38.1"> is then swapped with either the element after the last active particle when enabling in order to make it last, or with the very last particle when disabling. </span><span class="koboSpan" id="kobo.38.2">Consider the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.39.1"><img src="graphics/image_03_004.jpg" alt="Storing particles"/></span></div><p><span class="koboSpan" id="kobo.40.1">Although it covers the scenario of disabling a particle, the same basic principle holds up for enabling as well.</span></p><p><span class="koboSpan" id="kobo.41.1">Actual data swapping isn't a very complicated process:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void Swap(size_t l_first, size_t l_second) { 
  std::swap(m_position[l_first], m_position[l_second]); 
  std::swap(m_velocity[l_first], m_velocity[l_second]); 
  std::swap(m_acceleration[l_first], m_acceleration[l_second]); 
  std::swap(m_startSize[l_first], m_startSize[l_second]); 
  ... 
</span><span class="koboSpan" id="kobo.42.2">} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">It simply invokes </span><code class="literal"><span class="koboSpan" id="kobo.44.1">std::swap</span></code><span class="koboSpan" id="kobo.45.1"> on every single particle property at the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">l_first</span></code><span class="koboSpan" id="kobo.47.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.48.1">l_second</span></code><span class="koboSpan" id="kobo.49.1"> indices.</span></p><p><span class="koboSpan" id="kobo.50.1">Finally, we get to the actual reset code for a single particle:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">void ResetParticle(size_t l_id){ 
  m_alive[l_id] = false; 
  m_gravity[l_id] = false; 
  m_addBlend[l_id] = false; 
  m_lifespan[l_id] = 0.f; 
  m_maxLifespan[l_id] = 0.f; 
  m_position[l_id] = { 0.f, 0.f, 0.f }; 
  m_velocity[l_id] = { 0.f, 0.f, 0.f }; 
  m_acceleration[l_id] = { 0.f, 0.f, 0.f }; 
  m_startRotation[l_id] = 0.f; 
  m_currentRotation[l_id] = 0.f; 
  m_finalRotation[l_id] = 0.f; 
  m_startSize[l_id] = { 0.f, 0.f }; 
  m_currentSize[l_id] = { 0.f, 0.f }; 
  m_finalSize[l_id] = { 0.f, 0.f }; 
  m_startColor[l_id] = { 0, 0, 0, 0 }; 
  m_currentColor[l_id] = { 0, 0, 0, 0 }; 
  m_finalColor[l_id] = { 0, 0, 0, 0 }; 
  if (!m_texture[l_id].empty()){ 
    m_textureManager-&gt;ReleaseResource(m_texture[l_id]); 
    m_texture[l_id].clear(); 
    m_drawable[l_id].setTexture(nullptr); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">Predictably, every single particle parameter is reset to an appropriate default value at the provided index. </span><span class="koboSpan" id="kobo.52.2">If the texture identifier is not empty, the resource also gets released, since it is no longer needed.</span></p></div><div class="section" title="Particle system architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/><span class="koboSpan" id="kobo.53.1">Particle system architecture</span></h2></div></div></div><p><span class="koboSpan" id="kobo.54.1">In order to cater for the way particles are stored and still provide a means of updating, interaction, and flexibility to the system, we must carefully address its architecture. </span><span class="koboSpan" id="kobo.54.2">Let's begin by breaking it down into smaller parts that will be easier to manage on their own:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.55.1">Emitter</span></strong></span><span class="koboSpan" id="kobo.56.1">:an object that exists in the world and acts as a particle spawner. </span><span class="koboSpan" id="kobo.56.2">It has access to a list of generators that each emitted particle is fed through before it gets spawned.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">Generator</span></strong></span><span class="koboSpan" id="kobo.58.1">:this belongs to a list of other similar objects that have direct access to particle properties and modify them according to their own, pre-defined rules in order to achieve a certain look.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.59.1">Updater</span></strong></span><span class="koboSpan" id="kobo.60.1">:one of many objects owned by the particle system, and designed to only use the data it needs for a specific task, which is always related to updating particles in a specific way.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.61.1">Force applicator</span></strong></span><span class="koboSpan" id="kobo.62.1">:a small data structure, used by one of the updaters in order to create </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">forces</span></em></span><span class="koboSpan" id="kobo.64.1"> in the world, which physically interact with the particles.</span></li></ul></div><p><span class="koboSpan" id="kobo.65.1">Let us take some time and look at each individual piece in more depth.</span></p><div class="section" title="The generator"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec0"/><span class="koboSpan" id="kobo.66.1">The generator</span></h3></div></div></div><p><span class="koboSpan" id="kobo.67.1">A generator within this context is going to act as a stamp in a way. </span><span class="koboSpan" id="kobo.67.2">It will take in a range of particles, the properties of which are going to be adjusted according to the type of generator that received them. </span><span class="koboSpan" id="kobo.67.3">Consider this illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.68.1"><img src="graphics/image_03_005.jpg" alt="The generator"/></span></div><p><span class="koboSpan" id="kobo.69.1">A specific generator can be almost considered as a stamp of sorts. </span><span class="koboSpan" id="kobo.69.2">Some of the properties it imprints on a particle can be random, while others are constant. </span><span class="koboSpan" id="kobo.69.3">Either way, once a few particles are fed into it, they come out </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">stamped</span></em></span><span class="koboSpan" id="kobo.71.1"> with the properties that the generator is responsible for.</span></p><p><span class="koboSpan" id="kobo.72.1">All the generators we're going to be implementing need to be generalized, which is why they all must obey by the provided interface:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">class BaseGenerator { 
public: 
  virtual ~BaseGenerator() {} 
  virtual void Generate(Emitter* l_emitter, 
    ParticleContainer* l_particles, size_t l_from, size_t l_to)=0; 
  friend std::stringstream&amp; operator &gt;&gt; ( 
    std::stringstream&amp; l_stream, BaseGenerator&amp; b) 
  { 
    b.ReadIn(l_stream); 
    return l_stream; 
  } 
 
  virtual void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</span></pre><p><span class="koboSpan" id="kobo.74.1">First, the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">Generate()</span></code><span class="koboSpan" id="kobo.76.1"> method needs some explaining. </span><span class="koboSpan" id="kobo.76.2">It takes in a pointer to the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">Emitter</span></code><span class="koboSpan" id="kobo.78.1"> instance that owns it. </span><span class="koboSpan" id="kobo.78.2">It also takes a pointer to the particle container it's going to be working with. </span><span class="koboSpan" id="kobo.78.3">The last two arguments are particle IDs that form a range, which represents particles that will be enabled inside the container. </span><span class="koboSpan" id="kobo.78.4">The range itself is going to be calculated inside the emitter that owns the generator.</span></p><p><span class="koboSpan" id="kobo.79.1">This base class also allows derivative generators to implement how their properties are loaded from files. </span><span class="koboSpan" id="kobo.79.2">This will be important later, when we start actually creating different types of generators.</span></p></div><div class="section" title="The emitter"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec1"/><span class="koboSpan" id="kobo.80.1">The emitter</span></h3></div></div></div><p><span class="koboSpan" id="kobo.81.1">As mentioned previously, an emitter is simply a class that owns a list of generators in order to spawn a specific type of particle. </span><span class="koboSpan" id="kobo.81.2">It can be positioned within the world, and is responsible for calculating particle ID ranges for emission by keeping track of its emit rate. </span><span class="koboSpan" id="kobo.81.3">Let's take a look at the header of the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">Emitter</span></code><span class="koboSpan" id="kobo.83.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.84.1">class Emitter { 
public: 
  Emitter(const sf::Vector3f&amp; l_position,int l_maxParticles = -1); 
  void Update(float l_dT, ParticleContainer* l_particles); 
  void SetPosition(const sf::Vector3f&amp; l_position); 
  sf::Vector3f GetPosition() const; 
  size_t GetEmitRate() const; 
  void SetEmitRate(size_t l_nPerSecond); 
  void SetParticleSystem(ParticleSystem* l_system); 
  void SetGenerators(const std::string&amp; l_generators); 
  std::string GetGenerators() const; 
  ParticleSystem* GetParticleSystem() const; 
private: 
  std::string m_generators; 
  size_t m_emitRate; 
  int m_maxParticles; 
  sf::Vector3f m_position; 
  float m_accumulator; 
  ParticleSystem* m_system; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.85.1">As you can see, this class doesn't actually store a list of generator instances. </span><span class="koboSpan" id="kobo.85.2">Instead, it stores a string identifier that will be used to obtain the list for a specific style of particles from the particle system.</span></p><p><span class="koboSpan" id="kobo.86.1">All of the setters and getters in this class are simple one-line methods that perform exactly as advertised, so we won't be covering them.</span></p><p><span class="koboSpan" id="kobo.87.1">Aside all of the other obvious data members, it stores a floating point value named </span><code class="literal"><span class="koboSpan" id="kobo.88.1">m_accumulator</span></code><span class="koboSpan" id="kobo.89.1">, which is going to be used in conjunction with the emit rate. </span><span class="koboSpan" id="kobo.89.2">We'll go over it more very shortly. </span><span class="koboSpan" id="kobo.89.3">It also stores an </span><code class="literal"><span class="koboSpan" id="kobo.90.1">m_maxParticles</span></code><span class="koboSpan" id="kobo.91.1"> data member in order to know if particles should be emitted indefinitely, or if the emitter needs to stop after a certain amount have been created.</span></p><div class="section" title="Implementing emitter"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec0"/><span class="koboSpan" id="kobo.92.1">Implementing emitter</span></h4></div></div></div><p><span class="koboSpan" id="kobo.93.1">Let's start with the basics of simply initializing all data members to their default values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.94.1">Emitter::Emitter(const sf::Vector3f&amp; l_position, 
  int l_maxParticles) : m_position(l_position),  
  m_maxParticles(l_maxParticles), m_emitRate(0), 
  m_accumulator(0.f), m_system(nullptr){} 
</span></pre><p><span class="koboSpan" id="kobo.95.1">The only real method of importance in this class is obviously the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">Update()</span></code><span class="koboSpan" id="kobo.97.1"> method. </span><span class="koboSpan" id="kobo.97.2">It's responsible for actually doing all of the heavy lifting when it comes to particle emission:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.98.1">void Emitter::Update(float l_dT, ParticleContainer* l_particles){ 
  if (m_generators.empty()) { return; } 
  auto generatorList = m_system-&gt;GetGenerators(m_generators); 
  if (!generatorList) { return; } 
  m_accumulator += l_dT * m_emitRate; 
  if (m_accumulator &lt; 1.f) { return; } 
  auto num_particles = static_cast&lt;int&gt;(m_accumulator); 
  m_accumulator -= num_particles; 
  if (m_maxParticles != -1) { 
    if (num_particles &gt; m_maxParticles) { 
      num_particles = m_maxParticles; 
      m_maxParticles = 0; 
    } 
    else { m_maxParticles -= num_particles; } 
  } 
  size_t from = l_particles-&gt;m_countAlive; 
  size_t to = (l_particles-&gt;m_countAlive + num_particles &gt; 
    l_particles-&gt;Max_Particles ? </span><span class="koboSpan" id="kobo.98.2">l_particles-&gt;Max_Particles - 1 
    : l_particles-&gt;m_countAlive + num_particles - 1); 
 
  for (auto&amp; generator : *generatorList){ 
    generator-&gt;Generate(this, l_particles, from, to); 
  } 
  for (auto i = from; i &lt;= to; ++i){ l_particles-&gt;Enable(i); } 
  if (!m_maxParticles) { m_system-&gt;RemoveEmitter(this); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.99.1">Naturally, the updating is not going to happen if either the generator identifier is empty, or we were unable to obtain the list of generators from the particle system. </span><span class="koboSpan" id="kobo.99.2">Provided that isn't the case, the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">m_accumulator</span></code><span class="koboSpan" id="kobo.101.1"> data member is added to based on the emit rate and </span><span class="strong"><strong><span class="koboSpan" id="kobo.102.1">delta time</span></strong></span><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">It holds the total number of particles that have yet to be emitted. </span><span class="koboSpan" id="kobo.103.3">Since we obviously can't emit half of a particle, or any other fraction for that matter, the accumulator data member is checked to see whether it's less than one. </span><span class="koboSpan" id="kobo.103.4">If that's the case, there is nothing to emit/update.</span></p><p><span class="koboSpan" id="kobo.104.1">The number of particles to be emitted is then calculated by simply converting the accumulator value to an integer. </span><span class="koboSpan" id="kobo.104.2">It is then subtracted from the accumulator, which retains whatever fraction of a particle is left for the next tick.</span></p><p><span class="koboSpan" id="kobo.105.1">The way we know an emitter should keep on spitting particles out indefinitely is if its </span><code class="literal"><span class="koboSpan" id="kobo.106.1">m_maxParticles</span></code><span class="koboSpan" id="kobo.107.1"> data member is set to </span><code class="literal"><span class="koboSpan" id="kobo.108.1">-1</span></code><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">If it isn't, the number of particles to be emitted this tick is checked for not having exceeded the limit.</span></p><p><span class="koboSpan" id="kobo.110.1">Finally, we get to the interesting part. </span><span class="koboSpan" id="kobo.110.2">First, the range of IDs that will be brought back to life is calculated, making sure it doesn't go beyond the maximum number of particles allowed. </span><span class="koboSpan" id="kobo.110.3">The generator list for the type of particle the emitter is spitting out is then iterated over, with pointers to the current emitter, and the particle list being passed into their </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Generate()</span></code><span class="koboSpan" id="kobo.112.1"> methods, alongside the calculated ranges. </span><span class="koboSpan" id="kobo.112.2">The range of particles is then iterated over and re-enabled to be displayed again, and the emitter is checked to see if it needs to be removed, should the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">m_maxParticles</span></code><span class="koboSpan" id="kobo.114.1"> data member reach zero.</span></p></div></div><div class="section" title="The updater"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec2"/><span class="koboSpan" id="kobo.115.1">The updater</span></h3></div></div></div><p><span class="koboSpan" id="kobo.116.1">In order to breathe life into our particle system, we must constantly keep it updated. </span><span class="koboSpan" id="kobo.116.2">Keeping performance in mind, we must stay true to the SoA pattern and only work with the data that is absolutely necessary for a particular scenario, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.117.1"><img src="graphics/image_03_006.jpg" alt="The updater"/></span></div><p><span class="koboSpan" id="kobo.118.1">With that in mind, a very basic interface for all updaters can be put together, looking something like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.119.1">class BaseUpdater { 
public: 
  virtual ~BaseUpdater() {} 
  virtual void Update(float l_dT, 
    ParticleContainer* l_particles) = 0; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.120.1">All updaters should ever care about, as you can see, is the delta time and having a pointer to the particle container they are operating on. </span><span class="koboSpan" id="kobo.120.2">There is no need to provide it with ranges, as it will be operating on all </span><span class="emphasis"><em><span class="koboSpan" id="kobo.121.1">alive</span></em></span><span class="koboSpan" id="kobo.122.1"> particles.</span></p></div><div class="section" title="Force applicators"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec3"/><span class="koboSpan" id="kobo.123.1">Force applicators</span></h3></div></div></div><p><span class="koboSpan" id="kobo.124.1">Because we don't want our character to be running around a static, dead environment, some interactivity between events and particles is required. </span><span class="koboSpan" id="kobo.124.2">This relationship is established via the means of forces, which impact the kinematic states of particles within reach, as shown here:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.125.1"><img src="graphics/image_03_007.jpg" alt="Force applicators"/></span></div><p><span class="koboSpan" id="kobo.126.1">Force applicators are not fundamental to particle systems. </span><span class="koboSpan" id="kobo.126.2">All we need to do in order to generalize them is store some data, and let the appropriate updater(s) take care of the logic. </span><span class="koboSpan" id="kobo.126.3">Having said that, let us take a look at what we need to store:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.127.1">struct ForceApplicator { 
  ForceApplicator(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius) 
    : m_center(l_center), m_force(l_force), m_radius(l_radius){} 
  sf::Vector3f m_center; 
  sf::Vector3f m_force; 
  float m_radius; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.128.1">Forces can be positioned in the world, so their centers need to be stored. </span><span class="koboSpan" id="kobo.128.2">Additionally, a radius of the force is also necessary, in order to figure out the area of impact. </span><span class="koboSpan" id="kobo.128.3">Lastly, there can be no impact without first knowing how strong it is. </span><span class="koboSpan" id="kobo.128.4">This is where </span><code class="literal"><span class="koboSpan" id="kobo.129.1">m_force</span></code><span class="koboSpan" id="kobo.130.1"> comes in, by allowing force to be defined in all three axes.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building the particle system class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/><span class="koboSpan" id="kobo.1.1">Building the particle system class</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With all of the building blocks in place, it's time to actually build the particle system class. </span><span class="koboSpan" id="kobo.2.2">Let's start with some type definitions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">using Updaters = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;BaseUpdater&gt;&gt;; 
using EmitterList = std::vector&lt;std::unique_ptr&lt;Emitter&gt;&gt;; 
using Emitters = std::unordered_map&lt;StateType, EmitterList&gt;; 
using GeneratorList = std::vector&lt;std::unique_ptr&lt;BaseGenerator&gt;&gt;; 
using Generators = std::unordered_map&lt;std::string,GeneratorList&gt;; 
using RemovedEmitters = std::vector&lt;Emitter*&gt;; 
using Particles = std::unordered_map&lt;StateType, 
  std::unique_ptr&lt;ParticleContainer&gt;&gt;; 
using ForceApplicatorList = std::vector&lt;ForceApplicator&gt;; 
using ForceApplicators = std::unordered_map&lt;StateType, 
  ForceApplicatorList&gt;; 
 
using GeneratorFactory = std::unordered_map&lt;std::string, 
  std::function&lt;BaseGenerator*(void)&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">In order to access any updater we want, we can map them to </span><code class="literal"><span class="koboSpan" id="kobo.5.1">string</span></code><span class="koboSpan" id="kobo.6.1"> identifiers. </span><span class="koboSpan" id="kobo.6.2">While the updaters aren't state-specific, emitters are. </span><span class="koboSpan" id="kobo.6.3">Their lists have to be associated with specific states in order to maintain particles across the entire application. </span><span class="koboSpan" id="kobo.6.4">Generators, just like updaters, aren't unique to any particular state, and we want to be able to access them via a string identifier from </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Emitter</span></code><span class="koboSpan" id="kobo.8.1"> classes. </span><span class="koboSpan" id="kobo.8.2">Speaking of which, as evident from the code we've already covered, emitters can request removal of themselves in case they should stop emitting particles. </span><span class="koboSpan" id="kobo.8.3">Since that happens during the update cycle while the class is still in use, a separate list of emitter pointers must be kept for later removal.</span></p><p><span class="koboSpan" id="kobo.9.1">Particles themselves are obviously stored within the designated </span><code class="literal"><span class="koboSpan" id="kobo.10.1">ParticleContainer</span></code><span class="koboSpan" id="kobo.11.1"> class, but these containers can, obviously, be possessed by different states. </span><span class="koboSpan" id="kobo.11.2">A similar idea applies as before, where we mapped state types to different particle containers in order to maintain application-wide particle support. </span><span class="koboSpan" id="kobo.11.3">The same exact principle also applies to force applicators.</span></p><p><span class="koboSpan" id="kobo.12.1">The last data type we have should be a dead giveaway for the fact that we're going to be using the factory design pattern for producing different types of particle generator. </span><span class="koboSpan" id="kobo.12.2">These types will also be tied to string identifiers.</span></p><p><span class="koboSpan" id="kobo.13.1">With all of that in mind, it's time to discuss how the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">ParticleSystem</span></code><span class="koboSpan" id="kobo.15.1"> class can be implemented, starting with its header:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">class ParticleSystem : public FileLoader, public StateDependent, 
  public MapLoadee 
{ 
public: 
  ParticleSystem(StateManager* l_stateManager, 
    TextureManager* l_textureMgr, RandomGenerator* l_rand, 
    Map* l_map); 
  void AddEmitter(std::unique_ptr&lt;Emitter&gt; l_emitter, 
    const StateType&amp; l_state = StateType(0)); 
  void AddForce(ForceApplicator l_force, 
    const StateType&amp; l_state = StateType(0)); 
  void RemoveEmitter(Emitter* l_emitter); 
 
  GeneratorList* GetGenerators(const std::string&amp; l_name); 
 
  TextureManager* GetTextureManager() const; 
  RandomGenerator* GetRand() const; 
 
  void CreateState(const StateType&amp; l_state); 
  void ChangeState(const StateType&amp; l_state); 
  void RemoveState(const StateType&amp; l_state); 
 
  void ReadMapLine(const std::string&amp; l_type, 
    std::stringstream&amp; l_stream); 
 
  void Update(float l_dT); 
  void ApplyForce(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius); 
  void Draw(Window* l_window, int l_elevation); 
private: 
  bool ProcessLine(std::stringstream&amp; l_stream); 
  void ResetForNextFile(); 
 
  template&lt;class T&gt; 
  void RegisterGenerator(const std::string&amp; l_name) { ... </span><span class="koboSpan" id="kobo.16.2">} 
 
  std::string m_loadingGenerator; 
  Particles m_container; 
  Particles::iterator m_stateItr; 
  Emitters::iterator m_emitterItr; 
  Updaters m_updaters; 
  Emitters m_emitters; 
  Generators m_generators; 
  GeneratorFactory m_factory; 
  ForceApplicators m_forces; 
  RemovedEmitters m_removedEmitters; 
  TextureManager* m_textureMgr; 
  RandomGenerator* m_rand; 
  Map* m_map; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.17.1">First, let us examine the inheritance subtleties of this class. </span><span class="koboSpan" id="kobo.17.2">Because we are going to have properties of particles saved inside text files, inheritance from </span><code class="literal"><span class="koboSpan" id="kobo.18.1">FileLoader</span></code><span class="koboSpan" id="kobo.19.1"> is useful, not to mention we get to offload the work to a separate thread. </span><span class="koboSpan" id="kobo.19.2">Also, recall that different states will need to be provided access to our particle system, which means the particle manager must implement methods for adding, changing, and removing states. </span><span class="koboSpan" id="kobo.19.3">Lastly, keep in mind that particle emitters and the different forces that impact them may be something game maps contain, so we're also inheriting from the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">MapLoadee</span></code><span class="koboSpan" id="kobo.21.1"> class.</span></p><p><span class="koboSpan" id="kobo.22.1">The class itself obviously needs access to the texture manager, a pointer to which is later passed down to the classes that need it. </span><span class="koboSpan" id="kobo.22.2">The same is true for the random number generator, as well as a pointer to the map instance.</span></p><p><span class="koboSpan" id="kobo.23.1">Lastly, note the two highlighted data members of this class, which are both iterators. </span><span class="koboSpan" id="kobo.23.2">These are kept around for easier access to data that is state-specific while updating/rendering particles.</span></p><div class="section" title="Implementing the particle system"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/><span class="koboSpan" id="kobo.24.1">Implementing the particle system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.25.1">Let's start by taking a look at the constructor of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">ParticleSystem::ParticleSystem(StateManager* l_stateManager, 
  TextureManager* l_textureManager, RandomGenerator* l_rand, 
  Map* l_map) 
  : m_stateManager(l_stateManager),m_textureMgr(l_textureManager), 
  m_rand(l_rand), m_map(l_map) 
{ 
  m_updaters.emplace("Lifespan", 
    std::make_unique&lt;LifespanUpdater&gt;()); 
  ... 
  </span><span class="koboSpan" id="kobo.26.2">RegisterGenerator&lt;PointPosition&gt;("PointPosition"); 
  ... 
</span><span class="koboSpan" id="kobo.26.3">} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">Outside the initializer list that performs all of the data member set-up duties, there is only one other purpose for the constructor here: setting up all of the updaters and generator types. </span><span class="koboSpan" id="kobo.27.2">The code we have above is heavily abridged, but the idea remains the same. </span><span class="koboSpan" id="kobo.27.3">All of the updaters we want to use are inserted into their container with the appropriate string identifier attached. </span><span class="koboSpan" id="kobo.27.4">On the generator side, we invoke a private template method that ties a specific type of a generator to a string identifier. </span><span class="koboSpan" id="kobo.27.5">Once again, we are using the factory pattern here.</span></p><p><span class="koboSpan" id="kobo.28.1">Adding emitter objects to our particle system is relatively straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">void ParticleSystem::AddEmitter( 
  std::unique_ptr&lt;Emitter&gt; l_emitter, const StateType&amp; l_state) 
{ 
  l_emitter-&gt;SetParticleSystem(this); 
  if (!GetGenerators(l_emitter-&gt;GetGenerators())) {  
    return;  
  } 
  if (l_state == StateType(0)) { 
    if (m_emitterItr == m_emitters.end()) { return; } 
    m_emitterItr-&gt;second.emplace_back(std::move(l_emitter)); 
    return; 
  } 
  auto itr = m_emitters.find(l_state); 
  if (itr == m_emitters.end()) { return; } 
  itr-&gt;second.emplace_back(std::move(l_emitter)); 
} 
</span></pre><p><span class="koboSpan" id="kobo.30.1">First, the emitter is provided with a pointer to the particle system for later access. </span><span class="koboSpan" id="kobo.30.2">We then check if the emitter's generator list name is valid. </span><span class="koboSpan" id="kobo.30.3">It's pointless to have an emitter that is going to be spawning </span><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">empty</span></em></span><span class="koboSpan" id="kobo.32.1"> particles.</span></p><p><span class="koboSpan" id="kobo.33.1">As evident from the class header, a default value to the second argument of this method is provided. </span><span class="koboSpan" id="kobo.33.2">This gives us a nice way to differentiate whether a user of this class wants to add an emitter to a specific state, or just the current state that is selected. </span><span class="koboSpan" id="kobo.33.3">Both of these possibilities are then handled in the remaining chunk of the code.</span></p><p><span class="koboSpan" id="kobo.34.1">Force applicators are dealt with in a very similar fashion:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void ParticleSystem::AddForce(ForceApplicator l_force, 
  const StateType&amp; l_state) 
{ 
  if (l_state == StateType(0)) { 
    if (m_stateItr == m_container.end()) { return; } 
    m_forces[m_currentState].emplace_back(l_force); 
    return; 
  } 
  auto itr = m_forces.find(l_state); 
  if(itr == m_forces.end()) { return; } 
  itr-&gt;second.emplace_back(l_force); 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">Once again, the second argument has a default value, so we handle both the possibilities before attempting to insert the force applicator data inside the appropriate container.</span></p><p><span class="koboSpan" id="kobo.37.1">Removal of emitters, as mentioned in the data type section, has two stages. </span><span class="koboSpan" id="kobo.37.2">The first stage is simply putting a pointer to the emitter in a designated list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">void ParticleSystem::RemoveEmitter(Emitter* l_emitter) { 
  m_removedEmitters.push_back(l_emitter); 
} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">The actual removal is handled elsewhere. </span><span class="koboSpan" id="kobo.39.2">We will be covering that shortly.</span></p><p><span class="koboSpan" id="kobo.40.1">Obtaining the generator list is important for the emission process, so naturally, we must have a method for that as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">GeneratorList* ParticleSystem::GetGenerators( 
  const std::string&amp; l_name) 
{ 
  auto&amp; itr = m_generators.find(l_name); 
  if (itr == m_generators.end()) { 
    return nullptr; 
  } 
  return &amp;itr-&gt;second; 
} 
</span></pre><p><span class="koboSpan" id="kobo.42.1">Now, we stumble upon the state-dependent part of the particle system, starting with state creation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">void ParticleSystem::CreateState(const StateType&amp; l_state) { 
  if (m_container.find(l_state) != m_container.end()) { return; } 
  m_container.emplace(l_state, 
    std::make_unique&lt;ParticleContainer&gt;(m_textureMgr)); 
  m_emitters.emplace(l_state, EmitterList()); 
  m_forces.emplace(l_state, ForceApplicatorList()); 
  ChangeState(l_state); 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">First, a determination needs to be made whether the state being created doesn't already, for some reason, have its own particle container allocated. </span><span class="koboSpan" id="kobo.44.2">If it doesn't, one is created and inserted into the state's particle container, as well as an emitter list, and a force applicator list for that same state.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/><span class="koboSpan" id="kobo.45.1">Note</span></h3><p><span class="koboSpan" id="kobo.46.1">The </span><code class="literal"><span class="koboSpan" id="kobo.47.1">CreateState()</span></code><span class="koboSpan" id="kobo.48.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">StateDependent</span></code><span class="koboSpan" id="kobo.50.1"> class is the only piece of code that needs to be invoked manually, in case certain states don't need to utilize that particular state dependent resource.</span></p></div></div><p><span class="koboSpan" id="kobo.51.1">Next, let's discuss how a state can be changed inside a particle system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">void ParticleSystem::ChangeState(const StateType&amp; l_state) { 
  SetState(l_state); 
  m_stateItr = m_container.find(m_currentState); 
  m_emitterItr = m_emitters.find(m_currentState); 
 
  auto c = static_cast&lt;CollisionUpdater*&gt;( 
    m_updaters["Collision"].get()); 
  if (l_state == StateType::Game) { c-&gt;SetMap(m_map); } 
  else { c-&gt;SetMap(nullptr); } 
  auto f = static_cast&lt;ForceUpdater*&gt;(m_updaters["Force"].get()); 
  auto&amp; forceItr = m_forces.find(m_currentState); 
  if (forceItr == m_forces.end()) { 
    f-&gt;SetApplicators(nullptr); return; 
  } 
  f-&gt;SetApplicators(&amp;forceItr-&gt;second); 
} 
</span></pre><p><span class="koboSpan" id="kobo.53.1">After a private method for changing its own internal state is invoked, the data member that holds an iterator to the particles of the current state is updated. </span><span class="koboSpan" id="kobo.53.2">The same exact thing is done to the emitter iterator.</span></p><p><span class="koboSpan" id="kobo.54.1">The next few lines of code may not make much sense within this context, since we have not worked on any updaters yet, but let us cover them anyway. </span><span class="koboSpan" id="kobo.54.2">Further down the line, we are going to have updaters for particle collisions and forces. </span><span class="koboSpan" id="kobo.54.3">As far as collisions go, the updater only needs to have a pointer to the game map, presuming the current state is </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Game</span></code><span class="koboSpan" id="kobo.56.1">. </span><code class="literal"><span class="koboSpan" id="kobo.57.1">ForceUpdater</span></code><span class="koboSpan" id="kobo.58.1">, on the other hand, needs to have access to a list of force applicators for the current state. </span><span class="koboSpan" id="kobo.58.2">Both of these types of updater are accommodated here.</span></p><p><span class="koboSpan" id="kobo.59.1">Let's wrap up the state modification subject by taking a look at what happens inside a particle system when a state is removed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">void ParticleSystem::RemoveState(const StateType&amp; l_state) { 
  if (m_stateItr-&gt;first == l_state) { 
    m_stateItr = m_container.end(); 
    m_emitterItr = m_emitters.end(); 
  } 
  m_emitters.erase(l_state); 
  m_forces.erase(l_state); 
  m_container.erase(l_state); 
} 
</span></pre><p><span class="koboSpan" id="kobo.61.1">All we do here is erase data from state-bound containers. </span><span class="koboSpan" id="kobo.61.2">Since there are two iterator data members kept around, those too must be reset in case the state being removed matches the current state. </span><span class="koboSpan" id="kobo.61.3">Because of the way our state system works, and the order of </span><code class="literal"><span class="koboSpan" id="kobo.62.1">ChangeState</span></code><span class="koboSpan" id="kobo.63.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.64.1">RemoveState</span></code><span class="koboSpan" id="kobo.65.1">, we don't need to worry about iterators being invalidated.</span></p><p><span class="koboSpan" id="kobo.66.1">Our particle system will definitely have plenty of data to load from text files, which is why it inherits from a file loader class. </span><span class="koboSpan" id="kobo.66.2">Let us take a look at the method that every single line stream will be fed into:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.67.1">bool ParticleSystem::ProcessLine(std::stringstream&amp; l_stream) { 
  std::string type; 
  l_stream &gt;&gt; type; 
  if (type == "Name") { 
    if (!(l_stream &gt;&gt; m_loadingGenerator)) { return false; } 
    auto generators = GetGenerators(m_loadingGenerator); 
    if (generators) { return false; } 
  } else { 
    if (m_loadingGenerator.empty()) { return false; } 
    auto itr = m_factory.find(type); 
    if (itr == m_factory.end()) { return true; } 
    std::unique_ptr&lt;BaseGenerator&gt; generator(itr-&gt;second()); 
    l_stream &gt;&gt; *generator; 
    m_generators[m_loadingGenerator].emplace_back( 
      std::move(generator)); 
  } 
  return true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.68.1">The first string of each line, later referred to as type, is extracted. </span><span class="koboSpan" id="kobo.68.2">If we have a name, another string is attempted to be extracted, and later checked for matches inside the generator list, in order to avoid duplicates. </span><span class="koboSpan" id="kobo.68.3">The name of the generator list is stored inside the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">m_loadingGenerator</span></code><span class="koboSpan" id="kobo.70.1"> data member.</span></p><p><span class="koboSpan" id="kobo.71.1">If any other type is encountered, it is safe to assume we are dealing with a specific type of generator. </span><span class="koboSpan" id="kobo.71.2">If that is the case, the generator list name is first checked that it isnt't being empty, which would indicate a file format problem. </span><span class="koboSpan" id="kobo.71.3">The generator factory is then searched for the generator with the type loaded from the file. </span><span class="koboSpan" id="kobo.71.4">If it is found, a new generator instance is created through it, the stream object is passed to it to do its own loading via the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.73.1"> operator, and the final instance is inserted into the generator list for the current type of </span><code class="literal"><span class="koboSpan" id="kobo.74.1">m_loadingGenerator</span></code><span class="koboSpan" id="kobo.75.1">.</span></p><p><span class="koboSpan" id="kobo.76.1">Because we're using a data member to keep file information around, it must be reset before attempting to load another file. </span><span class="koboSpan" id="kobo.76.2">Our </span><code class="literal"><span class="koboSpan" id="kobo.77.1">FileLoader</span></code><span class="koboSpan" id="kobo.78.1"> interface provides such functionality, given this method is overloaded:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.79.1">void ParticleSystem::ResetForNextFile() { 
  m_loadingGenerator.clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.80.1">The final base class the particle system is inheriting from, </span><code class="literal"><span class="koboSpan" id="kobo.81.1">MapLoadee</span></code><span class="koboSpan" id="kobo.82.1">, requires us to implement a single method that will handle map file entries with its own custom types:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.83.1">void ParticleSystem::ReadMapLine(const std::string&amp; l_type, 
  std::stringstream&amp; l_stream) 
{ 
  if (l_type == "ParticleEmitter") { 
    sf::Vector3f position; 
    size_t emitRate; 
    std::string generatorType; 
    l_stream &gt;&gt; generatorType &gt;&gt; position.x &gt;&gt; position.y &gt;&gt; 
      position.z &gt;&gt; emitRate; 
    auto emitter = std::make_unique&lt;Emitter&gt;(position); 
    emitter-&gt;SetEmitRate(emitRate); 
    emitter-&gt;SetGenerators(generatorType); 
    AddEmitter(std::move(emitter), StateType::Game); 
  } else if (l_type == "ForceApplicator") { 
    sf::Vector3f position; 
    sf::Vector3f force; 
    float radius; 
    l_stream &gt;&gt; position.x &gt;&gt; position.y &gt;&gt; position.z &gt;&gt; 
      force.x &gt;&gt; force.y &gt;&gt; force.z &gt;&gt; radius; 
    AddForce(ForceApplicator(position, force, radius), 
      StateType::Game); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.84.1">As you can see, two different types of map entry are supported by the particle system: </span><code class="literal"><span class="koboSpan" id="kobo.85.1">ParticleEmitter</span></code><span class="koboSpan" id="kobo.86.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.87.1">ForceApplicator</span></code><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">In both cases, all of the appropriate data is streamed in and applied to the newly constructed objects, which are then added to the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">Game</span></code><span class="koboSpan" id="kobo.90.1"> state.</span></p><p><span class="koboSpan" id="kobo.91.1">Next, let's focus on the method that </span><span class="emphasis"><em><span class="koboSpan" id="kobo.92.1">makes it all move</span></em></span><span class="koboSpan" id="kobo.93.1">, so of speak. </span><span class="koboSpan" id="kobo.93.2">It's time to take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">Update()</span></code><span class="koboSpan" id="kobo.95.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.96.1">void ParticleSystem::Update(float l_dT) { 
  if (m_stateItr == m_container.end()) { return; } 
  for (auto&amp; emitter : m_emitterItr-&gt;second) { 
    emitter-&gt;Update(l_dT, m_stateItr-&gt;second.get()); 
  } 
  for (auto&amp; updater : m_updaters){ 
    updater.second-&gt;Update(l_dT, m_stateItr-&gt;second.get()); 
  } 
  if (!m_removedEmitters.size()) { return; } 
  for (auto&amp; removed : m_removedEmitters) { 
    m_emitterItr-&gt;second.erase( 
      std::remove_if( 
        m_emitterItr-&gt;second.begin(), 
        m_emitterItr-&gt;second.end(), 
        [removed](std::unique_ptr&lt;Emitter&gt;&amp; emitter) { 
          return emitter.get() == removed; 
        } 
    )); 
  } 
  m_removedEmitters.clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.97.1">It really only consists of three basic parts: updating emitters, updating all the different </span><code class="literal"><span class="koboSpan" id="kobo.98.1">BaseUpdater</span></code><span class="koboSpan" id="kobo.99.1"> instances, and processing removed emitters. </span><span class="koboSpan" id="kobo.99.2">None of this happens if the current state iterator is not valid. </span><span class="koboSpan" id="kobo.99.3">Having no particles to work with means we have no work at all.</span></p><p><span class="koboSpan" id="kobo.100.1">The updating of emitters and updaters is fairly straightforward. </span><span class="koboSpan" id="kobo.100.2">Removal of disposed emitters is not anything too complex either. </span><span class="koboSpan" id="kobo.100.3">The container of removed emitter pointers is iterated over, and for each entry, an emitter that is still within the world and has the same memory address is removed from the container.</span></p><p><span class="koboSpan" id="kobo.101.1">Finally, we get to the code responsible for getting all of our beautiful particles out on the screen:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.102.1">void ParticleSystem::Draw(Window* l_window, int l_elevation) { 
  if (m_stateItr == m_container.end()) { return; } 
  auto container = m_stateItr-&gt;second.get(); 
  auto&amp; drawables = container-&gt;m_drawable; 
  auto&amp; positions = container-&gt;m_position; 
  auto&amp; blendModes = container-&gt;m_addBlend; 
  auto view = l_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto renderer = l_window-&gt;GetRenderer(); 
 
  auto state = m_stateManager-&gt;GetCurrentStateType(); 
  if (state == StateType::Game || state == StateType::MapEditor) { 
    renderer-&gt;UseShader("default"); 
  } else { 
    renderer-&gt;DisableShader(); 
  } 
 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    if (l_elevation &gt;= 0) { 
      if (positions[i].z &lt; l_elevation * Sheet::Tile_Size) { 
        continue; 
      } 
      if (positions[i].z &gt;= (l_elevation + 1) * Sheet::Tile_Size){ 
        continue; 
      } 
    } else if (positions[i].z &lt; 
      Sheet::Num_Layers * Sheet::Tile_Size) 
    { continue; } 
    renderer-&gt;AdditiveBlend(blendModes[i]); 
    renderer-&gt;Draw(drawables[i]); 
  } 
  renderer-&gt;AdditiveBlend(false); 
} 
</span></pre><p><span class="koboSpan" id="kobo.103.1">Naturally, if we're in a state that does not have a particle container, no drawing needs to be done. </span><span class="koboSpan" id="kobo.103.2">Otherwise, we obtain references to arrays of drawables, their positions and blend modes. </span><span class="koboSpan" id="kobo.103.3">Since we want particles to support layering in order to add depth, the second argument of this method takes in the current layer being drawn.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note7"/><span class="koboSpan" id="kobo.104.1">Note</span></h3><p><span class="koboSpan" id="kobo.105.1">Note the state checking and use of shaders in this portion of the code. </span><span class="koboSpan" id="kobo.105.2">We're essentially controlling which states the particles are shaded in here. </span><span class="koboSpan" id="kobo.105.3">The map editor state will be covered in the next two chapters.</span></p></div></div><p><span class="koboSpan" id="kobo.106.1">If the layer/elevation tests pass, there's one more check we need to make in order to be able to render a particle, and that is whether the particle is currently within the view of the screen.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip8"/><span class="koboSpan" id="kobo.107.1">Tip</span></h3><p><span class="koboSpan" id="kobo.108.1">This simple AABB collision check obviously does </span><span class="strong"><strong><span class="koboSpan" id="kobo.109.1">not</span></strong></span><span class="koboSpan" id="kobo.110.1"> account for particles being rotated. </span><span class="koboSpan" id="kobo.110.2">Although the bounds that are checked still contain the entire body of a particle, certain corner-case scenarios may result in it being rendered, while it is rotated in such a way that it should be invisible, yet where the bounding box is still within the view. </span><span class="koboSpan" id="kobo.110.3">This can be solved by applying a more sophisticated collision check algorithm, but it isn't going to be covered here.</span></p></div></div><p><span class="koboSpan" id="kobo.111.1">Finally, after all of the tests have passed, it is time to render the particle. </span><span class="koboSpan" id="kobo.111.2">Keep in mind that it is in our best interest here to support two blending modes when it comes to rendering: additive and alpha blending. </span><span class="koboSpan" id="kobo.111.3">Luckily, SFML makes it easy for us, and it's only necessary to pass an additional argument to the draw method of a window instance to determine how something is drawn.</span></p><p><span class="koboSpan" id="kobo.112.1">Having the ability to switch between blending modes can be useful when rendering some particle types, since they would look more realistic that way. </span><span class="koboSpan" id="kobo.112.2">For example, take a look at the same type of particles being rendered with additive blending, versus alpha blending, which is the default mode:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.113.1"><img src="graphics/image_03_008.jpg" alt="Implementing the particle system"/></span></div><p><span class="koboSpan" id="kobo.114.1">While not all particles are going to take advantage of this blending mode, it's definitely a nice option to have for those that need that extra oomph.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Creating updaters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/><span class="koboSpan" id="kobo.1.1">Creating updaters</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With the core particle system all built up, it is time to focus on individual bits and pieces that will give our system its functionality and polish. </span><span class="koboSpan" id="kobo.2.2">By the time we are done, these are some of the effects that will be possible:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.3.1"><img src="graphics/image_03_009.jpg" alt="Creating updaters"/></span></div><p><span class="koboSpan" id="kobo.4.1">The only way to get there is to keep going, so let us get to it!</span></p><div class="section" title="Spatial updater"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/><span class="koboSpan" id="kobo.5.1">Spatial updater</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">First, and probably the most obvious task is adjusting particle positions based on their kinematic states. </span><span class="koboSpan" id="kobo.6.2">As small as they may be, they still operate based on changes in velocity, acceleration, and position:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class SpatialUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    auto&amp; accelerations = l_particles-&gt;m_acceleration; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      velocities[i] += accelerations[i] * l_dT; 
    } 
    auto&amp; positions = l_particles-&gt;m_position; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      positions[i] += velocities[i] * l_dT; 
    } 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">So far, so good! </span><span class="koboSpan" id="kobo.8.2">Some of these updaters will have rather small footprints since they perform incredibly simple tasks. </span><span class="koboSpan" id="kobo.8.3">All we do here is obtain references to velocity, acceleration and position containers. </span><span class="koboSpan" id="kobo.8.4">The data is then manipulated in two separate loops in order to minimize cache misses.</span></p></div><div class="section" title="Drawable updater"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/><span class="koboSpan" id="kobo.9.1">Drawable updater</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">Next, let's update the drawable bits of our particles. </span><span class="koboSpan" id="kobo.10.2">This is where the appropriately named </span><code class="literal"><span class="koboSpan" id="kobo.11.1">DrawableUpdater</span></code><span class="koboSpan" id="kobo.12.1"> comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">class DrawableUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto&amp; drawables = l_particles-&gt;m_drawable; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setPosition(positions[i].x, positions[i].y); 
    } 
    auto&amp; sizes = l_particles-&gt;m_currentSize; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setSize(sizes[i]); 
    } 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      float ScaleFactor = std::max( 
        (positions[i].z / Sheet::Tile_Size) * 
        ScaleToElevationRatio, 1.f); 
      drawables[i].setScale(ScaleFactor, ScaleFactor); 
    } 
    auto&amp; colors = l_particles-&gt;m_currentColor; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setFillColor(colors[i]); 
    } 
    auto&amp; rotations = l_particles-&gt;m_currentRotation; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setRotation(rotations[i]); 
    } 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setOrigin( 
        drawables[i].getLocalBounds().width / 2, 
        drawables[i].getLocalBounds().height / 2); 
    } 
  } 
  static const float ScaleToElevationRatio; 
}; 
 
const float DrawableUpdater::ScaleToElevationRatio = 1.5f; 
</span></pre><p><span class="koboSpan" id="kobo.14.1">This is quite a bit of code, but its essence is incredibly simple. </span><span class="koboSpan" id="kobo.14.2">Separate loops are utilized in order to set all of the relevant drawable properties up. </span><span class="koboSpan" id="kobo.14.3">We do, however, have something more interesting going on. </span><span class="koboSpan" id="kobo.14.4">Note the highlighted portions of the code, all of which are related to scale. </span><span class="koboSpan" id="kobo.14.5">As you have probably figured out by now, SFML deals with only two dimensions when it comes to visuals. </span><span class="koboSpan" id="kobo.14.6">In order to fake 3D particles flying around, we can utilize drawable scaling. </span><span class="koboSpan" id="kobo.14.7">The scale factor itself is capped at </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">1.f</span></em></span><span class="koboSpan" id="kobo.16.1">, so we don't go any smaller than the default particle size. </span><span class="koboSpan" id="kobo.16.2">The scale to elevation ratio here is set to </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">1.5f</span></em></span><span class="koboSpan" id="kobo.18.1">, which is debatably the best value, but is obviously up for tweaking. </span><span class="koboSpan" id="kobo.18.2">All it is is a simple ratio that the supposed </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">elevation</span></em></span><span class="koboSpan" id="kobo.20.1"> of a particle gets multiplied by in order to obtain a scale value, which, when used, should create the illusion of a particle flying towards the camera.</span></p></div><div class="section" title="Lifespan updater"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/><span class="koboSpan" id="kobo.21.1">Lifespan updater</span></h2></div></div></div><p><span class="koboSpan" id="kobo.22.1">Since computer resources, at least during the time of writing this book, are limited, we need to have a good way of disposing of particles when it's time. </span><span class="koboSpan" id="kobo.22.2">One good idea is attaching a lifespan to particles, so that after it's supposed to have expired, the particle is gracefully removed from the population:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">class LifespanUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; lifespans = l_particles-&gt;m_lifespan; 
    auto&amp; maxLifespans = l_particles-&gt;m_maxLifespan; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive;) { 
      lifespans[i] += l_dT; 
      if (lifespans[i] &lt; maxLifespans[i]) { ++i; continue; } 
      l_particles-&gt;Disable(i); 
    } 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.24.1">This is a quite simple little updater. </span><span class="koboSpan" id="kobo.24.2">The delta time is added to each live particle, which then is checked for having exceeded its lifespan. </span><span class="koboSpan" id="kobo.24.3">If it has, the particle is disabled. </span><span class="koboSpan" id="kobo.24.4">Keep in mind that disabling the particle will decrease the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">m_countAlive</span></code><span class="koboSpan" id="kobo.26.1"> data member of a particle container. </span><span class="koboSpan" id="kobo.26.2">For this very reason, we must be careful when incrementing the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">i</span></code><span class="koboSpan" id="kobo.28.1"> local variable, in order to not skip any data in the process.</span></p></div><div class="section" title="Interpolator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/><span class="koboSpan" id="kobo.29.1">Interpolator</span></h2></div></div></div><p><span class="koboSpan" id="kobo.30.1">Tons of particle properties are not going to be static throughout their lifetime. </span><span class="koboSpan" id="kobo.30.2">Take, for example, the particle color. </span><span class="koboSpan" id="kobo.30.3">We may want to fade a particle to complete transparency, or even cycle through a range of colors. </span><span class="koboSpan" id="kobo.30.4">All of this can be achieved by interpolating. </span><span class="koboSpan" id="kobo.30.5">This process is a good candidate for its own updater class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">class Interpolator : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; startColors = l_particles-&gt;m_startColor; 
    auto&amp; currentColors = l_particles-&gt;m_currentColor; 
    auto&amp; finalColors = l_particles-&gt;m_finalColor; 
    auto&amp; lifespans = l_particles-&gt;m_lifespan; 
    auto&amp; maxLifespans = l_particles-&gt;m_maxLifespan; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startColors[i] == finalColors[i]) { continue; } 
      currentColors[i].r = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].r, finalColors[i].r, 
        lifespans[i]); 
      currentColors[i].g = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].g, finalColors[i].g, 
        lifespans[i]); 
      currentColors[i].b = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].b, finalColors[i].b, 
        lifespans[i]); 
      currentColors[i].a = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].a, finalColors[i].a, 
        lifespans[i]); 
    } 
 
    auto&amp; startRotations = l_particles-&gt;m_startRotation; 
    auto&amp; currentRotations = l_particles-&gt;m_currentRotation; 
    auto&amp; finalRotations = l_particles-&gt;m_finalRotation; 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startRotations[i] == finalRotations[i]) { continue; } 
      currentRotations[i] = Utils::Interpolate&lt;float&gt;(0.f, 
        maxLifespans[i], startRotations[i], finalRotations[i], 
        lifespans[i]); 
    } 
 
    auto&amp; startSizes = l_particles-&gt;m_startSize; 
    auto&amp; currentSizes = l_particles-&gt;m_currentSize; 
    auto&amp; finalSizes = l_particles-&gt;m_finalSize; 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startSizes[i] == finalSizes[i]) { continue; } 
      currentSizes[i] = sf::Vector2f( 
        Utils::Interpolate&lt;float&gt;(0.f, maxLifespans[i], 
          startSizes[i].x, finalSizes[i].x, lifespans[i]), 
        Utils::Interpolate&lt;float&gt;(0.f, maxLifespans[i], 
          startSizes[i].y, finalSizes[i].y, lifespans[i])); 
    } 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.32.1">Once again, we have lots of code, but the essence of it is basically the same all throughout. </span><span class="koboSpan" id="kobo.32.2">The </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Interpolate</span></code><span class="koboSpan" id="kobo.34.1"> function, stored within our </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Utilities.h</span></code><span class="koboSpan" id="kobo.36.1"> header, takes in a range of time values throughout which we need interpolation, the range of values that are supposed to be interpolated, and the current time value, which determines the output.</span></p><p><span class="koboSpan" id="kobo.37.1">The interpolated properties are particle colors, rotations, and sizes. </span><span class="koboSpan" id="kobo.37.2">For all three of them, we first check if the starting value is the same as the final value in order to avoid useless computations.</span></p></div><div class="section" title="Force updater"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/><span class="koboSpan" id="kobo.38.1">Force updater</span></h2></div></div></div><p><span class="koboSpan" id="kobo.39.1">During the planning stages of this particle system, we have discussed having different forces in the world that would affect particles. </span><span class="koboSpan" id="kobo.39.2">Outside the possibility of having custom forces, we also want to have basic gravity, so that particles with any sort of elevation begin falling down, provided they have the property of being affected by gravity. </span><span class="koboSpan" id="kobo.39.3">Let us implement an updater that will allow us to do that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.40.1">class ForceUpdater : public BaseUpdater { 
  friend class ParticleSystem; 
public: 
  ForceUpdater() : m_applicators(nullptr) {} 
 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    auto&amp; gravity = l_particles-&gt;m_gravity; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (!gravity[i]) { continue; } 
      velocities[i].z -= Gravity * l_dT; 
    } 
 
    if (!m_applicators) { return; } 
    auto&amp; positions = l_particles-&gt;m_position; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      for (auto&amp; force : *m_applicators) { 
        Force(force.m_center, force.m_force * l_dT, 
          force.m_radius, positions[i], velocities[i]); 
      } 
    } 
  } 
 
  void SetApplicators(ForceApplicatorList* l_list) { 
    m_applicators = l_list; 
  } 
 
  static const float Gravity; 
private: 
  void Force(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius, 
    sf::Vector3f&amp; l_position, sf::Vector3f&amp; l_velocity) 
  { ... </span><span class="koboSpan" id="kobo.40.2">} 
 
  ForceApplicatorList* m_applicators; 
}; 
 
const float ForceUpdater::Gravity = 128.f; 
</span></pre><p><span class="koboSpan" id="kobo.41.1">The first, and arguably the most important, function of this particular updater is applying gravity to all of the particles that need it. </span><span class="koboSpan" id="kobo.41.2">We want to be able to give certain types of particles, such as smoke or fire, the ability to not be affected by the gravitational force, so it's all left up to a flag that can be set. </span><span class="koboSpan" id="kobo.41.3">The actual gravitational force is defined as a static </span><code class="literal"><span class="koboSpan" id="kobo.42.1">const</span></code><span class="koboSpan" id="kobo.43.1"> data member, and set up underneath the class definition.</span></p><p><span class="koboSpan" id="kobo.44.1">Next is the business we have with the force applicators within the world. </span><span class="koboSpan" id="kobo.44.2">If the force updater has no pointer to a force applicator list, there is obviously nothing left to do, so we return from the update method. </span><span class="koboSpan" id="kobo.44.3">Otherwise, a private </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Force() </span></code><span class="koboSpan" id="kobo.46.1">method is invoked with the force's center, the amount of force adjusted for delta time, its radius, and references to the position and velocity of the particle passed in as arguments:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.47.1">void Force(const sf::Vector3f&amp; l_center, 
  const sf::Vector3f&amp; l_force, float l_radius, 
  sf::Vector3f&amp; l_position, sf::Vector3f&amp; l_velocity) 
{ 
  sf::Vector3f from(l_center.x - l_radius, 
    l_center.y - l_radius, l_center.z - l_radius); 
  sf::Vector3f to(l_center.x + l_radius, 
    l_center.y + l_radius, l_center.z + l_radius); 
  if (l_position.x &lt; from.x) { return; } 
  if (l_position.y &lt; from.y) { return; } 
  if (l_position.z &lt; from.z) { return; } 
  if (l_position.x &gt; to.x) { return; } 
  if (l_position.y &gt; to.y) { return; } 
  if (l_position.z &gt; to.z) { return; } 
 
  sf::Vector3f distance = l_center - l_position; 
  sf::Vector3f a_distance = sf::Vector3f(std::abs(distance.x), 
    std::abs(distance.y), std::abs(distance.z)); 
  float magnitude = std::sqrt(std::pow(a_distance.x, 2) + 
    std::pow(a_distance.y, 2) + std::pow(a_distance.z, 2)); 
  sf::Vector3f normal = sf::Vector3f( 
    a_distance.x / magnitude, 
    a_distance.y / magnitude, 
    a_distance.z / magnitude 
  ); 
  sf::Vector3f loss = sf::Vector3f( 
    std::abs(l_force.x) / (l_radius / a_distance.x), 
    std::abs(l_force.y) / (l_radius / a_distance.y), 
    std::abs(l_force.z) / (l_radius / a_distance.z) 
  ); 
  sf::Vector3f applied = sf::Vector3f( 
    (l_force.x &gt; 0 ? </span><span class="koboSpan" id="kobo.47.2">l_force.x - loss.x : l_force.x + loss.x), 
    (l_force.y &gt; 0 ? </span><span class="koboSpan" id="kobo.47.3">l_force.y - loss.y : l_force.y + loss.y), 
    (l_force.z &gt; 0 ? </span><span class="koboSpan" id="kobo.47.4">l_force.z - loss.z : l_force.z + loss.z) 
  ); 
  applied.x *= normal.x; 
  applied.y *= normal.y; 
  applied.z *= normal.z; 
  if (distance.x &lt; 0) { applied.x = -applied.x; } 
  if (distance.y &lt; 0) { applied.y = -applied.y; } 
  if (distance.z &lt; 0) { applied.z = -applied.z; } 
 
  l_velocity += applied; 
} 
</span></pre><p><span class="koboSpan" id="kobo.48.1">After the distance ranges are calculated using the center and radius of the force, the position of the particle is tested to see whether it is within the force-affected area. </span><span class="koboSpan" id="kobo.48.2">Provided all of the tests pass, the distance is calculated between the center of the force and the particle. </span><span class="koboSpan" id="kobo.48.3">It's then used to calculate the absolute distance between them, determine the magnitude of the force, and normalize the vector. </span><span class="koboSpan" id="kobo.48.4">Force loss is calculated based on the radii and distances on all three axes, and subtracted from the actual applied force, which is then multiplied by the normal in order to yield the finished product. </span><span class="koboSpan" id="kobo.48.5">Depending on the distance sign, we can determine which direction the force should be applied to, which is what the next three lines are for. </span><span class="koboSpan" id="kobo.48.6">Finally, after all of that work, we're ready to add the applied force to the particle's velocity.</span></p><p><span class="koboSpan" id="kobo.49.1">With the help of this updater, we can actually apply forces to particles even from outside classes, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">void ParticleSystem::ApplyForce(const sf::Vector3f&amp; l_center, 
  const sf::Vector3f&amp; l_force, float l_radius) 
{ 
  if (m_stateItr == m_container.end()) { return; } 
  auto f = static_cast&lt;ForceUpdater*&gt;(m_updaters["Force"].get()); 
  auto container = m_stateItr-&gt;second.get(); 
  auto&amp; positions = container-&gt;m_position; 
  auto&amp; velocities = container-&gt;m_velocity; 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    f-&gt;Force(l_center, l_force, l_radius, 
      positions[i], velocities[i]); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.51.1">While this isn't as useful as, say, having constant forces inside the world, it can still be used for testing purposes.</span></p></div><div class="section" title="Collision updater"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/><span class="koboSpan" id="kobo.52.1">Collision updater</span></h2></div></div></div><p><span class="koboSpan" id="kobo.53.1">Another important aspect of particles interacting with the world is handling their collisions. </span><span class="koboSpan" id="kobo.53.2">So far, the only real collision we need to worry about is particles hitting the floor; however, actual map collisions could be implemented quite easily with the help of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">class CollisionUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (positions[i].z &gt; 0.f) { continue; } 
      positions[i].z = 0.f; 
      velocities[i].z = 0.f; 
    } 
 
    if (!m_map) { return; } 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (positions[i].z &gt; 0.f) { continue; } 
      ApplyFriction(l_dT, positions[i], velocities[i]); 
    } 
  } 
  void SetMap(Map* l_map) { m_map = l_map; } 
private: 
  void ApplyFriction(float l_dT, sf::Vector3f&amp; l_position, 
    sf::Vector3f&amp; l_velocity) { ... </span><span class="koboSpan" id="kobo.54.2">} 
  Map* m_map; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.55.1">All we have to worry about here is checking whether the position of a particle on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">z </span></em></span><span class="koboSpan" id="kobo.57.1">axis is below zero. </span><span class="koboSpan" id="kobo.57.2">If it is, the position on that axis is reset back to zero, as well as its velocity. </span><span class="koboSpan" id="kobo.57.3">Additionally, if the updater has been provided with a pointer to a map instance, we want to handle particle friction against the map, provided they are touching the ground. </span><span class="koboSpan" id="kobo.57.4">Provided that's the case, the delta time is passed into a private </span><code class="literal"><span class="koboSpan" id="kobo.58.1">ApplyFriction()</span></code><span class="koboSpan" id="kobo.59.1"> method, along with the position and velocity vectors of the particle:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">void ApplyFriction(float l_dT, sf::Vector3f&amp; l_position, 
  sf::Vector3f&amp; l_velocity) 
{ 
  sf::Vector2i tileCoords = sf::Vector2i( 
    static_cast&lt;int&gt;(floor(l_position.x / Sheet::Tile_Size)), 
    static_cast&lt;int&gt;(floor(l_position.y / Sheet::Tile_Size))); 
  auto tile = m_map-&gt;GetTile(tileCoords.x, tileCoords.y, 0); 
  sf::Vector2f friction; 
  if (!tile) { friction = m_map-&gt;GetDefaultTile()-&gt;m_friction; } 
  else { friction = tile-&gt;m_properties-&gt;m_friction; } 
  friction.x *= std::abs(l_velocity.x); 
  friction.y *= std::abs(l_velocity.y); 
  friction *= l_dT; 
  if (l_velocity.x != 0.f &amp;&amp; friction.x != 0.f) { 
    if (std::abs(l_velocity.x) - std::abs(friction.x) &lt; 0.f) { 
      l_velocity.x = 0.f; 
    } else { 
      l_velocity.x += (l_velocity.x &gt; 0.f ? 
        </span><span class="koboSpan" id="kobo.60.2">friction.x * -1.f : friction.x); 
    } 
  } 
 
  if (l_velocity.y != 0.f &amp;&amp; friction.y != 0.f) { 
    if (std::abs(l_velocity.y) - std::abs(friction.y) &lt; 0.f) { 
      l_velocity.y = 0.f; 
    } else { 
      l_velocity.y += (l_velocity.y &gt; 0.f ? 
        </span><span class="koboSpan" id="kobo.60.3">friction.y * -1.f : friction.y); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.61.1">After the tile coordinates a particle is touching are determined, the tile is checked to see whether it exists in the first place. </span><span class="koboSpan" id="kobo.61.2">If it does not, the default friction is used. </span><span class="koboSpan" id="kobo.61.3">Once all of that is sorted out, the velocity </span><span class="strong"><strong><span class="koboSpan" id="kobo.62.1">lost to friction</span></strong></span><span class="koboSpan" id="kobo.63.1"> is calculated, and then multiplied by delta time to get accurate results for the current frame. </span><span class="koboSpan" id="kobo.63.2">Everything else after this point is related to making sure the values being added have the right sign, and don't result in going past absolute zero into the opposite sign domain.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Particle generators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/><span class="koboSpan" id="kobo.1.1">Particle generators</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having all of these updaters really does nothing unless certain base values are generated for the particles. </span><span class="koboSpan" id="kobo.2.2">Whether it is the initial position of a particle, the range of colors, or the name of a texture that gets attached to our flying little data structures, having that initial data set based on some pre-conceived notion is important. </span><span class="koboSpan" id="kobo.2.3">There are quite a few generators we support, not to mention tons of candidates for new generators, and thus new types of particles. </span><span class="koboSpan" id="kobo.2.4">Having said that, let us take a look at a couple of basics that we need to get some basic effects going.</span></p><div class="section" title="Point position"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/><span class="koboSpan" id="kobo.3.1">Point position</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">The simplest generator we can possibly have in this entire system is a point position. </span><span class="koboSpan" id="kobo.4.2">Essentially, it just sets all positions of fed-in particles to a static point in space:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class PointPosition : public BaseGenerator { 
public: 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    for (auto i = l_from; i &lt;= l_to; ++i) {positions[i] = center;} 
  } 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">The center point all particles are positioned at is taken from the emitter. </span><span class="koboSpan" id="kobo.6.2">Its position will always be used to determine where a particle should be spawned.</span></p></div><div class="section" title="Area position"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/><span class="koboSpan" id="kobo.7.1">Area position</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">Setting all particle positions to the same point can get rather boring, not to mention visually odd. </span><span class="koboSpan" id="kobo.8.2">If we're dealing with particles such as smoke or fire, it may make more sense to scatter the particles within a specified area. </span><span class="koboSpan" id="kobo.8.3">This is where </span><code class="literal"><span class="koboSpan" id="kobo.9.1">AreaPosition</span></code><span class="koboSpan" id="kobo.10.1"> comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">class AreaPosition : public BaseGenerator { 
public: 
  AreaPosition() = default; 
  AreaPosition(const sf::Vector3f&amp; l_deviation) 
    : m_deviation(l_deviation) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    auto rangeFrom = sf::Vector3f(center.x - m_deviation.x, 
      center.y - m_deviation.y, center.z - m_deviation.z); 
    auto rangeTo = sf::Vector3f(center.x + m_deviation.x, 
      center.y + m_deviation.y, center.z + m_deviation.z); 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      positions[i] = sf::Vector3f( 
        rand(rangeFrom.x, rangeTo.x), 
        rand(rangeFrom.y, rangeTo.y), 
        rand(rangeFrom.z, rangeTo.z) 
      ); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_deviation.x &gt;&gt; m_deviation.y &gt;&gt; m_deviation.z; 
  } 
private: 
  sf::Vector3f m_deviation; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.12.1">This particular position generator still uses the emitter position as the center point, but also applies a random deviation range to it. </span><span class="koboSpan" id="kobo.12.2">The deviation value can be read directly from the particle file, or simply set through the constructor of this generator.</span></p></div><div class="section" title="Line position"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/><span class="koboSpan" id="kobo.13.1">Line position</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">A slight variation on the area position is a line position. </span><span class="koboSpan" id="kobo.14.2">It works in the same basic way as the area position does, except only for one axis, which is either provided through the constructor or loaded in from the particle file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">enum class LineAxis{ x, y, z }; 
 
class LinePosition : public BaseGenerator { 
public: 
  LinePosition() : m_axis(LineAxis::x), m_deviation(0.f) {} 
  LinePosition(LineAxis l_axis, float l_deviation) 
    : m_axis(l_axis), m_deviation(l_deviation) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      if (m_axis == LineAxis::x) { 
        center.x = rand(center.x - m_deviation, 
          center.x + m_deviation); 
      } else if (m_axis == LineAxis::y) { 
        center.y = rand(center.y - m_deviation, 
          center.y + m_deviation); 
      } else { 
        center.z = rand(center.z - m_deviation, 
          center.z + m_deviation); } 
      positions[i] = center; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    std::string axis; 
    l_stream &gt;&gt; axis &gt;&gt; m_deviation; 
    if (axis == "x") { m_axis = LineAxis::x; } 
    else if (axis == "y") { m_axis = LineAxis::y; } 
    else if (axis == "z") { m_axis = LineAxis::z; } 
    else { std::cout &lt;&lt; "Faulty axis: " &lt;&lt; axis &lt;&lt; std::endl; } 
  } 
private: 
  LineAxis m_axis; 
  float m_deviation; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.16.1">The random deviation here is only applied to one of the axes. </span><span class="koboSpan" id="kobo.16.2">The same effect could arguably be achieved with an area position generator, but it doesn't hurt to have a little variety.</span></p></div><div class="section" title="Particle properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/><span class="koboSpan" id="kobo.17.1">Particle properties</span></h2></div></div></div><p><span class="koboSpan" id="kobo.18.1">Certain properties particles possess would really not call for their own generators. </span><span class="koboSpan" id="kobo.18.2">For example, gravity and blending mode flags for particles could just be pooled to exist within a single type of generator:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">class PropGenerator : public BaseGenerator { 
public: 
  PropGenerator(bool l_gravity = true, bool l_additive = false) 
    : m_gravity(l_gravity), m_additive(l_additive) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; gravity = l_particles-&gt;m_gravity; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      gravity[i] = m_gravity; 
    } 
    auto&amp; additive = l_particles-&gt;m_addBlend; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      additive[i] = m_additive; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    int gravity = 1; 
    int additive = 0; 
    l_stream &gt;&gt; gravity &gt;&gt; additive; 
    m_gravity = (gravity != 0); 
    m_additive = (additive != 0); 
  } 
private: 
  bool m_gravity; 
  bool m_additive; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.20.1">Both the gravity and blending mode flags can, as with all the previous generators, be loaded in from the file, or set through the constructor of the class.</span></p></div><div class="section" title="Random color"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/><span class="koboSpan" id="kobo.21.1">Random color</span></h2></div></div></div><p><span class="koboSpan" id="kobo.22.1">Randomizing the color of all emitted particles may be something one may want to do, whether the random variations are slight for something such as differently shaded water particles, or completely random for a fountain of skittles. </span><span class="koboSpan" id="kobo.22.2">All of that and more can be done by this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">class RandomColor : public BaseGenerator { 
public: 
  RandomColor() = default; 
  RandomColor(const sf::Vector3i&amp; l_from,const sf::Vector3i&amp; l_to) 
    : m_from(l_from), m_to(l_to) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; colors = l_particles-&gt;m_currentColor; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      sf::Color target{ 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.x, m_to.x)), 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.y, m_to.y)), 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.z, m_to.z)), 
        255 
      }; 
      colors[i] = target; 
    } 
  } 
   void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from.x &gt;&gt; m_to.x &gt;&gt; m_from.y &gt;&gt; m_to.y &gt;&gt; 
      m_from.z &gt;&gt; m_to.z; 
  } 
private: 
  sf::Vector3i m_from; 
  sf::Vector3i m_to; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.24.1">The generator stores ranges, which are going to be used to generate random results. </span><span class="koboSpan" id="kobo.24.2">They can either be loaded in from the particle file, or set through the constructor. </span><span class="koboSpan" id="kobo.24.3">Since the ranges can be different for each one of the three color channels, they are randomized separately.</span></p></div><div class="section" title="Color range"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/><span class="koboSpan" id="kobo.25.1">Color range</span></h2></div></div></div><p><span class="koboSpan" id="kobo.26.1">While the random color generator simply assigns the current color of the particle, a color range provides a range of colors that the particle will fade through during its lifespan, thanks to interpolation. </span><span class="koboSpan" id="kobo.26.2">This process is as simple as assigning those values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">class ColorRange : public BaseGenerator { 
public: 
  ColorRange() = default; 
  ColorRange(const sf::Color&amp; l_start, const sf::Color&amp; l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; beginning = l_particles-&gt;m_startColor; 
    auto&amp; current = l_particles-&gt;m_currentColor; 
    auto&amp; ending = l_particles-&gt;m_finalColor; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      beginning[i] = m_start; 
      current[i] = m_start; 
      ending[i] = m_finish; 
    } 
  } 
  void ReadIn(std::stringstream&amp; l_stream) { 
    int s_r = 0, s_g = 0, s_b = 0, s_a = 0; 
    int f_r = 0, f_g = 0, f_b = 0, f_a = 0; 
    l_stream &gt;&gt; s_r &gt;&gt; s_g &gt;&gt; s_b &gt;&gt; s_a; 
    l_stream &gt;&gt; f_r &gt;&gt; f_g &gt;&gt; f_b &gt;&gt; f_a; 
 
    m_start = { 
      static_cast&lt;sf::Uint8&gt;(s_r), static_cast&lt;sf::Uint8&gt;(s_g), 
      static_cast&lt;sf::Uint8&gt;(s_b), static_cast&lt;sf::Uint8&gt;(s_a) 
    }; 
    m_finish = { 
      static_cast&lt;sf::Uint8&gt;(f_r), static_cast&lt;sf::Uint8&gt;(f_g), 
      static_cast&lt;sf::Uint8&gt;(f_b), static_cast&lt;sf::Uint8&gt;(f_a) 
    }; 
  } 
private: 
  sf::Color m_start; 
  sf::Color m_finish; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Just as before, the ranges can be read in from the particle file or set up by using the constructor. </span><span class="koboSpan" id="kobo.28.2">Both the initial and the current colors of a particle are set to match the starting color.</span></p><p><span class="koboSpan" id="kobo.29.1">Note the de-serialization method. </span><span class="koboSpan" id="kobo.29.2">Because we're reading integers from the text file, the variable type must reflect that at first. </span><span class="koboSpan" id="kobo.29.3">After all the values are read in, they're then converted to </span><code class="literal"><span class="koboSpan" id="kobo.30.1">sf::Uint8</span></code><span class="koboSpan" id="kobo.31.1"> and stored as ranges. </span><span class="koboSpan" id="kobo.31.2">This obviously includes the alpha channel, in order to give particles the means of fading out when they're about to de-spawn.</span></p></div><div class="section" title="Random lifespan"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/><span class="koboSpan" id="kobo.32.1">Random lifespan</span></h2></div></div></div><p><span class="koboSpan" id="kobo.33.1">Generating the lifespan for particles is fairly similar to everything else we've done so far, so let's just jump straight into it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">class RandomLifespan : public BaseGenerator { 
public: 
  RandomLifespan() : m_from(0.f), m_to(0.f) {} 
  RandomLifespan(float l_from, float l_to) 
    : m_from(l_from), m_to(l_to) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; lifespans = l_particles-&gt;m_maxLifespan; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      lifespans[i] = rand(m_from, m_to); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from &gt;&gt; m_to; 
  } 
private: 
  float m_from; 
  float m_to; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.35.1">Predictably, lifespans are also stored as ranges, which can be loaded from the particle file or set up by using the constructor. </span><span class="koboSpan" id="kobo.35.2">Afterwards, the life of a particle is randomized within the specified range. </span><span class="koboSpan" id="kobo.35.3">This can provide certain effects with visual variety by eliminating the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">line of death</span></em></span><span class="koboSpan" id="kobo.37.1"> that tends to visually stick out.</span></p></div><div class="section" title="Random size"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/><span class="koboSpan" id="kobo.38.1">Random size</span></h2></div></div></div><p><span class="koboSpan" id="kobo.39.1">Randomizing the particle size is another useful tool to have in our visual arsenal. </span><span class="koboSpan" id="kobo.39.2">Let us take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.40.1">class RandomSize : public BaseGenerator { 
public: 
  RandomSize() : m_from(0), m_to(0) {} 
  RandomSize(int l_from, int l_to): m_from(l_from), m_to(l_to) {} 
 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; sizes = l_particles-&gt;m_currentSize; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      float size = static_cast&lt;float&gt;(rand(m_from, m_to)); 
      sizes[i] = sf::Vector2f(size, size); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from &gt;&gt; m_to; 
  } 
private: 
  int m_from; 
  int m_to; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.41.1">As always, ranges are stored as data members, and can be read in from a file, or set up via the constructor. </span><span class="koboSpan" id="kobo.41.2">The size itself is randomized once, and then applied as the same size for both axes. </span><span class="koboSpan" id="kobo.41.3">As of yet, we have no reason to generate rectangular particles with non-matching dimensions.</span></p></div><div class="section" title="Random velocity"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/><span class="koboSpan" id="kobo.42.1">Random velocity</span></h2></div></div></div><p><span class="koboSpan" id="kobo.43.1">All of the effort we have put into the system so far would literally be at a standstill if we did not give these particles a push from their birth. </span><span class="koboSpan" id="kobo.43.2">Applying random velocity values can achieve just that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.44.1">class RandomVelocity : public BaseGenerator { 
public: 
  RandomVelocity() = default; 
  RandomVelocity(const sf::Vector3f&amp; l_from, 
    const sf::Vector3f&amp; l_to) : m_from(l_from), m_to(l_to) {} 
 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      sf::Vector3f target{ 
        rand(m_from.x, m_to.x), 
        rand(m_from.y, m_to.y), 
        rand(m_from.z, m_to.z) 
      }; 
      velocities[i] = target; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from.x &gt;&gt; m_to.x &gt;&gt; m_from.y &gt;&gt; m_to.y &gt;&gt; 
    m_from.z &gt;&gt; m_to.z; 
  } 
private: 
  sf::Vector3f m_from; 
  sf::Vector3f m_to; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.45.1">Velocities, as covered earlier, work in three dimensions, so that is precisely how we must store them. </span><span class="koboSpan" id="kobo.45.2">Their ranges are either loaded from particle files, or set up through the constructor of this generator. </span><span class="koboSpan" id="kobo.45.3">They are then individually randomized and applied.</span></p></div><div class="section" title="Rotation range"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/><span class="koboSpan" id="kobo.46.1">Rotation range</span></h2></div></div></div><p><span class="koboSpan" id="kobo.47.1">Rotation of particles can be nice for a number of different effects we can think of. </span><span class="koboSpan" id="kobo.47.2">Rotating them slightly over their lifetimes can provide some nice variety, so let us reflect that in this next generator:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">class RotationRange : public BaseGenerator { 
public: 
  RotationRange() : m_start(0.f), m_finish(0.f) {} 
  RotationRange(float l_start, float l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; beginning = l_particles-&gt;m_startRotation; 
    auto&amp; ending = l_particles-&gt;m_finalRotation; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      beginning[i] = m_start; 
      ending[i] = m_finish; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_start &gt;&gt; m_finish; 
  } 
private: 
  float m_start; 
  float m_finish; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.49.1">Since the rotation values are going to be interpolated over the particle's lifetime, we use beginning and ending values to reflect that.</span></p></div><div class="section" title="Size range"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/><span class="koboSpan" id="kobo.50.1">Size range</span></h2></div></div></div><p><span class="koboSpan" id="kobo.51.1">Particle sizes are no different from any other data we have been dealing with so far, so let's take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">class SizeRange : public BaseGenerator { 
public: 
  SizeRange() : m_start(0), m_finish(0) {} 
  SizeRange(float l_start, float l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    if (m_start == m_finish) { 
      auto&amp; sizes = l_particles-&gt;m_currentSize; 
      for (auto i = l_from; i &lt;= l_to; ++i) { 
        sizes[i] = sf::Vector2f(m_start, m_start); 
      } 
    } else { 
      auto&amp; beginning = l_particles-&gt;m_startSize; 
      auto&amp; ending = l_particles-&gt;m_finalSize; 
      for (auto i = l_from; i &lt;= l_to; ++i) { 
        beginning[i] = sf::Vector2f(m_start, m_start); 
        ending[i] = sf::Vector2f(m_finish, m_finish); 
      } 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_start &gt;&gt; m_finish; 
  } 
private: 
  float m_start; 
  float m_finish; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.53.1">The ranges provided to this generator are first checked to see whether they're not equal. </span><span class="koboSpan" id="kobo.53.2">If that is the case, however, we can treat the size of a particle as constant and simply set its current size to it to save the interpolator some work. </span><span class="koboSpan" id="kobo.53.3">Otherwise, the beginning and ending values of the size are filled out.</span></p></div><div class="section" title="Texture generator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/><span class="koboSpan" id="kobo.54.1">Texture generator</span></h2></div></div></div><p><span class="koboSpan" id="kobo.55.1">Last, but definitely not least, we can make our particles about a million times more appealing to the eye by texturing them. </span><span class="koboSpan" id="kobo.55.2">Luckily, our system makes it fairly easy to do at this point. </span><span class="koboSpan" id="kobo.55.3">Let's take a look:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">class TextureGenerator : public BaseGenerator { 
public: 
  TextureGenerator() = default; 
  TextureGenerator(const std::string&amp; l_texture) 
    : m_texture(l_texture) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    if (m_texture.empty()) { return; } 
    TextureManager* manager = l_emitter-&gt; 
      GetParticleSystem()-&gt;GetTextureManager(); 
    if (!manager-&gt;RequireResource(m_texture)) { return; } 
    auto&amp; textures = l_particles-&gt;m_texture; 
    auto&amp; drawables = l_particles-&gt;m_drawable; 
    auto resource = manager-&gt;GetResource(m_texture); 
    auto size = resource-&gt;getSize(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      textures[i] = m_texture; 
      manager-&gt;RequireResource(m_texture); 
      drawables[i].setTexture(resource); 
      drawables[i].setTextureRect(sf::IntRect(0,0,size.x,size.y)); 
    } 
    manager-&gt;ReleaseResource(m_texture); 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream){l_stream &gt;&gt; m_texture;} 
private: 
  std::string m_texture; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.57.1">The string identifier of the texture that needs to be used for the particle type is first either loaded in from a file, or passed in via the constructor. </span><span class="koboSpan" id="kobo.57.2">The string is then checked inside the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">Generate</span></code><span class="koboSpan" id="kobo.59.1"> method in order to make sure it is not empty. </span><span class="koboSpan" id="kobo.59.2">After a pointer to the texture manager is obtained, the resource handle is checked for validity by an attempt to require it.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note9"/><span class="koboSpan" id="kobo.60.1">Note</span></h3><p><span class="koboSpan" id="kobo.61.1">Remember that the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">RequireResource</span></code><span class="koboSpan" id="kobo.63.1"> line actually claims the resource is being used, until it's released.</span></p></div></div><p><span class="koboSpan" id="kobo.64.1">All particles that are being generated are then provided with the resource handle of the texture. </span><span class="koboSpan" id="kobo.64.2">For each particle, the resource is required one more time, and then finally passed into the drawable object of the particle, as well as properly cropped based on the particle size.</span></p><p><span class="koboSpan" id="kobo.65.1">Finally, note the last highlighted line of code inside the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Generate()</span></code><span class="koboSpan" id="kobo.67.1"> method. </span><span class="koboSpan" id="kobo.67.2">Because we have increased the internal resource counter once by requiring it at the very beginning for verification purposes, as well as to obtain a reference to the resource, it must now be released, leaving the internal resource counter with the same value as the number of particles that actually use this texture.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using the particle system"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/><span class="koboSpan" id="kobo.1.1">Using the particle system</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Before we can start using our particle system, some basic setting up is in order. </span><span class="koboSpan" id="kobo.2.2">First, since the particle system is dependent on both states and map loading, their relationship must be set up inside the main </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Game</span></code><span class="koboSpan" id="kobo.4.1"> class like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">void Game::SetUpStates() { 
  ... 
  </span><span class="koboSpan" id="kobo.5.2">m_stateManager-&gt;AddDependent(m_particles.get()); 
  ... 
</span><span class="koboSpan" id="kobo.5.3">} 
 
void Game::SetUpClasses() { 
  ... 
  </span><span class="koboSpan" id="kobo.5.4">m_gameMap.AddLoadee(m_particles.get()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.6.1">Next, let's build an actual type of particle that will be used inside the main menu to make it look spectacular:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">Name MenuFlame 
PointPosition 
SizeRange 32 8 
|ColorRange 255 255 0 100 0 255 255 0 
RandomColor 100 255 100 255 100 255 
RandomLifespan 6 6 
RandomVelocity -10 10 -50 -80 5 10 
RotationRange 0 45 
Texture Flame 
Properties 0 1 
</span></pre><p><span class="koboSpan" id="kobo.8.1">All of these generator parameters have already been covered, so if this format looks questionable, it may be prudent to review the generator section once again.</span></p><p><span class="koboSpan" id="kobo.9.1">Let us add all of these spectacular visuals to the menu state, in order to make it much more impressive than it currently is. </span><span class="koboSpan" id="kobo.9.2">We can start by first setting up a couple of emitters:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">void State_MainMenu::OnCreate() { 
  ... 
  </span><span class="koboSpan" id="kobo.10.2">auto w_size = context-&gt;m_wind-&gt;GetWindowSize(); 
  context-&gt;m_particles-&gt;CreateState(StateType::MainMenu); 
  auto emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    static_cast&lt;float&gt;(w_size.x) / 3.f, 
    static_cast&lt;float&gt;(w_size.y) - 64.f, 
    33.f)); 
  emitter-&gt;SetEmitRate(25); 
  emitter-&gt;SetGenerators("MenuFlame"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    (static_cast&lt;float&gt;(w_size.x) / 3.f) * 2.f, 
    static_cast&lt;float&gt;(w_size.y) - 64.f, 
    33.f)); 
  emitter-&gt;SetEmitRate(25); 
  emitter-&gt;SetGenerators("MenuFlame"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    0.f, 
    static_cast&lt;float&gt;(w_size.y) / 2.f, 
    0.f)); 
  emitter-&gt;SetEmitRate(60); 
  emitter-&gt;SetGenerators("MenuSmoke"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  auto f = ForceApplicator( 
    sf::Vector3f(static_cast&lt;float&gt;(w_size.x) / 2.f, 
      static_cast&lt;float&gt;(w_size.y) / 2.f, 64.f), 
    sf::Vector3f(500.f, 500.f, 500.f), 256.f); 
  context-&gt;m_particles-&gt;AddForce(f); 
} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">Note the highlighted line of the code. </span><span class="koboSpan" id="kobo.11.2">A state must be created inside the particle system in order for us to be able to use it. </span><span class="koboSpan" id="kobo.11.3">Next, two emitters are created. </span><span class="koboSpan" id="kobo.11.4">One is positioned at one third of the width of the screen, and the other, two thirds. </span><span class="koboSpan" id="kobo.11.5">Both of them are added to the system, as well as another emitter, positioned off to the left, which will be emitting smoke. </span><span class="koboSpan" id="kobo.11.6">Finally, a force applicator, positioned right in between the two flames, is added to the particle system as well. </span><span class="koboSpan" id="kobo.11.7">With this thoughtful positioning, we're going to be creating a really good-looking effect that will be showcased shortly.</span></p><p><span class="koboSpan" id="kobo.12.1">Our particles obviously need to be updated in order to function properly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">void State_MainMenu::Update(const sf::Time&amp; l_dT) { 
  m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Update(l_dT.asSeconds()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">Finally, let's draw them on screen:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">void State_MainMenu::Draw() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  for (unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i) { 
    m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Draw( 
      *m_stateMgr-&gt;GetContext()-&gt;m_wind, i); 
  } 
  m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Draw( 
    *m_stateMgr-&gt;GetContext()-&gt;m_wind, -1); 
} 
</span></pre><p><span class="koboSpan" id="kobo.16.1">Since the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Draw()</span></code><span class="koboSpan" id="kobo.18.1"> method takes in the layer we are currently drawing, and for this state layers are irrelevant, we simply iterate over the number of layers, invoking the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">Draw()</span></code><span class="koboSpan" id="kobo.20.1"> method for each one. </span><span class="koboSpan" id="kobo.20.2">At the end, the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Draw()</span></code><span class="koboSpan" id="kobo.22.1"> method is invoked one last time with the argument </span><code class="literal"><span class="koboSpan" id="kobo.23.1">-1</span></code><span class="koboSpan" id="kobo.24.1">, signifying that we want to draw all of the particles that are outside the maximum layer.</span></p><p><span class="koboSpan" id="kobo.25.1">The final result, along with the smoke effect, looks a little like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.26.1"><img src="graphics/image_03_010.jpg" alt="Using the particle system"/></span></div><p><span class="koboSpan" id="kobo.27.1">This is far from showcasing what the particle system can really do. </span><span class="koboSpan" id="kobo.27.2">The code in this chapter includes examples that exist within the game state, and can be easily found by compiling the project and simply taking a stroll through the scenery.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">There may have been quite a bit to take in, but if you are here, congratulations! </span><span class="koboSpan" id="kobo.2.2">With some careful architecting, calculated decisions, and a dash of taste, we have not only produced a particle system that makes the game look ten times better, but also formed the bedrock of knowledge that serves as a stepping stone towards better design, and increased performance.</span></p><p><span class="koboSpan" id="kobo.3.1">In the next few chapters, we are going to be covering the fundamentals of sculpting your own tools for actually designing the game we are working with, as well as its assets. </span><span class="koboSpan" id="kobo.3.2">See you there!</span></p></div></div></div></body></html>