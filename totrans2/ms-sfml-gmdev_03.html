<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3.  Make It Rain! - Building a Particle System </h1></div></div></div><p>Having the right amount of interactivity in any given game is incredibly important. Whether it amuses the player by having their consequences start chain reactions that eventually impact their state, or it simply means that the controls and input management feel just right, one cannot deny that this is one of the few things that can either make or break a game. While the latter is quite important, it's not the smooth navigation of menus that draw most gamers in, which is why in this chapter we are going to be focusing on environmental interactions, as well as stylization through the means of particle systems.</p><p>In this chapter, we're going to be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Benefits of the <strong>Structure of Arrays</strong> storage pattern</li><li class="listitem" style="list-style-type: disc">Architecture and implementation of a flexible particle system</li><li class="listitem" style="list-style-type: disc">Creation of different types of generator and updater objects that allow a wide variety of effects to be created</li></ul></div><p>There is quite a bit to learn, so let us not waste any time and dive right in!</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Use of copyrighted resources</h1></div></div></div><p>As always, let us begin by acknowledging all of the generous artists out there, who make all of this possible by providing assets under incredibly flexible licenses:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>misc png</em> by <em>dbszabo1</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="http://dbszabo1.deviantart.com/art/misc-png-316228902">http://dbszabo1.deviantart.com/art/misc-png-316228902</a></li><li class="listitem" style="list-style-type: disc"><em>Jillcreation-overlay-cloud</em> by <em>Juan Story</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="http://www.effecthub.com/item/5358">http://www.effecthub.com/item/5358</a></li><li class="listitem" style="list-style-type: disc"><em>[LPC] Leaf Recolor</em> by <em>William.Thompsonj</em> under the <strong>CC-BY-SA 3.0</strong> and <strong>GPL 3.0</strong> licenses: <a class="ulink" href="http://opengameart.org/content/lpc-leaf-recolor">http://opengameart.org/content/lpc-leaf-recolor</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Particle system basics</h1></div></div></div><p>There are quite a few things we first need to cover in order to get to the more meaty parts of implementing the particle system. Understanding certain concepts is key to making our system work as intended, starting with the way data is stored.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Array of structs versus struct of arrays</h2></div></div></div><p>It may be tempting at first to simply stick all of the data a particle has into a single class, give it some custom methods for handling certain situations, and store all of these objects in some generic container, as shown here:</p><div><img src="img/image_03_001.jpg" alt="Array of structs versus struct of arrays"/></div><p>While it's certainly easier this way, it doesn't help with performance at all. Keep in mind that we're probably going to be dealing with thousands, if not tens of thousands of instances of particles, all of which need to be updated in a variety of different ways. A simple update loop that works with particles may end up making the cache look like this:</p><div><img src="img/image_03_002.jpg" alt="Array of structs versus struct of arrays"/></div><p>This is terrible as far as performance is concerned, because if we only need to work with positions, that means all of the additional space in the cache that could be used to store positions of other particles now holds useless data that will not be used at all, at least not now. In turn, when it's time to update another particle and its position is requested, it will most likely not be found inside the cache, resulting in a cache miss and time wasted.</p><p>A much better scenario would look like this:</p><div><img src="img/image_03_003.jpg" alt="Array of structs versus struct of arrays"/></div><p>This is much better in terms of performance, as all of the data that exists in the cache is guaranteed to be used. How do we achieve such a result? By storing different particle properties in their own containers, where the memory is ensured to be contiguous, as shown here:</p><pre class="programlisting">struct S{ 
  int m_x[50]; 
  int m_y[50]; 
  std::string m_name[50]; 
  ... 
}; 
</pre><p>Storage, however, isn't everything. We must also make sure that whenever we are working with structures such as this, only the relevant and necessary data is being used. That part, however, will be addressed later down the line.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Storing particles</h2></div></div></div><p>With the key concept out of the way, let us take a look at how particles can be stored using the <strong>SoA</strong> pattern:</p><pre class="programlisting">class ParticleContainer { 
public: 
  ... 
  const static size_t Max_Particles = 3000; 
  sf::Vector3f m_position[Max_Particles]; 
  sf::Vector3f m_velocity[Max_Particles]; 
  sf::Vector3f m_acceleration[Max_Particles]; 
  sf::Vector2f m_startSize[Max_Particles]; 
  sf::Vector2f m_currentSize[Max_Particles]; 
  sf::Vector2f m_finalSize[Max_Particles]; 
  sf::Color m_startColor[Max_Particles]; 
  sf::Color m_currentColor[Max_Particles]; 
  sf::Color m_finalColor[Max_Particles]; 
  std::string m_texture[Max_Particles]; 
  sf::RectangleShape m_drawable[Max_Particles]; 
  float m_startRotation[Max_Particles]; 
  float m_currentRotation[Max_Particles]; 
  float m_finalRotation[Max_Particles]; 
  float m_lifespan[Max_Particles]; 
  float m_maxLifespan[Max_Particles]; 
  bool m_gravity[Max_Particles]; 
  bool m_addBlend[Max_Particles]; 
  bool m_alive[Max_Particles]; 
 
  size_t m_countAlive; 
  TextureManager* m_textureManager; 
protected: 
  ... 
}; 
</pre><p>There are a couple of ways particle properties can be stored and accounted for. Here, we're using C-style arrays along with a static constant that denotes their sizes. All of these properties, as well as their purposes, will be covered in later segments of the chapter.</p><p>A few extra things that are beneficial to keep track of here are the count of particles that are still alive and a pointer to the texture manager, since some of these suckers may be using textures that need to be grabbed and released. They are, of course, set up properly inside the constructor:</p><pre class="programlisting">ParticleContainer(TextureManager* l_textureManager) 
  : m_textureManager(l_textureManager), m_countAlive(0) 
{ Reset(); } 
 
~ParticleContainer(){ 
  for (size_t i = 0; i &lt; Max_Particles; ++i){ 
    if (m_texture[i].empty()) { continue; } 
    m_textureManager-&gt;ReleaseResource(m_texture[i]); 
  } 
} 
</pre><p>The destructor of this container class has a fairly simple job. All it needs to do, in order to not leave any loose ends, is loop through every particle stored and check if it is using a texture, which is just a string identifier. If it is, the texture is released.</p><p>Another fairly important task that was left up to the constructor is resetting all of the allocated memory for the particles. This is left to the <code class="literal">Reset()</code> method:</p><pre class="programlisting">void Reset(){ 
  for (size_t i = 0; i &lt; Max_Particles; ++i) { ResetParticle(i); } 
  m_countAlive = 0; 
} 
</pre><p>The <code class="literal">ResetParticle</code> private method is invoked for each single particle in the list. It is responsible for actually zeroing all of the data out to make sure the next particle that gets the same identifier will not possess certain properties carried over from the previous particle that owned it.</p><p>In order to actually manage the SoA structure efficiently, we're going to be using these two key methods for enabling and disabling a particular ID:</p><pre class="programlisting">void Enable(size_t l_id){ 
  if (m_countAlive &gt;= Max_Particles) { return; } 
  m_alive[l_id] = true; 
  Swap(l_id, m_countAlive); 
  ++m_countAlive; 
} 
 
void Disable(size_t l_id){ 
  if (!m_countAlive) { return; } 
  ResetParticle(l_id); 
  Swap(l_id, m_countAlive - 1); 
  --m_countAlive; 
} 
</pre><p>A sanity check is performed first in order to make sure we're not enabling any particles if the maximum amount already exists, or disabling any if there are no active ones. Enabling a particle simply requires its <em>alive</em> flag to be set to <em>true</em>, while disabling calls for a complete reset. All of the data stored at <code class="literal">l_id</code> is then swapped with either the element after the last active particle when enabling in order to make it last, or with the very last particle when disabling. Consider the following illustration:</p><div><img src="img/image_03_004.jpg" alt="Storing particles"/></div><p>Although it covers the scenario of disabling a particle, the same basic principle holds up for enabling as well.</p><p>Actual data swapping isn't a very complicated process:</p><pre class="programlisting">void Swap(size_t l_first, size_t l_second) { 
  std::swap(m_position[l_first], m_position[l_second]); 
  std::swap(m_velocity[l_first], m_velocity[l_second]); 
  std::swap(m_acceleration[l_first], m_acceleration[l_second]); 
  std::swap(m_startSize[l_first], m_startSize[l_second]); 
  ... 
} 
</pre><p>It simply invokes <code class="literal">std::swap</code> on every single particle property at the <code class="literal">l_first</code> and <code class="literal">l_second</code> indices.</p><p>Finally, we get to the actual reset code for a single particle:</p><pre class="programlisting">void ResetParticle(size_t l_id){ 
  m_alive[l_id] = false; 
  m_gravity[l_id] = false; 
  m_addBlend[l_id] = false; 
  m_lifespan[l_id] = 0.f; 
  m_maxLifespan[l_id] = 0.f; 
  m_position[l_id] = { 0.f, 0.f, 0.f }; 
  m_velocity[l_id] = { 0.f, 0.f, 0.f }; 
  m_acceleration[l_id] = { 0.f, 0.f, 0.f }; 
  m_startRotation[l_id] = 0.f; 
  m_currentRotation[l_id] = 0.f; 
  m_finalRotation[l_id] = 0.f; 
  m_startSize[l_id] = { 0.f, 0.f }; 
  m_currentSize[l_id] = { 0.f, 0.f }; 
  m_finalSize[l_id] = { 0.f, 0.f }; 
  m_startColor[l_id] = { 0, 0, 0, 0 }; 
  m_currentColor[l_id] = { 0, 0, 0, 0 }; 
  m_finalColor[l_id] = { 0, 0, 0, 0 }; 
  if (!m_texture[l_id].empty()){ 
    m_textureManager-&gt;ReleaseResource(m_texture[l_id]); 
    m_texture[l_id].clear(); 
    m_drawable[l_id].setTexture(nullptr); 
  } 
} 
</pre><p>Predictably, every single particle parameter is reset to an appropriate default value at the provided index. If the texture identifier is not empty, the resource also gets released, since it is no longer needed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Particle system architecture</h2></div></div></div><p>In order to cater for the way particles are stored and still provide a means of updating, interaction, and flexibility to the system, we must carefully address its architecture. Let's begin by breaking it down into smaller parts that will be easier to manage on their own:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Emitter</strong>:an object that exists in the world and acts as a particle spawner. It has access to a list of generators that each emitted particle is fed through before it gets spawned.</li><li class="listitem" style="list-style-type: disc"><strong>Generator</strong>:this belongs to a list of other similar objects that have direct access to particle properties and modify them according to their own, pre-defined rules in order to achieve a certain look.</li><li class="listitem" style="list-style-type: disc"><strong>Updater</strong>:one of many objects owned by the particle system, and designed to only use the data it needs for a specific task, which is always related to updating particles in a specific way.</li><li class="listitem" style="list-style-type: disc"><strong>Force applicator</strong>:a small data structure, used by one of the updaters in order to create <em>forces</em> in the world, which physically interact with the particles.</li></ul></div><p>Let us take some time and look at each individual piece in more depth.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec0"/>The generator</h3></div></div></div><p>A generator within this context is going to act as a stamp in a way. It will take in a range of particles, the properties of which are going to be adjusted according to the type of generator that received them. Consider this illustration:</p><div><img src="img/image_03_005.jpg" alt="The generator"/></div><p>A specific generator can be almost considered as a stamp of sorts. Some of the properties it imprints on a particle can be random, while others are constant. Either way, once a few particles are fed into it, they come out <em>stamped</em> with the properties that the generator is responsible for.</p><p>All the generators we're going to be implementing need to be generalized, which is why they all must obey by the provided interface:</p><pre class="programlisting">class BaseGenerator { 
public: 
  virtual ~BaseGenerator() {} 
  virtual void Generate(Emitter* l_emitter, 
    ParticleContainer* l_particles, size_t l_from, size_t l_to)=0; 
  friend std::stringstream&amp; operator &gt;&gt; ( 
    std::stringstream&amp; l_stream, BaseGenerator&amp; b) 
  { 
    b.ReadIn(l_stream); 
    return l_stream; 
  } 
 
  virtual void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</pre><p>First, the <code class="literal">Generate()</code> method needs some explaining. It takes in a pointer to the <code class="literal">Emitter</code> instance that owns it. It also takes a pointer to the particle container it's going to be working with. The last two arguments are particle IDs that form a range, which represents particles that will be enabled inside the container. The range itself is going to be calculated inside the emitter that owns the generator.</p><p>This base class also allows derivative generators to implement how their properties are loaded from files. This will be important later, when we start actually creating different types of generators.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec1"/>The emitter</h3></div></div></div><p>As mentioned previously, an emitter is simply a class that owns a list of generators in order to spawn a specific type of particle. It can be positioned within the world, and is responsible for calculating particle ID ranges for emission by keeping track of its emit rate. Let's take a look at the header of the <code class="literal">Emitter</code> class:</p><pre class="programlisting">class Emitter { 
public: 
  Emitter(const sf::Vector3f&amp; l_position,int l_maxParticles = -1); 
  void Update(float l_dT, ParticleContainer* l_particles); 
  void SetPosition(const sf::Vector3f&amp; l_position); 
  sf::Vector3f GetPosition() const; 
  size_t GetEmitRate() const; 
  void SetEmitRate(size_t l_nPerSecond); 
  void SetParticleSystem(ParticleSystem* l_system); 
  void SetGenerators(const std::string&amp; l_generators); 
  std::string GetGenerators() const; 
  ParticleSystem* GetParticleSystem() const; 
private: 
  std::string m_generators; 
  size_t m_emitRate; 
  int m_maxParticles; 
  sf::Vector3f m_position; 
  float m_accumulator; 
  ParticleSystem* m_system; 
}; 
</pre><p>As you can see, this class doesn't actually store a list of generator instances. Instead, it stores a string identifier that will be used to obtain the list for a specific style of particles from the particle system.</p><p>All of the setters and getters in this class are simple one-line methods that perform exactly as advertised, so we won't be covering them.</p><p>Aside all of the other obvious data members, it stores a floating point value named <code class="literal">m_accumulator</code>, which is going to be used in conjunction with the emit rate. We'll go over it more very shortly. It also stores an <code class="literal">m_maxParticles</code> data member in order to know if particles should be emitted indefinitely, or if the emitter needs to stop after a certain amount have been created.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec0"/>Implementing emitter</h4></div></div></div><p>Let's start with the basics of simply initializing all data members to their default values:</p><pre class="programlisting">Emitter::Emitter(const sf::Vector3f&amp; l_position, 
  int l_maxParticles) : m_position(l_position),  
  m_maxParticles(l_maxParticles), m_emitRate(0), 
  m_accumulator(0.f), m_system(nullptr){} 
</pre><p>The only real method of importance in this class is obviously the <code class="literal">Update()</code> method. It's responsible for actually doing all of the heavy lifting when it comes to particle emission:</p><pre class="programlisting">void Emitter::Update(float l_dT, ParticleContainer* l_particles){ 
  if (m_generators.empty()) { return; } 
  auto generatorList = m_system-&gt;GetGenerators(m_generators); 
  if (!generatorList) { return; } 
  m_accumulator += l_dT * m_emitRate; 
  if (m_accumulator &lt; 1.f) { return; } 
  auto num_particles = static_cast&lt;int&gt;(m_accumulator); 
  m_accumulator -= num_particles; 
  if (m_maxParticles != -1) { 
    if (num_particles &gt; m_maxParticles) { 
      num_particles = m_maxParticles; 
      m_maxParticles = 0; 
    } 
    else { m_maxParticles -= num_particles; } 
  } 
  size_t from = l_particles-&gt;m_countAlive; 
  size_t to = (l_particles-&gt;m_countAlive + num_particles &gt; 
    l_particles-&gt;Max_Particles ? l_particles-&gt;Max_Particles - 1 
    : l_particles-&gt;m_countAlive + num_particles - 1); 
 
  for (auto&amp; generator : *generatorList){ 
    generator-&gt;Generate(this, l_particles, from, to); 
  } 
  for (auto i = from; i &lt;= to; ++i){ l_particles-&gt;Enable(i); } 
  if (!m_maxParticles) { m_system-&gt;RemoveEmitter(this); } 
} 
</pre><p>Naturally, the updating is not going to happen if either the generator identifier is empty, or we were unable to obtain the list of generators from the particle system. Provided that isn't the case, the <code class="literal">m_accumulator</code> data member is added to based on the emit rate and <strong>delta time</strong>. It holds the total number of particles that have yet to be emitted. Since we obviously can't emit half of a particle, or any other fraction for that matter, the accumulator data member is checked to see whether it's less than one. If that's the case, there is nothing to emit/update.</p><p>The number of particles to be emitted is then calculated by simply converting the accumulator value to an integer. It is then subtracted from the accumulator, which retains whatever fraction of a particle is left for the next tick.</p><p>The way we know an emitter should keep on spitting particles out indefinitely is if its <code class="literal">m_maxParticles</code> data member is set to <code class="literal">-1</code>. If it isn't, the number of particles to be emitted this tick is checked for not having exceeded the limit.</p><p>Finally, we get to the interesting part. First, the range of IDs that will be brought back to life is calculated, making sure it doesn't go beyond the maximum number of particles allowed. The generator list for the type of particle the emitter is spitting out is then iterated over, with pointers to the current emitter, and the particle list being passed into their <code class="literal">Generate()</code> methods, alongside the calculated ranges. The range of particles is then iterated over and re-enabled to be displayed again, and the emitter is checked to see if it needs to be removed, should the <code class="literal">m_maxParticles</code> data member reach zero.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec2"/>The updater</h3></div></div></div><p>In order to breathe life into our particle system, we must constantly keep it updated. Keeping performance in mind, we must stay true to the SoA pattern and only work with the data that is absolutely necessary for a particular scenario, as shown here:</p><div><img src="img/image_03_006.jpg" alt="The updater"/></div><p>With that in mind, a very basic interface for all updaters can be put together, looking something like this:</p><pre class="programlisting">class BaseUpdater { 
public: 
  virtual ~BaseUpdater() {} 
  virtual void Update(float l_dT, 
    ParticleContainer* l_particles) = 0; 
}; 
</pre><p>All updaters should ever care about, as you can see, is the delta time and having a pointer to the particle container they are operating on. There is no need to provide it with ranges, as it will be operating on all <em>alive</em> particles.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec3"/>Force applicators</h3></div></div></div><p>Because we don't want our character to be running around a static, dead environment, some interactivity between events and particles is required. This relationship is established via the means of forces, which impact the kinematic states of particles within reach, as shown here:</p><div><img src="img/image_03_007.jpg" alt="Force applicators"/></div><p>Force applicators are not fundamental to particle systems. All we need to do in order to generalize them is store some data, and let the appropriate updater(s) take care of the logic. Having said that, let us take a look at what we need to store:</p><pre class="programlisting">struct ForceApplicator { 
  ForceApplicator(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius) 
    : m_center(l_center), m_force(l_force), m_radius(l_radius){} 
  sf::Vector3f m_center; 
  sf::Vector3f m_force; 
  float m_radius; 
}; 
</pre><p>Forces can be positioned in the world, so their centers need to be stored. Additionally, a radius of the force is also necessary, in order to figure out the area of impact. Lastly, there can be no impact without first knowing how strong it is. This is where <code class="literal">m_force</code> comes in, by allowing force to be defined in all three axes.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Building the particle system class</h1></div></div></div><p>With all of the building blocks in place, it's time to actually build the particle system class. Let's start with some type definitions:</p><pre class="programlisting">using Updaters = std::unordered_map&lt;std::string, 
  std::unique_ptr&lt;BaseUpdater&gt;&gt;; 
using EmitterList = std::vector&lt;std::unique_ptr&lt;Emitter&gt;&gt;; 
using Emitters = std::unordered_map&lt;StateType, EmitterList&gt;; 
using GeneratorList = std::vector&lt;std::unique_ptr&lt;BaseGenerator&gt;&gt;; 
using Generators = std::unordered_map&lt;std::string,GeneratorList&gt;; 
using RemovedEmitters = std::vector&lt;Emitter*&gt;; 
using Particles = std::unordered_map&lt;StateType, 
  std::unique_ptr&lt;ParticleContainer&gt;&gt;; 
using ForceApplicatorList = std::vector&lt;ForceApplicator&gt;; 
using ForceApplicators = std::unordered_map&lt;StateType, 
  ForceApplicatorList&gt;; 
 
using GeneratorFactory = std::unordered_map&lt;std::string, 
  std::function&lt;BaseGenerator*(void)&gt;&gt;; 
</pre><p>In order to access any updater we want, we can map them to <code class="literal">string</code> identifiers. While the updaters aren't state-specific, emitters are. Their lists have to be associated with specific states in order to maintain particles across the entire application. Generators, just like updaters, aren't unique to any particular state, and we want to be able to access them via a string identifier from <code class="literal">Emitter</code> classes. Speaking of which, as evident from the code we've already covered, emitters can request removal of themselves in case they should stop emitting particles. Since that happens during the update cycle while the class is still in use, a separate list of emitter pointers must be kept for later removal.</p><p>Particles themselves are obviously stored within the designated <code class="literal">ParticleContainer</code> class, but these containers can, obviously, be possessed by different states. A similar idea applies as before, where we mapped state types to different particle containers in order to maintain application-wide particle support. The same exact principle also applies to force applicators.</p><p>The last data type we have should be a dead giveaway for the fact that we're going to be using the factory design pattern for producing different types of particle generator. These types will also be tied to string identifiers.</p><p>With all of that in mind, it's time to discuss how the <code class="literal">ParticleSystem</code> class can be implemented, starting with its header:</p><pre class="programlisting">class ParticleSystem : public FileLoader, public StateDependent, 
  public MapLoadee 
{ 
public: 
  ParticleSystem(StateManager* l_stateManager, 
    TextureManager* l_textureMgr, RandomGenerator* l_rand, 
    Map* l_map); 
  void AddEmitter(std::unique_ptr&lt;Emitter&gt; l_emitter, 
    const StateType&amp; l_state = StateType(0)); 
  void AddForce(ForceApplicator l_force, 
    const StateType&amp; l_state = StateType(0)); 
  void RemoveEmitter(Emitter* l_emitter); 
 
  GeneratorList* GetGenerators(const std::string&amp; l_name); 
 
  TextureManager* GetTextureManager() const; 
  RandomGenerator* GetRand() const; 
 
  void CreateState(const StateType&amp; l_state); 
  void ChangeState(const StateType&amp; l_state); 
  void RemoveState(const StateType&amp; l_state); 
 
  void ReadMapLine(const std::string&amp; l_type, 
    std::stringstream&amp; l_stream); 
 
  void Update(float l_dT); 
  void ApplyForce(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius); 
  void Draw(Window* l_window, int l_elevation); 
private: 
  bool ProcessLine(std::stringstream&amp; l_stream); 
  void ResetForNextFile(); 
 
  template&lt;class T&gt; 
  void RegisterGenerator(const std::string&amp; l_name) { ... } 
 
  std::string m_loadingGenerator; 
  Particles m_container; 
  Particles::iterator m_stateItr; 
  Emitters::iterator m_emitterItr; 
  Updaters m_updaters; 
  Emitters m_emitters; 
  Generators m_generators; 
  GeneratorFactory m_factory; 
  ForceApplicators m_forces; 
  RemovedEmitters m_removedEmitters; 
  TextureManager* m_textureMgr; 
  RandomGenerator* m_rand; 
  Map* m_map; 
}; 
</pre><p>First, let us examine the inheritance subtleties of this class. Because we are going to have properties of particles saved inside text files, inheritance from <code class="literal">FileLoader</code> is useful, not to mention we get to offload the work to a separate thread. Also, recall that different states will need to be provided access to our particle system, which means the particle manager must implement methods for adding, changing, and removing states. Lastly, keep in mind that particle emitters and the different forces that impact them may be something game maps contain, so we're also inheriting from the <code class="literal">MapLoadee</code> class.</p><p>The class itself obviously needs access to the texture manager, a pointer to which is later passed down to the classes that need it. The same is true for the random number generator, as well as a pointer to the map instance.</p><p>Lastly, note the two highlighted data members of this class, which are both iterators. These are kept around for easier access to data that is state-specific while updating/rendering particles.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Implementing the particle system</h2></div></div></div><p>Let's start by taking a look at the constructor of this class:</p><pre class="programlisting">ParticleSystem::ParticleSystem(StateManager* l_stateManager, 
  TextureManager* l_textureManager, RandomGenerator* l_rand, 
  Map* l_map) 
  : m_stateManager(l_stateManager),m_textureMgr(l_textureManager), 
  m_rand(l_rand), m_map(l_map) 
{ 
  m_updaters.emplace("Lifespan", 
    std::make_unique&lt;LifespanUpdater&gt;()); 
  ... 
  RegisterGenerator&lt;PointPosition&gt;("PointPosition"); 
  ... 
} 
</pre><p>Outside the initializer list that performs all of the data member set-up duties, there is only one other purpose for the constructor here: setting up all of the updaters and generator types. The code we have above is heavily abridged, but the idea remains the same. All of the updaters we want to use are inserted into their container with the appropriate string identifier attached. On the generator side, we invoke a private template method that ties a specific type of a generator to a string identifier. Once again, we are using the factory pattern here.</p><p>Adding emitter objects to our particle system is relatively straightforward:</p><pre class="programlisting">void ParticleSystem::AddEmitter( 
  std::unique_ptr&lt;Emitter&gt; l_emitter, const StateType&amp; l_state) 
{ 
  l_emitter-&gt;SetParticleSystem(this); 
  if (!GetGenerators(l_emitter-&gt;GetGenerators())) {  
    return;  
  } 
  if (l_state == StateType(0)) { 
    if (m_emitterItr == m_emitters.end()) { return; } 
    m_emitterItr-&gt;second.emplace_back(std::move(l_emitter)); 
    return; 
  } 
  auto itr = m_emitters.find(l_state); 
  if (itr == m_emitters.end()) { return; } 
  itr-&gt;second.emplace_back(std::move(l_emitter)); 
} 
</pre><p>First, the emitter is provided with a pointer to the particle system for later access. We then check if the emitter's generator list name is valid. It's pointless to have an emitter that is going to be spawning <em>empty</em> particles.</p><p>As evident from the class header, a default value to the second argument of this method is provided. This gives us a nice way to differentiate whether a user of this class wants to add an emitter to a specific state, or just the current state that is selected. Both of these possibilities are then handled in the remaining chunk of the code.</p><p>Force applicators are dealt with in a very similar fashion:</p><pre class="programlisting">void ParticleSystem::AddForce(ForceApplicator l_force, 
  const StateType&amp; l_state) 
{ 
  if (l_state == StateType(0)) { 
    if (m_stateItr == m_container.end()) { return; } 
    m_forces[m_currentState].emplace_back(l_force); 
    return; 
  } 
  auto itr = m_forces.find(l_state); 
  if(itr == m_forces.end()) { return; } 
  itr-&gt;second.emplace_back(l_force); 
} 
</pre><p>Once again, the second argument has a default value, so we handle both the possibilities before attempting to insert the force applicator data inside the appropriate container.</p><p>Removal of emitters, as mentioned in the data type section, has two stages. The first stage is simply putting a pointer to the emitter in a designated list:</p><pre class="programlisting">void ParticleSystem::RemoveEmitter(Emitter* l_emitter) { 
  m_removedEmitters.push_back(l_emitter); 
} 
</pre><p>The actual removal is handled elsewhere. We will be covering that shortly.</p><p>Obtaining the generator list is important for the emission process, so naturally, we must have a method for that as well:</p><pre class="programlisting">GeneratorList* ParticleSystem::GetGenerators( 
  const std::string&amp; l_name) 
{ 
  auto&amp; itr = m_generators.find(l_name); 
  if (itr == m_generators.end()) { 
    return nullptr; 
  } 
  return &amp;itr-&gt;second; 
} 
</pre><p>Now, we stumble upon the state-dependent part of the particle system, starting with state creation:</p><pre class="programlisting">void ParticleSystem::CreateState(const StateType&amp; l_state) { 
  if (m_container.find(l_state) != m_container.end()) { return; } 
  m_container.emplace(l_state, 
    std::make_unique&lt;ParticleContainer&gt;(m_textureMgr)); 
  m_emitters.emplace(l_state, EmitterList()); 
  m_forces.emplace(l_state, ForceApplicatorList()); 
  ChangeState(l_state); 
} 
</pre><p>First, a determination needs to be made whether the state being created doesn't already, for some reason, have its own particle container allocated. If it doesn't, one is created and inserted into the state's particle container, as well as an emitter list, and a force applicator list for that same state.</p><div><div><h3 class="title"><a id="note6"/>Note</h3><p>The <code class="literal">CreateState()</code> method of the <code class="literal">StateDependent</code> class is the only piece of code that needs to be invoked manually, in case certain states don't need to utilize that particular state dependent resource.</p></div></div><p>Next, let's discuss how a state can be changed inside a particle system:</p><pre class="programlisting">void ParticleSystem::ChangeState(const StateType&amp; l_state) { 
  SetState(l_state); 
  m_stateItr = m_container.find(m_currentState); 
  m_emitterItr = m_emitters.find(m_currentState); 
 
  auto c = static_cast&lt;CollisionUpdater*&gt;( 
    m_updaters["Collision"].get()); 
  if (l_state == StateType::Game) { c-&gt;SetMap(m_map); } 
  else { c-&gt;SetMap(nullptr); } 
  auto f = static_cast&lt;ForceUpdater*&gt;(m_updaters["Force"].get()); 
  auto&amp; forceItr = m_forces.find(m_currentState); 
  if (forceItr == m_forces.end()) { 
    f-&gt;SetApplicators(nullptr); return; 
  } 
  f-&gt;SetApplicators(&amp;forceItr-&gt;second); 
} 
</pre><p>After a private method for changing its own internal state is invoked, the data member that holds an iterator to the particles of the current state is updated. The same exact thing is done to the emitter iterator.</p><p>The next few lines of code may not make much sense within this context, since we have not worked on any updaters yet, but let us cover them anyway. Further down the line, we are going to have updaters for particle collisions and forces. As far as collisions go, the updater only needs to have a pointer to the game map, presuming the current state is <code class="literal">Game</code>. <code class="literal">ForceUpdater</code>, on the other hand, needs to have access to a list of force applicators for the current state. Both of these types of updater are accommodated here.</p><p>Let's wrap up the state modification subject by taking a look at what happens inside a particle system when a state is removed:</p><pre class="programlisting">void ParticleSystem::RemoveState(const StateType&amp; l_state) { 
  if (m_stateItr-&gt;first == l_state) { 
    m_stateItr = m_container.end(); 
    m_emitterItr = m_emitters.end(); 
  } 
  m_emitters.erase(l_state); 
  m_forces.erase(l_state); 
  m_container.erase(l_state); 
} 
</pre><p>All we do here is erase data from state-bound containers. Since there are two iterator data members kept around, those too must be reset in case the state being removed matches the current state. Because of the way our state system works, and the order of <code class="literal">ChangeState</code> and <code class="literal">RemoveState</code>, we don't need to worry about iterators being invalidated.</p><p>Our particle system will definitely have plenty of data to load from text files, which is why it inherits from a file loader class. Let us take a look at the method that every single line stream will be fed into:</p><pre class="programlisting">bool ParticleSystem::ProcessLine(std::stringstream&amp; l_stream) { 
  std::string type; 
  l_stream &gt;&gt; type; 
  if (type == "Name") { 
    if (!(l_stream &gt;&gt; m_loadingGenerator)) { return false; } 
    auto generators = GetGenerators(m_loadingGenerator); 
    if (generators) { return false; } 
  } else { 
    if (m_loadingGenerator.empty()) { return false; } 
    auto itr = m_factory.find(type); 
    if (itr == m_factory.end()) { return true; } 
    std::unique_ptr&lt;BaseGenerator&gt; generator(itr-&gt;second()); 
    l_stream &gt;&gt; *generator; 
    m_generators[m_loadingGenerator].emplace_back( 
      std::move(generator)); 
  } 
  return true; 
} 
</pre><p>The first string of each line, later referred to as type, is extracted. If we have a name, another string is attempted to be extracted, and later checked for matches inside the generator list, in order to avoid duplicates. The name of the generator list is stored inside the <code class="literal">m_loadingGenerator</code> data member.</p><p>If any other type is encountered, it is safe to assume we are dealing with a specific type of generator. If that is the case, the generator list name is first checked that it isnt't being empty, which would indicate a file format problem. The generator factory is then searched for the generator with the type loaded from the file. If it is found, a new generator instance is created through it, the stream object is passed to it to do its own loading via the <code class="literal">&gt;&gt;</code> operator, and the final instance is inserted into the generator list for the current type of <code class="literal">m_loadingGenerator</code>.</p><p>Because we're using a data member to keep file information around, it must be reset before attempting to load another file. Our <code class="literal">FileLoader</code> interface provides such functionality, given this method is overloaded:</p><pre class="programlisting">void ParticleSystem::ResetForNextFile() { 
  m_loadingGenerator.clear(); 
} 
</pre><p>The final base class the particle system is inheriting from, <code class="literal">MapLoadee</code>, requires us to implement a single method that will handle map file entries with its own custom types:</p><pre class="programlisting">void ParticleSystem::ReadMapLine(const std::string&amp; l_type, 
  std::stringstream&amp; l_stream) 
{ 
  if (l_type == "ParticleEmitter") { 
    sf::Vector3f position; 
    size_t emitRate; 
    std::string generatorType; 
    l_stream &gt;&gt; generatorType &gt;&gt; position.x &gt;&gt; position.y &gt;&gt; 
      position.z &gt;&gt; emitRate; 
    auto emitter = std::make_unique&lt;Emitter&gt;(position); 
    emitter-&gt;SetEmitRate(emitRate); 
    emitter-&gt;SetGenerators(generatorType); 
    AddEmitter(std::move(emitter), StateType::Game); 
  } else if (l_type == "ForceApplicator") { 
    sf::Vector3f position; 
    sf::Vector3f force; 
    float radius; 
    l_stream &gt;&gt; position.x &gt;&gt; position.y &gt;&gt; position.z &gt;&gt; 
      force.x &gt;&gt; force.y &gt;&gt; force.z &gt;&gt; radius; 
    AddForce(ForceApplicator(position, force, radius), 
      StateType::Game); 
  } 
} 
</pre><p>As you can see, two different types of map entry are supported by the particle system: <code class="literal">ParticleEmitter</code> and <code class="literal">ForceApplicator</code>. In both cases, all of the appropriate data is streamed in and applied to the newly constructed objects, which are then added to the <code class="literal">Game</code> state.</p><p>Next, let's focus on the method that <em>makes it all move</em>, so of speak. It's time to take a look at the <code class="literal">Update()</code> method:</p><pre class="programlisting">void ParticleSystem::Update(float l_dT) { 
  if (m_stateItr == m_container.end()) { return; } 
  for (auto&amp; emitter : m_emitterItr-&gt;second) { 
    emitter-&gt;Update(l_dT, m_stateItr-&gt;second.get()); 
  } 
  for (auto&amp; updater : m_updaters){ 
    updater.second-&gt;Update(l_dT, m_stateItr-&gt;second.get()); 
  } 
  if (!m_removedEmitters.size()) { return; } 
  for (auto&amp; removed : m_removedEmitters) { 
    m_emitterItr-&gt;second.erase( 
      std::remove_if( 
        m_emitterItr-&gt;second.begin(), 
        m_emitterItr-&gt;second.end(), 
        [removed](std::unique_ptr&lt;Emitter&gt;&amp; emitter) { 
          return emitter.get() == removed; 
        } 
    )); 
  } 
  m_removedEmitters.clear(); 
} 
</pre><p>It really only consists of three basic parts: updating emitters, updating all the different <code class="literal">BaseUpdater</code> instances, and processing removed emitters. None of this happens if the current state iterator is not valid. Having no particles to work with means we have no work at all.</p><p>The updating of emitters and updaters is fairly straightforward. Removal of disposed emitters is not anything too complex either. The container of removed emitter pointers is iterated over, and for each entry, an emitter that is still within the world and has the same memory address is removed from the container.</p><p>Finally, we get to the code responsible for getting all of our beautiful particles out on the screen:</p><pre class="programlisting">void ParticleSystem::Draw(Window* l_window, int l_elevation) { 
  if (m_stateItr == m_container.end()) { return; } 
  auto container = m_stateItr-&gt;second.get(); 
  auto&amp; drawables = container-&gt;m_drawable; 
  auto&amp; positions = container-&gt;m_position; 
  auto&amp; blendModes = container-&gt;m_addBlend; 
  auto view = l_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto renderer = l_window-&gt;GetRenderer(); 
 
  auto state = m_stateManager-&gt;GetCurrentStateType(); 
  if (state == StateType::Game || state == StateType::MapEditor) { 
    renderer-&gt;UseShader("default"); 
  } else { 
    renderer-&gt;DisableShader(); 
  } 
 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    if (l_elevation &gt;= 0) { 
      if (positions[i].z &lt; l_elevation * Sheet::Tile_Size) { 
        continue; 
      } 
      if (positions[i].z &gt;= (l_elevation + 1) * Sheet::Tile_Size){ 
        continue; 
      } 
    } else if (positions[i].z &lt; 
      Sheet::Num_Layers * Sheet::Tile_Size) 
    { continue; } 
    renderer-&gt;AdditiveBlend(blendModes[i]); 
    renderer-&gt;Draw(drawables[i]); 
  } 
  renderer-&gt;AdditiveBlend(false); 
} 
</pre><p>Naturally, if we're in a state that does not have a particle container, no drawing needs to be done. Otherwise, we obtain references to arrays of drawables, their positions and blend modes. Since we want particles to support layering in order to add depth, the second argument of this method takes in the current layer being drawn.</p><div><div><h3 class="title"><a id="note7"/>Note</h3><p>Note the state checking and use of shaders in this portion of the code. We're essentially controlling which states the particles are shaded in here. The map editor state will be covered in the next two chapters.</p></div></div><p>If the layer/elevation tests pass, there's one more check we need to make in order to be able to render a particle, and that is whether the particle is currently within the view of the screen.</p><div><div><h3 class="title"><a id="tip8"/>Tip</h3><p>This simple AABB collision check obviously does <strong>not</strong> account for particles being rotated. Although the bounds that are checked still contain the entire body of a particle, certain corner-case scenarios may result in it being rendered, while it is rotated in such a way that it should be invisible, yet where the bounding box is still within the view. This can be solved by applying a more sophisticated collision check algorithm, but it isn't going to be covered here.</p></div></div><p>Finally, after all of the tests have passed, it is time to render the particle. Keep in mind that it is in our best interest here to support two blending modes when it comes to rendering: additive and alpha blending. Luckily, SFML makes it easy for us, and it's only necessary to pass an additional argument to the draw method of a window instance to determine how something is drawn.</p><p>Having the ability to switch between blending modes can be useful when rendering some particle types, since they would look more realistic that way. For example, take a look at the same type of particles being rendered with additive blending, versus alpha blending, which is the default mode:</p><div><img src="img/image_03_008.jpg" alt="Implementing the particle system"/></div><p>While not all particles are going to take advantage of this blending mode, it's definitely a nice option to have for those that need that extra oomph.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Creating updaters</h1></div></div></div><p>With the core particle system all built up, it is time to focus on individual bits and pieces that will give our system its functionality and polish. By the time we are done, these are some of the effects that will be possible:</p><div><img src="img/image_03_009.jpg" alt="Creating updaters"/></div><p>The only way to get there is to keep going, so let us get to it!</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Spatial updater</h2></div></div></div><p>First, and probably the most obvious task is adjusting particle positions based on their kinematic states. As small as they may be, they still operate based on changes in velocity, acceleration, and position:</p><pre class="programlisting">class SpatialUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    auto&amp; accelerations = l_particles-&gt;m_acceleration; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      velocities[i] += accelerations[i] * l_dT; 
    } 
    auto&amp; positions = l_particles-&gt;m_position; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      positions[i] += velocities[i] * l_dT; 
    } 
  } 
}; 
</pre><p>So far, so good! Some of these updaters will have rather small footprints since they perform incredibly simple tasks. All we do here is obtain references to velocity, acceleration and position containers. The data is then manipulated in two separate loops in order to minimize cache misses.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Drawable updater</h2></div></div></div><p>Next, let's update the drawable bits of our particles. This is where the appropriately named <code class="literal">DrawableUpdater</code> comes in:</p><pre class="programlisting">class DrawableUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto&amp; drawables = l_particles-&gt;m_drawable; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setPosition(positions[i].x, positions[i].y); 
    } 
    auto&amp; sizes = l_particles-&gt;m_currentSize; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setSize(sizes[i]); 
    } 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      float ScaleFactor = std::max( 
        (positions[i].z / Sheet::Tile_Size) * 
        ScaleToElevationRatio, 1.f); 
      drawables[i].setScale(ScaleFactor, ScaleFactor); 
    } 
    auto&amp; colors = l_particles-&gt;m_currentColor; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setFillColor(colors[i]); 
    } 
    auto&amp; rotations = l_particles-&gt;m_currentRotation; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setRotation(rotations[i]); 
    } 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      drawables[i].setOrigin( 
        drawables[i].getLocalBounds().width / 2, 
        drawables[i].getLocalBounds().height / 2); 
    } 
  } 
  static const float ScaleToElevationRatio; 
}; 
 
const float DrawableUpdater::ScaleToElevationRatio = 1.5f; 
</pre><p>This is quite a bit of code, but its essence is incredibly simple. Separate loops are utilized in order to set all of the relevant drawable properties up. We do, however, have something more interesting going on. Note the highlighted portions of the code, all of which are related to scale. As you have probably figured out by now, SFML deals with only two dimensions when it comes to visuals. In order to fake 3D particles flying around, we can utilize drawable scaling. The scale factor itself is capped at <em>1.f</em>, so we don't go any smaller than the default particle size. The scale to elevation ratio here is set to <em>1.5f</em>, which is debatably the best value, but is obviously up for tweaking. All it is is a simple ratio that the supposed <em>elevation</em> of a particle gets multiplied by in order to obtain a scale value, which, when used, should create the illusion of a particle flying towards the camera.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Lifespan updater</h2></div></div></div><p>Since computer resources, at least during the time of writing this book, are limited, we need to have a good way of disposing of particles when it's time. One good idea is attaching a lifespan to particles, so that after it's supposed to have expired, the particle is gracefully removed from the population:</p><pre class="programlisting">class LifespanUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; lifespans = l_particles-&gt;m_lifespan; 
    auto&amp; maxLifespans = l_particles-&gt;m_maxLifespan; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive;) { 
      lifespans[i] += l_dT; 
      if (lifespans[i] &lt; maxLifespans[i]) { ++i; continue; } 
      l_particles-&gt;Disable(i); 
    } 
  } 
}; 
</pre><p>This is a quite simple little updater. The delta time is added to each live particle, which then is checked for having exceeded its lifespan. If it has, the particle is disabled. Keep in mind that disabling the particle will decrease the <code class="literal">m_countAlive</code> data member of a particle container. For this very reason, we must be careful when incrementing the <code class="literal">i</code> local variable, in order to not skip any data in the process.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Interpolator</h2></div></div></div><p>Tons of particle properties are not going to be static throughout their lifetime. Take, for example, the particle color. We may want to fade a particle to complete transparency, or even cycle through a range of colors. All of this can be achieved by interpolating. This process is a good candidate for its own updater class:</p><pre class="programlisting">class Interpolator : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; startColors = l_particles-&gt;m_startColor; 
    auto&amp; currentColors = l_particles-&gt;m_currentColor; 
    auto&amp; finalColors = l_particles-&gt;m_finalColor; 
    auto&amp; lifespans = l_particles-&gt;m_lifespan; 
    auto&amp; maxLifespans = l_particles-&gt;m_maxLifespan; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startColors[i] == finalColors[i]) { continue; } 
      currentColors[i].r = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].r, finalColors[i].r, 
        lifespans[i]); 
      currentColors[i].g = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].g, finalColors[i].g, 
        lifespans[i]); 
      currentColors[i].b = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].b, finalColors[i].b, 
        lifespans[i]); 
      currentColors[i].a = Utils::Interpolate&lt;sf::Uint8&gt;(0.f, 
        maxLifespans[i], startColors[i].a, finalColors[i].a, 
        lifespans[i]); 
    } 
 
    auto&amp; startRotations = l_particles-&gt;m_startRotation; 
    auto&amp; currentRotations = l_particles-&gt;m_currentRotation; 
    auto&amp; finalRotations = l_particles-&gt;m_finalRotation; 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startRotations[i] == finalRotations[i]) { continue; } 
      currentRotations[i] = Utils::Interpolate&lt;float&gt;(0.f, 
        maxLifespans[i], startRotations[i], finalRotations[i], 
        lifespans[i]); 
    } 
 
    auto&amp; startSizes = l_particles-&gt;m_startSize; 
    auto&amp; currentSizes = l_particles-&gt;m_currentSize; 
    auto&amp; finalSizes = l_particles-&gt;m_finalSize; 
 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (startSizes[i] == finalSizes[i]) { continue; } 
      currentSizes[i] = sf::Vector2f( 
        Utils::Interpolate&lt;float&gt;(0.f, maxLifespans[i], 
          startSizes[i].x, finalSizes[i].x, lifespans[i]), 
        Utils::Interpolate&lt;float&gt;(0.f, maxLifespans[i], 
          startSizes[i].y, finalSizes[i].y, lifespans[i])); 
    } 
  } 
}; 
</pre><p>Once again, we have lots of code, but the essence of it is basically the same all throughout. The <code class="literal">Interpolate</code> function, stored within our <code class="literal">Utilities.h</code> header, takes in a range of time values throughout which we need interpolation, the range of values that are supposed to be interpolated, and the current time value, which determines the output.</p><p>The interpolated properties are particle colors, rotations, and sizes. For all three of them, we first check if the starting value is the same as the final value in order to avoid useless computations.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Force updater</h2></div></div></div><p>During the planning stages of this particle system, we have discussed having different forces in the world that would affect particles. Outside the possibility of having custom forces, we also want to have basic gravity, so that particles with any sort of elevation begin falling down, provided they have the property of being affected by gravity. Let us implement an updater that will allow us to do that:</p><pre class="programlisting">class ForceUpdater : public BaseUpdater { 
  friend class ParticleSystem; 
public: 
  ForceUpdater() : m_applicators(nullptr) {} 
 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    auto&amp; gravity = l_particles-&gt;m_gravity; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (!gravity[i]) { continue; } 
      velocities[i].z -= Gravity * l_dT; 
    } 
 
    if (!m_applicators) { return; } 
    auto&amp; positions = l_particles-&gt;m_position; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      for (auto&amp; force : *m_applicators) { 
        Force(force.m_center, force.m_force * l_dT, 
          force.m_radius, positions[i], velocities[i]); 
      } 
    } 
  } 
 
  void SetApplicators(ForceApplicatorList* l_list) { 
    m_applicators = l_list; 
  } 
 
  static const float Gravity; 
private: 
  void Force(const sf::Vector3f&amp; l_center, 
    const sf::Vector3f&amp; l_force, float l_radius, 
    sf::Vector3f&amp; l_position, sf::Vector3f&amp; l_velocity) 
  { ... } 
 
  ForceApplicatorList* m_applicators; 
}; 
 
const float ForceUpdater::Gravity = 128.f; 
</pre><p>The first, and arguably the most important, function of this particular updater is applying gravity to all of the particles that need it. We want to be able to give certain types of particles, such as smoke or fire, the ability to not be affected by the gravitational force, so it's all left up to a flag that can be set. The actual gravitational force is defined as a static <code class="literal">const</code> data member, and set up underneath the class definition.</p><p>Next is the business we have with the force applicators within the world. If the force updater has no pointer to a force applicator list, there is obviously nothing left to do, so we return from the update method. Otherwise, a private <code class="literal">Force() </code>method is invoked with the force's center, the amount of force adjusted for delta time, its radius, and references to the position and velocity of the particle passed in as arguments:</p><pre class="programlisting">void Force(const sf::Vector3f&amp; l_center, 
  const sf::Vector3f&amp; l_force, float l_radius, 
  sf::Vector3f&amp; l_position, sf::Vector3f&amp; l_velocity) 
{ 
  sf::Vector3f from(l_center.x - l_radius, 
    l_center.y - l_radius, l_center.z - l_radius); 
  sf::Vector3f to(l_center.x + l_radius, 
    l_center.y + l_radius, l_center.z + l_radius); 
  if (l_position.x &lt; from.x) { return; } 
  if (l_position.y &lt; from.y) { return; } 
  if (l_position.z &lt; from.z) { return; } 
  if (l_position.x &gt; to.x) { return; } 
  if (l_position.y &gt; to.y) { return; } 
  if (l_position.z &gt; to.z) { return; } 
 
  sf::Vector3f distance = l_center - l_position; 
  sf::Vector3f a_distance = sf::Vector3f(std::abs(distance.x), 
    std::abs(distance.y), std::abs(distance.z)); 
  float magnitude = std::sqrt(std::pow(a_distance.x, 2) + 
    std::pow(a_distance.y, 2) + std::pow(a_distance.z, 2)); 
  sf::Vector3f normal = sf::Vector3f( 
    a_distance.x / magnitude, 
    a_distance.y / magnitude, 
    a_distance.z / magnitude 
  ); 
  sf::Vector3f loss = sf::Vector3f( 
    std::abs(l_force.x) / (l_radius / a_distance.x), 
    std::abs(l_force.y) / (l_radius / a_distance.y), 
    std::abs(l_force.z) / (l_radius / a_distance.z) 
  ); 
  sf::Vector3f applied = sf::Vector3f( 
    (l_force.x &gt; 0 ? l_force.x - loss.x : l_force.x + loss.x), 
    (l_force.y &gt; 0 ? l_force.y - loss.y : l_force.y + loss.y), 
    (l_force.z &gt; 0 ? l_force.z - loss.z : l_force.z + loss.z) 
  ); 
  applied.x *= normal.x; 
  applied.y *= normal.y; 
  applied.z *= normal.z; 
  if (distance.x &lt; 0) { applied.x = -applied.x; } 
  if (distance.y &lt; 0) { applied.y = -applied.y; } 
  if (distance.z &lt; 0) { applied.z = -applied.z; } 
 
  l_velocity += applied; 
} 
</pre><p>After the distance ranges are calculated using the center and radius of the force, the position of the particle is tested to see whether it is within the force-affected area. Provided all of the tests pass, the distance is calculated between the center of the force and the particle. It's then used to calculate the absolute distance between them, determine the magnitude of the force, and normalize the vector. Force loss is calculated based on the radii and distances on all three axes, and subtracted from the actual applied force, which is then multiplied by the normal in order to yield the finished product. Depending on the distance sign, we can determine which direction the force should be applied to, which is what the next three lines are for. Finally, after all of that work, we're ready to add the applied force to the particle's velocity.</p><p>With the help of this updater, we can actually apply forces to particles even from outside classes, like so:</p><pre class="programlisting">void ParticleSystem::ApplyForce(const sf::Vector3f&amp; l_center, 
  const sf::Vector3f&amp; l_force, float l_radius) 
{ 
  if (m_stateItr == m_container.end()) { return; } 
  auto f = static_cast&lt;ForceUpdater*&gt;(m_updaters["Force"].get()); 
  auto container = m_stateItr-&gt;second.get(); 
  auto&amp; positions = container-&gt;m_position; 
  auto&amp; velocities = container-&gt;m_velocity; 
  for (size_t i = 0; i &lt; container-&gt;m_countAlive; ++i) { 
    f-&gt;Force(l_center, l_force, l_radius, 
      positions[i], velocities[i]); 
  } 
} 
</pre><p>While this isn't as useful as, say, having constant forces inside the world, it can still be used for testing purposes.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Collision updater</h2></div></div></div><p>Another important aspect of particles interacting with the world is handling their collisions. So far, the only real collision we need to worry about is particles hitting the floor; however, actual map collisions could be implemented quite easily with the help of this class:</p><pre class="programlisting">class CollisionUpdater : public BaseUpdater { 
public: 
  void Update(float l_dT, ParticleContainer* l_particles) { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (positions[i].z &gt; 0.f) { continue; } 
      positions[i].z = 0.f; 
      velocities[i].z = 0.f; 
    } 
 
    if (!m_map) { return; } 
    for (size_t i = 0; i &lt; l_particles-&gt;m_countAlive; ++i) { 
      if (positions[i].z &gt; 0.f) { continue; } 
      ApplyFriction(l_dT, positions[i], velocities[i]); 
    } 
  } 
  void SetMap(Map* l_map) { m_map = l_map; } 
private: 
  void ApplyFriction(float l_dT, sf::Vector3f&amp; l_position, 
    sf::Vector3f&amp; l_velocity) { ... } 
  Map* m_map; 
}; 
</pre><p>All we have to worry about here is checking whether the position of a particle on the <em>z </em>axis is below zero. If it is, the position on that axis is reset back to zero, as well as its velocity. Additionally, if the updater has been provided with a pointer to a map instance, we want to handle particle friction against the map, provided they are touching the ground. Provided that's the case, the delta time is passed into a private <code class="literal">ApplyFriction()</code> method, along with the position and velocity vectors of the particle:</p><pre class="programlisting">void ApplyFriction(float l_dT, sf::Vector3f&amp; l_position, 
  sf::Vector3f&amp; l_velocity) 
{ 
  sf::Vector2i tileCoords = sf::Vector2i( 
    static_cast&lt;int&gt;(floor(l_position.x / Sheet::Tile_Size)), 
    static_cast&lt;int&gt;(floor(l_position.y / Sheet::Tile_Size))); 
  auto tile = m_map-&gt;GetTile(tileCoords.x, tileCoords.y, 0); 
  sf::Vector2f friction; 
  if (!tile) { friction = m_map-&gt;GetDefaultTile()-&gt;m_friction; } 
  else { friction = tile-&gt;m_properties-&gt;m_friction; } 
  friction.x *= std::abs(l_velocity.x); 
  friction.y *= std::abs(l_velocity.y); 
  friction *= l_dT; 
  if (l_velocity.x != 0.f &amp;&amp; friction.x != 0.f) { 
    if (std::abs(l_velocity.x) - std::abs(friction.x) &lt; 0.f) { 
      l_velocity.x = 0.f; 
    } else { 
      l_velocity.x += (l_velocity.x &gt; 0.f ? 
        friction.x * -1.f : friction.x); 
    } 
  } 
 
  if (l_velocity.y != 0.f &amp;&amp; friction.y != 0.f) { 
    if (std::abs(l_velocity.y) - std::abs(friction.y) &lt; 0.f) { 
      l_velocity.y = 0.f; 
    } else { 
      l_velocity.y += (l_velocity.y &gt; 0.f ? 
        friction.y * -1.f : friction.y); 
    } 
  } 
} 
</pre><p>After the tile coordinates a particle is touching are determined, the tile is checked to see whether it exists in the first place. If it does not, the default friction is used. Once all of that is sorted out, the velocity <strong>lost to friction</strong> is calculated, and then multiplied by delta time to get accurate results for the current frame. Everything else after this point is related to making sure the values being added have the right sign, and don't result in going past absolute zero into the opposite sign domain.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Particle generators</h1></div></div></div><p>Having all of these updaters really does nothing unless certain base values are generated for the particles. Whether it is the initial position of a particle, the range of colors, or the name of a texture that gets attached to our flying little data structures, having that initial data set based on some pre-conceived notion is important. There are quite a few generators we support, not to mention tons of candidates for new generators, and thus new types of particles. Having said that, let us take a look at a couple of basics that we need to get some basic effects going.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Point position</h2></div></div></div><p>The simplest generator we can possibly have in this entire system is a point position. Essentially, it just sets all positions of fed-in particles to a static point in space:</p><pre class="programlisting">class PointPosition : public BaseGenerator { 
public: 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    for (auto i = l_from; i &lt;= l_to; ++i) {positions[i] = center;} 
  } 
}; 
</pre><p>The center point all particles are positioned at is taken from the emitter. Its position will always be used to determine where a particle should be spawned.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Area position</h2></div></div></div><p>Setting all particle positions to the same point can get rather boring, not to mention visually odd. If we're dealing with particles such as smoke or fire, it may make more sense to scatter the particles within a specified area. This is where <code class="literal">AreaPosition</code> comes in:</p><pre class="programlisting">class AreaPosition : public BaseGenerator { 
public: 
  AreaPosition() = default; 
  AreaPosition(const sf::Vector3f&amp; l_deviation) 
    : m_deviation(l_deviation) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    auto rangeFrom = sf::Vector3f(center.x - m_deviation.x, 
      center.y - m_deviation.y, center.z - m_deviation.z); 
    auto rangeTo = sf::Vector3f(center.x + m_deviation.x, 
      center.y + m_deviation.y, center.z + m_deviation.z); 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      positions[i] = sf::Vector3f( 
        rand(rangeFrom.x, rangeTo.x), 
        rand(rangeFrom.y, rangeTo.y), 
        rand(rangeFrom.z, rangeTo.z) 
      ); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_deviation.x &gt;&gt; m_deviation.y &gt;&gt; m_deviation.z; 
  } 
private: 
  sf::Vector3f m_deviation; 
}; 
</pre><p>This particular position generator still uses the emitter position as the center point, but also applies a random deviation range to it. The deviation value can be read directly from the particle file, or simply set through the constructor of this generator.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Line position</h2></div></div></div><p>A slight variation on the area position is a line position. It works in the same basic way as the area position does, except only for one axis, which is either provided through the constructor or loaded in from the particle file:</p><pre class="programlisting">enum class LineAxis{ x, y, z }; 
 
class LinePosition : public BaseGenerator { 
public: 
  LinePosition() : m_axis(LineAxis::x), m_deviation(0.f) {} 
  LinePosition(LineAxis l_axis, float l_deviation) 
    : m_axis(l_axis), m_deviation(l_deviation) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; positions = l_particles-&gt;m_position; 
    auto center = l_emitter-&gt;GetPosition(); 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      if (m_axis == LineAxis::x) { 
        center.x = rand(center.x - m_deviation, 
          center.x + m_deviation); 
      } else if (m_axis == LineAxis::y) { 
        center.y = rand(center.y - m_deviation, 
          center.y + m_deviation); 
      } else { 
        center.z = rand(center.z - m_deviation, 
          center.z + m_deviation); } 
      positions[i] = center; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    std::string axis; 
    l_stream &gt;&gt; axis &gt;&gt; m_deviation; 
    if (axis == "x") { m_axis = LineAxis::x; } 
    else if (axis == "y") { m_axis = LineAxis::y; } 
    else if (axis == "z") { m_axis = LineAxis::z; } 
    else { std::cout &lt;&lt; "Faulty axis: " &lt;&lt; axis &lt;&lt; std::endl; } 
  } 
private: 
  LineAxis m_axis; 
  float m_deviation; 
}; 
</pre><p>The random deviation here is only applied to one of the axes. The same effect could arguably be achieved with an area position generator, but it doesn't hurt to have a little variety.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Particle properties</h2></div></div></div><p>Certain properties particles possess would really not call for their own generators. For example, gravity and blending mode flags for particles could just be pooled to exist within a single type of generator:</p><pre class="programlisting">class PropGenerator : public BaseGenerator { 
public: 
  PropGenerator(bool l_gravity = true, bool l_additive = false) 
    : m_gravity(l_gravity), m_additive(l_additive) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; gravity = l_particles-&gt;m_gravity; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      gravity[i] = m_gravity; 
    } 
    auto&amp; additive = l_particles-&gt;m_addBlend; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      additive[i] = m_additive; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    int gravity = 1; 
    int additive = 0; 
    l_stream &gt;&gt; gravity &gt;&gt; additive; 
    m_gravity = (gravity != 0); 
    m_additive = (additive != 0); 
  } 
private: 
  bool m_gravity; 
  bool m_additive; 
}; 
</pre><p>Both the gravity and blending mode flags can, as with all the previous generators, be loaded in from the file, or set through the constructor of the class.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Random color</h2></div></div></div><p>Randomizing the color of all emitted particles may be something one may want to do, whether the random variations are slight for something such as differently shaded water particles, or completely random for a fountain of skittles. All of that and more can be done by this class:</p><pre class="programlisting">class RandomColor : public BaseGenerator { 
public: 
  RandomColor() = default; 
  RandomColor(const sf::Vector3i&amp; l_from,const sf::Vector3i&amp; l_to) 
    : m_from(l_from), m_to(l_to) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; colors = l_particles-&gt;m_currentColor; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      sf::Color target{ 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.x, m_to.x)), 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.y, m_to.y)), 
        static_cast&lt;sf::Uint8&gt;(rand(m_from.z, m_to.z)), 
        255 
      }; 
      colors[i] = target; 
    } 
  } 
   void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from.x &gt;&gt; m_to.x &gt;&gt; m_from.y &gt;&gt; m_to.y &gt;&gt; 
      m_from.z &gt;&gt; m_to.z; 
  } 
private: 
  sf::Vector3i m_from; 
  sf::Vector3i m_to; 
}; 
</pre><p>The generator stores ranges, which are going to be used to generate random results. They can either be loaded in from the particle file, or set through the constructor. Since the ranges can be different for each one of the three color channels, they are randomized separately.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Color range</h2></div></div></div><p>While the random color generator simply assigns the current color of the particle, a color range provides a range of colors that the particle will fade through during its lifespan, thanks to interpolation. This process is as simple as assigning those values:</p><pre class="programlisting">class ColorRange : public BaseGenerator { 
public: 
  ColorRange() = default; 
  ColorRange(const sf::Color&amp; l_start, const sf::Color&amp; l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; beginning = l_particles-&gt;m_startColor; 
    auto&amp; current = l_particles-&gt;m_currentColor; 
    auto&amp; ending = l_particles-&gt;m_finalColor; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      beginning[i] = m_start; 
      current[i] = m_start; 
      ending[i] = m_finish; 
    } 
  } 
  void ReadIn(std::stringstream&amp; l_stream) { 
    int s_r = 0, s_g = 0, s_b = 0, s_a = 0; 
    int f_r = 0, f_g = 0, f_b = 0, f_a = 0; 
    l_stream &gt;&gt; s_r &gt;&gt; s_g &gt;&gt; s_b &gt;&gt; s_a; 
    l_stream &gt;&gt; f_r &gt;&gt; f_g &gt;&gt; f_b &gt;&gt; f_a; 
 
    m_start = { 
      static_cast&lt;sf::Uint8&gt;(s_r), static_cast&lt;sf::Uint8&gt;(s_g), 
      static_cast&lt;sf::Uint8&gt;(s_b), static_cast&lt;sf::Uint8&gt;(s_a) 
    }; 
    m_finish = { 
      static_cast&lt;sf::Uint8&gt;(f_r), static_cast&lt;sf::Uint8&gt;(f_g), 
      static_cast&lt;sf::Uint8&gt;(f_b), static_cast&lt;sf::Uint8&gt;(f_a) 
    }; 
  } 
private: 
  sf::Color m_start; 
  sf::Color m_finish; 
}; 
</pre><p>Just as before, the ranges can be read in from the particle file or set up by using the constructor. Both the initial and the current colors of a particle are set to match the starting color.</p><p>Note the de-serialization method. Because we're reading integers from the text file, the variable type must reflect that at first. After all the values are read in, they're then converted to <code class="literal">sf::Uint8</code> and stored as ranges. This obviously includes the alpha channel, in order to give particles the means of fading out when they're about to de-spawn.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Random lifespan</h2></div></div></div><p>Generating the lifespan for particles is fairly similar to everything else we've done so far, so let's just jump straight into it:</p><pre class="programlisting">class RandomLifespan : public BaseGenerator { 
public: 
  RandomLifespan() : m_from(0.f), m_to(0.f) {} 
  RandomLifespan(float l_from, float l_to) 
    : m_from(l_from), m_to(l_to) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; lifespans = l_particles-&gt;m_maxLifespan; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      lifespans[i] = rand(m_from, m_to); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from &gt;&gt; m_to; 
  } 
private: 
  float m_from; 
  float m_to; 
}; 
</pre><p>Predictably, lifespans are also stored as ranges, which can be loaded from the particle file or set up by using the constructor. Afterwards, the life of a particle is randomized within the specified range. This can provide certain effects with visual variety by eliminating the <em>line of death</em> that tends to visually stick out.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Random size</h2></div></div></div><p>Randomizing the particle size is another useful tool to have in our visual arsenal. Let us take a look:</p><pre class="programlisting">class RandomSize : public BaseGenerator { 
public: 
  RandomSize() : m_from(0), m_to(0) {} 
  RandomSize(int l_from, int l_to): m_from(l_from), m_to(l_to) {} 
 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; sizes = l_particles-&gt;m_currentSize; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      float size = static_cast&lt;float&gt;(rand(m_from, m_to)); 
      sizes[i] = sf::Vector2f(size, size); 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from &gt;&gt; m_to; 
  } 
private: 
  int m_from; 
  int m_to; 
}; 
</pre><p>As always, ranges are stored as data members, and can be read in from a file, or set up via the constructor. The size itself is randomized once, and then applied as the same size for both axes. As of yet, we have no reason to generate rectangular particles with non-matching dimensions.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Random velocity</h2></div></div></div><p>All of the effort we have put into the system so far would literally be at a standstill if we did not give these particles a push from their birth. Applying random velocity values can achieve just that:</p><pre class="programlisting">class RandomVelocity : public BaseGenerator { 
public: 
  RandomVelocity() = default; 
  RandomVelocity(const sf::Vector3f&amp; l_from, 
    const sf::Vector3f&amp; l_to) : m_from(l_from), m_to(l_to) {} 
 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; rand = *l_emitter-&gt;GetParticleSystem()-&gt;GetRand(); 
    auto&amp; velocities = l_particles-&gt;m_velocity; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      sf::Vector3f target{ 
        rand(m_from.x, m_to.x), 
        rand(m_from.y, m_to.y), 
        rand(m_from.z, m_to.z) 
      }; 
      velocities[i] = target; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_from.x &gt;&gt; m_to.x &gt;&gt; m_from.y &gt;&gt; m_to.y &gt;&gt; 
    m_from.z &gt;&gt; m_to.z; 
  } 
private: 
  sf::Vector3f m_from; 
  sf::Vector3f m_to; 
}; 
</pre><p>Velocities, as covered earlier, work in three dimensions, so that is precisely how we must store them. Their ranges are either loaded from particle files, or set up through the constructor of this generator. They are then individually randomized and applied.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Rotation range</h2></div></div></div><p>Rotation of particles can be nice for a number of different effects we can think of. Rotating them slightly over their lifetimes can provide some nice variety, so let us reflect that in this next generator:</p><pre class="programlisting">class RotationRange : public BaseGenerator { 
public: 
  RotationRange() : m_start(0.f), m_finish(0.f) {} 
  RotationRange(float l_start, float l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    auto&amp; beginning = l_particles-&gt;m_startRotation; 
    auto&amp; ending = l_particles-&gt;m_finalRotation; 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      beginning[i] = m_start; 
      ending[i] = m_finish; 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_start &gt;&gt; m_finish; 
  } 
private: 
  float m_start; 
  float m_finish; 
}; 
</pre><p>Since the rotation values are going to be interpolated over the particle's lifetime, we use beginning and ending values to reflect that.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Size range</h2></div></div></div><p>Particle sizes are no different from any other data we have been dealing with so far, so let's take a look:</p><pre class="programlisting">class SizeRange : public BaseGenerator { 
public: 
  SizeRange() : m_start(0), m_finish(0) {} 
  SizeRange(float l_start, float l_finish) 
    : m_start(l_start), m_finish(l_finish) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    if (m_start == m_finish) { 
      auto&amp; sizes = l_particles-&gt;m_currentSize; 
      for (auto i = l_from; i &lt;= l_to; ++i) { 
        sizes[i] = sf::Vector2f(m_start, m_start); 
      } 
    } else { 
      auto&amp; beginning = l_particles-&gt;m_startSize; 
      auto&amp; ending = l_particles-&gt;m_finalSize; 
      for (auto i = l_from; i &lt;= l_to; ++i) { 
        beginning[i] = sf::Vector2f(m_start, m_start); 
        ending[i] = sf::Vector2f(m_finish, m_finish); 
      } 
    } 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream) { 
    l_stream &gt;&gt; m_start &gt;&gt; m_finish; 
  } 
private: 
  float m_start; 
  float m_finish; 
}; 
</pre><p>The ranges provided to this generator are first checked to see whether they're not equal. If that is the case, however, we can treat the size of a particle as constant and simply set its current size to it to save the interpolator some work. Otherwise, the beginning and ending values of the size are filled out.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Texture generator</h2></div></div></div><p>Last, but definitely not least, we can make our particles about a million times more appealing to the eye by texturing them. Luckily, our system makes it fairly easy to do at this point. Let's take a look:</p><pre class="programlisting">class TextureGenerator : public BaseGenerator { 
public: 
  TextureGenerator() = default; 
  TextureGenerator(const std::string&amp; l_texture) 
    : m_texture(l_texture) {} 
  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, 
    size_t l_from, size_t l_to) 
  { 
    if (m_texture.empty()) { return; } 
    TextureManager* manager = l_emitter-&gt; 
      GetParticleSystem()-&gt;GetTextureManager(); 
    if (!manager-&gt;RequireResource(m_texture)) { return; } 
    auto&amp; textures = l_particles-&gt;m_texture; 
    auto&amp; drawables = l_particles-&gt;m_drawable; 
    auto resource = manager-&gt;GetResource(m_texture); 
    auto size = resource-&gt;getSize(); 
    for (auto i = l_from; i &lt;= l_to; ++i) { 
      textures[i] = m_texture; 
      manager-&gt;RequireResource(m_texture); 
      drawables[i].setTexture(resource); 
      drawables[i].setTextureRect(sf::IntRect(0,0,size.x,size.y)); 
    } 
    manager-&gt;ReleaseResource(m_texture); 
  } 
 
  void ReadIn(std::stringstream&amp; l_stream){l_stream &gt;&gt; m_texture;} 
private: 
  std::string m_texture; 
}; 
</pre><p>The string identifier of the texture that needs to be used for the particle type is first either loaded in from a file, or passed in via the constructor. The string is then checked inside the <code class="literal">Generate</code> method in order to make sure it is not empty. After a pointer to the texture manager is obtained, the resource handle is checked for validity by an attempt to require it.</p><div><div><h3 class="title"><a id="note9"/>Note</h3><p>Remember that the <code class="literal">RequireResource</code> line actually claims the resource is being used, until it's released.</p></div></div><p>All particles that are being generated are then provided with the resource handle of the texture. For each particle, the resource is required one more time, and then finally passed into the drawable object of the particle, as well as properly cropped based on the particle size.</p><p>Finally, note the last highlighted line of code inside the <code class="literal">Generate()</code> method. Because we have increased the internal resource counter once by requiring it at the very beginning for verification purposes, as well as to obtain a reference to the resource, it must now be released, leaving the internal resource counter with the same value as the number of particles that actually use this texture.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Using the particle system</h1></div></div></div><p>Before we can start using our particle system, some basic setting up is in order. First, since the particle system is dependent on both states and map loading, their relationship must be set up inside the main <code class="literal">Game</code> class like so:</p><pre class="programlisting">void Game::SetUpStates() { 
  ... 
  m_stateManager-&gt;AddDependent(m_particles.get()); 
  ... 
} 
 
void Game::SetUpClasses() { 
  ... 
  m_gameMap.AddLoadee(m_particles.get()); 
} 
</pre><p>Next, let's build an actual type of particle that will be used inside the main menu to make it look spectacular:</p><pre class="programlisting">Name MenuFlame 
PointPosition 
SizeRange 32 8 
|ColorRange 255 255 0 100 0 255 255 0 
RandomColor 100 255 100 255 100 255 
RandomLifespan 6 6 
RandomVelocity -10 10 -50 -80 5 10 
RotationRange 0 45 
Texture Flame 
Properties 0 1 
</pre><p>All of these generator parameters have already been covered, so if this format looks questionable, it may be prudent to review the generator section once again.</p><p>Let us add all of these spectacular visuals to the menu state, in order to make it much more impressive than it currently is. We can start by first setting up a couple of emitters:</p><pre class="programlisting">void State_MainMenu::OnCreate() { 
  ... 
  auto w_size = context-&gt;m_wind-&gt;GetWindowSize(); 
  context-&gt;m_particles-&gt;CreateState(StateType::MainMenu); 
  auto emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    static_cast&lt;float&gt;(w_size.x) / 3.f, 
    static_cast&lt;float&gt;(w_size.y) - 64.f, 
    33.f)); 
  emitter-&gt;SetEmitRate(25); 
  emitter-&gt;SetGenerators("MenuFlame"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    (static_cast&lt;float&gt;(w_size.x) / 3.f) * 2.f, 
    static_cast&lt;float&gt;(w_size.y) - 64.f, 
    33.f)); 
  emitter-&gt;SetEmitRate(25); 
  emitter-&gt;SetGenerators("MenuFlame"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  emitter = std::make_unique&lt;Emitter&gt;(sf::Vector3f( 
    0.f, 
    static_cast&lt;float&gt;(w_size.y) / 2.f, 
    0.f)); 
  emitter-&gt;SetEmitRate(60); 
  emitter-&gt;SetGenerators("MenuSmoke"); 
  context-&gt;m_particles-&gt;AddEmitter(std::move(emitter)); 
  auto f = ForceApplicator( 
    sf::Vector3f(static_cast&lt;float&gt;(w_size.x) / 2.f, 
      static_cast&lt;float&gt;(w_size.y) / 2.f, 64.f), 
    sf::Vector3f(500.f, 500.f, 500.f), 256.f); 
  context-&gt;m_particles-&gt;AddForce(f); 
} 
</pre><p>Note the highlighted line of the code. A state must be created inside the particle system in order for us to be able to use it. Next, two emitters are created. One is positioned at one third of the width of the screen, and the other, two thirds. Both of them are added to the system, as well as another emitter, positioned off to the left, which will be emitting smoke. Finally, a force applicator, positioned right in between the two flames, is added to the particle system as well. With this thoughtful positioning, we're going to be creating a really good-looking effect that will be showcased shortly.</p><p>Our particles obviously need to be updated in order to function properly:</p><pre class="programlisting">void State_MainMenu::Update(const sf::Time&amp; l_dT) { 
  m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Update(l_dT.asSeconds()); 
} 
</pre><p>Finally, let's draw them on screen:</p><pre class="programlisting">void State_MainMenu::Draw() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  for (unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i) { 
    m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Draw( 
      *m_stateMgr-&gt;GetContext()-&gt;m_wind, i); 
  } 
  m_stateMgr-&gt;GetContext()-&gt;m_particles-&gt;Draw( 
    *m_stateMgr-&gt;GetContext()-&gt;m_wind, -1); 
} 
</pre><p>Since the <code class="literal">Draw()</code> method takes in the layer we are currently drawing, and for this state layers are irrelevant, we simply iterate over the number of layers, invoking the <code class="literal">Draw()</code> method for each one. At the end, the <code class="literal">Draw()</code> method is invoked one last time with the argument <code class="literal">-1</code>, signifying that we want to draw all of the particles that are outside the maximum layer.</p><p>The final result, along with the smoke effect, looks a little like this:</p><div><img src="img/image_03_010.jpg" alt="Using the particle system"/></div><p>This is far from showcasing what the particle system can really do. The code in this chapter includes examples that exist within the game state, and can be easily found by compiling the project and simply taking a stroll through the scenery.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Summary</h1></div></div></div><p>There may have been quite a bit to take in, but if you are here, congratulations! With some careful architecting, calculated decisions, and a dash of taste, we have not only produced a particle system that makes the game look ten times better, but also formed the bedrock of knowledge that serves as a stepping stone towards better design, and increased performance.</p><p>In the next few chapters, we are going to be covering the fundamentals of sculpting your own tools for actually designing the game we are working with, as well as its assets. See you there!</p></div></div></div></body></html>