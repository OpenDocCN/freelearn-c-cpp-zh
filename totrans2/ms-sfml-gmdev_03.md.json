["```cpp\nstruct S{ \n  int m_x[50]; \n  int m_y[50]; \n  std::string m_name[50]; \n  ... \n}; \n\n```", "```cpp\nclass ParticleContainer { \npublic: \n  ... \n  const static size_t Max_Particles = 3000; \n  sf::Vector3f m_position[Max_Particles]; \n  sf::Vector3f m_velocity[Max_Particles]; \n  sf::Vector3f m_acceleration[Max_Particles]; \n  sf::Vector2f m_startSize[Max_Particles]; \n  sf::Vector2f m_currentSize[Max_Particles]; \n  sf::Vector2f m_finalSize[Max_Particles]; \n  sf::Color m_startColor[Max_Particles]; \n  sf::Color m_currentColor[Max_Particles]; \n  sf::Color m_finalColor[Max_Particles]; \n  std::string m_texture[Max_Particles]; \n  sf::RectangleShape m_drawable[Max_Particles]; \n  float m_startRotation[Max_Particles]; \n  float m_currentRotation[Max_Particles]; \n  float m_finalRotation[Max_Particles]; \n  float m_lifespan[Max_Particles]; \n  float m_maxLifespan[Max_Particles]; \n  bool m_gravity[Max_Particles]; \n  bool m_addBlend[Max_Particles]; \n  bool m_alive[Max_Particles]; \n\n  size_t m_countAlive; \n  TextureManager* m_textureManager; \nprotected: \n  ... \n}; \n\n```", "```cpp\nParticleContainer(TextureManager* l_textureManager) \n  : m_textureManager(l_textureManager), m_countAlive(0) \n{ Reset(); } \n\n~ParticleContainer(){ \n  for (size_t i = 0; i < Max_Particles; ++i){ \n    if (m_texture[i].empty()) { continue; } \n    m_textureManager->ReleaseResource(m_texture[i]); \n  } \n} \n\n```", "```cpp\nvoid Reset(){ \n  for (size_t i = 0; i < Max_Particles; ++i) { ResetParticle(i); } \n  m_countAlive = 0; \n} \n\n```", "```cpp\nvoid Enable(size_t l_id){ \n  if (m_countAlive >= Max_Particles) { return; } \n  m_alive[l_id] = true; \n  Swap(l_id, m_countAlive); \n  ++m_countAlive; \n} \n\nvoid Disable(size_t l_id){ \n  if (!m_countAlive) { return; } \n  ResetParticle(l_id); \n  Swap(l_id, m_countAlive - 1); \n  --m_countAlive; \n} \n\n```", "```cpp\nvoid Swap(size_t l_first, size_t l_second) { \n  std::swap(m_position[l_first], m_position[l_second]); \n  std::swap(m_velocity[l_first], m_velocity[l_second]); \n  std::swap(m_acceleration[l_first], m_acceleration[l_second]); \n  std::swap(m_startSize[l_first], m_startSize[l_second]); \n  ... \n} \n\n```", "```cpp\nvoid ResetParticle(size_t l_id){ \n  m_alive[l_id] = false; \n  m_gravity[l_id] = false; \n  m_addBlend[l_id] = false; \n  m_lifespan[l_id] = 0.f; \n  m_maxLifespan[l_id] = 0.f; \n  m_position[l_id] = { 0.f, 0.f, 0.f }; \n  m_velocity[l_id] = { 0.f, 0.f, 0.f }; \n  m_acceleration[l_id] = { 0.f, 0.f, 0.f }; \n  m_startRotation[l_id] = 0.f; \n  m_currentRotation[l_id] = 0.f; \n  m_finalRotation[l_id] = 0.f; \n  m_startSize[l_id] = { 0.f, 0.f }; \n  m_currentSize[l_id] = { 0.f, 0.f }; \n  m_finalSize[l_id] = { 0.f, 0.f }; \n  m_startColor[l_id] = { 0, 0, 0, 0 }; \n  m_currentColor[l_id] = { 0, 0, 0, 0 }; \n  m_finalColor[l_id] = { 0, 0, 0, 0 }; \n  if (!m_texture[l_id].empty()){ \n    m_textureManager->ReleaseResource(m_texture[l_id]); \n    m_texture[l_id].clear(); \n    m_drawable[l_id].setTexture(nullptr); \n  } \n} \n\n```", "```cpp\nclass BaseGenerator { \npublic: \n  virtual ~BaseGenerator() {} \n  virtual void Generate(Emitter* l_emitter, \n    ParticleContainer* l_particles, size_t l_from, size_t l_to)=0; \n  friend std::stringstream& operator >> ( \n    std::stringstream& l_stream, BaseGenerator& b) \n  { \n    b.ReadIn(l_stream); \n    return l_stream; \n  } \n\n  virtual void ReadIn(std::stringstream& l_stream){} \n}; \n\n```", "```cpp\nclass Emitter { \npublic: \n  Emitter(const sf::Vector3f& l_position,int l_maxParticles = -1); \n  void Update(float l_dT, ParticleContainer* l_particles); \n  void SetPosition(const sf::Vector3f& l_position); \n  sf::Vector3f GetPosition() const; \n  size_t GetEmitRate() const; \n  void SetEmitRate(size_t l_nPerSecond); \n  void SetParticleSystem(ParticleSystem* l_system); \n  void SetGenerators(const std::string& l_generators); \n  std::string GetGenerators() const; \n  ParticleSystem* GetParticleSystem() const; \nprivate: \n  std::string m_generators; \n  size_t m_emitRate; \n  int m_maxParticles; \n  sf::Vector3f m_position; \n  float m_accumulator; \n  ParticleSystem* m_system; \n}; \n\n```", "```cpp\nEmitter::Emitter(const sf::Vector3f& l_position, \n  int l_maxParticles) : m_position(l_position),  \n  m_maxParticles(l_maxParticles), m_emitRate(0), \n  m_accumulator(0.f), m_system(nullptr){} \n\n```", "```cpp\nvoid Emitter::Update(float l_dT, ParticleContainer* l_particles){ \n  if (m_generators.empty()) { return; } \n  auto generatorList = m_system->GetGenerators(m_generators); \n  if (!generatorList) { return; } \n  m_accumulator += l_dT * m_emitRate; \n  if (m_accumulator < 1.f) { return; } \n  auto num_particles = static_cast<int>(m_accumulator); \n  m_accumulator -= num_particles; \n  if (m_maxParticles != -1) { \n    if (num_particles > m_maxParticles) { \n      num_particles = m_maxParticles; \n      m_maxParticles = 0; \n    } \n    else { m_maxParticles -= num_particles; } \n  } \n  size_t from = l_particles->m_countAlive; \n  size_t to = (l_particles->m_countAlive + num_particles > \n    l_particles->Max_Particles ? l_particles->Max_Particles - 1 \n    : l_particles->m_countAlive + num_particles - 1); \n\n  for (auto& generator : *generatorList){ \n    generator->Generate(this, l_particles, from, to); \n  } \n  for (auto i = from; i <= to; ++i){ l_particles->Enable(i); } \n  if (!m_maxParticles) { m_system->RemoveEmitter(this); } \n} \n\n```", "```cpp\nclass BaseUpdater { \npublic: \n  virtual ~BaseUpdater() {} \n  virtual void Update(float l_dT, \n    ParticleContainer* l_particles) = 0; \n}; \n\n```", "```cpp\nstruct ForceApplicator { \n  ForceApplicator(const sf::Vector3f& l_center, \n    const sf::Vector3f& l_force, float l_radius) \n    : m_center(l_center), m_force(l_force), m_radius(l_radius){} \n  sf::Vector3f m_center; \n  sf::Vector3f m_force; \n  float m_radius; \n}; \n\n```", "```cpp\nusing Updaters = std::unordered_map<std::string, \n  std::unique_ptr<BaseUpdater>>; \nusing EmitterList = std::vector<std::unique_ptr<Emitter>>; \nusing Emitters = std::unordered_map<StateType, EmitterList>; \nusing GeneratorList = std::vector<std::unique_ptr<BaseGenerator>>; \nusing Generators = std::unordered_map<std::string,GeneratorList>; \nusing RemovedEmitters = std::vector<Emitter*>; \nusing Particles = std::unordered_map<StateType, \n  std::unique_ptr<ParticleContainer>>; \nusing ForceApplicatorList = std::vector<ForceApplicator>; \nusing ForceApplicators = std::unordered_map<StateType, \n  ForceApplicatorList>; \n\nusing GeneratorFactory = std::unordered_map<std::string, \n  std::function<BaseGenerator*(void)>>; \n\n```", "```cpp\nclass ParticleSystem : public FileLoader, public StateDependent, \n  public MapLoadee \n{ \npublic: \n  ParticleSystem(StateManager* l_stateManager, \n    TextureManager* l_textureMgr, RandomGenerator* l_rand, \n    Map* l_map); \n  void AddEmitter(std::unique_ptr<Emitter> l_emitter, \n    const StateType& l_state = StateType(0)); \n  void AddForce(ForceApplicator l_force, \n    const StateType& l_state = StateType(0)); \n  void RemoveEmitter(Emitter* l_emitter); \n\n  GeneratorList* GetGenerators(const std::string& l_name); \n\n  TextureManager* GetTextureManager() const; \n  RandomGenerator* GetRand() const; \n\n  void CreateState(const StateType& l_state); \n  void ChangeState(const StateType& l_state); \n  void RemoveState(const StateType& l_state); \n\n  void ReadMapLine(const std::string& l_type, \n    std::stringstream& l_stream); \n\n  void Update(float l_dT); \n  void ApplyForce(const sf::Vector3f& l_center, \n    const sf::Vector3f& l_force, float l_radius); \n  void Draw(Window* l_window, int l_elevation); \nprivate: \n  bool ProcessLine(std::stringstream& l_stream); \n  void ResetForNextFile(); \n\n  template<class T> \n  void RegisterGenerator(const std::string& l_name) { ... } \n\n  std::string m_loadingGenerator; \n  Particles m_container; \n  Particles::iterator m_stateItr; \n  Emitters::iterator m_emitterItr; \n  Updaters m_updaters; \n  Emitters m_emitters; \n  Generators m_generators; \n  GeneratorFactory m_factory; \n  ForceApplicators m_forces; \n  RemovedEmitters m_removedEmitters; \n  TextureManager* m_textureMgr; \n  RandomGenerator* m_rand; \n  Map* m_map; \n}; \n\n```", "```cpp\nParticleSystem::ParticleSystem(StateManager* l_stateManager, \n  TextureManager* l_textureManager, RandomGenerator* l_rand, \n  Map* l_map) \n  : m_stateManager(l_stateManager),m_textureMgr(l_textureManager), \n  m_rand(l_rand), m_map(l_map) \n{ \n  m_updaters.emplace(\"Lifespan\", \n    std::make_unique<LifespanUpdater>()); \n  ... \n  RegisterGenerator<PointPosition>(\"PointPosition\"); \n  ... \n} \n\n```", "```cpp\nvoid ParticleSystem::AddEmitter( \n  std::unique_ptr<Emitter> l_emitter, const StateType& l_state) \n{ \n  l_emitter->SetParticleSystem(this); \n  if (!GetGenerators(l_emitter->GetGenerators())) {  \n    return;  \n  } \n  if (l_state == StateType(0)) { \n    if (m_emitterItr == m_emitters.end()) { return; } \n    m_emitterItr->second.emplace_back(std::move(l_emitter)); \n    return; \n  } \n  auto itr = m_emitters.find(l_state); \n  if (itr == m_emitters.end()) { return; } \n  itr->second.emplace_back(std::move(l_emitter)); \n} \n\n```", "```cpp\nvoid ParticleSystem::AddForce(ForceApplicator l_force, \n  const StateType& l_state) \n{ \n  if (l_state == StateType(0)) { \n    if (m_stateItr == m_container.end()) { return; } \n    m_forces[m_currentState].emplace_back(l_force); \n    return; \n  } \n  auto itr = m_forces.find(l_state); \n  if(itr == m_forces.end()) { return; } \n  itr->second.emplace_back(l_force); \n} \n\n```", "```cpp\nvoid ParticleSystem::RemoveEmitter(Emitter* l_emitter) { \n  m_removedEmitters.push_back(l_emitter); \n} \n\n```", "```cpp\nGeneratorList* ParticleSystem::GetGenerators( \n  const std::string& l_name) \n{ \n  auto& itr = m_generators.find(l_name); \n  if (itr == m_generators.end()) { \n    return nullptr; \n  } \n  return &itr->second; \n} \n\n```", "```cpp\nvoid ParticleSystem::CreateState(const StateType& l_state) { \n  if (m_container.find(l_state) != m_container.end()) { return; } \n  m_container.emplace(l_state, \n    std::make_unique<ParticleContainer>(m_textureMgr)); \n  m_emitters.emplace(l_state, EmitterList()); \n  m_forces.emplace(l_state, ForceApplicatorList()); \n  ChangeState(l_state); \n} \n\n```", "```cpp\nvoid ParticleSystem::ChangeState(const StateType& l_state) { \n  SetState(l_state); \n  m_stateItr = m_container.find(m_currentState); \n  m_emitterItr = m_emitters.find(m_currentState); \n\n  auto c = static_cast<CollisionUpdater*>( \n    m_updaters[\"Collision\"].get()); \n  if (l_state == StateType::Game) { c->SetMap(m_map); } \n  else { c->SetMap(nullptr); } \n  auto f = static_cast<ForceUpdater*>(m_updaters[\"Force\"].get()); \n  auto& forceItr = m_forces.find(m_currentState); \n  if (forceItr == m_forces.end()) { \n    f->SetApplicators(nullptr); return; \n  } \n  f->SetApplicators(&forceItr->second); \n} \n\n```", "```cpp\nvoid ParticleSystem::RemoveState(const StateType& l_state) { \n  if (m_stateItr->first == l_state) { \n    m_stateItr = m_container.end(); \n    m_emitterItr = m_emitters.end(); \n  } \n  m_emitters.erase(l_state); \n  m_forces.erase(l_state); \n  m_container.erase(l_state); \n} \n\n```", "```cpp\nbool ParticleSystem::ProcessLine(std::stringstream& l_stream) { \n  std::string type; \n  l_stream >> type; \n  if (type == \"Name\") { \n    if (!(l_stream >> m_loadingGenerator)) { return false; } \n    auto generators = GetGenerators(m_loadingGenerator); \n    if (generators) { return false; } \n  } else { \n    if (m_loadingGenerator.empty()) { return false; } \n    auto itr = m_factory.find(type); \n    if (itr == m_factory.end()) { return true; } \n    std::unique_ptr<BaseGenerator> generator(itr->second()); \n    l_stream >> *generator; \n    m_generators[m_loadingGenerator].emplace_back( \n      std::move(generator)); \n  } \n  return true; \n} \n\n```", "```cpp\nvoid ParticleSystem::ResetForNextFile() { \n  m_loadingGenerator.clear(); \n} \n\n```", "```cpp\nvoid ParticleSystem::ReadMapLine(const std::string& l_type, \n  std::stringstream& l_stream) \n{ \n  if (l_type == \"ParticleEmitter\") { \n    sf::Vector3f position; \n    size_t emitRate; \n    std::string generatorType; \n    l_stream >> generatorType >> position.x >> position.y >> \n      position.z >> emitRate; \n    auto emitter = std::make_unique<Emitter>(position); \n    emitter->SetEmitRate(emitRate); \n    emitter->SetGenerators(generatorType); \n    AddEmitter(std::move(emitter), StateType::Game); \n  } else if (l_type == \"ForceApplicator\") { \n    sf::Vector3f position; \n    sf::Vector3f force; \n    float radius; \n    l_stream >> position.x >> position.y >> position.z >> \n      force.x >> force.y >> force.z >> radius; \n    AddForce(ForceApplicator(position, force, radius), \n      StateType::Game); \n  } \n} \n\n```", "```cpp\nvoid ParticleSystem::Update(float l_dT) { \n  if (m_stateItr == m_container.end()) { return; } \n  for (auto& emitter : m_emitterItr->second) { \n    emitter->Update(l_dT, m_stateItr->second.get()); \n  } \n  for (auto& updater : m_updaters){ \n    updater.second->Update(l_dT, m_stateItr->second.get()); \n  } \n  if (!m_removedEmitters.size()) { return; } \n  for (auto& removed : m_removedEmitters) { \n    m_emitterItr->second.erase( \n      std::remove_if( \n        m_emitterItr->second.begin(), \n        m_emitterItr->second.end(), \n        [removed](std::unique_ptr<Emitter>& emitter) { \n          return emitter.get() == removed; \n        } \n    )); \n  } \n  m_removedEmitters.clear(); \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(Window* l_window, int l_elevation) { \n  if (m_stateItr == m_container.end()) { return; } \n  auto container = m_stateItr->second.get(); \n  auto& drawables = container->m_drawable; \n  auto& positions = container->m_position; \n  auto& blendModes = container->m_addBlend; \n  auto view = l_window->GetRenderWindow()->getView(); \n  auto renderer = l_window->GetRenderer(); \n\n  auto state = m_stateManager->GetCurrentStateType(); \n  if (state == StateType::Game || state == StateType::MapEditor) { \n    renderer->UseShader(\"default\"); \n  } else { \n    renderer->DisableShader(); \n  } \n\n  for (size_t i = 0; i < container->m_countAlive; ++i) { \n    if (l_elevation >= 0) { \n      if (positions[i].z < l_elevation * Sheet::Tile_Size) { \n        continue; \n      } \n      if (positions[i].z >= (l_elevation + 1) * Sheet::Tile_Size){ \n        continue; \n      } \n    } else if (positions[i].z < \n      Sheet::Num_Layers * Sheet::Tile_Size) \n    { continue; } \n    renderer->AdditiveBlend(blendModes[i]); \n    renderer->Draw(drawables[i]); \n  } \n  renderer->AdditiveBlend(false); \n} \n\n```", "```cpp\nclass SpatialUpdater : public BaseUpdater { \npublic: \n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& velocities = l_particles->m_velocity; \n    auto& accelerations = l_particles->m_acceleration; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      velocities[i] += accelerations[i] * l_dT; \n    } \n    auto& positions = l_particles->m_position; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      positions[i] += velocities[i] * l_dT; \n    } \n  } \n}; \n\n```", "```cpp\nclass DrawableUpdater : public BaseUpdater { \npublic: \n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& positions = l_particles->m_position; \n    auto& drawables = l_particles->m_drawable; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      drawables[i].setPosition(positions[i].x, positions[i].y); \n    } \n    auto& sizes = l_particles->m_currentSize; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      drawables[i].setSize(sizes[i]); \n    } \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      float ScaleFactor = std::max( \n        (positions[i].z / Sheet::Tile_Size) * \n        ScaleToElevationRatio, 1.f); \n      drawables[i].setScale(ScaleFactor, ScaleFactor); \n    } \n    auto& colors = l_particles->m_currentColor; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      drawables[i].setFillColor(colors[i]); \n    } \n    auto& rotations = l_particles->m_currentRotation; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      drawables[i].setRotation(rotations[i]); \n    } \n\n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      drawables[i].setOrigin( \n        drawables[i].getLocalBounds().width / 2, \n        drawables[i].getLocalBounds().height / 2); \n    } \n  } \n  static const float ScaleToElevationRatio; \n}; \n\nconst float DrawableUpdater::ScaleToElevationRatio = 1.5f; \n\n```", "```cpp\nclass LifespanUpdater : public BaseUpdater { \npublic: \n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& lifespans = l_particles->m_lifespan; \n    auto& maxLifespans = l_particles->m_maxLifespan; \n    for (size_t i = 0; i < l_particles->m_countAlive;) { \n      lifespans[i] += l_dT; \n      if (lifespans[i] < maxLifespans[i]) { ++i; continue; } \n      l_particles->Disable(i); \n    } \n  } \n}; \n\n```", "```cpp\nclass Interpolator : public BaseUpdater { \npublic: \n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& startColors = l_particles->m_startColor; \n    auto& currentColors = l_particles->m_currentColor; \n    auto& finalColors = l_particles->m_finalColor; \n    auto& lifespans = l_particles->m_lifespan; \n    auto& maxLifespans = l_particles->m_maxLifespan; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (startColors[i] == finalColors[i]) { continue; } \n      currentColors[i].r = Utils::Interpolate<sf::Uint8>(0.f, \n        maxLifespans[i], startColors[i].r, finalColors[i].r, \n        lifespans[i]); \n      currentColors[i].g = Utils::Interpolate<sf::Uint8>(0.f, \n        maxLifespans[i], startColors[i].g, finalColors[i].g, \n        lifespans[i]); \n      currentColors[i].b = Utils::Interpolate<sf::Uint8>(0.f, \n        maxLifespans[i], startColors[i].b, finalColors[i].b, \n        lifespans[i]); \n      currentColors[i].a = Utils::Interpolate<sf::Uint8>(0.f, \n        maxLifespans[i], startColors[i].a, finalColors[i].a, \n        lifespans[i]); \n    } \n\n    auto& startRotations = l_particles->m_startRotation; \n    auto& currentRotations = l_particles->m_currentRotation; \n    auto& finalRotations = l_particles->m_finalRotation; \n\n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (startRotations[i] == finalRotations[i]) { continue; } \n      currentRotations[i] = Utils::Interpolate<float>(0.f, \n        maxLifespans[i], startRotations[i], finalRotations[i], \n        lifespans[i]); \n    } \n\n    auto& startSizes = l_particles->m_startSize; \n    auto& currentSizes = l_particles->m_currentSize; \n    auto& finalSizes = l_particles->m_finalSize; \n\n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (startSizes[i] == finalSizes[i]) { continue; } \n      currentSizes[i] = sf::Vector2f( \n        Utils::Interpolate<float>(0.f, maxLifespans[i], \n          startSizes[i].x, finalSizes[i].x, lifespans[i]), \n        Utils::Interpolate<float>(0.f, maxLifespans[i], \n          startSizes[i].y, finalSizes[i].y, lifespans[i])); \n    } \n  } \n}; \n\n```", "```cpp\nclass ForceUpdater : public BaseUpdater { \n  friend class ParticleSystem; \npublic: \n  ForceUpdater() : m_applicators(nullptr) {} \n\n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& velocities = l_particles->m_velocity; \n    auto& gravity = l_particles->m_gravity; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (!gravity[i]) { continue; } \n      velocities[i].z -= Gravity * l_dT; \n    } \n\n    if (!m_applicators) { return; } \n    auto& positions = l_particles->m_position; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      for (auto& force : *m_applicators) { \n        Force(force.m_center, force.m_force * l_dT, \n          force.m_radius, positions[i], velocities[i]); \n      } \n    } \n  } \n\n  void SetApplicators(ForceApplicatorList* l_list) { \n    m_applicators = l_list; \n  } \n\n  static const float Gravity; \nprivate: \n  void Force(const sf::Vector3f& l_center, \n    const sf::Vector3f& l_force, float l_radius, \n    sf::Vector3f& l_position, sf::Vector3f& l_velocity) \n  { ... } \n\n  ForceApplicatorList* m_applicators; \n}; \n\nconst float ForceUpdater::Gravity = 128.f; \n\n```", "```cpp\nvoid Force(const sf::Vector3f& l_center, \n  const sf::Vector3f& l_force, float l_radius, \n  sf::Vector3f& l_position, sf::Vector3f& l_velocity) \n{ \n  sf::Vector3f from(l_center.x - l_radius, \n    l_center.y - l_radius, l_center.z - l_radius); \n  sf::Vector3f to(l_center.x + l_radius, \n    l_center.y + l_radius, l_center.z + l_radius); \n  if (l_position.x < from.x) { return; } \n  if (l_position.y < from.y) { return; } \n  if (l_position.z < from.z) { return; } \n  if (l_position.x > to.x) { return; } \n  if (l_position.y > to.y) { return; } \n  if (l_position.z > to.z) { return; } \n\n  sf::Vector3f distance = l_center - l_position; \n  sf::Vector3f a_distance = sf::Vector3f(std::abs(distance.x), \n    std::abs(distance.y), std::abs(distance.z)); \n  float magnitude = std::sqrt(std::pow(a_distance.x, 2) + \n    std::pow(a_distance.y, 2) + std::pow(a_distance.z, 2)); \n  sf::Vector3f normal = sf::Vector3f( \n    a_distance.x / magnitude, \n    a_distance.y / magnitude, \n    a_distance.z / magnitude \n  ); \n  sf::Vector3f loss = sf::Vector3f( \n    std::abs(l_force.x) / (l_radius / a_distance.x), \n    std::abs(l_force.y) / (l_radius / a_distance.y), \n    std::abs(l_force.z) / (l_radius / a_distance.z) \n  ); \n  sf::Vector3f applied = sf::Vector3f( \n    (l_force.x > 0 ? l_force.x - loss.x : l_force.x + loss.x), \n    (l_force.y > 0 ? l_force.y - loss.y : l_force.y + loss.y), \n    (l_force.z > 0 ? l_force.z - loss.z : l_force.z + loss.z) \n  ); \n  applied.x *= normal.x; \n  applied.y *= normal.y; \n  applied.z *= normal.z; \n  if (distance.x < 0) { applied.x = -applied.x; } \n  if (distance.y < 0) { applied.y = -applied.y; } \n  if (distance.z < 0) { applied.z = -applied.z; } \n\n  l_velocity += applied; \n} \n\n```", "```cpp\nvoid ParticleSystem::ApplyForce(const sf::Vector3f& l_center, \n  const sf::Vector3f& l_force, float l_radius) \n{ \n  if (m_stateItr == m_container.end()) { return; } \n  auto f = static_cast<ForceUpdater*>(m_updaters[\"Force\"].get()); \n  auto container = m_stateItr->second.get(); \n  auto& positions = container->m_position; \n  auto& velocities = container->m_velocity; \n  for (size_t i = 0; i < container->m_countAlive; ++i) { \n    f->Force(l_center, l_force, l_radius, \n      positions[i], velocities[i]); \n  } \n} \n\n```", "```cpp\nclass CollisionUpdater : public BaseUpdater { \npublic: \n  void Update(float l_dT, ParticleContainer* l_particles) { \n    auto& positions = l_particles->m_position; \n    auto& velocities = l_particles->m_velocity; \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (positions[i].z > 0.f) { continue; } \n      positions[i].z = 0.f; \n      velocities[i].z = 0.f; \n    } \n\n    if (!m_map) { return; } \n    for (size_t i = 0; i < l_particles->m_countAlive; ++i) { \n      if (positions[i].z > 0.f) { continue; } \n      ApplyFriction(l_dT, positions[i], velocities[i]); \n    } \n  } \n  void SetMap(Map* l_map) { m_map = l_map; } \nprivate: \n  void ApplyFriction(float l_dT, sf::Vector3f& l_position, \n    sf::Vector3f& l_velocity) { ... } \n  Map* m_map; \n}; \n\n```", "```cpp\nvoid ApplyFriction(float l_dT, sf::Vector3f& l_position, \n  sf::Vector3f& l_velocity) \n{ \n  sf::Vector2i tileCoords = sf::Vector2i( \n    static_cast<int>(floor(l_position.x / Sheet::Tile_Size)), \n    static_cast<int>(floor(l_position.y / Sheet::Tile_Size))); \n  auto tile = m_map->GetTile(tileCoords.x, tileCoords.y, 0); \n  sf::Vector2f friction; \n  if (!tile) { friction = m_map->GetDefaultTile()->m_friction; } \n  else { friction = tile->m_properties->m_friction; } \n  friction.x *= std::abs(l_velocity.x); \n  friction.y *= std::abs(l_velocity.y); \n  friction *= l_dT; \n  if (l_velocity.x != 0.f && friction.x != 0.f) { \n    if (std::abs(l_velocity.x) - std::abs(friction.x) < 0.f) { \n      l_velocity.x = 0.f; \n    } else { \n      l_velocity.x += (l_velocity.x > 0.f ? \n        friction.x * -1.f : friction.x); \n    } \n  } \n\n  if (l_velocity.y != 0.f && friction.y != 0.f) { \n    if (std::abs(l_velocity.y) - std::abs(friction.y) < 0.f) { \n      l_velocity.y = 0.f; \n    } else { \n      l_velocity.y += (l_velocity.y > 0.f ? \n        friction.y * -1.f : friction.y); \n    } \n  } \n} \n\n```", "```cpp\nclass PointPosition : public BaseGenerator { \npublic: \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& positions = l_particles->m_position; \n    auto center = l_emitter->GetPosition(); \n    for (auto i = l_from; i <= l_to; ++i) {positions[i] = center;} \n  } \n}; \n\n```", "```cpp\nclass AreaPosition : public BaseGenerator { \npublic: \n  AreaPosition() = default; \n  AreaPosition(const sf::Vector3f& l_deviation) \n    : m_deviation(l_deviation) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& positions = l_particles->m_position; \n    auto center = l_emitter->GetPosition(); \n    auto rangeFrom = sf::Vector3f(center.x - m_deviation.x, \n      center.y - m_deviation.y, center.z - m_deviation.z); \n    auto rangeTo = sf::Vector3f(center.x + m_deviation.x, \n      center.y + m_deviation.y, center.z + m_deviation.z); \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    for (auto i = l_from; i <= l_to; ++i) { \n      positions[i] = sf::Vector3f( \n        rand(rangeFrom.x, rangeTo.x), \n        rand(rangeFrom.y, rangeTo.y), \n        rand(rangeFrom.z, rangeTo.z) \n      ); \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_deviation.x >> m_deviation.y >> m_deviation.z; \n  } \nprivate: \n  sf::Vector3f m_deviation; \n}; \n\n```", "```cpp\nenum class LineAxis{ x, y, z }; \n\nclass LinePosition : public BaseGenerator { \npublic: \n  LinePosition() : m_axis(LineAxis::x), m_deviation(0.f) {} \n  LinePosition(LineAxis l_axis, float l_deviation) \n    : m_axis(l_axis), m_deviation(l_deviation) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& positions = l_particles->m_position; \n    auto center = l_emitter->GetPosition(); \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    for (auto i = l_from; i <= l_to; ++i) { \n      if (m_axis == LineAxis::x) { \n        center.x = rand(center.x - m_deviation, \n          center.x + m_deviation); \n      } else if (m_axis == LineAxis::y) { \n        center.y = rand(center.y - m_deviation, \n          center.y + m_deviation); \n      } else { \n        center.z = rand(center.z - m_deviation, \n          center.z + m_deviation); } \n      positions[i] = center; \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    std::string axis; \n    l_stream >> axis >> m_deviation; \n    if (axis == \"x\") { m_axis = LineAxis::x; } \n    else if (axis == \"y\") { m_axis = LineAxis::y; } \n    else if (axis == \"z\") { m_axis = LineAxis::z; } \n    else { std::cout << \"Faulty axis: \" << axis << std::endl; } \n  } \nprivate: \n  LineAxis m_axis; \n  float m_deviation; \n}; \n\n```", "```cpp\nclass PropGenerator : public BaseGenerator { \npublic: \n  PropGenerator(bool l_gravity = true, bool l_additive = false) \n    : m_gravity(l_gravity), m_additive(l_additive) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& gravity = l_particles->m_gravity; \n    for (auto i = l_from; i <= l_to; ++i) { \n      gravity[i] = m_gravity; \n    } \n    auto& additive = l_particles->m_addBlend; \n    for (auto i = l_from; i <= l_to; ++i) { \n      additive[i] = m_additive; \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    int gravity = 1; \n    int additive = 0; \n    l_stream >> gravity >> additive; \n    m_gravity = (gravity != 0); \n    m_additive = (additive != 0); \n  } \nprivate: \n  bool m_gravity; \n  bool m_additive; \n}; \n\n```", "```cpp\nclass RandomColor : public BaseGenerator { \npublic: \n  RandomColor() = default; \n  RandomColor(const sf::Vector3i& l_from,const sf::Vector3i& l_to) \n    : m_from(l_from), m_to(l_to) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    auto& colors = l_particles->m_currentColor; \n    for (auto i = l_from; i <= l_to; ++i) { \n      sf::Color target{ \n        static_cast<sf::Uint8>(rand(m_from.x, m_to.x)), \n        static_cast<sf::Uint8>(rand(m_from.y, m_to.y)), \n        static_cast<sf::Uint8>(rand(m_from.z, m_to.z)), \n        255 \n      }; \n      colors[i] = target; \n    } \n  } \n   void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_from.x >> m_to.x >> m_from.y >> m_to.y >> \n      m_from.z >> m_to.z; \n  } \nprivate: \n  sf::Vector3i m_from; \n  sf::Vector3i m_to; \n}; \n\n```", "```cpp\nclass ColorRange : public BaseGenerator { \npublic: \n  ColorRange() = default; \n  ColorRange(const sf::Color& l_start, const sf::Color& l_finish) \n    : m_start(l_start), m_finish(l_finish) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& beginning = l_particles->m_startColor; \n    auto& current = l_particles->m_currentColor; \n    auto& ending = l_particles->m_finalColor; \n    for (auto i = l_from; i <= l_to; ++i) { \n      beginning[i] = m_start; \n      current[i] = m_start; \n      ending[i] = m_finish; \n    } \n  } \n  void ReadIn(std::stringstream& l_stream) { \n    int s_r = 0, s_g = 0, s_b = 0, s_a = 0; \n    int f_r = 0, f_g = 0, f_b = 0, f_a = 0; \n    l_stream >> s_r >> s_g >> s_b >> s_a; \n    l_stream >> f_r >> f_g >> f_b >> f_a; \n\n    m_start = { \n      static_cast<sf::Uint8>(s_r), static_cast<sf::Uint8>(s_g), \n      static_cast<sf::Uint8>(s_b), static_cast<sf::Uint8>(s_a) \n    }; \n    m_finish = { \n      static_cast<sf::Uint8>(f_r), static_cast<sf::Uint8>(f_g), \n      static_cast<sf::Uint8>(f_b), static_cast<sf::Uint8>(f_a) \n    }; \n  } \nprivate: \n  sf::Color m_start; \n  sf::Color m_finish; \n}; \n\n```", "```cpp\nclass RandomLifespan : public BaseGenerator { \npublic: \n  RandomLifespan() : m_from(0.f), m_to(0.f) {} \n  RandomLifespan(float l_from, float l_to) \n    : m_from(l_from), m_to(l_to) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    auto& lifespans = l_particles->m_maxLifespan; \n    for (auto i = l_from; i <= l_to; ++i) { \n      lifespans[i] = rand(m_from, m_to); \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_from >> m_to; \n  } \nprivate: \n  float m_from; \n  float m_to; \n}; \n\n```", "```cpp\nclass RandomSize : public BaseGenerator { \npublic: \n  RandomSize() : m_from(0), m_to(0) {} \n  RandomSize(int l_from, int l_to): m_from(l_from), m_to(l_to) {} \n\n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    auto& sizes = l_particles->m_currentSize; \n    for (auto i = l_from; i <= l_to; ++i) { \n      float size = static_cast<float>(rand(m_from, m_to)); \n      sizes[i] = sf::Vector2f(size, size); \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_from >> m_to; \n  } \nprivate: \n  int m_from; \n  int m_to; \n}; \n\n```", "```cpp\nclass RandomVelocity : public BaseGenerator { \npublic: \n  RandomVelocity() = default; \n  RandomVelocity(const sf::Vector3f& l_from, \n    const sf::Vector3f& l_to) : m_from(l_from), m_to(l_to) {} \n\n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& rand = *l_emitter->GetParticleSystem()->GetRand(); \n    auto& velocities = l_particles->m_velocity; \n    for (auto i = l_from; i <= l_to; ++i) { \n      sf::Vector3f target{ \n        rand(m_from.x, m_to.x), \n        rand(m_from.y, m_to.y), \n        rand(m_from.z, m_to.z) \n      }; \n      velocities[i] = target; \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_from.x >> m_to.x >> m_from.y >> m_to.y >> \n    m_from.z >> m_to.z; \n  } \nprivate: \n  sf::Vector3f m_from; \n  sf::Vector3f m_to; \n}; \n\n```", "```cpp\nclass RotationRange : public BaseGenerator { \npublic: \n  RotationRange() : m_start(0.f), m_finish(0.f) {} \n  RotationRange(float l_start, float l_finish) \n    : m_start(l_start), m_finish(l_finish) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    auto& beginning = l_particles->m_startRotation; \n    auto& ending = l_particles->m_finalRotation; \n    for (auto i = l_from; i <= l_to; ++i) { \n      beginning[i] = m_start; \n      ending[i] = m_finish; \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_start >> m_finish; \n  } \nprivate: \n  float m_start; \n  float m_finish; \n}; \n\n```", "```cpp\nclass SizeRange : public BaseGenerator { \npublic: \n  SizeRange() : m_start(0), m_finish(0) {} \n  SizeRange(float l_start, float l_finish) \n    : m_start(l_start), m_finish(l_finish) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    if (m_start == m_finish) { \n      auto& sizes = l_particles->m_currentSize; \n      for (auto i = l_from; i <= l_to; ++i) { \n        sizes[i] = sf::Vector2f(m_start, m_start); \n      } \n    } else { \n      auto& beginning = l_particles->m_startSize; \n      auto& ending = l_particles->m_finalSize; \n      for (auto i = l_from; i <= l_to; ++i) { \n        beginning[i] = sf::Vector2f(m_start, m_start); \n        ending[i] = sf::Vector2f(m_finish, m_finish); \n      } \n    } \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    l_stream >> m_start >> m_finish; \n  } \nprivate: \n  float m_start; \n  float m_finish; \n}; \n\n```", "```cpp\nclass TextureGenerator : public BaseGenerator { \npublic: \n  TextureGenerator() = default; \n  TextureGenerator(const std::string& l_texture) \n    : m_texture(l_texture) {} \n  void Generate(Emitter* l_emitter,ParticleContainer* l_particles, \n    size_t l_from, size_t l_to) \n  { \n    if (m_texture.empty()) { return; } \n    TextureManager* manager = l_emitter-> \n      GetParticleSystem()->GetTextureManager(); \n    if (!manager->RequireResource(m_texture)) { return; } \n    auto& textures = l_particles->m_texture; \n    auto& drawables = l_particles->m_drawable; \n    auto resource = manager->GetResource(m_texture); \n    auto size = resource->getSize(); \n    for (auto i = l_from; i <= l_to; ++i) { \n      textures[i] = m_texture; \n      manager->RequireResource(m_texture); \n      drawables[i].setTexture(resource); \n      drawables[i].setTextureRect(sf::IntRect(0,0,size.x,size.y)); \n    } \n    manager->ReleaseResource(m_texture); \n  } \n\n  void ReadIn(std::stringstream& l_stream){l_stream >> m_texture;} \nprivate: \n  std::string m_texture; \n}; \n\n```", "```cpp\nvoid Game::SetUpStates() { \n  ... \n  m_stateManager->AddDependent(m_particles.get()); \n  ... \n} \n\nvoid Game::SetUpClasses() { \n  ... \n  m_gameMap.AddLoadee(m_particles.get()); \n} \n\n```", "```cpp\nName MenuFlame \nPointPosition \nSizeRange 32 8 \n|ColorRange 255 255 0 100 0 255 255 0 \nRandomColor 100 255 100 255 100 255 \nRandomLifespan 6 6 \nRandomVelocity -10 10 -50 -80 5 10 \nRotationRange 0 45 \nTexture Flame \nProperties 0 1 \n\n```", "```cpp\nvoid State_MainMenu::OnCreate() { \n  ... \n  auto w_size = context->m_wind->GetWindowSize(); \n  context->m_particles->CreateState(StateType::MainMenu); \n  auto emitter = std::make_unique<Emitter>(sf::Vector3f( \n    static_cast<float>(w_size.x) / 3.f, \n    static_cast<float>(w_size.y) - 64.f, \n    33.f)); \n  emitter->SetEmitRate(25); \n  emitter->SetGenerators(\"MenuFlame\"); \n  context->m_particles->AddEmitter(std::move(emitter)); \n  emitter = std::make_unique<Emitter>(sf::Vector3f( \n    (static_cast<float>(w_size.x) / 3.f) * 2.f, \n    static_cast<float>(w_size.y) - 64.f, \n    33.f)); \n  emitter->SetEmitRate(25); \n  emitter->SetGenerators(\"MenuFlame\"); \n  context->m_particles->AddEmitter(std::move(emitter)); \n  emitter = std::make_unique<Emitter>(sf::Vector3f( \n    0.f, \n    static_cast<float>(w_size.y) / 2.f, \n    0.f)); \n  emitter->SetEmitRate(60); \n  emitter->SetGenerators(\"MenuSmoke\"); \n  context->m_particles->AddEmitter(std::move(emitter)); \n  auto f = ForceApplicator( \n    sf::Vector3f(static_cast<float>(w_size.x) / 2.f, \n      static_cast<float>(w_size.y) / 2.f, 64.f), \n    sf::Vector3f(500.f, 500.f, 500.f), 256.f); \n  context->m_particles->AddForce(f); \n} \n\n```", "```cpp\nvoid State_MainMenu::Update(const sf::Time& l_dT) { \n  m_stateMgr->GetContext()->m_particles->Update(l_dT.asSeconds()); \n} \n\n```", "```cpp\nvoid State_MainMenu::Draw() { \n  auto context = m_stateMgr->GetContext(); \n  for (unsigned int i = 0; i < Sheet::Num_Layers; ++i) { \n    m_stateMgr->GetContext()->m_particles->Draw( \n      *m_stateMgr->GetContext()->m_wind, i); \n  } \n  m_stateMgr->GetContext()->m_particles->Draw( \n    *m_stateMgr->GetContext()->m_wind, -1); \n} \n\n```"]