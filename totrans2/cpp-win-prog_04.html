<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with Shapes and Figures</h1></div></div></div><p>In this chapter, we develop a program capable of drawing lines, arrows, rectangles, and ellipses. The application can be viewed as a more advanced version of the circle application. Similar to the circle application, we have a list of figures and we catch the user's mouse actions. However, there are four different kinds of figures: lines, arrows, rectangles, and ellipses. They are defined in a class hierarchy that is similar to but more advanced than the hierarchy in the Tetris game. Moreover, we also introduce cut, copy, paste, cursor control, and registry handling:</p><p>
</p><div><img src="img/image_04_001.jpg" alt="Working with Shapes and Figures"/></div><p>
</p><p>The user can add new figures, move one or several figures, modify figures by grabbing their endpoints, mark and unmark figures by pressing the mouse button and the <em>Ctrl</em> key, and mark several figures by enclosing them by a rectangle. When a figure is marked, it becomes annotated with small black squares. The user can modify the shape of a figure by grabbing one of the squares. The user can also move a figure by grabbing some other part of the figure.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec18"/>The MainWindow function</h1></div></div></div><p>The <code class="literal">MainWindow</code> function in this application is very similar to that in <a class="link" href="ch03.html" title="Chapter 3. Building a Tetris Application">Chapter 3</a>, <em>Building a Tetris Application</em>; it sets the application name and creates the main document window:</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "DrawFigure.h" &#13;
#include "LineFigure.h" &#13;
#include "ArrowFigure.h" &#13;
#include "RectangleFigure.h" &#13;
#include "EllipseFigure.h" &#13;
#include "TextFigure.h" &#13;
#include "DrawDocument.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, &#13;
                WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("DrawFigure"); &#13;
  Application::MainWindowPtr() = new DrawDocument(windowShow); &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec19"/>The DrawDocument class</h1></div></div></div><p>The <code class="literal">DrawDocument</code> class extends the <code class="literal">StandardDocument</code> framework, similar to the circle application. It catches the mouse events, overrides the file methods, implements cut, copy, and paste, as well as cursor handling:</p><p>
<strong>DrawDocument.h</strong>
</p><pre class="programlisting">class DrawDocument : public StandardDocument { &#13;
  public: &#13;
    DrawDocument(WindowShow windowShow); &#13;
    ~DrawDocument(); &#13;
</pre><p>Similar to the circle application, we catch mouse action with the <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseMove</code>, and <code class="literal">OnMouseUp</code> methods. However, in this application, we also catch double-clicks with the <code class="literal">OnDoubleClick</code> method. When the user double-clicks on a figure, it takes individual actions:</p><pre class="programlisting">    void OnMouseDown(MouseButton mouseButtons, Point mousePoint, &#13;
                     bool shiftPressed, bool controlPressed); &#13;
    void OnMouseMove(MouseButton mouseButtons, Point mousePoint, &#13;
                     bool shiftPressed, bool controlPressed); &#13;
    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint, &#13;
                       bool shiftPressed, bool controlPressed); &#13;
    void OnMouseUp(MouseButton mouseButtons, Point mousePoint, &#13;
                   bool shiftPressed, bool controlPressed); &#13;
</pre><p>The <code class="literal">OnDraw</code> method is called when the window's client area needs to be redrawn. It draws the figures, and the rectangle enclosing the figures, if the user is in the process of marking figures with a rectangle:</p><pre class="programlisting">    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
</pre><p>The <code class="literal">ClearDocument</code> method is called when the user selects the <strong>New</strong> menu item, the <code class="literal">ReadDocumentFromStream</code> method is called when they select the <strong>Open</strong> menu item, and the <code class="literal">WriteDocumentToStream</code> method is called when they select the <strong>Save</strong> or <strong>Save As</strong> menu item:</p><pre class="programlisting">    void ClearDocument(); &#13;
    bool WriteDocumentToStream(String name, ostream&amp; outstream) &#13;
                               const; &#13;
</pre><p>Each figure has an integer identity value that is written by the <code class="literal">WriteDocumentToStream</code> method and read by the <code class="literal">ReadDocumentFromStream</code> method to decide which figure has to be created. Given the identity value, the <code class="literal">CreateFigure</code> method creates the new figure:</p><pre class="programlisting">    bool ReadDocumentFromStream(String name, istream&amp; instream); &#13;
    DrawFigure* CreateFigure(FigureId figureId) const; &#13;
</pre><p>In this application, we introduce functionality for cut, copy, and paste. The <code class="literal">CopyGeneric</code> method is called when the user selects the <strong>Cut</strong> or <strong>Copy</strong> menu item in the <strong>Edit</strong> menu and the <code class="literal">PasteGeneric</code> method is called when the user selects the <strong>Paste</strong> menu item. In the <code class="literal">StandardDocument</code> framework, there are methods for cutting, copying, and pasting ASCII and Unicode text as well. However, we do not use them in this application:</p><pre class="programlisting">    bool IsCopyGenericReady(int /* format */) const; &#13;
    void CopyGeneric(int format, InfoList&amp; infoList) const; &#13;
    void PasteGeneric(int format, InfoList&amp; infoList); &#13;
</pre><p>The <code class="literal">CopyEnable</code> method returns <code class="literal">true</code> if information is ready to be copied. In that case, the <strong>Cut</strong>, <strong>Copy</strong>, and <strong>Delete</strong> menu items are enabled. In this application, we do not override the <code class="literal">PasteEnable</code> method, since the <code class="literal">StandardDocument</code> framework looks up whether there is a memory buffer in the global clipboard suitable to paste. The <code class="literal">OnDelete</code> method is called when the user selects the <strong>Delete</strong> menu item:</p><pre class="programlisting">    bool CopyEnable() const; &#13;
    void OnDelete(); &#13;
</pre><p>Similar to the circle application, we have a set of listeners, even though the set is larger in this case. Each listener is added to the menus in the constructor. Unlike the circle application, we also use enable methods: methods that are called before the menu item becomes visible. If the methods return <code class="literal">false</code>, the menu items become disabled and grayed. If the menu item is connected to an accelerator, the accelerator also becomes disabled. We place the <strong>Modify</strong>, <strong>Color</strong>, and <strong>Fill</strong> items in the <strong>Modify</strong> menu, and the <strong>Line</strong>, <strong>Arrow,</strong>
<strong>Rectangle</strong>, and <strong>Ellipse</strong> items in the <strong>Add</strong> menu:</p><pre class="programlisting">    DEFINE_BOOL_LISTENER(DrawDocument, ModifyEnable) &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, ModifyRadio) &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnModify) &#13;
 &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, ColorEnable) &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnColor) &#13;
 &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, FillEnable)&#13;
    DEFINE_BOOL_LISTENER(DrawDocument, FillCheck)&#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnFill) &#13;
 &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, LineEnable); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, ArrowEnable); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, RectangleEnable); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, EllipseEnable); &#13;
 &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, LineRadio); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, ArrowRadio); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, RectangleRadio); &#13;
    DEFINE_BOOL_LISTENER(DrawDocument, EllipseRadio); &#13;
 &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnLine); &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnArrow); &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnRectangle); &#13;
    DEFINE_VOID_LISTENER(DrawDocument, OnEllipse); &#13;
</pre><p>In this application, we also introduce cursor control. The <code class="literal">UpdateCursor</code> method sets the cursor to an appropriate appearance depending on whether the user is creating, modifying, or moving figures:</p><pre class="programlisting">    void UpdateCursor(); &#13;
</pre><p>One central point of this application is its mode: the <code class="literal">applicationMode</code> method keeps track of the actions when the user presses the left mouse button. It holds the following modes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Idle</code>: The application waits for input from the user. This is always the mode as long as the user does not press the left mouse button. However, when the user presses the mouse button, until they release it, the <code class="literal">applicationMode</code> method holds one value. The user presses the <em>Ctrl</em> key and clicks on an already marked figure. The figure becomes unmarked, nothing more happens.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModifySingle</code>: The user grabs one single figure that is being modified (if the user clicks on one of its endpoints) or moved (if the user clicks on any other part of the figure).</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModifyRectangle</code>: The user has clicked on the client area without hitting a figure, resulting in a rectangle being drawn. When the user releases the mouse button, every figure completely enclosed by the rectangle is marked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MoveMultiple</code>: The user presses the <em>Ctr</em>l key and clicks on an unmarked figure. It is not possible to modify more than one figure at the same time.</li></ul></div><p>Note that the <code class="literal">applicationMode</code> method is relevant only as long as the user presses the left mouse button. As soon as they release the mouse button, the <code class="literal">applicationMode</code> method is always <code class="literal">Idle</code>:</p><pre class="programlisting">  private: &#13;
    enum ApplicationMode {Idle, ModifySingle, &#13;
                          MoveMultiple, ModifyRectangle}; &#13;
    ApplicationMode applicationMode = Idle; &#13;
</pre><p>When the <code class="literal">applicationMode</code> method holds the <code class="literal">Idle</code> mode, the application waits for further input from the user. The <code class="literal">actionMode</code> field defines the next action, which may hold the following values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Modify</code>: When the user presses the mouse button, the <code class="literal">applicationMode</code> method is set to the <code class="literal">ModifySingle</code> mode if they click on a figure, the <code class="literal">MoveMultiple</code> mode if they click on an unmarked figure while pressing the <em>Ctrl</em> key, the <code class="literal">Idle</code> mode if the figure is already marked, or the <code class="literal">ModifyRectangle</code> mode if they click on the client area without hitting a figure.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Add</code>: When the user presses the left mouse button, a new figure is created at the location, regardless of whether there already is a figure at the location. The value of the <code class="literal">addFigureId</code> method decides which kind of figure should be added; it can hold any of the values <code class="literal">LineId</code>, <code class="literal">ArrowId</code>, <code class="literal">RectangleId</code>, or <code class="literal">EllipseId</code>.</li></ul></div><pre class="programlisting">    enum ActionMode {Modify, Add}; &#13;
    ActionMode actionMode = Add; &#13;
    FigureId addFigureId = LineId; &#13;
</pre><p>Later in the chapter, we will encounter expressions such as <strong>in Modify mode</strong> and <strong>in Add mode</strong>, which refer to the value of the <code class="literal">actionMode</code> variable: <code class="literal">Modify</code> or <code class="literal">Add</code>.</p><p>The <code class="literal">nextColor</code> and <code class="literal">nextFill</code> fields hold the figure's color and fill status (in the case of a rectangle or ellipse), respectively, of the next figure to be added:</p><pre class="programlisting">    Color nextColor; &#13;
    bool nextFill; &#13;
</pre><p>Similar to the circle application, when the user adds or modifies a figure, we need to store the previous mouse position in the <code class="literal">prevMousePoint</code> method in order to keep track of the distance the mouse has been moved since the last mouse action:</p><pre class="programlisting">    Point prevMousePoint; &#13;
</pre><p>When the <code class="literal">applicationMode</code> method holds the <code class="literal">ModifySingle</code> value, the figure being modified is always placed at the beginning of the figure pointer list (<code class="literal">figurePtrList[0]</code>) in order for it to appear on top of the figures. When the <code class="literal">applicationMode</code> method holds the <code class="literal">ModifyRectangle</code> mode, the <code class="literal">insideRectangle</code> method keeps track of the rectangle enclosing the figures:</p><pre class="programlisting">    Rect insideRectangle; &#13;
</pre><p>The <code class="literal">static DrawFormat</code> constant is used to identify data to be cut, copied, or pasted in the global clipboard. It is arbitrarily set to 1000:</p><pre class="programlisting">    static const unsigned int DrawFormat = 1000; &#13;
</pre><p>As the user adds and removes figures from the drawing, the figures are dynamically created and deleted; their addresses are stored in the <code class="literal">figurePtrList</code> list. The <code class="literal">DynamicList</code> class is a Small Windows class that is a more advanced version of the C++ standard classes <code class="literal">list</code> and <code class="literal">vector</code>.</p><p>The values of the figure list are pointers to the <code class="literal">DrawFigure</code> class, which is the root class of the figure hierarchy used in this application (described in <a class="link" href="ch05.html" title="Chapter 5. The Figure Hierarchy">Chapter 5</a>, <em>The Figure Hierarchy</em>). Unlike the circle and Tetris applications in the previous chapters, we do not store the figure objects directly in the list, but rather their pointers. This is necessary, since we use class hierarchy holds with pure virtual methods, which makes the <code class="literal">DrawWindow</code> class abstract and not possible to store directly in the list. It is also necessary in order to take advantage of dynamic binding of the class hierarchy:</p><pre class="programlisting">    DynamicList&lt;DrawFigure*&gt; figurePtrList; &#13;
}; &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>The application modes</h2></div></div></div><p>This section holds a further description of the <code class="literal">applicationMode</code> field. It is closely connected to the mouse input cycle. When the user is not pressing the left mouse button, the <code class="literal">applicationMode</code> method is always in the <code class="literal">Idle</code> mode. When the user presses the left mouse button in modify mode, they can choose to press the <em>Ctrl</em> key at the same time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If they do not press the <em>Ctrl</em> key, the <code class="literal">applicationMode</code> method is set to the <code class="literal">ModifySingle</code> mode if they hit a figure. That figure becomes marked and other figures become unmarked.</li><li class="listitem" style="list-style-type: disc">If they do press the <em>Ctrl</em> key, the <code class="literal">applicationMode</code> method is set to the <code class="literal">MoveMultiple</code> mode if they hit a figure that is not marked and to the <code class="literal">Idle</code> mode if it is marked. The figure becomes marked if it is unmarked and unmarked if it is marked. The rest of the figures are unaffected.</li><li class="listitem" style="list-style-type: disc">If they do not hit a figure, the <code class="literal">applicationMode</code> method is set to the <code class="literal">ModifyRectangle</code> mode regardless of whether they pressed the <em>Ctrl</em> key and the inside rectangle (<code class="literal">insideRectangle</code>) is being initialized. All figures become unmarked. All figures that are completely enclosed by the rectangle when the user releases the left button are marked.</li></ul></div><p>When the user moves the mouse with the left button pressed in modify mode, there are four possible values of the <code class="literal">applicationMode</code> method to consider:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Idle</code>: We do nothing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModifySingle</code>: We call the <code class="literal">Modify</code> method on the single figure. This may result in the single hit figure being modified or moved, depending on where the user hit the figure.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MoveMultiple</code>: We call the <code class="literal">Move</code> method on all marked figures. This always results in the marked figures being moved, not modified.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModifyRectangle</code>: We modify the inside rectangle.</li></ul></div><p>Finally, when the user releases the left mouse button, we again look into the four modes of the <code class="literal">applicationMode</code> method:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Idle</code>, <code class="literal">ModifySingle</code>, or <code class="literal">MoveMultiple</code>: We do nothing since everything has already been done when the user moved the mouse. The marked figures have been moved or modified.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModifyRectangle</code>: We mark all figures completely enclosed by the rectangle.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The DynamicList class</h2></div></div></div><p>In this chapter, we use a subset of the methods of the auxiliary <code class="literal">DynamicList</code> class. It holds a set of methods that take callback functions, that is, functions that are sent as parameters to methods and called by the methods:</p><pre class="programlisting">template &lt;class Type&gt; &#13;
class DynamicList { &#13;
  public: &#13;
</pre><p>
<code class="literal">IfFuncPtr</code> and <code class="literal">DoFuncPtr</code> are pointers to callback functions. The difference between them is that the <code class="literal">IfFuncPtr</code> pointer is intended for methods that only inspect the values of the list. Therefore, the <code class="literal">value</code> parameter is constant. The <code class="literal">DoFuncPtr</code> pointer is intended for methods that modify the values. Consequently, the <code class="literal">value</code> parameter is not constant:</p><pre class="programlisting">    typedef bool (*IfFuncPtr) (const Type&amp; value, void* voidPtr); &#13;
    typedef void (*DoFuncPtr) (Type&amp; value, void* voidPtr); &#13;
</pre><p>The <code class="literal">AnyOf</code> method takes the <code class="literal">ifFuncPtr</code> pointer and applies it to each value of the array. The methods return <code class="literal">true</code> if at least one of the values satisfies the <code class="literal">ifFunctPtr</code> pointer (if the <code class="literal">ifFuncPtr</code> pointer returns <code class="literal">true</code> for the value). The <code class="literal">ifVoidPtr</code> parameter is sent as the second parameter to the <code class="literal">ifFuncPtr</code> pointer:</p><pre class="programlisting">    bool AnyOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) &#13;
               const; &#13;
</pre><p>The <code class="literal">FirstOf</code> method also returns <code class="literal">true</code> if at least one value satisfies the <code class="literal">ifFuncPtr</code> pointer. In that case, the first satisfied value is copied to the <code class="literal">value</code> parameter:</p><pre class="programlisting">    bool FirstOf(IfFuncPtr ifFuncPtr,Type&amp; value, &#13;
                 void* ifVoidPtr = nullptr) const; &#13;
</pre><p>The <code class="literal">Apply</code> method calls the <code class="literal">doFunctPtr</code> pointer to every value of the list. The <code class="literal">ApplyIf</code> method calls the <code class="literal">doFuncPtr</code> pointer to all values that satisfy the <code class="literal">ifFuncPtr</code> pointer:</p><pre class="programlisting">    void Apply(DoFuncPtr doFuncPtr, void* ifVoidPtr = nullptr); &#13;
    void ApplyIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, &#13;
                 void* ifVoidPtr = nullptr, &#13;
                 void* doVoidPtr = nullptr); &#13;
</pre><p>The <code class="literal">CopyIf</code> method copies the values satisfying the <code class="literal">ifFuncPtr</code> pointer into the <code class="literal">copyArray</code> method. The <code class="literal">RemoveIf</code> method removes every value satisfying the <code class="literal">ifFuncPtr</code> pointer:</p><pre class="programlisting">    void CopyIf(IfFuncPtr ifFuncPtr, DynamicList&amp; copyArray, &#13;
                void* ifVoidPtr = nullptr) const; &#13;
    void RemoveIf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr); &#13;
</pre><p>The <code class="literal">ApplyRemoveIf</code> method calls the <code class="literal">doFuncPtr</code> pointer and then removes every value satisfying the <code class="literal">ifFuncPtr</code> pointer, which comes in handy when we want to deallocate and remove pointers from the list:</p><pre class="programlisting">    void ApplyRemoveIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, &#13;
              void* ifVoidPtr = nullptr, void* doVoidPtr=nullptr); &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Initialization</h2></div></div></div><p>The constructor of the <code class="literal">DrawDocument</code> class is similar to the constructor of the <code class="literal">CircleDocument</code> class. We use the <code class="literal">LogicalWithScroll</code> coordinate system with US letter size. The file description <code class="literal">Draw Files</code> and the suffix <code class="literal">drw</code> are used to filter drawing files in the open and save dialogs. The null pointer indicates that the document does not have a parent window, and the <code class="literal">false</code> parameter indicates that the <strong>Print</strong> and <strong>Print Preview</strong> items in the <strong>File</strong> menu are omitted. Finally, the initiation lists holding the <code class="literal">DrawFormat</code> parameter indicates the format used to identify data to be copied and pasted. In this case, we use the same format for both copying and pasting:</p><p>
<strong>DrawDocument.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "DrawFigure.h" &#13;
#include "LineFigure.h" &#13;
#include "ArrowFigure.h" &#13;
#include "RectangleFigure.h" &#13;
#include "EllipseFigure.h" &#13;
#include "TextFigure.h" &#13;
#include "DrawDocument.h" &#13;
 &#13;
DrawDocument::DrawDocument(WindowShow windowShow) &#13;
 :StandardDocument(LogicalWithScroll, USLetterPortrait, &#13;
                   TEXT("Draw Files, drw"), nullptr, &#13;
                   OverlappedWindow, windowShow, &#13;
                   {DrawFormat}, {DrawFormat}) { &#13;
</pre><p>Since we extend the <code class="literal">StandardDocument</code> framework, the window has a standard menu bar with the <strong>File</strong> menu holding <strong>New</strong>, <strong>Open</strong>, <strong>Save</strong>, <strong>Save As</strong>, and <strong>Exit</strong> (the <strong>Print</strong> and <strong>Print Preview</strong> items are omitted due to the <code class="literal">false</code> parameter in the constructor call) items, the <strong>Edit</strong> menu holding <strong>Cut</strong>, <strong>Copy</strong>, <strong>Paste</strong>, and <strong>Delete</strong>, and the <strong>Help</strong> items, and <strong>About</strong>.</p><p>We also add two application-specific menus: <strong>Format</strong> and <strong>Add</strong>. The <strong>Format</strong> menu holds the menu items <strong>Modify</strong>, <strong>Color</strong>, and <strong>Fill</strong>. Similar to the circle application, we mark the menu items with mnemonics and accelerators. However, we also use the enable parameters; the <code class="literal">ModifyEnable</code>, <code class="literal">ColorEnable</code>, and <code class="literal">FillEnable</code> methods are called before the menu items become visible. If they return <code class="literal">false</code>, the menu item is disabled and grayed:</p><pre class="programlisting">  Menu menuBar(this); &#13;
  menuBar.AddMenu(StandardFileMenu(false)); &#13;
  menuBar.AddMenu(StandardEditMenu()); &#13;
 &#13;
  Menu formatMenu(this, TEXT("F&amp;ormat")); &#13;
  formatMenu.AddItem(TEXT("&amp;Modify\tCtrl+M"), OnModify, &#13;
                     ModifyEnable, nullptr, ModifyRadio); &#13;
  formatMenu.AddItem(TEXT("&amp;Color\tAlt+C"), OnColor, ColorEnable); &#13;
  formatMenu.AddItem(TEXT("F&amp;ill\tCtrl+I"), OnFill, FillEnable&#13;
                     FillCheck, nullptr);&#13;
  menuBar.AddMenu(formatMenu); &#13;
</pre><p>The <strong>Add</strong> menu holds one item for each kind of figure to be added:</p><pre class="programlisting">  Menu addMenu(this, TEXT("&amp;Add")); &#13;
  addMenu.AddItem(TEXT("&amp;Line\tCtrl+L"), OnLine, &#13;
                  LineEnable, nullptr, LineRadio); &#13;
  addMenu.AddItem(TEXT("&amp;Arrow\tAlt+A"), OnArrow, &#13;
                  ArrowEnable, nullptr, ArrowRadio); &#13;
  addMenu.AddItem(TEXT("&amp;Rectangle\tCtrl+R"), OnRectangle, &#13;
                  RectangleEnable, nullptr, RectangleRadio); &#13;
  addMenu.AddItem(TEXT("&amp;Ellipse\tCtrl+E"), OnEllipse, &#13;
                  EllipseEnable, nullptr, EllipseRadio); &#13;
  menuBar.AddMenu(addMenu); &#13;
 &#13;
  menuBar.AddMenu(StandardHelpMenu()); &#13;
  SetMenuBar(menuBar); &#13;
</pre><p>Finally, we read values from the <strong>Windows Registry</strong>, which is a database in the Windows system that we can use to store values between the executions of our applications. The Small Windows auxiliary classes <code class="literal">Color</code>, <code class="literal">Font</code>, <code class="literal">Point</code>, <code class="literal">Size</code>, and <code class="literal">Rect</code> have their own registry methods. The Small Windows <code class="literal">Registry</code> class holds static methods for reading and writing text as well as numerical and integer values:</p><pre class="programlisting">  actionMode = (ActionMode) &#13;
              Registry::ReadInteger(TEXT("actionMode"), Modify); &#13;
  addFigureId = (FigureId) &#13;
              Registry::ReadInteger(TEXT("addFigureId"), LineId); &#13;
  nextColor.ReadColorFromRegistry(TEXT("nextColor")); &#13;
  nextFill = Registry::ReadBoolean(TEXT("nextFill"), false); &#13;
} &#13;
</pre><p>The destructor writes the values to the registry. In this application, it is not necessary to provide any common destructor actions such as deallocating memory or closing files:</p><pre class="programlisting">DrawDocument::~DrawDocument() { &#13;
  Registry::WriteInteger(TEXT("actionMode"), actionMode); &#13;
  Registry::WriteInteger(TEXT("addFigureId "), addFigureId); &#13;
  nextColor.WriteColorToRegistry(TEXT("nextColor")); &#13;
  Registry::WriteBoolean(TEXT("nextFill"), nextFill); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Mouse input</h2></div></div></div><p>
<code class="literal">IsFigureMarked</code>, <code class="literal">IsFigureClicked</code>, and <code class="literal">UnmarkFigure</code> are callback functions that are called by the <code class="literal">DynamicList</code> methods <code class="literal">AnyOf</code>, <code class="literal">FirstOf</code>, <code class="literal">CopyIf</code>, <code class="literal">ApplyIf</code>, and <code class="literal">ApplyRemoveIf</code>. These methods take the pointer to a figure and an optional void pointer that holds additional information.</p><p>The <code class="literal">IsFigureMarked</code> function returns <code class="literal">true</code> if the figure is marked, the <code class="literal">IsFigureClicked</code> function returns <code class="literal">true</code> if the mouse point given in the <code class="literal">voidPtr</code> pointer hits the figure, and the <code class="literal">IsFigureClicked</code> function unmarks the figure if it is marked. As you can see, the <code class="literal">IsFigureMarked</code> function is defined as a lambda function, while the <code class="literal">IsFigureClicked</code> function is defined as a regular function.</p><p>There is no rational reason for this, other than that I would like to demonstrate both ways to define functions:</p><pre class="programlisting">auto IsFigureMarked = [](DrawFigure* const&amp; figurePtr, &#13;
                         void* /* voidPtr */) { &#13;
  return figurePtr-&gt;IsMarked(); &#13;
}; &#13;
 &#13;
bool IsFigureClicked(DrawFigure* const&amp; figurePtr, void* voidPtr) { &#13;
  Point* mousePointPtr = (Point*) voidPtr; &#13;
  return figurePtr-&gt;IsClick(*mousePointPtr); &#13;
} &#13;
 &#13;
void UnmarkFigure(DrawFigure*&amp; figurePtr, void* /* voidPtr */) { &#13;
  if (figurePtr-&gt;IsMarked()) { &#13;
    figurePtr-&gt;Mark(false); &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">OnMouseDown</code> method, we first check that the user presses the left mouse button. If so, we save the mouse position in the <code class="literal">prevMousePoint</code> field so that we can calculate the distance the figure has moved in subsequent calls to the <code class="literal">OnMouseMove</code> method:</p><pre class="programlisting">void DrawDocument::OnMouseDown(MouseButton mouseButtons, &#13;
                     Point mousePoint, bool shiftPressed, &#13;
                     bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    prevMousePoint = mousePoint; &#13;
</pre><p>As mentioned earlier, the mouse click will result in different actions depending on the value of the <code class="literal">actionMode</code> method. In case of the <code class="literal">Modify</code> method, we call the <code class="literal">FirstOf</code> parameter on the figure pointer list to extract the first clicked figure. The figures can overlap, and the click may hit more than one figure. In that case, we want the topmost figure located at the beginning of the list. The <code class="literal">FirstOf</code> method returns <code class="literal">true</code> if there is at least one clicked figure, which is copied into the <code class="literal">topClickedFigurePtr</code> reference parameter. The address of the <code class="literal">mousePoint</code> method is given as the second parameter to the <code class="literal">FirstOf</code> method and is, in turn, given to the <code class="literal">IsFigureClicked</code> function as its second parameter:</p><pre class="programlisting">    switch (actionMode) { &#13;
      case Modify: { &#13;
          DrawFigure* topClickedFigurePtr; &#13;
          if (figurePtrList.FirstOf(IsFigureClicked, &#13;
                            topClickedFigurePtr, &amp;mousePoint)) { &#13;
</pre><p>We have two cases to consider, depending on whether the user presses the <em>Ctrl</em> key. If they do so, the figure will be marked if it is unmarked and vice versa, and other marked figures will remain marked.</p><p>However, in the other case, when the user does not press the <em>Ctrl</em> key, the figure becomes marked regardless of whether it is already marked, all other marked figures become unmarked, and the application is set to the <code class="literal">ModifySingle</code> mode. The figures are removed from the list and inserted at the beginning (front) in order to appear on top of the drawing:</p><pre class="programlisting">            if (!controlPressed) { &#13;
              figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); &#13;
              topClickedFigurePtr-&gt;Mark(true); &#13;
              applicationMode = ModifySingle; &#13;
              int topFigureIndex = &#13;
                figurePtrList.IndexOf(topClickedFigurePtr); &#13;
              figurePtrList.Erase(topFigureIndex); &#13;
              figurePtrList.PushFront(topClickedFigurePtr); &#13;
            } &#13;
</pre><p>If the user presses the <em>Ctrl</em> key, we have another two cases. If the clicked figure is already marked, we unmark it and set the <code class="literal">applicationMode</code> method to the <code class="literal">Idle</code> mode. If the clicked figure is not already marked, we mark it and set the <code class="literal">applicationMode</code> method to the <code class="literal">MoveMultiple</code> mode. In this way, we have at least one marked figure to be moved in the <code class="literal">OnMouseMove</code> method when the user moves the mouse. Note that if the user presses the <em>Ctrl</em> key, one or several figures can be moved but not modified. It would be illogical to modify more than one figure at the same time:</p><pre class="programlisting">            else { &#13;
              if (topClickedFigurePtr-&gt;IsMarked()) { &#13;
                applicationMode = Idle; &#13;
                topClickedFigurePtr-&gt;Mark(false); &#13;
              } &#13;
              else { &#13;
                applicationMode = MoveMultiple; &#13;
                topClickedFigurePtr-&gt;Mark(true); &#13;
              } &#13;
            } &#13;
          } &#13;
</pre><p>If the user hits a point where no figure is located (the <code class="literal">figurePtrList.FirstOf</code> method returns <code class="literal">false</code>), we unmark all marked figures, initialize the <code class="literal">insideRectangle</code> method, and set the <code class="literal">applicationMode</code> method to the <code class="literal">ModifyRectangle</code> mode.</p><pre class="programlisting">          else { &#13;
            figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); &#13;
            insideRectangle = Rect(mousePoint, mousePoint); &#13;
            applicationMode = ModifyRectangle; &#13;
          } &#13;
        } &#13;
        break; &#13;
</pre><p>All the aforementioned cases in this method takes place when the <code class="literal">actionMode</code> method is <code class="literal">Modify</code>. However, it can also be <code class="literal">Add</code>, in which case a new figure will be added to the drawing. We use the <code class="literal">addFigureId</code> method to decide which kind of figure to add when calling the <code class="literal">CreateFigure</code> method. We set the dirty flag, since we have added a figure and the document has been modified. Finally, we add the address of the new figure to the beginning of the figure list (so that it appears on top) and set the <code class="literal">applicationMode</code> method to the <code class="literal">ModifySingle</code> mode:</p><pre class="programlisting">      case Add: { &#13;
          DrawFigure* newFigurePtr = CreateFigure(addFigureId); &#13;
          newFigurePtr-&gt;SetColor(nextColor); &#13;
          newFigurePtr-&gt;Fill(nextFill); &#13;
          newFigurePtr-&gt;SetFirstPoint(mousePoint); &#13;
          SetDirty(true); &#13;
          figurePtrList.PushFront(newFigurePtr); &#13;
          applicationMode = ModifySingle; &#13;
        } &#13;
        break; &#13;
    } &#13;
</pre><p>Depending on the action and modes, the window and cursor may need to be updated:</p><pre class="programlisting">    UpdateWindow(); &#13;
    UpdateCursor(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">MoveMarkFigure</code> method is a callback function that is called by the <code class="literal">Apply</code> method on <code class="literal">figurePtrList</code> in the <code class="literal">OnMouseMove</code> method. It moves the figure that is marked. The address of the moving distance is given in the <code class="literal">voidPtr</code> parameter:</p><pre class="programlisting">void MoveMarkedFigure(DrawFigure*&amp; figurePtr, void* voidPtr) { &#13;
  if (figurePtr-&gt;IsMarked()) { &#13;
    figurePtr-&gt;Invalidate(); &#13;
    Size* distanzeSizePtr = (Size*) voidPtr; &#13;
    figurePtr-&gt;Move(*distanzeSizePtr); &#13;
    figurePtr-&gt;Invalidate(); &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">OnMouseMove</code> method, we start by calculating the distance since the previous call to the <code class="literal">OnMouseDown</code> or <code class="literal">OnMouseMove</code> method. We also set the <code class="literal">prevMousePoint</code> method to the mouse position:</p><pre class="programlisting">void DrawDocument::OnMouseMove(MouseButton mouseButtons, &#13;
                               Point mousePoint,bool shiftPressed, &#13;
                               bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    Size distanceSize = mousePoint - prevMousePoint; &#13;
    prevMousePoint = mousePoint; &#13;
</pre><p>Depending on the <code class="literal">applicationMode</code> method, we perform different tasks. In case of the <code class="literal">Modify</code> method on a single figure, we call the <code class="literal">MoveOrModify</code> method on that figure. The figure is placed at the beginning of the figure pointer list (<code class="literal">figurePtrList[0]</code>), since we placed it there in the <code class="literal">OnMouseDown</code> method. The idea is that the figure itself, depending on where the user clicked, decides whether it is moved or modified. The state of the figure is set when the user clicks on it, and depends on whether they click on any of the endpoints of the figure:</p><pre class="programlisting">    switch (applicationMode) { &#13;
      case ModifySingle: &#13;
        figurePtrList[0]-&gt;Modify(distanceSize); &#13;
        SetDirty(true); &#13;
        break; &#13;
</pre><p>In case of multiple movements, we move every marked figure the distance since the last mouse message. Note that we do not modify the figures in the multiple cases as we do in the single case:</p><pre class="programlisting">      case MoveMultiple: &#13;
        figurePtrList.Apply(MoveMarkedFigure, &amp;distanceSize); &#13;
        SetDirty(true); &#13;
        break; &#13;
</pre><p>In the rectangle case, we set its bottom-right corner and redraw it:</p><pre class="programlisting">      case ModifyRectangle: &#13;
        Invalidate(insideRectangle); &#13;
        insideRectangle.SetBottomRight(mousePoint); &#13;
        Invalidate(insideRectangle); &#13;
        UpdateWindow(); &#13;
        break; &#13;
    } &#13;
 &#13;
    UpdateWindow(); &#13;
    UpdateCursor(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">IsFigureInside</code> and <code class="literal">MarkFigure</code> methods are callback functions that are called by the <code class="literal">DynamicList</code> methods <code class="literal">CopyIf</code>, <code class="literal">RemoveIf</code>, and <code class="literal">Apply</code> on <code class="literal">figurePtrList</code> in the <code class="literal">OnMouseUp</code> method. The <code class="literal">IsFigureInside</code> method returns <code class="literal">true</code> if the figure is located inside the given rectangle, while the <code class="literal">MarkFigure</code> method simply marks the figure:</p><pre class="programlisting">bool IsFigureInside(DrawFigure* const&amp; figurePtr, void* voidPtr) { &#13;
  Rect* insideRectanglePtr = (Rect*) voidPtr; &#13;
  return figurePtr-&gt;IsInside(*insideRectanglePtr); &#13;
} &#13;
 &#13;
void MarkFigure(DrawFigure*&amp; figurePtr, void* /* voidPtr */) { &#13;
  figurePtr-&gt;Mark(true); &#13;
} &#13;
</pre><p>In the <code class="literal">OnMouseUp</code> method, we only need to take the <code class="literal">ModifyRectangle</code> case into consideration. We need to decide which figures are totally enclosed by the rectangle. In order for them to appear on top of the drawing, we first call the <code class="literal">CopyIf</code> method on the <code class="literal">figurePtrList</code> list to temporarily copy the figures located completely inside the rectangle to the <code class="literal">insideList</code> list.</p><p>Then we remove the figures from the <code class="literal">figurePtrList</code> list and insert them from the <code class="literal">insideList</code> list at the beginning of the <code class="literal">figurePtrList</code> list. This makes them appear at the top of the drawing. Finally, we mark the figure inside the rectangle by calling <code class="literal">Apply</code> on the <code class="literal">insideList</code> list:</p><pre class="programlisting">void DrawDocument::OnMouseUp(MouseButton mouseButtons, &#13;
                             Point mousePoint, bool shiftPressed, &#13;
                             bool controlPressed) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    switch (applicationMode) { &#13;
      case ModifyRectangle: { &#13;
          insideRectangle.Normalize();&#13;
          DynamicList&lt;DrawFigure*&gt; insideList; &#13;
          figurePtrList.CopyIf(IsFigureInside, insideList, &#13;
                                 &amp;insideRectangle); &#13;
          figurePtrList.RemoveIf(IsFigureInside, &#13;
                                 &amp;insideRectangle); &#13;
          figurePtrList.PushFront(insideList); &#13;
          insideList.Apply(MarkFigure); &#13;
          Invalidate(insideRectangle); &#13;
          insideRectangle.Clear(); &#13;
          UpdateWindow(); &#13;
        } &#13;
        break; &#13;
    } &#13;
</pre><p>After the user has released the left mouse button, the application holds the <code class="literal">Idle</code> mode, which it always holds as long as the user does not press the left mouse button:</p><pre class="programlisting">    applicationMode = Idle; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnDoubleClick</code> method is called when the user double-clicks on the mouse button. The difference between a double-click and two consecutive clicks is decided by the Windows system, and can be adjusted in the Windows control panel. In case of a double-click, the <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseUp</code> methods are called before the <code class="literal">OnDoubleClick</code> method. We extract the topmost clicked figure, if any, and call the <code class="literal">DoubleClick</code> method. The result depends on the type of figure: the head of an arrow is reversed, a rectangle or ellipse is filled if unfilled and vice versa, and a line is not affected at all:</p><pre class="programlisting">void DrawDocument::OnDoubleClick(MouseButton mouseButtons, &#13;
                           Point mousePoint, bool shiftPressed, &#13;
                           bool controlPressed) { &#13;
  if ((mouseButtons == LeftButton) &amp;&amp; !controlPressed) { &#13;
    DrawFigure* topClickedFigurePtr; &#13;
 &#13;
    if (figurePtrList.FirstOf(IsFigureClicked,topClickedFigurePtr,  &#13;
                              &amp;mousePoint)) { &#13;
      topClickedFigurePtr-&gt;DoubleClick(mousePoint); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Painting</h2></div></div></div><p>In Small Windows, there are three general  painting methods: <code class="literal">OnPaint</code>, <code class="literal">OnPrint</code>, and <code class="literal">OnDraw</code>. The Windows system indirectly calls the <code class="literal">OnPaint</code> and <code class="literal">OnPrint</code> methods for painting a window or printing a paper, respectively. Their default behavior is to call the <code class="literal">OnDraw</code> method. Remember that we do not take any initiatives to paint the window, we just wait for the right message. The idea is that in cases when we need to distinguish between painting and printing, we override the <code class="literal">OnPaint</code> and <code class="literal">OnPrint</code> methods, and when we do not need that distinction, we override the <code class="literal">OnDraw</code> method instead.</p><p>In the word processor, which is discussed later in this book, we will look into the difference between painting and printing. However, in this application, we just override the <code class="literal">OnDraw</code> method. As mentioned in <a class="link" href="ch03.html" title="Chapter 3. Building a Tetris Application">Chapter 3</a>, <em>Building a Tetris Application</em>, the <code class="literal">Graphics</code> class reference is created by the framework and can be considered a toolbox equipped with pens and brushes. In this case, we just call the <code class="literal">DrawFigure</code> method for each figure with the <code class="literal">Graphics</code> reference as a parameter. In case of the <code class="literal">ModifyRectangle</code> mode, we also draw the rectangle:</p><pre class="programlisting">void DrawDocument::OnDraw(Graphics&amp; graphics,&#13;
                          DrawMode /* drawMode */) const {&#13;
  int size = figurePtrList.Size();&#13;
  for (int index = (size - 1); index &gt;= 0; --index) {&#13;
    DrawFigure* figurePtr := figurePtrList) {[index];&#13;
    figurePtr-&gt;Draw(graphics);&#13;
  }&#13;
&#13;
  if (applicationMode == ModifyRectangle) {&#13;
    graphics.DrawRectangle(insideRectangle, Gray);&#13;
  }&#13;
}</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>The File menu</h2></div></div></div><p>Thanks to the framework in the <code class="literal">StandardDocument</code> class, the file management is quite easy. The <code class="literal">ClearDocument</code> method is called when the user selects the <strong>New</strong> menu item, we just delete the figures and clear the figure list:</p><pre class="programlisting">void DrawDocument::ClearDocument() { &#13;
  for (DrawFigure* figurePtr : figurePtrList) { &#13;
    delete figurePtr; &#13;
  } &#13;
 &#13;
  figurePtrList.Clear(); &#13;
} &#13;
</pre><p>The <code class="literal">WriteDocumentToStream</code> method is called when the user selects the <strong>Save</strong> or <strong>Save As</strong> menu item. It first writes the size of the figure list, and for each figure it writes its identity number (which is necessary when reading the figure in the <code class="literal">ReadDocumentFromStream</code> method shown as follows), and then writes the figure itself by calling its <code class="literal">WriteFigureToStream</code> method:</p><pre class="programlisting">bool DrawDocument::WriteDocumentToStream(String name, &#13;
                                         ostream&amp; outStream)const{ &#13;
  int listSize = figurePtrList.Size(); &#13;
  outStream.write((char*) &amp;listSize, sizeof listSize); &#13;
 &#13;
  for (DrawFigure* figurePtr : figurePtrList) { &#13;
    FigureId figureId = figurePtr-&gt;GetId(); &#13;
    outStream.write((char*) &amp;figureId, sizeof figureId); &#13;
    figurePtr-&gt;WriteFigureToStream(outStream); &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
</pre><p>The <code class="literal">ReadDocumentFromStream</code> method is called when the user selects the <strong>Open</strong> menu item. It starts by reading the number of figures in the figure list. We need to read the identity number for the next figure and call the <code class="literal">CreateFigure</code> method to receive a pointer to the created figure. Then we just call the <code class="literal">ReadFigureFromStream</code> method for the figure and add the figure's address to the figure pointer list:</p><pre class="programlisting">bool DrawDocument::ReadDocumentFromStream(String name, &#13;
                                          istream&amp; inStream) { &#13;
  int listSize; &#13;
  inStream.read((char*) &amp;listSize, sizeof listSize); &#13;
 &#13;
&#13;
  for (int index = 0; index &lt; listSize; ++index) { &#13;
    FigureId figureId; &#13;
    inStream.read((char*) &amp;figureId, sizeof figureId); &#13;
 &#13;
    DrawFigure* figurePtr = CreateFigure(figureId); &#13;
    figurePtr-&gt;ReadFigureFromStream(inStream); &#13;
 &#13;
    figurePtrList.PushBack(figurePtr); &#13;
  } &#13;
 &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">CreateFigure</code> method is called by the <code class="literal">ReadFigureFromStream</code> and <code class="literal">ReadFigureFromClipboard</code> method and creates a figure of the given type:</p><pre class="programlisting">DrawFigure* DrawDocument::CreateFigure(FigureId figureId) const { &#13;
  switch (figureId) { &#13;
    case LineId: &#13;
      return (new LineFigure(this)); &#13;
 &#13;
    case ArrowId: &#13;
      return (new ArrowFigure(this)); &#13;
 &#13;
    case RectangleId: &#13;
      return (new RectangleFigure(this)); &#13;
 &#13;
    case EllipseId: &#13;
      return (new EllipseFigure(this)); &#13;
  } &#13;
 &#13;
  return nullptr; &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Cut, copy, and paste</h2></div></div></div><p>Similar to the aforementioned file management case, the framework also takes care of the details of cut, copy, and paste. First, we do need to decide when the cut and copy menu items and accelerators will be enabled. In <code class="literal">Modify</code> mode, it is enough that at least one figure is marked. We use the <code class="literal">DynamicList</code> method <code class="literal">AnyOf</code> to decide whether at least one figure is marked. In <code class="literal">Add</code> mode, cut or copy is never allowed. We do not need to override the <code class="literal">CutEnable</code> method, since its default behavior in the <code class="literal">StandardDocument</code> framework is to call the <code class="literal">CopyEnable</code> method:</p><pre class="programlisting">bool DrawDocument::CopyEnable() const { &#13;
  if (applicationMode == Idle) { &#13;
    switch (actionMode) { &#13;
      case Modify: &#13;
        return figurePtrList.AnyOf(IsFigureMarked); &#13;
 &#13;
      case Add: &#13;
        return false; &#13;
    } &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>There is a <code class="literal">PasteEnable</code> method in the <code class="literal">StandardDocument</code> framework. However, in this application we do not need to override it, since the framework decides when to enable pasting or, more specifically, when there is data on the global clipboard with the format code given in the <code class="literal">StandardDocument</code> constructor, in this case the <code class="literal">DrawFormat</code> field. The global clipboard is a Windows resource intended for short-term storing of information that has been copied.</p><p>The <code class="literal">CopyGeneric</code> method takes a list of characters that are intended to be filled with application-specific information. We save the number of marked figures, and for each marked figure, we write its identity number and call the <code class="literal">WriteFigureToClipboard</code> method, which writes the figure-specific information to the <code class="literal">infoList</code> parameter:</p><pre class="programlisting">bool DrawDocument::IsCopyGenericReady(int /* format */) const { &#13;
  return true; &#13;
} &#13;
 &#13;
void DrawDocument::CopyGeneric(int format, InfoList&amp; infoList) &#13;
                               const { &#13;
  DynamicList&lt;DrawFigure*&gt; markedList; &#13;
  figurePtrList.CopyIf(IsFigureMarked, markedList); &#13;
  infoList.AddValue&lt;int&gt;(markedList.Size()); &#13;
 &#13;
  for (DrawFigure* figurePtr : markedList) { &#13;
    infoList.AddValue&lt;FigureId&gt;(figurePtr-&gt;GetId()); &#13;
    figurePtr-&gt;WriteFigureToClipboard(infoList); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">PasteGeneric</code> method pastes the figures in a way similar to the aforementioned the <code class="literal">ReadDocumentFromStream</code> method:</p><pre class="programlisting">void DrawDocument::PasteGeneric(int format, InfoList&amp; infoList) { &#13;
  figurePtrList.ApplyIf(IsFigureMarked, UnmarkFigure); &#13;
 &#13;
  int pasteSize; &#13;
  infoList.GetValue&lt;int&gt;(pasteSize); &#13;
 &#13;
  for (int count = 0; count &lt; pasteSize; ++count) { &#13;
    FigureId figureId; &#13;
    infoList.GetValue&lt;FigureId&gt;(figureId); &#13;
 &#13;
    DrawFigure* figurePtr = CreateFigure(figureId); &#13;
    figurePtr-&gt;ReadFigureFromClipboard(infoList); &#13;
    figurePtr-&gt;Move(Size(1000, 1000)); &#13;
    figurePtrList.PushBack(figurePtr); &#13;
 &#13;
    figurePtr-&gt;Mark(true); &#13;
  } &#13;
 &#13;
  UpdateWindow(); &#13;
} &#13;
</pre><p>There is a <code class="literal">DeleteEnable</code> method in the <code class="literal">StandardDocument</code> framework, which we do not need to override since its default behavior is to call the <code class="literal">CopyEnable</code> method. The <code class="literal">OnDelete</code> method goes through the figure list, invalidating and deleting the marked figures. We use the <code class="literal">DynamicList</code> method <code class="literal">ApplyRemoveIf</code> to remove and delete marked figures.</p><p>We cannot simply use the <code class="literal">ApplyIf</code> and <code class="literal">RemoveIf</code> methods to deallocate and remove the figures, since it would result in memory errors (dangling pointers):</p><pre class="programlisting">void DeleteFigure(DrawFigure*&amp; figurePtr, void* /* voidPtr */) { &#13;
  figurePtr-&gt;Invalidate(); &#13;
  delete figurePtr; &#13;
} &#13;
 &#13;
void DrawDocument::OnDelete() { &#13;
  figurePtrList.ApplyRemoveIf(IsFigureMarked, DeleteFigure, &#13;
                              nullptr, this); &#13;
  UpdateWindow(); &#13;
  SetDirty(true); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>The Modify menu</h2></div></div></div><p>The <strong>Modify</strong> menu item is quite easy to handle. It is enabled in case the application is in the <code class="literal">Idle</code> mode, which it is in when the user does not press the left mouse button. The radio button is also present if the <code class="literal">actionMode</code> method is <code class="literal">Modify</code>, and the menu item listener just sets the <code class="literal">actionMode</code> method to <code class="literal">Modify</code>:</p><pre class="programlisting">bool DrawDocument::ModifyEnable() const { &#13;
  return (applicationMode == Idle); &#13;
} &#13;
 &#13;
bool DrawDocument::ModifyRadio() const { &#13;
  return ((applicationMode == Idle) &amp;&amp; (actionMode == Modify)); &#13;
} &#13;
 &#13;
void DrawDocument::OnModify() { &#13;
  actionMode = Modify; &#13;
} &#13;
</pre><p>For the <strong>Color</strong> and <strong>Fill</strong> menu items, there are enable methods that are rather easy and listeners that are a little bit more complicated. It is possible to change the color in <code class="literal">Modify</code> mode if at least one figure is marked. In <code class="literal">Add</code> mode, it is always possible to change the color:</p><pre class="programlisting">bool DrawDocument::ColorEnable() const { &#13;
  if (applicationMode == Idle) { &#13;
    switch (actionMode) { &#13;
      case Modify: &#13;
        return figurePtrList.AnyOf(IsFigureMarked);  &#13;
      case Add: &#13;
        return true; &#13;
    } &#13;
  }  &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">SetFigureColor</code> method is a callback function that is called by the <code class="literal">ApplyIf</code> method on the <code class="literal">figurePtrList</code> list in the <code class="literal">OnColor</code> method:</p><pre class="programlisting">void SetFigureColor(DrawFigure*&amp; figurePtr, void* voidPtr) { &#13;
  Color* colorPtr = (Color*) voidPtr; &#13;
 &#13;
  if (figurePtr-&gt;IsMarked() &amp;&amp; &#13;
      (figurePtr-&gt;GetColor() != *colorPtr)) { &#13;
    figurePtr-&gt;SetColor(*colorPtr); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnColor</code> method is called when the user selects the <strong>Color</strong> menu item. In <code class="literal">Modify</code> mode, we extract the marked figures and choose the color of the topmost of them. We know that at least one figure is marked, otherwise the preceding <code class="literal">ColorEnable</code> method would return <code class="literal">false</code> and the <strong>Color</strong> menu item would be disabled. If the <code class="literal">ColorDialog</code> call returns <code class="literal">true</code>, we set the new color of all marked figures by calling the <code class="literal">ApplyIf</code> method on the <code class="literal">figurePtrList</code> list:</p><pre class="programlisting">void DrawDocument::OnColor() { &#13;
  switch (actionMode) { &#13;
    case Modify: { &#13;
        DynamicList&lt;DrawFigure*&gt; markedList; &#13;
        figurePtrList.CopyIf(IsFigureMarked, markedList); &#13;
        DrawFigure* topFigurePtr = markedList[0]; &#13;
        Color topColor = topFigurePtr-&gt;GetColor(); &#13;
 &#13;
        if (StandardDialog::ColorDialog(this, topColor)) { &#13;
          nextColor = topColor; &#13;
          figurePtrList.ApplyIf(IsFigureMarked, SetFigureColor, &#13;
                                nullptr, &amp;topColor); &#13;
          UpdateWindow(); &#13;
          SetDirty(true); &#13;
        } &#13;
      } &#13;
      break; &#13;
</pre><p>If the <code class="literal">actionMode</code> method is <code class="literal">Add</code>, we just display a color dialog to set the next color:</p><pre class="programlisting">    case Add: &#13;
      StandardDialog::ColorDialog(this, nextColor); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">IsFigureMarkedAndFilled</code> method is a callback function that is called by the <code class="literal">AnyOf</code> method on the <code class="literal">figurePtrList</code> list in the <code class="literal">FillCheck</code> method. The <strong>Fill</strong> menu item is checked with a radio mark if at least one figure is marked and filled:</p><pre class="programlisting">bool IsFigureMarkedAndFilled(DrawFigure* const&amp; figurePtr, &#13;
                             void* /* voidPtr */) { &#13;
  return (figurePtr-&gt;IsMarked() &amp;&amp; figurePtr-&gt;IsFilled()); &#13;
} &#13;
 &#13;
bool DrawDocument::FillCheck() const { &#13;
  if (applicationMode == Idle) { &#13;
    switch (actionMode) { &#13;
      case Modify: &#13;
        return figurePtrList.AnyOf(IsFigureMarkedAndFilled); &#13;
 &#13;
      case Add: &#13;
        return nextFill; &#13;
    } &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">IsFigureMarkedAndFillable</code> method is a callback function that is called by the <code class="literal">AnyOf</code> method on the <code class="literal">figurePtrList</code> list in the <code class="literal">FillEnable</code> method. The <strong>Fill</strong> menu item is enabled if at least one fillable figure (rectangle or ellipse) is marked, or if the user is about to add a rectangle or ellipse:</p><pre class="programlisting">bool IsFigureMarkedAndFillable(DrawFigure* const&amp; figurePtr, &#13;
                               void* /* voidPtr */){ &#13;
  return (figurePtr-&gt;IsMarked() &amp;&amp; figurePtr-&gt;IsFillable()); &#13;
} &#13;
 &#13;
bool DrawDocument::FillEnable() const { &#13;
  if (applicationMode == Idle) { &#13;
    switch (actionMode) { &#13;
      case Modify: &#13;
        return figurePtrList.AnyOf(IsFigureMarkedAndFillable); &#13;
</pre><p>In order to test whether the figure type of the next figure to be added is fillable, we create and delete such a figure:</p><pre class="programlisting">      case Add: { &#13;
          DrawFigure* addFigurePtr = CreateFigure(addFigureId); &#13;
          bool fillable = addFigurePtr-&gt;IsFillable(); &#13;
          delete addFigurePtr; &#13;
          return fillable; &#13;
        } &#13;
    } &#13;
  } &#13;
  return false; &#13;
} &#13;
</pre><p>The <code class="literal">InverseFill</code> method is a callback function that is called by the <code class="literal">AnyOf</code> method on the <code class="literal">figurePtrList</code> list in the <code class="literal">OnFill</code> method, which is called when the user selects the <strong>Fill</strong> menu item. The <code class="literal">OnFill</code> method inverts the fill status of all marked figures in <code class="literal">Modify</code> mode. In <code class="literal">Add</code> mode, it just inverts the value of <code class="literal">nextFill</code>, indicating that the next figure to be added will have the inverted fill status:</p><pre class="programlisting">void InverseFill(DrawFigure*&amp; figurePtr, void* /* voidPtr */) { &#13;
  if (figurePtr-&gt;IsMarked()) { &#13;
    figurePtr-&gt;Fill(!figurePtr-&gt;IsFilled()); &#13;
  } &#13;
} &#13;
 &#13;
void DrawDocument::OnFill() { &#13;
  switch (actionMode) { &#13;
    case Modify: &#13;
      figurePtrList.ApplyIf(IsFigureMarked, InverseFill); &#13;
      UpdateWindow(); &#13;
      break; &#13;
 &#13;
    case Add: &#13;
      nextFill = !nextFill; &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>The Add menu</h2></div></div></div><p>The listeners for the items of the <code class="literal">Add</code> menu are rather straightforward. The enable methods are simple, for the menu item to be enabled it is enough if the <code class="literal">applicationMode</code> method is in the <code class="literal">Idle</code> mode:</p><pre class="programlisting">bool DrawDocument::LineEnable() const { &#13;
  return (applicationMode == Idle); &#13;
} &#13;
bool DrawDocument::ArrowEnable() const { &#13;
  return (applicationMode == Idle); &#13;
} &#13;
 &#13;
bool DrawDocument::RectangleEnable() const { &#13;
  return (applicationMode == Idle); &#13;
} &#13;
 &#13;
bool DrawDocument::EllipseEnable() const { &#13;
  return (applicationMode == Idle); &#13;
} &#13;
</pre><p>The radio methods return <code class="literal">true</code> in <code class="literal">Add</code> mode if the figure to be added matches the figure of the radio method:</p><pre class="programlisting">bool DrawDocument::LineRadio() const { &#13;
  return ((actionMode == Add) &amp;&amp; (addFigureId == LineId)); &#13;
} &#13;
 &#13;
bool DrawDocument::ArrowRadio() const { &#13;
  return ((actionMode == Add) &amp;&amp; (addFigureId == ArrowId)); &#13;
} &#13;
 &#13;
bool DrawDocument::RectangleRadio() const { &#13;
  return ((actionMode == Add) &amp;&amp; (addFigureId == RectangleId)); &#13;
} &#13;
 &#13;
bool DrawDocument::EllipseRadio() const { &#13;
  return ((actionMode == Add) &amp;&amp; (addFigureId == EllipseId)); &#13;
} &#13;
</pre><p>Finally, the methods responding to the menu item and accelerator selections sets the <code class="literal">actionMode</code> to <code class="literal">Add</code> and the figure to be added:</p><pre class="programlisting">void DrawDocument::OnLine() { &#13;
  actionMode = Add; &#13;
  addFigureId = LineId; &#13;
} &#13;
 &#13;
void DrawDocument::OnArrow() { &#13;
  actionMode = Add; &#13;
  addFigureId = ArrowId; &#13;
} &#13;
void DrawDocument::OnRectangle() { &#13;
  actionMode = Add; &#13;
  addFigureId = RectangleId; &#13;
} &#13;
 &#13;
void DrawDocument::OnEllipse() { &#13;
  actionMode = Add; &#13;
  addFigureId = EllipseId; &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>The cursor</h2></div></div></div><p>The <code class="literal">Set</code> method in the <code class="literal">Cursor</code> class sets the cursor to an appropriate value. If the application mode is <code class="literal">Idle</code> mode, we wait for the user to press the mouse button. In that case, we use the well-known arrow cursor image. If the user is in the process of enclosing figures with a rectangle, we use the cross-hair. If the user is in the process of moving several figures, we use the cursor with four arrows (size all). Finally, if they are in the process of modifying a single figure, the figure (whose address is located in the <code class="literal">figurePtrList[0]</code> list) itself is deciding which cursor to use:</p><pre class="programlisting">void DrawDocument::UpdateCursor() { &#13;
  switch (applicationMode) { &#13;
    case Idle: &#13;
      Cursor::Set(Cursor::Arrow); &#13;
      break; &#13;
 &#13;
    case ModifyRectangle: &#13;
      Cursor::Set(Cursor::Crosshair); &#13;
      break; &#13;
 &#13;
    case MoveMultiple: &#13;
      Cursor::Set(Cursor::SizeAll); &#13;
      break; &#13;
 &#13;
    case ModifySingle: &#13;
      Cursor::Set(figurePtrList[0]-&gt;GetCursor()); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, you started the development of a drawing program capable of drawing lines, arrows, rectangles, and ellipses. In <a class="link" href="ch05.html" title="Chapter 5. The Figure Hierarchy">Chapter 5</a>, <em>The Figure Hierarchy</em>, we will look into the figure hierarchy.</p></div></body></html>