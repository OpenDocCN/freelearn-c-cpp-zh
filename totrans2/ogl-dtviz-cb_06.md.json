["```cpp\nsudo port install assimp\n\n```", "```cpp\nsudo apt-get install install libassimp-dev\n\n```", "```cpp\n`pkg-config --static --libs assimp`\n\n```", "```cpp\n`pkg-config --cflags assimp`\n\n```", "```cpp\nPKG_CONFIG_PATH=/usr/local/lib/pkgconfig/\nCFILES = ../common/shader.cpp ../common/controls.cpp ../common/ObjLoader.cpp main.cpp \nCFLAGS = -c\nOPT = -O3\nINCLUDES = -I../common -I/usr/include -I/usr/include/SOIL -I.  `pkg-config --cflags glfw3` `pkg-config --cflags assimp`\nLIBS = -lm -L/usr/local/lib -lGLEW `pkg-config --static --libs glfw3` `pkg-config --static --libs assimp`\nCC = g++\nOBJECTS=$(CFILES:.cpp=.o)\nEXECUTABLE=main\nall: $(CFILES) $(EXECUTABLE)\n$(EXECUTABLE): $(OBJECTS)\n$(CC) $(OPT) $(INCLUDES) $(OBJECTS) -o $@ $(LIBS)\n.cpp.o:\n$(CC) $(OPT) $(CFLAGS) $(INCLUDES) $< -o $@\nclean:\nrm -v -f *~ ../common/*.o *.o $(EXECUTABLE)\n\n```", "```cpp\n    cmake_minimum_required (VERSION 2.8)\n    set(CMAKE_CONFIGURATION_TYPES Debug Release)\n    set(PROGRAM_PATH \"C:/Program Files \\(x86\\)\")\n    set(OpenCV_DIR ${PROGRAM_PATH}/opencv/build)\n    project (code)\n    #modify these path based on your configuration\n    #OpenCV\n    find_package(OpenCV REQUIRED )\n    INCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})\n    INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glm)\n    INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/include)\n    LINK_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/lib/Release/Win32)\n    INCLUDE_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/include)\n    LINK_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/lib)\n    INCLUDE_DIRECTORIES(${PROGRAM_PATH}/Simple\\ OpenGL\\ Image\\ Library/src)\n    INCLUDE_DIRECTORIES(${PROGRAM_PATH}/assimp--3.0.1270-sdk/include/assimp)\n    LINK_DIRECTORIES(${PROGRAM_PATH}/assimp--3.0.1270-sdk/lib/assimp_release-dll_win32)\n    add_subdirectory (../common common)\n    add_executable (main main.cpp)\n    target_link_libraries (main LINK_PUBLIC shader controls texture glew32s glfw3 opengl32 assimp ObjLoader)\n    ```", "```cpp\n#include <cimport.h>\n#include <scene.h>\n#include <postprocess.h>\n```", "```cpp\n# This is a comment.\n# Front facing square.\n# vertices [x, y, z]\nv 0 0 0   # Bottom left.\nv 1 0 0   # Bottom right.\nv 1 1 0   # Top    right.\nv 0 1 0   # Top    left.\n# List of faces: \nf 1 2 3 4       # Square.\n```", "```cpp\n#ifndef OBJLOADER_H_\n#define OBJLOADER_H_\n/* Assimp include files. These three are usually needed. */\n#include <cimport.h>\n#include <scene.h>\n#include <postprocess.h>\n#include <common.h>\n#define aisgl_min(x,y) (x<y?x:y)\n#define aisgl_max(x,y) (y>x?y:x)\nclass ObjLoader {\n  public:\n  ObjLoader();\n  virtual ~ObjLoader();\n  int loadAsset(const char* path);\n  void setScale(float scale);\n  unsigned int getNumVertices();\n  void draw(const GLenum draw_mode);\n  void loadVertices(GLfloat *g_vertex_buffer_data);\nprivate:\n  //helper functions and variables\n  const struct aiScene* scene;\n  GLuint scene_list;\n  aiVector3D scene_min, scene_max, scene_center;\n  float g_scale;\n  unsigned int num_vertices;\n  unsigned int recursiveDrawing(const struct aiNode* nd, unsigned int v_count, const GLenum);\n  unsigned int recursiveVertexLoading(const struct aiNode *nd, GLfloat *g_vertex_buffer_data, unsigned int v_counter);\n  unsigned int recursiveGetNumVertices(const struct aiNode *nd);\n  void get_bounding_box (aiVector3D* min, aiVector3D* max);\n  void get_bounding_box_for_node (const struct aiNode* nd, aiVector3D* min, aiVector3D* max, aiMatrix4x4* trafo);\n};\n#endif\n```", "```cpp\n#include <ObjLoader.h>\nObjLoader::ObjLoader() {\n  g_scale=1.0f;\n  scene = NULL; //empty scene\n  scene_list = 0;\n  num_vertices = 0;\n}\n```", "```cpp\nint ObjLoader::loadAsset(const char *path){\n  scene = aiImportFile(path, aiProcessPreset_TargetRealtime_MaxQuality);\n  if (scene) {\n    get_bounding_box(&scene_min,&scene_max);\n    scene_center.x = (scene_min.x + scene_max.x) / 2.0f;\n    scene_center.y = (scene_min.y + scene_max.y) / 2.0f;\n    scene_center.z = (scene_min.z + scene_max.z) / 2.0f;\n    printf(\"Loaded file %s\\n\", path);\n    g_scale =4.0/(scene_max.x-scene_min.x);\n\n    printf(\"Scaling: %lf\", g_scale);\n    num_vertices = recursiveGetNumVertices(scene->mRootNode);\n    printf(\"This Scene has %d vertices.\\n\", num_vertices);\n    return 0;\n  }\n  return 1;\n}\n```", "```cpp\nunsigned int ObjLoader::recursiveGetNumVertices(const struct aiNode *nd){\n  unsigned int counter=0;\n  unsigned int i;\n  unsigned int n = 0, t;\n  // draw all meshes assigned to this node\n  for (; n < nd->mNumMeshes; ++n) {\n    const struct aiMesh* mesh = scene-> mMeshes[nd->mMeshes[n]];\n    for (t = 0; t < mesh->mNumFaces; ++t) {\n      const struct aiFace* face = &mesh-> mFaces[t];\n      counter+=3*face->mNumIndices;\n    }\n    printf(\"recursiveGetNumVertices: mNumFaces \t%d\\n\", mesh->mNumFaces);\n  }\n  //traverse all children nodes\n  for (n = 0; n < nd->mNumChildren; ++n) {\n    counter+=recursiveGetNumVertices(nd-> mChildren[n]);\n  }\n  printf(\"recursiveGetNumVertices: counter %d\\n\", counter);\n  return counter;\n}\n```", "```cpp\nvoid ObjLoader::get_bounding_box (aiVector3D* min, aiVector3D* max)\n{\n  aiMatrix4x4 trafo;\n  aiIdentityMatrix4(&trafo);\n  min->x = min->y = min->z =  1e10f;\n  max->x = max->y = max->z = -1e10f;\n  get_bounding_box_for_node(scene-> mRootNode,min,max,&trafo);\n}\nvoid ObjLoader::get_bounding_box_for_node (const struct aiNode* nd, aiVector3D* min, aiVector3D* max, aiMatrix4x4* trafo) \n{\n  aiMatrix4x4 prev;\n  unsigned int n = 0, t;\n  prev = *trafo;\n  aiMultiplyMatrix4(trafo,&nd->mTransformation);\n  for (; n < nd->mNumMeshes; ++n) {\n    const struct aiMesh* mesh = scene-> mMeshes[nd->mMeshes[n]];\n    for (t = 0; t < mesh->mNumVertices; ++t) {\n      aiVector3D tmp = mesh->mVertices[t];\n      aiTransformVecByMatrix4(&tmp,trafo);\n      min->x = aisgl_min(min->x,tmp.x);\n      min->y = aisgl_min(min->y,tmp.y);\n      min->z = aisgl_min(min->z,tmp.z);\n      max->x = aisgl_max(max->x,tmp.x);\n      max->y = aisgl_max(max->y,tmp.y);\n      max->z = aisgl_max(max->z,tmp.z);\n    }\n  }\n  for (n = 0; n < nd->mNumChildren; ++n) {\n    get_bounding_box_for_node(nd-> mChildren[n],min,max,trafo);\n  }\n  *trafo = prev;\n}\n```", "```cpp\n#include <ObjLoader.h>\n```", "```cpp\nObjLoader *obj_loader = new ObjLoader();\nint result = 0;\nif(argc > 1){\n  result = obj_loader->loadAsset(argv[1]);\n}\nelse{\n  result = obj_loader-> loadAsset(\"dragon.obj\");\n}\nif(result){\n  fprintf(stderr, \"Final to Load the 3D file\\n\");\n  glfwTerminate();\n  exit(EXIT_FAILURE);\n}\n```", "```cpp\nGLfloat *g_vertex_buffer_data = (GLfloat*) \nmalloc (obj_loader->getNumVertices()*sizeof(GLfloat));\n//load the scene data to the vertex buffer\nobj_loader->loadVertices(g_vertex_buffer_data);\n```", "```cpp\n( \\\n  aiProcessPreset_TargetRealtime_Quality | \\\n  aiProcess_FindInstances | \\\n  aiProcess_ValidateDataStructure | \\\n  aiProcess_OptimizeMeshes | \\\n  aiProcess_Debone | \\\n0 )\n```", "```cpp\nvoid ObjLoader::loadVertices(GLfloat *g_vertex_buffer_data)\n{\n  recursiveVertexLoading(scene->mRootNode, g_vertex_buffer_data, 0);\n}\nunsigned int ObjLoader::recursiveVertexLoading (const struct aiNode *nd, GLfloat *g_vertex_buffer_data, unsigned int v_counter)\n{\n  unsigned int i;\n  unsigned int n = 0, t;\n  /* save all data to the vertex array, perform offset and scaling to reduce the computation */\n  for (; n < nd->mNumMeshes; ++n) {\n    const struct aiMesh* mesh = scene-> mMeshes[nd->mMeshes[n]];\n    for (t = 0; t < mesh->mNumFaces; ++t) {\n      const struct aiFace* face = &mesh->mFaces[t];\n      for(i = 0; i < face->mNumIndices; i++) {\n        int index = face->mIndices[i];\n        g_vertex_buffer_data[v_counter]=\n          (mesh->mVertices[index].x-scene_center.x)*g_scale;\n        g_vertex_buffer_data[v_counter+1]=\n          (mesh->mVertices[index].y-scene_center.y)*g_scale;\n        g_vertex_buffer_data[v_counter+2]=\n          (mesh->mVertices[index].z-scene_center.z)*g_scale;\n        v_counter+=3;\n      }\n    }\n  }\n  //traverse all children nodes\n  for (n = 0; n < nd->mNumChildren; ++n) {\n    v_counter = recursiveVertexLoading(nd-> mChildren[n], g_vertex_buffer_data, v_counter);\n  }\n  return v_counter;\n}\n```", "```cpp\nvoid ObjLoader::draw(const GLenum draw_mode){\n  recursiveDrawing(scene->mRootNode, 0, draw_mode);\n}\nunsigned int ObjLoader::recursiveDrawing(const struct aiNode* nd, unsigned int v_counter, const GLenum draw_mode){\n  /* break up the drawing, and shift the pointer to draw different parts of the scene */\n  unsigned int i;\n  unsigned int n = 0, t;\n  unsigned int total_count = v_counter;\n  // draw all meshes assigned to this node\n  for (; n < nd->mNumMeshes; ++n) {\n    unsigned int count=0;\n    const struct aiMesh* mesh = scene-> mMeshes[nd->mMeshes[n]];\n    for (t = 0; t < mesh->mNumFaces; ++t) {\n      const struct aiFace* face = &mesh-> mFaces[t];\n      count+=3*face->mNumIndices;\n    }\n    glDrawArrays(draw_mode, total_count, count);\n      total_count+=count;\n  }\n  v_counter = total_count;\n  // draw all children nodes recursively\n  for (n = 0; n < nd->mNumChildren; ++n) {\n    v_counter = recursiveDrawing(nd-> mChildren[n], v_counter, draw_mode);\n  }\n  return v_counter;\n}\n```", "```cpp\n#version 150 core\n// Input\nin vec3 vertexPosition_modelspace;\n// Output \nout vec4 color_based_on_position;\n// Uniform/constant variable.\nuniform mat4 MVP;\n//heat map generator\nvec4 heatMap(float v, float vmin, float vmax){\n  float dv;\n  float r=1.0f, g=1.0f, b=1.0f;\n  if (v < vmin)\n    v = vmin;\n  if (v > vmax)\n    v = vmax;\n  dv = vmax - vmin;\n  if (v < (vmin + 0.25f * dv)) {\n    r = 0.0f;\n    g = 4.0f * (v - vmin) / dv;\n  } else if (v < (vmin + 0.5f * dv)) {\n    r = 0.0f;\n    b = 1.0f + 4.0f * (vmin + 0.25f * dv - v) / dv;\n  } else if (v < (vmin + 0.75f * dv)) {\n    r = 4.0f * (v - vmin - 0.5f * dv) / dv;\n    b = 0.0f;\n  } else {\n    g = 1.0f + 4.0f * (vmin + 0.75f * dv - v) / dv;\n    b = 0.0f;\n  }\n  //with 0.2 transparency - can be dynamic if we pass in variables\n  return vec4(r, g, b, 0.2f);\n} \n\nvoid main () {\n  // Output position of the vertex, in clip space : MVP * position\n  gl_Position =  MVP * vec4(vertexPosition_modelspace, 1.0f);\n  // remapping the color based on the depth (z) value.\n  color_based_on_position = heatMap(vertexPosition_modelspace.z, -1.0f, 1.0f);\n}\n```", "```cpp\n#version 150 core\nout vec4 color;\nin vec4 color_based_on_position;\nvoid main(){\n  color = color_based_on_position;\n}\n```", "```cpp\n//draw the left eye (but full screen)\nglViewport(0, 0, width, height);\n//compute the MVP matrix from the IOD and virtual image plane distance\ncomputeStereoViewProjectionMatrices(g_window, IOD, depthZ, true);\n//get the View and Model Matrix and apply to the rendering\nglm::mat4 projection_matrix = getProjectionMatrix();\nglm::mat4 view_matrix = getViewMatrix();\nglm::mat4 model_matrix = glm::mat4(1.0);\nmodel_matrix = glm::translate(model_matrix, glm::vec3(0.0f, 0.0f, -depthZ));\nmodel_matrix = glm::rotate(model_matrix, \nglm::pi<float>()*rotateY, glm::vec3(0.0f, 1.0f, 0.0f));\nmodel_matrix = glm::rotate(model_matrix, \nglm::pi<float>()*rotateX, glm::vec3(1.0f, 0.0f, 0.0f));\nglm::mat4 mvp = projection_matrix * view_matrix * model_matrix;\n//send our transformation to the currently bound shader,\n//in the \"MVP\" uniform variable\nglUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);\n/* render scene with different modes that can be enabled separately to get different effects */\nobj_loader->draw(GL_TRIANGLES);\nif(drawPoints)\n  obj_loader->draw(GL_POINTS);\nif(drawLines)\n  obj_loader->draw(GL_LINES);\n```", "```cpp\nvoid computeStereoViewProjectionMatrices(GLFWwindow* window, float IOD, float depthZ, bool left_eye){\n  int width, height;\n  glfwGetWindowSize(window, &width, &height);\n  //up vector\n  glm::vec3 up = glm::vec3(0,-1,0);\n  glm::vec3 direction_z(0, 0, -1);\n  //mirror the parameters with the right eye\n  float left_right_direction = -1.0f;\n  if(left_eye)\n    left_right_direction = 1.0f;\n  float aspect_ratio = (float)width/(float)height;\n  float nearZ = 1.0f;\n  float farZ = 100.0f;\n  double frustumshift = (IOD/2)*nearZ/depthZ;\n  float top = tan(g_initial_fov/2)*nearZ;\n  float right =\naspect_ratio*top+frustumshift*left_right_direction; \n//half screen\n  float left = -aspect_ratio*top+frustumshift*left_right_direction;\n  float bottom = -top;\n  g_projection_matrix = glm::frustum(left, right, bottom, top, nearZ, farZ);\n  // update the view matrix\n g_view_matrix = \n glm::lookAt(\n   g_position-direction_z+\n     glm::vec3(left_right_direction*IOD/2, 0, 0), \n     //eye position\n   g_position+\n     glm::vec3(left_right_direction*IOD/2, 0, 0), \n     //centre position\n   up //up direction\n );\n\n```", "```cpp\nif(stereo){\n  //draw the LEFT eye, left half of the screen\n  glViewport(0, 0, width/2, height);\n  //computes the MVP matrix from the IOD and virtual image plane distance\n  computeStereoViewProjectionMatrices(g_window, IOD, depthZ, true);\n  //gets the View and Model Matrix and apply to the rendering\n  glm::mat4 projection_matrix = getProjectionMatrix();\n  glm::mat4 view_matrix = getViewMatrix();\n  glm::mat4 model_matrix = glm::mat4(1.0);\n  model_matrix = glm::translate(model_matrix, glm::vec3(0.0f, 0.0f, -depthZ));\n  model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateY, glm::vec3(0.0f, 1.0f, 0.0f));\n  model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateX, glm::vec3(1.0f, 0.0f, 0.0f));\n  glm::mat4 mvp = projection_matrix * view_matrix * model_matrix;\n  //sends our transformation to the currently bound shader,\n  //in the \"MVP\" uniform variable\n  glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);\n  //render scene, with different drawing modes\n\n  if(drawTriangles)\n  obj_loader->draw(GL_TRIANGLES);\n\n  if(drawPoints)\n    obj_loader->draw(GL_POINTS);\n\n  if(drawLines)\n    obj_loader->draw(GL_LINES);\n  //Draw the RIGHT eye, right half of the screen\n  glViewport(width/2, 0, width/2, height);\n  computeStereoViewProjectionMatrices(g_window, IOD, depthZ, false);\n  projection_matrix = getProjectionMatrix();\n  view_matrix = getViewMatrix();\n  model_matrix = glm::mat4(1.0);\n  model_matrix = glm::translate(model_matrix, glm::vec3(0.0f, 0.0f, -depthZ));\n  model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateY, glm::vec3(0.0f, 1.0f, 0.0f));\n  model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateX, glm::vec3(1.0f, 0.0f, 0.0f));\n  mvp = projection_matrix * view_matrix * model_matrix;\n  glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);\n  if(drawTriangles)\n    obj_loader->draw(GL_TRIANGLES);\n  if(drawPoints)\n    obj_loader->draw(GL_POINTS);\n  if(drawLines)\n    obj_loader->draw(GL_LINES);\n}\n```"]