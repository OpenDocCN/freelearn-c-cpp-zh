<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Improving Performance with Object Pools</h1>
            

            
                
<p class="calibre2">In programming languages, one of the most time-consuming things for the computer to do is deal with memory allocation. It's fairly inefficient and, depending on the resources being used, could slow down your game drastically.</p>
<p class="calibre2">A common element found in shooter games, or any game with explosions or bullets, is to create and destroy many objects in quick succession. Take, for example, the <em class="calibre12">Touhou Project</em> series of games, where there are many bullets being fired by both the player and enemies. When done in the simplest manner, calling <kbd class="calibre14">new</kbd> when you want to create a bullet and <kbd class="calibre14">delete</kbd> when you want to remove it will cause our game to lag or freeze over time.</p>
<p class="calibre2">To prevent this from happening, we can make use of the Object Pool pattern.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, we will create an object pool that will allow players to spawn a large number of bullets on the screen for the game.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            
                
<p class="calibre2">This chapter will be split into a number of topics. It will contain a simple step-by-step process from beginning to end. Here is the outline of our tasks:</p>
<ul class="calibre17">
<li class="calibre18">Why we should care about memory</li>
<li class="calibre18">The Object Pool pattern explained</li>
<li class="calibre18">Using memory pools--overloading <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd></li>
<li class="calibre18">Design decisions</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Why you should care about memory</h1>
            

            
                
<p class="calibre2">As a programmer, you're probably already used to using <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd> (or <kbd class="calibre14">malloc</kbd> and <kbd class="calibre14">free</kbd> if you're writing C), and you may be wondering why you would want to handle memory by yourself when it's already built into the language and is easy to use. Well, the first thing is that like most aspects of using a high-level programming language, you do not know what is going on behind the scenes. If you write your own logic to handle memory, you can create your own statistics and additional debugging support, such as automatically initializing data. You can also check for things such as memory leaks.</p>
<p class="calibre2">However, for game developers the most important aspect to look into is that of performance. Allocating memory for a single object or thousands of them at once is approximately the same time as the computer needs to look through your computer's memory for an opening that isn't being used, and then give you the address to the beginning of that contiguous piece of memory. If you keep requesting small pieces of memory over and over again this can lead to memory fragmentation, which is to say that there isn't enough free continuous space when you want to get a larger object.</p>
<div><img class="alignnone15" src="img/00045.jpeg"/></div>
<p class="calibre2">We may start off with some memory like this, with the gray sections being free memory and black being memory set aside because we called <kbd class="calibre14">new</kbd> for that amount of data. Each time we call for new, the computer needs to look for the first address that is open which has enough space to fit the object type we provide:</p>
<div><img class="alignnone16" src="img/00046.jpeg"/></div>
<p class="calibre2">Later on, we remove some of the memory and that opens up some space, but the computer will need to look at each address and spend more time searching:</p>
<div><img class="alignnone16" src="img/00047.jpeg"/></div>
<p class="calibre2">Finally, we get to a spot where we have very little open data and it requires a lot of work to find a place to insert new data, due to the memory becoming fragmented.</p>
<p class="calibre2">This is especially important if you are developing titles for a console or for a mobile device, as the size of memory you have to work with is much smaller than what you're used to working with on a PC. If you used computers five or more years ago you may remember the idea of defragging your computer, in which your computer would shift pieces of memory over in order to create larger blocks that could be used later. But this was a very time-consuming process.</p>
<p class="calibre2">Mach5 doesn't easily give us the ability to support having game objects being created in this way but, if you are interested in doing this, we do have a way that can use the concepts of an object pool in order to not waste resources; we will discuss that later on in the chapter.</p>
<p>An excellent article on writing memory managers for game programming can be found at <a href="http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php" target="_blank" class="calibre24">http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php</a>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">The Object Pool pattern explained</h1>
            

            
                
<p class="calibre2">Previously, we talked about the Singleton design pattern and how it's used to create a single instance of something inside of our project, often something static. We know there is only one and it's only created once, and that we can share it with the rest of our project without issues. However, the Singleton pattern only works when the instance is initialized.</p>
<p class="calibre2">The object pool is similar but, instead of one object, we want to have a group (or pool) of objects (or instances) that we can refer to within the rest of the project. Whenever the project wants to access these objects, we have another object called an <strong class="calibre1">object pool</strong>, which acts as a liaison between the project and the objects themselves.</p>
<p class="calibre2">Also called a resource pool or an N-ton elsewhere in computer science (but most frequently in game development referred to as an object pool) you can think of the object pool as having a similar role to a manager. When our program wants an object to work with, the manager knows which objects are currently being used and will give you one that isn't, or expand to create a new one. This promotes reusing previously created objects instead of creating and deleting them on the fly. This provides a number of advantages when the cost of initializing a class instance is an expensive operation, or when the rate of instantiation is high and the amount of time the objects are being used is low.</p>
<p class="calibre2">Let's consider our space shooter game as an example. Any time we press the spacebar, we have been creating a new object of the laser we want to shoot out. Also, any time we shoot something, we have to destroy them. This will slow down the performance of our game. This is not a huge issue now with such a simple game, but in AAA games we use this idea a lot, for example, in any of the games in the Naughty Dog's <em class="calibre12">Uncharted</em> series or most FPS titles. The enemies in these games are very complex, and having them in the game is very expensive. Instead of having a bunch of enemy objects in the game what will often be done instead is, after using enemies and having them die, they just turn invisible and when you need a new enemy, the dead object gets moved to a new position and gets turned on again.</p>
<p class="calibre2">The very basic elements of an object pool will look something like this:</p>
<div><img class="alignnone17" src="img/00048.jpeg"/></div>
<p class="calibre2">In our object pool's case, we have some type of variable that we want to hold the copies of. In this case, I've named it <kbd class="calibre14">GameObject</kbd>, but you'll also hear it referred to as a <kbd class="calibre14">Reusable</kbd> or <kbd class="calibre14">Resource</kbd> class instead. We use the <kbd class="calibre14">AcquireObject</kbd> function to get an object from our object pool, and we use the <kbd class="calibre14">ReleaseObject</kbd> function when we are finished working with it. The <kbd class="calibre14">GetInstance</kbd> function works in a similar manner to how it did with the Singleton class we talked about earlier, by giving us access to the <kbd class="calibre14">ObjectPool</kbd> referred to by it.</p>
<p class="calibre2">In the Mach5 Engine, there isn't an included object pool by default, so we will actually need to extend the engine to support it. That means we'll need to actually build one from scratch.</p>
<p class="calibre2">There are multiple ways to implement the Object Pool pattern or to get a similar behavior. We'll go over some of the commonly seen versions and the cons before moving to our final version.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Implementing a basic object pool</h1>
            

            
                
<p class="calibre2">Let's first start off by creating an object pool for a simple class that we can create multiples of:</p>
<pre class="calibre23">
class GameObject <br class="title-page-name"/>{ <br class="title-page-name"/>private: <br class="title-page-name"/>  // Character's health <br class="title-page-name"/>  int currentHealth; <br class="title-page-name"/>  int maxHealth; <br class="title-page-name"/> <br class="title-page-name"/>  // Character's name <br class="title-page-name"/>  std::string name; <br class="title-page-name"/> <br class="title-page-name"/>public: <br class="title-page-name"/>  GameObject(); <br class="title-page-name"/>  void Initialize(std::string _name = "Unnamed", <br class="title-page-name"/>     int _maxHealth = -1); <br class="title-page-name"/>  std::string GetInfo(); <br class="title-page-name"/> <br class="title-page-name"/>};
</pre>
<p class="calibre2">So, this sample <kbd class="calibre14">GameObject</kbd> class contains a name of the object to identify it by and some example properties to make the class seem more game-object-like. Obviously, you can easily add more properties and the same principles apply. In this case, we have a function called <kbd class="calibre14">Initialize</kbd>, which provides both a <kbd class="calibre14">set</kbd> and <kbd class="calibre14">reset</kbd> of values for the class. Finally, I added in a <kbd class="calibre14">GetInfo</kbd> function to print out information about the class so we can verify that things are working correctly.</p>
<p class="calibre2">The implementation for the class will look something like this:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Constructor that initializes the class' data <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>GameObject::GameObject() <br class="title-page-name"/>{ <br class="title-page-name"/>  Initialize(); <br class="title-page-name"/>} <br class="title-page-name"/>   <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Initializes or resets the values of the class <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>void GameObject::Initialize(std::string _name, int _maxHealth) <br class="title-page-name"/>{ <br class="title-page-name"/>  name = _name; <br class="title-page-name"/>  maxHealth = _maxHealth; <br class="title-page-name"/>  currentHealth = maxHealth; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Prints out information about the class <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>std::string GameObject::GetInfo() <br class="title-page-name"/>{ <br class="title-page-name"/>  return name + ": " + std::to_string(currentHealth) + "/" + <br class="title-page-name"/>     std::to_string(maxHealth); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Now that we have our game objects created, we need the pool to be created:</p>
<pre class="calibre23">
class GameObject; <br class="title-page-name"/> <br class="title-page-name"/>class ObjectPool <br class="title-page-name"/>{ <br class="title-page-name"/>private: <br class="title-page-name"/>  std::list&lt;GameObject*&gt; pool; <br class="title-page-name"/>  static ObjectPool* instance; <br class="title-page-name"/> <br class="title-page-name"/>  // Private constructor so users are unable to create without <br class="title-page-name"/>  // GetInstance <br class="title-page-name"/>  ObjectPool() {} <br class="title-page-name"/> <br class="title-page-name"/>public: <br class="title-page-name"/> <br class="title-page-name"/>  static ObjectPool* GetInstance(); <br class="title-page-name"/>  GameObject* AcquireObject(); <br class="title-page-name"/>  void ReleaseObject(GameObject* object); <br class="title-page-name"/>  void ClearPool(); <br class="title-page-name"/> <br class="title-page-name"/>};
</pre>
<p class="calibre2">To start off with there are two variables: <kbd class="calibre14">pool</kbd>, which will contain all of the available objects within our object pool, and <kbd class="calibre14">instance</kbd>, which is a way for us to access it. Note that our object pool uses the Singleton design pattern, in that there can only be one per type of object you'd like to have copies of. In this instance, we have the same issues that we talked about earlier, namely that you have to actually delete the pool and remove all of the elements that were created, which is why we added in a <kbd class="calibre14">ClearPool</kbd> function which does exactly that. The implementation for the class will look something like this:</p>
<pre class="calibre23">
ObjectPool* ObjectPool::GetInstance() <br class="title-page-name"/>{ <br class="title-page-name"/>  if (instance == nullptr) <br class="title-page-name"/>  { <br class="title-page-name"/>    instance = new ObjectPool(); <br class="title-page-name"/>  } <br class="title-page-name"/>  return instance; <br class="title-page-name"/>}
</pre>
<p class="calibre2">In this preceding function, we first check if <kbd class="calibre14">instance</kbd> is set. If it's not, we dynamically allocate memory for it and set the <kbd class="calibre14">instance</kbd> variable to it. Either way, we'll have an instance afterwards, and that is what we return:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Returns the first available object if it exists. If not, it will create a new <br class="title-page-name"/>one for us <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/> <br class="title-page-name"/>GameObject* ObjectPool::AcquireObject() <br class="title-page-name"/>{ <br class="title-page-name"/>  // Check if we have any objects available <br class="title-page-name"/>  if (!pool.empty()) <br class="title-page-name"/>  { <br class="title-page-name"/>    // Get reference to an avaliable object <br class="title-page-name"/>    GameObject* object = pool.back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Since we are going to use it, it's no longer available, <br class="title-page-name"/>    // so we need to remove the last element from our list <br class="title-page-name"/>    pool.pop_back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Finally, return the reference <br class="title-page-name"/>    return object; <br class="title-page-name"/>  } <br class="title-page-name"/>  else <br class="title-page-name"/>  { <br class="title-page-name"/>    // If none are available, create a new one <br class="title-page-name"/>    return new GameObject() <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Marks an object as being available again <br class="title-page-name"/> <br class="title-page-name"/>\param <br class="title-page-name"/>The object to be made available again <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>void ObjectPool::ReleaseObject(GameObject* object) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Reset the object <br class="title-page-name"/>  object-&gt;Initialize(); <br class="title-page-name"/> <br class="title-page-name"/>  // Add it to our avaliable list <br class="title-page-name"/>  pool.push_back(object); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Takes care of removing all of the objects from the pool whenever we're finished <br class="title-page-name"/>working with it. <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>void ObjectPool::ClearPool() <br class="title-page-name"/>{ <br class="title-page-name"/>  while (!pool.empty()) <br class="title-page-name"/>  { <br class="title-page-name"/>    GameObject * object = pool.back(); <br class="title-page-name"/>    pool.pop_back(); <br class="title-page-name"/>    delete object; <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre14">ClearPool</kbd> function will continuously remove objects from the pool until it is empty. We first get a reference to the object, by retrieving the last element using the <kbd class="calibre14">back</kbd> function.</p>
<p class="calibre2">We then remove the element from the pool before deleting the object itself safely:</p>
<pre class="calibre23">
ObjectPool* ObjectPool::instance = 0;
</pre>
<p class="calibre2">Finally, C++ requires that we initialize the <kbd class="calibre14">instance</kbd> variable, so we add that last.</p>
<p class="calibre2">Once we have this foundational code in, we can start to use the classes. An example usage could be the following:</p>
<pre class="calibre23">
  ObjectPool* pool = ObjectPool::GetInstance(); <br class="title-page-name"/>  GameObject * slime = pool-&gt;AcquireObject(); <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "Initial: " &lt;&lt; slime-&gt;GetInfo() &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/>  slime-&gt;Initialize("Slime", 10); <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "After Assignment: " &lt;&lt; slime-&gt;GetInfo() &lt;&lt; <br class="title-page-name"/>std::endl; <br class="title-page-name"/> <br class="title-page-name"/>  pool-&gt;ReleaseObject(slime); <br class="title-page-name"/> <br class="title-page-name"/>  slime = pool-&gt;AcquireObject(); <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "Reused: " &lt;&lt; slime-&gt;GetInfo() &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/>  pool-&gt;ClearPool(); <br class="title-page-name"/>  delete pool;
</pre>
<p class="calibre2">If we save this script and run it in a blank project, you'll see the following:</p>
<div><img class="image-border8" src="img/00049.gif"/></div>
<p class="calibre2">In this case, we first get our <kbd class="calibre14">ObjectPool</kbd> that makes use of the <kbd class="calibre14">GetInstance</kbd> function, and then obtain an object from the object pool using the <kbd class="calibre14">AcquireObject</kbd> function (which calls <kbd class="calibre14">new</kbd> to create the object). From there we print out its values and, due to the constructor, it is set to our predefined default values. We then assign the values and use it. Afterward, we release it from the list in which we placed it on the pool, to be reused when we are ready. We then get the object again and show that it's already reset to be reused in exactly the same way as before!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Operator overloading in C++</h1>
            

            
                
<p class="calibre2">We now have a good foundation to build on, but we can actually make our object pool much nicer to use. One of the cooler features in C++ is the fact that you can override the default behaviors of operators, typically referred to as <strong class="calibre1">operator overloading</strong>. This is done with functions being created with specific names that contain the operator keyword, followed by what operator you want to define. Just like regular functions, they have return types as well as parameters that get passed to them.</p>
<p>For more information on operator overloading and how it works in C++, check out <a href="http://www.cprogramming.com/tutorial/operator_overloading.html" target="_blank" class="calibre24">http://www.cprogramming.com/tutorial/operator_overloading.html</a>.</p>
<p class="calibre2">In addition to common operators, such as <kbd class="calibre14">+</kbd>, <kbd class="calibre14">-</kbd>, and <kbd class="calibre14">/</kbd>, we also have the ability to overload the <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd> operators as well, allowing us to use our own custom object pool instead!</p>
<p class="calibre2">To do this, we will need to add the following to the end of the <kbd class="calibre14">GameObject</kbd> class, and add the following bold lines to the class definition:</p>
<pre class="calibre23">
class GameObject <br class="title-page-name"/>{ <br class="title-page-name"/>private: <br class="title-page-name"/>  // Character's health <br class="title-page-name"/>  int currentHealth; <br class="title-page-name"/>  int maxHealth; <br class="title-page-name"/> <br class="title-page-name"/>  // Character's name <br class="title-page-name"/>  std::string name; <br class="title-page-name"/> <br class="title-page-name"/>public: <br class="title-page-name"/>  GameObject(); <br class="title-page-name"/>  void Initialize(std::string _name = "Unnamed", <br class="title-page-name"/>     int _maxHealth = -1); <br class="title-page-name"/>  std::string GetInfo(); <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  void* operator new(size_t);<br class="title-page-name"/></strong><strong class="calibre1">  void operator delete(void* obj);</strong> <br class="title-page-name"/> <br class="title-page-name"/>};
</pre>
<p class="calibre2">Here, we added two new functions to the <kbd class="calibre14">GameObject</kbd> class--one for us to create our own version of <kbd class="calibre14">new</kbd> and another for our version of <kbd class="calibre14">delete</kbd>. Then, we need to add the implementations:</p>
<pre class="calibre23">
void* GameObject::operator new(size_t) <br class="title-page-name"/>{ <br class="title-page-name"/>  return ObjectPool::GetInstance()-&gt;AcquireObject(); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>void GameObject::operator delete(void* obj) <br class="title-page-name"/>{ <br class="title-page-name"/>  ObjectPool::GetInstance()-&gt;ReleaseObject(static_cast&lt;GameObject*&gt;(obj)); <br class="title-page-name"/>}
</pre>
<p class="calibre2">In our case, we are just using the <kbd class="calibre14">ObjectPool</kbd> class' functions to acquire and release our objects when needed, instead of just allocating memory all of the time. Then, we can modify the original implementation code as follows:</p>
<pre class="calibre23">
  ObjectPool* pool = ObjectPool::GetInstance(); <br class="title-page-name"/><strong class="calibre1">  GameObject * slime = new GameObject();</strong> <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "Initial: " &lt;&lt; slime-&gt;GetInfo() &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/>  slime-&gt;Initialize("Slime", 10); <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "After Assignment: " <br class="title-page-name"/>     &lt;&lt; slime-&gt;GetInfo() &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">  delete slime;<br class="title-page-name"/></strong><strong class="calibre1">  slime = new GameObject();</strong> <br class="title-page-name"/> <br class="title-page-name"/>  std::cout &lt;&lt; "Reused: " &lt;&lt; slime-&gt;GetInfo() &lt;&lt; std::endl; <br class="title-page-name"/> <br class="title-page-name"/>  pool-&gt;ClearPool(); <br class="title-page-name"/>  delete pool; <br class="title-page-name"/> <br class="title-page-name"/>  return 0;
</pre>
<p class="calibre2">Now, don't run the code just yet. If you remember, we call the <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd> operators inside of our <kbd class="calibre14">ObjectPool</kbd> class, so running the code now will cause a stack overflow error, because when <kbd class="calibre14">AquireObject</kbd> calls <kbd class="calibre14">new</kbd>, it will call the <kbd class="calibre14">GameObject</kbd> class' version of <kbd class="calibre14">new</kbd>, which in turn calls the <kbd class="calibre14">AquireObject</kbd> function, and so on and so forth. To fix this, we'll need to use the C version of allocating memory, the <kbd class="calibre14">malloc</kbd> and <kbd class="calibre14">free</kbd> functions, in order to get memory from the system:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Returns the first available object if it exists. If not, it will create a new <br class="title-page-name"/>one for us <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/> <br class="title-page-name"/>GameObject* ObjectPool::AcquireObject() <br class="title-page-name"/>{ <br class="title-page-name"/>  // Check if we have any objects available <br class="title-page-name"/>  if (!pool.empty()) <br class="title-page-name"/>  { <br class="title-page-name"/>    // Get reference to an avaliable object <br class="title-page-name"/>    GameObject* object = pool.back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Since we are going to use it, it's no longer available, so <br class="title-page-name"/>    // we need to remove the last element from our list <br class="title-page-name"/>    pool.pop_back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Finally, return the reference <br class="title-page-name"/>    return object; <br class="title-page-name"/>  } <br class="title-page-name"/>  else <br class="title-page-name"/>  { <br class="title-page-name"/>    // If none are avaliable, create a new one <br class="title-page-name"/><strong class="calibre1">    return static_cast&lt;GameObject*&gt;(malloc(sizeof(GameObject)));</strong> <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Takes care of removing all of the objects from the pool whenever we're finished <br class="title-page-name"/>working with it. <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>void ObjectPool::ClearPool() <br class="title-page-name"/>{ <br class="title-page-name"/>  while (!pool.empty()) <br class="title-page-name"/>  { <br class="title-page-name"/>    GameObject * object = pool.back(); <br class="title-page-name"/>    pool.pop_back(); <br class="title-page-name"/><strong class="calibre1">    free(object);</strong> <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Now we should be able to run and see if everything is working the way we intended! This version works fairly well as long as you want your users to still call <kbd class="calibre14">new</kbd> and <kbd class="calibre14">delete</kbd>; however, it gives you a performance boost over time.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Building the object pool for Mach5</h1>
            

            
                
<p class="calibre2">Now that we've seen an object pool in action, let's next learn how we can integrate the Object Pool pattern into the Mach5 game engine. Since we are creating a shooter game, one of the things that we spawn a lot during gameplay are the laser bullets from our ship, which makes it perfect for using object pool functionality. And unlike the previous examples, we'll see a version of the object pool that will not need to use pointers to access the pool, and we'll not have to worry about the pool being created. To do this, we'll need to make some adjustments to the starter project. First, we are going to need to change how our bullets are destroyed.</p>
<p class="calibre2">If you go into the <kbd class="calibre14">Bullet.ini</kbd> file located at <kbd class="calibre14">Mach5-master\EngineTest\EngineTest\ArcheTypes</kbd>, you'll see the following:</p>
<pre class="calibre23">
posX = 0<br class="title-page-name"/>posY = 0<br class="title-page-name"/>velX = 0<br class="title-page-name"/>velY = 0<br class="title-page-name"/>scaleX = 2.5<br class="title-page-name"/>scaleY = 2.5<br class="title-page-name"/>rot = 0<br class="title-page-name"/>rotVel = 0<br class="title-page-name"/>components = GfxComponent ColliderComponent OutsideViewKillComponent<br class="title-page-name"/><br class="title-page-name"/>[GfxComponent]<br class="title-page-name"/>texture = bullet.tga<br class="title-page-name"/>drawSpace = world<br class="title-page-name"/>texScaleX = 1<br class="title-page-name"/>texScaleY = 1<br class="title-page-name"/>texTransX = 0<br class="title-page-name"/>texTransY = 0<br class="title-page-name"/><br class="title-page-name"/>[ColliderComponent]<br class="title-page-name"/>radius = 1.25
</pre>
<p class="calibre2">Go in and remove <kbd class="calibre14">OutsideViewKillComponent</kbd> and replace it with <kbd class="calibre14">BulletComponent</kbd>. We are replacing <kbd class="calibre14">OutsideViewKillComponent</kbd> because when it leaves the screen, it will set the object's <kbd class="calibre14">isDead</kbd> property to <kbd class="calibre14">true</kbd>, which will call <kbd class="calibre14">delete</kbd> on it and remove it from the world. We are actually going to take care of this ourselves, so let's replace this with our own behavior, which we will write inside of the <kbd class="calibre14">BulletComponent</kbd> script that we will write later on in this chapter.</p>
<p class="calibre2">Next, we will want to create a new place for our <kbd class="calibre14">ObjectPool</kbd> so, with that in mind, go to the Solution Explorer tab and then right-click on the Core/Singletons folder and select New Filter. Once you create one, name it <kbd class="calibre14">ObjectPool</kbd>. From there, right-click on the newly created folder and select New Item.... Then, from the menu select the Header File (.h) option and give it a name of <kbd class="calibre14">M5ObjectPool.h</kbd>.</p>
<p class="calibre2">In the <kbd class="calibre14">.h</kbd> file, we'll put in the following code:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>\file   M5ObjectPool.h <br class="title-page-name"/>\author John P. Doran <br class="title-page-name"/>\par    email: john\@johnpdoran.com <br class="title-page-name"/>\par    Mach5 Game Engine <br class="title-page-name"/>\date   2016/11/19 <br class="title-page-name"/> <br class="title-page-name"/>Globally accessible static class for object caching to avoid creating new objects <br class="title-page-name"/>if we already have one not being used. <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>#ifndef M5OBJECT_POOL_H <br class="title-page-name"/>#define M5OBJECT_POOL_H <br class="title-page-name"/> <br class="title-page-name"/>#include &lt;vector&gt; <br class="title-page-name"/>#include &lt;queue&gt; <br class="title-page-name"/> <br class="title-page-name"/>#include "EngineTest\Source\Core\M5Object.h" <br class="title-page-name"/> <br class="title-page-name"/>template &lt;M5ArcheTypes T&gt; <br class="title-page-name"/>class M5ObjectPool <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  // Gives to us the first available object, creating a new one if none is available <br class="title-page-name"/>  static M5Object * AcquireObject(); <br class="title-page-name"/>   <br class="title-page-name"/>  // Returns the object to the pool making it available for reuse <br class="title-page-name"/>  static void ReleaseObject(M5Object* object); <br class="title-page-name"/> <br class="title-page-name"/>  // Removes all of the objects in the pool and removes references<br class="title-page-name"/>  // as needed <br class="title-page-name"/>  static void ClearPool(); <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  // All of the objects in the object pool <br class="title-page-name"/>  static std::vector&lt;M5Object*&gt;  pool; <br class="title-page-name"/> <br class="title-page-name"/>  // All of the objects that are currently available <br class="title-page-name"/>  static std::deque&lt;M5Object*&gt; available; <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>#endif //M5OBJECT_POOL_H
</pre>
<p class="calibre2">You'll notice that the class is very similar to what we've done in the past but, instead of using the <kbd class="calibre14">GameObject</kbd> class, we are going to use the Mach5 engine's <kbd class="calibre14">M5Object</kbd> class. We've also templatized the class to make it so that this will work with any kind of object archetype that exists (including our bullet, which is represented by <kbd class="calibre14">AT_Bullet</kbd>). I've also added a new variable called <kbd class="calibre14">available</kbd>, which is a <strong class="calibre1">deque</strong> (pronounced <strong class="calibre1">deck</strong>), which stands for a double-ended queue. This variable will contain all of the objects that both exist and are unused, so we can easily tell if we have any objects that we can use or if we need to create a new one.</p>
<p>If you want to learn more about the deque class, check out <a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" class="calibre24">http://www.cplusplus.com/reference/deque/deque/</a>.</p>
<p class="calibre2">We'll also want to create an <kbd class="calibre14">M5ObjectPool.cpp</kbd> file as well. In the <kbd class="calibre14">.cpp</kbd>, we'll write the following code:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>\file   M5ObjectPool.cpp <br class="title-page-name"/>\author John P. Doran <br class="title-page-name"/>\par    email: john\@johnpdoran.com <br class="title-page-name"/>\par    Mach5 Game Engine <br class="title-page-name"/>\date   2016/11/19 <br class="title-page-name"/> <br class="title-page-name"/>Globally accessible static class for object caching to avoid creating new objects <br class="title-page-name"/>if we already have one not being used. <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>#include "M5ObjectPool.h" <br class="title-page-name"/>#include "Source\Core\M5ObjectManager.h" <br class="title-page-name"/> <br class="title-page-name"/>template class M5ObjectPool&lt;AT_Bullet&gt;;// explicit instantiation     <br class="title-page-name"/> <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Returns the first available object if it exists. If not, it will create a new <br class="title-page-name"/>one for us <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/> <br class="title-page-name"/>template &lt;M5ArcheTypes T&gt; <br class="title-page-name"/>M5Object * M5ObjectPool&lt;T&gt;::AcquireObject() <br class="title-page-name"/>{ <br class="title-page-name"/>  // Check if we have any available <br class="title-page-name"/>  if (!available.empty()) <br class="title-page-name"/>  { <br class="title-page-name"/>    // Get reference to an available object <br class="title-page-name"/>    M5Object * object = available.back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Since we are going to use it, it's no longer available, <br class="title-page-name"/>    // so we need to remove the last element from our list <br class="title-page-name"/>    available.pop_back(); <br class="title-page-name"/> <br class="title-page-name"/>    // Finally, return the reference <br class="title-page-name"/>    return object; <br class="title-page-name"/>  } <br class="title-page-name"/>  else <br class="title-page-name"/>  { <br class="title-page-name"/>    M5Object * object = M5ObjectManager::CreateObject(T); <br class="title-page-name"/> <br class="title-page-name"/>    pool.push_back(object); <br class="title-page-name"/> <br class="title-page-name"/>    return object; <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">In this instance, we are first going to check if we have any objects inside of the available list. If none exist we will spawn a new object, making use of the <kbd class="calibre14">M5ObjectManager</kbd> class' <kbd class="calibre14">CreateObject</kbd> function. We then add it to the pool as it is an object in our object pool, but we do not make it available as it's going to be used upon being acquired:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Marks an object as being available again <br class="title-page-name"/> <br class="title-page-name"/>\param <br class="title-page-name"/>The object to be made available again <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>template &lt;M5ArcheTypes T&gt; <br class="title-page-name"/>void M5ObjectPool&lt;T&gt;::ReleaseObject(M5Object * object) <br class="title-page-name"/>{ <br class="title-page-name"/>  // If it's valid, move this object into our available list <br class="title-page-name"/>  if ((object-&gt;GetType() == T) &amp;&amp; <br class="title-page-name"/>    (std::find(pool.begin(), pool.end(), object) != pool.end())) <br class="title-page-name"/>  { <br class="title-page-name"/>    //Make sure we haven't already been added already <br class="title-page-name"/>    if(std::find(available.begin(), available.end(), object) == available.end()) <br class="title-page-name"/>    { <br class="title-page-name"/>      available.push_back(object); <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>}
</pre>
<p class="calibre2">In this case, the <kbd class="calibre14">ReleaseObject</kbd> function marks an object as being available for reuse. But, we want to do some error checking to make sure that the function is being used properly and isn't being provided with an invalid object.</p>
<p class="calibre2">First, the code makes sure that the object is the same type as the object pool's and that it is actually located inside the pool somewhere. This ensures that we will only be adding objects that are valid into our available deque. If we know the object is valid, we then look through the objects we already have in the deque and make sure that the object hasn't already been added before. If it hasn't, we then add it into the available deque:</p>
<pre class="calibre23">
/*************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Takes care of removing all of the objects from the pool whenever we're finished working with it. <br class="title-page-name"/>*/ <br class="title-page-name"/>/*************************************************************************/ <br class="title-page-name"/>template&lt;M5ArcheTypes T&gt; <br class="title-page-name"/>void M5ObjectPool&lt;T&gt;::ClearPool() <br class="title-page-name"/>{   <br class="title-page-name"/>  //  Go through each of our objects and destroy them <br class="title-page-name"/>  for (int i = pool.size() - 1; i &gt;= 0; --i) <br class="title-page-name"/>  { <br class="title-page-name"/>    M5ObjectManager::DestroyObject(pool[i]); <br class="title-page-name"/>    pool.pop_back(); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  // Now clear out the available queue <br class="title-page-name"/>  available.clear(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">In the <kbd class="calibre14">ClearPool</kbd> function, we just go through every object in the pool and destroy that game object. Then, we clear out the available list:</p>
<pre class="calibre23">
template&lt;M5ArcheTypes T&gt; <br class="title-page-name"/>std::vector&lt;M5Object*&gt;  M5ObjectPool&lt;T&gt;::pool; <br class="title-page-name"/> <br class="title-page-name"/>template&lt;M5ArcheTypes T&gt; <br class="title-page-name"/>std::deque&lt;M5Object*&gt;  M5ObjectPool&lt;T&gt;::available;
</pre>
<p class="calibre2">Finally, we need to declare the pool and available objects so they can be created in the future.</p>
<p class="calibre2">Now that we have this base functionality, we need to return these objects back to our available pool. To do this, we'll need to add the <kbd class="calibre14">BulletComponent</kbd> component we mentioned previously. Since this component is exclusive to our game, let's move over to the <kbd class="calibre14">SpaceShooter</kbd>/<kbd class="calibre14">Components</kbd> filter and create a new filter called <kbd class="calibre14">BulletComp</kbd>. From there, create two new files, <kbd class="calibre14">BulletComponent.h</kbd> and <kbd class="calibre14">BulletComponent.cpp</kbd>, making sure the location is set to the <kbd class="calibre14">Mach5-master\EngineTest\EngineTest\Source\</kbd> folder.</p>
<p class="calibre2">In the <kbd class="calibre14">.h</kbd> file, put in the following:</p>
<pre class="calibre23">
#ifndef BULLET_COMPONENT_H <br class="title-page-name"/>#define BULLET_COMPONENT_H <br class="title-page-name"/> <br class="title-page-name"/>#include "Core\M5Component.h" <br class="title-page-name"/> <br class="title-page-name"/>//!&lt; Removes The parent Game Object if it is outside the view port <br class="title-page-name"/>class BulletComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  BulletComponent(); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual M5Component* Clone(void); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>#endif // !BULLET_COMPONENT_H
</pre>
<p class="calibre2">Next, inside of the <kbd class="calibre14">.cpp</kbd> file, use the following:</p>
<pre class="calibre23">
#include "BulletComponent.h" <br class="title-page-name"/>#include "Core\M5Gfx.h" <br class="title-page-name"/>#include "Core\M5Math.h" <br class="title-page-name"/>#include "Core\M5Object.h"   <br class="title-page-name"/>#include "EngineTest\M5ObjectPool.h" <br class="title-page-name"/> <br class="title-page-name"/>BulletComponent::BulletComponent(): <br class="title-page-name"/>M5Component(CT_BulletComponent) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>void BulletComponent::Update(float /*dt*/) <br class="title-page-name"/>{ <br class="title-page-name"/>  M5Vec2 pos = m_pObj-&gt;pos; <br class="title-page-name"/>  M5Vec2 scale = m_pObj-&gt;scale; <br class="title-page-name"/>  scale *= .5f; <br class="title-page-name"/>  M5Vec2 botLeft; <br class="title-page-name"/>  M5Vec2 topRight; <br class="title-page-name"/>  M5Gfx::GetWorldBotLeft(botLeft); <br class="title-page-name"/>  M5Gfx::GetWorldTopRight(topRight); <br class="title-page-name"/> <br class="title-page-name"/>  if (pos.x + scale.x &gt; topRight.x || pos.x - <br class="title-page-name"/>     scale.x &lt; botLeft.x || <br class="title-page-name"/>    pos.y + scale.y &gt; topRight.y || pos.y - scale.y &lt; botLeft.y) <br class="title-page-name"/>  { <br class="title-page-name"/>    M5ObjectPool&lt;AT_Bullet&gt;::ReleaseObject(m_pObj); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>M5Component * BulletComponent::Clone(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  BulletComponent * pNew = new BulletComponent; <br class="title-page-name"/>  pNew-&gt;m_pObj = m_pObj; <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Save your files. This will make it so that if the object has a bullet component, it'll be returned to the list; but we have to first make our objects. Go into the <kbd class="calibre14">PlayerInputComponent.cpp</kbd> file and update the section of code for creating bullets in the <kbd class="calibre14">Update</kbd> function, as follows:</p>
<pre class="calibre23">
//then check for bullets <br class="title-page-name"/> if (M5Input::IsTriggered(M5_SPACE) || M5Input::IsTriggered(M5_GAMEPAD_A))<br class="title-page-name"/> {<br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1"> M5Object* bullet1 = M5ObjectPool&lt;AT_Bullet&gt;::AcquireObject();</strong><br class="title-page-name"/><strong class="calibre1"> M5Object* bullet2 = M5ObjectPool&lt;AT_Bullet&gt;::AcquireObject();</strong><br class="title-page-name"/> bullet2-&gt;rotation = bullet1-&gt;rotation = m_pObj-&gt;rotation;<br class="title-page-name"/><br class="title-page-name"/> M5Vec2 bulletDir(std::cos(bullet1-&gt;rotation), std::sin(bullet1-&gt;rotation));<br class="title-page-name"/> M5Vec2 perp(bulletDir.y, -bulletDir.x);<br class="title-page-name"/> bullet1-&gt;pos = m_pObj-&gt;pos + perp * .5f * m_pObj-&gt;scale.y;<br class="title-page-name"/> bullet2-&gt;pos = m_pObj-&gt;pos - perp * .5f * m_pObj-&gt;scale.y;<br class="title-page-name"/><br class="title-page-name"/> M5Vec2::Scale(bulletDir, bulletDir, m_bulletSpeed * dt);<br class="title-page-name"/><br class="title-page-name"/> bullet1-&gt;vel = m_pObj-&gt;vel + bulletDir;<br class="title-page-name"/> bullet2-&gt;vel = m_pObj-&gt;vel + bulletDir;<br class="title-page-name"/><br class="title-page-name"/> }
</pre>
<p class="calibre2">Notice that we've replaced the creation of <kbd class="calibre14">bullet1</kbd> and <kbd class="calibre14">bullet2</kbd> to use our <kbd class="calibre14">ObjectPool</kbd> class' <kbd class="calibre14">AcquireObject</kbd> function, instead of our <kbd class="calibre14">ObjectManager</kbd> class' version.</p>
<p class="calibre2">Now it will be difficult for us to see if we are using objects that have just been created or if they are things we are reusing. Let's go back into <kbd class="calibre14">BulletComponent</kbd> and modify a property before we give it back to the object pool:</p>
<pre class="calibre23">
void BulletComponent::Update(float /*dt*/) <br class="title-page-name"/>{ <br class="title-page-name"/>  M5Vec2 pos = m_pObj-&gt;pos; <br class="title-page-name"/>  M5Vec2 scale = m_pObj-&gt;scale; <br class="title-page-name"/>  scale *= .5f; <br class="title-page-name"/>  M5Vec2 botLeft; <br class="title-page-name"/>  M5Vec2 topRight; <br class="title-page-name"/>  M5Gfx::GetWorldBotLeft(botLeft); <br class="title-page-name"/>  M5Gfx::GetWorldTopRight(topRight); <br class="title-page-name"/> <br class="title-page-name"/>  if (pos.x + scale.x &gt; topRight.x || pos.x - scale.x &lt; botLeft.x || <br class="title-page-name"/>    pos.y + scale.y &gt; topRight.y || pos.y - scale.y &lt; botLeft.y) <br class="title-page-name"/>  { <br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">    m_pObj-&gt;scale = M5Vec2(1.5f, 1.5f);</strong> <br class="title-page-name"/>    M5ObjectPool&lt;AT_Bullet&gt;::ReleaseObject(m_pObj); <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>}
</pre>
<p class="calibre2">Now we can go ahead and save our scripts and run our game!</p>
<div><img class="image-border23" src="img/00050.jpeg"/></div>
<p class="calibre2">You'll notice that, at the beginning of play, the objects have a scale of <kbd class="calibre14">2.5, 2.5</kbd>. However, once some objects go off the screen, you'll see something similar to the following screenshot:</p>
<div><img class="image-border24" src="img/00051.jpeg"/></div>
<p class="calibre2">When we shoot the new bullets, they have been scaled down! With this, we know that our pool is working correctly, and that we are reusing the objects we've made before!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Issues with object pools</h1>
            

            
                
<p class="calibre2">Now, as great as object pools are, we should take some time to talk about times when you would not want to use object pools, and the alternatives out there.</p>
<p class="calibre2">First of all, you need to remember that when you are using a memory manager, you are telling the computer that you are smarter than them and that you know how the data should be handled. This is more power than other languages tend to give you, and using Uncle Ben's famous line, "<em class="calibre12">with great power comes great responsibility"</em> as we mentioned previously in this book in <a href="part0047.html#1CQAE0-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 2</a>, <em class="calibre12">One Instance to Rule Them All - Singletons</em>. When using an object pool, you typically want to use it when objects only have a limited lifetime and a lot of them will be created, but not all at the same time. If at one point in time you'll have 10,000 on the screen, but the rest of the game you'll have 30 max, that 9,970 other objects' worth of memory will just be standing there waiting for you in the unlikely event that you want to use it again.</p>
<p class="calibre2">An alternative method of handling a lot of objects at once is through a circular linked list, in which the last element connects to the first. This will guarantee that you'll never create more things than you have allocated memory for. If you happen to go all the way around you'll just be replacing the oldest one and, if you have so many things on the screen at once, users will not notice the oldest one being removed. This can be useful for things such as particle systems which we will be talking about in <a href="part0179.html#5AMKM0-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 10</a>, <em class="calibre12">Sharing Objects with the Flyweight Pattern</em>. If you're spawning many particles, people probably will not notice the game replacing the oldest particles with new ones.</p>
<p>For more information on circular linked lists, check out <a href="https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm" target="_blank" class="calibre24">https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm</a>.</p>
<p class="calibre2">We were also using a type of object pool that allocated one element at a time. Alternatively, you could allocate memory for a large number of them at a time to ensure that you'll always have that memory reserved. While it's not needed in this case, it's definitely something to use for large classes.</p>
<p>While the code samples listed are in C#, Michal Warkocz lists some very good examples of why an object pool may be a bad choice to use here: <a href="https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/" target="_blank" class="calibre24">https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/</a>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">In this chapter, we have used object pools to reduce system resources and user frustration by storing and reusing objects instead of creating and removing them. After spending this time polishing your work, you'll probably want to spend time modifying the UI of your game, which is what we will be talking about in the next chapter!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>