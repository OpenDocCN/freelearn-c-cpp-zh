["```cpp\n    volatile int& x = memory_mapped_register_x();\n    volatile bool& y = memory_mapped_register_y();\n    int stack;\n\n    stack = x; // load\n    y = true; // store \n    stack += x; // load\n```", "```cpp\n    stack = 2*x; // load\n    y = true; // store\n```", "```cpp\nx is a view onto some hardware buffer, and the store to memory location y is the signal for the hardware to load the next four bytes of data into the x register. It might help to view the situation as an operator overloading, but in hardware. And if \"operator overloading, but in hardware\" sounds crazy to you, then you probably have zero reason to use volatile in your programs!\n```", "```cpp\n    // Global variables:\n    int64_t x = 0;\n    bool y = false;\n\n    void thread_A() {\n      x = 0x42'00000042;\n      y = true;\n    }\n\n    void thread_B() {\n      if (x) {\n        assert(x == 0x42'00000042);\n      }\n    }\n\n    void thread_C() {\n      if (y) {\n        assert(x == 0x42'00000042);\n      }\n    }\n```", "```cpp\n    // Global variables:\n    std::atomic<int64_t> x = 0;\n    std::atomic<bool> y = false;\n\n    void thread_A() {\n      x = 0x42'00000042; // atomic!\n      y = true; // atomic!\n    }\n\n    void thread_B() {\n      if (x) {\n        // The assignment to x happens atomically.\n        assert(x == 0x42'00000042);\n      }\n    }\n\n    void thread_C() {\n      if (y) {\n        // The assignment to x \"happens before\" the\n        // assignment to y, even from another thread's\n        // point of view.\n        assert(x == 0x42'00000042);\n      }\n    }\n```", "```cpp\n    std::atomic<int> a, b;\n    a = b; // DOES NOT COMPILE!\n```", "```cpp\n    int shortlived = b; // atomic load\n    a = shortlived; // atomic store\n```", "```cpp\n    int shortlived = b.load(); // atomic load\n    a.store(shortlived); // atomic store\n```", "```cpp\n    std::atomic<int> a = 6;\n\n    a *= 9; // This isn't allowed.\n\n    // But this is:\n\n    int expected, desired;\n    do {\n      expected = a.load();\n      desired = expected * 9;\n    } while (!a.compare_exchange_weak(expected, desired));\n\n    // At the end of this loop, a's value will\n    // have been \"atomically\" multiplied by 9.\n```", "```cpp\n    int expected = a.load();\n    while (!a.compare_exchange_weak(expected, expected * 9)) {\n      // continue looping\n    }\n```", "```cpp\n    void log(const char *message)\n    {\n      static std::mutex m;\n      m.lock(); // avoid interleaving messages on stdout\n      puts(message);\n      m.unlock();\n    }\n```", "```cpp\n    static std::mutex m;\n\n    void log1(const char *message) {\n      m.lock();\n      printf(\"LOG1: %s\\n\", message);\n      m.unlock();\n    }\n\n    void log2(const char *message) {\n      m.lock();\n      printf(\"LOG2: %s\\n\", message);\n      m.unlock();\n    }\n```", "```cpp\n    struct Logger {\n      std::mutex m_mtx;\n\n      void log1(const char *message) {\n        m_mtx.lock();\n        printf(\"LOG1: %s\\n\", message);\n        m_mtx.unlock();\n      }\n\n      void log2(const char *message) {\n        m_mtx.lock();\n        printf(\"LOG2: %s\\n\", message);\n        m_mtx.unlock();\n      }\n    };\n```", "```cpp\n    template<typename M>\n    class unique_lock {\n      M *m_mtx = nullptr;\n      bool m_locked = false;\n    public:\n      constexpr unique_lock() noexcept = default;\n      constexpr unique_lock(M *p) noexcept : m_mtx(p) {}\n\n      M *mutex() const noexcept { return m_mtx; }\n      bool owns_lock() const noexcept { return m_locked; }\n\n      void lock() { m_mtx->lock(); m_locked = true; }\n      void unlock() { m_mtx->unlock(); m_locked = false; }\n\n      unique_lock(unique_lock&& rhs) noexcept {\n        m_mtx = std::exchange(rhs.m_mtx, nullptr);\n        m_locked = std::exchange(rhs.m_locked, false);\n      }\n\n      unique_lock& operator=(unique_lock&& rhs) {\n        if (m_locked) {\n            unlock();\n        }\n        m_mtx = std::exchange(rhs.m_mtx, nullptr);\n        m_locked = std::exchange(rhs.m_locked, false);\n        return *this;\n      }\n\n      ~unique_lock() {\n        if (m_locked) {\n            unlock();\n        }\n      }\n    };\n```", "```cpp\n    struct Lockbox {\n      std::mutex m_mtx;\n      int m_value = 0;\n\n      void locked_increment() {\n        std::lock_guard<std::mutex> lk(m_mtx);\n        m_value += 1;\n      }\n\n      void locked_decrement() {\n        std::lock_guard lk(m_mtx); // C++17 only\n        m_value -= 1;\n      }\n    };\n```", "```cpp\n    class StreamingAverage {\n      double m_sum = 0;\n      int m_count = 0;\n      double m_last_average = 0;\n      std::mutex m_mtx;\n    public:\n      // Called from the single producer thread\n      void add_value(double x) {\n        std::lock_guard lk(m_mtx);\n        m_sum += x;\n        m_count += 1; // A\n      }\n\n      // Called from the single consumer thread\n      double get_current_average() {\n        std::lock_guard lk(m_mtx);\n        m_last_average = m_sum / m_count; // B\n        return m_last_average;\n      }\n\n      // Called from the single consumer thread\n      double get_last_average() const {\n        return m_last_average; // C\n      }\n\n      // Called from the single consumer thread\n      double get_current_count() const {\n        return m_count; // D\n      }\n    };\n```", "```cpp\n    class StreamingAverage {\n      double m_sum = 0;\n      int m_count = 0;\n      double m_last_average = 0;\n      std::mutex m_sum_count_mtx;\n\n      // ...\n    };\n```", "```cpp\n    class StreamingAverage {\n      struct {\n        double sum = 0;\n        int count = 0;\n        std::mutex mtx;\n      } m_guarded_sc;\n      double m_last_average = 0;\n\n      // ...\n    };\n```", "```cpp\n    template<class Data>\n    class Guarded {\n      std::mutex m_mtx;\n      Data m_data;\n\n      class Handle {\n        std::unique_lock<std::mutex> m_lk;\n        Data *m_ptr;\n      public:\n        Handle(std::unique_lock<std::mutex> lk, Data *p) :\n          m_lk(std::move(lk)), m_ptr(p) {}\n        auto operator->() const { return m_ptr; }\n      };\n    public:\n      Handle lock() {\n        std::unique_lock lk(m_mtx);\n        return Handle{std::move(lk), &m_data};\n      }\n    };\n```", "```cpp\n    class StreamingAverage {\n      struct Guts {\n        double m_sum = 0;\n        int m_count = 0;\n      };\n      Guarded<Guts> m_sc;\n      double m_last_average = 0;\n\n      // ...\n\n      double get_current_average() {\n        auto h = m_sc.lock();\n        m_last_average = h->m_sum / h->m_count;\n        return m_last_average;\n      }\n    };\nimpossible for any member function of StreamingAverage to access m_sum without owning a lock on m_mtx; access to the guarded m_sum is possible only via the RAII Handle type.\n```", "```cpp\n    double get_sum() {\n      return m_sc.lock()->m_sum; \n    }\n\n    int get_count() {\n      return m_sc.lock()->m_count;\n    }\n\n    double get_current_average() {\n      return get_sum() / get_count();\n    }\n```", "```cpp\n    double get_sum() {\n      return m_sc.lock()->m_sum; // LOCK 2\n    }\n\n    int get_count() {\n      return m_sc.lock()->m_count;\n    }\n\n    double get_current_average() {\n      auto h = m_sc.lock(); // LOCK 1\n      return get_sum() / get_count();\n    }\n```", "```cpp\n    std::timed_mutex m;\n    std::atomic<bool> ready = false;\n\n    std::thread thread_b([&]() {\n      std::lock_guard lk(m);\n      puts(\"Thread B got the lock.\");\n      ready = true;\n      std::this_thread::sleep_for(100ms);\n    });\n\n    while (!ready) {\n      puts(\"Thread A is waiting for thread B to launch.\");\n      std::this_thread::sleep_for(10ms);\n    }\n\n    while (!m.try_lock_for(10ms)) {\n      puts(\"Thread A spent 10ms trying to get the lock and failed.\");\n    }\n\n    puts(\"Thread A finally got the lock!\");\n    m.unlock();\n```", "```cpp\n    std::timed_mutex m1, m2;\n    std::atomic<bool> ready = false;\n\n    std::thread thread_b([&]() {\n      std::unique_lock lk1(m1);\n      std::unique_lock lk2(m2);\n      puts(\"Thread B got the locks.\");\n      ready = true;\n      std::this_thread::sleep_for(50ms);\n      lk1.unlock();\n      std::this_thread::sleep_for(50ms);\n    });\n\n    while (!ready) {\n      std::this_thread::sleep_for(10ms); \n    }\n\n    auto start_time = std::chrono::system_clock::now();\n    auto deadline = start_time + 100ms;\n\n    bool got_m1 = m1.try_lock_until(deadline);\n    auto elapsed_m1 = std::chrono::system_clock::now() - start_time;\n\n    bool got_m2 = m2.try_lock_until(deadline);\n    auto elapsed_m2 = std::chrono::system_clock::now() - start_time;\n\n    if (got_m1) {\n      printf(\"Thread A got the first lock after %dms.\\n\",\n      count_ms(elapsed_m1));\n      m1.unlock();\n    }\n    if (got_m2) {\n      printf(\"Thread A got the second lock after %dms.\\n\",\n      count_ms(elapsed_m2));\n      m2.unlock();\n    }  \n```", "```cpp\n    auto count_ms = [](auto&& d) -> int {\n      using namespace std::chrono;\n      return duration_cast<milliseconds>(d).count();\n    };\n```", "```cpp\n    template<class M> \n    std::unique_lock<M> upgrade(std::shared_lock<M> lk)\n    {\n      lk.unlock();\n      // Some other writer might sneak in here.\n      return std::unique_lock<M>(*lk.mutex());\n    }\n```", "```cpp\n    template<class M>\n    std::shared_lock<M> downgrade(std::unique_lock<M> lk)\n    {\n      lk.unlock();\n      // Some other writer might sneak in here.\n      return std::shared_lock<M>(*lk.mutex()); \n    }\n```", "```cpp\n    std::atomic<bool> ready = false;\n\n    std::thread thread_b([&]() {\n      prep_work();\n      ready = true;\n      main_work();\n    });\n\n    // Wait for thread B to be ready.\n    while (!ready) {\n      std::this_thread::sleep_for(10ms); \n    }\n    // Now thread B has completed its prep work.\n```", "```cpp\n    bool ready = false; // not atomic!\n    std::mutex ready_mutex;\n    std::condition_variable cv;\n\n    std::thread thread_b([&]() {\n      prep_work();\n      {\n        std::lock_guard lk(ready_mutex);\n        ready = true;\n      }\n      cv.notify_one();\n      main_work();\n    });\n\n    // Wait for thread B to be ready.\n    {\n      std::unique_lock lk(ready_mutex);\n      while (!ready) {\n        cv.wait(lk);\n      }\n    }\n    // Now thread B has completed its prep work.\n```", "```cpp\n    bool ready = false;\n    std::shared_mutex ready_rwlock;\n    std::condition_variable_any cv;\n    std::thread thread_b([&]() {\n      prep_work();\n      {\n        std::lock_guard lk(ready_rwlock);\n        ready = true;\n      }\n      cv.notify_one();\n      main_work();\n    });\n\n    // Wait for thread B to be ready.\n    {\n      std::shared_lock lk(ready_rwlock);\n      while (!ready) {\n        cv.wait(lk);\n      }\n    }\n    // Now thread B has completed its prep work.\n```", "```cpp\n    std::promise<int> p1, p2;\n    std::future<int> f1 = p1.get_future();\n    std::future<int> f2 = p2.get_future();\n\n      // If the promise is satisfied first,\n      // then f.get() will not block.\n    p1.set_value(42);\n    assert(f1.get() == 42);\n\n      // If f.get() is called first, then it\n      // will block until set_value() is called\n      // from some other thread.\n    std::thread t([&](){\n      std::this_thread::sleep_for(100ms);\n      p2.set_value(43);\n    });\n    auto start_time = std::chrono::system_clock::now();\n    assert(f2.get() == 43);\n    auto elapsed = std::chrono::system_clock::now() - start_time;\n    printf(\"f2.get() took %dms.\\n\", count_ms(elapsed));\n    t.join();\n```", "```cpp\n    std::promise<void> ready_p;\n    std::future<void> ready_f = ready_p.get_future();\n\n    std::thread thread_b([&]() {\n      prep_work();\n      ready_p.set_value();\n      main_work();\n    });\n\n      // Wait for thread B to be ready.\n    ready_f.wait();\n      // Now thread B has completed its prep work.\n```", "```cpp\n    MyAllocator myalloc{};\n    std::promise<int> p(std::allocator_arg, myalloc);\n    std::future<int> f = p.get_future();\n```", "```cpp\n    template<class T>\n    class simple_packaged_task {\n      std::function<T()> m_func;\n      std::promise<T> m_promise;\n    public:\n      template<class F>\n      simple_packaged_task(const F& f) : m_func(f) {}\n\n      auto get_future() { return m_promise.get_future(); }\n\n      void operator()() {\n        try {\n          T result = m_func();\n          m_promise.set_value(result);\n        } catch (...) {\n          m_promise.set_exception(std::current_exception());\n        }\n      }\n    };\n```", "```cpp\n    template<class T>\n    auto pf() {\n      std::promise<T> p;\n      std::future<T> f = p.get_future();\n      return std::make_pair(std::move(p), std::move(f));\n    }\n\n    void test() {\n      auto [p1, f1] = pf<Connection>();\n      auto [p2, f2] = pf<Data>();\n      auto [p3, f3] = pf<Data>();\n\n      auto t1 = std::thread([p1 = std::move(p1)]() mutable {\n        Connection conn = slowly_open_connection();\n        p1.set_value(conn);\n        // DANGER: what if slowly_open_connection throws?\n      });\n      auto t2 = std::thread([p2 = std::move(p2)]() mutable {\n        Data data = slowly_get_data_from_disk();\n        p2.set_value(data);\n      });\n      auto t3 = std::thread(\n      [p3 = std::move(p3), f1 = std::move(f1)]() mutable {\n        Data data = slowly_get_data_from_connection(f1.get());\n        p3.set_value(data);\n      });\n      bool success = (f2.get() == f3.get());\n\n      assert(success);\n    }\n```", "```cpp\n    void test() {\n      auto f1 = std::async(slowly_open_connection);\n      auto f2 = std::async(slowly_get_data_from_disk);\n      auto f3 = std::async([f1 = std::move(f1)]() mutable {\n        return slowly_get_data_from_connection(f1.get());\n        // No more danger.\n      });\n      bool success = (f2.get() == f3.get());\n\n      assert(success);\n    }\n```", "```cpp\n    void test() {\n      auto f1 = my::async(slowly_open_connection);\n      auto f2 = my::async(slowly_get_data_from_disk);\n      auto f3 = f1.then([](Connection conn) {\n        return slowly_get_data_from_connection(conn);\n      });\n      bool success = f2.get() == f3.get();\n\n      assert(success);\n    }\n```", "```cpp\n    using namespace std::literals; // for \"ms\"\n\n    std::thread a([](){\n      puts(\"Thread A says hello ~0ms\");\n      std::this_thread::sleep_for(10ms);\n      puts(\"Thread A says goodbye ~10ms\");\n    });\n\n    std::thread b([](){\n      puts(\"Thread B says hello ~0ms\");\n      std::this_thread::sleep_for(20ms);\n      puts(\"Thread B says goodbye ~20ms\");\n    });\n\n    puts(\"The main thread says hello ~0ms\");\n    a.join(); // waits for thread A\n    b.detach(); // doesn't wait for thread B\n    puts(\"The main thread says goodbye ~10ms\");\n```", "```cpp\n    std::string to_string(std::thread::id id)\n    {\n      std::ostringstream o;\n      o << id;\n      return o.str();\n    }\n```", "```cpp\n    std::mutex ready;\n    std::unique_lock lk(ready);\n    std::vector<std::thread> threads;\n\n    auto task = [&](){\n        // Block here until the main thread is ready.\n      (void)std::lock_guard(ready);\n        // Now go. Find my thread-id in the vector.\n      auto my_id = std::this_thread::get_id();\n      auto iter = std::find_if(\n        threads.begin(), threads.end(),\n        [=](const std::thread& t) {\n          return t.get_id() == my_id;\n         }\n      );\n      printf(\"Thread %s %s in the list.\\n\",\n        to_string(my_id).c_str(),\n        iter != threads.end() ? \"is\" : \"is not\");\n    };\n\n    std::vector<std::thread> others;\n    for (int i = 0; i < 10; ++i) {\n      std::thread t(task);\n      if (i % 2) {\n        threads.push_back(std::move(t));\n      } else {\n        others.push_back(std::move(t));\n      }\n    }\n\n      // Let all the threads run.\n    ready.unlock();\n\n      // Join all the threads.\n    for (std::thread& t : threads) t.join();\n    for (std::thread& t : others) t.join();\n```", "```cpp\n    template<class F>\n    auto async(F&& func) {\n      using ResultType = std::invoke_result_t<std::decay_t<F>>;\n      using PromiseType = std::promise<ResultType>;\n      using FutureType = std::future<ResultType>;\n\n      PromiseType promise;\n      FutureType future = promise.get_future();\n      auto t = std::thread([\n        func = std::forward<F>(func),\n        promise = std::move(promise)\n      ]() mutable {\n        try {\n          ResultType result = func();\n           promise.set_value(result);\n        } catch (...) {\n          promise.set_exception(std::current_exception());\n        }\n      });\n      // This special behavior is not implementable\n      // outside of the library, but async does do it.\n      // future.on_destruction([t = std::move(t)]() {\n      //  t.join();\n      // });\n      return future;\n    }\n```", "```cpp\n    template<class F>\n    void fire_and_forget_wrong(const F& f) {\n      // WRONG! Runs f in another thread, but blocks anyway.\n      std::async(f);\n    }\n\n    template<class F>\n    void fire_and_forget_better(const F& f) {\n      // BETTER! Launches f in another thread without blocking.\n      std::thread(f).detach();\n    }\n```", "```cpp\n    int test() {\n      int i = 0;\n      auto future = std::async([&]() {\n        i += 1;\n      });\n      // suppose we do not call f.wait() here\n      return i;\n    }\n```", "```cpp\n    class ThreadPool {\n      using UniqueFunction = std::packaged_task<void()>;\n      struct {\n        std::mutex mtx;\n        std::queue<UniqueFunction> work_queue;\n        bool aborting = false;\n      } m_state;\n      std::vector<std::thread> m_workers;\n      std::condition_variable m_cv;\n```", "```cpp\n    public:\n      ThreadPool(int size) {\n        for (int i=0; i < size; ++i) {\n          m_workers.emplace_back([this]() { worker_loop(); });\n        }\n      }\n```", "```cpp\n      ~ThreadPool() {\n        if (std::lock_guard lk(m_state.mtx); true) {\n          m_state.aborting = true;\n        }\n        m_cv.notify_all();\n        for (std::thread& t : m_workers) {\n          t.join();\n        }\n      }\n```", "```cpp\n      void enqueue_task(UniqueFunction task) {\n        if (std::lock_guard lk(m_state.mtx); true) {\n          m_state.work_queue.push(std::move(task));\n        }\n        m_cv.notify_one();\n      }\n```", "```cpp\n    private:\n      void worker_loop() {\n        while (true) {\n          std::unique_lock lk(m_state.mtx);\n          while (m_state.work_queue.empty() && !m_state.aborting) {\n            m_cv.wait(lk);\n          }\n          if (m_state.aborting) break;\n          // Pop the next task, while still under the lock.\n          assert(!m_state.work_queue.empty());\n          UniqueFunction task = std::move(m_state.work_queue.front());\n          m_state.work_queue.pop();\n\n          lk.unlock();\n          // Actually run the task. This might take a while.\n          task();\n          // When we're done with this task, go get another.\n        }\n      }\n```", "```cpp\n    public:\n      template<class F>\n      auto async(F&& func) {\n        using ResultType = std::invoke_result_t<std::decay_t<F>>;\n\n        std::packaged_task<ResultType()> pt(std::forward<F>(func));\n        std::future<ResultType> future = pt.get_future();\n\n        UniqueFunction task(\n           [pt = std::move(pt)]() mutable { pt(); }\n        );\n\n        enqueue_task(std::move(task));\n\n        // Give the user a future for retrieving the result.\n        return future;\n      }\n    }; // class ThreadPool\n```", "```cpp\n    void test() {\n      std::atomic<int> sum(0);\n      ThreadPool tp(4);\n      std::vector<std::future<int>> futures;\n      for (int i=0; i < 60000; ++i) {\n        auto f = tp.async([i, &sum](){\n          sum += i;\n          return i;\n        });\n        futures.push_back(std::move(f));\n      }\n      assert(futures[42].get() == 42);\n      assert(903 <= sum && sum <= 1799970000);\n    }\n```", "```cpp\n    class ThreadPool {\n      boost::thread_group m_workers;\n      boost::asio::io_service m_io;\n      boost::asio::io_service::work m_work;\n    public:\n      ThreadPool(int size) : m_work(m_io) {\n        for (int i=0; i < size; ++i) {\n          m_workers.create_thread([&](){ m_io.run(); });\n        }\n      }\n\n      template<class F>\n      void enqueue_task(F&& func) {\n        m_io.post(std::forward<F>(func));\n      }\n\n      ~ThreadPool() {\n        m_io.stop();\n        m_workers.join_all();\n      }\n    };\n```"]