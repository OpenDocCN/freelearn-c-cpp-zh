<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;A Matter of Character"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. A Matter of Character</h1></div></div></div><p>A video game wouldn't be much fun without characters, and this chapter is all about bringing your game characters to life. Games typically have two kinds of characters. First, there is the character or characters that you are playing as. These are called the player characters. The characters that are controlled by the computer are called the non-player characters or NPCs.</p><p>This chapter will explain how to create characters for your game. Along the way we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sprites</strong></span>: Sprites are any textures that the player interacts with in the game. This includes the player characters, NPCs, and other objects in the game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Animation</strong></span>: The<a id="id124" class="indexterm"/> art of making an image appear to move is called animation. You will learn how to use multiple images to make your textures move on the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Atlases</strong></span>: Images<a id="id125" class="indexterm"/> can be stored one at a time, or they can be combined into single <a id="id126" class="indexterm"/>composite texture known as a <span class="strong"><strong>sprite sheet</strong></span> or an <span class="strong"><strong>atlas</strong></span>.</li></ul></div><div class="section" title="Spritely speaking"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Spritely speaking</h1></div></div></div><p>Many years ago, a computer geek invented a cool way to render and display small images on a computer screen. These images would move around on the screen and even collide with other objects. The<a id="id127" class="indexterm"/> computer geek called these images sprites, and that name has stuck ever since.</p><div class="section" title="Sprites versus non-sprites"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Sprites versus non-sprites</h2></div></div></div><p>A sprite is simply <a id="id128" class="indexterm"/>an image that represents an object on the screen. Examples <a id="id129" class="indexterm"/>of sprites include characters, NPCs, weapons, alien spaceships, and rocks. Anything that can move on the screen or be hit by another object in the game is a sprite. Objects that don't interact with other objects aren't sprites. Examples might include mountains in the background, the ground, and the sky.</p><p>Obviously, it takes<a id="id130" class="indexterm"/> both sprites and non-sprites to implement a<a id="id131" class="indexterm"/> game. Also, the distinction is a little arbitrary. Some games implement all of the images in the game as sprites because it is more convenient to treat all images in the game in a consistent manner.</p></div><div class="section" title="Flipbook animation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Flipbook animation</h2></div></div></div><p>Did you ever create a flipbook when you were a kid? To jog your memory, here is how it worked. First, you<a id="id132" class="indexterm"/> sketched a simple figure on a notepad. Then<a id="id133" class="indexterm"/> you went to the next page and sketched the same image, but this time something was slightly different. You continued sketching images that were slightly different from the original on successive pages. When you were done, you flipped the pages at the notebook edge and saw what appeared to be a rudimentary movie.</p><div class="mediaobject"><img src="graphics/8188OS_03_01.jpg" alt="Flipbook animation"/></div><p>Another example is a movie. Movies are recorded on film as frames. The film is then run through a projector, which plays the film back one frame at a time. The key, as mentioned before, is to play frames back at least 24 frames per second to fool the eye into thinking that there is fluid motion.</p></div><div class="section" title="Framed animation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Framed animation</h2></div></div></div><p>2D sprite animation <a id="id134" class="indexterm"/>works much like a flipbook. An artist draws<a id="id135" class="indexterm"/> successive versions of an image. When the images are rendered one after another, it appears to move. Each image in an animation is called a frame. It takes at least 24 or more fps to create a convincing animation. Obviously, more frames will create a smoother animation.</p><div class="mediaobject"><img src="graphics/8188OS_03_02.jpg" alt="Framed animation"/></div><p>The preceding <a id="id136" class="indexterm"/>image illustrates a very simple animation using <a id="id137" class="indexterm"/>four frames. The only thing that changes is the robot's arm position. Played in sequence from <span class="strong"><strong>Frame 1</strong></span> through <span class="strong"><strong>Frame 4</strong></span>, the arm would appear to swing from the front to the back and then forward again. If this was combined with moving the sprite to the right, then you would get a very simple animation of a walking robot.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>As the preceding example illustrates, I am not an artist! I am a coder, so the art created for this book will be very simple. It is actually common for very simple placeholder art to be used in the initial stages of a game. This allows the programmers to test features of the game while the art team is working on the real art that will be put in the game at a later stage.</p></div></div></div></div></div>
<div class="section" title="Creating sprites"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Creating sprites</h1></div></div></div><p>Professional 2D <a id="id138" class="indexterm"/>artists use programs, such as Adobe Photoshop, to create 2D assets for a game. Unfortunately, we can't take the time to teach you how to use a program as sophisticated as Photoshop.</p><p>If you want to play around with creating your own assets, then you might try the Paint program that comes installed on any Windows based computer. If you really want to dig deep into 2D art creation without digging deeply into your bank account, then you can download <a id="id139" class="indexterm"/>GIMP (<a class="ulink" href="http://www.gimp.org">http://www.gimp.org</a>), a free, full-features 2D image manipulation program.</p><div class="section" title="Working with PNGs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Working with PNGs</h2></div></div></div><p>In the previous <a id="id140" class="indexterm"/>chapter, we loaded and rendered a bitmap file. It turns out that bitmaps<a id="id141" class="indexterm"/> aren't the best format to work with sprites because they take more file space (and therefore, more memory) than PNGs, and bitmaps do not support transparency.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Before we had image formats that allowed transparency to be directly encoded as part of the image, we used a specific background color, and then expected our image library to remove that color when it handled the image. Magenta was often used as the background because it is a color rarely used in images.</p></div></div><p>Bitmaps are larger in file size than PNGs because they are not stored in a compressed format. Compression allows an image to be stored in less space, and this can be very important on devices, such as mobile phones.</p><p>PNGs are stored using <a id="id142" class="indexterm"/>a <span class="strong"><strong>lossless</strong></span> compression algorithm. Lossless means that the image quality is not sacrificed to achieve the compression. Other formats, such as JPEG, can be stored in a compressed format, but use a <span class="strong"><strong>lossy</strong></span> algorithm that degrades the image quality.</p><p>PNGs also support transparency using<a id="id143" class="indexterm"/> an <span class="strong"><strong>alpha</strong></span> channel. In addition to storing the red, green, and blue component of each pixel (RGB), PNGs also store each pixel's transparency in the alpha channel (RGBA).</p><p>You will recall from the previous chapter that all textures are represented as rectangles in a game. However, real shapes aren't rectangular. Trees, cars, and robots all have much more complex shapes.</p><p>If we used bitmaps for all of our images, then the full rectangle of the texture would be rendered blocking out everything behind the sprite. In the following image, our robot is passing in front of a pipe, and part of the pipe is occluded by the blank space in the bitmap.</p><div class="mediaobject"><img src="graphics/8188OS_03_03.jpg" alt="Working with PNGs"/></div><p>In a PNG image, we <a id="id144" class="indexterm"/>set the blank space to be transparent. In the following <a id="id145" class="indexterm"/>image, the pipe is no longer occluded by the transparent parts of the image of the robot:</p><div class="mediaobject"><img src="graphics/8188OS_03_04.jpg" alt="Working with PNGs"/></div><p>In the previous chapter, we wrote a code to load a BMP file. Normally, we would have to write different code to load a PNG file. In fact, we would have to write a loader for each different type of image we wanted to work with.</p><p>Fortunately, someone has already done all of this work and made it available in a library known as <span class="strong"><strong>SOIL</strong></span>: <span class="strong"><strong>Simple OpenGL Image Library</strong></span>. You can download your copy from <a class="ulink" href="http://www.lonesock.net/soil.html">http://www.lonesock.net/soil.html</a>.</p><p>There are <a id="id146" class="indexterm"/>several advantages to using the<a id="id147" class="indexterm"/> SOIL library:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We no longer <a id="id148" class="indexterm"/>have to worry about writing our own loader for every type of image that we want to use. SOIL supports BMP, PNG, and many other formats.</li><li class="listitem" style="list-style-type: disc">File loading is not completely abstracted. You don't have to worry about how the code works, only that it does.</li><li class="listitem" style="list-style-type: disc">SOIL has other features that may be useful (such as the ability to write out image files).</li></ul></div><p>The download<a id="id149" class="indexterm"/> comes as a zipped folder. Once you unzip the folder, you will <a id="id150" class="indexterm"/>see a folder named <code class="literal">Simple OpenGL Image Library</code>. This folder contains a lot of files, but we only need <code class="literal">soil.h</code>.</p><div class="section" title="Linking to the SOIL library"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Linking to the SOIL library</h3></div></div></div><p>Now, it is time<a id="id151" class="indexterm"/> to add the SOIL library to our project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the folder where you unzipped the SOIL code.</li><li class="listitem">Open the <code class="literal">lib</code> folder and find <code class="literal">libSOIL.a</code>.</li><li class="listitem">Copy <code class="literal">libSOIL.a</code> to the folder that contains the <span class="strong"><strong>RoboRacer2D</strong></span> source code.</li><li class="listitem">Open the <span class="strong"><strong>RoboRacer2D</strong></span> project.</li><li class="listitem">Right-click on the <span class="strong"><strong>RoboRacer2D</strong></span> project in the <span class="strong"><strong>Solution Explorer</strong></span> panel and choose <span class="strong"><strong>Properties</strong></span>.</li><li class="listitem">For the <span class="strong"><strong>Configuration</strong></span> drop-down box, make sure that you select <span class="strong"><strong>All Configurations</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>Configuration Properties</strong></span> branch, then the <span class="strong"><strong>Linker</strong></span> branch.</li><li class="listitem">Select the <span class="strong"><strong>Input</strong></span> option.</li><li class="listitem">Click the dropdown for <span class="strong"><strong>Additional Dependencies</strong></span> and choose <span class="strong"><strong>&lt;Edit…&gt;</strong></span>.</li><li class="listitem">Enter <code class="literal">opengl32.lib</code> and <code class="literal">glu32.lib</code> on separate lines in the dialog window and click <span class="strong"><strong>OK</strong></span>.<div class="mediaobject"><img src="graphics/8188OS_03_05.jpg" alt="Linking to the SOIL library"/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>Library files<a id="id152" class="indexterm"/> for Windows usually end in <code class="literal">.lib</code>, while those written for UNIX end in <code class="literal">.a</code>. The standard SOIL distribution comes with the UNIX library; you need to use the Windows library. You can either find <code class="literal">SOIL.lib</code> online, use the SOIL source code to create your own Windows library file, or download SOIL.lib from the book's website.</p></div></div></div><div class="section" title="Including the SOIL header file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Including the SOIL header file</h3></div></div></div><p>Next, we<a id="id153" class="indexterm"/> need to copy the SOIL header file into our project and include it in our code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the folder where you unzipped the SOIL code.</li><li class="listitem">Open the <code class="literal">src</code> folder and find <code class="literal">SOIL.h</code>.</li><li class="listitem">Copy <code class="literal">SOIL.h</code> to the folder that contains the <span class="strong"><strong>RoboRacer2D</strong></span> source code.</li><li class="listitem">Open the <span class="strong"><strong>RoboRacer2D</strong></span> project.</li><li class="listitem">Open <code class="literal">RoboRacer2D.cpp</code>.</li><li class="listitem">Add <code class="literal">#include "SOIL.h"</code> to the list of includes.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>You will<a id="id154" class="indexterm"/> notice that there are many other files that were unzipped as part of the SOIL package. This includes all of the original source files and several samples for how to use the library.</p></div></div></div><div class="section" title="Opening an image file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Opening an image file</h3></div></div></div><p>Now, we <a id="id155" class="indexterm"/>are ready to write a function that loads an image file. We will pass in the name of the file, and the function will return an integer representing a handle on the OpenGL texture.</p><p>The following lines of code uses SOIL to load an image:</p><div class="informalexample"><pre class="programlisting">GLuint texture = SOIL_load_OGL_texture
(
  imageName,
  SOIL_LOAD_AUTO,
  SOIL_CREATE_NEW_ID,
  0
);</pre></div><p>All of the work is done by the call to <code class="literal">SOIL_load_OGL_texture</code>. The four parameters are the most generic settings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first parameter is the path and filename to the image file.</li><li class="listitem" style="list-style-type: disc">The second parameter tells SOIL how to load the image (and in this case, we indicate that we want SOIL to figure things out automatically).</li><li class="listitem" style="list-style-type: disc">The third parameter tells SOIL to create an OpenGL texture ID for us.</li><li class="listitem" style="list-style-type: disc">The fourth parameter, if used, can be set to several flag bits that tell SOIL to perform some custom processing. We are not using this, so we just send a 0.</li></ul></div><p>We will use code, such as this one, to load images into our <code class="literal">sprite</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>If you want to see all of the options available to you, open <code class="literal">SOIL.h</code> and read the source code comments.</p></div></div></div></div><div class="section" title="Coding a sprite class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Coding a sprite class</h2></div></div></div><p>In order to <a id="id156" class="indexterm"/>easily incorporate sprites into our game, we will create a class specifically for dealing with sprites.</p><p>Let's think about the features that we want:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An array of images.</li><li class="listitem" style="list-style-type: disc">An index that represents the current frame.</li><li class="listitem" style="list-style-type: disc">A variable that holds the total number of frames.</li><li class="listitem" style="list-style-type: disc">Variables to store the current <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position of the sprite. For this game, this will be the upper-left corner of the image.</li><li class="listitem" style="list-style-type: disc">A variable that stores the x and y components of the current velocity of the sprite (<code class="literal">0</code> if it isn't moving).</li><li class="listitem" style="list-style-type: disc">Variables that store the width and height of the image. Note that if the sprite has multiple images, they must all be the same size.</li><li class="listitem" style="list-style-type: disc">A Boolean that tells us if this sprite collides with other sprites.</li><li class="listitem" style="list-style-type: disc">A Boolean that tells us if this sprite should be rendered normal or flipped.</li><li class="listitem" style="list-style-type: disc">A Boolean that tells us if this sprite is visible right now.</li><li class="listitem" style="list-style-type: disc">A Boolean that tells us if this sprite is active right now.</li></ul></div><p>In addition to these properties, we would also like to be able to manipulate the sprite in several ways. We may add methods to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add an image to the sprite</li><li class="listitem" style="list-style-type: disc">Update the position of the sprite</li><li class="listitem" style="list-style-type: disc">Update the animation frame for the sprite</li><li class="listitem" style="list-style-type: disc">Render the sprite to the screen</li></ul></div><p>Open your game project, and add a new class called <code class="literal">Sprite.cpp</code> with a header file called <code class="literal">Sprite.h</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>In Visual Studio, right-click on the <span class="strong"><strong>Header Files</strong></span> filter in the Solution Explorer pane. Then choose <span class="strong"><strong>Add Class</strong></span>. Give the class the name <code class="literal">Sprite</code> and click <span class="strong"><strong>Add</strong></span>. Visual Studio will create a template header and source code files for you.</p></div></div><p>Use the <a id="id157" class="indexterm"/>following code for <code class="literal">Sprite.h</code>:</p><div class="informalexample"><pre class="programlisting">#pragma once:
#include &lt;gl\gl.h&gt;

class Sprite
{
  public:
struct Point
{
  GLfloat x;
  GLfloat y;
};
  
   struct Size
 {
  GLfloat width;
  GLfloat height;
 };
 struct Rect
 {
  GLfloat top;
  GLfloat bottom;
  GLfloat left;
  GLfloat right;
 };
  
  protected:
  GLuint* m_textures;
  unsigned int m_textureIndex;
  unsigned int m_currentFrame;
  unsigned int m_numberOfFrames;
  GLfloat m_animationDelay;
  GLfloat m_animationElapsed;
  
  Point m_position;
  Size m_size;
  GLfloat m_velocity;
  
  bool m_isCollideable;
  bool m_flipHorizontal;
  bool m_flipVertical;
  bool m_isVisible;
  bool m_isActive;
  bool m_useTransparency;
  bool m_isSpriteSheet;
  
  public:
  Sprite(const unsigned int m_pNumberOfTextures);
  ~Sprite();
  
  void Update(const float p_deltaTime);
  void Render();
  
  const bool AddTexture(const char* p_fileName, const bool p_useTransparency = true);
   const GLuint GetCurrentFrame() {
  if (m_isSpriteSheet)
  {
   return m_textures[0];
  }
  else
  {
   return m_textures[m_currentFrame];
  }
 }
  
  void SetPosition(const GLfloat p_x, const GLfloat p_y) { m_position.x = p_x; m_position.y = p_y; }
   void SetPosition(const Point p_position) { m_position = p_position; }
 const Point GetPosition() { return m_position; }
 const Size GetSize() const { return m_size; }
void SetFrameSize(const GLfloat p_width, const GLfloat p_height) {
m_size.width = p_width; m_size.height = p_height; }
  void SetVelocity(const GLfloat p_velocity) { m_velocity = p_velocity; }
  void SetNumberOfFrames(const unsigned int p_frames) { m_numberOfFrames = p_frames;  }
  
  const bool isCollideable() const { return m_isCollideable; }
void IsCollideable(const bool p_value) { m_isCollideable = p_value;  }
  void FlipHorizontal(const bool p_value) { m_flipHorizontal = p_value; }
  void FlipVertical(const bool p_value) { m_flipVertical = p_value; }
  void IsActive(const bool p_value) { m_isActive = p_value; }
  const bool IsActive() const { return m_isActive; }
void IsVisible(const bool p_value) { m_isVisible = p_value; }
const bool IsVisible() const { return m_isVisible; }
void UseTransparency(const bool p_value) { m_useTransparency = p_value; }
};</pre></div><p>I know, it's a<a id="id158" class="indexterm"/> lot of code! This is a typical object-oriented class, consisting of protected properties and public methods. Let's take a look at the features of this class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#pragma once</code>: This is a C++ directive telling Visual Studio to only include files once if they are included in several source files.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>An alternative is to use header guards:</p><div class="informalexample"><pre class="programlisting">#ifndef SPRITE_H
#define SPRITE_H
...code...
#endif</pre></div><p>This stops the code from being included if <code class="literal">SPRITE_H</code> has already been defined. Then the header has already been included and will not be included more than once.</p></div></div></li><li class="listitem" style="list-style-type: disc">We include <code class="literal">gl.h</code> in this header file because we need access to the standard OpenGL<a id="id159" class="indexterm"/> variable types.</li><li class="listitem" style="list-style-type: disc">Inside the class, we define two very useful structures: point and rect. We work with points and rectangles so much that it makes sense to have simple structures that hold their values.</li><li class="listitem" style="list-style-type: disc">The member variables are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">m_textures</code> is a <code class="literal">GLuint</code> array that will dynamically hold all of the OpenGL texture handles that make up this sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_textureIndex</code> starts at zero, and is incremented each time a texture is added to the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_currentFrame</code> starts at zero, and is incremented each time we want to advance the frame of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_numberOfFrames</code> stores the total number of frames that make up our animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_animationDelay</code> is the number of seconds that we want to pass before the animation frame advances. This allows us to control the speed of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_animationElapsed</code> will hold the amount of time that has elapsed since the last animation frame was changed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_position</code> holds the <code class="literal">x</code> and<code class="literal"> y</code> positions of the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_size</code> holds the <code class="literal">width</code> and <code class="literal">height</code> of the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_velocity</code> holds the velocity of the sprite. Larger values will cause the sprite to move more quickly across the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_isCollideable</code> is a flag that tells us whether or not this sprite collides with other objects on the screen. When set to <code class="literal">false</code>, the sprite will pass through other objects on the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_flipHorizontal</code> is a flag that tells the class whether or not the sprite image should be horizontally flipped when it is rendered. This technique can be used to save texture memory by reusing a single texture for both right and left movement.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_flipVertical</code> is a flag that tells the class whether or not the sprite image should be vertically flipped when it is rendered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_isVisible</code> is a flag that indicates whether the sprite is currently visible in the game. If this is set to false, then the sprite will not be rendered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_isActive</code> is a flag that indicates whether the sprite is currently active. If this is set to false, then the sprite animation frame and sprite position will not be updated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">m_useTransparency</code> is a flag that tells the sprite class whether or not to use the alpha channel in the sprite. As alpha checking is costly, we set this to false for images that don't have any transparency (such as the game background).</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">m_isSpriteSheet</code> is a flat that tells the sprite class if a single texture is used to hold all of the frames for this sprite. If set to <code class="literal">true</code>, then each frame is loaded as a separate texture.</li><li class="listitem" style="list-style-type: disc">Next, we<a id="id160" class="indexterm"/> have the methods:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Sprite</code> is a constructor that takes a single parameter, <code class="literal">p_numberOfTextures</code>. We have to tell the class the number of textures that will be used when the sprite is created so that the correct amount of memory can be allocated for the textures dynamic array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">~Sprite</code> is the class destructor.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Update</code> will be used to update the current animation frame and the current position of the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Render</code> will be used to actually display the sprite on the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AddTexture</code> is used once the sprite is created to add the required textures.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetCurrentFrame</code> is used when the sprite is rendered to determine which frame of the sprite to render.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The remaining methods are simply accessor methods that allow you to modify the class properties.</li></ul></div><p>Next, let's start the class implementation. Open <code class="literal">Sprite.cpp</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">#include "stdafx.h"
#include "Sprite.h"
#include "SOIL.h"

Sprite::Sprite(const unsigned int p_numberOfTextures)
{   
  m_textures = new GLuint[p_numberOfTextures];
  m_textureIndex = 0;
  m_currentFrame = 0;
  m_numberOfFrames = 0;
  m_animationDelay = 0.25f;
  m_animationElapsed = 0.0f;
  m_position.x = 0.0f;
  m_position.y = 0.0f;
  m_size.height = 0.0f;
  m_size.width = 0.0f;
  m_velocity = 0.0f;
  
  m_isCollideable = true;
  m_flipHorizontal = false;
  m_flipVertical = false;
  m_isVisible = false;
  m_isActive = false;
  m_isSpriteSheet = false;
}

Sprite::~Sprite()
{
  delete[] m_textures;
}</pre></div><p>Here are<a id="id161" class="indexterm"/> some details about the implementation code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Along with <code class="literal">stdafx.h</code> and <code class="literal">Sprite.h</code>, we include <code class="literal">SOIL.h</code> because this is the actual code block that we will use to load textures</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Sprite</code> constructor:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dynamically allocates space for the <code class="literal">m_textures</code> array based on <code class="literal">p_numberOfTextures</code>.</li><li class="listitem" style="list-style-type: disc">Initializes all of other class properties. Note that most of the Boolean properties are set to <code class="literal">false</code>. The result is that a newly created sprite will not be active or visible until we specifically set it to be active and visible.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">~Sprite</code> destructor deallocates the memory used for the <code class="literal">m_textures</code> array</li></ul></div><p>We will<a id="id162" class="indexterm"/> implement the <code class="literal">Update</code>, <code class="literal">Render</code>, and <code class="literal">AddTexture</code> methods next.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>You probably noticed that I prefix many of the variables in my code with either <code class="literal">m_</code> or <code class="literal">p_</code>. m_ is always used to prefix the name of class properties (or member variables), and <code class="literal">p_</code> is used to prefix variables used as parameters in functions. If a variable does not have a prefix, it is usually a local variable.</p></div></div></div><div class="section" title="Creating sprite frames"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Creating sprite frames</h2></div></div></div><p>We already<a id="id163" class="indexterm"/> discussed how 2D animations are created by drawing multiple frames of the image with each frame being slightly different. The key points that must be remembered are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each frame must have exactly the same dimensions</li><li class="listitem" style="list-style-type: disc">The placement of the image within the frame must be consistent</li><li class="listitem" style="list-style-type: disc">Only the parts of the image that are supposed to move should change from frame to frame</li></ul></div></div><div class="section" title="Saving each frame"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Saving each frame</h2></div></div></div><p>One technique to<a id="id164" class="indexterm"/> save your frames is to save each frame as its own image. As you will eventually have a lot of sprites and frames to work with, it is important to come up with a consistent naming convention for all of your images. For example, with our three frame robot animation that were illustrated previously, we might use the following filenames:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">robot_left_00.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_left_01.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_left_02.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_left_03.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_right_00.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_right_01.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_right_02.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">robot_right_03.png</code></li></ul></div><p>Every image in<a id="id165" class="indexterm"/> the game should use the same naming mechanism. This will save you endless headaches when coding the animation system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>You should save all of your images in a folder named "resources" which should be created in the same folder that holds your source files.</p></div></div></div><div class="section" title="Loading a sprite from individual textures"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Loading a sprite from individual textures</h2></div></div></div><p>Let's take<a id="id166" class="indexterm"/> a look the code to load a sprite that has each frame saved as an individual file:</p><div class="informalexample"><pre class="programlisting">robot_right = new Sprite(4);
 robot_right-&gt;SetFrameSize(100.0f, 125.0f);
 robot_right-&gt;SetNumberOfFrames(4);
 robot_right-&gt;SetPosition(0, screen_height - 130.0f);
 robot_right-&gt;AddTexture("resources/robot_right_00.png");
 robot_right-&gt;AddTexture("resources/robot_right_01.png");
 robot_right-&gt;AddTexture("resources/robot_right_02.png");
 robot_right-&gt;AddTexture("resources/robot_right_03.png");</pre></div><p>The important points to notice about the preceding code are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a new instance of our sprite class to store the information. We have to tell the sprite class to allocate space for 4 textures for this sprite.</li><li class="listitem" style="list-style-type: disc">We first store the width and height of each frame. In this case, this happens to be the width and height of each texture that makes up this sprite. As every texture that makes up a particular sprite must have the same dimensions, we only have to make this call once.</li><li class="listitem" style="list-style-type: disc">We then store the number of frames in this sprite. This might seem to duplicate the number of textures that we specified in the constructor. However, as you will see in the next section, the number of textures does not always equal the number of frames.</li><li class="listitem" style="list-style-type: disc">We now add each texture to the sprite. The sprite class takes care of allocating the necessary memory for us.</li></ul></div></div><div class="section" title="Creating a sprite sheet"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Creating a sprite sheet</h2></div></div></div><p>An alternative<a id="id167" class="indexterm"/> method to store your sprites is to use a sprite sheet. A sprite sheet holds all of the sprites for a particular animation in a single file. The sprites are often organized into a strip.</p><div class="mediaobject"><img src="graphics/8188OS_03_06.jpg" alt="Creating a sprite sheet"/></div><p>As the dimensions <a id="id168" class="indexterm"/>of each frame are identical, we can calculate the position of each frame in a particular animation as an offset from the first frame in the sprite sheet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>You can download a cool little program called <span class="strong"><strong>GlueIt</strong></span> at <a class="ulink" href="http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/">http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/</a>. This<a id="id169" class="indexterm"/> small program allows you to specify several individual images, and then it glues them into a sprite sheet for you.</p></div></div></div><div class="section" title="Loading a sprite sheet"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Loading a sprite sheet</h2></div></div></div><p>The following <a id="id170" class="indexterm"/>code loads a sprite that has been stored as a sprite sheet:</p><div class="informalexample"><pre class="programlisting"> robot_right_strip = new Sprite(1);
 robot_right_strip-&gt;SetFrameSize(125.0f, 100.0f);
 robot_right_strip-&gt;SetNumberOfFrames(4);
 robot_right_strip-&gt;SetPosition(0, screen_height - 130.0f);
 robot_right_strip-&gt;AddTexture("resources/robot_right_strip.png");</pre></div><p>This code is very similar to the code that we used to create a sprite with individual textures previously. However, there are important differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We only need to allocate space for one texture because we only load one texture. This is the main advantage of using a sprite sheet because it is much more efficient to load a single large texture than it is to load several smaller textures.</li><li class="listitem" style="list-style-type: disc">Again, we set the width and height of each frame. Note that these are the same values as when loading individual textures because the important information is the width and height of each frame, not the width and height of the texture.</li><li class="listitem" style="list-style-type: disc">Again, we store the number of frames for this sprite. This sprite still has four frames, <a id="id171" class="indexterm"/>although all of the four frames are stored in a single image.</li><li class="listitem" style="list-style-type: disc">We then add a single image to the sprite.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip30"/>Tip</h3><p>When we get ready to render each frame of the animation, the sprite class will take care of calculating exactly which part the sprite strip to render based on the current frame and the width of each frame.</p></div></div></div><div class="section" title="Loading our sprites"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Loading our sprites</h2></div></div></div><p>The following<a id="id172" class="indexterm"/> code shows the full code that we will use to load the sprites into our game. Open the <span class="strong"><strong>RoboRacer2D</strong></span> project and open <code class="literal">RoboRacer.cpp</code>. First we need to include the Sprite header:</p><div class="informalexample"><pre class="programlisting">#include "Sprite.h"</pre></div><p>Next, we need some global variables to hold our sprites. Add this code in the variable declarations section of the code (before any functions):</p><div class="informalexample"><pre class="programlisting">Sprite* robot_left;
Sprite* robot_right;
Sprite* robot_right_strip;
Sprite* robot_left_strip;
Sprite* background;
Sprite* player;</pre></div><p>We created pointers for each sprite that we will need in the game until this point:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A sprite to move the robot left</li><li class="listitem" style="list-style-type: disc">A sprite to move the robot right</li><li class="listitem" style="list-style-type: disc">A sprite for the background</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>In order to make it easy for you to work with both types of sprites, I defined two sprites for each robot direction. For example, <code class="literal">robot_left</code> will define a sprite made up of individual textures, while <code class="literal">robot_left_strip</code> will define a sprite made up of a single sprite sheet. Normally, you would not use both in a single game!</p></div></div><p>Now, add the <code class="literal">LoadTextures</code> function:</p><div class="informalexample"><pre class="programlisting">const bool LoadTextures()
{
  background = new Sprite(1);
  background-&gt;SetFrameSize(1877.0f, 600.0f);
  background-&gt;SetNumberOfFrames(1);
  background-&gt;AddTexture("resources/background.png", false);
  
  robot_right = new Sprite(4);
  robot_right-&gt;SetFrameSize(100.0f, 125.0f);
  robot_right-&gt;SetNumberOfFrames(4);
  robot_right-&gt;SetPosition(0, screen_height - 130.0f);
  robot_right-&gt;AddTexture("resources/robot_right_00.png");
  robot_right-&gt;AddTexture("resources/robot_right_01.png");
  robot_right-&gt;AddTexture("resources/robot_right_02.png");
  robot_right-&gt;AddTexture("resources/robot_right_03.png");
  
  robot_left = new Sprite(4);
  robot_left-&gt;SetFrameSize(100.0f, 125.0f);
  robot_left-&gt;SetNumberOfFrames(4);
  robot_left-&gt;SetPosition(0, screen_height - 130.0f);
  robot_left-&gt;AddTexture("resources/robot_left_00.png");
  robot_left-&gt;AddTexture("resources/robot_left_01.png");
  robot_left-&gt;AddTexture("resources/robot_left_02.png");
  robot_left-&gt;AddTexture("resources/robot_left_03.png");
  
  robot_right_strip = new Sprite(1);
  robot_right_strip-&gt;SetFrameSize(125.0f, 100.0f);
  robot_right_strip-&gt;SetNumberOfFrames(4);
  robot_right_strip-&gt;SetPosition(0, screen_height - 130.0f);
  robot_right_strip-&gt;AddTexture("resources/robot_right_strip.png");
  
  robot_left_strip = new Sprite(1);
  robot_left_strip-&gt;SetFrameSize(125.0f, 100.0f);
  robot_left_strip-&gt;SetNumberOfFrames(4);
  robot_right_strip-&gt;SetPosition(0, screen_height - 130.0f);
  robot_left_strip-&gt;AddTexture("resources/robot_left_strip.png");
  
  background-&gt;IsVisible(true);
  background-&gt;IsActive(true);
  background-&gt;SetVelocity(-50.0f);
  
  robot_right-&gt;IsActive(true);
  robot_right-&gt;IsVisible(true);
  robot_right-&gt;SetVelocity(50.0f);
  
  player = robot_right;
  player-&gt;IsActive(true);
  player-&gt;IsVisible(true);
  player-&gt;SetVelocity(50.0f);

  return true;
}</pre></div><p>This code is <a id="id173" class="indexterm"/>exactly the same as the code that I showed you earlier to load sprites. It is simply more comprehensive:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LoadTexures</code> loads all of the sprites needed in the game (including duplicate <span class="emphasis"><em>strip</em></span> versions so that you can see the difference between using sprite sheets versus individual textures).</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetPosition</code> is used to set the initial position for the robot sprites. Notice that we don't do this for the background sprite because its position starts at <code class="literal">(0, 0)</code>, which is the default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetVisible</code> and <code class="literal">SetActive</code> are used to set the <code class="literal">background</code> sprite and the <code class="literal">robot_left_strip</code> sprite as active and visible. All of the other sprites will remain inactive and invisible.</li></ul></div><p>As the loading of textures only needs to occur once in the game, we will add the call to do this to the <code class="literal">StartGame</code> function. Modify the <code class="literal">StartGame</code> function in <code class="literal">RoboRacer.cpp</code>:</p><div class="informalexample"><pre class="programlisting">void StartGame()
{
  LoadTextures();
}</pre></div><p>The final step in getting our textures loaded is to implement the <code class="literal">AddTexture</code> method in our sprite class. Open <code class="literal">Sprite.cpp</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">const bool Sprite::AddTexture(const char* p_imageName, const bool p_useTransparency)
{
  GLuint texture = SOIL_load_OGL_texture( p_imageName, SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, 0 );
  if (texture == 0)
  {
    return false;
  }
  
  m_textures[m_textureIndex] = texture;
  m_textureIndex++;
  if (m_textureIndex == 1 &amp;&amp; m_numberOfFrames &gt; 1)
  {
    m_isSpriteSheet= true;
  }
  else
  {
    m_isSpriteSheet = false;
  }
  m_useTransparency = p_useTransparency;
  return true;
}</pre></div><p>
<code class="literal">AddTexture</code> is used<a id="id174" class="indexterm"/> after a new sprite has been created. It adds the required textures to the <code class="literal">m_textures</code> array. Here's how it works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">p_imageName</code> holds the name and path of the image to load.</li><li class="listitem" style="list-style-type: disc"><code class="literal">p_useTransparency</code> is used to tell the sprite class whether this image uses an alpha channel. As most of our sprites will use transparency, this is coded to default to <code class="literal">true</code>. However, if we set <code class="literal">p_useTransparency</code> to <code class="literal">false</code>, then any transparency information will be ignored.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SOIL_load_OGL_texture</code> does all of the work of loading the texture. The parameters for this call were described earlier in this chapter. Note that SOIL is smart enough to load image types based on the file extension.</li><li class="listitem" style="list-style-type: disc">If the texture was successfully loaded, <code class="literal">SOIL_load_OGL_texture</code> will return an OpenGL texture handle. If not, it will return <code class="literal">0</code>. Generally, we would test this value and use some kind of error handling, or quit if any texture did not load correctly.</li><li class="listitem" style="list-style-type: disc">As the <code class="literal">m_textures</code> array is allocated in the constructor, we can simply store texture in the <code class="literal">m_textureIndex</code> slot.</li><li class="listitem" style="list-style-type: disc">We then increment <code class="literal">m_textureIndex</code>.</li><li class="listitem" style="list-style-type: disc">We use a little trick to determine if this sprite uses a sprite sheet or individual sprites. Basically, if there is only one texture but many frames, then we assume that this sprite uses a sprite sheet and set <code class="literal">m_isSpriteSheet</code> to <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc">Finally, we set <code class="literal">m_useTransparency</code> to the value that was passed in. This will be used later in the <code class="literal">Render</code> method.</li></ul></div></div></div>
<div class="section" title="Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Rendering</h1></div></div></div><p>We did a lot <a id="id175" class="indexterm"/>of work creating our sprites, but nothing is going to show up until we actually render the sprites using OpenGL. Rendering is done for every frame of the game. First, an <code class="literal">Update</code> function is called to update the state of the game, then everything<a id="id176" class="indexterm"/> is rendered to the screen.</p><div class="section" title="Adding a render to the game loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Adding a render to the game loop</h2></div></div></div><p>Let's start by<a id="id177" class="indexterm"/> adding a call to <code class="literal">Render</code> in the <code class="literal">GameLoop</code> RoboRacer.cpp:</p><div class="informalexample"><pre class="programlisting">void GameLoop()
{
  Render();
}</pre></div><p>At this point, we are simply calling the main <code class="literal">Render</code> function (implemented in the next section). Every object that can be drawn to the screen will also have a <code class="literal">Render</code> method. In this way, the call to render the game will cascade down through every renderable object in the game.</p></div><div class="section" title="Implementing the main Render function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Implementing the main Render function</h2></div></div></div><p>Now, it is time<a id="id178" class="indexterm"/> to implement the main <code class="literal">Render</code> function. Add the following code to <code class="literal">RoboRacer.cpp</code>:</p><div class="informalexample"><pre class="programlisting">void Render()
{
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();
  
  background-&gt;Render();
  robot_left-&gt;Render();
  robot_right-&gt;Render();
  robot_left_strip-&gt;Render();
  robot_right_strip-&gt;Render();
  
  SwapBuffers(hDC);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>Notice that we render the background first. In a 2D game, the objects will be rendered in a first come, first rendered basis. This way the robot will always render on top of the background.</p></div></div><p>Here's how it works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We always<a id="id179" class="indexterm"/> start our render cycle by resetting the OpenGL render pipeline. <code class="literal">glClear</code> sets the entire color buffer to the background color that we chose when initializing OpenGL. <code class="literal">glLoadIdentify</code> resets the rendering matrix.</li><li class="listitem" style="list-style-type: disc">Next, we call <code class="literal">Render</code> for each sprite. We don't care if the sprite is actually visible or not. We let the sprite class <code class="literal">Render</code> method make that decision.</li><li class="listitem" style="list-style-type: disc">Once all objects are rendered, we make the call to <code class="literal">SwapBuffers</code>. This is a technique known as double-buffering. When we render our scene, it is actually created in a buffer off screen. This way the player doesn't actually see the separate images as they are composited to the screen. Then, a single call to <code class="literal">SwapBuffers</code> makes a fast copy of the offscreen buffer to the actual screen buffer. This makes the screen render appear much more smoothly.</li></ul></div></div><div class="section" title="Implementing Render in the Sprite class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Implementing Render in the Sprite class</h2></div></div></div><p>The last <a id="id180" class="indexterm"/>step in our render chain is to add a render method to the <code class="literal">Sprite</code> class. This will allow each sprite to render itself to the screen. Open <code class="literal">Sprite.h</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">void Sprite::Render()
{
  if (m_isVisible)
  {
    if (m_useTransparency)
    {
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    }
    
    glBindTexture(GL_TEXTURE_2D, GetCurrentFrame());
    
    glBegin(GL_QUADS);
    
    GLfloat x = m_position.x;
    GLfloat y = m_position.y;
    
    GLfloat w = m_size.width;
    GLfloat h = m_size.height;
    
    GLfloat texWidth = (GLfloat)m_textureIndex / (GLfloat)m_numberOfFrames;
    GLfloat texHeight = 1.0f;
    GLfloat u = 0.0f;
    GLfloat v = 0.0f;
    if (m_textureIndex &lt; m_numberOfFrames)
    {
      u = (GLfloat)m_currentFrame * texWidth;
    }
    glTexCoord2f(u, v); glVertex2f(x, y);
    glTexCoord2f(u + texWidth, v); glVertex2f(x + w, y);
    glTexCoord2f(u + texWidth, v + texHeight); glVertex2f(x + w, y + h);
    glTexCoord2f(u, v + texHeight); glVertex2f(x, y + h);
    
    glEnd();
    
    if (m_useTransparency)
    {
      glDisable(GL_BLEND);
    }
  }
}</pre></div><p>This is probably<a id="id181" class="indexterm"/> one of the more complex sections of the code because rendering has to take many things into consideration. Is the sprite visible? Which frame of the sprite are we rendering? Where on screen should the sprite be rendered? Do we care about transparency? Let's walk through the code step by step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we check to see if <code class="literal">m_visible</code> is <code class="literal">true</code>. If not, we bypass the entire render.</li><li class="listitem" style="list-style-type: disc">Next, we check to see if this sprite uses transparency. If it does, we have to enable transparency. The technical term to implement transparency is blending. OpenGL has to blend the current texture with what is already on the screen. <code class="literal">glEnable(GL_BLEND)</code> turns on transparency blending. The call to <code class="literal">glBlendFunc</code> tells OpenGL exactly what type of blending we want to implement. Suffice to say that the <code class="literal">GL_SRC_ALPHA</code> and <code class="literal">GL_ONE_MIUS_SRC_ALPHA</code> parameters tell OpenGL to allow background images to be seen through transparent sections of the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glBindTexture</code> tells OpenGL which texture we want to work with right now. The call to <code class="literal">GetCurrentFrame</code> returns the OpenGL handle of the appropriate texture.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glBegin</code> tells OpenGL that we are ready to render a particular item. In this case, we are rendering a quad.</li><li class="listitem" style="list-style-type: disc">The next two lines of code set up the <code class="literal">x</code> and <code class="literal">y</code> coordinates for the sprite based on the <code class="literal">x</code> and <code class="literal">y</code> values stored in <code class="literal">m_position</code>. These values are used in the <code class="literal">glVertex2f</code> calls to position the sprite.</li><li class="listitem" style="list-style-type: disc">We will also need the <code class="literal">width</code> and <code class="literal">height</code> of the current frame, and the next two lines store these as <code class="literal">w</code> and <code class="literal">h</code> for convenience.</li><li class="listitem" style="list-style-type: disc">Finally, we<a id="id182" class="indexterm"/> need to know how much of the texture we are going to render. Typically, we render the entire texture. However, in the case of a sprite sheet we will only want to render a section of the texture. We will discuss how this works in more detail later.</li><li class="listitem" style="list-style-type: disc">Once we have the position, width, and portion of the texture that we want to render, we use for pairs of calls to <code class="literal">glTexCoord2f</code> and <code class="literal">glVertex2f</code> to map each corner of the texture to the quad. This was discussed in great detail in <a class="link" href="ch02.html" title="Chapter 2. Your Point of View">Chapter 2</a>, <span class="emphasis"><em>Your Point of View</em></span>.</li><li class="listitem" style="list-style-type: disc">The call to <code class="literal">glEnd</code> tells OpenGL that we are finished with the current render.</li><li class="listitem" style="list-style-type: disc">As alpha checking is computationally expensive, we turn it off at the end of the render with a call to <code class="literal">glDisable(GL_BLEND)</code>.</li></ul></div></div><div class="section" title="UV mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>UV mapping</h2></div></div></div><p>UV mapping was covered in detail in <a class="link" href="ch02.html" title="Chapter 2. Your Point of View">Chapter 2</a>, <span class="emphasis"><em>Your Point of View</em></span>. However, we'll do a recap here <a id="id183" class="indexterm"/>and see how it is implemented in code.</p><p>By convention, we <a id="id184" class="indexterm"/>assign the left coordinate of the texture to the variable <span class="strong"><strong>u</strong></span>, and the top coordinate of the texture to the variable <span class="strong"><strong>v</strong></span>. This technique is therefore known as <span class="strong"><strong>uv</strong></span> mapping.</p><p>OpenGL considers the origin of a texture to be at <span class="strong"><strong>uv</strong></span> coordinates of (0, 0), and the farthest extent of the texture to be at <span class="strong"><strong>uv</strong></span> coordinates of (1, 1). So, if we want to render the entire texture, we will map the entire range from (0, 0) to (1, 1) the four corners of the quad. However, let's say that we only want to render the first half of the image width (but the entire height). In this case, we will map the range of <span class="strong"><strong>uv</strong></span> coordinates from (0, 1) to (0.5, 1) to the four corners of the quad. Hopefully, you can visualize that this will only render one-half of the texture.</p><p>So, in order to render our sprite sheets, we first determine how wide each frame of the sprite is by dividing <code class="literal">m_textureIndex</code> by <code class="literal">m_numberOfFrames</code>. In the case of a sprite that has four frames, this will give us a value of 0.25.</p><p>Next, we <a id="id185" class="indexterm"/>determine which frame we are in. The following table<a id="id186" class="indexterm"/> shows the <span class="strong"><strong>uv</strong></span> ranges for each frame of a sprite with four frames:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Frame</p>
</th><th style="text-align: left" valign="bottom">
<p>u</p>
</th><th style="text-align: left" valign="bottom">
<p>v</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>0.0 to 0.25</p>
</td><td style="text-align: left" valign="top">
<p>0.0 to 1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>0.25 to 0.5</p>
</td><td style="text-align: left" valign="top">
<p>0.0 to 1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>0.5 to 0.75</p>
</td><td style="text-align: left" valign="top">
<p>0.0 to 1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>0.75 to 1.0</p>
</td><td style="text-align: left" valign="top">
<p>0.0 to 1.0</p>
</td></tr></tbody></table></div><p>As our sprite sheets are set up horizontally, we only need to worry about taking the correct range of <span class="strong"><strong>u</strong></span> from the whole texture, while the range for <span class="strong"><strong>v</strong></span> stays the same.</p><p>So, here is how our algorithm works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the sprite is not a sprite sheet, then each frame uses 100 percent of the texture, and we use a range of uv values from (0,0) to (1, 1)</li><li class="listitem" style="list-style-type: disc">If the sprite is based on a sprite sheet, we determine the width of each frame (<code class="literal">texWidth</code>) by dividing <code class="literal">m_textureIndex</code> by <code class="literal">m_numberOfFrames</code></li><li class="listitem" style="list-style-type: disc">We determine the starting u value by multiplying <code class="literal">m_currentFrame</code> by <code class="literal">texWidth</code></li><li class="listitem" style="list-style-type: disc">We determine the extent of <span class="strong"><strong>u</strong></span> by adding <code class="literal">u</code> + <code class="literal">texWidth</code></li><li class="listitem" style="list-style-type: disc">We map u to the upper-corner of the quad, and <code class="literal">u</code> + <code class="literal">texWidth</code> to the lower corner of the quad</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>v</strong></span> is mapped normally because our sprite sheets use 100 percent of the height of the texture</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>If you are having a hard time understanding uv mapping, don't fret. It took me years of application to fully understand this concept. You can play around with the uv coordinates to see how things work. For example, try settings of .05, 1, and 1.5 and see what happens!</p></div></div></div><div class="section" title="One more detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>One more detail</h2></div></div></div><p>We need to<a id="id187" class="indexterm"/> take a closer look at the call to <code class="literal">GetCurrentFrame</code> to make sure you understand what this function does. Here is the implementation:</p><div class="informalexample"><pre class="programlisting">const GLuint GetCurrentFrame()
{
  
  if(m_isSpriteSheet)
  {
    return m_textures[0];
  }
  else
  {
    return m_textures[m_currentFrame];
  }
}</pre></div><p>Here is what is happening:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the sprite is a sprite sheet, we always return <code class="literal">m_textures[0]</code> because, by definition, there is only one texture at index <code class="literal">0</code></li><li class="listitem" style="list-style-type: disc">If the sprite is not a sprite sheet, then we return the texture at index <code class="literal">m_currentFrame</code>. <code class="literal">m_currentFrame</code> is updated in the sprite update method (defined next)</li></ul></div></div></div>
<div class="section" title="A moving example"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>A moving example</h1></div></div></div><p>The code that we created until this point creates a basic scene with our robot and a background. Now, it's time to bring our robot to life using the power of animation.</p><p>Animation<a id="id188" class="indexterm"/> actually has two components. First, the sprite itself will appear to animate because we will play each frame of the sprite in sequence. If you use the stock files that were made for this book, you will see the robot's eyes and arms move.</p><p>The second component is movement across the screen. It is the combination of the robot's horizontal movement and body movements that will make a convincing animation.</p><div class="section" title="Adding update to the game loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Adding update to the game loop</h2></div></div></div><p>As with<a id="id189" class="indexterm"/> rendering, we start by adding an <code class="literal">Update</code> call to the <code class="literal">GameLoop</code> function. Modify the <code class="literal">GameLoop</code> function in <code class="literal">RoboRacer.cpp</code>:</p><div class="informalexample"><pre class="programlisting">void GameLoop(const float p_deltatTime)
{
  Update(p_deltatTime);
  Render();
}</pre></div><p>We now have two new features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We added <code class="literal">p_deltaTime</code> as a parameter. This represents the amount of time that has passed in milliseconds since the last frame. We will see how this is calculated in the following section.</li><li class="listitem" style="list-style-type: disc">We added a call to the main <code class="literal">Update</code> function (defined in the following section). Every object in the game will also have an <code class="literal">Update</code> method. In this way, the call to update the game will cascade down through every object in the game. We pass <code class="literal">p_deltatTime</code> so that every subsequent call to <code class="literal">Update</code> will know how much time has passed in the game.</li></ul></div></div><div class="section" title="Implementing the main Update call"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Implementing the main Update call</h2></div></div></div><p>Our first<a id="id190" class="indexterm"/> task is to implement the <code class="literal">Update</code> function in <code class="literal">RoboRacer.cpp</code>. Add the following function to <code class="literal">RoboRacer.cpp</code>:</p><div class="informalexample"><pre class="programlisting">void Update(const float p_deltaTime)
{
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
}</pre></div><p>Notice that we make an <code class="literal">Update</code> call to every sprite. At this point, we don't care if the sprite really needs to be updated. This decision will be made inside the <code class="literal">Sprite</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>In a real game, we would probably have an array of sprites, and we would update them<a id="id191" class="indexterm"/> all by iterating through the array and calling update on each element. As this game uses so few sprites, I have coded each sprite individually.</p></div></div></div><div class="section" title="Implementing Update in the Sprite class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Implementing Update in the Sprite class</h2></div></div></div><p>Now it's <a id="id192" class="indexterm"/>time to implement the <code class="literal">Update</code> method in our <code class="literal">Sprite</code> class. This method does all of the work required to both position the sprite and update the sprite's internal animation. Add this code to <code class="literal">Sprite.h</code>:</p><div class="informalexample"><pre class="programlisting">void Sprite::Update(const float p_deltaTime)
{
  float dt = p_deltaTime;
  
  if (m_isActive)
  {
    m_animationElapsed += dt;
    if (m_animationElapsed &gt;= m_animationDelay)
    {
      m_currentFrame++;
      if (m_currentFrame &gt;= m_numberOfFrames) m_currentFrame = 0;
      m_animationElapsed = 0.0f;
    }
    m_position.x = m_position.x + m_velocity * dt;
  }
}</pre></div><p>Here is what this code does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We store <code class="literal">p_deltaTime</code> into a local variable <code class="literal">dt</code> for convenience. This is useful because you sometimes want to hardcode the value of <code class="literal">dt</code> during testing.</li><li class="listitem" style="list-style-type: disc">Next, we test <code class="literal">m_active</code>. If this if <code class="literal">false</code>, then we bypass the entire update.</li><li class="listitem" style="list-style-type: disc">We now handle the sprite's internal animation. We first add <code class="literal">dt</code> to <code class="literal">m_animationElapsed</code> to see how much time has elapsed since the last frame change. If <code class="literal">m_animationElapsed</code> exceeds <code class="literal">m_animationDelay</code>, then it is time to increment to the next frame. This means that the higher the value of <code class="literal">m_animationDelay</code>, the slower the sprite will animate.</li><li class="listitem" style="list-style-type: disc">If necessary, we increment <code class="literal">m_currentFrame</code> making sure that once we have exceeded the total number of frame, we reset to <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc">If we just<a id="id193" class="indexterm"/> did a frame increment, we also want to reset <code class="literal">m_animationElapsed</code> to <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc">Now ,we move the sprite based on <code class="literal">m_velocity</code> and <code class="literal">dt</code>. Look at the details on using delta time to calculate movement in the upcoming sections.</li></ul></div></div><div class="section" title="Character movement"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Character movement</h2></div></div></div><p>In this version of the game, we programmed our robot to move across the screen from left to right. The <a id="id194" class="indexterm"/>key to making our character move is the <span class="strong"><strong>velocity</strong></span> property. The velocity property tells the program how many pixels to <a id="id195" class="indexterm"/>move our robot each game cycle.</p><p>As the frames come pretty fast, the velocity is typically pretty small. For example, in a game running at 60 fps, a velocity of 1 would move the robot 60 pixels each game frame. The sprite would probably be moving too fast to interact with.</p></div><div class="section" title="Using delta time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Using delta time</h2></div></div></div><p>There is a small<a id="id196" class="indexterm"/> problem with setting the velocity as a fixed value. Obviously, some computers are faster than other computers. With a fixed velocity, the robot will move faster on faster computers. This is a problem because it means that people on faster computers will have to be much better at playing the game!</p><p>We can use the computer's clock to solve this problem. The computer keeps track of the time that has passed since the start of the previous frame. In game terminology, this is called <span class="strong"><strong>delta time</strong></span>, and <a id="id197" class="indexterm"/>we assign this to a variable that we can access in the <code class="literal">Update</code> loop:</p><div class="informalexample"><pre class="programlisting">void Update(float deltaTime);</pre></div><p>In the preceding function definition, <code class="literal">deltaTime</code> is a floating value. Remember, our game is typically running at 60 fps, so <code class="literal">deltaTime</code> is going to be a very small number.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>When we set up a game to run at 60 fps, it rarely runs at exactly that speed. Each frame may take slightly more or less time to finish its calculations. Delta time tells us exactly how much time has passed, and we can use that information to adjust the timing or speed of events.</p></div></div><p>Let's take a closer look at how we use velocity to position our sprites:</p><div class="informalexample"><pre class="programlisting">m_position.x += m_velocity * dt;</pre></div><p>We multiply <code class="literal">m_velocity</code> times <code class="literal">dt</code>, and then add this to the current position. This technique automatically adjusts the velocity based on the amount of time that has passed since the<a id="id198" class="indexterm"/> last frame. If the last frame took a little less time to process, then the robot will move a little less. If the last frame took a little longer to process, then our robot will move a little further. The end result is that the robot moves consistently now on both faster and slower computers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>For slower computers, this could cause other side effects, especially regarding collision detection. If too much time goes by, then the sprite will move farther. This could, for example, cause the sprite to go right through a wall before the collision detection is checked.</p></div></div><p>As <code class="literal">dt</code> is a very small number, we will now have to use a larger number for our velocity. The current code uses a value of 50. Of course, in the full game this value will change based on what is happening to our robot.</p></div><div class="section" title="Calculating delta time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Calculating delta time</h2></div></div></div><p>We already<a id="id199" class="indexterm"/> have all of the code in place except the actual code to<a id="id200" class="indexterm"/> calculate delta time. In order to calculate the time that has elapsed during each frame of the game, we must:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Store the time before the frame.</li><li class="listitem">Store the time after the frame.</li><li class="listitem">Calculate the difference between the two.</li></ol></div><p>Open <code class="literal">RoboRacer.cpp</code> and add the following code right after the call to <code class="literal">StartGame</code>:</p><div class="informalexample"><pre class="programlisting">int previousTime = glutGet(GLUT_ELAPSED_TIME);</pre></div><p>Notice that we are using <code class="literal">GLUT</code> to get the current elapsed time. Each call to <code class="literal">glutGet(GLUT_ELAPSED_TIME)</code> will give us the number of milliseconds that have elapsed since the game started.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>In order to use GLUT, remember to copy glut.h, glut32.dll, and glut32.lib from the OpenGLFun project to the source code folder of RoboRacer2D. include glut.h at the top of SpaceRacer2D.cpp.</p></div></div><p>Next, add the following lines directly above the call to <code class="literal">GameLoop</code>:</p><div class="informalexample"><pre class="programlisting">int currentTime = glutGet(GLUT_ELAPSED_TIME);
float deltaTime = (float)(currentTime - previousTime) / 1000;
previousTime= currentTime;
GameLoop(deltaTime);</pre></div><p>Here is what<a id="id201" class="indexterm"/> we have done:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we <a id="id202" class="indexterm"/>captured the current elapsed time and stored that in <code class="literal">m_currentTime</code>.</li><li class="listitem" style="list-style-type: disc">We then calculated the time that elapsed since the last frame by subtracting <code class="literal">m_currentTime</code> from <code class="literal">m_previousTime</code>. We converted this to seconds to make it easier to deal with.</li><li class="listitem" style="list-style-type: disc">We then set <code class="literal">previousTime</code> to equal current time so that we have a benchmark for our next calculation.</li><li class="listitem" style="list-style-type: disc">Finally, we modified the call to <code class="literal">GameLoop</code> to pass the value of <code class="literal">deltaTime</code>. This will subsequently be passed to every <code class="literal">Update</code> call in the game.</li></ul></div></div><div class="section" title="Flipping"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Flipping</h2></div></div></div><p>Today's games can be created for and played on a wide variety of devices, ranging from supercharged PCs to mobile phones. Each of these devices has its own set of advantages and disadvantages. However, one rule of thumb is that as the device gets smaller its capabilities<a id="id203" class="indexterm"/> become more limited.</p><p>One area where<a id="id204" class="indexterm"/> these limitations become critical is texture memory. Texture <a id="id205" class="indexterm"/>memory is the location in the memory that stores the textures that are being used in the game. Mobile devices, in particular, are very limited by the amount of available texture memory, and game programmers have to be very careful not to exceed this limitation.</p><p>2D games tend to use a lot of texture memory. This is because each frame of every animation has to be stored in the memory to bring the 2D images to life. It is typical for a 2D game to have thousands of frames of textures that have to be loaded into memory.</p><p>One simple way to almost cut the required amount of texture memory in half is to utilize texture flipping. Simply put, our robot moving to the left is a mirror image of our robot moving to the right. Instead of using one set of textures to move to the left and another to move to the right, we can use code to flip the texture when it is rendered.</p><div class="mediaobject"><img src="graphics/8188OS_03_07.jpg" alt="Flipping"/></div><p>If you<a id="id206" class="indexterm"/> want to try it out sometime, flipping would be implemented by <a id="id207" class="indexterm"/>changing the way you mapped the sprite's <span class="strong"><strong>uv</strong></span> coordinates to the<a id="id208" class="indexterm"/> texture.</p></div><div class="section" title="Scrolling the background"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Scrolling the background</h2></div></div></div><p>You may be wondering why we set up our background as a sprite. After all, we defined sprites as<a id="id209" class="indexterm"/> objects that the player interacts with in the game, and the background is basically ignored by the robot.</p><p>The main reason to set up the background as a sprite is that this allows us to handle all of our textures in a uniform manner. The advantage of this is that we can then apply the same properties to all of our images. For example, what if we decided that we wanted our background to move?</p><p>Scrolling backgrounds are used in 2D games to give the impression of a continuously changing background. In fact, the 2D side-scrolling game is considered its own genre. There are basically two requirements to create a scrolling background:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a large texture that is wider than the screen.</li><li class="listitem">Assign a velocity to the texture so that it moves sideways.<div class="mediaobject"><img src="graphics/8188OS_03_08.jpg" alt="Scrolling the background"/></div></li></ol></div><p>The parts of the texture background that exceeds the screen width will not be rendered. As the image moves, the background appears to slide either to the left or the right. If you set the velocity <a id="id210" class="indexterm"/>of the background image to be exactly the same as the velocity of the player, you get the illusion of a background that is flying by as the robot runs left or right.</p><p>As we already implemented our background image as a sprite, the only thing that we have to do to make it scroll is to set its velocity. This was already done in the code for <code class="literal">AddTextures</code>:</p><div class="informalexample"><pre class="programlisting">background-&gt;SetVelocity(-50.0f); </pre></div><p>By setting the background velocity to <code class="literal">-50</code>, the background scrolls to the left as the robot moves to the right.</p></div></div>
<div class="section" title="Using an atlas"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Using an atlas</h1></div></div></div><p>As I have mentioned already, texture memory is one of your core resources. In fact, it is common to run out of memory because of all the textures required to animate a typical 2D game. It is also time-consuming to load individual textures rather than loading on a larger texture. So, we<a id="id211" class="indexterm"/> have to come up with methods to use texture memory more efficiently.</p><p>One common technique designed to pack more textures into less space is known as <span class="strong"><strong>atlasing</strong></span>. A <a id="id212" class="indexterm"/>texture atlas works much like a sprite sheet described earlier in this chapter. Instead of storing each texture as its own image, we pack all of the textures for the entire game into one or more textures known as <span class="strong"><strong>atlases</strong></span>.</p><p>As the word suggests, an atlas works much like a map. We simply need to know the location of any particular image, and we can find and extract it out of the atlas. Every atlas consists of two parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The texture that contains all of the images</li><li class="listitem" style="list-style-type: disc">A text file that contains the positions of each image in the atlas</li></ul></div><p>As you can<a id="id213" class="indexterm"/> imagine, efficiently packing thousands of images into an atlas and then keeping track of each image's position within the atlas would be almost impossible to manage manually. This is why there are programs to do this for us.</p><p>I use a free<a id="id214" class="indexterm"/> texture atlas tool called <span class="strong"><strong>Texture Atlas Generator</strong></span>. You can download this at <a class="ulink" href="http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/">http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/</a>.</p><p>A detailed example of atlasing is beyond the scope of this chapter. If you want to explore this on your own, here are the steps that you require:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use a program, such as the one just mentioned, to create your atlas.</li><li class="listitem">Save your data as an XML file.</li><li class="listitem">Write a<a id="id215" class="indexterm"/> class to parse the XML saved in the previous step (I suggest <span class="strong"><strong>TinyXML</strong></span> at <a class="ulink" href="http://www.grinninglizard.com/tinyxml/">http://www.grinninglizard.com/tinyxml/</a> as a starter).</li><li class="listitem">Using the code to work with sprite sheets, modify the sprite class to be able to handle sub-textures from any arbitrary position in a larger texture.</li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>This chapter has covered a lot of ground. You created a new class specifically to work with sprites. Consider this class a huge part of your utility box for any game that you will create. This class handles all of the requirements that you will need to load, move, and handle textures as objects in your game.</p><p>In the next chapter, you will learn how to how to handle input, and actually control your robot.</p></div></body></html>