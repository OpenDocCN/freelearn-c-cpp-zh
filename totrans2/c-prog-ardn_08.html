<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Designing Visual Output Feedback</h1></div></div></div><p>Interaction <a id="id879" class="indexterm"/>is everything about control and feedback. You control a system by performing actions upon it. You can even modify it. The system gives you feedback by providing useful information about what it does when you modify it.</p><p>In the previous chapter, we learned more about us controlling Arduino than Arduino giving us feedback. For instance, we used buttons and knobs to send data to Arduino, making it working for us. Of course, there are a lot of point of view, and we can easily consider controlling an LED and giving feedback to Arduino. But usually, we talk about feedback when we want to qualify a return of information from the system to us.</p><p>Arkalgud Ramaprasad, Professor at the Department of Information and Decision Sciences at the College of Business Administration, University of Illinois, Chicago, defines feedback as follows:</p><div><blockquote class="blockquote"><p>"Information about the gap between the actual level and the reference level of a system parameter which is used to alter the gap in some way."</p></blockquote></div><p>We already talked about some visual output in <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>,<em> Sensing Digital Inputs</em>, when we tried to visualize the result of our button push events. This visual rendering resulting from our push events was feedback.</p><p>We are now going to talk about the design of visual feedback systems based especially on LEDs driven by the Arduino board. LEDs are the easiest systems with which to provide visual feedback from Arduino.</p><p>We are going to learn about the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use basic monochromatic LEDs</li><li class="listitem" style="list-style-type: disc">How to make LED matrices and how to multiplex LEDs</li><li class="listitem" style="list-style-type: disc">How to use RGB LEDs</li></ul></div><p>We will finish the chapter by introducing the LCD display device.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Using LEDs</h1></div></div></div><p>LEDs can<a id="id880" class="indexterm"/> be monochromatic or polychromatic. Indeed, there are many types of LEDs. Before going though some examples, let's discover some of these LED types.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Different types of LEDs</h2></div></div></div><p>Usually, LEDs are <a id="id881" class="indexterm"/>used both to block the current coming from a line to its cathode leg and to give light feedback when the current goes into its anode:</p><div><img src="img/7584_08_001.jpg" alt="Different types of LEDs"/></div><p>The different models that we can find are as follows: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic <a id="id882" class="indexterm"/>LEDs </li><li class="listitem" style="list-style-type: disc"><strong>OLED</strong> (<strong>Organic LED</strong> made by<a id="id883" class="indexterm"/> layering the organic semi-conductor part)</li><li class="listitem" style="list-style-type: disc"><strong>AMOLED</strong> (<strong>Active Matrix OLED</strong> <a id="id884" class="indexterm"/>provides a high density of pixels for big size screens)</li><li class="listitem" style="list-style-type: disc"><strong>FOLED</strong>  (<strong>Flexible </strong><a id="id885" class="indexterm"/><strong>OLED</strong>)</li></ul></div><p>We will only talk about basic LEDs here. By the term "basic", I mean an LED with discrete components like the one in the preceding image.</p><p>The package can vary from two-legged components with a molded epoxy-like lens at the top, to surface components that provide many connectors, as shown in the following screenshot:</p><div><img src="img/7584OS_08_002.jpg" alt="Different types of LEDs"/></div><p>We can also sort them, using their light's color characteristics, into:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monochromatic LEDs</li><li class="listitem" style="list-style-type: disc">Polychromatic LEDs</li></ul></div><p>In each case, the visible color of an LED is given by the color of the molded epoxy cap; the LED itself emits the same wavelength.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec106"/>Monochromatic LEDS</h3></div></div></div><p>Monochromatic <a id="id886" class="indexterm"/>LEDs emit one color only.</p><p>The most usual monochromatic LEDs emit constant colors at each voltage need.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec107"/>Polychromatic LEDs</h3></div></div></div><p>Polychromatic LEDs <a id="id887" class="indexterm"/>can emit more than one color, depending on several parameters such as voltage but also depending on the leg fed with current in case of an LED with more than one leg.</p><p>The most important characteristic here is controllability. Polychromatic LEDs have to be easily controllable. This means that we should be able to control each color by switching it on or off. </p><p>Here is a classic RGB LED with common cathode and three different anodes:</p><div><img src="img/7584OS_08_003.jpg" alt="Polychromatic LEDs"/></div><p>This type of LED is the way to go with our Arduino stuff. They aren't expensive (around 1.2 Euros per 100 LEDs ), considering the fact that we can control them easily and produce a very huge range of colors with them.</p><p>We are going to understand how we can deal with multiple LEDs and also polychromatic RGB LEDs in the following pages.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Remembering the Hello LED example</h2></div></div></div><p>In <a id="id888" class="indexterm"/>Hello LED, we made an LED blink for 250 ms of every 1000 ms that pass. Let's see its schematic view once again to maintain the flow of your reading:</p><div><img src="img/7584OS_08_032.jpg" alt="Remembering the Hello LED example"/></div><p>The code for Hello LED is as follows:</p><div><pre class="programlisting">// Pin 8 is the one connected to our pretty LED
int ledPin = 8;                // ledPin is an integer variable initialized at 8

void setup() {                
  pinMode(ledPin, OUTPUT);     // initialize the digital pin as an output
}

// --------- the loop routine runs forever
void loop() {
  digitalWrite(ledPin, HIGH);   // turn the LED on
  delay(250);                   // wait for 250ms in the current state
  digitalWrite(ledPin, LOW);    // turn the LED off
  delay(1000);                  // wait for 1s in the current state
}</pre></div><p>Intuitively, in the next examples, we <a id="id889" class="indexterm"/>are going to try using more than one LED, playing with both monochromatic and polychromatic LEDs.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Multiple monochromatic LEDs</h2></div></div></div><p>Since we are talking <a id="id890" class="indexterm"/>about feedback here, and not just pure output, we will build a small example showing you how to deal with multiple buttons and multiple LEDs. Don't worry if you are totally unable to understand this right now; just continue reading.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec108"/>Two buttons and two LEDs</h3></div></div></div><p>We already spoke about playing with multiple buttons in <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>, <em>Sensing Digital Inputs</em>. Let's build a new circuit now.</p><p>Here are the schematics:</p><div><img src="img/7584_08_004.jpg" alt="Two buttons and two LEDs"/></div><p>It's preferable to continue<a id="id891" class="indexterm"/> drawing the electric diagram related for each schematic.</p><p>Basically,  the multiple buttons example from <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>, <em>Sensing Digital Inputs</em>; however, we have removed one button and added two LEDs instead.</p><div><img src="img/7584_08_005.jpg" alt="Two buttons and two LEDs"/></div><p>As you know, the <a id="id892" class="indexterm"/>digital pins of Arduino can be used as inputs or outputs. We can see that two switches are connected on one side to a 5 V Arduino pin and on the other side to the digital pins 2 and 3, with one pull-down resistor related to each of those latter pins, sinking the current to Arduino's ground pin.</p><p>We can also see that an LED is connected each to digital pin 8 and 9 on one side; both are connected to Arduino's ground pin.</p><p>Nothing's really incredible about that.</p><p>Before you design a dedicated firmware, you need to briefly cover something very important: coupling. It is a must to know for any interface design; more widely for interaction design.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec109"/>Control and feedback coupling in interaction design</h3></div></div></div><p>This section is considered a subchapter for two main reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, it sounds great and is key to keeping the motivation groove on</li><li class="listitem" style="list-style-type: disc">Secondly, this part is the key for all your future human-machine interface design</li></ul></div><p>As you already know, Arduino (thanks to its firmware) links the control and feedback sides. It is really important to keep this in mind.</p><p>Whatever the type of the external system may be, it is often considered as human from the Arduino point of view. As soon as you want to design an interaction system, you will have to deal with that.</p><p>We can summarize this concept with a very simple schematic in order to fix things in the mind.</p><p>Indeed, you have to understand that the firmware we are about to design will create a control-feedback coupling.</p><p>A <strong>control/feedback coupling</strong> <a id="id893" class="indexterm"/>is a set of rules that define how a system behaves when it receives orders from us and how it reacts by giving us (or not) feedback.</p><p>This hard-coded set of rules is very important to understand.</p><div><img src="img/7584_08_006.jpg" alt="Control and feedback coupling in interaction design"/></div><p>But, imagine that you <a id="id894" class="indexterm"/>want to control another system with Arduino. In that case, you may want to make the coupling outside Arduino itself. </p><p>See the second figure <strong>EXTERNAL SYSTEM 2</strong>, where I put the coupling outside Arduino. Usually, <strong>EXTERNAL SYSTEM 1</strong> is us and <strong>EXTERNAL SYSTEM 2</strong> is a computer:</p><div><img src="img/7584_08_007.jpg" alt="Control and feedback coupling in interaction design"/></div><p>We can now quote a real-life example. As with many users of interfaces and remote controllers, <a id="id895" class="indexterm"/>I like and I need to control complex software on my computer with minimalistic hardware gears.</p><p>I like the <a id="id896" class="indexterm"/>minimalistic and open source <strong>Monome interface</strong> (<a class="ulink" href="http://monome.org">http://monome.org</a>) designed by Brian Crabtree. I used it a lot, and still use it sometimes. It is basically a matrix of LEDs and buttons. The amazing trick under the hood is that there is NO coupling inside the gear.</p><div><img src="img/7584OS_08_008.jpg" alt="Control and feedback coupling in interaction design"/></div><p>The preceding image is of Monome 256 by <a id="id897" class="indexterm"/>Brian Crabtree and its very well-made wooden case.</p><p>If it isn't directly written like that in all the docs, I would like to define it to my friends and students like this: "The Monome concept is the most minimalistic interface you'll ever need because it only provides a way of controlling LEDs; beside of that, you have many buttons, but there are no logical or physical links between buttons and LEDs."</p><p>If Monome doesn't provide a real, already made coupling between buttons and LEDs, it's because it would be very restrictive and would even remove all the creativity!</p><p>Since there is a very raw and efficient protocol designed (<a class="ulink" href="http://monome.org/data/monome256_protocol.txt">http://monome.org/data/monome256_protocol.txt</a>) to especially control LEDs and read buttons pushes, we are ourselves able to create and design our own coupling. Monome is also provided with the <a id="id898" class="indexterm"/>
<strong>Monome Serial Router</strong>, which is a very small application that basically translates the raw protocol into <strong>OSC</strong>
<a id="id899" class="indexterm"/> (<a class="ulink" href="http://archive.cnmat.berkeley.edu/OpenSoundControl/">http://archive.cnmat.berkeley.edu/OpenSoundControl/</a>) or <strong>MIDI</strong>
<a id="id900" class="indexterm"/> (<a class="ulink" href="http://www.midi.org/">http://www.midi.org/</a>). We will discuss them in later sections of this chapter. These are very common in multimedia interaction design; OSC can be transported over networks, while MIDI is very suited for links between music-related equipment such as sequencers and synthesizers.</p><p>This short digression wouldn't be complete without another schematic about the Monome.</p><p>Check it and let's learn more about it after that:</p><div><img src="img/7584_08_009.jpg" alt="Control and feedback coupling in interaction design"/><div><p>The smart minimalistic Monome interface in its usual computer-based setup</p></div></div><p>Here is a schematic of the Monome 64 interface, in that usual computer-based setup inside of which the coupling occurs. This is the real setup that I used on stage for a music performance many times (<a class="ulink" href="https://vimeo.com/20110773">https://vimeo.com/20110773</a>).</p><p>I designed a specific coupling inside Max 6, translating specific messages from/to the Monome itself, but from/to the software too, especially Ableton Live (<a class="ulink" href="https://www.ableton.com">https://www.ableton.com</a>).</p><p>This is a very powerful system that controls things and provides feedback with which you can basically build your coupling from the ground up and transform your raw and minimalistic interface into whatever you need.</p><p>This was a small part of a more global monologue about interaction design.</p><p>Let's build this coupling firmware right now, and see how we can couple controls and feedback into a basic sample code.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec110"/>The coupling firmware</h3></div></div></div><p>Here, we only <a id="id901" class="indexterm"/>use the Arduino switches and LEDs and no computer actually.</p><p>Let's design a basic firmware, including coupling, based on this pseudocode:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If I push switch 1, LED 1 is switched on, and if I release it, LED 1 is switched off</li><li class="listitem" style="list-style-type: disc">If I push switch 2, LED 2 is switched on, and if I release it, LED 2 is switched off</li></ul></div><p>In order to manipulate new elements and ideas, we are going to use a library named <code class="literal">Bounce</code>. It provides an easy way to debounce digital pin inputs. We already spoke about debouncing in the <em>Understanding the debounce concept </em>section of <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>, <em>Sensing Digital Inputs</em>. Reminding you of that a bit: if no button absorbs the bounce totally when you push it, we can smoothen things and filter the non-desired harsh value jumps by using software.</p><p>You can find instructions about the <code class="literal">Bounce</code> library at <a class="ulink" href="http://arduino.cc/playground/Code/Bounce">http://arduino.cc/playground/Code/Bounce</a>.</p><p>Let's check that piece of code:</p><div><pre class="programlisting">#include &lt;Bounce.h&gt;   // include the (magic) Bounce library

#define BUTTON01 2    // pin of the button #1
#define BUTTON02 3    // pin of the button #2

#define LED01 8       // pin of the button #1
#define LED02 9       // pin of the button #2

// let's instantiate the 2 debouncers with a debounce time of 7 ms
Bounce bouncer_button01 = Bounce (BUTTON01, 7);
Bounce bouncer_button02 = Bounce (BUTTON02, 7);


void setup() {

  pinMode(BUTTON01, INPUT); // the switch pin 2 is setup as an input
  pinMode(BUTTON02, INPUT); // the switch pin 3 is setup as an input

  pinMode(LED01, OUTPUT);   // the switch pin 8 is setup as an output
  pinMode(LED02, OUTPUT);   // the switch pin 9 is setup as an output
}

void loop(){

  // let's update the two debouncers
  bouncer_button01.update();
  bouncer_button02.update();

  // let's read each button state, debounced!
  int button01_state = bouncer_button01.read();
  int button02_state = bouncer_button02.read();

  // let's test each button state and switch leds on or off
  if ( button01_state == HIGH ) digitalWrite(LED01, HIGH);
  else digitalWrite(LED01, LOW);

  if ( button02_state == HIGH ) digitalWrite(LED02, HIGH);
  else digitalWrite(LED02, LOW);
}</pre></div><p>You can find <a id="id902" class="indexterm"/>it in the <code class="literal">Chapter08/feedbacks_2x2/</code> folder.</p><p>This code includes the Bounce header file, that is, the Bounce library, at the beginning.</p><p>Then I defined four constants according to the digital input and output pins, where we put switches and LEDs in the circuit.</p><p>The Bounce library requires to <a id="id903" class="indexterm"/>instantiate each debouncer, as follows:</p><div><pre class="programlisting">Bounce bouncer_button01 = Bounce (BUTTON01, 7);
Bounce bouncer_button02 = Bounce (BUTTON02, 7);</pre></div><p>I chose a debounce time of 7 ms. This means, if you remember correctly, that two value changes occurring (voluntarily or non-voluntarily) very fast in a time interval of less than 7ms wouldn't be considered by the system, avoiding strange and uncanny bouncing results.</p><p>The <code class="literal">setup()</code> block isn't really difficult, it only defines digital pins as inputs for buttons and outputs for LEDs (please remember that digital pins can be both and that you have to choose at some point).</p><p>
<code class="literal">loop()</code> begins by the update of both debouncers, after which we read each debounced button state value.</p><p>At last, we handle the LED controls, depending on the button states. Where does the coupling occur? Of course, at this very last step. We couple our control (buttons pushed) to our feedback (LED lights) in that firmware. Let's upload and test it.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec111"/>More LEDs?</h3></div></div></div><p>We basically just saw how to attach more than one LED to our Arduino. Of course, we could do the very same way with more than two LEDs. You can find code handling six LEDs and six switches in the <code class="literal">Chapter05/feedbacks_6x6/</code> folder. </p><p>But hey, I have a question for you: how would you handle more LEDs with an Arduino Uno? Please don't answer that by saying "I'll buy an Arduino MEGA" because then I would ask you how you would handle more than 50 LEDs.</p><p>The right<a id="id904" class="indexterm"/> answer is <strong>multiplexing</strong>. Let's check how we can handle a lot of LEDs.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Multiplexing LEDs</h1></div></div></div><p>The concept of multiplexing is an interesting and efficient one. It is the key to having a bunch of peripherals connected to our Arduino boards.</p><p>Multiplexing provides a way<a id="id905" class="indexterm"/> to use few I/O pins on the board while using a lot of external components. The link between Arduino and these external components is made by using a multiplexer/demultiplexer (also shortened to mux/demux). </p><p>We spoke about input multiplexing in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <em>Playing with Analog Inputs</em>.</p><p>We are going to use the 74HC595 component here. Its datasheet can be found at <a class="ulink" href="http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf">http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf</a>.</p><p>This component is an 8-bit serial-in / serial-or-parallel-out. This means it is controlled through a serial interface, basically using three pins with Arduino and can drive with eight of its pins.</p><p>I'm going to show you how you can control eight LEDs with only three pins of your Arduino. Since Arduino Uno contains 12 digital usable pins (I'm not taking 0 and 1, as usual), we can easily imagine using 4 x 75HC595 to control 4 x 8 = 32 monochromatic LEDs with this system. I'll provide the code to do that as well.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Connecting 75HC595 to Arduino and LEDs</h2></div></div></div><p>As we<a id="id906" class="indexterm"/> learnt<a id="id907" class="indexterm"/> together <a id="id908" class="indexterm"/>with the CD4051 and the multiplexing of analog inputs, we are <a id="id909" class="indexterm"/>going to wire the chip to a 75HC595 shift register in order to mux/demux eight digital output pins. Let's check the wiring:</p><div><img src="img/7584_08_010.jpg" alt="Connecting 75HC595 to Arduino and LEDs"/></div><p>We have the Arduino supplying power to the breadboard. Each resistor provides 220 ohms resistance.</p><p>The 75HC595<a id="id910" class="indexterm"/> grabs the GND and 5 V potential for its own supply <a id="id911" class="indexterm"/>and configuration.</p><p>Basically, 74HC595 <a id="id912" class="indexterm"/>needs to be connected through pins 11, 12, and <a id="id913" class="indexterm"/>14 in order to be controlled by a serial protocol handled here by Arduino.</p><p>Let's check 74HC595 itself:</p><div><img src="img/7584_08_011.jpg" alt="Connecting 75HC595 to Arduino and LEDs"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pins 8 and 16 are used for internal power supply.</li><li class="listitem" style="list-style-type: disc">Pin 10 is named <strong>Master Reset</strong>, and in order to activate it, you have to connect this <a id="id914" class="indexterm"/>pin to the ground. That is <a id="id915" class="indexterm"/>the reason why, in normal operational states of work, we drive it to 5 V.</li><li class="listitem" style="list-style-type: disc">Pin 13 is the output enable input pin and has to be kept active in order to make the whole device output currents. Connecting it to the ground does this.</li><li class="listitem" style="list-style-type: disc">Pin 11 is the shift <a id="id916" class="indexterm"/>register clock input.</li><li class="listitem" style="list-style-type: disc">Pin 12 is the storage <a id="id917" class="indexterm"/>register clock input, also named <a id="id918" class="indexterm"/><strong>Latch</strong>.</li><li class="listitem" style="list-style-type: disc">Pin 14 is the serial data input.</li><li class="listitem" style="list-style-type: disc">Pin 15 and pins 1 to 7 are the output pins.</li></ul></div><p>Our small and inexpensive serial link to the Arduino, handled by pins 11, 12 and 14, provides an easy way to control and basically load eight bits into the device. We can cycle over the eight bits and send them serially to the device that stores them in its registers.</p><p>These types of devices are usually referred to as <strong>Shift Registers</strong> we<a id="id919" class="indexterm"/> shift bits from 0 to 7 while loading them.</p><p>Then, each state is outputted to the correct output from Q0 to Q7, transposing the previously transmitted states over serial.</p><p>This is a direct <a id="id920" class="indexterm"/>illustration of the serial-to-parallel <a id="id921" class="indexterm"/>conversion that we talked about in the previous chapter. We <a id="id922" class="indexterm"/>had a data flow coming sequentially, retained until the <a id="id923" class="indexterm"/>register is globally loaded, then pushing this to many output pins.</p><p>Now, let's visualize the wiring diagram:</p><div><img src="img/7584_08_012.jpg" alt="Connecting 75HC595 to Arduino and LEDs"/><div><p>An eight-LED array with resistors wired to the 74HC595 shift register</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Firmware for shift register handling</h2></div></div></div><p>We are going to learn how to design a firmware<a id="id924" class="indexterm"/> specifically for these kinds of shift registers. This firmware is basically made for the 595 but wouldn't require a lot of modifications to be used with other integrated circuits. You'd specially have to take care about three serial pins, Latch, Clock, and Data.</p><p>Because I want to teach you each time a bit more than the exact content evoked by each chapter title, I created a very inexpensive and small random groove machine for you. Its purpose is to generate random bytes. These bytes will then be sent to the shift register in order to feed or not each LED. You'll then have then a neat random pattern of LEDs.</p><p>You can find the code for this in the <code class="literal">Chapter08/ Multiplexing_8Leds/</code> folder.</p><p>Let's check it:</p><div><pre class="programlisting">// 595 clock pin connecting to pin 4
int CLOCK_595 = 4;

// 595 latch pin connecting to pin 3
int LATCH_595 = 3;

// 595 serial data input pin connecting to pin 2
int DATA_595 = 2;

// random groove machine variables
int counter = 0;
byte LED_states = B00000000 ;

void setup() {

  // Let's set all serial related pins as outputs
  pinMode(LATCH_595, OUTPUT);
  pinMode(CLOCK_595, OUTPUT);
  pinMode(DATA_595, OUTPUT);

  // use a seed coming from the electronic noise of the ADC 
  randomSeed(analogRead(0));
}

void loop(){

  // generate a random byte
  for (int i = 0 ; i &lt; 8 ; i++)
  {
    bitWrite(LED_states, i, random(2));
  }

  // Put latch pin to LOW (ground) while transmitting data to 595
  digitalWrite(LATCH_595, LOW);

  // Shifting Out bits i.e. using the random byte for LEDs states
  shiftOut(DATA_595, CLOCK_595, MSBFIRST, LED_states);

  // Put latch pin to HIGH (5V) &amp; all data are pushed to outputs
  digitalWrite(LATCH_595, HIGH);

  // each 5000 loop() execution, grab a new seed for the random function
  if (counter &lt; 5000) counter++;
  else 
  {
    randomSeed(analogRead(0));    // read a new value from analog pin 0
    counter = 0;                  // reset the counter
  }

  // make a short pause before changing LEDs states
  delay(45);
}</pre></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec112"/>Global shift register programming pattern</h3></div></div></div><p>First, let's check<a id="id925" class="indexterm"/> the global structure.</p><p>I first define the 3 three pins of the 595 shift register. Then, I set up each of them as output in the <code class="literal">setup()</code> block.</p><p>Then, I have a pattern that looks similar to the following:</p><div><pre class="programlisting">digitalWrite(latch-pin, LOW)
shiftOut(data-pin, clock-pin, MSBFIRST, my_states)
digitalWrite(latch-pin, HIGH)</pre></div><p>This is the usual pattern for shift- registering operations.The <code class="literal">latch-pin</code>, as evoked explained before, is the one providing us a way to inform the integrated circuit about the fact that we want to load it with data, and then we want it to apply these this data to its outputs.</p><p>This is a bit like saying:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Latch-pin LOW = "Hi there, let's store what I'm about to send to you."</li><li class="listitem" style="list-style-type: disc">Latch-pin HIGH = "Ok, now use the data I just sent to commute to your outputs or not."</li></ul></div><p>Then, we have this <code class="literal">shiftOut()</code>. This function provides an easy way to send data per entire bytes packets to a specific pin (the data pin) using a specific clock/ rate speed over a particular pin (the clock pin), and given an order of transmission (<code class="literal">MSBFIRST</code> or <code class="literal">LSBFIRST</code>).</p><p>Even though we aren't going to describe the things under- the- hood here, you have to understand the MSB and LSB concept.</p><p>Let's consider a byte: <code class="literal">1 0 1 0 0 1 1 0</code>.</p><p>The <strong>MSB</strong>
<a id="id926" class="indexterm"/> is the<a id="id927" class="indexterm"/> abbreviation of <strong>Most Significant Bit</strong>. This bit is at  the left-most position (the one of the bit having of the greatest value). Here, its value is <code class="literal">1</code>.</p><p>The <strong>LSB</strong>
<a id="id928" class="indexterm"/> is stands for the <strong>Least Significant Bit</strong>. This bit is at the right-most position (the bit of the smallest value) It is the bit the most at the right (the one of the bit having the smallest value). Here, its value is <code class="literal">0</code>.</p><p>By fixing this argument in the <code class="literal">shiftOut()</code> function, we are providing special information about the sense of the transmission. Indeed, we can send the previous byte by sending these bits: <code class="literal">1</code> then, <code class="literal">0</code>, then <code class="literal">1 0 0 1 1 0</code> (MSBFIRST), or by sending these bits: <code class="literal">0 1 1 0 0 1 0 1</code> (LSBFIRST).</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec113"/>Playing with chance and random seeds</h3></div></div></div><p>I would like to provide an example from my personal ways of programming. Here, I'm going to describe an inexpensive and small system generating random bytes. These bytes will then be sent to the the 595, and our 8 eight-LEDs array will have a very random state.</p><p>Random, in computers, isn't really random. Indeed, the <code class="literal">random()</code> function is a pseudo-random number generator. It can also be named a <strong>deterministic random bit generator</strong> (<strong>DRBG</strong>)<a id="id929" class="indexterm"/>. Indeed, the sequence is (totally) determined by a small set of initial values, including the seed.</p><p>For a particular seed, a pseudo-random number generator generates the same number sequences each time the same number sequences.</p><p>But, we you can use a trick here to disturb determinism a little bit more.</p><p>Imagine that you make the seed vary sometimes. You can also introduce an external factor of randomness into your system. As we already explained before in this book, there is always some electronic noises coming going to from to the ADC even if nothing is wired to the analog inputs. You can use that external/physical noise by reading the analog input 0, for instance.</p><p>As we now well know, analog <code class="literal">analogRead()</code> provides a number from 0 to 1023. This is a huge resolution for our purpose here.</p><p>This is what I have put in the firmware.</p><p>I defined a counter variable and a byte. I'm first reading the value coming from the ADC for the analog pin 0 in the <code class="literal">setup()</code> first. Then, I'm generating generated a random byte with a <code class="literal">for()</code> loop and the <code class="literal">bitWrite()</code> function.</p><p>I'm writing each bit of the byte <code class="literal">LED_states</code> using numbers generated by the <code class="literal">random(2)</code> number function, which gives 0 or 1, randomly. Then, I'm using use the pseudo-random-generated byte into the structure previously described.</p><p>I'm redefining each 5000 <code class="literal">loop()</code> execution of the seed by reading the ADC for the analog pin 0.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>If you want to use <code class="literal">random()</code> with computers, including Arduino and embedded systems, grab some physical and external noise.</p></div></div><p>Now, let's move further.</p><p>We can use many 74HC595 shift registers for LED handling, but imagine that you need to save some more digital pins. Okay, we saw we can save a lot using shift registers. One shift registers requires three digital pins and drives eight LEDs. It means we save five pins with each shift register, considering we wire eight LEDs.</p><p>What if you need A LOT more? What if you need to save all the other pins for switches handling, for instance?</p><p>Let's daisy chain now!</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Daisy chaining multiple 74HC595 shift registers</h2></div></div></div><p>A <strong>daisy chain</strong>
<a id="id930" class="indexterm"/> is a wiring scheme used to link multiple devices in a sequence or even a ring.</p><p>Indeed, since we already understood a bit more about how shift registers work, we could have the idea to extend this to multiple shift registers wired together, couldn't we?</p><p>I'm going to show you how to do this by using the <strong>ShiftOutX</strong> library<a id="id931" class="indexterm"/> by Juan Hernandez. I had very nice results with Version 1.0, and I advise you to use this one.</p><p>You can<a id="id932" class="indexterm"/> download it here: <a class="ulink" href="http://arduino.cc/playground/Main/ShiftOutX">http://arduino.cc/playground/Main/ShiftOutX</a>. You can install it by following the procedure explained in the appendice.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec114"/>Linking multiple shift registers</h3></div></div></div><p>What would each shift <a id="id933" class="indexterm"/>register need to know about?</p><p>The serial clock, the latch, and the data are the necessary points of information that have to be transmitted all along the device chain. Let's check a schematic:</p><div><img src="img/7584_08_013.jpg" alt="Linking multiple shift registers"/><div><p>Two shift registers daisy chained driving 16 monochromatic LEDs with only three digital pins on the Arduino</p></div></div><p>I used the same colors as with the previous circuit for the clock (blue), latch (green), and serial data (orange).</p><p>The serial clock and latch are shared across the shift registers. The command/order coming from Arduino to synchronize serial communication with the clock and to <a id="id934" class="indexterm"/>tell shift registers to store or apply data received to their output has to be coherent.</p><p>The serial data coming from Arduino first goes into the first shift register, which sends the serial data to the second one. This is the core of the chaining concept.</p><p>Let's check the circuit diagram to put this in mind:</p><div><img src="img/7584_08_014.jpg" alt="Linking multiple shift registers"/><div><p>Circuit diagram of two daisy-chained shift registers driving 16 monochromatic LEDs</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec115"/>Firmware handling two shift registers and 16 LEDs</h3></div></div></div><p>The firmware includes the<a id="id935" class="indexterm"/> <code class="literal">ShiftOutX</code> library ShiftOutX as wrote before. It provides very easy and smooth handling for daisy chaining of shift registers.</p><p>Here is the the code for the firmware.</p><p> You can find it in the <code class="literal">Chapter08/Multiplexing_WithDaisyChain/</code> folder:</p><div><pre class="programlisting">#include &lt;ShiftOutX.h&gt;
#include &lt;ShiftPinNo.h&gt;

int CLOCK_595 = 4;    // first 595 clock pin connecting to pin 4
int LATCH_595 = 3;    // first 595 latch pin connecting to pin 3
int DATA_595 = 2;     // first 595 serial data input pin connecting to pin 2

int SR_Number = 2;    // number of shift registers in the chain

// instantiate and enabling the shiftOutX library with our circuit parameters
shiftOutX regGroupOne(LATCH_595, DATA_595, CLOCK_595, MSBFIRST, SR_Number);

// random groove machine variables
int counter = 0;
byte LED0to7_states = B00000000 ;
byte LED8to15_states = B00000000 ;

void setup() {

  // NO MORE setup for each digital pin of the Arduino
  // EVERYTHING is made by the library :-)

  // use a seed coming from the electronic noise of the ADC 
  randomSeed(analogRead(0));
}

void loop(){ 

  // generate a 2 random bytes
  for (int i = 0 ; i &lt; 8 ; i++)
  {
    bitWrite(LED0to7_states, i, random(2));
    bitWrite(LED8to15_states, i, random(2));
  }

  unsigned long int data; // declaring the data container as a very local variable
  data = LED0to7_states | (LED8to15_states &lt;&lt; 8); // aggregating the 2 random bytes
  shiftOut_16(DATA_595, CLOCK_595, MSBFIRST, data);  // pushing the whole data to SRs

  // each 5000 loop() execution, grab a new seed for the random function
  if (counter &lt; 5000) counter++;
  else 
  {
    randomSeed(analogRead(0));    // read a new value from analog pin 0
    counter = 0;                  // reset the counter
  }

  // make a short pause before changing LEDs states
  delay(45);
}</pre></div><p>The ShiftOutX library<a id="id936" class="indexterm"/> can be used in many ways. We are using it here following in the same way that we did with <code class="literal">ShiftOut</code>, the library part of the core and suited for the use of only one shift register.</p><p>First, we have to include the library by using <strong>Sketch | Import Library | ShiftOutX</strong>.</p><p>It includes two header files at the beginning, namely, <code class="literal">ShiftOutX.h</code> and <code class="literal">ShiftPinNo.h</code>.</p><p> Then, we define a new variable storing the number of shift registers in the chain.</p><p> At last, we instantiate the ShiftOutX library by using the following code:</p><div><pre class="programlisting">shiftOutX regGroupOne(LATCH_595, DATA_595, CLOCK_595, MSBFIRST, SR_Number);</pre></div><p>The code in <code class="literal">setup()</code> changed a bit. Indeed, there are no more setup statements for digital pins. This part is handled by the library, which can look weird but is very usual. Indeed, when you instantiated the library before, you passed three pins of Arduino as arguments, and in fact, this statement also sets up the pins as outputs.</p><p>The <code class="literal">loop()</code> block is almost the same as before. Indeed, I included again the small random groove machine with the analog read trick. But I'm creating two random bytes, this time. Indeed, this is because I need 16 values and I want to use the <code class="literal">shiftOut_16</code> function to send all my data in the same statement. It is quite easy and usual to generate bytes, then aggregate them into an <code class="literal">unsigned short int</code> datatype by using bitwise operators.</p><p>Let's detail this operation a bit.</p><p>When we generate random bytes, we have two series of 8 eight bits. Let's take the following example:</p><div><pre class="programlisting">0 1 1 1 0 1 0 0
1 1 0 1 0 0 0 1</pre></div><p>If we want to store them in one place, what could we do? We can shift one and then add the shifted one to the other one, couldn't we?</p><div><pre class="programlisting">0 1 1 1 0 1 0 0 &lt;&lt; 8 = 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0</pre></div><p>Then, if we add a byte using the bitwise operator (<code class="literal">|</code>), we get:</p><div><pre class="programlisting">0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0
       |                             1 1 0 1 0 0 0 1
       =    0 1 1 1 0 1 0 0 1 1 0 1 0 0 0 1</pre></div><p>The result seems to be a concatenation of all the bits.</p><p>This is what we are doing in this part of the code. Then we use <code class="literal">shiftOut_16()</code> to send all the data to the two shift registers. Hey, what should we do with the four shift registers? The same thing in the same way!</p><p>Probably we would have to shift more using <code class="literal">&lt;&lt; 32</code>, <code class="literal">&lt;&lt; 16</code>, and again <code class="literal">&lt;&lt;8</code>, in order to store all our the bytes into a variable that we could send using <code class="literal">shiftOut_32()</code> functions.</p><p>By using this library, you can have two groups, each one containing eight shift registers.</p><p>What does that mean?</p><p>It means that you can drive 2 x 8 x 8 = 128 outputs using only four pins (two latches but common serial clock and data). It sounds crazy, doesn't it?</p><p>In real life, it is totally possible to use only one Arduino to make this kind of architecture, but we would have to take care of something very important, the current amount. In this particular case of 128 LEDs, we should imagine the worst case when all the LEDs would be switched on. The amount of current driven could even burn the Arduino board, which would protect itself by resetting, sometimes. But personally, I wouldn't even try.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec116"/>Current short considerations</h3></div></div></div><p>The Arduino board, using USB power supply, cannot drive more than 500 mA. All combined pins cannot drive more than 200 mA, and no pin can drive more than 40 mA. It can vary a bit from one board type to another, but these are real, absolute maximum ratings.</p><p>We didn't make these considerations and the following calculations because, in our examples, we only used a few devices and components, but you could sometimes be tempted to build a huge device such as I made sometimes, for example, with the Protodeck controller. </p><p>Let's take an example in order to look closer at some current calculations.</p><p>Imagine that you have an LED that needs around 10 mA to bright light up correctly  (without burning at the second blink!!)</p><p>This would mean you'd have 8 x 10 mA for one eight -LEDs array, driven by one 595 shift register, if all LEDs were to be switched on at the same time.</p><p>80 mA would be the global current driven by one 595 shift register from the Arduino Vcc source.</p><p>If you had more 595 shift registers, the magnitude of the current would increase. You have to know that all integrated circuits also consume current. Their consumption isn't generally taken into consideration, because it is very small. For instance, the 595 shift register circuit only consumes around 80 micro Amperes itself, which means 0.008 mA. Compared to our LEDs, it is negligible. Resistors consume current too, even if they are often used to protect LEDs, they  are very useful.</p><p>Anyway, we are about to learn another very neat and smart trick that can be used for monochromatic or RGB LEDs.</p><p>Let's move to a world full of colors.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Using RGB LEDs</h1></div></div></div><p>RGB <a id="id937" class="indexterm"/>stands for Red, Green, and Blue, as you were probably guessing.</p><p>I don't talk about <a id="id938" class="indexterm"/>LEDs that can change their color according to the voltage you apply to them. LEDs of this kind exists, but as far as I experimented, these aren't the way to go, especially while still learning steps.</p><p>I'm talking about common cathode and common anode RGB LEDs.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Some control concepts</h2></div></div></div><p>What do you need to <a id="id939" class="indexterm"/>control an LED? </p><p>You need to be able to apply a current to its legs. More precisely, you need to be able to create a difference of potential between its legs.</p><p>The direct application of this principle is what we have already tested in the first part of this chapter, which remind us how we can switch on an LED: we you need to control the current using digital output pins of our Arduino, knowing the LED we want to control has its node wired to the output pin and its cathode wired to the ground, with a resistor on the line too.</p><p>We can discuss the different ways of controls,  and you are going to understand that very quickly with the next image.</p><p>In order to make a digital output sourcing current, we need to write with <code class="literal">digitalWrite</code> to it a value of <code class="literal">HIGH</code>. In that this case, the considered digital output will be internally connected to a 5 V battery and will produce a voltage of 5 V. That means that the wired LED between it and the ground will be fed by a current.</p><p>In the other case, if we apply 5 V to an LED and if we want to switch it on, we need to write a value of <code class="literal">LOW</code> to the digital pin to which it is linked. In this case, the digital pin will be internally connected to the ground and will sink the current.</p><p>These are the two ways of controlling the current.</p><p>Check the following diagram:</p><div><img src="img/7584_08_015.jpg" alt="Some control concepts"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Different types of RGB LEDs</h2></div></div></div><p>Let's check the two <a id="id940" class="indexterm"/>common RGB LEDs:</p><div><img src="img/7584_08_016.jpg" alt="Different types of RGB LEDs"/></div><p>There are basically three LEDs in one <a id="id941" class="indexterm"/>package, with different types of wiring inside. The way of making this package isn't really about wiring inside, but I won't debate that here. </p><p>If you followed me correctly, you may have guessed that we need more digital outputs to connect RGB LEDs. Indeed, the previous section talked about saving digital pins. I guess you understand why it could be important to save pins and to plan our circuit architectures carefully.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Lighting an RGB LED</h2></div></div></div><p>Check this <a id="id942" class="indexterm"/>basic circuit:</p><div><img src="img/7584_08_017.jpg" alt="Lighting an RGB LED"/><div><p>An RGB LED wired to Arduino</p></div></div><p>Check the <a id="id943" class="indexterm"/>code now. You can find it in the <code class="literal">Chapter08/One_RGB_LED/</code> folder.</p><div><pre class="programlisting">int pinR = 4; // pin related to Red of RGB LED
int pinG = 3; // pin related to Green of RGB LED
int pinB = 2; // pin related to Blue of RGB LED

void setup() {

  pinMode(pinR, OUTPUT);
  pinMode(pinG, OUTPUT);
  pinMode(pinB, OUTPUT);
}

void loop() {

  for (int r = 0 ; r &lt; 2 ; r++)
  {
    for (int g = 0 ; g &lt; 2 ; g++)
    {
      for (int b = 0 ; b &lt; 2 ; b++)
      {
        digitalWrite(pinR,r); // turning red pin to value r
        digitalWrite(pinG,g); // turning green pin to value g
        digitalWrite(pinB,b); // turning blue pin to value b
        
        delay(150); // pausing a bit
      }
    }
  }

}</pre></div><p>Again, some tips are present inside this code.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec117"/>Red, Green, and Blue light components and colors</h3></div></div></div><p>First, what is the point here? I want to make the RGB LED<a id="id944" class="indexterm"/> cycle through all the possible states. Some math can help to list all the states.</p><p>We have an ordered list of three elements, each one of which can be on or off. Thus, there are 23 states, that which means eight states in total:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>R</p>
</th><th style="text-align: left" valign="bottom">
<p>G</p>
</th><th style="text-align: left" valign="bottom">
<p>B</p>
</th><th style="text-align: left" valign="bottom">
<p>Resulting color</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>OFF</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Blue</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Green</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Cyan</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Purple</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>Off</p>
</td><td style="text-align: left" valign="top">
<p>Orange</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>On</p>
</td><td style="text-align: left" valign="top">
<p>White</p>
</td></tr></tbody></table></div><p>Only by switching each color component on or off, can we change the global RGB LED state.</p><p>Don't forget that the system works exactly as if we were controlling three monochromatic LEDS through three digital outputs from Arduino.</p><p>First, we define three variables storing the different colors LED connectors.</p><p>Then, in the <code class="literal">setup()</code>, we set those 3 three pins as output.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec118"/>Multiple imbricated for() loops</h3></div></div></div><p>At last, the <code class="literal">loop()</code> block contains triple-imbricated <code class="literal">for()</code> loops. What's that? It is nice efficient way to be sure to match all the cases possible. It is also an easy way to cycle each number possible. Let's check the first steps, in order to understand this imbricated loops concept better.:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">1st step: <strong>r = 0, g = 0, and b = 0</strong> implies everything is OFF, then pauses for 150ms in that state</li><li class="listitem" style="list-style-type: disc">2nd step: <strong>r = 0, g = 0, and b = 1</strong> implies only BLUE is switched on, then pauses for 150ms in that state</li><li class="listitem" style="list-style-type: disc">3rd step: <strong>r = 0, g = 1, and b = 0</strong> implies only GREEN is switched on, then pauses for 150ms in that state</li></ul></div><p>The innermost loop is always the one executed the most number of times. </p><p>Is that okay? You bet, it is!</p><p>You also may have noticed that I didn't write HIGH or LOW as arguments for the <code class="literal">digitalWrite()</code> function. Indeed, HIGH and LOW are constants defined in the Arduino core library and are only replace the values 1 and 0, respectively.</p><p>In order to prove this, and especially to show you for the first time where the Arduino core files sit, the important file to check here is <code class="literal">Arduino.h</code>.</p><p>On a Windows systems, it can be found in the <code class="literal">Arduino</code> folder inside some subdirectories, depending upon the version of the IDE.</p><p>On OS X, it is in <code class="literal">Arduino.app/Contents/Resources/Java/hardware/arduino/cores/arduino/Arduino.h</code>. We can see the content of an application package by right-clicking on the package itself.</p><p>In this file, we can read a big list of constants, among many other definitions.</p><p>And finally, we can retrieve the following:</p><div><pre class="programlisting">#define HIGH 0x1
#define LOW  0x0</pre></div><p>Yes, the HIGH and LOW keywords are just constants for 1 and 0.</p><p>This is the reason why I'm directly feeding <code class="literal">digitalWrite()</code> with <code class="literal">0</code> and <code class="literal">1</code> through the imbricated loops, cycling over all the states possible for each LED, and as a consequence, over all states for the RGB LED.</p><p>Using this concept, we are going to dig further by making an LED array.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Building LED arrays</h1></div></div></div><p>LED arrays <a id="id945" class="indexterm"/>are basically LEDs wired as a matrix.</p><p>We are going to build a 3 x 3 LEDs matrix together. This is not that hard, and we'll approach this task with a really nice, neat and smart concept that can really optimize your hardware designs.</p><p>Let's check the simplest schematic of this book:</p><div><img src="img/7584_08_018.jpg" alt="Building LED arrays"/><div><p>An LED can blink when a current feeds it, when a voltage is applied to its legs</p></div></div><p>In order to switch off the LED shown in the preceding screenshot, we can stop to create the 5 V current at its node. No voltage means no current feeding. We can also cut the circuit itself to switch off the LED. And at last, we can change the ground by putting adding a 5 V source current. </p><p>This means that as soon as the difference of potential is cancelled, the LED is switched off.</p><p>An LED array is based on these double controls possible.</p><p>We are going to<a id="id946" class="indexterm"/> introduce a new component right here, the transistor.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec113"/>A new friend named transistor</h2></div></div></div><p>A <strong>transistor</strong>
<a id="id947" class="indexterm"/> is a special component that we introduced a bit in the first part of this book.</p><div><img src="img/7584_08_019.jpg" alt="A new friend named transistor"/><div><p>The usual NPN transistor with its three legs</p></div></div><p>This component is usually used in three main cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a digital switch in a logical circuit</li><li class="listitem" style="list-style-type: disc">As a signal amplifier</li><li class="listitem" style="list-style-type: disc">As a voltage stabilizer combined with other components</li></ul></div><p>Transistors are the most widespread components in the world. They are not only used as discrete components (independent ones) but are also combined with many others into a high-density system, for instance, in processors.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec114"/>The Darlington transistors array, ULN2003</h2></div></div></div><p>We are going to use a transistor here, as included inside an integrated circuit named ULN2003. What a pretty name! A more explicit one is <strong>High-current </strong>
<a id="id948" class="indexterm"/>
<strong>Darlington Transistors Array</strong>. Ok, I know that doesn't help!</p><div><img src="img/7584_08_020.jpg" alt="The Darlington transistors array, ULN2003"/></div><p>Its datasheet can be found at </p><p>
<a class="ulink" href="http://www.ti.com/lit/ds/symlink/uln2003a.pdf">http://www.ti.com/lit/ds/symlink/uln2003a.pdf</a>. </p><p>It contains seven pins named inputs and seven named outputs. We can see also a 0 V pin (the number 8) and the COM pin 9 too.</p><p> The principle is simple and amazing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0 V has to be connected to the ground</li><li class="listitem" style="list-style-type: disc">If you apply 5 V to the input <em>n</em>, the output <em>n</em> is commuted to ground</li></ul></div><p>If you apply 0 V to the input <em>n</em>, the output <em>n</em> will get disconnected.</p><p>This can easily be used as a current sink array of switches.</p><p>Combined with 74HC595, we'll drive our 3 x 3 LED matrix right now:</p><div><img src="img/7584_08_021.jpg" alt="The Darlington transistors array, ULN2003"/><div><p>A case where inputs 1 and 2 are fed, resulting in the commutation of outputs 1 and 2 (pin 16 and 14)</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec115"/>The LED matrix</h2></div></div></div><p>Let's check how we can<a id="id949" class="indexterm"/> wire our matrix, keeping in mind that we have to be able to control each LED independently, of course.</p><p>This kind of design is very usual. You can easily find ready made matrices of LEDs wired like this, sold in packages with connectors available related to rows and columns.</p><p>An LED matrix is basically an array where:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each row pops out a connector related to all the anodes of that row</li><li class="listitem" style="list-style-type: disc">Each column pops out a connector related to all the cathodes of that column</li></ul></div><p>This is not law, and I found some matrices wired totally in the opposite way and sometimes quite strangely. So, be careful and check the datasheet. Here, we are going to study a very basic LED matrix in order to dig into that concept:</p><div><img src="img/7584_08_022.jpg" alt="The LED matrix"/><div><p>A basic 3 x 3 LED matrix</p></div></div><p>Let's look at the <a id="id950" class="indexterm"/>LED <a id="id951" class="indexterm"/>matrix architecture concept.</p><p>How can we control it? By controlling, I mean addressing the good LED to a good behavior, from being switched on or off.</p><p>Let's imagine that, if we want to light up the <strong>LED 2</strong>, we have to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connect <strong>ROW 1</strong> to 5 V</li><li class="listitem" style="list-style-type: disc">Connect <strong>COLUMN 2</strong> to the ground</li></ul></div><p>Good! We can light up that <strong>LED 2</strong>.</p><p>Let's move further. Let's imagine that, if we want to light up the <strong>LED 2</strong> and <strong>LED 4</strong>, we have to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connect <strong>ROW 1</strong> to 5 V</li><li class="listitem" style="list-style-type: disc">Connect <strong>COLUMN 2</strong> to the ground</li><li class="listitem" style="list-style-type: disc">Connect <strong>ROW 2</strong> to 5 V</li><li class="listitem" style="list-style-type: disc">Connect <strong>COLUMN 1</strong> to the ground</li></ul></div><p>Did you notice something?</p><p>If you follow the steps carefully, you should have something strange on your matrix:</p><p>
<strong>LED 1</strong>, <strong>LED 2</strong>, <strong>LED 4</strong>, and <strong>LED5</strong> would be switched ON</p><p>Problem<a id="id952" class="indexterm"/> appeared: if we put 5 V to the <strong>ROW 1</strong>, how can you distinguish <strong>COLUMN 1</strong> and <strong>COLUMN 2</strong>?</p><p>We are going<a id="id953" class="indexterm"/> to see that it isn't hard at all and that it just uses a small trick related to our persistence of vision.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec116"/>Cycling and POV</h2></div></div></div><p>We can take <a id="id954" class="indexterm"/>care of the problem encountered in the previous section by cycling our matrix quickly.</p><p>The trick is switching ON only one column at a time. This could also work by switching ON only one row at a time, of course.</p><p>Let's take our previous problem: If we want to light up the <strong>LED 2</strong> and <strong>LED 4</strong>, we have to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connect <strong>ROW 1</strong> to 5 V and <strong>COLUMN 1</strong> to 5 V only</li><li class="listitem" style="list-style-type: disc">Then, put connect <strong>ROW 2</strong> to 5 V and <strong>COLUMN 2</strong> to 5 V only</li></ul></div><p>If we we are doing that this very quickly, our eyes won't see that there is only one LED switched on at a time.</p><p>The pseudo code would be:</p><div><pre class="programlisting">For each column
	Switch On the column
		For each row
			Switch on the row if the corresponding LED has to be switched On
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec117"/>The circuit</h2></div></div></div><p>First, the circuit<a id="id955" class="indexterm"/> has to be designed. Here is how it looks:</p><div><img src="img/7584_08_023.jpg" alt="The circuit"/><div><p>Arduino wired to a 595 shift register driving each row and column through an ULN2003</p></div></div><p>Let's now<a id="id956" class="indexterm"/> check the circuit diagram:</p><div><img src="img/7584_08_024.jpg" alt="The circuit"/><div><p>Circuit diagram showing the handling of matrix rows and columns </p></div></div><p>We have the now <a id="id957" class="indexterm"/>well-known shift register 74HC595.</p><p>This one is wired to a ULN2003 shift register and to the matrix' rows, the ULN2003 being wired to the columns of the matrix.</p><p>What is that design pattern?</p><p>The shift register grabs data from the serial protocol-based messages sent by the Arduino from its digital pin 2. As we tested before, the shift register is clocked to Arduino, and as soon as its latch pin is connected to HIGH (=(equal to 5 V), it drives an output to 5V or not, depending upon the data sent to it by Arduino. As a consequence, we can control each row of the matrix, feeding them rows with 5V or not through the data sent to the shift register.</p><p>In order to switch on LEDs, we have to close the circuit on which they are plugged, the electrical line, I mean. We can feed the <strong>ROW 1</strong> with a 5V current, but if we don't put this or that column to the ground, the circuit won't be closed and no LED will be switched on. Right?</p><p>The ULN2003 was made precisely for the purpose of ground commutation, as we already saw. And if we feed 5V to one of its input, it commutes the corresponding out <em>n</em> pin to the ground. So, with our 595 shift registers, we can control the 5V commutation for rows, and the ground commutation for columns. We now have total control over our matrix. </p><p>Especially, we are going to check the code, including the power cycle of columns previously explained.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec118"/>The 3 x 3 LED matrix code</h2></div></div></div><p>You can <a id="id958" class="indexterm"/>find the following 3 x 3 LED matrix code in the <code class="literal">Chapter08/LedMatrix3x3/</code> folder:</p><div><pre class="programlisting">int CLOCK_595 = 4;    // first 595 clock pin connecting to pin 4
int LATCH_595 = 3;    // first 595 latch pin connecting to pin 3
int DATA_595 = 2;     // first 595 serial data pin connecting to pin 2

// random groove machine variables
int counter = 0;
boolean LED_states[9] ;


void setup() {

  pinMode(LATCH_595, OUTPUT);
  pinMode(CLOCK_595, OUTPUT);
  pinMode(DATA_595, OUTPUT);

  // use a seed coming from the electronic noise of the ADC 
  randomSeed(analogRead(0));
}

void loop() {

  // generate random state for each 9 LEDs
  for (int i = 0 ; i &lt; 9 ; i++)
  {
    LED_states[i] = random(2) ;
  }

  // initialize data at each loop()
  byte data = 0;
  byte dataRow = 0;
  byte dataColumn = 0;
  int currentLed = 0;


  // cycling columns
  for (int c = 0 ; c &lt; 3 ; c++)
  {
    // write the 1 at the correct bit place (= current column)
    dataColumn = 1 &lt;&lt; (4 - c); 

    // cycling rows
    for (int r = 0 ; r &lt; 3 ; r++)
    {
      // IF that LED has to be up, according to LED_states array
      // write the 1 at the correct bit place (= current row)
      if (LED_states[currentLed]) dataRow = 1 &lt;&lt; (4 - c);

      // sum the two half-bytes results in the data to be sent
      data = dataRow | dataColumn;

      // Put latch pin to LOW (ground) while transmitting data to 595
      digitalWrite(LATCH_595, LOW);

      // Shifting Out bits 
      shiftOut(DATA_595, CLOCK_595, MSBFIRST, data);

      // Put latch pin to HIGH (5V) &amp; all data are pushed to outputs
      digitalWrite(LATCH_595, HIGH);


      dataRow = 0; // resetting row bits for next turn
      currentLed++;// incrementing to next LED to process
    }

    dataColumn = 0;// resetting column bits for next turn
  }


  // each 5000 loop() execution, grab a new seed for the random function
  if (counter &lt; 5000) counter++;
  else 
  {
    randomSeed(analogRead(0));    // read a new value from analog pin 0
    counter = 0;                  // reset the counter
  }

  // pause a bit to provide a cuter fx
  delay(150);
}</pre></div><p>This code is <a id="id959" class="indexterm"/>quite self-explanatory with comments, but let's check it out a bit more.</p><p>The global structure reminds the one in Multiplexing_8Leds.</p><p>We have an integers array named LED_states. We are storing data for each LED state inside of it. The setup() block is quite easy, defining each digital pin used in the communication with the 595 shift- register and then grabbing a random seed from the ADC. The loop() is a bit more tricky. At first, we generating nine random values and store them in the LED_states array. Then, we initialize/define some values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">data</code> is the byte sent to the shift register</li><li class="listitem" style="list-style-type: disc"><code class="literal">dataRow</code> is the part of the byte handling row state (commuted to 5V or not)</li><li class="listitem" style="list-style-type: disc"><code class="literal">dataColumn</code> is the part of the byte handling column state (commuted to the ground or not)</li><li class="listitem" style="list-style-type: disc"><code class="literal">currentLed</code> keeps the trace of the current handled handled by the LED</li></ul></div><p>Then, those imbricated loops occur.</p><p>For each column (first for() loop), we activate it the loop by using a small/cheap and fast bitwise operator:</p><div><pre class="programlisting">dataColumn = 1 &lt;&lt; (4 – c);</pre></div><p>
<code class="literal">(4 – c)</code> goes from <code class="literal">4</code> to <code class="literal">2</code>, all along this first <code class="literal">loop()</code> ; function; then, <code class="literal">dataColumn</code> goes from: <code class="literal">0 0 0 1 0 0 0 0</code> to <code class="literal">0 0 0 0 1 0 0 0</code>, and at last <code class="literal">0 0 0 0 0 1 0 0</code>.</p><p>What's going on right here? It is all about coding.</p><p>The first three bits (beginning at the left, the MSB bit) handle the rows of our matrix. Indeed the three rows are connected to the <code class="literal">Q0</code>, <code class="literal">Q1</code>, and <code class="literal">Q2</code> pins of the 595 shift register.</p><p>The second three-bit group handles the ULN2003, which itself handles the columns.</p><p>By feeding 5 V from <code class="literal">Q0</code>, <code class="literal">Q1</code>, and <code class="literal">Q2</code> of the 595, we handle rows. By feeding 5 V from <code class="literal">Q3</code>, <code class="literal">Q4</code>, and <code class="literal">Q5</code> of the 595, we handle columns through the ULN2003.</p><p>Good!</p><p>We still <a id="id960" class="indexterm"/>have two bits not unused bits right here, the last two.</p><p>Let's take look at our our code again.</p><p>At each column turn of the for() loop, we move the bit corresponding to the column to the right, commuting each column to the ground cyclically.</p><p>Then, for each column, we cycle the row on the same mode, testing the state of the corresponding LED that we have to push to the 595. If the LED has to be switched on, we store the corresponding bit in the dataRow variable with the same bitwise operation trick.</p><p>Then, we sum those two parts, resulting in the data variable.</p><p>For instance, if we are on the second row and the second column and the LED has to be switched on, then the data stored will be: </p><p>
<code class="literal">0 1 0 0 1 0 0 0</code>.</p><p> If we are at (1,3), then the data stored will be data will store:</p><p>
<code class="literal">1 0 0 0 0 1 0 0</code>.</p><p>Then, we have the pattern that adds Latch to LOW, shifting out bits stored in data to the shift- register, and then putting adds Latch to HIGH to commit data to the Q0 to Q7 outputs, feeding the right elements in the circuits.</p><p>At the <a id="id961" class="indexterm"/>end of each row handled, we reset the three bits corresponding to the first three rows and increment the <code class="literal">currentLed</code> variable. </p><p>At the end of each column handled, we reset the three bits corresponding to the next three columns. </p><p>This global imbricated structure makes us ensures that we'll have only one LED switched on at a time.</p><p>What is the consequence of the current consumption? </p><p>We'll only have one LED fed, which means we'll have our maximum consumption potentially divided by nine. Yes, that sounds great!</p><p>Then, we have the pattern grabbing that grabs a new seed, each 5000 loop() turn.</p><p>We just learned how to handle LED matrices quite easily and to reduce our power consumption at the same time.</p><p>But, I'm not satisfied. Usually, creators and artists are generally never completely satisfied, but here, trust me it's different; we could do better things than just switching on and off LEDs. We could dim them too and switch them from a very low intensity to a very high one, making some different shades of light.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Simulating analog outputs with PWM</h1></div></div></div><p>As we know <a id="id962" class="indexterm"/>very well by now, it's okay to<a id="id963" class="indexterm"/> switch on/off LEDs, and as we are going to see in the next chapter, to switch on/off many things too by using digital pins as output on the Arduino.</p><p>We also know how to read states from digital pins set up as inputs, and even values from 0 to 1023 from the analog inputs from in the ADC.</p><p>As far as we know, there isn't analog output on the Arduino. </p><p>What would an analog output add? It would provide a way to write values other than only 0 and 1, I mean 0 V and 5 V. This would be nice but would require an expensive DAC.</p><p>Indeed, <a id="id964" class="indexterm"/>there <a id="id965" class="indexterm"/>isn't a DAC on Arduino boards.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec119"/>The pulse-width modulation concept</h2></div></div></div><p>The <a id="id966" class="indexterm"/>
<strong>pulse-width modulation</strong> is a very common technique used to mimic analog output behavior.</p><p>Let's put that another way.</p><p>Our digital outputs can only be at 0 V or 5 V. But at a particular time-interval, if we switch them on/off quickly, then we can calculate a mean value depending on the time passed at 0 V or 5 V. This mean can easily be used as a value.</p><p>Check the following schematic to know know more about the concept of duty cycle:</p><div><img src="img/7584_08_025.jpg" alt="The pulse-width modulation concept"/><div><p>The concept of duty cycle and PWM</p></div></div><p>The mean of the time spent at 5V defines the duty cycle. This value is the mean time when the pin is at 5V and is given as a percentage.</p><p>
<code class="literal">analogWrite()</code> is a <a id="id967" class="indexterm"/>special function that can generate a steady square wave at a specific duty cycle until the next call.</p><p>According to the Arduino core documentation, the PWM signal pulses at a frequency of 490 Hz. I didn't (yet) verify this, but it would really only be possible with an oscilloscope, for instance.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>Be careful: PWM isn't available on every pin of your board!</p><p>For instance, Arduino Uno and Leonardo provide PWM on digital pins numbers 3, 5, 6, 9, 10, and 11.</p><p>You have to know this before trying anything.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec120"/>Dimming an LED</h2></div></div></div><p>Let's check a basic circuit in <a id="id968" class="indexterm"/>order to test PWM:</p><div><img src="img/7584_08_026.jpg" alt="Dimming an LED"/></div><p>Let's look at the circuit diagram, even if it's obvious:</p><div><img src="img/7584_08_027.jpg" alt="Dimming an LED"/></div><p>We'll use the<a id="id969" class="indexterm"/> Fading example by David A. Mellis and modified by Tom Igoe. Check it in <strong>File</strong> | <strong>examples</strong> | <strong>03.Analog</strong> | <strong>Fading</strong>. We are going to change the <code class="literal">ledPin</code> value from <code class="literal">9</code> to <code class="literal">11</code> to fit our circuit.</p><p>Here it is, modified:</p><div><pre class="programlisting">int ledPin = 11;    // LED connected to digital pin 11 (!!)

void setup()  { 
  // nothing happens in setup 
} 

void loop()  { 
  // fade in from min to max in increments of 5 points:
  for(int fadeValue = 0 ; fadeValue &lt;= 255; fadeValue +=5) { 
    // sets the value (range from 0 to 255):
    analogWrite(ledPin, fadeValue);         
    // wait for 30 milliseconds to see the dimming effect    
    delay(30);                            
  } 

  // fade out from max to min in increments of 5 points:
  for(int fadeValue = 255 ; fadeValue &gt;= 0; fadeValue -=5) { 
    // sets the value (range from 0 to 255):
    analogWrite(ledPin, fadeValue);         
    // wait for 30 milliseconds to see the dimming effect    
    delay(30);                            
  } 
}</pre></div><p>Upload it, <a id="id970" class="indexterm"/>test it, and love it! </p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec119"/>A higher resolution PWM driver component</h3></div></div></div><p>Of course, there are components providing <a id="id971" class="indexterm"/>higher resolutions of PWM. Here, with native Arduino boards, we have an 8-bit resolution (256 values). I wanted to point out to you the Texas Instrument, TLC5940. You can find its datasheet here: <a class="ulink" href="http://www.ti.com/lit/ds/symlink/tlc5940.pdf">http://www.ti.com/lit/ds/symlink/tlc5940.pdf</a>.</p><div><img src="img/7584_08_028.jpg" alt="A higher resolution PWM driver component"/><div><p>TLC5950, the 16-channel LED driver that provides PWM control</p></div></div><p>Be careful, it is a constant-current sink driver. This means that it sinks the current and does not feed the current. For instance, you'd have to connect cathodes of your LEDs to the <code class="literal">OUT0</code> and <code class="literal">OUT15</code> pins, not anodes. If you want to use a specific driver like that, you won't use <code class="literal">analogWrite()</code>, of course. Why? Because this driver works as a shift register, wired through a serial connection with our Arduino.</p><p>I'd suggest using a nice library named tlc5940arduino, and available on Google code at</p><p>
<a class="ulink" href="http://code.google.com/p/tlc5940arduino/">http://code.google.com/p/tlc5940arduino/</a>
</p><p>We'll see, in the<a id="id972" class="indexterm"/> third part of this book, how to write messages on LED matrices. But, there is also a nice way to use highest resolution displays: LCD.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Quick introduction to LCD</h1></div></div></div><p>
<strong>LCD</strong> <a id="id973" class="indexterm"/>means <strong>Liquid Crystal Display</strong>. We use LCD technology everyday in watches, digicode display, and so on. Look around you, and check these small or great LCDs.</p><p>There exist two big families of LCD displays:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Character LCD is based on a <a id="id974" class="indexterm"/>matrix of characters (columns x rows)</li><li class="listitem" style="list-style-type: disc">Graphical LCD , is based on<a id="id975" class="indexterm"/> a pixel matrix</li></ul></div><p>We can find a lot of printed circuit boards that include an LCD and the connectors to interface them with Arduino and other systems for cheap, nowadays.</p><p>There is now a library included in the Arduino Core that is really easy to use. Its name is <a id="id976" class="indexterm"/>
<strong>LiquidCrystal</strong>, and it works with all LCD displays that are compatible with the Hitachi HD44780 driver. This driver is really common.</p><p>Hitachi developed it as a very dedicated driver, that includes a micro-controller itself, specifically to drive alphanumeric characters LCDs and to connect to the external world easily too, which can be done by a specific link using, usually, 16 connectors, including power supply for the external circuit itself and the backlight supply too:</p><div><img src="img/7584_08_029.jpg" alt="Quick introduction to LCD"/><div><p>A 16 x 2 character LCD </p></div></div><p>We are going to wire it and display some messages on it.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec121"/>HD44780-compatible LCD display circuit</h2></div></div></div><p>Here is the basic <a id="id977" class="indexterm"/>circuit of the HD44780-compatible LCD display:</p><div><img src="img/7584_08_030.jpg" alt="HD44780-compatible LCD display circuit"/><div><p>A 16 x 2 character LCD wired to Arduino and a potentiometer controlling its contrast</p></div></div><p>The <a id="id978" class="indexterm"/>corresponding circuit diagram is as follows:</p><div><img src="img/7584_08_031.jpg" alt="HD44780-compatible LCD display circuit"/><div><p>Circuit diagram of the character LCD, the potentiometer, and the Arduino board</p></div></div><p>LED+ and LED- aren't necessary as far as you have sufficient light. Using the potentiometer, you can also set the contrast of the LCD in order to have enough readability.</p><p>By the way, <a id="id979" class="indexterm"/>LED+ and LED- are, respectively, backlight anode and backlight cathode of the internal LED used for the backlight. You can drive these from Arduino, but it can lead to more consumption. Please read the LCD instructions and datasheet carefully.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec122"/>Displaying some random messages</h2></div></div></div><p>Here<a id="id980" class="indexterm"/> is some neat firmware. You can find it in the <code class="literal">Chapter08/basicLCD/</code> folder:</p><div><pre class="programlisting">#include &lt;LiquidCrystal.h&gt;

String manyMessages[4];
int counter = 0;

// Initialize the library with pins number of the circuit
// 4-bit mode here without RW
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

void setup() {

  // set up the number of column and row of the LCD
  lcd.begin(16, 2);

  manyMessages[0] = "I am the Arduino";
  manyMessages[1] = "I can talk";
  manyMessages[2] = "I can feel";
  manyMessages[3] = "I can react";

  // shaking the dice!
  randomSeed(analogRead(0);
}

void loop() {

  // set the cursor to column 0 and row 0
  lcd.setCursor(0, 0);

  // each 5s
  if (millis() - counter &gt; 5000)
  {
    lcd.clear(); // clear the whole LCD
    lcd.print(manyMessages[random(4)]); // display a random message
    counter = millis();  // store the current time
  }

  // set the cursor to column 0 and row 1
  lcd.setCursor(0, 1);
  // print the value of millis() at each loop() execution
  lcd.print("up since: " + millis() + "ms");
}</pre></div><p>First, we have to<a id="id981" class="indexterm"/> include the <code class="literal">LiquidCrystal</code> library. Then, we define two variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">manyMessages</code> is an array of String for message storage</li><li class="listitem" style="list-style-type: disc"><code class="literal">counter</code> is a variable used for time tracing</li></ul></div><p>Then, we initialize the <code class="literal">LiquidCrystal</code> library by passing some variables to its constructor, corresponding to each pin used to wired the LCD to the Arduino. Of course, the order of pins matters. It is: <code class="literal">rs</code>, <code class="literal">enable</code>, <code class="literal">d4</code>, <code class="literal">d5</code>, <code class="literal">d6</code>, and <code class="literal">d7.</code>
</p><p>In the <code class="literal">setup()</code>, we define the size of the LCD according to the hardware, here that would be 16 columns and two rows.</p><p>Then, we statically store some messages in each element of the String array.</p><p>In the <code class="literal">loop()</code> block, we first place the cursor to the first place of the LCD.</p><p>We test the <a id="id982" class="indexterm"/>expression <code class="literal">(millis() – counter &gt; 5000)</code> , and if it is true, we clear the whole LCD. Then, I'm printing a message defined by chance. Indeed, <code class="literal">random(4)</code> produces a pseudo-random number between 0 and 3 , and that index being random, we print a random message to the LCD from among the four defined in <code class="literal">setup()</code> to the LCD, on the first row.</p><p>Then, we store the current time in order to be able to measure the time passed since the last random message was displayed.</p><p>Then, we put the cursor at the first column of the second row, then, we print a String composed by constant and variable parts displaying the time in milliseconds since the last reset of the Arduino board.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Summary</h1></div></div></div><p>In this long chapter, we learned to deal with many things, including monochromatic LEDs to RGB LEDs, using shift registers and transistor arrays, and even introduce the LCD display. We dug a bit deeper into displaying visual feedbacks from the Arduino without necessarily using a computer.</p><p>In many cases of real life design, we can find projects using Arduino boards totally standalone and, without a computer. Using special libraries and specific components, we now know that we can make our Arduino feeling, expressing, and reacting.</p><p>In the following chapter, we are going to explain and dig into some other concepts, such as making Arduino move and eventually generating sounds too.</p></div></body></html>