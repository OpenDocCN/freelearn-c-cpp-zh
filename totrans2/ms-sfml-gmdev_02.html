<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 2.  Its Game Time! - Designing the Project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/><span class="koboSpan" id="kobo.1.1">Chapter 2.  Its Game Time! </span><span class="koboSpan" id="kobo.1.2">- Designing the Project </span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the previous chapter, we covered the essential parts of our pre-established code base that is going to be used while creating a game. </span><span class="koboSpan" id="kobo.2.2">The time has come to take what we have learned and build upon it, by focusing on project-specific code that will be unique to the game we are making.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to be covering the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Implementing key entity components and systems for minimal gameplay</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Creating a couple of states for navigating the game</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Arranging all of our code into a cohesive, working project</span></li></ul></div><p><span class="koboSpan" id="kobo.7.1">We have a whole game to design, so let us get to it!</span></p><div class="section" title="Use of copyrighted resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/><span class="koboSpan" id="kobo.8.1">Use of copyrighted resources</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">In this chapter, and for the entire length of this book, we are going to be using these resources:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">Mage City Arcanos</span></em></span><span class="koboSpan" id="kobo.11.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">Hyptosis</span></em></span><span class="koboSpan" id="kobo.13.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">CC0</span></strong></span><span class="koboSpan" id="kobo.15.1"> license (public domain): </span><a class="ulink" href="http://opengameart.org/content/mage-city-arcanos"><span class="koboSpan" id="kobo.16.1">http://opengameart.org/content/mage-city-arcanos</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">[LPC] Leaf Recolor</span></em></span><span class="koboSpan" id="kobo.18.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">William. </span><span class="koboSpan" id="kobo.19.2">Thompsonj</span></em></span><span class="koboSpan" id="kobo.20.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.21.1">CC-BY-SA 3.0</span></strong></span><span class="koboSpan" id="kobo.22.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">GPL 3.0</span></strong></span><span class="koboSpan" id="kobo.24.1"> licenses: </span><a class="ulink" href="http://opengameart.org/content/lpc-leaf-recolor"><span class="koboSpan" id="kobo.25.1">http://opengameart.org/content/lpc-leaf-recolor</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.26.1">[LPC] Medieval fantasy character sprites</span></em></span><span class="koboSpan" id="kobo.27.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">Wulax</span></em></span><span class="koboSpan" id="kobo.29.1"> under </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">CC-BY-SA 3.0</span></strong></span><span class="koboSpan" id="kobo.31.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">GPL 3.0</span></strong></span><span class="koboSpan" id="kobo.33.1"> licenses: </span><a class="ulink" href="http://opengameart.org/content/lpc-medieval-fantasy-character-sprites"><span class="koboSpan" id="kobo.34.1">http://opengameart.org/content/lpc-medieval-fantasy-character-sprites</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.35.1">Fantasy UI Elements</span></em></span><span class="koboSpan" id="kobo.36.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.37.1">Ravenmore</span></em></span><span class="koboSpan" id="kobo.38.1"> at </span><a class="ulink" href="http://dycha.net/"><span class="koboSpan" id="kobo.39.1">http://dycha.net/</span></a><span class="koboSpan" id="kobo.40.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.41.1">CC-BY 3.0</span></strong></span><span class="koboSpan" id="kobo.42.1"> license: </span><a class="ulink" href="http://opengameart.org/content/fantasy-ui-elements-by-ravenmore"><span class="koboSpan" id="kobo.43.1">http://opengameart.org/content/fantasy-ui-elements-by-ravenmore</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.44.1">Vegur font</span></em></span><span class="koboSpan" id="kobo.45.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.46.1">Arro</span></em></span><span class="koboSpan" id="kobo.47.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">CC0</span></strong></span><span class="koboSpan" id="kobo.49.1"> license (public domain): </span><a class="ulink" href="http://www.fontspace.com/arro/vegur"><span class="koboSpan" id="kobo.50.1">http://www.fontspace.com/arro/vegur</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">Fantozzi's Footsteps (Grass/Sand &amp; Stone)</span></em></span><span class="koboSpan" id="kobo.52.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.53.1">Fantozzi</span></em></span><span class="koboSpan" id="kobo.54.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.55.1">CC0</span></strong></span><span class="koboSpan" id="kobo.56.1"> license (public domain): </span><a class="ulink" href="http://opengameart.org/content/fantozzis-footsteps-grasssand-stone"><span class="koboSpan" id="kobo.57.1">http://opengameart.org/content/fantozzis-footsteps-grasssand-stone</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">Electrix</span></em></span><span class="koboSpan" id="kobo.59.1"> (NES Version) by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.60.1">Snabisch</span></em></span><span class="koboSpan" id="kobo.61.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.62.1">CC-BY 3.0</span></strong></span><span class="koboSpan" id="kobo.63.1"> license: </span><a class="ulink" href="http://opengameart.org/content/electrix-nes-version"><span class="koboSpan" id="kobo.64.1">http://opengameart.org/content/electrix-nes-version</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.65.1">Town Theme RPG</span></em></span><span class="koboSpan" id="kobo.66.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.67.1">cynicmusic</span></em></span><span class="koboSpan" id="kobo.68.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.69.1">CC-BY 3.0</span></strong></span><span class="koboSpan" id="kobo.70.1"> license: </span><a class="ulink" href="http://opengameart.org/content/town-theme-rpg"><span class="koboSpan" id="kobo.71.1">http://opengameart.org/content/town-theme-rpg</span></a></li></ul></div><p><span class="koboSpan" id="kobo.72.1">Information about all of the licenses that apply to these resources can be found here:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/publicdomain/zero/1.0/"><span class="koboSpan" id="kobo.73.1">http://creativecommons.org/publicdomain/zero/1.0/</span></a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by/3.0/"><span class="koboSpan" id="kobo.74.1">http://creativecommons.org/licenses/by/3.0/</span></a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by-sa/3.0/"><span class="koboSpan" id="kobo.75.1">http://creativecommons.org/licenses/by-sa/3.0/</span></a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.gnu.org/licenses/gpl-3.0.html"><span class="koboSpan" id="kobo.76.1">http://www.gnu.org/licenses/gpl-3.0.html</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Entity placement and rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/><span class="koboSpan" id="kobo.1.1">Entity placement and rendering</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Let us start with the basics. </span><span class="koboSpan" id="kobo.2.2">Most (if not all) entities in any game we build are going to be positioned within the world. </span><span class="koboSpan" id="kobo.2.3">Let us ignore the corner cases of special types of entities for now. </span><span class="koboSpan" id="kobo.2.4">In order to represent the entity position, we are going to be creating a position component like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class C_Position : public C_Base{ 
public: 
  C_Position(): C_Base(Component::Position), m_elevation(0){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    l_stream &gt;&gt; m_position.x &gt;&gt; m_position.y &gt;&gt; m_elevation; 
  } 
 
  sf::Vector2f GetPosition() const { ... </span><span class="koboSpan" id="kobo.3.2">} 
  sf::Vector2f GetOldPosition() const { ... </span><span class="koboSpan" id="kobo.3.3">} 
  unsigned int GetElevation() const { ... </span><span class="koboSpan" id="kobo.3.4">} 
  void SetPosition(float l_x, float l_y){ ... </span><span class="koboSpan" id="kobo.3.5">} 
  void SetPosition(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.6">} 
  void SetElevation(unsigned int l_elevation){ ... </span><span class="koboSpan" id="kobo.3.7">} 
  void MoveBy(float l_x, float l_y){ ... </span><span class="koboSpan" id="kobo.3.8">} 
  void MoveBy(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.9">} 
private: 
  sf::Vector2f m_position; 
  sf::Vector2f m_positionOld; 
  unsigned int m_elevation; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">Only two things are worthy of noting here. </span><span class="koboSpan" id="kobo.4.2">First, the component type has to be set up through the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">C_Base</span></code><span class="koboSpan" id="kobo.6.1"> constructor. </span><span class="koboSpan" id="kobo.6.2">That can be changed in the future if we are going to be re-designing this system, but for now this is the way to do it. </span><span class="koboSpan" id="kobo.6.3">We must also implement the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">ReadIn</span></code><span class="koboSpan" id="kobo.8.1"> method, in order to be able to de-serialize component data properly. </span><span class="koboSpan" id="kobo.8.2">This means that every time an entity file is being loaded and the position data is encountered, it is going to read in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">x</span></em></span><span class="koboSpan" id="kobo.10.1"> coordinate, the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">y</span></em></span><span class="koboSpan" id="kobo.12.1"> coordinate, and the elevation in this exact order.</span></p><p><span class="koboSpan" id="kobo.13.1">The component itself only holds the data that is relevant to its cause. </span><span class="koboSpan" id="kobo.13.2">Two different data members for entity position are being stored here: the current position </span><code class="literal"><span class="koboSpan" id="kobo.14.1">m_position</span></code><span class="koboSpan" id="kobo.15.1">, and the position of the entity one game tick ago, </span><code class="literal"><span class="koboSpan" id="kobo.16.1">m_positionOld</span></code><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">That can be useful, should any system need to rely on position changes between updates.</span></p><div class="section" title="The drawable side of things"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/><span class="koboSpan" id="kobo.18.1">The drawable side of things</span></h2></div></div></div><p><span class="koboSpan" id="kobo.19.1">The visual side of things is not that different to represent within the ECS paradigm. </span><span class="koboSpan" id="kobo.19.2">Because we may be dealing with more than one type of renderable objects, it helps out to have an interface that they all have to honor and implement:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">class C_Drawable : public C_Base{ 
public: 
  C_Drawable(const Component&amp; l_type) : C_Base(l_type){} 
  virtual ~C_Drawable(){} 
 
  virtual void UpdatePosition(const sf::Vector2f&amp; l_vec) = 0; 
  virtual sf::Vector2u GetSize() const = 0; 
  virtual void Draw(sf::RenderWindow* l_wind) = 0; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.21.1">Depending on the type and implementation of drawable components, they may rely on different ways of representing their position, size, and the particular method of being drawn. </span><span class="koboSpan" id="kobo.21.2">All three of these aspects need to be defined when a new drawable type is created, much like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">class C_SpriteSheet : public C_Drawable{ 
public: 
  C_SpriteSheet(): C_Drawable(Component::SpriteSheet), 
    m_spriteSheet(nullptr){} 
 
  void ReadIn(std::stringstream&amp; l_stream){l_stream&gt;&gt;m_sheetName;} 
  void Create(TextureManager* l_textureMgr, 
    const std::string&amp; l_name = "") 
  { 
    if (m_spriteSheet) { m_spriteSheet.release(); } 
    m_spriteSheet = std::make_unique&lt;SpriteSheet&gt;(l_textureMgr); 
    m_spriteSheet-&gt;LoadSheet("media/Spritesheets/" + 
      (!l_name.empty() ? </span><span class="koboSpan" id="kobo.22.2">l_name : m_sheetName) + ".sheet"); 
  } 
 
  SpriteSheet* GetSpriteSheet(){ ... </span><span class="koboSpan" id="kobo.22.3">} 
  void UpdatePosition(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.22.4">} 
  sf::Vector2u GetSize() const { ... </span><span class="koboSpan" id="kobo.22.5">} 
  void Draw(sf::RenderWindow* l_wind){ ... </span><span class="koboSpan" id="kobo.22.6">} 
private: 
  std::unique_ptr&lt;SpriteSheet&gt; m_spriteSheet; 
  std::string m_sheetName; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.23.1">A sprite-sheet component utilizes one of the classes we have covered back in </span><a class="link" href="ch01.html" title="Chapter 1. Under the Hood - Setting up the Backend"><span class="koboSpan" id="kobo.24.1">Chapter 1</span></a><span class="koboSpan" id="kobo.25.1">
, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.26.1">Under the Hood - Setting up the Backend</span></em></span><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">De-serialization for this component is quite simple. </span><span class="koboSpan" id="kobo.27.3">All it requires is the name of the sheet file, which contains all size, padding, space, and animation information. </span><span class="koboSpan" id="kobo.27.4">Because this class relies on the texture manager for loading its assets, a special </span><code class="literal"><span class="koboSpan" id="kobo.28.1">Create()</span></code><span class="koboSpan" id="kobo.29.1"> method is used in order to set up this relationship post-loading.</span></p></div><div class="section" title="Rendering system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/><span class="koboSpan" id="kobo.30.1">Rendering system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.31.1">With the data aspect all taken care of and out of the way, we can now focus on actually drawing entities on screen. </span><span class="koboSpan" id="kobo.31.2">This is where the very first type of system comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">S_Renderer::S_Renderer(SystemManager* l_systemMgr) 
  :S_Base(System::Renderer, l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::SpriteSheet); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_drawableTypes.TurnOnBit((unsigned int)Component::SpriteSheet); 
  // Other types... 
 
  </span><span class="koboSpan" id="kobo.32.2">m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Direction_Changed,this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">The renderer system operates on two different types of component for now: position and sprite sheet. </span><span class="koboSpan" id="kobo.33.2">Given a wider variety of drawable component types, it would, of course, need to include them as well. </span><span class="koboSpan" id="kobo.33.3">This is precisely why a bitmask data member with the name </span><code class="literal"><span class="koboSpan" id="kobo.34.1">m_drawableTypes</span></code><span class="koboSpan" id="kobo.35.1"> is kept around. </span><span class="koboSpan" id="kobo.35.2">It keeps track of all possible drawable component types, and will be used later to fetch actual component data. </span><span class="koboSpan" id="kobo.35.3">All of those types should be registered here.</span></p><p><span class="koboSpan" id="kobo.36.1">This system also needs to be notified when an entity changes its direction, in order to enforce those changes on a given sprite sheet.</span></p><p><span class="koboSpan" id="kobo.37.1">All of the components a system uses usually need to be updated like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">void S_Renderer::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities) 
  { 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    C_Drawable* drawable = GetDrawableFromType(entity); 
    if (!drawable) { continue; } 
    drawable-&gt;UpdatePosition(position-&gt;GetPosition()); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">It's pretty straightforward. </span><span class="koboSpan" id="kobo.39.2">Any and all drawable components need to have their positions updated in order for the simulation to be accurate. </span><span class="koboSpan" id="kobo.39.3">We use a private method to obtain a pointer to whatever drawable type the current entity has, check if it's not </span><code class="literal"><span class="koboSpan" id="kobo.40.1">nullptr</span></code><span class="koboSpan" id="kobo.41.1">, and then update its position.</span></p><p><span class="koboSpan" id="kobo.42.1">Event handling is also utilized in this system in order to achieve a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.43.1">depth</span></em></span><span class="koboSpan" id="kobo.44.1"> effect by sorting entities:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.45.1">void S_Renderer::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event) 
{ 
  if (l_event == EntityEvent::Moving_Left || 
    l_event == EntityEvent::Moving_Right || 
    l_event == EntityEvent::Moving_Up || 
    l_event == EntityEvent::Moving_Down || 
    l_event == EntityEvent::Elevation_Change || 
    l_event == EntityEvent::Spawned) 
  { 
    SortDrawables(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.46.1">All we have to do here is invoke another private method that's going to sort all entities this system has along the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">y</span></em></span><span class="koboSpan" id="kobo.48.1"> axis. </span><span class="koboSpan" id="kobo.48.2">This only needs to happen if an entity is moving, changing elevations, or has just spawned.</span></p><p><span class="koboSpan" id="kobo.49.1">As far as entity messages go, we're only interested in one single type, as should be evident from the constructor of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">S_Renderer</span></code><span class="koboSpan" id="kobo.51.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">void S_Renderer::Notify(const Message&amp; l_message){ 
  if(HasEntity(l_message.m_receiver)){ 
    EntityMessage m=static_cast&lt;EntityMessage&gt;(l_message.m_type); 
    switch(m){ 
    case EntityMessage::Direction_Changed:  
      SetSheetDirection(l_message.m_receiver, 
        (Direction)l_message.m_int); 
      break; 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Another private method comes to the rescue. </span><span class="koboSpan" id="kobo.53.2">It will be covered shortly, but the basic gist of it is that sprite sheets need to be informed of any direction changes, in order to reflect them visually.</span></p><p><span class="koboSpan" id="kobo.54.1">Since the whole point of this system is rendering our entities on screen, let's do just that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.55.1">void S_Renderer::Render(Window* l_wind, unsigned int l_layer) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    if(position-&gt;GetElevation() &lt; l_layer){ continue; } 
    if(position-&gt;GetElevation() &gt; l_layer){ break; } 
    C_Drawable* drawable = GetDrawableFromType(entity); 
    if (!drawable) { continue; } 
    sf::FloatRect drawableBounds; 
    drawableBounds.left = position-&gt;GetPosition().x - 
      (drawable-&gt;GetSize().x / 2); 
    drawableBounds.top = position-&gt;GetPosition().y - 
      drawable-&gt;GetSize().y; 
    drawableBounds.width = 
      static_cast&lt;float&gt;(drawable-&gt;GetSize().x); 
    drawableBounds.height = 
      static_cast&lt;float&gt;(drawable-&gt;GetSize().y); 
    if (!l_wind-&gt;GetViewSpace().intersects(drawableBounds)){ 
      continue; 
    } 
    drawable-&gt;Draw(l_wind-&gt;GetRenderWindow()); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.56.1">Once again, it's fairly simple. </span><span class="koboSpan" id="kobo.56.2">The actual rendering is layer-based, so an argument is taken in for the specific layer we're currently drawing. </span><span class="koboSpan" id="kobo.56.3">The position component is obtained first in order to check if the entity's elevation matches the current layer being rendered. </span><span class="koboSpan" id="kobo.56.4">Because the game entities are always kept sorted, we know it's okay to break out of the loop if any given entity's elevation goes beyond the layer we're working with.</span></p><p><span class="koboSpan" id="kobo.57.1">Finally, the drawable component of the entity is obtained, as well as checked for being outside the screen area, in order to minimize unnecessary drawing.</span></p><p><span class="koboSpan" id="kobo.58.1">All we have left now are the private helper methods, starting with </span><code class="literal"><span class="koboSpan" id="kobo.59.1">SetSheetDirection</span></code><span class="koboSpan" id="kobo.60.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.61.1">void S_Renderer::SetSheetDirection(const EntityId&amp; l_entity, 
  const Direction&amp; l_dir) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  if (!entities-&gt;HasComponent(l_entity, Component::SpriteSheet)) 
  { return; } 
  auto sheet = entities-&gt; 
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet); 
  sheet-&gt;GetSpriteSheet()-&gt;SetDirection(l_dir); 
} 
</span></pre><p><span class="koboSpan" id="kobo.62.1">There's nothing we haven't seen before. </span><span class="koboSpan" id="kobo.62.2">The entity is checked for having a sprite-sheet component, which then gets obtained and informed of direction changes.</span></p><p><span class="koboSpan" id="kobo.63.1">This system heavily relies on entities being sorted, based on their </span><span class="emphasis"><em><span class="koboSpan" id="kobo.64.1">y</span></em></span><span class="koboSpan" id="kobo.65.1"> coordinate and elevation. </span><span class="koboSpan" id="kobo.65.2">For that, we use this bit of code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.66.1">void S_Renderer::SortDrawables(){ 
  EntityManager* e_mgr = m_systemManager-&gt;GetEntityManager(); 
  std::sort(m_entities.begin(), m_entities.end(), 
    [e_mgr](unsigned int l_1, unsigned int l_2) 
  { 
    auto pos1 = e_mgr-&gt; 
      GetComponent&lt;C_Position&gt;(l_1, Component::Position); 
    auto pos2 = e_mgr-&gt; 
      GetComponent&lt;C_Position&gt;(l_2, Component::Position); 
    if (pos1-&gt;GetElevation() == pos2-&gt;GetElevation()){ 
      return pos1-&gt;GetPosition().y &lt; pos2-&gt;GetPosition().y; 
    } 
    return pos1-&gt;GetElevation() &lt; pos2-&gt;GetElevation(); 
  }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.67.1">Because entity identifiers are stored inside an STL container, </span><code class="literal"><span class="koboSpan" id="kobo.68.1">std::sort</span></code><span class="koboSpan" id="kobo.69.1"> comes to the rescue. </span><span class="koboSpan" id="kobo.69.2">The actual sorting gives priority to elevation; however, if two entities share that in common, they're sorted according to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">y</span></em></span><span class="koboSpan" id="kobo.71.1"> coordinate, going from smallest to largest.</span></p><p><span class="koboSpan" id="kobo.72.1">To wrap this up, here's a method that's going to save us some typing, should additional drawable component types be added in the future:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">C_Drawable* S_Renderer::GetDrawableFromType( 
  const EntityId&amp; l_entity) 
{ 
  auto entities = m_systemManager-&gt;GetEntityManager(); 
  for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(Component::COUNT); 
    ++i) 
  { 
    if (!m_drawableTypes.GetBit(i)) { continue; } 
    auto component = static_cast&lt;Component&gt;(i); 
    if (!entities-&gt;HasComponent(l_entity, component)){ continue; } 
    return entities-&gt;GetComponent&lt;C_Drawable&gt;(l_entity,component); 
  } 
  return nullptr; 
} 
</span></pre><p><span class="koboSpan" id="kobo.74.1">All it does is simply iterate through all component types, looking for one that matches drawable types registered in the constructor of this system. </span><span class="koboSpan" id="kobo.74.2">Once one is found, the entity is checked for having that component. </span><span class="koboSpan" id="kobo.74.3">If it does, a pointer to it gets returned.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Entity kinematics"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/><span class="koboSpan" id="kobo.1.1">Entity kinematics</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The code we have written so far would only produce a static, unmoving scene. </span><span class="koboSpan" id="kobo.2.2">Since that isn't very exciting, let's work on adding potential for entity movement. </span><span class="koboSpan" id="kobo.2.3">Since it calls for more data being stored, we need another component type to work with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class C_Movable : public C_Base{ 
public: 
  C_Movable() : C_Base(Component::Movable), 
    m_velocityMax(0.f), m_direction((Direction)0){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    l_stream &gt;&gt; m_velocityMax &gt;&gt; m_speed.x &gt;&gt; m_speed.y; 
    unsigned int dir = 0; 
    l_stream &gt;&gt; dir; 
    m_direction = static_cast&lt;Direction&gt;(dir); 
  } 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">void SetVelocity(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.3">} 
  void SetMaxVelocity(float l_vel){ ... </span><span class="koboSpan" id="kobo.3.4">} 
  void SetSpeed(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.5">} 
  void SetAcceleration(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.6">} 
  void SetDirection(const Direction&amp; l_dir){ ... </span><span class="koboSpan" id="kobo.3.7">} 
  void AddVelocity(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.8">} 
  void ApplyFriction(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.9">} 
  void Accelerate(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.3.10">} 
  void Accelerate(float l_x, float l_y){ ... </span><span class="koboSpan" id="kobo.3.11">} 
  void Move(const Direction&amp; l_dir){ ... </span><span class="koboSpan" id="kobo.3.12">} 
private: 
  sf::Vector2f m_velocity; 
  sf::Vector2f m_speed; 
  sf::Vector2f m_acceleration; 
  float m_velocityMax; 
  Direction m_direction; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">Our movement is going to be modeled by the relationships between velocity, speed, and acceleration. </span><span class="koboSpan" id="kobo.4.2">For purposes of controlling entities, a maximum velocity value is going to be imposed as well, in order to prevent endless acceleration. </span><span class="koboSpan" id="kobo.4.3">We also store direction with this component in order to reduce certain complexities and inter-component relationships; however, it could be its own separate component.</span></p><div class="section" title="Movement system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/><span class="koboSpan" id="kobo.5.1">Movement system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">To kick this into gear, let us first take a look at what the movement system needs in order to work:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">S_Movement::S_Movement(SystemManager* l_systemMgr)  
  : S_Base(System::Movement,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Movable); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Is_Moving,this); 
 
  m_gameMap = nullptr; 
} 
</span></pre><p><span class="koboSpan" id="kobo.8.1">The entity's kinematic state is going to directly control its position, so we need both position and movable components here. </span><span class="koboSpan" id="kobo.8.2">An entity message type of </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Is_Moving</span></code><span class="koboSpan" id="kobo.10.1"> is also subscribed to. </span><span class="koboSpan" id="kobo.10.2">The way it is named should be a clue that this message is going to be used as a request for information, and its sender will be expecting an answer. </span><span class="koboSpan" id="kobo.10.3">Since this system is responsible for everything related to motion, it will be handling requests like this.</span></p><p><span class="koboSpan" id="kobo.11.1">Next, let us update the component data:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">void S_Movement::Update(float l_dT){ 
  if (!m_gameMap){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto movable = entities-&gt; 
      GetComponent&lt;C_Movable&gt;(entity, Component::Movable); 
    MovementStep(l_dT, movable, position); 
    position-&gt;MoveBy(movable-&gt;GetVelocity() * l_dT); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">After both components are obtained, they are passed into a private method that handles a movement step. </span><span class="koboSpan" id="kobo.13.2">We will be covering this later, but it's important to note that it takes the position component pointer in as a </span><code class="literal"><span class="koboSpan" id="kobo.14.1">const</span></code><span class="koboSpan" id="kobo.15.1"> value, which implies that it will be read only. </span><span class="koboSpan" id="kobo.15.2">This is why the position of the entity is modified separately one line down, by invoking its </span><code class="literal"><span class="koboSpan" id="kobo.16.1">MoveBy()</span></code><span class="koboSpan" id="kobo.17.1"> method. </span><span class="koboSpan" id="kobo.17.2">It simply advances the position by a vector, provided as the sole argument.</span></p><p><span class="koboSpan" id="kobo.18.1">With a more complex system task, we obviously have more events to deal with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">void S_Movement::HandleEvent(const EntityId&amp; l_entity,  
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Colliding_X: 
    StopEntity(l_entity, Axis::x); break; 
  case EntityEvent::Colliding_Y: 
    StopEntity(l_entity, Axis::y); break; 
  case EntityEvent::Moving_Left: 
    SetDirection(l_entity, Direction::Left); break; 
  case EntityEvent::Moving_Right: 
    SetDirection(l_entity, Direction::Right); break; 
  case EntityEvent::Moving_Up: 
    { 
      auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
      if(mov-&gt;GetVelocity().x == 0){ 
        SetDirection(l_entity, Direction::Up); 
      } 
    } 
    break; 
  case EntityEvent::Moving_Down: 
    { 
      auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
      if(mov-&gt;GetVelocity().x == 0){ 
        SetDirection(l_entity, Direction::Down); 
      } 
    } 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.20.1">We will want to stop our entity on a given axis, if it is actually colliding with a solid. </span><span class="koboSpan" id="kobo.20.2">The collision event emission will be discussed when we are covering the collision system, so all we have to remember now is that if an entity is colliding on a specific axis, it needs to have its velocity reduced to </span><code class="literal"><span class="koboSpan" id="kobo.21.1">0</span></code><span class="koboSpan" id="kobo.22.1"> on that axis.</span></p><p><span class="koboSpan" id="kobo.23.1">Since we are also in charge of the entity's direction, movement events are handled and used to update it. </span><span class="koboSpan" id="kobo.23.2">Direction priority is given to horizontal movement, while up and down directions are only set if the velocity on the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">x</span></em></span><span class="koboSpan" id="kobo.25.1"> axis is zero.</span></p><p><span class="koboSpan" id="kobo.26.1">Back in the constructor of this system, we have subscribed to a message that requests movement information. </span><span class="koboSpan" id="kobo.26.2">Let us take a look at how that can be handled:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">void S_Movement::Notify(const Message&amp; l_message){ 
  EntityManager* eMgr = m_systemManager-&gt;GetEntityManager(); 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::Is_Moving: 
    { 
    if (!HasEntity(l_message.m_receiver)){ return; } 
    auto movable = eMgr-&gt; 
     GetComponent&lt;C_Movable&gt;(l_message.m_receiver, 
     Component::Movable); 
    if (movable-&gt;GetVelocity() != sf::Vector2f(0.f, 0.f)){return;} 
    m_systemManager-&gt;AddEvent(l_message.m_receiver, 
      (EventID)EntityEvent::Became_Idle); 
    } 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">If the entity information was requested about isn't even part of this system, the message gets ignored. </span><span class="koboSpan" id="kobo.28.2">Otherwise, the movable component is obtained and its velocity gets checked for not being an absolute zero. </span><span class="koboSpan" id="kobo.28.3">If it is, an entity event </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Became_Idle</span></code><span class="koboSpan" id="kobo.30.1"> is sent out. </span><span class="koboSpan" id="kobo.30.2">This will be useful later, when we're dealing with entity animations.</span></p><p><span class="koboSpan" id="kobo.31.1">Once again, all the hard lifting exists inside our helper methods. </span><span class="koboSpan" id="kobo.31.2">Let's start with a simple one, used to obtain tile friction for a specific coordinate in space:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">sf::Vector2f S_Movement::GetTileFriction(unsigned int l_elevation, 
  unsigned int l_x, unsigned int l_y) 
{ 
  Tile* t = nullptr; 
  while (!t &amp;&amp; l_elevation &gt;= 0){ 
    t = m_gameMap-&gt;GetTile(l_x, l_y, l_elevation); 
    --l_elevation; 
  } 
 
  return(t ? </span><span class="koboSpan" id="kobo.32.2">t-&gt;m_properties-&gt;m_friction : 
    m_gameMap-&gt;GetDefaultTile()-&gt;m_friction); 
} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">A </span><code class="literal"><span class="koboSpan" id="kobo.34.1">null</span></code><span class="koboSpan" id="kobo.35.1"> pointer to a tile is established first. </span><span class="koboSpan" id="kobo.35.2">A </span><code class="literal"><span class="koboSpan" id="kobo.36.1">while</span></code><span class="koboSpan" id="kobo.37.1"> loop is then used to attempt to obtain an actual tile, starting with the original elevation and moving down until it reaches </span><span class="emphasis"><em><span class="koboSpan" id="kobo.38.1">0</span></em></span><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">We finally return either the friction of the tile that was found, or the default friction of the map if it wasn't. </span><span class="koboSpan" id="kobo.39.3">It comes into play when we're trying to process the movement step of an entity here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.40.1">void S_Movement::MovementStep(float l_dT, C_Movable* l_movable, 
  const C_Position* l_position) 
{ 
  sf::Vector2f f_coefficient = GetTileFriction( 
    l_position-&gt;GetElevation(), 
    static_cast&lt;unsigned int&gt;(floor(l_position-&gt;GetPosition().x / 
      Sheet::Tile_Size)), 
    static_cast&lt;unsigned int&gt;(floor(l_position-&gt;GetPosition().y / 
      Sheet::Tile_Size))); 
 
  sf::Vector2f friction(l_movable-&gt;GetSpeed().x * f_coefficient.x, 
    l_movable-&gt;GetSpeed().y * f_coefficient.y); 
 
  l_movable-&gt;AddVelocity(l_movable-&gt;GetAcceleration() * l_dT); 
  l_movable-&gt;SetAcceleration(sf::Vector2f(0.0f, 0.0f)); 
  l_movable-&gt;ApplyFriction(friction * l_dT); 
 
  float magnitude = sqrt( 
    (l_movable-&gt;GetVelocity().x * l_movable-&gt;GetVelocity().x) + 
    (l_movable-&gt;GetVelocity().y * l_movable-&gt;GetVelocity().y)); 
 
  if (magnitude &lt;= l_movable-&gt;GetMaxVelocity()){ return; } 
  float max_V = l_movable-&gt;GetMaxVelocity(); 
  l_movable-&gt;SetVelocity(sf::Vector2f( 
    (l_movable-&gt;GetVelocity().x / magnitude) * max_V, 
    (l_movable-&gt;GetVelocity().y / magnitude) * max_V)); 
} 
</span></pre><p><span class="koboSpan" id="kobo.41.1">After the friction coefficient is obtained from the current tile an entity is standing on, speed loss due to friction is calculated, velocity due to acceleration is added, acceleration itself is zeroed out, and friction is applied. </span><span class="koboSpan" id="kobo.41.2">In order to account for diagonal movement, a velocity magnitude is calculated and checked for exceeding the maximum allowed value. </span><span class="koboSpan" id="kobo.41.3">If it does, the entity's velocity is re-calculated based on the ratios between its current velocity and the total magnitude, and adjusted to fit within the provided boundaries.</span></p><p><span class="koboSpan" id="kobo.42.1">Stopping an entity simply comes down to zeroing its velocity out on a provided axis, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">void S_Movement::StopEntity(const EntityId&amp; l_entity,  
  const Axis&amp; l_axis) 
{ 
  auto movable = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
  if(l_axis == Axis::x){ 
    movable-&gt;SetVelocity(sf::Vector2f( 
      0.f, movable-&gt;GetVelocity().y)); 
  } else if(l_axis == Axis::y){ 
    movable-&gt;SetVelocity(sf::Vector2f( 
      movable-&gt;GetVelocity().x, 0.f)); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">Updating the entity's direction is equally as simple, but it can't go unnoticed by other systems:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.45.1">void S_Movement::SetDirection(const EntityId&amp; l_entity,  
  const Direction&amp; l_dir) 
{ 
  auto movable = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
  movable-&gt;SetDirection(l_dir); 
 
  Message msg((MessageType)EntityMessage::Direction_Changed); 
  msg.m_receiver = l_entity; 
  msg.m_int = static_cast&lt;int&gt;(l_dir); 
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
} 
</span></pre><p><span class="koboSpan" id="kobo.46.1">After the direction is updated, a new message is constructed and dispatched, letting the relevant systems know about the direction changes of an entity. </span><span class="koboSpan" id="kobo.46.2">This will also prove to be incredibly useful when handling entity animations.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Handling collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/><span class="koboSpan" id="kobo.1.1">Handling collisions</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In order to make the game we're making feel like more than just entities moving across a static background with no consequences, collisions have to be checked for and handled. </span><span class="koboSpan" id="kobo.2.2">Within the ECS paradigm, this can be achieved by implementing a collidable component. </span><span class="koboSpan" id="kobo.2.3">For more flexibility, let's define multiple points that the collision box can be attached to:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class Origin{ Top_Left, Abs_Centre, Mid_Bottom }; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">TOP_LEFT</span></strong></span><span class="koboSpan" id="kobo.6.1"> origin simply places the collision rectangle's top-left corner to the position provided. </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">ABS_CENTRE</span></strong></span><span class="koboSpan" id="kobo.8.1"> moves that rectangle's centre to the position, and the </span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">MIDDLE_BOTTOM</span></strong></span><span class="koboSpan" id="kobo.10.1"> origin places it halfway through the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">x</span></em></span><span class="koboSpan" id="kobo.12.1"> axis and all the way down the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">y</span></em></span><span class="koboSpan" id="kobo.14.1"> axis. </span><span class="koboSpan" id="kobo.14.2">Consider the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.15.1"><img src="graphics/image_02_001.jpg" alt="Handling collisions"/></span></div><p><span class="koboSpan" id="kobo.16.1">With this information, let us work on implementing the collidable component:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">class C_Collidable : public C_Base{ 
public: 
  C_Collidable(): C_Base(Component::Collidable),  
    m_origin(Origin::Mid_Bottom), m_collidingOnX(false), 
    m_collidingOnY(false){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    unsigned int origin = 0; 
    l_stream &gt;&gt; m_AABB.width &gt;&gt; m_AABB.height &gt;&gt; m_offset.x 
      &gt;&gt; m_offset.y &gt;&gt; origin; 
    m_origin = static_cast&lt;Origin&gt;(origin); 
  } 
   
  const sf::FloatRect&amp; GetCollidable() const { ... </span><span class="koboSpan" id="kobo.17.2">} 
  bool IsCollidingOnX() const { ... </span><span class="koboSpan" id="kobo.17.3">} 
  bool IsCollidingOnY() const { ... </span><span class="koboSpan" id="kobo.17.4">} 
  void CollideOnX(){ m_collidingOnX = true; } 
  void CollideOnY(){ m_collidingOnY = true; } 
  void ResetCollisionFlags(){ ... </span><span class="koboSpan" id="kobo.17.5">} 
  void SetCollidable(const sf::FloatRect&amp; l_rect){ ... </span><span class="koboSpan" id="kobo.17.6">} 
  void SetOrigin(const Origin&amp; l_origin){ ... </span><span class="koboSpan" id="kobo.17.7">} 
  void SetSize(const sf::Vector2f&amp; l_vec){ ... </span><span class="koboSpan" id="kobo.17.8">} 
 
  void SetPosition(const sf::Vector2f&amp; l_vec){ 
    switch(m_origin){ 
    case(Origin::Top_Left) : 
      m_AABB.left    = l_vec.x + m_offset.x; 
      m_AABB.top     = l_vec.y + m_offset.y; 
      break; 
    case(Origin::Abs_Centre): 
      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; 
      m_AABB.top     = l_vec.y - (m_AABB.height / 2) + m_offset.y; 
      break; 
    case(Origin::Mid_Bottom): 
      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; 
      m_AABB.top     = l_vec.y - m_AABB.height + m_offset.y; 
      break; 
    } 
  } 
private: 
  sf::FloatRect m_AABB; 
  sf::Vector2f m_offset; 
  Origin m_origin; 
 
  bool m_collidingOnX; 
  bool m_collidingOnY; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.18.1">First, let us look at the data we are keeping. </span><code class="literal"><span class="koboSpan" id="kobo.19.1">sf::FloatRect</span></code><span class="koboSpan" id="kobo.20.1"> represents the basic </span><span class="strong"><strong><span class="koboSpan" id="kobo.21.1">AABB</span></strong></span><span class="koboSpan" id="kobo.22.1"> bounding box around the entity that will be used as our collider. </span><span class="koboSpan" id="kobo.22.2">We also want to be able to offset it by some value, which is going to be loaded from the entity file. </span><span class="koboSpan" id="kobo.22.3">Obviously, the origin point is stored as well, along with two flags that indicate whether a collision is happening on each axis.</span></p><p><span class="koboSpan" id="kobo.23.1">The </span><code class="literal"><span class="koboSpan" id="kobo.24.1">SetPosition()</span></code><span class="koboSpan" id="kobo.25.1"> method incorporates the use of an origin point and adjusts the rectangle to be positioned properly, since the native </span><code class="literal"><span class="koboSpan" id="kobo.26.1">sf::FloatRect</span></code><span class="koboSpan" id="kobo.27.1"> doesn't support origins by itself.</span></p><div class="section" title="Collision system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/><span class="koboSpan" id="kobo.28.1">Collision system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.29.1">In order to work with and handle collisions, we only need two components:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">S_Collision::S_Collision(SystemManager* l_systemMgr)  
  : S_Base(System::Collision,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Collidable); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_gameMap = nullptr; 
} 
</span></pre><p><span class="koboSpan" id="kobo.31.1">Note the</span><code class="literal"><span class="koboSpan" id="kobo.32.1"> m_gameMap</span></code><span class="koboSpan" id="kobo.33.1"> data member. </span><span class="koboSpan" id="kobo.33.2">We're going to need to provide the collision system with a pointer to the game map at some point, in order to be able to handle map collisions.</span></p><p><span class="koboSpan" id="kobo.34.1">Next, let's handle updating our component data:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void S_Collision::Update(float l_dT){ 
  if (!m_gameMap){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto collidable = entities-&gt; 
      GetComponent&lt;C_Collidable&gt;(entity, Component::Collidable); 
     
    CheckOutOfBounds(position); 
    collidable-&gt;SetPosition(position-&gt;GetPosition()); 
    collidable-&gt;ResetCollisionFlags(); 
    MapCollisions(entity, position, collidable); 
  } 
  EntityCollisions(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">First, the entity's position is checked to see whether it's outside the map's boundaries. </span><span class="koboSpan" id="kobo.36.2">After it potentially has been adjusted, the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">collidable</span></code><span class="koboSpan" id="kobo.38.1"> component is updated with the new position information, and its collision flags are reset. </span><span class="koboSpan" id="kobo.38.2">Both components are then passed into a private method that handles map collisions.</span></p><p><span class="koboSpan" id="kobo.39.1">After all of the entities are checked against the map, we must check them for collisions against each other:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.40.1">void S_Collision::EntityCollisions(){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto itr = m_entities.begin(); itr!=m_entities.end(); ++itr) 
  { 
    for(auto itr2=std::next(itr); itr2!=m_entities.end(); ++itr2){ 
      auto collidable1 = entities-&gt; 
        GetComponent&lt;C_Collidable&gt;(*itr, Component::Collidable); 
      auto collidable2 = entities-&gt; 
        GetComponent&lt;C_Collidable&gt;(*itr2, Component::Collidable); 
      if(collidable1-&gt;GetCollidable().intersects( 
        collidable2-&gt;GetCollidable())) 
      { 
        // Entity-on-entity collision! 
      </span><span class="koboSpan" id="kobo.40.2">} 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.41.1">So far, we don't really need to handle entity-on-entity collisions in any way, but this is an entry point for later features.</span></p><p><span class="koboSpan" id="kobo.42.1">The out-of-bounds check is fairly simple:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">void S_Collision::CheckOutOfBounds(C_Position* l_pos){ 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
 
  if (l_pos-&gt;GetPosition().x &lt; 0){ 
    l_pos-&gt;SetPosition(0.0f, l_pos-&gt;GetPosition().y); 
  } else if (l_pos-&gt;GetPosition().x &gt; 
    m_gameMap-&gt;GetMapSize().x * TileSize) 
  { 
    l_pos-&gt;SetPosition( 
      static_cast&lt;float&gt;(m_gameMap-&gt;GetMapSize().x * TileSize), 
      l_pos-&gt;GetPosition().y); 
  } 
 
  if (l_pos-&gt;GetPosition().y &lt; 0){ 
    l_pos-&gt;SetPosition(l_pos-&gt;GetPosition().x, 0.0f); 
  } else if (l_pos-&gt;GetPosition().y &gt; 
    m_gameMap-&gt;GetMapSize().y * TileSize) 
  { 
    l_pos-&gt;SetPosition( 
      l_pos-&gt;GetPosition().x, 
      static_cast&lt;float&gt;(m_gameMap-&gt;GetMapSize().y * TileSize)); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.44.1">It simply checks the position for being either in negative coordinates, or outside the map's boundaries.</span></p><p><span class="koboSpan" id="kobo.45.1">Processing actual map collisions is further broken down into more readable bits:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">void S_Collision::MapCollisions(const EntityId&amp; l_entity, 
  C_Position* l_pos, C_Collidable* l_col) 
{ 
  Collisions c; 
  CheckCollisions(l_pos, l_col, c); 
  HandleCollisions(l_entity, l_pos, l_col, c); 
} 
</span></pre><p><span class="koboSpan" id="kobo.47.1">After a </span><code class="literal"><span class="koboSpan" id="kobo.48.1">Collisions</span></code><span class="koboSpan" id="kobo.49.1"> data type is set up, it, along with the position and collidable components, is passed to two private methods, which actually perform collision checks, and later handle them. </span><span class="koboSpan" id="kobo.49.2">The </span><code class="literal"><span class="koboSpan" id="kobo.50.1">Collisions</span></code><span class="koboSpan" id="kobo.51.1"> data type is just a container for collision information:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">struct CollisionElement{ 
  CollisionElement(float l_area, TileInfo* l_info, 
    const sf::FloatRect&amp; l_bounds):m_area(l_area), m_tile(l_info), 
    m_tileBounds(l_bounds){} 
  float m_area; 
  TileInfo* m_tile; 
  sf::FloatRect m_tileBounds; 
}; 
 
using Collisions = std::vector&lt;CollisionElement&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Let us focus on actually filling this structure out with useful collision information next:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">void S_Collision::CheckCollisions(C_Position* l_pos, 
  C_Collidable* l_col, Collisions&amp; l_collisions) 
{ 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
  sf::FloatRect EntityAABB = l_col-&gt;GetCollidable(); 
  int FromX = static_cast&lt;int&gt;(floor(EntityAABB.left / TileSize)); 
  int ToX = static_cast&lt;int&gt;(floor((EntityAABB.left + 
    EntityAABB.width) / TileSize)); 
  int FromY = static_cast&lt;int&gt;(floor(EntityAABB.top / TileSize)); 
  int ToY = static_cast&lt;int&gt;(floor((EntityAABB.top + 
    EntityAABB.height) / TileSize)); 
 
  for (int x = FromX; x &lt;= ToX; ++x) { 
    for (int y = FromY; y &lt;= ToY; ++y) { 
      for (size_t l = l_pos-&gt;GetElevation(); l &lt; 
        l_pos-&gt;GetElevation() + 1; ++l) 
      { 
        auto t = m_gameMap-&gt;GetTile(x, y, l); 
        if (!t) { continue; } 
        if (!t-&gt;m_solid) { continue; } 
        sf::FloatRect TileAABB = static_cast&lt;sf::FloatRect&gt;( 
          sf::IntRect(x*TileSize, y*TileSize,TileSize,TileSize)); 
        sf::FloatRect Intersection; 
        EntityAABB.intersects(TileAABB, Intersection); 
        float S = Intersection.width * Intersection.height; 
        l_collisions.emplace_back(S, t-&gt;m_properties, TileAABB); 
        break; 
      } 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.55.1">This method uses the entity collision box and the map tile size to establish a range of tiles that are intersecting with it. </span><span class="koboSpan" id="kobo.55.2">We then use that range to obtain tiles one by one, check if they exist and are solid, construct their bounding boxes, measure the areas of intersection, and add all of that information to the collision container. </span><span class="koboSpan" id="kobo.55.3">So far, so good!</span></p><p><span class="koboSpan" id="kobo.56.1">The grand finale of this system is, of course, handling all of the collision information that got collected:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">void S_Collision::HandleCollisions(const EntityId&amp; l_entity, 
  C_Position* l_pos, C_Collidable* l_col,Collisions&amp; l_collisions) 
{ 
  sf::FloatRect EntityAABB = l_col-&gt;GetCollidable(); 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
 
  if (l_collisions.empty()) { return; } 
  std::sort(l_collisions.begin(), l_collisions.end(), 
    [](CollisionElement&amp; l_1, CollisionElement&amp; l_2) { 
      return l_1.m_area &gt; l_2.m_area; 
    } 
  ); 
 
  for (auto &amp;col : l_collisions) { 
    EntityAABB = l_col-&gt;GetCollidable(); 
    if (!EntityAABB.intersects(col.m_tileBounds)) { continue; } 
    float xDiff = (EntityAABB.left + (EntityAABB.width / 2)) - 
      (col.m_tileBounds.left + (col.m_tileBounds.width / 2)); 
    float yDiff = (EntityAABB.top + (EntityAABB.height / 2)) - 
      (col.m_tileBounds.top + (col.m_tileBounds.height / 2)); 
    float resolve = 0; 
    if (std::abs(xDiff) &gt; std::abs(yDiff)) { 
      if (xDiff &gt; 0) { 
        resolve=(col.m_tileBounds.left+TileSize)-EntityAABB.left; 
      } else { 
        resolve = -((EntityAABB.left + EntityAABB.width) - 
          col.m_tileBounds.left); 
      } 
      l_pos-&gt;MoveBy(resolve, 0); 
      l_col-&gt;SetPosition(l_pos-&gt;GetPosition()); 
      m_systemManager-&gt;AddEvent( 
        l_entity, (EventID)EntityEvent::Colliding_X); 
      l_col-&gt;CollideOnX(); 
    } else { 
      if (yDiff &gt; 0) { 
        resolve=(col.m_tileBounds.top + TileSize)-EntityAABB.top; 
      } else { 
        resolve = -((EntityAABB.top + EntityAABB.height) - 
          col.m_tileBounds.top); 
      } 
      l_pos-&gt;MoveBy(0, resolve); 
      l_col-&gt;SetPosition(l_pos-&gt;GetPosition()); 
      m_systemManager-&gt;AddEvent( 
        l_entity, (EventID)EntityEvent::Colliding_Y); 
      l_col-&gt;CollideOnY(); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">The collision container is first checked for being empty. </span><span class="koboSpan" id="kobo.58.2">If it isn't, we sort the collision information to flow in a descending order, and use the size of the intersecting area for the comparison. </span><span class="koboSpan" id="kobo.58.3">This ensures that the collision(s) with the largest area of intersection come first, and thus gets handled first.</span></p><p><span class="koboSpan" id="kobo.59.1">During the processing of this information, we must first check if the entity's bounding box is still colliding with the tile. </span><span class="koboSpan" id="kobo.59.2">In case of multiple collisions, the first collision that got processed may have moved an entity in such a way that it no longer collides with anything at all.</span></p><p><span class="koboSpan" id="kobo.60.1">The </span><code class="literal"><span class="koboSpan" id="kobo.61.1">xDiff</span></code><span class="koboSpan" id="kobo.62.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.63.1">yDiff</span></code><span class="koboSpan" id="kobo.64.1"> variables are used to hold the penetration information of each axis, and the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">resolve</span></code><span class="koboSpan" id="kobo.66.1"> variable will be used to store exact distance by which the entity is going to be pushed to resolve the collision. </span><span class="koboSpan" id="kobo.66.2">The first two variables are then compared, in order to decide which axis to resolve the collision on. </span><span class="koboSpan" id="kobo.66.3">Our </span><code class="literal"><span class="koboSpan" id="kobo.67.1">resolve</span></code><span class="koboSpan" id="kobo.68.1"> variable is used to calculate the exact distance of the push based on whether it's a left-to-right or right-to-left collision.</span></p><p><span class="koboSpan" id="kobo.69.1">Finally, the position is adjusted by the resolve distance on the relevant axis, the collidable component's position is updated to match the changes, a colliding event is sent out, and the collidable component's </span><code class="literal"><span class="koboSpan" id="kobo.70.1">CollideOnX</span></code><span class="koboSpan" id="kobo.71.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.72.1">CollideOnY</span></code><span class="koboSpan" id="kobo.73.1"> method is invoked to update the collision flags. </span><span class="koboSpan" id="kobo.73.2">These events then get handled by other systems, such as </span><code class="literal"><span class="koboSpan" id="kobo.74.1">S_Movement</span></code><span class="koboSpan" id="kobo.75.1">, which we have already covered.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Controlling entities"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/><span class="koboSpan" id="kobo.1.1">Controlling entities</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Since we have already laid down the code foundation, it's now possible to focus on controlling the entities on the screen. </span><span class="koboSpan" id="kobo.2.2">Whether they're being controlled as player avatars by means of a keyboard, or through some sort of </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">artificial intelligence </span></strong></span><span class="koboSpan" id="kobo.4.1">(</span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">AI</span></strong></span><span class="koboSpan" id="kobo.6.1">), they still need to have this basic component:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class C_Controller : public C_Base{ 
public: 
  C_Controller() : C_Base(Component::Controller){} 
  void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">As you can tell, we have absolutely no data that gets stored here so far. </span><span class="koboSpan" id="kobo.8.2">For now, it can simply be considered just a specific signature that lets the ECS know it can be controlled.</span></p><div class="section" title="Control system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/><span class="koboSpan" id="kobo.9.1">Control system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">In order for entities to be controlled, they must have three basic component types:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">S_Control::S_Control(SystemManager* l_systemMgr) 
  : S_Base(System::Control,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Movable); 
  req.TurnOnBit((unsigned int)Component::Controller); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Actual control happens through the event system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">void S_Control::HandleEvent(const EntityId&amp; l_entity,  
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Moving_Left: 
    MoveEntity(l_entity, Direction::Left); break; 
  case EntityEvent::Moving_Right: 
    MoveEntity(l_entity, Direction::Right); break; 
  case EntityEvent::Moving_Up: 
    MoveEntity(l_entity, Direction::Up); break; 
  case EntityEvent::Moving_Down: 
    MoveEntity(l_entity, Direction::Down); break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">The movement itself is just a modification of the movable component, as shown here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">void S_Control::MoveEntity(const EntityId&amp; l_entity,  
  const Direction&amp; l_dir) 
{ 
  auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity, Component::Movable); 
  mov-&gt;Move(l_dir); 
} 
</span></pre><p><span class="koboSpan" id="kobo.16.1">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">C_Movable</span></code><span class="koboSpan" id="kobo.18.1"> component type takes care of actually modifying its data. </span><span class="koboSpan" id="kobo.18.2">All we need to do is pass in a valid direction.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Entity states"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/><span class="koboSpan" id="kobo.1.1">Entity states</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Having entities that are able to move around now implies they can either be standing still or moving. </span><span class="koboSpan" id="kobo.2.2">This quickly brings about the issue of entity states. </span><span class="koboSpan" id="kobo.2.3">Luckily, we have an elegant way of dealing with that, by introducing another component type and a system. </span><span class="koboSpan" id="kobo.2.4">Let's start by enumerating all possible entity states, and using the enumeration to establish a component type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class EntityState{ Idle, Walking, Attacking, Hurt, Dying }; 
 
class C_State : public C_Base{ 
public: 
  C_State(): C_Base(Component::State){} 
  void ReadIn(std::stringstream&amp; l_stream){ 
    unsigned int state = 0; 
    l_stream &gt;&gt; state; 
    m_state = static_cast&lt;EntityState&gt;(state); 
  } 
 
  EntityState GetState() const { ... </span><span class="koboSpan" id="kobo.3.2">} 
  void SetState(const EntityState&amp; l_state){ ... </span><span class="koboSpan" id="kobo.3.3">} 
private: 
  EntityState m_state; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">That's all we have to keep track of inside the component class. </span><span class="koboSpan" id="kobo.4.2">Time to move on to the system!</span></p><div class="section" title="State system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/><span class="koboSpan" id="kobo.5.1">State system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.6.1">Because state is not directly tethered to any other data, we can only require one component type to be present in order to work with states:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">S_State::S_State(SystemManager* l_systemMgr) 
  : S_Base(System::State,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::State); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Move,this); 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Switch_State,this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.8.1">This system also needs to subscribe to two different message types: </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Move</span></code><span class="koboSpan" id="kobo.10.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Switch_State</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The action of movement is obviously state-dependent, since, for example, an entity shouldn't be able to move if it is dead.</span></p><p><span class="koboSpan" id="kobo.13.1">Updating entities with a state is fairly basic, since we're about to utilize the movement system indirectly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">void S_State::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(entity, Component::State); 
    if(state-&gt;GetState() == EntityState::Walking){ 
      Message msg((MessageType)EntityMessage::Is_Moving); 
      msg.m_receiver = entity; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">All we care about so far is if the state of the current entity is </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Walking</span></code><span class="koboSpan" id="kobo.17.1">, but the entity has gone idle. </span><span class="koboSpan" id="kobo.17.2">For that, we can send out the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Is_Moving</span></code><span class="koboSpan" id="kobo.19.1"> message, which the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">S_Movement</span></code><span class="koboSpan" id="kobo.21.1"> is going to respond to with an event, given that the entity has stopped. </span><span class="koboSpan" id="kobo.21.2">That event is then handled here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void S_State::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Became_Idle: 
    ChangeState(l_entity,EntityState::Idle,false); 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">A private method for changing an entity's state is invoked, setting it to </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Idle</span></code><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">Kids' stuff!</span></p><p><span class="koboSpan" id="kobo.26.1">Next, let us handle the message types this system is subscribed to:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">void S_State::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)){ return; } 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::Move: 
    { 
      auto state = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_State&gt;(l_message.m_receiver, 
        Component::State); 
 
      if (state-&gt;GetState() == EntityState::Dying){ return; } 
      EntityEvent e; 
      Direction dir = static_cast&lt;Direction&gt;(l_message.m_int); 
      if (dir==Direction::Up){e=EntityEvent::Moving_Up;} 
      else if (dir==Direction::Down){e=EntityEvent::Moving_Down;} 
      else if(dir==Direction::Left){e=EntityEvent::Moving_Left;} 
      else if(dir==Direction::Right){e=EntityEvent::Moving_Right;} 
 
      m_systemManager-&gt;AddEvent(l_message.m_receiver, 
        static_cast&lt;EventID&gt;(e)); 
      ChangeState(l_message.m_receiver, 
        EntityState::Walking,false); 
    } 
    break; 
  case EntityMessage::Switch_State:  
    ChangeState(l_message.m_receiver, 
      (EntityState)l_message.m_int,false); 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Since actual entity movement depends on its state, this is the system that decides whether there is movement or not. </span><span class="koboSpan" id="kobo.28.2">The entity's state is first checked, to make sure it can't move if it's dying. </span><span class="koboSpan" id="kobo.28.3">An </span><code class="literal"><span class="koboSpan" id="kobo.29.1">EntityEvent</span></code><span class="koboSpan" id="kobo.30.1"> structure is then constructed and set to match the direction of the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Move</span></code><span class="koboSpan" id="kobo.32.1"> message. </span><span class="koboSpan" id="kobo.32.2">After the event is dispatched, the entity's state is changed to </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Walking</span></code><span class="koboSpan" id="kobo.34.1">.</span></p><p><span class="koboSpan" id="kobo.35.1">Other systems within the ECS may care about the state of an entity changing. </span><span class="koboSpan" id="kobo.35.2">For that, we need to handle these changes accordingly:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">void S_State::ChangeState(const EntityId&amp; l_entity,  
  const EntityState&amp; l_state, bool l_force) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto state = entities-&gt; 
    GetComponent&lt;C_State&gt;(l_entity, Component::State); 
  if (!l_force &amp;&amp; state-&gt;GetState()==EntityState::Dying){return;} 
  state-&gt;SetState(l_state); 
  Message msg((MessageType)EntityMessage::State_Changed); 
  msg.m_receiver = l_entity; 
  msg.m_int = static_cast&lt;int&gt;(l_state); 
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
} 
</span></pre><p><span class="koboSpan" id="kobo.37.1">Note the last argument of this method. </span><span class="koboSpan" id="kobo.37.2">It indicates whether the state change should be forced or not. </span><span class="koboSpan" id="kobo.37.3">This is done to ensure that certain state changes can be defined as non-critical, and should be ignored if an entity is dying.</span></p><p><span class="koboSpan" id="kobo.38.1">If the state ends up getting changed, the component data is updated, and a new </span><code class="literal"><span class="koboSpan" id="kobo.39.1">State_Changed</span></code><span class="koboSpan" id="kobo.40.1"> message is dispatched to inform other systems.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Sheet animation system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/><span class="koboSpan" id="kobo.1.1">Sheet animation system</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">One of the objects sensitive to state changes is the sprite sheet animation system. </span><span class="koboSpan" id="kobo.2.2">Knowing an entity's state is of paramount importance, if we desire to apply animations that describe its current action:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">S_SheetAnimation::S_SheetAnimation(SystemManager* l_systemMgr) 
  : S_Base(System::SheetAnimation,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::SpriteSheet); 
  req.TurnOnBit((unsigned int)Component::State); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::State_Changed,this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.4.1">As you can see, all we need are two component types and a subscription to a message type of </span><code class="literal"><span class="koboSpan" id="kobo.5.1">State_Changed</span></code><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">So far, so good!</span></p><p><span class="koboSpan" id="kobo.7.1">Updating the sprite sheets can get a little involved, so let us delve right into it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">void S_SheetAnimation::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto sheet = entities-&gt; 
      GetComponent&lt;C_SpriteSheet&gt;(entity, Component::SpriteSheet); 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(entity, Component::State); 
 
    sheet-&gt;GetSpriteSheet()-&gt;Update(l_dT); 
 
    const std::string&amp; animName = sheet-&gt; 
      GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;GetName(); 
    if(animName == "Attack"){ 
      if(!sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying()) 
      { 
        Message msg((MessageType)EntityMessage::Switch_State); 
        msg.m_receiver = entity; 
        msg.m_int = static_cast&lt;int&gt;(EntityState::Idle); 
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
      } else if(sheet-&gt;GetSpriteSheet()-&gt; 
        GetCurrentAnim()-&gt;IsInAction()) 
      { 
        Message msg((MessageType)EntityMessage::Attack_Action); 
        msg.m_sender = entity; 
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
      } 
    } else if(animName == "Death" &amp;&amp; 
      !sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying()) 
    { 
      Message msg((MessageType)EntityMessage::Dead); 
      msg.m_receiver = entity; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
    if (sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;CheckMoved()){ 
      int frame = sheet-&gt;GetSpriteSheet()-&gt; 
        GetCurrentAnim()-&gt;GetFrame(); 
      Message msg((MessageType)EntityMessage::Frame_Change); 
      msg.m_receiver = entity; 
      msg.m_int = frame; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.9.1">After the sprite sheet and state components are obtained, the sheet gets updated. </span><span class="koboSpan" id="kobo.9.2">The name of its current animation is then obtained. </span><span class="koboSpan" id="kobo.9.3">Keep in mind that certain entity states are dependent on the current animation, and as soon as that animation is over, we want to switch back to an idle state. </span><span class="koboSpan" id="kobo.9.4">For example, the attack animation is first checked for no longer playing. </span><span class="koboSpan" id="kobo.9.5">If that's the case, a message is sent to the state system, letting it know that this entity's state needs to be switched to idle. </span><span class="koboSpan" id="kobo.9.6">Additionally, the animation's action range is checked, which is used to determine whether, for example, the current frames of the attack animation are of the character swinging the sword just right, where we can inflict damage.</span></p><p><span class="koboSpan" id="kobo.10.1">The exact same principle applies to the death animation, except the message that gets sent out once that is finished is different.</span></p><p><span class="koboSpan" id="kobo.11.1">Finally, every single animation has to be checked for frame progression, in which case a message gets sent out, notifying systems interested in that type that the animation frame has changed.</span></p><p><span class="koboSpan" id="kobo.12.1">As mentioned before, sprite sheets need to know if the entity's state has changed. </span><span class="koboSpan" id="kobo.12.2">This is where we handle that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">void S_SheetAnimation::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)) { return; } 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::State_Changed: 
    { 
      EntityState s = static_cast&lt;EntityState&gt;(l_message.m_int); 
      switch(s){ 
      case EntityState::Idle: 
        ChangeAnimation(l_message.m_receiver,"Idle",true,true); 
        break; 
      case EntityState::Walking: 
        ChangeAnimation(l_message.m_receiver,"Walk",true,true); 
        break; 
      case EntityState::Attacking: 
        ChangeAnimation(l_message.m_receiver,"Attack",true,false); 
        break; 
      case EntityState::Hurt: break; 
      case EntityState::Dying: 
        ChangeAnimation(l_message.m_receiver,"Death",true,false); 
        break; 
      } 
    } 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">This essentially just maps the name of a specific animation to a state. </span><span class="koboSpan" id="kobo.14.2">The private method used to set that up is quite simple:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">void S_SheetAnimation::ChangeAnimation(const EntityId&amp; l_entity,  
  const std::string&amp; l_anim, bool l_play, bool l_loop) 
{ 
  auto sheet = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet); 
  sheet-&gt;GetSpriteSheet()-&gt;SetAnimation(l_anim,l_play,l_loop); 
} 
</span></pre><p><span class="koboSpan" id="kobo.16.1">It takes in the entity identifier, the name of the animation, a flag for whether the animation should be played automatically, and another flag for whether it should loop. </span><span class="koboSpan" id="kobo.16.2">The sprite sheet that sits inside the component is then requested to play the animation provided.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Entity sounds"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/><span class="koboSpan" id="kobo.1.1">Entity sounds</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Just like states, an entity can emit multiple different types of sound. </span><span class="koboSpan" id="kobo.2.2">Each different type must also have certain parameters associated with it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class EntitySound{ None = -1, Footstep, Attack, 
  Hurt, Death, COUNT }; 
 
struct SoundParameters{ 
  static const int Max_SoundFrames = 5; 
  SoundParameters(){ 
    for (int i = 0; i &lt; Max_SoundFrames; ++i){ m_frames[i] = -1; } 
  } 
  std::string m_sound; 
  std::array&lt;int, Max_SoundFrames&gt; m_frames; 
}; 
</span></pre><p><code class="literal"><span class="koboSpan" id="kobo.4.1">struct SoundParameters</span></code><span class="koboSpan" id="kobo.5.1"> simply stores the name of the sound, as well as an array of integers for the maximum number of sound frames. </span><span class="koboSpan" id="kobo.5.2">A sound frame is the glue between sounds and sprite sheets, as it defines during which animation frames the sound is emitted.</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Having defined the previous data structure allows us to successfully create a sound emitter component type:</span></li></ul></div><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class C_SoundEmitter : public C_Base{ 
public: 
  C_SoundEmitter():C_Base(Component::SoundEmitter),m_soundID(-1){} 
  void ReadIn(std::stringstream&amp; l_stream){ 
    std::string main_delimiter = ":"; 
    std::string frame_delimiter = ","; 
    for (size_t i=0;i&lt;static_cast&lt;size_t&gt;(EntitySound::COUNT);++i) 
    { 
      std::string chunk; 
      l_stream &gt;&gt; chunk; 
      if (chunk.empty()){ break; } 
 
      std::string sound = chunk.substr(0, 
        chunk.find(main_delimiter)); 
      std::string frames = chunk.substr(chunk.find(main_delimiter) 
        +main_delimiter.length()); 
      m_params[i].m_sound = sound; 
      size_t pos = 0; 
      unsigned int frameNum = 0; 
      while (frameNum &lt; SoundParameters::Max_SoundFrames){ 
        pos = frames.find(frame_delimiter); 
        int frame = -1; 
        if (pos != std::string::npos){ 
          frame = stoi(frames.substr(0, pos)); 
          frames.erase(0, pos + frame_delimiter.length()); 
        } else { 
          frame = stoi(frames); 
          m_params[i].m_frames[frameNum] = frame; 
          break; 
        } 
        m_params[i].m_frames[frameNum] = frame; 
        ++frameNum; 
      } 
    } 
  } 
 
  SoundID GetSoundID() const { ... </span><span class="koboSpan" id="kobo.7.2">} 
  void SetSoundID(const SoundID&amp; l_id){ ... </span><span class="koboSpan" id="kobo.7.3">} 
  const std::string&amp; GetSound(const EntitySound&amp; l_snd) const{...} 
  bool IsSoundFrame(const EntitySound&amp; l_snd, int l_frame) const 
  { ... </span><span class="koboSpan" id="kobo.7.4">} 
  SoundParameters* GetParameters() { ... </span><span class="koboSpan" id="kobo.7.5">} 
private: 
  std::array&lt;SoundParameters, 
    static_cast&lt;size_t&gt;(EntitySound::COUNT)&gt; m_params; 
  SoundID m_soundID; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">The only data we are storing here is an array of </span><code class="literal"><span class="koboSpan" id="kobo.9.1">SoundParameter</span></code><span class="koboSpan" id="kobo.10.1"> objects for each type of </span><code class="literal"><span class="koboSpan" id="kobo.11.1">EntitySound</span></code><span class="koboSpan" id="kobo.12.1"> enum, and a </span><code class="literal"><span class="koboSpan" id="kobo.13.1">SoundID</span></code><span class="koboSpan" id="kobo.14.1"> data member, which is going to be used in the sound system, in order to make sure only one entity sound is playing at the same time. </span><span class="koboSpan" id="kobo.14.2">The large method for de-serialization simply deals with correctly loading in the sound frames.</span></p><p><span class="koboSpan" id="kobo.15.1">Another, much more basic component type we need before we can proceed is a sound listener:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">class C_SoundListener : public C_Base{ 
public: 
  C_SoundListener() : C_Base(Component::SoundListener){} 
  void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</span></pre><p><span class="koboSpan" id="kobo.17.1">This, much like </span><code class="literal"><span class="koboSpan" id="kobo.18.1">C_Controller</span></code><span class="koboSpan" id="kobo.19.1">, is basically just a flag that lets the sound system know that the entity that has it should be treated as the listener. </span><span class="koboSpan" id="kobo.19.2">We need to be careful with this, since there should only ever be one sound listener present at a time.</span></p><div class="section" title="Sound system"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/><span class="koboSpan" id="kobo.20.1">Sound system</span></h2></div></div></div><p><span class="koboSpan" id="kobo.21.1">The system in charge of managing entity sounds uses the component signature bitmask in a way that allows multiple different compositions to be recognized:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">S_Sound::S_Sound(SystemManager* l_systemMgr) 
  : S_Base(System::Sound, l_systemMgr), 
  m_audioManager(nullptr), m_soundManager(nullptr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::SoundEmitter); 
  m_requiredComponents.push_back(req); 
  req.ClearBit((unsigned int)Component::SoundEmitter); 
  req.TurnOnBit((unsigned int)Component::SoundListener); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Direction_Changed, this); 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Frame_Change, this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">We want entities with a position component, as well as an emitter and/or listener component. </span><span class="koboSpan" id="kobo.23.2">The message of type </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Direction_Changed</span></code><span class="koboSpan" id="kobo.25.1"> is also subscribed to, as well as </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Frame_Change</span></code><span class="koboSpan" id="kobo.27.1">.</span></p><p><span class="koboSpan" id="kobo.28.1">Updating these components looks like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">void S_Sound::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for (auto &amp;entity : m_entities){ 
    auto c_pos = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto position = c_pos-&gt;GetPosition(); 
    auto elevation = c_pos-&gt;GetElevation(); 
 
    auto IsListener = entities-&gt; 
      HasComponent(entity, Component::SoundListener); 
    if (IsListener){ 
      sf::Listener::setPosition( 
        MakeSoundPosition(position, elevation)); 
    } 
 
    if (!entities-&gt;HasComponent(entity, Component::SoundEmitter)) 
    { continue; } 
    auto c_snd = entities-&gt; 
     GetComponent&lt;C_SoundEmitter&gt;(entity,Component::SoundEmitter); 
    if (c_snd-&gt;GetSoundID() == -1){ continue; } 
    if (!IsListener){ 
      if (!m_soundManager-&gt;SetPosition(c_snd-&gt;GetSoundID(), 
        MakeSoundPosition(position, elevation))) 
      { c_snd-&gt;SetSoundID(-1); } 
    } else { 
      if (!m_soundManager-&gt;IsPlaying(c_snd-&gt;GetSoundID())){ 
        c_snd-&gt;SetSoundID(-1); 
      } 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.30.1">The entity is checked for being a sound listener. </span><span class="koboSpan" id="kobo.30.2">If it is, the SFML's sound listener position is set to the position of the entity, with elevation included. </span><span class="koboSpan" id="kobo.30.3">We utilize a private helper method here, to construct a 3D vector, which will be covered shortly.</span></p><p><span class="koboSpan" id="kobo.31.1">If the entity has a sound emitter component, and its sound identifier isn't equal to </span><code class="literal"><span class="koboSpan" id="kobo.32.1">-1</span></code><span class="koboSpan" id="kobo.33.1">, which would indicate that no sounds are playing, the sound's position is attempted to be updated, provided the entity isn't a sound listener. </span><span class="koboSpan" id="kobo.33.2">If either the position update fails, or the sound is no longer playing, its identifier is set back to </span><code class="literal"><span class="koboSpan" id="kobo.34.1">-1</span></code><span class="koboSpan" id="kobo.35.1">.</span></p><p><span class="koboSpan" id="kobo.36.1">Next up is message handling:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">void S_Sound::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto IsListener = entities-&gt; 
    HasComponent(l_message.m_receiver, Component::SoundListener); 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch (m){ 
  case EntityMessage::Direction_Changed: 
  { 
    if (!IsListener){ return; } 
    Direction dir = static_cast&lt;Direction&gt;(l_message.m_int); 
    switch (dir){ 
    case Direction::Up: 
      sf::Listener::setDirection(0, 0, -1); break; 
    case Direction::Down: 
      sf::Listener::setDirection(0, 0, 1); break; 
    case Direction::Left: 
      sf::Listener::setDirection(-1, 0, 0); break; 
    case Direction::Right: 
      sf::Listener::setDirection(1, 0, 0); break; 
    } 
  } 
    break; 
  case EntityMessage::Frame_Change: 
    if (!entities-&gt; 
      HasComponent(l_message.m_receiver,Component::SoundEmitter)) 
    { return; } 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(l_message.m_receiver,Component::State) 
      -&gt;GetState(); 
    auto sound = EntitySound::None; 
    if(state ==EntityState::Walking){sound=EntitySound::Footstep;} 
    else if (state == EntityState::Attacking){ 
      sound = EntitySound::Attack; 
    } else if (state == EntityState::Hurt){ 
      sound = EntitySound::Hurt; 
    } else if (state == EntityState::Dying){ 
      sound = EntitySound::Death; 
    } 
    if (sound == EntitySound::None){ return; } 
    EmitSound(l_message.m_receiver, sound, false, 
      IsListener, l_message.m_int); 
    break; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.38.1">We should only care about the direction change message if our entity is a sound listener, in which case the global sound listener direction is simply updated to reflect the changes.</span></p><p><span class="koboSpan" id="kobo.39.1">If a frame is changed, we make sure the entity is a sound emitter first. </span><span class="koboSpan" id="kobo.39.2">If it is, its current state is matched to a sound type that would play. </span><span class="koboSpan" id="kobo.39.3">The private </span><code class="literal"><span class="koboSpan" id="kobo.40.1">EmitSound</span></code><span class="koboSpan" id="kobo.41.1"> method is then invoked:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void S_Sound::EmitSound(const EntityId&amp; l_entity, 
  const EntitySound&amp; l_sound, bool l_useId, bool l_relative, 
  int l_checkFrame) 
{ 
  if (!HasEntity(l_entity)){ return; } 
  if (!m_systemManager-&gt;GetEntityManager()-&gt; 
    HasComponent(l_entity, Component::SoundEmitter)) 
  { return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto c_snd = entities-&gt;GetComponent&lt;C_SoundEmitter&gt;( 
    l_entity, Component::SoundEmitter); 
  if (c_snd-&gt;GetSoundID() != -1 &amp;&amp; l_useId){ return; } 
  if (l_checkFrame != -1 &amp;&amp; 
    !c_snd-&gt;IsSoundFrame(l_sound, l_checkFrame)) 
  { return; } 
  auto c_pos = entities-&gt; 
    GetComponent&lt;C_Position&gt;(l_entity, Component::Position); 
  auto pos = (l_relative ? 
   </span><span class="koboSpan" id="kobo.42.2">sf::Vector3f(0.f, 0.f, 0.f) : 
   MakeSoundPosition(c_pos-&gt;GetPosition(),c_pos-&gt;GetElevation())); 
  if (l_useId){ 
    c_snd-&gt;SetSoundID(m_soundManager-&gt;Play( 
      c_snd-&gt;GetSound(l_sound), pos)); 
  } else { 
    m_soundManager-&gt;Play(c_snd-&gt;GetSound(l_sound), 
      pos, false, l_relative); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">After all the component and entity checks have passed, the sound emitter is checked for not emitting another sound already in case we want to use the existing ID. </span><span class="koboSpan" id="kobo.43.2">The sound frame is then checked, and the position for the sound is calculated based on whether the entity is a listener or not. </span><span class="koboSpan" id="kobo.43.3">Finally, based on whether we're using the sound ID or not, the sound manager's </span><code class="literal"><span class="koboSpan" id="kobo.44.1">Play</span></code><span class="koboSpan" id="kobo.45.1"> method is invoked, and its return sound ID is possibly stored.</span></p><p><span class="koboSpan" id="kobo.46.1">To conclude the sound topic within ECS, as well as the entire ECS portion of this chapter, let's look at how we construct a 3D sound position based on the entity's </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">x</span></em></span><span class="koboSpan" id="kobo.48.1"> and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">y</span></em></span><span class="koboSpan" id="kobo.50.1"> positions, as well as its elevation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">sf::Vector3f S_Sound::MakeSoundPosition( 
  const sf::Vector2f&amp; l_entityPos, unsigned int l_elevation) 
{ 
  return sf::Vector3f( 
    l_entityPos.x, 
    static_cast&lt;float&gt;(l_elevation * Sheet::Tile_Size), 
    l_entityPos.y 
  ); 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">The </span><code class="literal"><span class="koboSpan" id="kobo.53.1">z</span></code><span class="koboSpan" id="kobo.54.1"> member of </span><code class="literal"><span class="koboSpan" id="kobo.55.1">sf::Vector3f</span></code><span class="koboSpan" id="kobo.56.1"> is used to store the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.57.1">height</span></em></span><span class="koboSpan" id="kobo.58.1">, which is simply the elevation multiplied by the tile size.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Implementing the menu state"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/><span class="koboSpan" id="kobo.1.1">Implementing the menu state</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With most of the backend already covered, we're ready to move towards the front, and start working on more interactive aspects of the project, such as interfaces. </span><span class="koboSpan" id="kobo.2.2">Let's start by creating a main menu:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">void State_MainMenu::OnCreate(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  GUI_Manager* gui = context-&gt;m_guiManager; 
  gui-&gt;LoadInterface("MainMenu.interface", "MainMenu"); 
  gui-&gt;GetInterface("MainMenu")-&gt;SetPosition( 
    sf::Vector2f(250.f, 168.f)); 
  EventManager* eMgr = context-&gt;m_eventManager; 
  eMgr-&gt;AddCallback("MainMenu_Play", &amp;State_MainMenu::Play, this); 
  eMgr-&gt;AddCallback("MainMenu_Quit", &amp;State_MainMenu::Quit, this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.4.1">All of these classes have already been covered in </span><a class="ulink" href="http://Chapter 1"><span class="koboSpan" id="kobo.5.1">Chapter 1</span></a><span class="koboSpan" id="kobo.6.1">
, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Under the Hood - Setting up the Backend</span></em></span><span class="koboSpan" id="kobo.8.1">, but let us have a quick rundown of what this does once more. </span><span class="koboSpan" id="kobo.8.2">After we obtain the shared context, a main menu interface is loaded and positioned on screen. </span><span class="koboSpan" id="kobo.8.3">The </span><code class="literal"><span class="koboSpan" id="kobo.9.1">m_eventManager</span></code><span class="koboSpan" id="kobo.10.1"> is then used to bind the main menu button clicks to methods of this class.</span></p><p><span class="koboSpan" id="kobo.11.1">These resources/bindings obviously have to be removed when the state is destroyed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">void State_MainMenu::OnDestroy(){ 
  m_stateMgr-&gt;GetContext()-&gt;m_guiManager-&gt; 
    RemoveInterface(StateType::Game, "MainMenu"); 
  EventManager* eMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Play"); 
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Quit"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">Upon activation of the main menu state, we are going to want to check if a game state has already been added:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">void State_MainMenu::Activate(){ 
  auto&amp; play = *m_stateMgr-&gt;GetContext()-&gt;m_guiManager-&gt; 
    GetInterface("MainMenu")-&gt;GetElement("Play"); 
  if (m_stateMgr-&gt;HasState(StateType::Game)){ 
    // Resume 
    play.SetText("Resume"); 
  } else { 
    // Play 
    play.SetText("Play"); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">This ensures that the first button in the menu accurately reflects the existence/lack of a game state.</span></p><p><span class="koboSpan" id="kobo.16.1">Finally, here are the callbacks of the main menu buttons:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">void State_MainMenu::Play(EventDetails* l_details){ 
  m_stateMgr-&gt;SwitchTo(StateType::Game); 
} 
void State_MainMenu::Quit(EventDetails* l_details){ 
  m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;Close(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.18.1">In case of the play button being clicked, we switch to a game state, whether or not it exists yet. </span><span class="koboSpan" id="kobo.18.2">The quit button, on the other hand, would reach the window class and close it.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Implementing the game state"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/><span class="koboSpan" id="kobo.1.1">Implementing the game state</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Now it's getting more interesting. </span><span class="koboSpan" id="kobo.2.2">The game state is where all of the fun happens, so we need to make sure it's set up properly. </span><span class="koboSpan" id="kobo.2.3">Let us start, as per usual, with the creation of the state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">void State_Game::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
 
  evMgr-&gt;AddCallback("Key_Escape", &amp;State_Game::MainMenu, this); 
  evMgr-&gt;AddCallback("Player_MoveLeft", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveRight", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveUp", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveDown", 
    &amp;State_Game::PlayerMove, this); 
 
  sf::Vector2u size = context-&gt;m_wind-&gt;GetWindowSize(); 
  m_view.setSize(static_cast&lt;float&gt;(size.x), 
    static_cast&lt;float&gt;(size.y)); 
  m_view.setCenter(static_cast&lt;float&gt;(size.x) / 2, 
    static_cast&lt;float&gt;(size.y) / 2); 
  m_view.zoom(0.6f); 
</span></pre><pre class="programlisting"><span class="koboSpan" id="kobo.4.1">  auto loading = m_stateMgr-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  context-&gt;m_gameMap-&gt;AddFile( 
    Utils::GetWorkingDirectory() + "media/Maps/map1.map"); 
  loading-&gt;AddLoader(context-&gt;m_gameMap); 
  loading-&gt;SetManualContinue(true); 
  context-&gt;m_soundManager-&gt;PlayMusic("TownTheme", 50.f, true); 
} 
</span></pre><p><span class="koboSpan" id="kobo.5.1">First, all of the relevant events we're interested in are bound to methods of this class. </span><span class="koboSpan" id="kobo.5.2">This includes the escape key, which simply switches back to the menu state, and four player movement keys. </span><span class="koboSpan" id="kobo.5.3">The view of this state is then set up to be zoomed in slightly more, just to be able to see the character better.</span></p><p><span class="koboSpan" id="kobo.6.1">The last couple of lines obtain the loading state, and add the game map and the tile set to it as loaders right after the map and tile set files to be loaded are added.</span></p><p><span class="koboSpan" id="kobo.7.1">Naturally, these callbacks are going to need to be unbound upon the destruction of the state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">void State_Game::OnDestroy(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::Game, "Key_Escape"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Key_O"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveLeft"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveRight"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveUp"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveDown"); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;GetTileSet()-&gt;Purge(); 
} 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note5"/><span class="koboSpan" id="kobo.9.1">Note</span></h3><p><span class="koboSpan" id="kobo.10.1">Note that both the game map and the tile set are both purged here as well.</span></p></div></div><p><span class="koboSpan" id="kobo.11.1">Updating the game state only comes down to updating its own camera, alongside the game map and the ECS system manager:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">void State_Game::Update(const sf::Time&amp; l_time){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  UpdateCamera(); 
  context-&gt;m_gameMap-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_systemManager-&gt;Update(l_time.asSeconds()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.13.1">The camera (or the view) of the state is updated like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">void State_Game::UpdateCamera(){ 
  if (m_player == -1){ return; } 
  SharedContext* context = m_stateMgr-&gt;GetContext(); 
  auto pos = m_stateMgr-&gt;GetContext()-&gt;m_entityManager-&gt; 
    GetComponent&lt;C_Position&gt;(m_player, Component::Position); 
 
  m_view.setCenter(pos-&gt;GetPosition()); 
  context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
 
  sf::FloatRect viewSpace = context-&gt;m_wind-&gt;GetViewSpace(); 
  if (viewSpace.left &lt;= 0){ 
    m_view.setCenter(viewSpace.width / 2, m_view.getCenter().y); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } else if (viewSpace.left + viewSpace.width &gt; 
    (context-&gt;m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size) 
  { 
    m_view.setCenter( 
      ((context-&gt;m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size) - 
        (viewSpace.width / 2), 
      m_view.getCenter().y); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } 
 
  if (viewSpace.top &lt;= 0){ 
    m_view.setCenter(m_view.getCenter().x, viewSpace.height / 2); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } else if (viewSpace.top + viewSpace.height &gt; 
    (context-&gt;m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size) 
  { 
    m_view.setCenter( 
      m_view.getCenter().x, 
      ((context-&gt;m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size) - 
        (viewSpace.height / 2)); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">This can look like a lot, but the basic gist of it is first obtaining the position of our player, and then using those coordinates to either centre the view on, or position it in such a way that the very edge of the map is at the edge of the view. </span><span class="koboSpan" id="kobo.15.2">The idea is not moving the state view beyond the borders of the map.</span></p><p><span class="koboSpan" id="kobo.16.1">Drawing is also fairly straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">void State_Game::Draw(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  for (unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i){ 
    context-&gt;m_gameMap-&gt;Draw(i); 
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;Draw( 
      m_stateMgr-&gt;GetContext()-&gt;m_wind, i); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.18.1">A loop is started for each layer/elevation the game map supports. </span><span class="koboSpan" id="kobo.18.2">The map data of that layer is drawn first, and is followed by the system manager drawing entities on that layer.</span></p><p><span class="koboSpan" id="kobo.19.1">Let us take a look at the callback method for our player movement:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">void State_Game::PlayerMove(EventDetails* l_details){ 
  Message msg((MessageType)EntityMessage::Move); 
  if (l_details-&gt;m_name == "Player_MoveLeft"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Left); 
  } else if (l_details-&gt;m_name == "Player_MoveRight"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Right); 
  } else if (l_details-&gt;m_name == "Player_MoveUp"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Up); 
  } else if (l_details-&gt;m_name == "Player_MoveDown"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Down); 
  } 
  msg.m_receiver = m_player; 
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt; 
    GetMessageHandler()-&gt;Dispatch(msg); 
} 
</span></pre><p><span class="koboSpan" id="kobo.21.1">Whenever this is invoked, a new </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Move</span></code><span class="koboSpan" id="kobo.23.1"> message is constructed. </span><span class="koboSpan" id="kobo.23.2">The direction it carries is set, based on the actual event name. </span><span class="koboSpan" id="kobo.23.3">After the receiving entity (the player) is stored, the message is dispatched.</span></p><p><span class="koboSpan" id="kobo.24.1">Lastly, we have one callback and the state's activation method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">void State_Game::MainMenu(EventDetails* l_details){ 
  m_stateMgr-&gt;SwitchTo(StateType::MainMenu); 
} 
 
void State_Game::Activate() { 
  auto map = m_stateMgr-&gt;GetContext()-&gt;m_gameMap; 
 
  m_player = map-&gt;GetPlayerId(); 
  map-&gt;Redraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">If the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">Esc</span></em></span><span class="koboSpan" id="kobo.28.1"> key is pressed, we simply switch to the main menu state. </span><span class="koboSpan" id="kobo.28.2">If the state is then switched back to </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Game</span></code><span class="koboSpan" id="kobo.30.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Activate</span></code><span class="koboSpan" id="kobo.32.1"> method of it is invoked. </span><span class="koboSpan" id="kobo.32.2">We use that functionality to re-obtain the player ID, in case it changed.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The main game class"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/><span class="koboSpan" id="kobo.1.1">The main game class</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">All we have left to do now is to put everything together. </span><span class="koboSpan" id="kobo.2.2">We're going to be using a </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Game</span></code><span class="koboSpan" id="kobo.4.1"> class for that, so let's take a look at it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.5.1">class Game{ 
public: 
  Game(); 
  ~Game(); 
  void Update(); 
  void Render(); 
  void LateUpdate(); 
  sf::Time GetElapsed(); 
  Window* GetWindow(); 
private: 
  void SetUpClasses(); 
  void SetUpECS(); 
  void SetUpStates(); 
  void RestartClock(); 
  sf::Clock m_clock; 
  sf::Time m_elapsed; 
  SharedContext m_context; 
  RandomGenerator m_rand; 
  Window m_window; 
  TextureManager m_textureManager; 
  FontManager m_fontManager; 
  AudioManager m_audioManager; 
  SoundManager m_soundManager; 
  GUI_Manager m_guiManager; 
  SystemManager m_systemManager; 
  EntityManager m_entityManager; 
  Map m_gameMap; 
  std::unique_ptr&lt;StateManager&gt; m_stateManager; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.6.1">This class holds all of the classes that we covered, so let us begin setting them up in the constructor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">Game::Game() 
  : m_window("Chapter 2", sf::Vector2u(800, 600), false), 
  m_entityManager(&amp;m_systemManager, &amp;m_textureManager), 
  m_guiManager(m_window.GetEventManager(), &amp;m_context), 
  m_soundManager(&amp;m_audioManager), 
  m_gameMap(&amp;m_window, &amp;m_entityManager, &amp;m_textureManager) 
{ 
  SetUpClasses(); 
  SetUpECS(); 
  SetUpStates(); 
 
  m_fontManager.RequireResource("Main"); 
  m_stateManager-&gt;SwitchTo(StateType::Intro); 
} 
 
Game::~Game(){ m_fontManager.ReleaseResource("Main"); } 
</span></pre><p><span class="koboSpan" id="kobo.8.1">The initializer list is used to set up whatever dependencies our classes have that need to be satisfied inside their constructors. </span><span class="koboSpan" id="kobo.8.2">The rest of the constructor body is used to invoke three private </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">setup</span></em></span><span class="koboSpan" id="kobo.10.1"> methods, as well as to require the main font that is to be used throughout the game, and switch to the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Intro</span></code><span class="koboSpan" id="kobo.12.1"> state.</span></p><p><span class="koboSpan" id="kobo.13.1">We're going to need a couple of basic setters and getters from this class as well:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">sf::Time Game::GetElapsed(){ return m_clock.getElapsedTime(); } 
void Game::RestartClock(){ m_elapsed = m_clock.restart(); } 
Window* Game::GetWindow(){ return &amp;m_window; } 
</span></pre><p><span class="koboSpan" id="kobo.15.1">With that out of the way, let us actually update all of our code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">void Game::Update(){ 
  m_window.Update(); 
  m_stateManager-&gt;Update(m_elapsed); 
  m_guiManager.Update(m_elapsed.asSeconds()); 
  m_soundManager.Update(m_elapsed.asSeconds()); 
 
  GUI_Event guiEvent; 
  while (m_context.m_guiManager-&gt;PollEvent(guiEvent)){ 
    m_window.GetEventManager()-&gt;HandleEvent(guiEvent); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.17.1">After the relevant managers are updated, the GUI events are polled and passed to the event manager to be handled.</span></p><p><span class="koboSpan" id="kobo.18.1">Next, let us take a look at what needs to happen during the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">Render</span></code><span class="koboSpan" id="kobo.20.1"> call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.21.1">void Game::Render(){ 
  m_window.BeginDraw(); 
  // Render here. 
  </span><span class="koboSpan" id="kobo.21.2">m_stateManager-&gt;Draw(); 
  m_guiManager.Render(m_window.GetRenderWindow()); 
  m_window.EndDraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.22.1">This is fairly basic as well. </span><span class="koboSpan" id="kobo.22.2">Since we're going to always want to draw states, the state manager's </span><code class="literal"><span class="koboSpan" id="kobo.23.1">Draw</span></code><span class="koboSpan" id="kobo.24.1"> call is placed here. </span><span class="koboSpan" id="kobo.24.2">On top of that (quite literally), we're going to always draw the GUIs.</span></p><p><span class="koboSpan" id="kobo.25.1">A nice little feature to have is a late update that can be used to process anything that can't go into regular updates:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">void Game::LateUpdate(){ 
  m_stateManager-&gt;ProcessRequests(); 
  RestartClock(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">The state manager's removal requests are processed here, in addition to the game clock being restarted.</span></p><p><span class="koboSpan" id="kobo.28.1">One of the three private methods invoked in the constructor that helps us set up all the classes can be implemented like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">void Game::SetUpClasses() { 
  m_clock.restart(); 
  m_context.m_rand = &amp;m_rand; 
  srand(static_cast&lt;unsigned int&gt;(time(nullptr))); 
  m_systemManager.SetEntityManager(&amp;m_entityManager); 
 
  m_context.m_wind = &amp;m_window; 
  m_context.m_eventManager = m_window.GetEventManager(); 
  m_context.m_textureManager = &amp;m_textureManager; 
  m_context.m_fontManager = &amp;m_fontManager; 
  m_context.m_audioManager = &amp;m_audioManager; 
  m_context.m_soundManager = &amp;m_soundManager; 
  m_context.m_gameMap = &amp;m_gameMap; 
  m_context.m_systemManager = &amp;m_systemManager; 
  m_context.m_entityManager = &amp;m_entityManager; 
  m_context.m_guiManager = &amp;m_guiManager; 
 
  m_stateManager = std::make_unique&lt;StateManager&gt;(&amp;m_context); 
  m_gameMap.SetStateManager(m_stateManager.get()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.30.1">After the random number generator is seeded, we need to make sure to bind every single class to the shared context, in order to be able to access them anywhere a service locator pattern is relied upon.</span></p><p><span class="koboSpan" id="kobo.31.1">Another set up function we invoked deals with setting up the entity component system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">void Game::SetUpECS() { 
  m_entityManager.AddComponentType&lt;C_Position&gt;( 
    Component::Position); 
  m_entityManager.AddComponentType&lt;C_SpriteSheet&gt;( 
    Component::SpriteSheet); 
  m_entityManager.AddComponentType&lt;C_State&gt;(Component::State); 
  m_entityManager.AddComponentType&lt;C_Movable&gt;(Component::Movable); 
  m_entityManager.AddComponentType&lt;C_Controller&gt;( 
    Component::Controller); 
  m_entityManager.AddComponentType&lt;C_Collidable&gt;( 
    Component::Collidable); 
  m_entityManager.AddComponentType&lt;C_SoundEmitter&gt;( 
    Component::SoundEmitter); 
  m_entityManager.AddComponentType&lt;C_SoundListener&gt;( 
    Component::SoundListener); 
 
  m_systemManager.AddSystem&lt;S_State&gt;(System::State); 
  m_systemManager.AddSystem&lt;S_Control&gt;(System::Control); 
  m_systemManager.AddSystem&lt;S_Movement&gt;(System::Movement); 
  m_systemManager.AddSystem&lt;S_Collision&gt;(System::Collision); 
  m_systemManager.AddSystem&lt;S_SheetAnimation&gt;( 
    System::SheetAnimation); 
  m_systemManager.AddSystem&lt;S_Sound&gt;(System::Sound); 
  m_systemManager.AddSystem&lt;S_Renderer&gt;(System::Renderer); 
 
  m_systemManager.GetSystem&lt;S_Collision&gt;(System::Collision)-&gt; 
    SetMap(&amp;m_gameMap); 
  m_systemManager.GetSystem&lt;S_Movement&gt;(System::Movement)-&gt; 
    SetMap(&amp;m_gameMap); 
  m_systemManager.GetSystem&lt;S_Sound&gt;(System::Sound)-&gt; 
    SetUp(&amp;m_audioManager, &amp;m_soundManager); 
} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">Here, all of the component types and systems are added and set up for use. </span><span class="koboSpan" id="kobo.33.2">The collision and movement systems need to have access to the game map, while the sound system relies on the audio and sound managers.</span></p><p><span class="koboSpan" id="kobo.34.1">The last bit of setup is related to states and their dependents:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">void Game::SetUpStates() { 
  m_stateManager-&gt;AddDependent(m_context.m_eventManager); 
  m_stateManager-&gt;AddDependent(&amp;m_guiManager); 
  m_stateManager-&gt;AddDependent(&amp;m_soundManager); 
  m_stateManager-&gt;RegisterState&lt;State_Intro&gt;(StateType::Intro); 
  m_stateManager-&gt;RegisterState&lt;State_MainMenu&gt;( 
    StateType::MainMenu); 
  m_stateManager-&gt;RegisterState&lt;State_Game&gt;(StateType::Game); 
} 
</span></pre><p><span class="koboSpan" id="kobo.36.1">The event, GUI, and sound managers all rely on being kept up to date on all state changes, so they must be registered as dependents. </span><span class="koboSpan" id="kobo.36.2">Also, our three main state types that we will be using are registered as well, so that they can be created using the factory method inside the state manager.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The final bit of code"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/><span class="koboSpan" id="kobo.1.1">The final bit of code</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Lastly, the main entry point of our application is defined inside the main function, like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">void main(int argc, void** argv[]){ 
  // Program entry point. 
  </span><span class="koboSpan" id="kobo.3.2">{ 
    Game game; 
    while(!game.GetWindow()-&gt;IsDone()){ 
      game.Update(); 
      game.Render(); 
      game.LateUpdate(); 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.4.1">After an instance of </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Game</span></code><span class="koboSpan" id="kobo.6.1"> is set up, we begin a </span><code class="literal"><span class="koboSpan" id="kobo.7.1">while</span></code><span class="koboSpan" id="kobo.8.1"> loop that keeps running until the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Window</span></code><span class="koboSpan" id="kobo.10.1"> instance is closed. </span><span class="koboSpan" id="kobo.10.2">Inside the loop, we update the game, render it, and call the late update method as well, for all of those post-rendering tasks.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">With that, it's a good time to wrap up. </span><span class="koboSpan" id="kobo.2.2">If you have followed through to the end, congratulations! </span><span class="koboSpan" id="kobo.2.3">You have just built a basic, fully functioning game out of nothing but a couple of states, some components, and systems. </span><span class="koboSpan" id="kobo.2.4">This chapter, much like the one before, is quite condensed, so feel free to look through the code and feel comfortable with its structure.</span></p><p><span class="koboSpan" id="kobo.3.1">In the next chapter, we're going to be focusing solely on implementing and using particle systems in order to really add some life to the bare-bones game we have made. </span><span class="koboSpan" id="kobo.3.2">See you there!</span></p></div></div></div></body></html>