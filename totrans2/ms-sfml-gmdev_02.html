<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2.  Its Game Time! - Designing the Project </h1></div></div></div><p>In the previous chapter, we covered the essential parts of our pre-established code base that is going to be used while creating a game. The time has come to take what we have learned and build upon it, by focusing on project-specific code that will be unique to the game we are making.</p><p>In this chapter, we are going to be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing key entity components and systems for minimal gameplay</li><li class="listitem" style="list-style-type: disc">Creating a couple of states for navigating the game</li><li class="listitem" style="list-style-type: disc">Arranging all of our code into a cohesive, working project</li></ul></div><p>We have a whole game to design, so let us get to it!</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Use of copyrighted resources</h1></div></div></div><p>In this chapter, and for the entire length of this book, we are going to be using these resources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Mage City Arcanos</em> by <em>Hyptosis</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="http://opengameart.org/content/mage-city-arcanos">http://opengameart.org/content/mage-city-arcanos</a></li><li class="listitem" style="list-style-type: disc"><em>[LPC] Leaf Recolor</em> by <em>William. Thompsonj</em> under the <strong>CC-BY-SA 3.0</strong> and <strong>GPL 3.0</strong> licenses: <a class="ulink" href="http://opengameart.org/content/lpc-leaf-recolor">http://opengameart.org/content/lpc-leaf-recolor</a></li><li class="listitem" style="list-style-type: disc"><em>[LPC] Medieval fantasy character sprites</em> by <em>Wulax</em> under <strong>CC-BY-SA 3.0</strong> and <strong>GPL 3.0</strong> licenses: <a class="ulink" href="http://opengameart.org/content/lpc-medieval-fantasy-character-sprites">http://opengameart.org/content/lpc-medieval-fantasy-character-sprites</a></li><li class="listitem" style="list-style-type: disc"><em>Fantasy UI Elements</em> by <em>Ravenmore</em> at <a class="ulink" href="http://dycha.net/">http://dycha.net/</a> under the <strong>CC-BY 3.0</strong> license: <a class="ulink" href="http://opengameart.org/content/fantasy-ui-elements-by-ravenmore">http://opengameart.org/content/fantasy-ui-elements-by-ravenmore</a></li><li class="listitem" style="list-style-type: disc"><em>Vegur font</em> by <em>Arro</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="http://www.fontspace.com/arro/vegur">http://www.fontspace.com/arro/vegur</a></li><li class="listitem" style="list-style-type: disc"><em>Fantozzi's Footsteps (Grass/Sand &amp; Stone)</em> by <em>Fantozzi</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="http://opengameart.org/content/fantozzis-footsteps-grasssand-stone">http://opengameart.org/content/fantozzis-footsteps-grasssand-stone</a></li><li class="listitem" style="list-style-type: disc"><em>Electrix</em> (NES Version) by <em>Snabisch</em> under the <strong>CC-BY 3.0</strong> license: <a class="ulink" href="http://opengameart.org/content/electrix-nes-version">http://opengameart.org/content/electrix-nes-version</a></li><li class="listitem" style="list-style-type: disc"><em>Town Theme RPG</em> by <em>cynicmusic</em> under the <strong>CC-BY 3.0</strong> license: <a class="ulink" href="http://opengameart.org/content/town-theme-rpg">http://opengameart.org/content/town-theme-rpg</a></li></ul></div><p>Information about all of the licenses that apply to these resources can be found here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.gnu.org/licenses/gpl-3.0.html">http://www.gnu.org/licenses/gpl-3.0.html</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Entity placement and rendering</h1></div></div></div><p>Let us start with the basics. Most (if not all) entities in any game we build are going to be positioned within the world. Let us ignore the corner cases of special types of entities for now. In order to represent the entity position, we are going to be creating a position component like so:</p><pre class="programlisting">class C_Position : public C_Base{ 
public: 
  C_Position(): C_Base(Component::Position), m_elevation(0){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    l_stream &gt;&gt; m_position.x &gt;&gt; m_position.y &gt;&gt; m_elevation; 
  } 
 
  sf::Vector2f GetPosition() const { ... } 
  sf::Vector2f GetOldPosition() const { ... } 
  unsigned int GetElevation() const { ... } 
  void SetPosition(float l_x, float l_y){ ... } 
  void SetPosition(const sf::Vector2f&amp; l_vec){ ... } 
  void SetElevation(unsigned int l_elevation){ ... } 
  void MoveBy(float l_x, float l_y){ ... } 
  void MoveBy(const sf::Vector2f&amp; l_vec){ ... } 
private: 
  sf::Vector2f m_position; 
  sf::Vector2f m_positionOld; 
  unsigned int m_elevation; 
}; 
</pre><p>Only two things are worthy of noting here. First, the component type has to be set up through the <code class="literal">C_Base</code> constructor. That can be changed in the future if we are going to be re-designing this system, but for now this is the way to do it. We must also implement the <code class="literal">ReadIn</code> method, in order to be able to de-serialize component data properly. This means that every time an entity file is being loaded and the position data is encountered, it is going to read in the <em>x</em> coordinate, the <em>y</em> coordinate, and the elevation in this exact order.</p><p>The component itself only holds the data that is relevant to its cause. Two different data members for entity position are being stored here: the current position <code class="literal">m_position</code>, and the position of the entity one game tick ago, <code class="literal">m_positionOld</code>. That can be useful, should any system need to rely on position changes between updates.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>The drawable side of things</h2></div></div></div><p>The visual side of things is not that different to represent within the ECS paradigm. Because we may be dealing with more than one type of renderable objects, it helps out to have an interface that they all have to honor and implement:</p><pre class="programlisting">class C_Drawable : public C_Base{ 
public: 
  C_Drawable(const Component&amp; l_type) : C_Base(l_type){} 
  virtual ~C_Drawable(){} 
 
  virtual void UpdatePosition(const sf::Vector2f&amp; l_vec) = 0; 
  virtual sf::Vector2u GetSize() const = 0; 
  virtual void Draw(sf::RenderWindow* l_wind) = 0; 
}; 
</pre><p>Depending on the type and implementation of drawable components, they may rely on different ways of representing their position, size, and the particular method of being drawn. All three of these aspects need to be defined when a new drawable type is created, much like this:</p><pre class="programlisting">class C_SpriteSheet : public C_Drawable{ 
public: 
  C_SpriteSheet(): C_Drawable(Component::SpriteSheet), 
    m_spriteSheet(nullptr){} 
 
  void ReadIn(std::stringstream&amp; l_stream){l_stream&gt;&gt;m_sheetName;} 
  void Create(TextureManager* l_textureMgr, 
    const std::string&amp; l_name = "") 
  { 
    if (m_spriteSheet) { m_spriteSheet.release(); } 
    m_spriteSheet = std::make_unique&lt;SpriteSheet&gt;(l_textureMgr); 
    m_spriteSheet-&gt;LoadSheet("media/Spritesheets/" + 
      (!l_name.empty() ? l_name : m_sheetName) + ".sheet"); 
  } 
 
  SpriteSheet* GetSpriteSheet(){ ... } 
  void UpdatePosition(const sf::Vector2f&amp; l_vec){ ... } 
  sf::Vector2u GetSize() const { ... } 
  void Draw(sf::RenderWindow* l_wind){ ... } 
private: 
  std::unique_ptr&lt;SpriteSheet&gt; m_spriteSheet; 
  std::string m_sheetName; 
}; 
</pre><p>A sprite-sheet component utilizes one of the classes we have covered back in <a class="link" href="ch01.html" title="Chapter 1. Under the Hood - Setting up the Backend">Chapter 1</a>
, <em>Under the Hood - Setting up the Backend</em>. De-serialization for this component is quite simple. All it requires is the name of the sheet file, which contains all size, padding, space, and animation information. Because this class relies on the texture manager for loading its assets, a special <code class="literal">Create()</code> method is used in order to set up this relationship post-loading.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Rendering system</h2></div></div></div><p>With the data aspect all taken care of and out of the way, we can now focus on actually drawing entities on screen. This is where the very first type of system comes in:</p><pre class="programlisting">S_Renderer::S_Renderer(SystemManager* l_systemMgr) 
  :S_Base(System::Renderer, l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::SpriteSheet); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_drawableTypes.TurnOnBit((unsigned int)Component::SpriteSheet); 
  // Other types... 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Direction_Changed,this); 
} 
</pre><p>The renderer system operates on two different types of component for now: position and sprite sheet. Given a wider variety of drawable component types, it would, of course, need to include them as well. This is precisely why a bitmask data member with the name <code class="literal">m_drawableTypes</code> is kept around. It keeps track of all possible drawable component types, and will be used later to fetch actual component data. All of those types should be registered here.</p><p>This system also needs to be notified when an entity changes its direction, in order to enforce those changes on a given sprite sheet.</p><p>All of the components a system uses usually need to be updated like so:</p><pre class="programlisting">void S_Renderer::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities) 
  { 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    C_Drawable* drawable = GetDrawableFromType(entity); 
    if (!drawable) { continue; } 
    drawable-&gt;UpdatePosition(position-&gt;GetPosition()); 
  } 
} 
</pre><p>It's pretty straightforward. Any and all drawable components need to have their positions updated in order for the simulation to be accurate. We use a private method to obtain a pointer to whatever drawable type the current entity has, check if it's not <code class="literal">nullptr</code>, and then update its position.</p><p>Event handling is also utilized in this system in order to achieve a <em>depth</em> effect by sorting entities:</p><pre class="programlisting">void S_Renderer::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event) 
{ 
  if (l_event == EntityEvent::Moving_Left || 
    l_event == EntityEvent::Moving_Right || 
    l_event == EntityEvent::Moving_Up || 
    l_event == EntityEvent::Moving_Down || 
    l_event == EntityEvent::Elevation_Change || 
    l_event == EntityEvent::Spawned) 
  { 
    SortDrawables(); 
  } 
} 
</pre><p>All we have to do here is invoke another private method that's going to sort all entities this system has along the <em>y</em> axis. This only needs to happen if an entity is moving, changing elevations, or has just spawned.</p><p>As far as entity messages go, we're only interested in one single type, as should be evident from the constructor of <code class="literal">S_Renderer</code>:</p><pre class="programlisting">void S_Renderer::Notify(const Message&amp; l_message){ 
  if(HasEntity(l_message.m_receiver)){ 
    EntityMessage m=static_cast&lt;EntityMessage&gt;(l_message.m_type); 
    switch(m){ 
    case EntityMessage::Direction_Changed:  
      SetSheetDirection(l_message.m_receiver, 
        (Direction)l_message.m_int); 
      break; 
    } 
  } 
} 
</pre><p>Another private method comes to the rescue. It will be covered shortly, but the basic gist of it is that sprite sheets need to be informed of any direction changes, in order to reflect them visually.</p><p>Since the whole point of this system is rendering our entities on screen, let's do just that:</p><pre class="programlisting">void S_Renderer::Render(Window* l_wind, unsigned int l_layer) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    if(position-&gt;GetElevation() &lt; l_layer){ continue; } 
    if(position-&gt;GetElevation() &gt; l_layer){ break; } 
    C_Drawable* drawable = GetDrawableFromType(entity); 
    if (!drawable) { continue; } 
    sf::FloatRect drawableBounds; 
    drawableBounds.left = position-&gt;GetPosition().x - 
      (drawable-&gt;GetSize().x / 2); 
    drawableBounds.top = position-&gt;GetPosition().y - 
      drawable-&gt;GetSize().y; 
    drawableBounds.width = 
      static_cast&lt;float&gt;(drawable-&gt;GetSize().x); 
    drawableBounds.height = 
      static_cast&lt;float&gt;(drawable-&gt;GetSize().y); 
    if (!l_wind-&gt;GetViewSpace().intersects(drawableBounds)){ 
      continue; 
    } 
    drawable-&gt;Draw(l_wind-&gt;GetRenderWindow()); 
  } 
} 
</pre><p>Once again, it's fairly simple. The actual rendering is layer-based, so an argument is taken in for the specific layer we're currently drawing. The position component is obtained first in order to check if the entity's elevation matches the current layer being rendered. Because the game entities are always kept sorted, we know it's okay to break out of the loop if any given entity's elevation goes beyond the layer we're working with.</p><p>Finally, the drawable component of the entity is obtained, as well as checked for being outside the screen area, in order to minimize unnecessary drawing.</p><p>All we have left now are the private helper methods, starting with <code class="literal">SetSheetDirection</code>:</p><pre class="programlisting">void S_Renderer::SetSheetDirection(const EntityId&amp; l_entity, 
  const Direction&amp; l_dir) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  if (!entities-&gt;HasComponent(l_entity, Component::SpriteSheet)) 
  { return; } 
  auto sheet = entities-&gt; 
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet); 
  sheet-&gt;GetSpriteSheet()-&gt;SetDirection(l_dir); 
} 
</pre><p>There's nothing we haven't seen before. The entity is checked for having a sprite-sheet component, which then gets obtained and informed of direction changes.</p><p>This system heavily relies on entities being sorted, based on their <em>y</em> coordinate and elevation. For that, we use this bit of code:</p><pre class="programlisting">void S_Renderer::SortDrawables(){ 
  EntityManager* e_mgr = m_systemManager-&gt;GetEntityManager(); 
  std::sort(m_entities.begin(), m_entities.end(), 
    [e_mgr](unsigned int l_1, unsigned int l_2) 
  { 
    auto pos1 = e_mgr-&gt; 
      GetComponent&lt;C_Position&gt;(l_1, Component::Position); 
    auto pos2 = e_mgr-&gt; 
      GetComponent&lt;C_Position&gt;(l_2, Component::Position); 
    if (pos1-&gt;GetElevation() == pos2-&gt;GetElevation()){ 
      return pos1-&gt;GetPosition().y &lt; pos2-&gt;GetPosition().y; 
    } 
    return pos1-&gt;GetElevation() &lt; pos2-&gt;GetElevation(); 
  }); 
} 
</pre><p>Because entity identifiers are stored inside an STL container, <code class="literal">std::sort</code> comes to the rescue. The actual sorting gives priority to elevation; however, if two entities share that in common, they're sorted according to the <em>y</em> coordinate, going from smallest to largest.</p><p>To wrap this up, here's a method that's going to save us some typing, should additional drawable component types be added in the future:</p><pre class="programlisting">C_Drawable* S_Renderer::GetDrawableFromType( 
  const EntityId&amp; l_entity) 
{ 
  auto entities = m_systemManager-&gt;GetEntityManager(); 
  for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(Component::COUNT); 
    ++i) 
  { 
    if (!m_drawableTypes.GetBit(i)) { continue; } 
    auto component = static_cast&lt;Component&gt;(i); 
    if (!entities-&gt;HasComponent(l_entity, component)){ continue; } 
    return entities-&gt;GetComponent&lt;C_Drawable&gt;(l_entity,component); 
  } 
  return nullptr; 
} 
</pre><p>All it does is simply iterate through all component types, looking for one that matches drawable types registered in the constructor of this system. Once one is found, the entity is checked for having that component. If it does, a pointer to it gets returned.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Entity kinematics</h1></div></div></div><p>The code we have written so far would only produce a static, unmoving scene. Since that isn't very exciting, let's work on adding potential for entity movement. Since it calls for more data being stored, we need another component type to work with:</p><pre class="programlisting">class C_Movable : public C_Base{ 
public: 
  C_Movable() : C_Base(Component::Movable), 
    m_velocityMax(0.f), m_direction((Direction)0){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    l_stream &gt;&gt; m_velocityMax &gt;&gt; m_speed.x &gt;&gt; m_speed.y; 
    unsigned int dir = 0; 
    l_stream &gt;&gt; dir; 
    m_direction = static_cast&lt;Direction&gt;(dir); 
  } 
  ... 
  void SetVelocity(const sf::Vector2f&amp; l_vec){ ... } 
  void SetMaxVelocity(float l_vel){ ... } 
  void SetSpeed(const sf::Vector2f&amp; l_vec){ ... } 
  void SetAcceleration(const sf::Vector2f&amp; l_vec){ ... } 
  void SetDirection(const Direction&amp; l_dir){ ... } 
  void AddVelocity(const sf::Vector2f&amp; l_vec){ ... } 
  void ApplyFriction(const sf::Vector2f&amp; l_vec){ ... } 
  void Accelerate(const sf::Vector2f&amp; l_vec){ ... } 
  void Accelerate(float l_x, float l_y){ ... } 
  void Move(const Direction&amp; l_dir){ ... } 
private: 
  sf::Vector2f m_velocity; 
  sf::Vector2f m_speed; 
  sf::Vector2f m_acceleration; 
  float m_velocityMax; 
  Direction m_direction; 
}; 
</pre><p>Our movement is going to be modeled by the relationships between velocity, speed, and acceleration. For purposes of controlling entities, a maximum velocity value is going to be imposed as well, in order to prevent endless acceleration. We also store direction with this component in order to reduce certain complexities and inter-component relationships; however, it could be its own separate component.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Movement system</h2></div></div></div><p>To kick this into gear, let us first take a look at what the movement system needs in order to work:</p><pre class="programlisting">S_Movement::S_Movement(SystemManager* l_systemMgr)  
  : S_Base(System::Movement,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Movable); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Is_Moving,this); 
 
  m_gameMap = nullptr; 
} 
</pre><p>The entity's kinematic state is going to directly control its position, so we need both position and movable components here. An entity message type of <code class="literal">Is_Moving</code> is also subscribed to. The way it is named should be a clue that this message is going to be used as a request for information, and its sender will be expecting an answer. Since this system is responsible for everything related to motion, it will be handling requests like this.</p><p>Next, let us update the component data:</p><pre class="programlisting">void S_Movement::Update(float l_dT){ 
  if (!m_gameMap){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto movable = entities-&gt; 
      GetComponent&lt;C_Movable&gt;(entity, Component::Movable); 
    MovementStep(l_dT, movable, position); 
    position-&gt;MoveBy(movable-&gt;GetVelocity() * l_dT); 
  } 
} 
</pre><p>After both components are obtained, they are passed into a private method that handles a movement step. We will be covering this later, but it's important to note that it takes the position component pointer in as a <code class="literal">const</code> value, which implies that it will be read only. This is why the position of the entity is modified separately one line down, by invoking its <code class="literal">MoveBy()</code> method. It simply advances the position by a vector, provided as the sole argument.</p><p>With a more complex system task, we obviously have more events to deal with:</p><pre class="programlisting">void S_Movement::HandleEvent(const EntityId&amp; l_entity,  
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Colliding_X: 
    StopEntity(l_entity, Axis::x); break; 
  case EntityEvent::Colliding_Y: 
    StopEntity(l_entity, Axis::y); break; 
  case EntityEvent::Moving_Left: 
    SetDirection(l_entity, Direction::Left); break; 
  case EntityEvent::Moving_Right: 
    SetDirection(l_entity, Direction::Right); break; 
  case EntityEvent::Moving_Up: 
    { 
      auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
      if(mov-&gt;GetVelocity().x == 0){ 
        SetDirection(l_entity, Direction::Up); 
      } 
    } 
    break; 
  case EntityEvent::Moving_Down: 
    { 
      auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
      if(mov-&gt;GetVelocity().x == 0){ 
        SetDirection(l_entity, Direction::Down); 
      } 
    } 
    break; 
  } 
} 
</pre><p>We will want to stop our entity on a given axis, if it is actually colliding with a solid. The collision event emission will be discussed when we are covering the collision system, so all we have to remember now is that if an entity is colliding on a specific axis, it needs to have its velocity reduced to <code class="literal">0</code> on that axis.</p><p>Since we are also in charge of the entity's direction, movement events are handled and used to update it. Direction priority is given to horizontal movement, while up and down directions are only set if the velocity on the <em>x</em> axis is zero.</p><p>Back in the constructor of this system, we have subscribed to a message that requests movement information. Let us take a look at how that can be handled:</p><pre class="programlisting">void S_Movement::Notify(const Message&amp; l_message){ 
  EntityManager* eMgr = m_systemManager-&gt;GetEntityManager(); 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::Is_Moving: 
    { 
    if (!HasEntity(l_message.m_receiver)){ return; } 
    auto movable = eMgr-&gt; 
     GetComponent&lt;C_Movable&gt;(l_message.m_receiver, 
     Component::Movable); 
    if (movable-&gt;GetVelocity() != sf::Vector2f(0.f, 0.f)){return;} 
    m_systemManager-&gt;AddEvent(l_message.m_receiver, 
      (EventID)EntityEvent::Became_Idle); 
    } 
    break; 
  } 
} 
</pre><p>If the entity information was requested about isn't even part of this system, the message gets ignored. Otherwise, the movable component is obtained and its velocity gets checked for not being an absolute zero. If it is, an entity event <code class="literal">Became_Idle</code> is sent out. This will be useful later, when we're dealing with entity animations.</p><p>Once again, all the hard lifting exists inside our helper methods. Let's start with a simple one, used to obtain tile friction for a specific coordinate in space:</p><pre class="programlisting">sf::Vector2f S_Movement::GetTileFriction(unsigned int l_elevation, 
  unsigned int l_x, unsigned int l_y) 
{ 
  Tile* t = nullptr; 
  while (!t &amp;&amp; l_elevation &gt;= 0){ 
    t = m_gameMap-&gt;GetTile(l_x, l_y, l_elevation); 
    --l_elevation; 
  } 
 
  return(t ? t-&gt;m_properties-&gt;m_friction : 
    m_gameMap-&gt;GetDefaultTile()-&gt;m_friction); 
} 
</pre><p>A <code class="literal">null</code> pointer to a tile is established first. A <code class="literal">while</code> loop is then used to attempt to obtain an actual tile, starting with the original elevation and moving down until it reaches <em>0</em>. We finally return either the friction of the tile that was found, or the default friction of the map if it wasn't. It comes into play when we're trying to process the movement step of an entity here:</p><pre class="programlisting">void S_Movement::MovementStep(float l_dT, C_Movable* l_movable, 
  const C_Position* l_position) 
{ 
  sf::Vector2f f_coefficient = GetTileFriction( 
    l_position-&gt;GetElevation(), 
    static_cast&lt;unsigned int&gt;(floor(l_position-&gt;GetPosition().x / 
      Sheet::Tile_Size)), 
    static_cast&lt;unsigned int&gt;(floor(l_position-&gt;GetPosition().y / 
      Sheet::Tile_Size))); 
 
  sf::Vector2f friction(l_movable-&gt;GetSpeed().x * f_coefficient.x, 
    l_movable-&gt;GetSpeed().y * f_coefficient.y); 
 
  l_movable-&gt;AddVelocity(l_movable-&gt;GetAcceleration() * l_dT); 
  l_movable-&gt;SetAcceleration(sf::Vector2f(0.0f, 0.0f)); 
  l_movable-&gt;ApplyFriction(friction * l_dT); 
 
  float magnitude = sqrt( 
    (l_movable-&gt;GetVelocity().x * l_movable-&gt;GetVelocity().x) + 
    (l_movable-&gt;GetVelocity().y * l_movable-&gt;GetVelocity().y)); 
 
  if (magnitude &lt;= l_movable-&gt;GetMaxVelocity()){ return; } 
  float max_V = l_movable-&gt;GetMaxVelocity(); 
  l_movable-&gt;SetVelocity(sf::Vector2f( 
    (l_movable-&gt;GetVelocity().x / magnitude) * max_V, 
    (l_movable-&gt;GetVelocity().y / magnitude) * max_V)); 
} 
</pre><p>After the friction coefficient is obtained from the current tile an entity is standing on, speed loss due to friction is calculated, velocity due to acceleration is added, acceleration itself is zeroed out, and friction is applied. In order to account for diagonal movement, a velocity magnitude is calculated and checked for exceeding the maximum allowed value. If it does, the entity's velocity is re-calculated based on the ratios between its current velocity and the total magnitude, and adjusted to fit within the provided boundaries.</p><p>Stopping an entity simply comes down to zeroing its velocity out on a provided axis, like so:</p><pre class="programlisting">void S_Movement::StopEntity(const EntityId&amp; l_entity,  
  const Axis&amp; l_axis) 
{ 
  auto movable = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
  if(l_axis == Axis::x){ 
    movable-&gt;SetVelocity(sf::Vector2f( 
      0.f, movable-&gt;GetVelocity().y)); 
  } else if(l_axis == Axis::y){ 
    movable-&gt;SetVelocity(sf::Vector2f( 
      movable-&gt;GetVelocity().x, 0.f)); 
  } 
} 
</pre><p>Updating the entity's direction is equally as simple, but it can't go unnoticed by other systems:</p><pre class="programlisting">void S_Movement::SetDirection(const EntityId&amp; l_entity,  
  const Direction&amp; l_dir) 
{ 
  auto movable = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity,Component::Movable); 
  movable-&gt;SetDirection(l_dir); 
 
  Message msg((MessageType)EntityMessage::Direction_Changed); 
  msg.m_receiver = l_entity; 
  msg.m_int = static_cast&lt;int&gt;(l_dir); 
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
} 
</pre><p>After the direction is updated, a new message is constructed and dispatched, letting the relevant systems know about the direction changes of an entity. This will also prove to be incredibly useful when handling entity animations.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Handling collisions</h1></div></div></div><p>In order to make the game we're making feel like more than just entities moving across a static background with no consequences, collisions have to be checked for and handled. Within the ECS paradigm, this can be achieved by implementing a collidable component. For more flexibility, let's define multiple points that the collision box can be attached to:</p><pre class="programlisting">enum class Origin{ Top_Left, Abs_Centre, Mid_Bottom }; 
</pre><p>The <strong>TOP_LEFT</strong> origin simply places the collision rectangle's top-left corner to the position provided. <strong>ABS_CENTRE</strong> moves that rectangle's centre to the position, and the <strong>MIDDLE_BOTTOM</strong> origin places it halfway through the <em>x</em> axis and all the way down the <em>y</em> axis. Consider the following illustration:</p><div><img src="img/image_02_001.jpg" alt="Handling collisions"/></div><p>With this information, let us work on implementing the collidable component:</p><pre class="programlisting">class C_Collidable : public C_Base{ 
public: 
  C_Collidable(): C_Base(Component::Collidable),  
    m_origin(Origin::Mid_Bottom), m_collidingOnX(false), 
    m_collidingOnY(false){} 
 
  void ReadIn(std::stringstream&amp; l_stream){ 
    unsigned int origin = 0; 
    l_stream &gt;&gt; m_AABB.width &gt;&gt; m_AABB.height &gt;&gt; m_offset.x 
      &gt;&gt; m_offset.y &gt;&gt; origin; 
    m_origin = static_cast&lt;Origin&gt;(origin); 
  } 
   
  const sf::FloatRect&amp; GetCollidable() const { ... } 
  bool IsCollidingOnX() const { ... } 
  bool IsCollidingOnY() const { ... } 
  void CollideOnX(){ m_collidingOnX = true; } 
  void CollideOnY(){ m_collidingOnY = true; } 
  void ResetCollisionFlags(){ ... } 
  void SetCollidable(const sf::FloatRect&amp; l_rect){ ... } 
  void SetOrigin(const Origin&amp; l_origin){ ... } 
  void SetSize(const sf::Vector2f&amp; l_vec){ ... } 
 
  void SetPosition(const sf::Vector2f&amp; l_vec){ 
    switch(m_origin){ 
    case(Origin::Top_Left) : 
      m_AABB.left    = l_vec.x + m_offset.x; 
      m_AABB.top     = l_vec.y + m_offset.y; 
      break; 
    case(Origin::Abs_Centre): 
      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; 
      m_AABB.top     = l_vec.y - (m_AABB.height / 2) + m_offset.y; 
      break; 
    case(Origin::Mid_Bottom): 
      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; 
      m_AABB.top     = l_vec.y - m_AABB.height + m_offset.y; 
      break; 
    } 
  } 
private: 
  sf::FloatRect m_AABB; 
  sf::Vector2f m_offset; 
  Origin m_origin; 
 
  bool m_collidingOnX; 
  bool m_collidingOnY; 
}; 
</pre><p>First, let us look at the data we are keeping. <code class="literal">sf::FloatRect</code> represents the basic <strong>AABB</strong> bounding box around the entity that will be used as our collider. We also want to be able to offset it by some value, which is going to be loaded from the entity file. Obviously, the origin point is stored as well, along with two flags that indicate whether a collision is happening on each axis.</p><p>The <code class="literal">SetPosition()</code> method incorporates the use of an origin point and adjusts the rectangle to be positioned properly, since the native <code class="literal">sf::FloatRect</code> doesn't support origins by itself.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Collision system</h2></div></div></div><p>In order to work with and handle collisions, we only need two components:</p><pre class="programlisting">S_Collision::S_Collision(SystemManager* l_systemMgr)  
  : S_Base(System::Collision,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Collidable); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
 
  m_gameMap = nullptr; 
} 
</pre><p>Note the<code class="literal"> m_gameMap</code> data member. We're going to need to provide the collision system with a pointer to the game map at some point, in order to be able to handle map collisions.</p><p>Next, let's handle updating our component data:</p><pre class="programlisting">void S_Collision::Update(float l_dT){ 
  if (!m_gameMap){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto position = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto collidable = entities-&gt; 
      GetComponent&lt;C_Collidable&gt;(entity, Component::Collidable); 
     
    CheckOutOfBounds(position); 
    collidable-&gt;SetPosition(position-&gt;GetPosition()); 
    collidable-&gt;ResetCollisionFlags(); 
    MapCollisions(entity, position, collidable); 
  } 
  EntityCollisions(); 
} 
</pre><p>First, the entity's position is checked to see whether it's outside the map's boundaries. After it potentially has been adjusted, the <code class="literal">collidable</code> component is updated with the new position information, and its collision flags are reset. Both components are then passed into a private method that handles map collisions.</p><p>After all of the entities are checked against the map, we must check them for collisions against each other:</p><pre class="programlisting">void S_Collision::EntityCollisions(){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto itr = m_entities.begin(); itr!=m_entities.end(); ++itr) 
  { 
    for(auto itr2=std::next(itr); itr2!=m_entities.end(); ++itr2){ 
      auto collidable1 = entities-&gt; 
        GetComponent&lt;C_Collidable&gt;(*itr, Component::Collidable); 
      auto collidable2 = entities-&gt; 
        GetComponent&lt;C_Collidable&gt;(*itr2, Component::Collidable); 
      if(collidable1-&gt;GetCollidable().intersects( 
        collidable2-&gt;GetCollidable())) 
      { 
        // Entity-on-entity collision! 
      } 
    } 
  } 
} 
</pre><p>So far, we don't really need to handle entity-on-entity collisions in any way, but this is an entry point for later features.</p><p>The out-of-bounds check is fairly simple:</p><pre class="programlisting">void S_Collision::CheckOutOfBounds(C_Position* l_pos){ 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
 
  if (l_pos-&gt;GetPosition().x &lt; 0){ 
    l_pos-&gt;SetPosition(0.0f, l_pos-&gt;GetPosition().y); 
  } else if (l_pos-&gt;GetPosition().x &gt; 
    m_gameMap-&gt;GetMapSize().x * TileSize) 
  { 
    l_pos-&gt;SetPosition( 
      static_cast&lt;float&gt;(m_gameMap-&gt;GetMapSize().x * TileSize), 
      l_pos-&gt;GetPosition().y); 
  } 
 
  if (l_pos-&gt;GetPosition().y &lt; 0){ 
    l_pos-&gt;SetPosition(l_pos-&gt;GetPosition().x, 0.0f); 
  } else if (l_pos-&gt;GetPosition().y &gt; 
    m_gameMap-&gt;GetMapSize().y * TileSize) 
  { 
    l_pos-&gt;SetPosition( 
      l_pos-&gt;GetPosition().x, 
      static_cast&lt;float&gt;(m_gameMap-&gt;GetMapSize().y * TileSize)); 
  } 
} 
</pre><p>It simply checks the position for being either in negative coordinates, or outside the map's boundaries.</p><p>Processing actual map collisions is further broken down into more readable bits:</p><pre class="programlisting">void S_Collision::MapCollisions(const EntityId&amp; l_entity, 
  C_Position* l_pos, C_Collidable* l_col) 
{ 
  Collisions c; 
  CheckCollisions(l_pos, l_col, c); 
  HandleCollisions(l_entity, l_pos, l_col, c); 
} 
</pre><p>After a <code class="literal">Collisions</code> data type is set up, it, along with the position and collidable components, is passed to two private methods, which actually perform collision checks, and later handle them. The <code class="literal">Collisions</code> data type is just a container for collision information:</p><pre class="programlisting">struct CollisionElement{ 
  CollisionElement(float l_area, TileInfo* l_info, 
    const sf::FloatRect&amp; l_bounds):m_area(l_area), m_tile(l_info), 
    m_tileBounds(l_bounds){} 
  float m_area; 
  TileInfo* m_tile; 
  sf::FloatRect m_tileBounds; 
}; 
 
using Collisions = std::vector&lt;CollisionElement&gt;; 
</pre><p>Let us focus on actually filling this structure out with useful collision information next:</p><pre class="programlisting">void S_Collision::CheckCollisions(C_Position* l_pos, 
  C_Collidable* l_col, Collisions&amp; l_collisions) 
{ 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
  sf::FloatRect EntityAABB = l_col-&gt;GetCollidable(); 
  int FromX = static_cast&lt;int&gt;(floor(EntityAABB.left / TileSize)); 
  int ToX = static_cast&lt;int&gt;(floor((EntityAABB.left + 
    EntityAABB.width) / TileSize)); 
  int FromY = static_cast&lt;int&gt;(floor(EntityAABB.top / TileSize)); 
  int ToY = static_cast&lt;int&gt;(floor((EntityAABB.top + 
    EntityAABB.height) / TileSize)); 
 
  for (int x = FromX; x &lt;= ToX; ++x) { 
    for (int y = FromY; y &lt;= ToY; ++y) { 
      for (size_t l = l_pos-&gt;GetElevation(); l &lt; 
        l_pos-&gt;GetElevation() + 1; ++l) 
      { 
        auto t = m_gameMap-&gt;GetTile(x, y, l); 
        if (!t) { continue; } 
        if (!t-&gt;m_solid) { continue; } 
        sf::FloatRect TileAABB = static_cast&lt;sf::FloatRect&gt;( 
          sf::IntRect(x*TileSize, y*TileSize,TileSize,TileSize)); 
        sf::FloatRect Intersection; 
        EntityAABB.intersects(TileAABB, Intersection); 
        float S = Intersection.width * Intersection.height; 
        l_collisions.emplace_back(S, t-&gt;m_properties, TileAABB); 
        break; 
      } 
    } 
  } 
} 
</pre><p>This method uses the entity collision box and the map tile size to establish a range of tiles that are intersecting with it. We then use that range to obtain tiles one by one, check if they exist and are solid, construct their bounding boxes, measure the areas of intersection, and add all of that information to the collision container. So far, so good!</p><p>The grand finale of this system is, of course, handling all of the collision information that got collected:</p><pre class="programlisting">void S_Collision::HandleCollisions(const EntityId&amp; l_entity, 
  C_Position* l_pos, C_Collidable* l_col,Collisions&amp; l_collisions) 
{ 
  sf::FloatRect EntityAABB = l_col-&gt;GetCollidable(); 
  unsigned int TileSize = m_gameMap-&gt;GetTileSize(); 
 
  if (l_collisions.empty()) { return; } 
  std::sort(l_collisions.begin(), l_collisions.end(), 
    [](CollisionElement&amp; l_1, CollisionElement&amp; l_2) { 
      return l_1.m_area &gt; l_2.m_area; 
    } 
  ); 
 
  for (auto &amp;col : l_collisions) { 
    EntityAABB = l_col-&gt;GetCollidable(); 
    if (!EntityAABB.intersects(col.m_tileBounds)) { continue; } 
    float xDiff = (EntityAABB.left + (EntityAABB.width / 2)) - 
      (col.m_tileBounds.left + (col.m_tileBounds.width / 2)); 
    float yDiff = (EntityAABB.top + (EntityAABB.height / 2)) - 
      (col.m_tileBounds.top + (col.m_tileBounds.height / 2)); 
    float resolve = 0; 
    if (std::abs(xDiff) &gt; std::abs(yDiff)) { 
      if (xDiff &gt; 0) { 
        resolve=(col.m_tileBounds.left+TileSize)-EntityAABB.left; 
      } else { 
        resolve = -((EntityAABB.left + EntityAABB.width) - 
          col.m_tileBounds.left); 
      } 
      l_pos-&gt;MoveBy(resolve, 0); 
      l_col-&gt;SetPosition(l_pos-&gt;GetPosition()); 
      m_systemManager-&gt;AddEvent( 
        l_entity, (EventID)EntityEvent::Colliding_X); 
      l_col-&gt;CollideOnX(); 
    } else { 
      if (yDiff &gt; 0) { 
        resolve=(col.m_tileBounds.top + TileSize)-EntityAABB.top; 
      } else { 
        resolve = -((EntityAABB.top + EntityAABB.height) - 
          col.m_tileBounds.top); 
      } 
      l_pos-&gt;MoveBy(0, resolve); 
      l_col-&gt;SetPosition(l_pos-&gt;GetPosition()); 
      m_systemManager-&gt;AddEvent( 
        l_entity, (EventID)EntityEvent::Colliding_Y); 
      l_col-&gt;CollideOnY(); 
    } 
  } 
} 
</pre><p>The collision container is first checked for being empty. If it isn't, we sort the collision information to flow in a descending order, and use the size of the intersecting area for the comparison. This ensures that the collision(s) with the largest area of intersection come first, and thus gets handled first.</p><p>During the processing of this information, we must first check if the entity's bounding box is still colliding with the tile. In case of multiple collisions, the first collision that got processed may have moved an entity in such a way that it no longer collides with anything at all.</p><p>The <code class="literal">xDiff</code> and <code class="literal">yDiff</code> variables are used to hold the penetration information of each axis, and the <code class="literal">resolve</code> variable will be used to store exact distance by which the entity is going to be pushed to resolve the collision. The first two variables are then compared, in order to decide which axis to resolve the collision on. Our <code class="literal">resolve</code> variable is used to calculate the exact distance of the push based on whether it's a left-to-right or right-to-left collision.</p><p>Finally, the position is adjusted by the resolve distance on the relevant axis, the collidable component's position is updated to match the changes, a colliding event is sent out, and the collidable component's <code class="literal">CollideOnX</code> or <code class="literal">CollideOnY</code> method is invoked to update the collision flags. These events then get handled by other systems, such as <code class="literal">S_Movement</code>, which we have already covered.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Controlling entities</h1></div></div></div><p>Since we have already laid down the code foundation, it's now possible to focus on controlling the entities on the screen. Whether they're being controlled as player avatars by means of a keyboard, or through some sort of <strong>artificial intelligence </strong>(<strong>AI</strong>), they still need to have this basic component:</p><pre class="programlisting">class C_Controller : public C_Base{ 
public: 
  C_Controller() : C_Base(Component::Controller){} 
  void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</pre><p>As you can tell, we have absolutely no data that gets stored here so far. For now, it can simply be considered just a specific signature that lets the ECS know it can be controlled.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Control system</h2></div></div></div><p>In order for entities to be controlled, they must have three basic component types:</p><pre class="programlisting">S_Control::S_Control(SystemManager* l_systemMgr) 
  : S_Base(System::Control,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::Movable); 
  req.TurnOnBit((unsigned int)Component::Controller); 
  m_requiredComponents.push_back(req); 
  req.Clear(); 
} 
</pre><p>Actual control happens through the event system:</p><pre class="programlisting">void S_Control::HandleEvent(const EntityId&amp; l_entity,  
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Moving_Left: 
    MoveEntity(l_entity, Direction::Left); break; 
  case EntityEvent::Moving_Right: 
    MoveEntity(l_entity, Direction::Right); break; 
  case EntityEvent::Moving_Up: 
    MoveEntity(l_entity, Direction::Up); break; 
  case EntityEvent::Moving_Down: 
    MoveEntity(l_entity, Direction::Down); break; 
  } 
} 
</pre><p>The movement itself is just a modification of the movable component, as shown here:</p><pre class="programlisting">void S_Control::MoveEntity(const EntityId&amp; l_entity,  
  const Direction&amp; l_dir) 
{ 
  auto mov = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_Movable&gt;(l_entity, Component::Movable); 
  mov-&gt;Move(l_dir); 
} 
</pre><p>The <code class="literal">C_Movable</code> component type takes care of actually modifying its data. All we need to do is pass in a valid direction.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Entity states</h1></div></div></div><p>Having entities that are able to move around now implies they can either be standing still or moving. This quickly brings about the issue of entity states. Luckily, we have an elegant way of dealing with that, by introducing another component type and a system. Let's start by enumerating all possible entity states, and using the enumeration to establish a component type:</p><pre class="programlisting">enum class EntityState{ Idle, Walking, Attacking, Hurt, Dying }; 
 
class C_State : public C_Base{ 
public: 
  C_State(): C_Base(Component::State){} 
  void ReadIn(std::stringstream&amp; l_stream){ 
    unsigned int state = 0; 
    l_stream &gt;&gt; state; 
    m_state = static_cast&lt;EntityState&gt;(state); 
  } 
 
  EntityState GetState() const { ... } 
  void SetState(const EntityState&amp; l_state){ ... } 
private: 
  EntityState m_state; 
}; 
</pre><p>That's all we have to keep track of inside the component class. Time to move on to the system!</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>State system</h2></div></div></div><p>Because state is not directly tethered to any other data, we can only require one component type to be present in order to work with states:</p><pre class="programlisting">S_State::S_State(SystemManager* l_systemMgr) 
  : S_Base(System::State,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::State); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Move,this); 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Switch_State,this); 
} 
</pre><p>This system also needs to subscribe to two different message types: <code class="literal">Move</code> and <code class="literal">Switch_State</code>. The action of movement is obviously state-dependent, since, for example, an entity shouldn't be able to move if it is dead.</p><p>Updating entities with a state is fairly basic, since we're about to utilize the movement system indirectly:</p><pre class="programlisting">void S_State::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(entity, Component::State); 
    if(state-&gt;GetState() == EntityState::Walking){ 
      Message msg((MessageType)EntityMessage::Is_Moving); 
      msg.m_receiver = entity; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
  } 
} 
</pre><p>All we care about so far is if the state of the current entity is <code class="literal">Walking</code>, but the entity has gone idle. For that, we can send out the <code class="literal">Is_Moving</code> message, which the <code class="literal">S_Movement</code> is going to respond to with an event, given that the entity has stopped. That event is then handled here:</p><pre class="programlisting">void S_State::HandleEvent(const EntityId&amp; l_entity, 
  const EntityEvent&amp; l_event) 
{ 
  switch(l_event){ 
  case EntityEvent::Became_Idle: 
    ChangeState(l_entity,EntityState::Idle,false); 
    break; 
  } 
} 
</pre><p>A private method for changing an entity's state is invoked, setting it to <code class="literal">Idle</code>. Kids' stuff!</p><p>Next, let us handle the message types this system is subscribed to:</p><pre class="programlisting">void S_State::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)){ return; } 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::Move: 
    { 
      auto state = m_systemManager-&gt;GetEntityManager()-&gt; 
        GetComponent&lt;C_State&gt;(l_message.m_receiver, 
        Component::State); 
 
      if (state-&gt;GetState() == EntityState::Dying){ return; } 
      EntityEvent e; 
      Direction dir = static_cast&lt;Direction&gt;(l_message.m_int); 
      if (dir==Direction::Up){e=EntityEvent::Moving_Up;} 
      else if (dir==Direction::Down){e=EntityEvent::Moving_Down;} 
      else if(dir==Direction::Left){e=EntityEvent::Moving_Left;} 
      else if(dir==Direction::Right){e=EntityEvent::Moving_Right;} 
 
      m_systemManager-&gt;AddEvent(l_message.m_receiver, 
        static_cast&lt;EventID&gt;(e)); 
      ChangeState(l_message.m_receiver, 
        EntityState::Walking,false); 
    } 
    break; 
  case EntityMessage::Switch_State:  
    ChangeState(l_message.m_receiver, 
      (EntityState)l_message.m_int,false); 
    break; 
  } 
} 
</pre><p>Since actual entity movement depends on its state, this is the system that decides whether there is movement or not. The entity's state is first checked, to make sure it can't move if it's dying. An <code class="literal">EntityEvent</code> structure is then constructed and set to match the direction of the <code class="literal">Move</code> message. After the event is dispatched, the entity's state is changed to <code class="literal">Walking</code>.</p><p>Other systems within the ECS may care about the state of an entity changing. For that, we need to handle these changes accordingly:</p><pre class="programlisting">void S_State::ChangeState(const EntityId&amp; l_entity,  
  const EntityState&amp; l_state, bool l_force) 
{ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto state = entities-&gt; 
    GetComponent&lt;C_State&gt;(l_entity, Component::State); 
  if (!l_force &amp;&amp; state-&gt;GetState()==EntityState::Dying){return;} 
  state-&gt;SetState(l_state); 
  Message msg((MessageType)EntityMessage::State_Changed); 
  msg.m_receiver = l_entity; 
  msg.m_int = static_cast&lt;int&gt;(l_state); 
  m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
} 
</pre><p>Note the last argument of this method. It indicates whether the state change should be forced or not. This is done to ensure that certain state changes can be defined as non-critical, and should be ignored if an entity is dying.</p><p>If the state ends up getting changed, the component data is updated, and a new <code class="literal">State_Changed</code> message is dispatched to inform other systems.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Sheet animation system</h1></div></div></div><p>One of the objects sensitive to state changes is the sprite sheet animation system. Knowing an entity's state is of paramount importance, if we desire to apply animations that describe its current action:</p><pre class="programlisting">S_SheetAnimation::S_SheetAnimation(SystemManager* l_systemMgr) 
  : S_Base(System::SheetAnimation,l_systemMgr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::SpriteSheet); 
  req.TurnOnBit((unsigned int)Component::State); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::State_Changed,this); 
} 
</pre><p>As you can see, all we need are two component types and a subscription to a message type of <code class="literal">State_Changed</code>. So far, so good!</p><p>Updating the sprite sheets can get a little involved, so let us delve right into it:</p><pre class="programlisting">void S_SheetAnimation::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for(auto &amp;entity : m_entities){ 
    auto sheet = entities-&gt; 
      GetComponent&lt;C_SpriteSheet&gt;(entity, Component::SpriteSheet); 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(entity, Component::State); 
 
    sheet-&gt;GetSpriteSheet()-&gt;Update(l_dT); 
 
    const std::string&amp; animName = sheet-&gt; 
      GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;GetName(); 
    if(animName == "Attack"){ 
      if(!sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying()) 
      { 
        Message msg((MessageType)EntityMessage::Switch_State); 
        msg.m_receiver = entity; 
        msg.m_int = static_cast&lt;int&gt;(EntityState::Idle); 
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
      } else if(sheet-&gt;GetSpriteSheet()-&gt; 
        GetCurrentAnim()-&gt;IsInAction()) 
      { 
        Message msg((MessageType)EntityMessage::Attack_Action); 
        msg.m_sender = entity; 
        m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
      } 
    } else if(animName == "Death" &amp;&amp; 
      !sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;IsPlaying()) 
    { 
      Message msg((MessageType)EntityMessage::Dead); 
      msg.m_receiver = entity; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
    if (sheet-&gt;GetSpriteSheet()-&gt;GetCurrentAnim()-&gt;CheckMoved()){ 
      int frame = sheet-&gt;GetSpriteSheet()-&gt; 
        GetCurrentAnim()-&gt;GetFrame(); 
      Message msg((MessageType)EntityMessage::Frame_Change); 
      msg.m_receiver = entity; 
      msg.m_int = frame; 
      m_systemManager-&gt;GetMessageHandler()-&gt;Dispatch(msg); 
    } 
  } 
} 
</pre><p>After the sprite sheet and state components are obtained, the sheet gets updated. The name of its current animation is then obtained. Keep in mind that certain entity states are dependent on the current animation, and as soon as that animation is over, we want to switch back to an idle state. For example, the attack animation is first checked for no longer playing. If that's the case, a message is sent to the state system, letting it know that this entity's state needs to be switched to idle. Additionally, the animation's action range is checked, which is used to determine whether, for example, the current frames of the attack animation are of the character swinging the sword just right, where we can inflict damage.</p><p>The exact same principle applies to the death animation, except the message that gets sent out once that is finished is different.</p><p>Finally, every single animation has to be checked for frame progression, in which case a message gets sent out, notifying systems interested in that type that the animation frame has changed.</p><p>As mentioned before, sprite sheets need to know if the entity's state has changed. This is where we handle that:</p><pre class="programlisting">void S_SheetAnimation::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)) { return; } 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch(m){ 
  case EntityMessage::State_Changed: 
    { 
      EntityState s = static_cast&lt;EntityState&gt;(l_message.m_int); 
      switch(s){ 
      case EntityState::Idle: 
        ChangeAnimation(l_message.m_receiver,"Idle",true,true); 
        break; 
      case EntityState::Walking: 
        ChangeAnimation(l_message.m_receiver,"Walk",true,true); 
        break; 
      case EntityState::Attacking: 
        ChangeAnimation(l_message.m_receiver,"Attack",true,false); 
        break; 
      case EntityState::Hurt: break; 
      case EntityState::Dying: 
        ChangeAnimation(l_message.m_receiver,"Death",true,false); 
        break; 
      } 
    } 
    break; 
  } 
} 
</pre><p>This essentially just maps the name of a specific animation to a state. The private method used to set that up is quite simple:</p><pre class="programlisting">void S_SheetAnimation::ChangeAnimation(const EntityId&amp; l_entity,  
  const std::string&amp; l_anim, bool l_play, bool l_loop) 
{ 
  auto sheet = m_systemManager-&gt;GetEntityManager()-&gt; 
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet); 
  sheet-&gt;GetSpriteSheet()-&gt;SetAnimation(l_anim,l_play,l_loop); 
} 
</pre><p>It takes in the entity identifier, the name of the animation, a flag for whether the animation should be played automatically, and another flag for whether it should loop. The sprite sheet that sits inside the component is then requested to play the animation provided.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Entity sounds</h1></div></div></div><p>Just like states, an entity can emit multiple different types of sound. Each different type must also have certain parameters associated with it:</p><pre class="programlisting">enum class EntitySound{ None = -1, Footstep, Attack, 
  Hurt, Death, COUNT }; 
 
struct SoundParameters{ 
  static const int Max_SoundFrames = 5; 
  SoundParameters(){ 
    for (int i = 0; i &lt; Max_SoundFrames; ++i){ m_frames[i] = -1; } 
  } 
  std::string m_sound; 
  std::array&lt;int, Max_SoundFrames&gt; m_frames; 
}; 
</pre><p><code class="literal">struct SoundParameters</code> simply stores the name of the sound, as well as an array of integers for the maximum number of sound frames. A sound frame is the glue between sounds and sprite sheets, as it defines during which animation frames the sound is emitted.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Having defined the previous data structure allows us to successfully create a sound emitter component type:</li></ul></div><pre class="programlisting">class C_SoundEmitter : public C_Base{ 
public: 
  C_SoundEmitter():C_Base(Component::SoundEmitter),m_soundID(-1){} 
  void ReadIn(std::stringstream&amp; l_stream){ 
    std::string main_delimiter = ":"; 
    std::string frame_delimiter = ","; 
    for (size_t i=0;i&lt;static_cast&lt;size_t&gt;(EntitySound::COUNT);++i) 
    { 
      std::string chunk; 
      l_stream &gt;&gt; chunk; 
      if (chunk.empty()){ break; } 
 
      std::string sound = chunk.substr(0, 
        chunk.find(main_delimiter)); 
      std::string frames = chunk.substr(chunk.find(main_delimiter) 
        +main_delimiter.length()); 
      m_params[i].m_sound = sound; 
      size_t pos = 0; 
      unsigned int frameNum = 0; 
      while (frameNum &lt; SoundParameters::Max_SoundFrames){ 
        pos = frames.find(frame_delimiter); 
        int frame = -1; 
        if (pos != std::string::npos){ 
          frame = stoi(frames.substr(0, pos)); 
          frames.erase(0, pos + frame_delimiter.length()); 
        } else { 
          frame = stoi(frames); 
          m_params[i].m_frames[frameNum] = frame; 
          break; 
        } 
        m_params[i].m_frames[frameNum] = frame; 
        ++frameNum; 
      } 
    } 
  } 
 
  SoundID GetSoundID() const { ... } 
  void SetSoundID(const SoundID&amp; l_id){ ... } 
  const std::string&amp; GetSound(const EntitySound&amp; l_snd) const{...} 
  bool IsSoundFrame(const EntitySound&amp; l_snd, int l_frame) const 
  { ... } 
  SoundParameters* GetParameters() { ... } 
private: 
  std::array&lt;SoundParameters, 
    static_cast&lt;size_t&gt;(EntitySound::COUNT)&gt; m_params; 
  SoundID m_soundID; 
}; 
</pre><p>The only data we are storing here is an array of <code class="literal">SoundParameter</code> objects for each type of <code class="literal">EntitySound</code> enum, and a <code class="literal">SoundID</code> data member, which is going to be used in the sound system, in order to make sure only one entity sound is playing at the same time. The large method for de-serialization simply deals with correctly loading in the sound frames.</p><p>Another, much more basic component type we need before we can proceed is a sound listener:</p><pre class="programlisting">class C_SoundListener : public C_Base{ 
public: 
  C_SoundListener() : C_Base(Component::SoundListener){} 
  void ReadIn(std::stringstream&amp; l_stream){} 
}; 
</pre><p>This, much like <code class="literal">C_Controller</code>, is basically just a flag that lets the sound system know that the entity that has it should be treated as the listener. We need to be careful with this, since there should only ever be one sound listener present at a time.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Sound system</h2></div></div></div><p>The system in charge of managing entity sounds uses the component signature bitmask in a way that allows multiple different compositions to be recognized:</p><pre class="programlisting">S_Sound::S_Sound(SystemManager* l_systemMgr) 
  : S_Base(System::Sound, l_systemMgr), 
  m_audioManager(nullptr), m_soundManager(nullptr) 
{ 
  Bitmask req; 
  req.TurnOnBit((unsigned int)Component::Position); 
  req.TurnOnBit((unsigned int)Component::SoundEmitter); 
  m_requiredComponents.push_back(req); 
  req.ClearBit((unsigned int)Component::SoundEmitter); 
  req.TurnOnBit((unsigned int)Component::SoundListener); 
  m_requiredComponents.push_back(req); 
 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Direction_Changed, this); 
  m_systemManager-&gt;GetMessageHandler()-&gt; 
    Subscribe(EntityMessage::Frame_Change, this); 
} 
</pre><p>We want entities with a position component, as well as an emitter and/or listener component. The message of type <code class="literal">Direction_Changed</code> is also subscribed to, as well as <code class="literal">Frame_Change</code>.</p><p>Updating these components looks like this:</p><pre class="programlisting">void S_Sound::Update(float l_dT){ 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  for (auto &amp;entity : m_entities){ 
    auto c_pos = entities-&gt; 
      GetComponent&lt;C_Position&gt;(entity, Component::Position); 
    auto position = c_pos-&gt;GetPosition(); 
    auto elevation = c_pos-&gt;GetElevation(); 
 
    auto IsListener = entities-&gt; 
      HasComponent(entity, Component::SoundListener); 
    if (IsListener){ 
      sf::Listener::setPosition( 
        MakeSoundPosition(position, elevation)); 
    } 
 
    if (!entities-&gt;HasComponent(entity, Component::SoundEmitter)) 
    { continue; } 
    auto c_snd = entities-&gt; 
     GetComponent&lt;C_SoundEmitter&gt;(entity,Component::SoundEmitter); 
    if (c_snd-&gt;GetSoundID() == -1){ continue; } 
    if (!IsListener){ 
      if (!m_soundManager-&gt;SetPosition(c_snd-&gt;GetSoundID(), 
        MakeSoundPosition(position, elevation))) 
      { c_snd-&gt;SetSoundID(-1); } 
    } else { 
      if (!m_soundManager-&gt;IsPlaying(c_snd-&gt;GetSoundID())){ 
        c_snd-&gt;SetSoundID(-1); 
      } 
    } 
  } 
} 
</pre><p>The entity is checked for being a sound listener. If it is, the SFML's sound listener position is set to the position of the entity, with elevation included. We utilize a private helper method here, to construct a 3D vector, which will be covered shortly.</p><p>If the entity has a sound emitter component, and its sound identifier isn't equal to <code class="literal">-1</code>, which would indicate that no sounds are playing, the sound's position is attempted to be updated, provided the entity isn't a sound listener. If either the position update fails, or the sound is no longer playing, its identifier is set back to <code class="literal">-1</code>.</p><p>Next up is message handling:</p><pre class="programlisting">void S_Sound::Notify(const Message&amp; l_message){ 
  if (!HasEntity(l_message.m_receiver)){ return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto IsListener = entities-&gt; 
    HasComponent(l_message.m_receiver, Component::SoundListener); 
  EntityMessage m = static_cast&lt;EntityMessage&gt;(l_message.m_type); 
  switch (m){ 
  case EntityMessage::Direction_Changed: 
  { 
    if (!IsListener){ return; } 
    Direction dir = static_cast&lt;Direction&gt;(l_message.m_int); 
    switch (dir){ 
    case Direction::Up: 
      sf::Listener::setDirection(0, 0, -1); break; 
    case Direction::Down: 
      sf::Listener::setDirection(0, 0, 1); break; 
    case Direction::Left: 
      sf::Listener::setDirection(-1, 0, 0); break; 
    case Direction::Right: 
      sf::Listener::setDirection(1, 0, 0); break; 
    } 
  } 
    break; 
  case EntityMessage::Frame_Change: 
    if (!entities-&gt; 
      HasComponent(l_message.m_receiver,Component::SoundEmitter)) 
    { return; } 
    auto state = entities-&gt; 
      GetComponent&lt;C_State&gt;(l_message.m_receiver,Component::State) 
      -&gt;GetState(); 
    auto sound = EntitySound::None; 
    if(state ==EntityState::Walking){sound=EntitySound::Footstep;} 
    else if (state == EntityState::Attacking){ 
      sound = EntitySound::Attack; 
    } else if (state == EntityState::Hurt){ 
      sound = EntitySound::Hurt; 
    } else if (state == EntityState::Dying){ 
      sound = EntitySound::Death; 
    } 
    if (sound == EntitySound::None){ return; } 
    EmitSound(l_message.m_receiver, sound, false, 
      IsListener, l_message.m_int); 
    break; 
  } 
} 
</pre><p>We should only care about the direction change message if our entity is a sound listener, in which case the global sound listener direction is simply updated to reflect the changes.</p><p>If a frame is changed, we make sure the entity is a sound emitter first. If it is, its current state is matched to a sound type that would play. The private <code class="literal">EmitSound</code> method is then invoked:</p><pre class="programlisting">void S_Sound::EmitSound(const EntityId&amp; l_entity, 
  const EntitySound&amp; l_sound, bool l_useId, bool l_relative, 
  int l_checkFrame) 
{ 
  if (!HasEntity(l_entity)){ return; } 
  if (!m_systemManager-&gt;GetEntityManager()-&gt; 
    HasComponent(l_entity, Component::SoundEmitter)) 
  { return; } 
  EntityManager* entities = m_systemManager-&gt;GetEntityManager(); 
  auto c_snd = entities-&gt;GetComponent&lt;C_SoundEmitter&gt;( 
    l_entity, Component::SoundEmitter); 
  if (c_snd-&gt;GetSoundID() != -1 &amp;&amp; l_useId){ return; } 
  if (l_checkFrame != -1 &amp;&amp; 
    !c_snd-&gt;IsSoundFrame(l_sound, l_checkFrame)) 
  { return; } 
  auto c_pos = entities-&gt; 
    GetComponent&lt;C_Position&gt;(l_entity, Component::Position); 
  auto pos = (l_relative ? 
   sf::Vector3f(0.f, 0.f, 0.f) : 
   MakeSoundPosition(c_pos-&gt;GetPosition(),c_pos-&gt;GetElevation())); 
  if (l_useId){ 
    c_snd-&gt;SetSoundID(m_soundManager-&gt;Play( 
      c_snd-&gt;GetSound(l_sound), pos)); 
  } else { 
    m_soundManager-&gt;Play(c_snd-&gt;GetSound(l_sound), 
      pos, false, l_relative); 
  } 
} 
</pre><p>After all the component and entity checks have passed, the sound emitter is checked for not emitting another sound already in case we want to use the existing ID. The sound frame is then checked, and the position for the sound is calculated based on whether the entity is a listener or not. Finally, based on whether we're using the sound ID or not, the sound manager's <code class="literal">Play</code> method is invoked, and its return sound ID is possibly stored.</p><p>To conclude the sound topic within ECS, as well as the entire ECS portion of this chapter, let's look at how we construct a 3D sound position based on the entity's <em>x</em> and <em>y</em> positions, as well as its elevation:</p><pre class="programlisting">sf::Vector3f S_Sound::MakeSoundPosition( 
  const sf::Vector2f&amp; l_entityPos, unsigned int l_elevation) 
{ 
  return sf::Vector3f( 
    l_entityPos.x, 
    static_cast&lt;float&gt;(l_elevation * Sheet::Tile_Size), 
    l_entityPos.y 
  ); 
} 
</pre><p>The <code class="literal">z</code> member of <code class="literal">sf::Vector3f</code> is used to store the <em>height</em>, which is simply the elevation multiplied by the tile size.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Implementing the menu state</h1></div></div></div><p>With most of the backend already covered, we're ready to move towards the front, and start working on more interactive aspects of the project, such as interfaces. Let's start by creating a main menu:</p><pre class="programlisting">void State_MainMenu::OnCreate(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  GUI_Manager* gui = context-&gt;m_guiManager; 
  gui-&gt;LoadInterface("MainMenu.interface", "MainMenu"); 
  gui-&gt;GetInterface("MainMenu")-&gt;SetPosition( 
    sf::Vector2f(250.f, 168.f)); 
  EventManager* eMgr = context-&gt;m_eventManager; 
  eMgr-&gt;AddCallback("MainMenu_Play", &amp;State_MainMenu::Play, this); 
  eMgr-&gt;AddCallback("MainMenu_Quit", &amp;State_MainMenu::Quit, this); 
} 
</pre><p>All of these classes have already been covered in <a class="ulink" href="http://Chapter 1">Chapter 1</a>
, <em>Under the Hood - Setting up the Backend</em>, but let us have a quick rundown of what this does once more. After we obtain the shared context, a main menu interface is loaded and positioned on screen. The <code class="literal">m_eventManager</code> is then used to bind the main menu button clicks to methods of this class.</p><p>These resources/bindings obviously have to be removed when the state is destroyed:</p><pre class="programlisting">void State_MainMenu::OnDestroy(){ 
  m_stateMgr-&gt;GetContext()-&gt;m_guiManager-&gt; 
    RemoveInterface(StateType::Game, "MainMenu"); 
  EventManager* eMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Play"); 
  eMgr-&gt;RemoveCallback(StateType::MainMenu, "MainMenu_Quit"); 
} 
</pre><p>Upon activation of the main menu state, we are going to want to check if a game state has already been added:</p><pre class="programlisting">void State_MainMenu::Activate(){ 
  auto&amp; play = *m_stateMgr-&gt;GetContext()-&gt;m_guiManager-&gt; 
    GetInterface("MainMenu")-&gt;GetElement("Play"); 
  if (m_stateMgr-&gt;HasState(StateType::Game)){ 
    // Resume 
    play.SetText("Resume"); 
  } else { 
    // Play 
    play.SetText("Play"); 
  } 
} 
</pre><p>This ensures that the first button in the menu accurately reflects the existence/lack of a game state.</p><p>Finally, here are the callbacks of the main menu buttons:</p><pre class="programlisting">void State_MainMenu::Play(EventDetails* l_details){ 
  m_stateMgr-&gt;SwitchTo(StateType::Game); 
} 
void State_MainMenu::Quit(EventDetails* l_details){ 
  m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;Close(); 
} 
</pre><p>In case of the play button being clicked, we switch to a game state, whether or not it exists yet. The quit button, on the other hand, would reach the window class and close it.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Implementing the game state</h1></div></div></div><p>Now it's getting more interesting. The game state is where all of the fun happens, so we need to make sure it's set up properly. Let us start, as per usual, with the creation of the state:</p><pre class="programlisting">void State_Game::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
 
  evMgr-&gt;AddCallback("Key_Escape", &amp;State_Game::MainMenu, this); 
  evMgr-&gt;AddCallback("Player_MoveLeft", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveRight", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveUp", 
    &amp;State_Game::PlayerMove, this); 
  evMgr-&gt;AddCallback("Player_MoveDown", 
    &amp;State_Game::PlayerMove, this); 
 
  sf::Vector2u size = context-&gt;m_wind-&gt;GetWindowSize(); 
  m_view.setSize(static_cast&lt;float&gt;(size.x), 
    static_cast&lt;float&gt;(size.y)); 
  m_view.setCenter(static_cast&lt;float&gt;(size.x) / 2, 
    static_cast&lt;float&gt;(size.y) / 2); 
  m_view.zoom(0.6f); 
</pre><pre class="programlisting">  auto loading = m_stateMgr-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  context-&gt;m_gameMap-&gt;AddFile( 
    Utils::GetWorkingDirectory() + "media/Maps/map1.map"); 
  loading-&gt;AddLoader(context-&gt;m_gameMap); 
  loading-&gt;SetManualContinue(true); 
  context-&gt;m_soundManager-&gt;PlayMusic("TownTheme", 50.f, true); 
} 
</pre><p>First, all of the relevant events we're interested in are bound to methods of this class. This includes the escape key, which simply switches back to the menu state, and four player movement keys. The view of this state is then set up to be zoomed in slightly more, just to be able to see the character better.</p><p>The last couple of lines obtain the loading state, and add the game map and the tile set to it as loaders right after the map and tile set files to be loaded are added.</p><p>Naturally, these callbacks are going to need to be unbound upon the destruction of the state:</p><pre class="programlisting">void State_Game::OnDestroy(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::Game, "Key_Escape"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Key_O"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveLeft"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveRight"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveUp"); 
  evMgr-&gt;RemoveCallback(StateType::Game, "Player_MoveDown"); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;GetTileSet()-&gt;Purge(); 
} 
</pre><div><div><h3 class="title"><a id="note5"/>Note</h3><p>Note that both the game map and the tile set are both purged here as well.</p></div></div><p>Updating the game state only comes down to updating its own camera, alongside the game map and the ECS system manager:</p><pre class="programlisting">void State_Game::Update(const sf::Time&amp; l_time){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  UpdateCamera(); 
  context-&gt;m_gameMap-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_systemManager-&gt;Update(l_time.asSeconds()); 
} 
</pre><p>The camera (or the view) of the state is updated like so:</p><pre class="programlisting">void State_Game::UpdateCamera(){ 
  if (m_player == -1){ return; } 
  SharedContext* context = m_stateMgr-&gt;GetContext(); 
  auto pos = m_stateMgr-&gt;GetContext()-&gt;m_entityManager-&gt; 
    GetComponent&lt;C_Position&gt;(m_player, Component::Position); 
 
  m_view.setCenter(pos-&gt;GetPosition()); 
  context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
 
  sf::FloatRect viewSpace = context-&gt;m_wind-&gt;GetViewSpace(); 
  if (viewSpace.left &lt;= 0){ 
    m_view.setCenter(viewSpace.width / 2, m_view.getCenter().y); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } else if (viewSpace.left + viewSpace.width &gt; 
    (context-&gt;m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size) 
  { 
    m_view.setCenter( 
      ((context-&gt;m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size) - 
        (viewSpace.width / 2), 
      m_view.getCenter().y); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } 
 
  if (viewSpace.top &lt;= 0){ 
    m_view.setCenter(m_view.getCenter().x, viewSpace.height / 2); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } else if (viewSpace.top + viewSpace.height &gt; 
    (context-&gt;m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size) 
  { 
    m_view.setCenter( 
      m_view.getCenter().x, 
      ((context-&gt;m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size) - 
        (viewSpace.height / 2)); 
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view); 
  } 
} 
</pre><p>This can look like a lot, but the basic gist of it is first obtaining the position of our player, and then using those coordinates to either centre the view on, or position it in such a way that the very edge of the map is at the edge of the view. The idea is not moving the state view beyond the borders of the map.</p><p>Drawing is also fairly straightforward:</p><pre class="programlisting">void State_Game::Draw(){ 
  auto context = m_stateMgr-&gt;GetContext(); 
  for (unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i){ 
    context-&gt;m_gameMap-&gt;Draw(i); 
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;Draw( 
      m_stateMgr-&gt;GetContext()-&gt;m_wind, i); 
  } 
} 
</pre><p>A loop is started for each layer/elevation the game map supports. The map data of that layer is drawn first, and is followed by the system manager drawing entities on that layer.</p><p>Let us take a look at the callback method for our player movement:</p><pre class="programlisting">void State_Game::PlayerMove(EventDetails* l_details){ 
  Message msg((MessageType)EntityMessage::Move); 
  if (l_details-&gt;m_name == "Player_MoveLeft"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Left); 
  } else if (l_details-&gt;m_name == "Player_MoveRight"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Right); 
  } else if (l_details-&gt;m_name == "Player_MoveUp"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Up); 
  } else if (l_details-&gt;m_name == "Player_MoveDown"){ 
    msg.m_int = static_cast&lt;int&gt;(Direction::Down); 
  } 
  msg.m_receiver = m_player; 
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt; 
    GetMessageHandler()-&gt;Dispatch(msg); 
} 
</pre><p>Whenever this is invoked, a new <code class="literal">Move</code> message is constructed. The direction it carries is set, based on the actual event name. After the receiving entity (the player) is stored, the message is dispatched.</p><p>Lastly, we have one callback and the state's activation method:</p><pre class="programlisting">void State_Game::MainMenu(EventDetails* l_details){ 
  m_stateMgr-&gt;SwitchTo(StateType::MainMenu); 
} 
 
void State_Game::Activate() { 
  auto map = m_stateMgr-&gt;GetContext()-&gt;m_gameMap; 
 
  m_player = map-&gt;GetPlayerId(); 
  map-&gt;Redraw(); 
} 
</pre><p>If the <em>Esc</em> key is pressed, we simply switch to the main menu state. If the state is then switched back to <code class="literal">Game</code>, the <code class="literal">Activate</code> method of it is invoked. We use that functionality to re-obtain the player ID, in case it changed.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>The main game class</h1></div></div></div><p>All we have left to do now is to put everything together. We're going to be using a <code class="literal">Game</code> class for that, so let's take a look at it:</p><pre class="programlisting">class Game{ 
public: 
  Game(); 
  ~Game(); 
  void Update(); 
  void Render(); 
  void LateUpdate(); 
  sf::Time GetElapsed(); 
  Window* GetWindow(); 
private: 
  void SetUpClasses(); 
  void SetUpECS(); 
  void SetUpStates(); 
  void RestartClock(); 
  sf::Clock m_clock; 
  sf::Time m_elapsed; 
  SharedContext m_context; 
  RandomGenerator m_rand; 
  Window m_window; 
  TextureManager m_textureManager; 
  FontManager m_fontManager; 
  AudioManager m_audioManager; 
  SoundManager m_soundManager; 
  GUI_Manager m_guiManager; 
  SystemManager m_systemManager; 
  EntityManager m_entityManager; 
  Map m_gameMap; 
  std::unique_ptr&lt;StateManager&gt; m_stateManager; 
}; 
</pre><p>This class holds all of the classes that we covered, so let us begin setting them up in the constructor:</p><pre class="programlisting">Game::Game() 
  : m_window("Chapter 2", sf::Vector2u(800, 600), false), 
  m_entityManager(&amp;m_systemManager, &amp;m_textureManager), 
  m_guiManager(m_window.GetEventManager(), &amp;m_context), 
  m_soundManager(&amp;m_audioManager), 
  m_gameMap(&amp;m_window, &amp;m_entityManager, &amp;m_textureManager) 
{ 
  SetUpClasses(); 
  SetUpECS(); 
  SetUpStates(); 
 
  m_fontManager.RequireResource("Main"); 
  m_stateManager-&gt;SwitchTo(StateType::Intro); 
} 
 
Game::~Game(){ m_fontManager.ReleaseResource("Main"); } 
</pre><p>The initializer list is used to set up whatever dependencies our classes have that need to be satisfied inside their constructors. The rest of the constructor body is used to invoke three private <em>setup</em> methods, as well as to require the main font that is to be used throughout the game, and switch to the <code class="literal">Intro</code> state.</p><p>We're going to need a couple of basic setters and getters from this class as well:</p><pre class="programlisting">sf::Time Game::GetElapsed(){ return m_clock.getElapsedTime(); } 
void Game::RestartClock(){ m_elapsed = m_clock.restart(); } 
Window* Game::GetWindow(){ return &amp;m_window; } 
</pre><p>With that out of the way, let us actually update all of our code:</p><pre class="programlisting">void Game::Update(){ 
  m_window.Update(); 
  m_stateManager-&gt;Update(m_elapsed); 
  m_guiManager.Update(m_elapsed.asSeconds()); 
  m_soundManager.Update(m_elapsed.asSeconds()); 
 
  GUI_Event guiEvent; 
  while (m_context.m_guiManager-&gt;PollEvent(guiEvent)){ 
    m_window.GetEventManager()-&gt;HandleEvent(guiEvent); 
  } 
} 
</pre><p>After the relevant managers are updated, the GUI events are polled and passed to the event manager to be handled.</p><p>Next, let us take a look at what needs to happen during the <code class="literal">Render</code> call:</p><pre class="programlisting">void Game::Render(){ 
  m_window.BeginDraw(); 
  // Render here. 
  m_stateManager-&gt;Draw(); 
  m_guiManager.Render(m_window.GetRenderWindow()); 
  m_window.EndDraw(); 
} 
</pre><p>This is fairly basic as well. Since we're going to always want to draw states, the state manager's <code class="literal">Draw</code> call is placed here. On top of that (quite literally), we're going to always draw the GUIs.</p><p>A nice little feature to have is a late update that can be used to process anything that can't go into regular updates:</p><pre class="programlisting">void Game::LateUpdate(){ 
  m_stateManager-&gt;ProcessRequests(); 
  RestartClock(); 
} 
</pre><p>The state manager's removal requests are processed here, in addition to the game clock being restarted.</p><p>One of the three private methods invoked in the constructor that helps us set up all the classes can be implemented like so:</p><pre class="programlisting">void Game::SetUpClasses() { 
  m_clock.restart(); 
  m_context.m_rand = &amp;m_rand; 
  srand(static_cast&lt;unsigned int&gt;(time(nullptr))); 
  m_systemManager.SetEntityManager(&amp;m_entityManager); 
 
  m_context.m_wind = &amp;m_window; 
  m_context.m_eventManager = m_window.GetEventManager(); 
  m_context.m_textureManager = &amp;m_textureManager; 
  m_context.m_fontManager = &amp;m_fontManager; 
  m_context.m_audioManager = &amp;m_audioManager; 
  m_context.m_soundManager = &amp;m_soundManager; 
  m_context.m_gameMap = &amp;m_gameMap; 
  m_context.m_systemManager = &amp;m_systemManager; 
  m_context.m_entityManager = &amp;m_entityManager; 
  m_context.m_guiManager = &amp;m_guiManager; 
 
  m_stateManager = std::make_unique&lt;StateManager&gt;(&amp;m_context); 
  m_gameMap.SetStateManager(m_stateManager.get()); 
} 
</pre><p>After the random number generator is seeded, we need to make sure to bind every single class to the shared context, in order to be able to access them anywhere a service locator pattern is relied upon.</p><p>Another set up function we invoked deals with setting up the entity component system:</p><pre class="programlisting">void Game::SetUpECS() { 
  m_entityManager.AddComponentType&lt;C_Position&gt;( 
    Component::Position); 
  m_entityManager.AddComponentType&lt;C_SpriteSheet&gt;( 
    Component::SpriteSheet); 
  m_entityManager.AddComponentType&lt;C_State&gt;(Component::State); 
  m_entityManager.AddComponentType&lt;C_Movable&gt;(Component::Movable); 
  m_entityManager.AddComponentType&lt;C_Controller&gt;( 
    Component::Controller); 
  m_entityManager.AddComponentType&lt;C_Collidable&gt;( 
    Component::Collidable); 
  m_entityManager.AddComponentType&lt;C_SoundEmitter&gt;( 
    Component::SoundEmitter); 
  m_entityManager.AddComponentType&lt;C_SoundListener&gt;( 
    Component::SoundListener); 
 
  m_systemManager.AddSystem&lt;S_State&gt;(System::State); 
  m_systemManager.AddSystem&lt;S_Control&gt;(System::Control); 
  m_systemManager.AddSystem&lt;S_Movement&gt;(System::Movement); 
  m_systemManager.AddSystem&lt;S_Collision&gt;(System::Collision); 
  m_systemManager.AddSystem&lt;S_SheetAnimation&gt;( 
    System::SheetAnimation); 
  m_systemManager.AddSystem&lt;S_Sound&gt;(System::Sound); 
  m_systemManager.AddSystem&lt;S_Renderer&gt;(System::Renderer); 
 
  m_systemManager.GetSystem&lt;S_Collision&gt;(System::Collision)-&gt; 
    SetMap(&amp;m_gameMap); 
  m_systemManager.GetSystem&lt;S_Movement&gt;(System::Movement)-&gt; 
    SetMap(&amp;m_gameMap); 
  m_systemManager.GetSystem&lt;S_Sound&gt;(System::Sound)-&gt; 
    SetUp(&amp;m_audioManager, &amp;m_soundManager); 
} 
</pre><p>Here, all of the component types and systems are added and set up for use. The collision and movement systems need to have access to the game map, while the sound system relies on the audio and sound managers.</p><p>The last bit of setup is related to states and their dependents:</p><pre class="programlisting">void Game::SetUpStates() { 
  m_stateManager-&gt;AddDependent(m_context.m_eventManager); 
  m_stateManager-&gt;AddDependent(&amp;m_guiManager); 
  m_stateManager-&gt;AddDependent(&amp;m_soundManager); 
  m_stateManager-&gt;RegisterState&lt;State_Intro&gt;(StateType::Intro); 
  m_stateManager-&gt;RegisterState&lt;State_MainMenu&gt;( 
    StateType::MainMenu); 
  m_stateManager-&gt;RegisterState&lt;State_Game&gt;(StateType::Game); 
} 
</pre><p>The event, GUI, and sound managers all rely on being kept up to date on all state changes, so they must be registered as dependents. Also, our three main state types that we will be using are registered as well, so that they can be created using the factory method inside the state manager.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec32"/>The final bit of code</h1></div></div></div><p>Lastly, the main entry point of our application is defined inside the main function, like so:</p><pre class="programlisting">void main(int argc, void** argv[]){ 
  // Program entry point. 
  { 
    Game game; 
    while(!game.GetWindow()-&gt;IsDone()){ 
      game.Update(); 
      game.Render(); 
      game.LateUpdate(); 
    } 
  } 
} 
</pre><p>After an instance of <code class="literal">Game</code> is set up, we begin a <code class="literal">while</code> loop that keeps running until the <code class="literal">Window</code> instance is closed. Inside the loop, we update the game, render it, and call the late update method as well, for all of those post-rendering tasks.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Summary</h1></div></div></div><p>With that, it's a good time to wrap up. If you have followed through to the end, congratulations! You have just built a basic, fully functioning game out of nothing but a couple of states, some components, and systems. This chapter, much like the one before, is quite condensed, so feel free to look through the code and feel comfortable with its structure.</p><p>In the next chapter, we're going to be focusing solely on implementing and using particle systems in order to really add some life to the bare-bones game we have made. See you there!</p></div></div></div></body></html>