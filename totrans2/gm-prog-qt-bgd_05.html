<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Graphics with Qt</h1></div></div></div><p>When it comes to graphics, we have so far been using only ready-made widgets for the user interface, which resulted in the crude approach of using buttons for a tic-tac-toe game. In this chapter, you will learn about much of what Qt has to offer with regard to custom graphics. This will let you not only create your own widgets, incorporating content that is entirely customized, but also integrate multimedia in your programs. You will also learn about employing your OpenGL skills to display fast 3D graphics. If you are not familiar with OpenGL, this chapter should give you a kick-start for further research in this topic. By the end of the chapter, you will be able to create 2D and 3D graphics for your games using classes offered by Qt and integrate them with the rest of the user interface.</p><p>When it comes to graphics, Qt splits this domain into two separate parts. One of them is raster graphics (used by widgets, for example). This part focuses on using high-level operations (such as drawing lines or filling rectangles) to manipulate colors of a grid of points that can be visualized on different devices, such as images or the display of your computer device. The other is vector graphics, which involves manipulating vertices, triangles, and textures. This is tailored for maximum speed of processing and display using hardware acceleration provided by modern graphics cards. Qt abstracts graphics by using the concept of a surface that it draws on. The surface (represented by the <code class="literal">QSurface</code> class) can be of one of two types—<code class="literal">RasterSurface</code> or <code class="literal">OpenGLSurface</code>. The surface can be further customized using the <code class="literal">QSurfaceFormat</code> class, but we will talk about that later as it is not important right now.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Raster painting</h1></div></div></div><p>When we talk about <a id="id235" class="indexterm"/>GUI frameworks, raster painting is usually associated with drawing on widgets. However, since Qt is something more than a GUI toolkit, the scope of raster painting that it offers is much broader.</p><p>In general, Qt's drawing architecture consists of three parts. The most important part is the device the drawing takes place on, represented by the <code class="literal">QPaintDevice</code> class. Qt provides a number of paint device subclasses such as <code class="literal">QWidget</code> or <code class="literal">QImage</code> and <code class="literal">QPrinter</code> or <code class="literal">QPdfWriter</code>. You can see that the approach for drawing on a widget and printing on a printer will be quite the same. The difference is in the second component of the architecture—the paint engine (<code class="literal">QPaintEngine</code>). The engine is responsible for performing the actual paint operations on a particular paint device. Different paint engines are used to draw on images and to print on printers. This is completely hidden from you as a developer, so you really don't need to worry about it.</p><p>For you, the most important piece is the third component—<code class="literal">QPainter</code>—which is an adapter for the whole painting framework. It contains a set of high-level operations that can be invoked on the paint device. Behind the scenes, the whole work is delegated to an appropriate paint engine. While talking about painting, we will be focusing solely on the painter object as any <a id="id236" class="indexterm"/>painting code can be invoked on any of the target devices only by using a painter initialized on a different paint device. This effectively makes painting in Qt device agnostic, like in the following example:</p><div><pre class="programlisting">void doSomePainting(QPainter *painter) {
  painter-&gt;drawLine(QPoint(0,0), QPoint(100, 40));
}</pre></div><p>The same code can be executed on a painter working on any possible <code class="literal">QPaintDevice</code> class, be it a widget, an image, or an OpenGL context (through the use of <code class="literal">QOpenGLPaintDevice</code>).</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Painter attributes</h2></div></div></div><p>The <code class="literal">QPainter</code> <a id="id237" class="indexterm"/>class has a rich API that can basically be divided into three groups of methods. The first group contains setters and getters for attributes of the painter. The second group consists of methods, with names starting with <code class="literal">draw</code> and <code class="literal">fill</code> that perform drawing operations on the device. The last group has other methods, mostly ones that allow manipulating the coordinate system of the painter.</p><p>Let's start with the attributes. The three most important ones are the font, pen, and brush. The first is an instance of the <code class="literal">QFont</code> class. It contains a large number of methods for controlling such font parameters as font family, style (italic or oblique), font weight, and font size (either in points or device-dependent pixels). All the parameters are self-explanatory, so we will not discuss them here in detail. It is important to note that <code class="literal">QFont</code> can use any font installed on the system. In case more control over fonts is required or a font that is not installed in the system needs to be used, one can take advantage of the <code class="literal">QFontDatabase</code> class. It provides information about available fonts (such as whether a particular font is scalable or bitmap or what writing systems it supports) and allows adding new fonts into the registry by loading their definitions directly from files.</p><p>An important class, when it comes to fonts, is the <code class="literal">QFontMetrics</code> class. It allows calculating how much space is needed to paint particular text using a font or calculates text eliding. The most common use case is to check how much space to allocate for a particular user-visible string, for example:</p><div><pre class="programlisting">QFontMetrics fm = painter.fontMetrics();
QRect rect = fm.boundingRect("Game Programming using Qt");</pre></div><p>This is especially useful when trying to determine <code class="literal">sizeHint</code> for a widget.</p><p>The pen and brush are two attributes that define how different drawing operations are performed. The pen defines the outline, and the brush fills the shapes drawn using the painter. The former is represented by the <code class="literal">QPen</code> class and the latter by <code class="literal">QBrush</code>. Each of them is really a set of parameters. The most simple one is the color defined either as a predefined global color enumeration value (such as <code class="literal">Qt::red</code> or <code class="literal">Qt::transparent</code>) or an instance of the <code class="literal">QColor</code> class. The effective color is made up of four attributes—three color components (red, green, and blue) and an optional alpha channel value that determines transparency of the color (the larger the value, the more opaque the color). By default, all components are expressed as 8-bit values (0 to 255) but can also be expressed as real values representing a percentage of the maximum saturation of the component; for example, 0.6 corresponds to 153 (<em>0.6*255</em>). For convenience, one of the <code class="literal">QColor</code> constructors <a id="id238" class="indexterm"/>accepts hexadecimal color codes used in HTML (with <code class="literal">#0000FF</code> being an opaque blue color) or even bare color names (for example, <code class="literal">blue</code>) from a predefined list of colors returned by a static function <code class="literal">QColor::colorNames()</code>. Once a color object is defined using RGB components, it can be queried using different color spaces (for example, CMYK or HSV). Also, a set of static methods are available that act as constructors for colors expressed in different color spaces. For example, to construct a clear magenta color, any of the following expressions can be used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">QColor("magenta")</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QColor("#FF00FF")</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QColor(255, 0, 255)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QColor::fromRgbF(1, 0, 1)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QColor::fromHsv(300, 255, 255)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QColor::fromCmyk(0, 255, 0, 0)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Qt::magenta</code></li></ul></div><p>Apart from the color, <code class="literal">QBrush</code> has two additional ways of expressing the fill of a shape. You can use <code class="literal">QBrush::setTexture()</code> to set a pixmap that will be used as a stamp or <code class="literal">QBrush::setGradient()</code> to make the brush use a gradient to do the filling. For example, to use a gradient that goes diagonally and starts yellow in the top-left corner of the shape, becomes red in the middle of the shape, and ends magenta at the bottom-right corner of the shape, the following code can be used:</p><div><pre class="programlisting">QLinearGradient gradient(0, 0, width, height);
gradient.setColorAt(0,   Qt::yellow);
gradient.setColorAt(0.5, Qt::red);
gradient.setColorAt(1.0, Qt::magenta);
QBrush brush = gradient;</pre></div><p>When used with <a id="id239" class="indexterm"/>drawing a rectangle, this code will give the following output:</p><div><img src="img/8874OS_05_01.jpg" alt="Painter attributes"/></div><p>Qt can handle linear (<code class="literal">QLinearGradient</code>), radial (<code class="literal">QRadialGradient</code>), and conical (<code class="literal">QConicalGradient</code>) gradients. It comes with a sample (shown in the following screenshot) where you can see different gradients in action. This sample is located in <code class="literal">examples/widgets/painting/gradients</code>.</p><div><img src="img/8874OS_05_02.jpg" alt="Painter attributes"/></div><p>As for the pen, its main attribute is its width (expressed in pixels), which determines the thickness of the shape outline. A special width setting is <code class="literal">0</code>, which constitutes a so-called cosmetic pen that is always drawn as a 1 pixel-wide line no matter what transformations are applied to the painter (we'll cover this later). A pen can of course have a color set but, in addition to that, you can use any brush as a pen. The result of such an operation is that you can draw thick outlines of shapes using gradients or textures.</p><p>There are three more <a id="id240" class="indexterm"/>important properties for a pen. The first of them is the pen style, set using <code class="literal">QPen::setStyle()</code>. It determines whether lines drawn by the pen are continuous or somehow divided (dashes, dots, and so on). You can see available line styles together with their corresponding constants in the following diagram:</p><div><img src="img/8874OS_05_03.jpg" alt="Painter attributes"/></div><p>The second attribute is the cap style, which can be flat, square, or round. The third attribute—the join style—is important for polyline outlines and dictates how different segments of the polyline are connected. You can make the joins sharp (with <code class="literal">Qt::MiterJoin</code>), round (<code class="literal">Qt::RoundJoin</code>), or a hybrid of the two (<code class="literal">Qt::BevelJoin</code>). You can see the different pen attribute configurations (including different join and cap styles) in action by launching <a id="id241" class="indexterm"/>the pathstroke example shown in the following screenshot:</p><div><img src="img/8874OS_05_04.jpg" alt="Painter attributes"/></div><p>The next important aspect of the painter is its coordinate system. The painter in fact has two coordinate systems. One is its own logical coordinate system that operates on real numbers, and the other is the physical coordinate system of the device the painter operates on. Each operation on the logical coordinate system is mapped to physical coordinates in the device and applied there. Let's start with explaining the logical coordinate system first, and then we'll see how this relates to physical coordinates.</p><p>The painter represents an infinite Cartesian canvas with the horizontal axis pointing right and the vertical axis pointing down by default. The system can be modified by applying affine transformations to it—translating, rotating, scaling, and shearing. This way, you can draw an analog clock face that marks each hour with a line by executing a loop that rotates the coordinate system by 30 degrees for each hour and draws a line that is vertical in the newly obtained coordinate system. Another example is when you wish to draw a simple plot with <em>x</em> axis going right and <em>y</em> axis going up. To obtain the proper coordinate system, you would scale the coordinate system by <code class="literal">-1</code> in the vertical direction, effectively reversing the direction of the vertical axis.</p><p>What we described here modifies the world transformation matrix for the painter represented by an instance of the <code class="literal">QTransform</code> class. You can always query the current state of the matrix by calling <code class="literal">transform()</code> on the painter and you can set a new matrix by calling <code class="literal">setTransform()</code>. <code class="literal">QTransform</code> has methods such as <code class="literal">scale()</code>, <code class="literal">rotate()</code>, and <code class="literal">translate()</code> that modify the matrix, but <code class="literal">QPainter</code> has equivalent methods for manipulating the world matrix directly. In most cases, using these would be preferable.</p><p>Each painting operation is expressed in logical coordinates, goes through the world transformation matrix, and reaches the second stage of coordinate manipulation, which is the view matrix. The painter has the concept of <code class="literal">viewport()</code> and <code class="literal">window()</code> rectangles. The <code class="literal">viewport</code> rectangle represents the physical coordinates of an arbitrary rectangle while the <code class="literal">window</code> rectangle expresses the same rectangle but in logical coordinates. Mapping one to another gives a transformation that needs to be applied to each drawn primitive to calculate the area of the physical device that is to be painted. By default, the two rectangles are identical to the rectangle of the underlying device (thus no <code class="literal">window</code>-<code class="literal">viewport</code> mapping is <a id="id242" class="indexterm"/>done). Such transformation is useful if you wish to perform painting operations using measurement units other than the pixels of the target device. For example, if you want to express coordinates using percentages of the width and height of the target device, you would set the window width and height both to <code class="literal">100</code>. Then, to draw a line starting at 20% of the width and 10% of the height and ending at 70% of the width and 30% of the height, you would tell the painter to draw the line between (<code class="literal">20</code>, <code class="literal">10</code>) and (<code class="literal">70</code>, <code class="literal">30</code>). If you wanted those percentages to apply not to the whole area of an image but rather to its left half, you set the viewport rectangle only to the left half of the image.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>Setting the <code class="literal">window</code> and <code class="literal">viewport</code> rectangles only defines coordinate mapping; it does not prevent drawing operations from painting outside the <code class="literal">viewport</code> rectangle. If you want such behavior, you have to set a <code class="literal">clipping</code> rectangle on the painter.</p></div></div><p>Once you have the painter properly set, you can start issuing painting operations. <code class="literal">QPainter</code> has a rich set of operations for drawing different kinds of primitives. All of these operations have the prefix <code class="literal">draw</code> in their names, followed by the name of the primitive that is to be drawn. Thus, such operations as <code class="literal">drawLine</code>, <code class="literal">drawRoundedRect</code>, and <code class="literal">drawText</code> are available with a number of overloads that usually allow us to express coordinates using different data types. These may be pure values (either integer or real), Qt's classes, such as <code class="literal">QPoint</code> and <code class="literal">QRect</code>, or their floating point equivalents—<code class="literal">QPointF</code> and <code class="literal">QRectF</code>. Each operation is performed using current painter settings (font, pen, and brush).</p><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>To see the list of all drawing operations available, switch to the <strong>Help</strong> pane in Qt Creator. From the drop-down list on top of the window, choose <strong>Index</strong> and then type in <code class="literal">qpainter</code>. After confirming the search, you should see the reference manual for the <code class="literal">QPainter</code> class with all the drawing operations listed.</p></div></div><p>Before you start drawing, you have to tell the painter what device you wish to draw on. This is done using the <code class="literal">begin()</code> and <code class="literal">end()</code> methods. The former accepts a pointer to a <code class="literal">QPaintDevice</code> instance and initializes the drawing infrastructure, and the latter marks the drawing as complete. Usually, we don't have to use these methods directly as the constructor of <code class="literal">QPainter</code> calls <code class="literal">begin()</code> for us and the destructor invokes <code class="literal">end()</code>. Thus, the typical workflow is to instantiate a painter object, passing it the device, then do the drawing by calling <code class="literal">set</code> and <code class="literal">draw</code> methods, and finally let the painter be destroyed by going out of scope, as follows:</p><div><pre class="programlisting">{
  QPainter painter(this); // paint on the current object
  QPen pen = Qt::red;
  pen.setWidth(2);
  painter.setPen(pen);
  painter.setBrush(Qt::yellow);
  painter.drawRect(0, 0, 100, 50);
}</pre></div><p>We will cover more <a id="id243" class="indexterm"/>methods from the <code class="literal">draw</code> family in the following sections of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Widget painting</h2></div></div></div><p>It is time to actually get <a id="id244" class="indexterm"/>something onto the screen by painting on a widget. A widget is repainted as a result of receiving an event called <code class="literal">QEvent::Paint</code>, which is handled by reimplementing the virtual method <code class="literal">paintEvent()</code>. This method accepts a pointer to the event object of type <code class="literal">QPaintEvent</code> that contains various bits of information about the repaint request. Remember that you can only paint on the widget from within that widget's <code class="literal">paintEvent()</code> call.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Time for action – custom-painted widgets</h1></div></div></div><p>Let's immediately <a id="id245" class="indexterm"/>use our new skills in practice!</p><p>Start by creating a new <strong>Qt Widgets Application</strong> in Qt Creator, choosing <code class="literal">QWidget</code> as the base class, and making sure the <strong>Generate Form</strong> box is unchecked.</p><p>Switch to the header file for the newly created class, add a protected section to the class and type void <code class="literal">paintEvent</code> for the section. Then press <em>Ctrl</em> + spacebar on your keyboard and Creator will suggest the parameters for the method. You should end up with the following code:</p><div><pre class="programlisting">protected:
    void paintEvent(QPaintEvent *);</pre></div><p>Creator will leave the cursor positioned right before the semicolon. Pressing <em>Alt</em> + <em>Enter</em> will open the refactoring menu, letting you add the definition in the implementation file. The standard code for a paint event is one that instantiates a painter on the widget, as shown:</p><div><pre class="programlisting">void Widget::paintEvent(QPaintEvent *)
{
  QPainter painter(this);
}</pre></div><p>If you run this code, the <a id="id246" class="indexterm"/>widget will remain blank. Now we can start adding the actual painting code there:</p><div><pre class="programlisting">void Widget::paintEvent(QPaintEvent *)
{
  QPainter painter(this);
<strong>  QPen pen(Qt::black);</strong>
<strong>  pen.setWidth(4);</strong>
<strong>  painter.setPen(pen);</strong>
<strong>  QRect r = rect().adjusted(10, 10, -10, -10);</strong>
<strong>  painter.drawRoundedRect(r, 20, 10);</strong>
}</pre></div><p>Build and run the code, and you'll obtain the following output:</p><div><img src="img/8874OS_05_06.jpg" alt="Time for action – custom-painted widgets"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>
<em>What just happened?</em>
</h2></div></div></div><p>First we set a 2 pixel-wide black pen for the painter. Then we called <code class="literal">rect()</code> to retrieve the geometry rectangle of the widget. By calling <code class="literal">adjusted()</code>, we received a new rectangle with its coordinates (in left, top, right, and bottom order) modified by the given arguments, effectively giving us a rectangle with a 10 pixel margin on each side.</p><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>Qt usually offers two methods that allow us to work with modified data. Calling <code class="literal">adjusted()</code> returns a new object with its attributes modified, while if we had called <code class="literal">adjust()</code>, the modification would have been done in place. Pay special attention to which method you use to avoid unexpected results. It's best to always check the return value for a method—whether it returns a copy or void.</p></div></div><p>Finally we call <code class="literal">drawRoundedRect()</code>, which paints a rectangle with its corners rounded by the number of pixels (in <em>x</em>, <em>y</em> order) given as the second and third argument. If you look closely, you will notice that the rectangle has nasty jagged rounded parts. This is caused by the effect of aliasing, where a logical line is approximated using the limited resolution of the screen; due to this, a pixel is either fully drawn or not drawn at all. Qt offers a mechanism called <a id="id247" class="indexterm"/>antialiasing to counter this effect by using intermediate pixel colors where appropriate. You can enable this mechanism by setting a proper render hint on the painter before you draw the rounded rectangle, as shown:</p><div><pre class="programlisting">void Widget::paintEvent(QPaintEvent *)
{
  QPainter painter(this);
<strong>  painter.setRenderHint(QPainter::Antialiasing, true);</strong>
  // …
}</pre></div><p>Now you'll get the following output:</p><div><img src="img/8874OS_05_07.jpg" alt="What just happened?"/></div><p>Of course, this has a negative impact on performance, so use antialiasing only where the aliasing effect is noticeable.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Time for action – transforming the viewport</h1></div></div></div><p>Let's extend our <a id="id248" class="indexterm"/>code so that all future operations focus only on drawing within the border boundaries after the border is drawn. Use the <code class="literal">window</code> and <a id="id249" class="indexterm"/>
<code class="literal">viewport</code> transformation as follows:</p><div><pre class="programlisting">void Widget::paintEvent(QPaintEvent *) {
  QPainter painter(this);
  painter.setRenderHint(QPainter::Antialiasing, true);
  QPen pen(Qt::black);
  pen.setWidth(4);
  painter.setPen(pen);
  QRect r = rect().adjusted(10, 10, -10, -10);
  painter.drawRoundedRect(r, 20, 10);
<strong>  painter.save();</strong>
<strong>  r.adjust(2, 2, -2, -2);</strong>
<strong>  painter.setViewport(r);</strong>
<strong>  r.moveTo(0, -r.height()/2);</strong>
<strong>  painter.setWindow(r);</strong>
<strong>  drawChart(&amp;painter, r);</strong>
<strong>  painter.restore();</strong>
}</pre></div><p>Also create a protected method called <code class="literal">drawChart()</code>:</p><div><pre class="programlisting">void Widget::drawChart(QPainter *painter, const QRect &amp;rect) {
  painter-&gt;setPen(Qt::red);
  painter-&gt;drawLine(0, 0, rect.width(), 0);
}</pre></div><p>Let's take a look <a id="id250" class="indexterm"/>at our output:</p><div><img src="img/8874OS_05_08.jpg" alt="Time for action – transforming the viewport"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>
<em>What just happened?</em>
</h2></div></div></div><p>The first thing we did in the newly added code is call <code class="literal">painter.save()</code>. This call stores all parameters of the painter in an internal stack. We can then modify the painter state (by changing its attributes, applying transformations, and so on) and then, if at any point we want to go back to the <a id="id251" class="indexterm"/>saved state, it is enough to call <code class="literal">painter.restore()</code> to undo all the modifications in one go.</p><div><div><h3 class="title"><a id="tip33"/>Tip</h3><p>The <code class="literal">save()</code> and <code class="literal">restore()</code> methods can be called as many times as needed. Just remember to always pair a call to <code class="literal">save()</code> with a similar call to <code class="literal">restore()</code>, or the internal painter state will get corrupted. Each call to <code class="literal">restore()</code> will revert the painter to the last saved state.</p></div></div><p>After the state is saved, we modify the rectangle again by adjusting for the width of the border. Then, we set the new rectangle as the viewport, informing the painter about the physical range of coordinates to operate on. Then we move the rectangle by half its height and set that as the painter window. This effectively puts the origin of the painter at half the height of the widget. Then, the <code class="literal">drawChart()</code> method is called whereby a red line is drawn on the <em>x</em> axis <a id="id252" class="indexterm"/>of the new coordinate <a id="id253" class="indexterm"/>system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Time for action – drawing an oscillogram</h1></div></div></div><p>Let's further <a id="id254" class="indexterm"/>extend our widget to become a simple oscillogram <a id="id255" class="indexterm"/>renderer. For that we have to make the widget remember a set of values and draw them as a series of lines.</p><p>Let's start by adding a <code class="literal">QList&lt;quint16&gt;</code> member variable that holds a list of unsigned 16-bit integer values. We will also add slots for adding values to the list and for clearing the list, as shown:</p><div><pre class="programlisting">class Widget : public QWidget
{
  // ...
<strong>public slots:</strong>
<strong>  void addPoint(unsigned yVal) { m_points &lt;&lt; qMax(0u, yVal); update(); }</strong>
<strong>  void clear() { m_points.clear(); update(); }</strong>
protected:
  // ...
<strong>  QList&lt;quint16&gt; m_points;</strong>
};</pre></div><p>Note that each modification of the list invokes a method called <code class="literal">update()</code>. This schedules a paint event so that our widget can be redrawn with the new values.</p><p>Drawing code is also easy; we just iterate over the list and draw symmetric blue lines based on the values from the list. Since the lines are vertical, they don't suffer from aliasing and so we can disable this render hint, as shown:</p><div><pre class="programlisting">void Widget::drawChart(QPainter *painter, const QRect &amp;rect) {
  painter-&gt;setPen(Qt::red);
  painter-&gt;drawLine(0, 0, rect.width(), 0);
<strong>  painter-&gt;save();</strong>
<strong>  painter-&gt;setRenderHint(QPainter::Antialiasing, false);</strong>
<strong>  painter-&gt;setPen(Qt::blue);</strong>
<strong>  for(int i=0;i &lt; m_points.size(); ++i) {</strong>
<strong>    painter-&gt;drawLine(i, -m_points.at(i), i, m_points.at(i));</strong>
<strong>  }</strong>
<strong>  painter-&gt;restore();</strong>
}</pre></div><p>To see the result add a loop to <code class="literal">main</code> as follows. This fills the widget with data:</p><div><pre class="programlisting">for(int i=0;i&lt;450;++i) w.addPoint(qrand() % 120);</pre></div><p>This loop takes a random number between <code class="literal">0</code> and <code class="literal">119</code> and adds it as a point to the widget. A sample result from <a id="id256" class="indexterm"/>running such code can be seen in the <a id="id257" class="indexterm"/>following screenshot:</p><div><img src="img/8874OS_05_09.jpg" alt="Time for action – drawing an oscillogram"/></div><div><div><h3 class="title"><a id="tip34"/>Tip</h3><p>If you scale down the window, you will notice that the oscillogram extends past the boundaries of the rounded rectangle. Remember about clipping? You can use it now to constrain drawing by adding a simple <code class="literal">painter.setClipRect(r)</code> call just before you call <code class="literal">drawChart()</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl3sec23"/>Input events</h2></div></div></div><p>So far, the custom widget <a id="id258" class="indexterm"/>was not interactive at all. Although the widget content could be manipulated from within the source code (say by adding new points to the plot), the widget was deaf to any user actions (apart from resizing the widget, which caused a repaint). In Qt, any interaction between the user and the widget is done by delivering events to the widget. Such a family of events is generally called input events and contains events such as keyboard events and different forms of pointing-device events—mouse, tablet, and touch events.</p><p>In a typical mouse event flow, a widget first receives a mouse press event, then a number of mouse move events (when the user moves the mouse around while the mouse button is kept pressed), and finally, a mouse release event. The widget can also receive an additional mouse double-click event in addition to these events. It is important to remember that, by default, mouse move events are only delivered if a mouse button is pressed when the mouse is moved. To receive mouse move events when no button is pressed, a widget needs to <a id="id259" class="indexterm"/>activate a feature called <strong>mouse tracking</strong>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Time for action – making oscillograms selectable</h1></div></div></div><p>It's time to make <a id="id260" class="indexterm"/>our oscillogram widget <a id="id261" class="indexterm"/>interactive. We will teach it to add a couple of lines of code to it that let the user select part of the plot. Let's start with storage for the selection. We'll need two integer variables that can be accessed via read-only properties; therefore, add the following two properties to the class (you can initialize them both to <code class="literal">-1</code>) and implement their getters:</p><div><pre class="programlisting">Q_PROPERTY(int selectionStart READ selectionStart NOTIFY selectionChanged)
Q_PROPERTY(int selectionEnd READ selectionEnd NOTIFY selectionChanged)</pre></div><p>The user can change the selection by dragging the mouse cursor over the plot. When the user presses the mouse button over some place in the plot, we'll mark that place as the start of the selection. Dragging the mouse will determine the end of the selection. The scheme for naming events is similar to the paint event; therefore, we need to declare and implement the following two protected methods:</p><div><pre class="programlisting">void Widget::mousePressEvent(QMouseEvent *mouseEvent) {
  m_selectionStart = m_selectionEnd = mouseEvent-&gt;pos().x() - 12;
  emit selectionChanged();
  update();
}
void Widget::mouseMoveEvent(QMouseEvent *mouseEvent) {
  m_selectionEnd = mouseEvent-&gt;pos().x() - 12;
  emit selectionChanged();
  update();
}</pre></div><p>The structure of both event handlers is similar. We update the needed values, taking into consideration the left padding (12 pixels) of the plot, similar to what we do while drawing. Then, a signal is emitted and <code class="literal">update()</code> is called to schedule a repaint of the widget.</p><p>What remains is to introduce changes to the drawing code. I suggest you add a <code class="literal">drawSelection()</code> method similar to <code class="literal">drawChart()</code> but that is called from the paint event handler immediately before <code class="literal">drawChart()</code>, as shown:</p><div><pre class="programlisting">void Widget::drawSelection(QPainter *painter, const QRect &amp;rect) {
  if(m_selectionStart &lt; 0 ) return;
  painter-&gt;save();
  painter-&gt;setPen(Qt::NoPen);
  painter-&gt;setBrush(palette().highlight());
  QRect selectionRect = rect;
  selectionRect.setLeft(m_selectionStart);
  selectionRect.setRight(m_selectionEnd);
  painter-&gt;drawRect(selectionRect);
  painter-&gt;restore();
}</pre></div><p>First we check if there is any selection to be drawn at all. Then, we save the painter state and adjust the pen and brush of the painter. The pen is set to <code class="literal">Qt::NoPen</code>, which means the painter should not draw any outline. To determine the brush, we use <code class="literal">palette()</code>; this returns an object of type <code class="literal">QPalette</code> holding basic colors for a widget. One of the colors held in the object is the color of the highlight often used for marking selections. If you use an entry from the palette instead of manually specifying a color, you gain an advantage that when the user of the <a id="id262" class="indexterm"/>class modifies the palette, this modification is taken into account <a id="id263" class="indexterm"/>by our widget code. </p><div><div><h3 class="title"><a id="tip35"/>Tip</h3><p>You can use other colors from the palette in the widget for other things we draw in the widget. You can even define your own <code class="literal">QPalette</code> object in the constructor of the widget to provide default colors for it.</p></div></div><p>Finally, we adjust the rectangle to be drawn and issue the drawing call.</p><p>When you run this program, you will notice that the selection color doesn't contrast very well with the plot itself. To overcome this, a common approach is to draw the "selected" content with a different (often inverted) color. This can easily be applied in this situation by modifying the <code class="literal">drawChart()</code> code slightly:</p><div><pre class="programlisting">for(int i=0; i &lt; m_points.size(); ++i) {
<strong>  if(m_selectionStart &lt;= i &amp;&amp; m_selectionEnd &gt;=i) {</strong>
<strong>    painter-&gt;setPen(Qt::white);</strong>
<strong>  } else</strong>
<strong>    painter-&gt;setPen(Qt::blue);</strong>
  painter-&gt;drawLine(i, -m_points.at(i), i, m_points.at(i));
}</pre></div><p>Now you see the following output:</p><div><img src="img/8874OS_05_10.jpg" alt="Time for action – making oscillograms selectable"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Have a go hero – reacting only to the left mouse button</h2></div></div></div><p>As an <a id="id264" class="indexterm"/>exercise, you can modify the event handling code so that it only changes the selection if the mouse event was triggered by the left mouse button. To see which button triggered the mouse press event, you can use the <code class="literal">QMouseEvent::button()</code> method, which returns <code class="literal">Qt::LeftButton</code> for the left button, <code class="literal">Qt::RightButton</code> for the right, and so on.</p><p>Handling touch events is different. For any such event, you receive a call to the <code class="literal">touchEvent()</code> virtual method. The parameter of such a call is an object that can retrieve a list of points currently touched by the user with additional information regarding the history of user interaction (whether the touch was just initiated or the point was pressed earlier and moved) and what force is applied to the point by the user. Note that this is a low-level framework that allows you to precisely follow the history of touch interaction. If you are more interested in higher-level gesture recognition (pan, pinch, and swipe), there is a separate family of events available for it.</p><p>Handling gestures is a two-step procedure. First you need to activate gesture recognition on your widget by calling <code class="literal">grabGesture()</code> and passing in the type of gesture you want to handle. A good place for such code is the widget constructor.</p><p>Then your widget will start receiving gesture events. There are no dedicated handlers for gesture events but, fortunately, all events for an object flow through its <code class="literal">event()</code> method, which we can reimplement. Here is some example code that handles pan gestures:</p><div><pre class="programlisting">bool Widget::event(QEvent *e) {
  if(e-&gt;type() == QEvent::Gesture) {
    QGestureEvent *gestureEvent = static_cast&lt;QGestureEvent*&gt;(e);
    QGesture *pan  = gestureEvent-&gt;gesture(Qt::PanGesture);
    if(pan) {
      handlePanGesture(static_cast&lt;QPanGesture*&gt;(pan));
    }
  }
  return QWidget::event(e);
}</pre></div><p>First, a check for the event type is made; if it matches the expected value, the event object is cast to <code class="literal">QGestureEvent</code>. Then, the event is asked if <code class="literal">Qt::PanGesture</code> was recognized. Finally, a <code class="literal">handlePanGesture</code> method is called. You can implement such a method to handle your pan gestures.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Working with images</h2></div></div></div><p>Qt has two <a id="id265" class="indexterm"/>classes for handling images. The first one is <code class="literal">QImage</code>, more tailored towards direct pixel manipulation. You can check the size of the image or check and modify the color of each pixel. You can convert the image into a different internal representation (say from 8-bit color map to full 32-bit color with a premultiplied alpha channel). This type, however, is not that fit for rendering. For that, we have a different class called <code class="literal">QPixmap</code>. The difference between the two classes is that <code class="literal">QImage</code> is always kept in the application memory, while <code class="literal">QPixmap</code> can only be a handle to a resource that may reside in the graphics card memory or on a remote <em>X</em> server. Its main advantage over <code class="literal">QImage</code> is that it can be rendered very quickly at the cost of the inability to access pixel data. You can freely convert between the two types but bear in mind that, on some platforms, this <a id="id266" class="indexterm"/>might be an expensive operation. Always consider which class serves your particular situation better. If you intend to crop the image, tint it with some color, or paint over it, <code class="literal">QImage</code> is a better choice. But if you just want to render a bunch of icons, it's best to keep them as <code class="literal">QPixmap</code> instances.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Loading</h3></div></div></div><p>Loading images is very <a id="id267" class="indexterm"/>easy. Both <code class="literal">QPixmap</code> and <code class="literal">QImage</code> have constructors that simply accept a path to a file containing the image. Qt accesses image data through plugins that implement reading and writing operations for different image formats. Without going into the details of plugins, it is enough to say that the default Qt installation supports reading the following image types:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>BMP</p>
</td><td style="text-align: left" valign="top">
<p>Windows bitmap</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GIF</p>
</td><td style="text-align: left" valign="top">
<p>Graphics Interchange Format</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ICO</p>
</td><td style="text-align: left" valign="top">
<p>Windows icon</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>JPEG</p>
</td><td style="text-align: left" valign="top">
<p>Joint Photography Experts Group</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MNG</p>
</td><td style="text-align: left" valign="top">
<p>Multiple-image Network Graphics</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PNG</p>
</td><td style="text-align: left" valign="top">
<p>Portable Network Graphics</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PPM/PBM/PGM</p>
</td><td style="text-align: left" valign="top">
<p>Portable anymap</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SVG</p>
</td><td style="text-align: left" valign="top">
<p>Scalable Vector Graphics</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TIFF</p>
</td><td style="text-align: left" valign="top">
<p>Tagged Image File Format</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>XBM</p>
</td><td style="text-align: left" valign="top">
<p>X Bitmap</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>XPM</p>
</td><td style="text-align: left" valign="top">
<p>X Pixmap</p>
</td></tr></tbody></table></div><p>As you can see, most popular image formats are available. The list can be further extended by installing additional plugins.</p><div><div><h3 class="title"><a id="tip36"/>Tip</h3><p>You can ask Qt for a list of supported image types by calling a static method, <code class="literal">QImageReader::supportedImageFormats()</code>, which returns a list of formats that can be read by Qt. For a list of writable formats, call <code class="literal">QImageWriter::supportedFileFormats()</code>.</p></div></div><p>An image can also be loaded directly from an existing memory buffer. This can be done in two ways. The first one is to use the <code class="literal">loadFromData()</code> method (it exists in both <code class="literal">QPixmap</code> and <code class="literal">QImage</code>), which behaves the same as when loading an image from a file—you pass it a data buffer and the size of the buffer and based on that, the loader determines the image type by inspecting the header data and loads the picture into <code class="literal">QImage</code> or <code class="literal">QPixmap</code>. The second situation is when you don't have images stored in a "filetype" such as JPEG or PNG but rather you have raw pixel data itself. In such a situation, <code class="literal">QImage</code> offers a constructor that takes a pointer to a block of data together with the size of the image and format of the data. The format is not a file format such as the ones listed earlier but rather <a id="id268" class="indexterm"/>a memory layout for data representing a single pixel.</p><p>The most popular format is <code class="literal">QImage::Format_ARGB32</code>, which means that each pixel is represented by 32-bits (4 bytes) of data divided equally between alpha, red, green, and blue channels—8-bits per channel. Another popular format is <code class="literal">QImage::Format_ARGB32_Premultiplied</code>, where values for the red, green, and blue channels are stored after being multiplied by the value of the alpha channel, which often results in faster rendering. You can change the internal data representation using a call to <code class="literal">convertToFormat()</code>. For example, the following code converts a true-color image to 256 colors, where color for each pixel is represented by an index in a color table:</p><div><pre class="programlisting">QImage trueColor(image.png);
QImage indexed = trueColor.convertToFormat(QImage::Format_Indexed8);</pre></div><p>The color table itself is a vector of color definitions that can be fetched using <code class="literal">colorTable()</code> and replaced using <code class="literal">setColorTable()</code>. The simplest way to convert an indexed image to grayscale is to adjust its color table as follows:</p><div><pre class="programlisting">QImage indexed = …;
QVector&lt;QRgb&gt; ct = indexed.colorTable();
for(int i=0;i&lt;ct.size();++i) ct[i] = qGray(ct[i]);
indexed.setColorTable(ct);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Modifying</h3></div></div></div><p>There are two ways <a id="id269" class="indexterm"/>to modify image pixel data. The first one works only for <code class="literal">QImage</code> and involves direct manipulation of pixels using the <code class="literal">setPixel()</code> call, which takes the pixel coordinates and color to be set for that pixel. The second one works for both <code class="literal">QImage</code> and <code class="literal">QPixmap</code> and makes use of the fact that both these classes are subclasses of <code class="literal">QPaintDevice</code>. Therefore, you can open <code class="literal">QPainter</code> on such objects and use its drawing API. Here is an example of obtaining a pixmap with a blue rectangle and red circle painted over it:</p><div><pre class="programlisting">QPixmap px(256, 256);
px.fill(Qt::transparent);
QPainter painter(&amp;px);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::blue);
QRect r = px.rect().adjusted(10, 10, -10, -10);
painter.drawRect(r);
painter.setBrush(Qt::red);
painter.drawEllipse(r);</pre></div><p>First we create a 256 x 256 pixmap and fill it with transparent color. Then we open a painter on it and invoke a series of calls that draws a blue rectangle and red circle.</p><p>
<code class="literal">QImage</code> also offers a <a id="id270" class="indexterm"/>number of methods for transforming the image, including <code class="literal">scaled()</code>, <code class="literal">mirrored()</code>, <code class="literal">transformed()</code>, and <code class="literal">copy()</code>. Their API is intuitive so we won't discuss them here.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec26"/>Painting</h3></div></div></div><p>Painting images in <a id="id271" class="indexterm"/>its basic form is as simple as calling <code class="literal">drawImage()</code> or <code class="literal">drawPixmap()</code> from the <code class="literal">QPainter</code> API. There are different variants of the two methods, but basically all of them allow one to specify which portion of a given image or pixmap is to be drawn and where. It is worth noting that painting pixmaps is preferred to painting images as an image has to first be converted into a pixmap before it can be drawn.</p><p>If you have a lot of pixmaps to draw, a class called <code class="literal">QPixmapCache</code> may come in handy. It provides an application-wide cache for pixmaps. By using it, you can speed up pixmap loading while introducing a cap on memory usage.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Painting text</h2></div></div></div><p>Drawing text using <a id="id272" class="indexterm"/>
<code class="literal">QPainter</code> deserves a separate explanation, not because it is complicated but rather because Qt offers much flexibility in this regard. In general, painting text takes place by calling <code class="literal">QPainter::drawText()</code> or <code class="literal">QPainter::drawStaticText()</code>. Let's focus on the former first, which allows the drawing of generic text.</p><p>The most basic call to paint some text is a variant of this method, which takes <em>x</em> and <em>y</em> coordinates and the text to draw:</p><div><pre class="programlisting">painter.drawText(10, 20, "Drawing some text at (10, 20)");</pre></div><p>The preceding call draws the given text at position 10 horizontally and places the baseline of the text at position 20 vertically. The text is drawn using the painter's current font and pen. The coordinates can alternatively be passed as <code class="literal">QPoint</code> instances instead of being given <em>x</em> and <em>y</em> values separately. The problem with this method is that it allows little control over how the text is drawn. A much more flexible variant is one that lets us give a set of flags and expresses the position of the text as a rectangle instead of a point. The flags can specify alignment of the text within the given rectangle or instruct the rendering engine about wrapping <a id="id273" class="indexterm"/>and clipping the text. You can see the result of giving a different combination of flags to the call in the following image:</p><div><img src="img/8874OS_05_12.jpg" alt="Painting text"/></div><p>In order to obtain each of the preceding results, run code similar to the following:</p><div><pre class="programlisting">painter.drawText(rect, Qt::AlignLeft|Qt::TextShowMnemonic, "&amp;ABC");</pre></div><p>You can see that, unless you set the <code class="literal">Qt::TextDontClip</code> flag, the text is clipped to the given rectangle; setting <code class="literal">Qt::TextWordWrap</code> enables line wrapping and <code class="literal">Qt::TextSingleLine</code> makes the engine ignore any newline characters encountered.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec27"/>Static text</h3></div></div></div><p>Qt has to perform a number of calculations when laying out the text, and this has to be done each time the text is rendered. This will be a waste of time if the text and its attributes have not changed since the last time. To avoid the need to recalculate the layout, the concept of static text was introduced.</p><p>To use it, instantiate <a id="id274" class="indexterm"/>
<code class="literal">QStaticText</code> and initialize it with text you want to render along with any options you might want it to have (kept as the <code class="literal">QTextOption</code> instance). Then, store the object somewhere and, whenever you want the text to be rendered, just call <code class="literal">QPainter::drawStaticText()</code>, passing the static text object to it. If the layout of the text has not changed since the previous time the text was drawn, it will not be recalculated, resulting in improved performance. Here is an example of a custom widget that <a id="id275" class="indexterm"/>simply draws text using the static text approach:</p><div><pre class="programlisting">class TextWidget : public QWidget {
public:
  TextWidget(QWidget *parent = 0) : QWidget(parent) {}
  void setText(const QString &amp;txt) {
    m_staticText.setText(txt);
    update();
  }
protected:
  void paintEvent(QPaintEvent *) {
    QPainter painter(this);
    paitner.drawStaticText(0, 0, m_staticText);
  }
private:
  QStaticText m_staticText;
};</pre></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec28"/>Rich text</h3></div></div></div><p>So far, we have seen <a id="id276" class="indexterm"/>how to draw text where all the glyphs were rendered using the same attributes (font, color, and style) and laid out as a contiguous flow of characters. While useful, this doesn't handle situations where we want to mark out portions of the text using a different color or align it differently. To make it work, we would have to execute a series of <code class="literal">drawText</code> calls with modified painter attributes and with manually calculated text positions. Fortunately, there are better solutions.</p><p>Qt supports complex document formatting using its <code class="literal">QTextDocument</code> class. With this we can manipulate the text in a fashion similar to that of a text processor, applying formatting to paragraphs of text or individual characters. Then we can lay out and render the resulting document according to our needs.</p><p>While useful and powerful, building <code class="literal">QTextDocument</code> is too complicated if all we want is to draw a small amount of text with simple customizations applied. The authors of Qt have thought about that as well and have implemented a rich text mode for rendering text. After enabling this mode, you can specify the formatted text to <code class="literal">drawText</code> directly using a subset of HTML tags to obtain formatting effects such as changing the color of the text, underlining it, or making it superscript. Drawing a centered underlined caption followed by a fully justified description in a given rectangle is as easy as issuing the following call:</p><div><pre class="programlisting">painter.drawText(rect,
  "&lt;div align='center'&gt;&lt;b&gt;Disclaimer&lt;/b&gt;&lt;/div&gt;"
  "&lt;div align='justify'&gt;You are using &lt;i&gt;this software&lt;/i&gt; "
  "at your own risk. The authors of the software do not give "
  "any warranties that using this software will not ruin your "
  "business.&lt;/div&gt;");</pre></div><div><div><h3 class="title"><a id="tip37"/>Tip</h3><p>Qt's rich text engine does not implement the full HTML specification; it will not handle cascading style sheets, hyperlinks, tables, or JavaScript. The <em>Supported HTML Subset</em> page in the Qt reference manual describes what parts of the HTML 4 standard are supported. If you require full HTML support, you will have to use Qt's web page and web <a id="id277" class="indexterm"/>browser classes contained in the <code class="literal">webkitwidgets</code> (classes <code class="literal">QWebPage</code> and <code class="literal">QWebView</code>) or <code class="literal">webenginewidgets</code> (classes <code class="literal">QWebEnginePage</code> and <code class="literal">QWebEngineView</code>) modules.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Optimized drawing</h2></div></div></div><p>During game <a id="id278" class="indexterm"/>programming, performance is often a bottleneck. Qt tries its best to be as efficient as possible, but sometimes the code needs additional tweaking to work even faster. Using static text instead of regular text is one such tweak; use it whenever possible.</p><p>Another important trick is to avoid re-rendering the whole widget unless really required. One thing is that the <code class="literal">QPaintEvent</code> object passed to <code class="literal">paintEvent()</code> contains information about the region of the widget that needs to be redrawn. If the logic of your widget allows it, you can optimize the process by rendering only the required part.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Time for action – optimizing oscillogram drawing</h1></div></div></div><p>As an <a id="id279" class="indexterm"/>exercise, we will modify our oscillogram widget so that it only re-renders the part of its data that is required. The first step is to modify the <a id="id280" class="indexterm"/>paint event handling code to fetch information about the region that needs updating and pass it to the method drawing the chart. The changed parts of the code have been highlighted here:</p><div><pre class="programlisting">void Widget::paintEvent(<strong>QPaintEvent *pe</strong>)
{
<strong>  QRect exposedRect = pe-&gt;rect();</strong>
  ...
<strong>  drawSelection(&amp;painter, r, exposedRect);</strong>
<strong>  drawChart(&amp;painter, r, exposedRect);</strong>
  painter.restore();
}</pre></div><p>The next step is to modify <code class="literal">drawSelection()</code> to only draw the part of the selection that intersects with the exposed rectangle. Luckily, <code class="literal">QRect</code> offers a method to calculate the intersection for us:</p><div><pre class="programlisting">void Widget::drawSelection(QPainter *painter, const QRect &amp;rect, <strong>const QRect &amp;exposedRect</strong>)
{
    // ...
    QRect selectionRect = rect;
    selectionRect.setLeft(m_pressX);
    selectionRect.setRight(m_releaseX);
<strong>    painter-&gt;drawRect(selectionRect.intersected(exposedRect));</strong>
    painter-&gt;restore();
}</pre></div><p>Finally, <code class="literal">drawChart</code> <a id="id281" class="indexterm"/>needs to be adjusted to omit the <a id="id282" class="indexterm"/>values outside the exposed rectangle:</p><div><pre class="programlisting">void Widget::drawChart(QPainter *painter, const QRect &amp;rect, <strong>const QRect &amp;exposedRect</strong>)
{
  painter-&gt;setPen(Qt::red);
<strong>  painter-&gt;drawLine(exposedRect.left(), 0, exposedRect.width(), 0);</strong>
  painter-&gt;save();
  painter-&gt;setRenderHint(QPainter::Antialiasing, false);
<strong>  const int lastPoint = qMin(m_points.size(), exposedRect.right()+1);</strong>
<strong>  for(int i=exposedRect.left(); i &lt; lastPoint; ++i) {</strong>
    if(m_selectionStart &lt;= i &amp;&amp; m_selectionEnd &gt;=i) {
      painter-&gt;setPen(Qt::white);
    } else
    painter-&gt;setPen(Qt::blue);
    painter-&gt;drawLine(i, -m_points.at(i), i, m_points.at(i));
  }
    painter-&gt;restore();
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>
<em>What just happened?</em>
</h2></div></div></div><p>By implementing these changes, we have effectively reduced the painted area to the rectangle received with the event. In this particular situation, we will not save much time as drawing the plot is not that time-consuming; in many situations, however, you will be able to save a lot of time using this approach. For example, if we were to plot a very detailed aerial map of a game world, it would be very expensive to replot the whole map if only a small part of it were modified. We can easily reduce the number of calculations and drawing calls by taking advantage of the information about the exposed area.</p><p>Making use of the exposed rectangle is already a good step towards efficiency, but we can go a step further. The current approach requires that we redraw each and every line of the plot within the exposed rectangle, which still takes some time. Instead, we can paint those lines only once into a pixmap, and then, whenever the widget needs repainting, tell Qt to render part of the pixmap to the widget. This approach is usually called "double-buffering" (the second buffer being the pixmap acting as a cache).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Have a go hero – implementing a double-buffered oscillogram</h2></div></div></div><p>It should <a id="id283" class="indexterm"/>be very easy for you now to implement <a id="id284" class="indexterm"/>this approach for our example widget. The main difference is that each change to the plot contents should not result in a call to <code class="literal">update()</code> but rather in a call that will re-render the pixmap and then call <code class="literal">update()</code>. The <code class="literal">paintEvent</code> method then becomes simply this:</p><div><pre class="programlisting">void Widget::paintEvent(QPaintEvent *pe)
{
  QRect exposedRect = pe-&gt;rect();
  QPainter painter(this);
  painter.drawPixmap(exposedRect, pixmap(), exposedRect);
}</pre></div><p>You'll also need to re-render the pixmap when the widget is resized. This can be done from within the void <code class="literal">resizeEvent(QResizeEvent*)</code> method.</p><p>At this point, you are ready to employ your newly gained skills in rendering graphics with Qt to create a game that uses widgets with custom graphics. The hero of today is going to be chess and other chess-like games.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Time for action – developing the game architecture</h1></div></div></div><p>Create a new <a id="id285" class="indexterm"/>
<strong>Qt Widgets Application</strong> project. After the project infrastructure is ready, choose <strong>New File or Project</strong> from the <strong>File</strong> menu and choose to create a <strong>C++ Class</strong>. Call the new class <code class="literal">ChessBoard</code> and set <code class="literal">QObject</code> as its base class. Repeat the process to create a <code class="literal">GameAlgorithm</code> class derived from <code class="literal">QObject</code> and another one called <code class="literal">ChessView</code> but, this time, choose <code class="literal">QWidget</code> as the base class. You should end up with a file named <code class="literal">main.cpp</code> and four classes—<code class="literal">MainWindow</code>, <code class="literal">ChessView</code>, <code class="literal">ChessBoard</code>, and <code class="literal">ChessAlgorithm</code>.</p><p>Now navigate to the header file for <code class="literal">ChessAlgorithm</code> and add the following methods to the class:</p><div><pre class="programlisting">public:
  ChessBoard* board() const;
public slots:
  virtual void newGame();
signals:
  void boardChanged(ChessBoard*);
protected:
  virtual void setupBoard();
  void setBoard(ChessBoard *board);</pre></div><p>Also, add a private <code class="literal">m_board</code> field of type <code class="literal">ChessBoard*</code>. Remember to either include <code class="literal">chessboard.h</code> or forward-declare the <code class="literal">ChessBoard</code> class. Implement <code class="literal">board()</code> as a simple getter method for <code class="literal">m_board</code>. The <code class="literal">setBoard()</code> method is going to be a protected setter for <code class="literal">m_board</code>:</p><div><pre class="programlisting">void ChessAlgorithm::setBoard(ChessBoard *board)
{
    if(board == m_board) return;
    if(m_board) delete m_board;
    m_board = board;
    emit boardChanged(m_board);
}</pre></div><p>Next, let's <a id="id286" class="indexterm"/>provide a base implementation for <code class="literal">setupBoard()</code> to create a default chess board with eight ranks and eight columns:</p><div><pre class="programlisting">void ChessAlgorithm::setupBoard()
{
    setBoard(new ChessBoard(8,8, this));
}</pre></div><p>The natural place to prepare the board is in a function executed when a new game is started:</p><div><pre class="programlisting">void ChessAlgorithm::newGame()
{
    setupBoard();
}</pre></div><p>The last addition to this class for now is to extend the provided constructor to initialize <code class="literal">m_board</code> to a null pointer.</p><p>In the last method shown, we instantiated a <code class="literal">ChessBoard</code> object so let's focus on that class now. First extend the constructor to accept two additional integer parameters besides the regular parent argument. Store their values in private <code class="literal">m_ranks</code> and <code class="literal">m_columns</code> fields (remember to declare the fields themselves in the class header file).</p><p>In the header file, just under the <code class="literal">Q_OBJECT</code> macro, add the following two lines as property definitions:</p><div><pre class="programlisting">  Q_PROPERTY(int ranks READ ranks NOTIFY ranksChanged)
  Q_PROPERTY(int columns READ columns NOTIFY columnsChanged)</pre></div><p>Declare signals and implement getter methods to cooperate with those definitions. Also add two protected methods:</p><div><pre class="programlisting">protected:
    void setRanks(int newRanks);
    void setColumns(int newColumns);</pre></div><p>These will be setters for ranks and columns properties, but we don't want to expose them to the outside world so we will give them <code class="literal">protected</code> access scope.</p><p>Put the following code into the <code class="literal">setRanks()</code> method body:</p><div><pre class="programlisting">void ChessBoard::setRanks(int newRanks)
{
    if(ranks() == newRanks) return;
    m_ranks = newRanks;
    emit ranksChanged(m_ranks);
}</pre></div><p>Next, in a similar way, you can implement <code class="literal">setColumns()</code>.</p><p>The last class we will deal with now is our custom widget, <code class="literal">ChessView</code>. For now, we will provide only a rudimentary implementation for one method, but we will expand it later as our <a id="id287" class="indexterm"/>implementation grows. Add a public <code class="literal">setBoard(ChessBoard *)</code> method with the following body:</p><div><pre class="programlisting">void ChessView::setBoard(ChessBoard *board)
{
    if(m_board == board) return;

    if(m_board) {
    // disconnect all signal-slot connections between m_board and this
        m_board-&gt;disconnect(this);
    }
    m_board = board;
    // connect signals (to be done later)
    updateGeometry();
}</pre></div><p>Now let's declare the <code class="literal">m_board</code> member. Because we are not the owners of the board object (the algorithm class is responsible for managing it) we will use the <code class="literal">QPointer</code> class, which tracks the lifetime of <code class="literal">QObject</code> and sets itself to null once the object is destroyed:</p><div><pre class="programlisting">private:
  QPointer&lt;ChessBoard&gt; m_board;</pre></div><p>
<code class="literal">QPointer</code> initializes its value to null, so we don't have to do it ourselves in the constructor. For completeness, let's provide a getter method for the board:</p><div><pre class="programlisting">ChessBoard *ChessView::board() const { return m_board; }</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the last exercise, we defined the base architecture for our solution. We can see that there are three classes involved: <code class="literal">ChessView</code> acting as the user interface, <code class="literal">ChessAlgorithm</code> for driving the actual game, and <code class="literal">ChessBoard</code> as a data structure shared between the view and the engine. The algorithm is going to be responsible for setting up the board (through <code class="literal">setupBoard()</code>), making moves, checking win conditions, and so on. The view will be rendering the current state of the board and will signal user interaction to the underlying logic.</p><div><img src="img/8874OS_05_17.jpg" alt="What just happened?"/></div><p>Most of the code is self-explanatory. You can see in the <code class="literal">ChessView::setBoard()</code> method that we are disconnecting all signals from an old board object, attaching the new one (we will come back to connecting the signals later when we have already defined them), and finally <a id="id288" class="indexterm"/>telling the widget to update its size and redraw itself with the new board.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Time for action – implementing the game board class</h1></div></div></div><p>Now we will <a id="id289" class="indexterm"/>focus on our data structure. Add a new private member to <code class="literal">ChessBoard</code>, a vector of characters that will contain information about pieces on the board:</p><div><pre class="programlisting">QVector&lt;char&gt; m_boardData;</pre></div><p>Consider the following table that shows the piece type and the letters used for it:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="2" style="text-align: center" valign="bottom">
<p>Piece type</p>
</th><th style="text-align: left" valign="bottom">
<p>White</p>
</th><th style="text-align: left" valign="bottom">
<p>Black</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><img src="img/Image_05_01.JPG" alt="Time for action – implementing the game board class"/></div>
</td><td style="text-align: left" valign="top">
<p>King</p>
</td><td style="text-align: left" valign="top">
<p>K</p>
</td><td style="text-align: left" valign="top">
<p>k</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p> </p><div><img src="img/Image_05_02.JPG" alt="Time for action – implementing the game board class"/></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>Queen</p>
</td><td style="text-align: left" valign="top">
<p>Q</p>
</td><td style="text-align: left" valign="top">
<p>q</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>  </p><div><img src="img/Image_05_03.JPG" alt="Time for action – implementing the game board class"/></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>Rook</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>r</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p> </p><div><img src="img/Image_05_04.JPG" alt="Time for action – implementing the game board class"/></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>Bishop</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>  </p><div><img src="img/Image_05_05.JPG" alt="Time for action – implementing the game board class"/></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>Knight</p>
</td><td style="text-align: left" valign="top">
<p>N</p>
</td><td style="text-align: left" valign="top">
<p>n</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>   </p><div><img src="img/Image_05_06.JPG" alt="Time for action – implementing the game board class"/></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>Pawn</p>
</td><td style="text-align: left" valign="top">
<p>P</p>
</td><td style="text-align: left" valign="top">
<p>P</p>
</td></tr></tbody></table></div><p>You can see that white pieces use upper-case letters and black pieces use lower-case variants of the same letters. In addition to that, we will use a space character (0x20 ASCII value) to denote that a field is empty. We will add a protected method for setting up an empty board <a id="id290" class="indexterm"/>based on the number of ranks and columns on the board and a <code class="literal">boardReset()</code> signal to inform that the position on the board has changed:</p><div><pre class="programlisting">void ChessBoard::initBoard()
{
  m_boardData.fill(' ', ranks()*columns());
  emit boardReset();
}</pre></div><p>We can update our methods for setting rank and column counts to make use of that method:</p><div><pre class="programlisting">void ChessBoard::setRanks(int newRanks)
{
  if(ranks() == newRanks) return;
  m_ranks = newRanks;
<strong>  initBoard();</strong>
  emit ranksChanged(m_ranks);
}

void ChessBoard::setColumns(int newColumns)
{
  if(columns() == newColumns) return;
  m_columns = newColumns;
<strong>  initBoard();</strong>
  emit columnsChanged(m_columns);
}</pre></div><p>The <code class="literal">initBoard()</code> method should also be called from within the constructor, so place the call there as well.</p><p>Next, we need a method to read which piece is positioned in the particular field of the board.</p><div><pre class="programlisting">char ChessBoard::data(int column, int rank) const
{ 
  return m_boardData.at((rank-1)*columns()+(column-1)); 
}</pre></div><p>Ranks and <a id="id291" class="indexterm"/>columns have indexes starting from 1, but the data structure is indexed starting from 0; therefore, we have to subtract 1 from both the rank and column index. It is also required to have a method to modify the data for the board. Implement the following public method:</p><div><pre class="programlisting">void ChessBoard::setData(int column, int rank, char value)
{
  if(setDataInternal(column, rank, value))
    emit dataChanged(column, rank);
}</pre></div><p>The method makes use of another one that does the actual job. However, this method should be declared with <code class="literal">protected</code> access scope. Again we adjust for index differences.</p><div><pre class="programlisting">bool ChessBoard::setDataInternal(int column, int rank, char value)
{
  int index = (rank-1)*columns()+(column-1);
  if(m_boardData.at(index) == value) return false;
  m_boardData[index] = value;
  return true;
}</pre></div><p>Since <code class="literal">setData()</code> makes use of a signal, we have to declare it as well:</p><div><pre class="programlisting">signals:
  void ranksChanged(int);
  void columnsChanged(int);
<strong>  void dataChanged(int c, int r);</strong>
  void boardReset();</pre></div><p>The signal will be emitted every time there is a successful change to the situation on the board. We delegate the actual work to the protected method to be able to modify the board without emitting the signal.</p><p>Having defined <code class="literal">setData()</code>, we can add another method for our convenience:</p><div><pre class="programlisting">void ChessBoard::movePiece(int fromColumn, int fromRank, int toColumn, int toRank)
{
  setData(toColumn, toRank, data(fromColumn, fromRank));
  setData(fromColumn, fromRank, ' ');
}</pre></div><p>Can you guess what it does? That's right! It moves a piece from one field to another one leaving an empty space behind.</p><p>There is still one more method worth implementing. A regular chess game contains 32 pieces, and there are variants of the game where starting positions for the pieces might be different. Setting the position of each piece through a separate call to <code class="literal">setData()</code> would be very cumbersome. Fortunately, there is a neat chess notation called the <strong>Forsyth-Edwards Notation</strong> (<strong>FEN</strong>), with which the complete state of the game can be stored as a single line of text. If you want the complete definition of the notation, you can look it up yourself. In short, we can say that the textual string lists piece placement rank by rank, starting from the <a id="id292" class="indexterm"/>last rank where each position is described by a single character interpreted as in our internal data structure (<code class="literal">K</code> for white king, <code class="literal">q</code> for black queen, and so on). Each rank description is separated by a <code class="literal">/</code> character. If there are empty fields on the board, they are not stored as spaces but rather as a digit specifying the number of consecutive empty fields. Therefore, the starting position for a standard game can be written as follows:</p><div><pre class="programlisting">"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"</pre></div><p>This can be interpreted visually as follows:</p><div><img src="img/8874OS_05_18.jpg" alt="Time for action – implementing the game board class"/></div><p>Let's write a <a id="id293" class="indexterm"/>method called <code class="literal">setFen()</code> to set up the board based on an FEN string:</p><div><pre class="programlisting">void ChessBoard::setFen(const QString &amp;fen)
{
  int index = 0;
  int skip = 0;
  const int columnCount = columns();
  QChar ch;
  for(int rank = ranks(); rank &gt;0; --rank) {
    for(int column = 1; column &lt;= columnCount; ++column) {
      if(skip &gt; 0) {
        ch = ' ';
        skip--;
      } else {
        ch = fen.at(index++);
        if(ch.isDigit()) {
          skip = ch.toLatin1()-'0';
          ch = ' ';
          skip--;
        }
      }
      setDataInternal(column, rank, ch.toLatin1());
    }
    QChar next = fen.at(index++);
    if(next != '/' &amp;&amp; next != ' ') {
      initBoard();
      return; // fail on error
    }
  }
  emit boardReset();
}</pre></div><p>The method iterates over all fields on the board and determines whether it is currently in the middle of inserting empty fields on the board or should rather read the next character from the string. If a digit is encountered, it is converted into an integer by subtracting the ASCII value of the 0 character (that is, <em>7-0 = 7</em>). After setting each rank, we require that a slash or a space be read from the string. Otherwise, we reset the board to an empty one and bail out of the method.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>
<em>What just happened?</em>
</h2></div></div></div><p>We taught the <code class="literal">ChessBoard</code> class to store simple information about chess pieces using a one-dimensional array of characters. We also equipped it with methods that allow querying and modifying game data. We implemented a fast way of setting the current state of the game by adopting the FEN standard. The game data itself is not tied to classic chess. Although we comply with a standard notation for describing pieces, it is possible to use other letters and characters outside the well-defined set for chess pieces. This creates a versatile solution for storing information about chess-like games, such as checkers, and possibly any other custom game played on a two-dimensional board of any size with ranks and columns. The data structure we came up with is not a stupid one—it communicates with <a id="id294" class="indexterm"/>its environment by emitting signals when the state of the game is modified.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Time for action – understanding the ChessView class</h1></div></div></div><p>This is a chapter <a id="id295" class="indexterm"/>about doing graphics, so it is high time to focus on displaying our chess game. Our widget currently displays nothing, and our first task is going to be to show a chess board with rank and column symbols and fields colored appropriately.</p><p>By default, the widget does not have any proper size defined and we will have to fix that by implementing <code class="literal">sizeHint()</code>. However, to be able to calculate the size, we have to decide how big a single field on the board is going to be. Therefore, in <code class="literal">ChessView</code>, you should declare a property containing the size of the field, as shown:</p><div><pre class="programlisting">Q_PROPERTY(QSize fieldSize 
           READ fieldSize WRITE setFieldSize 
           NOTIFY fieldSizeChanged)</pre></div><p>To speed up coding, you can position the cursor over the property declaration, hit the <em>Alt</em> + <em>Enter</em> combination, and choose the <strong>Generate missing Q_PROPERTY members</strong> fixup from the pop-up menu. Creator will provide minor implementations for the getter and setter for you. You can move the generated code to the implementation file by positioning the cursor over each method, hitting <em>Alt</em> + <em>Enter,</em> and choosing the <strong>Move definition to chessview.cpp file</strong> fixup. While the generated getter method is fine, the setter needs some adjusting. Modify it by adding the following highlighted code:</p><div><pre class="programlisting">void ChessView::setFieldSize(QSize arg)
{
    if (m_fieldSize == arg)
        return;

    m_fieldSize = arg;
    emit fieldSizeChanged(arg);
<strong>    updateGeometry();</strong>
}</pre></div><p>This tells our widget to recalculate its size whenever the size of the field is modified. Now we can implement <code class="literal">sizeHint()</code>:</p><div><pre class="programlisting">QSize ChessView::sizeHint() const
{
    if(!m_board) return QSize(100,100);
    QSize boardSize = QSize(fieldSize().width() * m_board-&gt;columns() +1,
    m_fieldSize.height() * m_board-&gt;ranks()   +1);
    int rankSize = fontMetrics().width('M')+4;
    int columnSize = fontMetrics().height()+4;
    return boardSize+QSize(rankSize, columnSize);
}</pre></div><p>First we check if we have a valid board definition and if not, return a sane size of 100 x 100 pixels. Otherwise, the method calculates the size of all the fields by multiplying the size of each of the fields by the number of columns or ranks. We add one pixel to each dimension to accommodate the right and bottom border. A chess board not only consists of not only the fields themselves but also displays rank symbols on the left edge of the board and column numbers on the bottom edge of the board. Since we use letters to enumerate ranks, we check the width of the widest letter in the alphabet using the <code class="literal">QFontMetrics</code> class. We use the same class to check how much space is required to render a line of text using the current font <a id="id296" class="indexterm"/>so that we have enough space to put column numbers. In both cases, we add 4 to the result to make a 2 pixel margin between the text and the edge of the board and another 2 pixel margin between the text and the edge of the widget.</p><p>It is very useful to define a helper method for returning a rectangle that contains a particular field, as shown:</p><div><pre class="programlisting">QRect ChessView::fieldRect(int column, int rank) const
{
  if(!m_board) return QRect();
  const QSize fs = fieldSize();
  QRect fRect = QRect(QPoint((column-1)*fs.width(), (m_board-&gt;ranks()-rank)*fs.height()), fs);
  // offset rect by rank symbols
  int offset = fontMetrics().width('M'); // 'M' is the widest letter
  return fRect.translated(offset+4, 0);
}</pre></div><p>Since rank numbers decrease from the top towards the bottom of the board, we subtract the desired rank from the maximum rank there is while calculating <code class="literal">fRect</code>. Then, we calculate the horizontal offset for rank symbols just like we did in <code class="literal">sizeHint()</code> and translate the rectangle by that offset before returning the result.</p><p>Finally, we can move on to implementing the event handler for the paint event. Declare the <code class="literal">paintEvent()</code> method (the fixup menu available under the <em>Alt</em> + <em>Enter</em> keyboard shortcut will let you generate a stub implementation of the method) and fill it with the following code:</p><div><pre class="programlisting">void ChessView::paintEvent(QPaintEvent *event)
{
  if(!m_board) return;
  QPainter painter(this);
  for(int r = m_board-&gt;ranks(); r&gt;0; --r) {
    painter.save();
    drawRank(&amp;painter, r);
    painter.restore();
  }
  for(int c = 1; c&lt;=m_board-&gt;columns();++c) {
    painter.save();
    drawColumn(&amp;painter, c);
    painter.restore();
  }
  for(int r = 1; r&lt;=m_board-&gt;ranks();++r) {
    for(int c = 1; c&lt;=m_board-&gt;columns();++c) {
      painter.save();
      drawField(&amp;painter, c, r);
      painter.restore();
    }
  }
}</pre></div><p>The handler is quite simple. First we instantiate the <code class="literal">QPainter</code> object that operates on the widget. Then we have three loops—the first one iterates over ranks, the second over columns, and the third over all fields. The body of each loop is very similar: there is a call to a custom draw method that accepts a pointer to the painter and index of the rank, column, or both of them, respectively. Each of the calls is surrounded by executing <code class="literal">save()</code> and <code class="literal">restore()</code><a id="id297" class="indexterm"/>on our <code class="literal">QPainter</code> instance. What are the calls for here? The three draw methods—<code class="literal">drawRank()</code>, <code class="literal">drawColumn()</code>, and <code class="literal">drawField()</code>—are going to be virtual methods responsible for rendering the rank symbol, the column number, and the field background. It will be possible to subclass <code class="literal">ChessView</code> and provide custom implementations for those renderers so that it is possible to provide a different look of the chess board. Since each of these methods takes the painter instance as its parameter, overrides of these methods could alter attribute values of the painter behind our back. Calling <code class="literal">save()</code> before handing the painter over to such override stores its state on an internal stack, and calling <code class="literal">restore()</code> after returning from the override resets the painter to what was stored with <code class="literal">save()</code>. This effectively gives us a failsafe to avoid breaking the painter in case the override does not clean up after itself if it modifies the painter.</p><div><div><h3 class="title"><a id="tip38"/>Tip</h3><p>Calling <code class="literal">save()</code> and <code class="literal">restore()</code> very often introduces a performance hit, so you should avoid saving and restoring painter states too often in time-critical situations. As our painting is very simple, we don't have to worry about that when painting our chess board.</p></div></div><p>Having introduced our three methods, we can start implementing them. Let's start with <code class="literal">drawRank</code> and <code class="literal">drawColumn</code>. Remember to declare them as virtual and put them in protected access scope (that's usually where Qt classes put such methods), as shown:</p><div><pre class="programlisting">void ChessView::drawRank(QPainter *painter, int rank)
{
  QRect r = fieldRect(1, rank);
  QRect rankRect = QRect(0, r.top(), r.left(), r.height()).adjusted(2, 0, -2, 0);
  QString rankText = QString::number(rank);
  painter-&gt;drawText(rankRect, Qt::AlignVCenter|Qt ::AlignRight, rankText);
}

void ChessView::drawColumn(QPainter *painter, int column)
{
  QRect r = fieldRect(column, 1);
  QRect columnRect = QRect(r.left(), r.bottom(), 
    r.width(), height()-r.bottom()).adjusted(0, 2, 0, -2);
  painter-&gt;drawText(columnRect, Qt:: AlignHCenter|Qt::AlignTop, QChar('a'+column-1));
}</pre></div><p>Both methods are very similar. We use <code class="literal">fieldRect()</code> to query for the left-most column and bottom-most rank and based on that, we calculate where rank symbols and column numbers should be placed. The call to <code class="literal">QRect::adjusted()</code> is to accommodate the 2 pixel margin around the text to be drawn. Finally, we use <code class="literal">drawText()</code> to render appropriate text. For the <a id="id298" class="indexterm"/>rank, we ask the painter to align the text to the right edge of the rectangle and center the text vertically. In a similar way, when drawing the column we align to the top edge and center the text horizontally.</p><p>Now we can implement the third draw method. It should also be declared protected and virtual. Place the following code in the method body:</p><div><pre class="programlisting">void ChessView::drawField(QPainter *painter, int column, int rank)
{
  QRect rect = fieldRect(column, rank);
  QColor fillColor = (column+rank) % 2 ? palette().
    color(QPalette::Light) : palette().color(QPalette::Mid);
  painter-&gt;setPen(palette().color(QPalette::Dark));
  painter-&gt;setBrush(fillColor);
  painter-&gt;drawRect(rect);
}</pre></div><p>In this method, we use the <code class="literal">QPalette</code> object coupled with each widget to query for <code class="literal">Light</code> (usually white) and <code class="literal">Mid</code> (darkish) color depending on whether the field we are drawing on the chess board is considered white or black. We do that instead of hardcoding the colors to make it possible to modify colors of the tiles without subclassing simply by adjusting the palette object. Then we use the palette again to ask for the <code class="literal">Dark</code> color and use that as a pen for our painter. When we draw a rectangle with such settings, the pen will stroke the border of the rectangle to give it a more elegant look. Note how we modify attributes of the painter in this method and we do not set them back afterwards. We can get away with it because of the <code class="literal">save()</code> and <code class="literal">restore()</code> calls surrounding the <code class="literal">drawField()</code> execution.</p><p>We are ready now to see the results of our work. Let's switch to the <code class="literal">MainWindow</code> class and equip it with the following two private variables:</p><div><pre class="programlisting">ChessView *m_view;
ChessAlgorithm *m_algorithm;</pre></div><p>Then modify the <a id="id299" class="indexterm"/>constructor by adding the following highlighted code to set up the view and the game engine:</p><div><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);
<strong>  m_view = new ChessView;</strong>
<strong>  m_algorithm = new ChessAlgorithm(this);</strong>
<strong>  m_algorithm-&gt;newGame();</strong>
<strong>  m_view-&gt;setBoard(m_algorithm-&gt;board());</strong>
<strong>  setCentralWidget(m_view);</strong>
<strong>  m_view-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);</strong>
<strong>  m_view-&gt;setFieldSize(QSize(50,50));</strong>
  layout()-&gt;setSizeConstraint(QLayout::SetFixedSize);
}</pre></div><p>Afterwards, you should be able to build the project. When you run it, you should see a result similar to the one in the following screenshot:</p><div><img src="img/8874OS_05_19.jpg" alt="Time for action – understanding the ChessView class"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>
<em>What just happened?</em>
</h2></div></div></div><p>In this exercise, we did two things. First we provided a number of methods for calculating the geometry of important parts of the chess board and the size of the widget. Second, we defined three virtual methods for rendering visual primitives of a chess board. By making the methods virtual, we provided an infrastructure to let the look be customized by subclassing and overriding base implementations. Furthermore, by reading color from <code class="literal">QPalette</code>, we allowed customizing the colors of the primitives even without subclassing.</p><p>The last line of the main <a id="id300" class="indexterm"/>window constructor tells the layout of the window to force a fixed size of the window equal to what the size hint of the widget inside it reports.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Time for action – rendering the pieces</h1></div></div></div><p>Now that we can <a id="id301" class="indexterm"/>see the board, it is time to put the pieces on it. We are going to use images for that purpose. In my case, we found a number of SVG files with chess pieces and decided to use them. SVG is a vector graphics format where all curves are defined not as a fixed set of points but rather as mathematic curves. Their main benefit is that they scale very well without causing an aliasing effect.</p><p>Let's equip our view with a registry of images to be used for "stamping" a particular piece type. Since each piece type is identified with char, we can use it to generate keys for a map of images. Let's put the following API into <code class="literal">ChessView</code>:</p><div><pre class="programlisting">public:
  void setPiece(char type, const QIcon &amp;icon);
  QIcon piece(char type) const;
private:
  QMap&lt;char,QIcon&gt; m_pieces;</pre></div><p>For the image type, we do not use <code class="literal">QImage</code> or <code class="literal">QPixmap</code> but rather <code class="literal">QIcon</code>. This is because <code class="literal">QIcon</code> can store many pixmaps of different sizes and use the most appropriate one when we request an icon of a given size to be painted. This doesn't matter if we use vector images, but it does matter if you choose to use PNG or other types of image. In such cases, you can use <code class="literal">addFile()</code> to add many images to a single icon.</p><p>Going back to our registry, the implementation is very simple. We just store the icon in a map and ask the widget to repaint itself:</p><div><pre class="programlisting">void ChessView::setPiece(char type, const QIcon &amp;icon)
{
  m_pieces.insert(type, icon);
  update();
}

QIcon ChessView::piece(char type) const
{
  return m_pieces.value(type, QIcon());
}</pre></div><p>Now we can fill the <a id="id302" class="indexterm"/>registry with actual images right after we create the view inside the <code class="literal">MainWindow</code> constructor. Note that we stored all the images in a resource file, as shown:</p><div><pre class="programlisting">m_view-&gt;setPiece('P', QIcon(":/pieces/Chess_plt45.svg")); // pawn
m_view-&gt;setPiece('K', QIcon(":/pieces/Chess_klt45.svg")); // king
m_view-&gt;setPiece('Q', QIcon(":/pieces/Chess_qlt45.svg")); // queen
m_view-&gt;setPiece('R', QIcon(":/pieces/Chess_rlt45.svg")); // rook
m_view-&gt;setPiece('N', QIcon(":/pieces/Chess_nlt45.svg")); // knight
m_view-&gt;setPiece('B', QIcon(":/pieces/Chess_blt45.svg")); // bishop

m_view-&gt;setPiece('p', QIcon(":/pieces/Chess_pdt45.svg")); // pawn
m_view-&gt;setPiece('k', QIcon(":/pieces/Chess_kdt45.svg")); // king
m_view-&gt;setPiece('q', QIcon(":/pieces/Chess_qdt45.svg")); // queen
m_view-&gt;setPiece('r', QIcon(":/pieces/Chess_rdt45.svg")); // rook
m_view-&gt;setPiece('n', QIcon(":/pieces/Chess_ndt45.svg")); // knight
m_view-&gt;setPiece('b', QIcon(":/pieces/Chess_bdt45.svg")); // bishop</pre></div><p>The next thing to do is to extend the <code class="literal">paintEvent()</code> method of the view to actually render our pieces. For that, we will introduce another protected virtual method called <code class="literal">drawPiece()</code>. We'll call it when iterating over all the ranks and columns of the board, as shown:</p><div><pre class="programlisting">void ChessView::paintEvent(QPaintEvent *event) 
{
  // ...
<strong>  for(int r = m_board-&gt;ranks(); r&gt;0; --r) {</strong>
<strong>    for(int c = 1; c&lt;=m_board-&gt;columns();++c) {</strong>
<strong>      drawPiece(&amp;painter, c, r);</strong>
<strong>    }</strong>
<strong>  }</strong>
}</pre></div><p>It is not a coincidence that <a id="id303" class="indexterm"/>we start drawing from the highest (top) rank to the lowest (bottom) one. By doing that, we allow a pseudo-3D effect: if a piece drawn extends past the area of the field, it will intersect the field from the next rank (which is possibly occupied by another piece). By drawing higher rank pieces first, we cause them to be partially covered by pieces from the lower rank, which imitates the effect of depth. By thinking ahead, we allow reimplementations of <code class="literal">drawPiece()</code> to have more freedom in what they can do.</p><p>The final step is to provide a base implementation for this method, as follows:</p><div><pre class="programlisting">void ChessView::drawPiece(QPainter *painter, int column, int rank)
{
  QRect rect = fieldRect(column, rank);
  char value = m_board-&gt;data(column, rank);
  if(value != ' ') {
    QIcon icon = piece(value);
    if(!icon.isNull()) {
      icon.paint(painter, rect, Qt::AlignCenter);
    }
  }
}</pre></div><p>The method is very simple, it queries for the rectangle of a given column and rank, then asks the <code class="literal">ChessBoard</code> instance about the piece occupying the given field. If there is a piece there, we ask the registry for the proper icon; if we get a valid one, we call its <code class="literal">paint()</code> routine to draw the piece centered in the field's rect. The image drawn will be scaled to the size of the rectangle. It is important that you only use images with a transparent background (such as PNG or SVG files and not JPEG files) so that the color of the field can be seen through the piece.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>
<em>What just happened?</em>
</h2></div></div></div><p>To test the implementation, you can modify the algorithm to fill the board with the default piece set up by introducing the following change to the <code class="literal">ChessAlgorithm</code> class:</p><div><pre class="programlisting">void ChessAlgorithm::newGame()
{
  setupBoard();
<strong>  board()-&gt;setFen(</strong>
<strong>    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"</strong>
<strong>  );</strong>
}</pre></div><p>Running the program should show the following result:</p><div><img src="img/8874OS_05_20.jpg" alt="What just happened?"/></div><p>The modification we did in this step was very simple. First we provided a way to tell the board what each piece type looks like. This includes not only standard chess pieces but anything that fits into char and can be set inside the <code class="literal">ChessBoard</code> class's internal data array. Second, we made an abstraction for drawing the pieces with the simplest possible base implementation: taking an icon from the registry and rendering it to the field. By making use of <code class="literal">QIcon</code>, we <a id="id304" class="indexterm"/>can add several pixmaps of different sizes to be used with different sizes of a single field. Alternatively, the icon can contain a single vector image that scales very well all by itself.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Time for action – making the chess game interactive</h1></div></div></div><p>We have managed to display the chess board but to actually play a game, we have to tell the program what <a id="id305" class="indexterm"/>moves we want to play. We could do that by adding the <code class="literal">QLineEdit</code> widget where we would input the move in algebraic form (for example, <code class="literal">Nf3</code> to move a knight to <code class="literal">f3</code>), but a more natural way is to click a piece with the mouse cursor (or tap it with a finger) and then click again on the destination field. To obtain such functionality, the first thing to do is to teach <code class="literal">ChessView</code> to detect mouse clicks. Therefore, add the following method:</p><div><pre class="programlisting">QPoint ChessView::fieldAt(const QPoint &amp;pt) const
{
  if(!m_board) return QPoint();
  const QSize fs = fieldSize();
    int offset = fontMetrics().width('M')+4; // 'M' is the widest letter
    if(pt.x() &lt; offset) return QPoint();
    int c = (pt.x()-offset) / fs.width();
    int r = pt.y()/fs.height();
    if(c &lt; 0 || c &gt;= m_board-&gt;columns() || r&lt;0 || r &gt;= m_board-&gt;ranks()) 
        return QPoint();
    return QPoint(c+1, m_board-&gt;ranks() - r); // max rank - r
}</pre></div><p>The code looks very similar to the implementation of <code class="literal">fieldRect()</code>. This is because <code class="literal">fieldAt()</code> implements its reverse operation—it transforms a point in the widget coordinate space to the column and rank index of a field the point is contained in. The index is calculated by dividing point coordinates by the size of the field. You surely remember that, in the case of columns, the fields are offset by the size of the widest letter and a margin of 4 and we have to consider that in our calculations here as well. We do two checks: first we check the horizontal point coordinate against the offset to detect if the user clicked on the part of the widget where column symbols are displayed, and then we check if the rank and column calculated fit the range represented in the board. Finally, we return the result as a <code class="literal">QPoint</code> value since this is the easiest way in Qt to represent a two-dimensional value.</p><p>Now we need to find a way to make the widget notify its environment that a particular field was clicked. We can do this through the signal-slot mechanism. Switch to the header file of <code class="literal">ChessView</code> (if you currently have chessview.cpp opened in Qt Creator, you can simply push the <em>F4</em> key to be transferred to the corresponding header file) and declare a <code class="literal">clicked(const QPoint &amp;)</code> signal:</p><div><pre class="programlisting">signals:
  void clicked(const QPoint &amp;);</pre></div><p>To detect mouse input, we have to override one of the mouse event handlers a widget has, either <code class="literal">mousePressEvent</code> or <code class="literal">mouseReleaseEvent</code>. It seems obvious we should choose the former event; this would work, but it is not the best decision. Just think about the semantics of a mouse click: it is a complex event composed of pushing and releasing the mouse button. The <a id="id306" class="indexterm"/>actual "click" takes place after the mouse is released. Therefore let's use <code class="literal">mouseReleaseEvent</code> as our event handler:</p><div><pre class="programlisting">void ChessView::mouseReleaseEvent(QMouseEvent *event)
{
  QPoint pt = fieldAt(event-&gt;pos());
  if(pt.isNull()) return;
  emit clicked(pt);
}</pre></div><p>The code is simple; we use the method we just implemented and pass it the position read from the <code class="literal">QMouseEvent</code> object. If the returned point is invalid, we quietly return from the method. Otherwise, <code class="literal">clicked()</code> is emitted with the obtained column and rank values.</p><p>We can make use of the signal now. Go to the constructor of <code class="literal">MainWindow</code> and add the following line to connect the widget's clicked signal to a custom slot:</p><div><pre class="programlisting">connect(m_view, SIGNAL(clicked(QPoint)), this, SLOT(viewClicked(QPoint)));</pre></div><p>Declare the slot and implement it as follows:</p><div><pre class="programlisting">void MainWindow::viewClicked(const QPoint &amp;field)
{
  if(m_clickPoint.isNull()) {
    m_clickPoint = field;
  } else {
  if(field != m_clickPoint) {
    m_view-&gt;board()-&gt;movePiece(
      m_clickPoint.x(), m_clickPoint.y(), 
      field.x(), field.y()
    );
    }
    m_clickPoint = QPoint();
  }
}</pre></div><p>The function uses a class member variable <code class="literal">m_clickPoint</code> to store the clicked field. The variable value is made invalid after a move is made. Thus we can detect whether the click we are currently handling has "select" or "move" semantics. In the first case, we store the selection in <code class="literal">m_clickPoint</code>; in the other case, we ask the board to make a move using the helper method we implemented some time ago. Remember to declare <code class="literal">m_clickPoint</code> as a private member variable of <code class="literal">MasinWindow</code>.</p><p>All should be working now. However, if you build the application, run it, and start clicking around on the chess board, you will see that nothing happens. This is because we forgot to tell the view to refresh itself when the game position on the board is changed. We have to connect the signals the board emits to the <code class="literal">update()</code> slot of the view. Open the <code class="literal">setBoard()</code> method <a id="id307" class="indexterm"/>of the widget class and fix it as follows:</p><div><pre class="programlisting">void ChessView::setBoard(ChessBoard *board)
{
  // ...
  m_board = board;
<strong>  // connect signals</strong>
<strong>  if(board){</strong>
<strong>    connect(board, SIGNAL(dataChanged(int,int)), this, SLOT(update()));</strong>
<strong>    connect(board, SIGNAL(boardReset()), this, SLOT(update()));</strong>
<strong>  }</strong>
  updateGeometry();
}</pre></div><p>If you run the program now, moves you make will be reflected in the widget, as shown:</p><div><img src="img/8874OS_05_21.jpg" alt="Time for action – making the chess game interactive"/></div><p>At this point, we might consider the visual part of the game as finished, but there is still one problem you might have spotted while testing our latest additions. When you click on the board, there is no visual hint that any piece was actually selected. Let's fix that now by introducing the ability to highlight any field on the board. </p><p>To do that, we will develop a generic system for different highlights. Begin by adding a <code class="literal">Highlight</code> class as an internal class to <code class="literal">ChessView</code>:</p><div><pre class="programlisting">class ChessView : public QWidget
    // ...
public:
<strong>    class Highlight {</strong>
<strong>    public:</strong>
<strong>        Highlight() {}</strong>
<strong>        virtual ~Highlight() {}</strong>
<strong>        virtual int type() const { return 0; }</strong>
<strong>    };</strong>
// ...
};</pre></div><p>It is a minimalistic interface for highlights and only exposes a method returning the type of the highlight using a virtual method. In our exercise, we will focus on just a basic type that marks a <a id="id308" class="indexterm"/>single field with a given color. Such a situation is going to be represented by the <code class="literal">FieldHighlight</code> class:</p><div><pre class="programlisting">class FieldHighlight : public Highlight {
public:
  enum { Type = 1 };
  FieldHighlight(int column, int rank, QColor color)
    : m_field(column, rank), m_color(color) {}
  inline int column() const { return m_field.x(); }
  inline int rank() const { return m_field.y(); }
  inline QColor color() const { return m_color; }
  int type() const { return Type; }
private:
  QPoint m_field;
  QColor m_color;
};</pre></div><p>You can see we provided a constructor that takes the column and rank indices and a color for the highlight and stores them in private member variables. Also, <code class="literal">type()</code> is redefined to return <code class="literal">FieldHighlight::Type</code>, which we can use to easily identify the type of highlight. The next step is to extend <code class="literal">ChessView</code> with abilities to add and remove highlights. As the container declares a private <code class="literal">QList&lt;Highlight*&gt; m_highlights </code>member variable, add method declarations:</p><div><pre class="programlisting">public:
  void addHighlight(Highlight *hl);
  void removeHighlight(Highlight *hl);
  inline Highlight *highlight(int index) const {return m_highlights.at(index); }
  inline int highlightCount() const { return m_highlights.size(); }</pre></div><p>Next provide implementations for non-inline methods:</p><div><pre class="programlisting">void ChessView::addHighlight(ChessView::Highlight *hl) 
{ m_highlights.append(hl); update(); }

void ChessView::removeHighlight(ChessView::Highlight *hl) 
{ m_highlights.removeOne(hl); update(); }</pre></div><p>Drawing the highlights is really easy: we will use yet another virtual <code class="literal">draw</code> method. Place the following call in the <code class="literal">paintEvent()</code> implementation right before the loop that is responsible for rendering pieces:</p><div><pre class="programlisting">drawHighlights(&amp;painter);</pre></div><p>The implementation simply iterates over all the highlights and renders those it understands.</p><div><pre class="programlisting">void ChessView::drawHighlights(QPainter *painter)
{
  for(int idx=0; idx &lt; highlightCount(); ++idx) {
    Highlight *hl = highlight(idx);
    if(hl-&gt;type() == FieldHighlight::Type) {
      FieldHighlight *fhl = static_cast&lt;FieldHighlight*&gt;(hl);
      QRect rect = fieldRect(fhl-&gt;column(), fhl-&gt;rank());
      painter-&gt;fillRect(rect, fhl-&gt;color());
    }
  }
}</pre></div><p>By checking the type of the highlight, we know which class to cast the generic pointer to. Then we can query the object for the needed data. Finally, we use <code class="literal">QPainter::fillRect()</code> to fill the field with the given color. As <code class="literal">drawHighlights()</code> is called before the <a id="id309" class="indexterm"/>piece painting loop and after the field painting loop, the highlight will cover the background but not the piece.</p><p>That's the basic highlighting system. Let's make our <code class="literal">viewClicked()</code> slot use it:</p><div><pre class="programlisting">void MainWindow::viewClicked(const QPoint &amp;field)
{
  if(m_clickPoint.isNull()) {
    <strong>if(m_view-&gt;board()-&gt;data(field.x(), field.y()) != ' ') {</strong>
      m_clickPoint = field;
      <strong>m_selectedField = new ChessView::FieldHighlight(</strong>
<strong>        field.x(), field.y(), QColor(255, 0, 0, 50)</strong>
<strong>      );</strong>
<strong>      m_view-&gt;addHighlight(m_selectedField);</strong>
<strong>    }</strong>
  } else {
    if(field != m_clickPoint) {
      m_view-&gt;board()-&gt;movePiece(
        m_clickPoint.x(), m_clickPoint.y(), field.x(), field.y()
      );
    };
    m_clickPoint = QPoint();
    <strong>m_view-&gt;removeHighlight(m_selectedField);</strong>
<strong>    delete m_selectedField;</strong>
<strong>    m_selectedField = 0;</strong>
  }
}</pre></div><p>Notice how we check that a field can only be selected if it is not empty (that is, there is an existing piece occupying that field)?</p><p>You should also add a <code class="literal">ChessView::FieldHighlight *m_selectedField</code> private member variable and initialize it with a null pointer in the constructor. You can now build the game, execute it, and start moving pieces around.</p><div><img src="img/8874OS_05_22.jpg" alt="Time for action – making the chess game interactive"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>
<em>What just happened?</em>
</h2></div></div></div><p>By adding a few lines of code, we managed to make the board clickable. We connected a custom slot that reads which field was clicked and can highlight it with a semi-transparent red color. Clicking on another field will move the highlighted piece there. The highlighting system we developed is very generic. We use it to highlight a single field with a solid color, but you can mark as many fields as you want with a number of different colors, for example, to show valid moves after selecting a piece. The system can easily be extended <a id="id310" class="indexterm"/>with new types of highlights; for example, you can draw arrows on the board using <code class="literal">QPainterPath</code> to have a complex hinting system (say showing the player the suggested move).</p><div><img src="img/8874OS_05_23.jpg" alt="What just happened?"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Time for action – connecting the game algorithm</h1></div></div></div><p>It would take <a id="id311" class="indexterm"/>us too long to implement a full chess game algorithm here, so we will instead settle for a much simpler game called Fox and Hounds. One of the players has four pawns (hounds) which can only move over black fields and the pawn can only move in a forward fashion (toward higher ranks). The other player has just a single pawn (fox) which starts from the opposite side of the board. </p><div><img src="img/8874OS_05_24.jpg" alt="Time for action – connecting the game algorithm"/></div><p>It can also move only over black fields; however it can move both forwards (toward higher ranks) as well as backwards (toward lower ranks). Players move in turns by moving their pawn by to a neighboring black field. The goal of the fox is to reach the opposite end of the <a id="id312" class="indexterm"/>board; the goal of the hounds is to trap the fox so that it can't make a move.</p><div><img src="img/8874OS_05_25.jpg" alt="Time for action – connecting the game algorithm"/></div><p>Time to get to <a id="id313" class="indexterm"/>work! First we will extend the <code class="literal">ChessAlgorithm</code> class with the required interface:</p><div><pre class="programlisting">class ChessAlgorithm : public QObject
{
  Q_OBJECT
  <strong>Q_ENUMS(Result Player)</strong>
<strong>  Q_PROPERTY(Result result READ result)</strong>
<strong>  Q_PROPERTY(Player currentPlayer </strong>
<strong>             READ currentPlayer </strong>
<strong>             NOTIFY currentPlayerChanged)</strong>
public:
  <strong>enum Result { NoResult, Player1Wins, Draw, Player2Wins };</strong>
<strong>  enum Player { NoPlayer, Player1, Player2 };</strong>

  explicit ChessAlgorithm(QObject *parent = 0);
  ChessBoard* board() const;
  <strong>inline Result result() const { return m_result; }</strong>
  <strong>inline Player currentPlayer() const { return m_currentPlayer; }</strong>

signals:
  void boardChanged(ChessBoard*);
  <strong>void gameOver(Result);</strong>
<strong>  void currentPlayerChanged(Player);</strong>

public slots:
  virtual void newGame();
  <strong>virtual bool move(int colFrom, int rankFrom, int colTo, int rankTo);</strong>
<strong>  bool move(const QPoint &amp;from, const QPoint &amp;to);</strong>

protected:
  virtual void setupBoard();
  void setBoard(ChessBoard *board);
<strong>  void setResult(Result);</strong>
<strong>  void setCurrentPlayer(Player);</strong>
private:
  ChessBoard *m_board;
<strong>  Result m_result;</strong>
<strong>  Player m_currentPlayer;</strong>
};</pre></div><p>There are two sets of members here. First we have a number of enums, variables, signals, and methods that are related to the state of the game: which player should make his move now and what is currently the result of the game. The <code class="literal">Q_ENUMS</code> macro is used to register enumerations in Qt's meta-type system so that they can be used as values for properties or arguments in signals. Property declarations and getters for them don't need any extra explanation. We have also declared protected methods for setting the variables from within subclasses. Here <a id="id314" class="indexterm"/>is their suggested implementation:</p><div><pre class="programlisting">void ChessAlgorithm::setResult(Result value)
{
  if(result() == value) return;
  if(result() == NoResult) {
     m_result = value;
     emit gameOver(m_result);
  } else { m_result = value; }
}

void ChessAlgorithm::setCurrentPlayer(Player value)
{
  if(currentPlayer() == value) return;
  m_currentPlayer = value;
  emit currentPlayerChanged(m_currentPlayer);
}</pre></div><p>Remember about initializing <code class="literal">m_currentPlayer</code> and <code class="literal">m_result</code> to <code class="literal">NoPlayer</code> and <code class="literal">NoResult</code> in the constructor of the <code class="literal">ChessAlgorithm</code> class.</p><p>The second group of functions is methods that modify the state of the game—the two variants of <code class="literal">move()</code>. The virtual variant is meant to be reimplemented by the real algorithm to check whether a given move is valid in the current game state and if that is the case, to perform the actual modification of the game board. In the base class, we can simply reject all possible moves:</p><div><pre class="programlisting">bool ChessAlgorithm::move(int colFrom, int rankFrom, int colTo, int rankTo)
{
  Q_UNUSED(colFrom)
  Q_UNUSED(rankFrom)
  Q_UNUSED(colTo)
  Q_UNUSED(rankTo)
  return false;
}</pre></div><div><div><h3 class="title"><a id="tip39"/>Tip</h3><p>
<code class="literal">Q_UNUSED</code> is a macro to prevent the compiler from issuing warnings during compilation if the enclosed local variable is never used in the scope.</p></div></div><p>The overload is simply a convenience method that accepts two <code class="literal">QPoint</code> objects instead of four integers.</p><div><pre class="programlisting">bool ChessAlgorithm::move(const QPoint &amp;from, const QPoint &amp;to)
{
  return move(from.x(), from.y(), to.x(), to.y());
}</pre></div><p>The interface for the algorithm is ready now and we can implement it for the Fox and Hounds game. Subclass <code class="literal">ChessAlgorithm</code> to create a <code class="literal">FoxAndHounds</code> class:</p><div><pre class="programlisting">class FoxAndHounds : public ChessAlgorithm
{
public:
  FoxAndHounds(QObject *parent = 0);
  void newGame();
  bool move(int colFrom, int rankFrom, int colTo, int rankTo);
};</pre></div><p>The implementation of <code class="literal">newGame()</code> is pretty simple: we set up the board, place pieces on it, and signal that it is time for the first player to make their move.</p><div><pre class="programlisting">void FoxAndHounds::newGame()
{
  setupBoard();
  board()-&gt;setFen("3p4/8/8/8/8/8/8/P1P1P1P1 w"); // 'w' - white to move
  m_fox = QPoint(5,8);
  setResult(NoResult);
  setCurrentPlayer(Player1);
}</pre></div><p>The algorithm for the <a id="id315" class="indexterm"/>game is quite simple. Implement <code class="literal">move()</code> as follows:</p><div><pre class="programlisting">bool FoxAndHounds::move(int colFrom, int rankFrom, int colTo, int rankTo)
{
  if(currentPlayer() == NoPlayer) return false;

  // is there a piece of the right color?
  char source = board()-&gt;data(colFrom, rankFrom);
  if(currentPlayer() == Player1 &amp;&amp; source != 'P') return false;
  if(currentPlayer() == Player2 &amp;&amp; source != 'p') return false;

  // both can only move one column right or left
  if(colTo != colFrom+1 &amp;&amp; colTo != colFrom-1) return false;

  // do we move within the board?
  if(colTo &lt; 1 || colTo &gt; board()-&gt;columns()) return false;
  if(rankTo &lt; 1 || rankTo &gt; board()-&gt;ranks()) return false;

  // is the destination field black?
  if((colTo + rankTo) % 2) return false;

  // is the destination field empty?
  char destination = board()-&gt;data(colTo, rankTo);
  if(destination != ' ') return false;

  // is white advancing?
  if(currentPlayer() == Player1 &amp;&amp; rankTo &lt;= rankFrom) return false;

  board()-&gt;movePiece(colFrom, rankFrom, colTo, rankTo);  // make the move
  if(currentPlayer() == Player2) {
    m_fox = QPoint(colTo, rankTo);      // cache fox position
  }
  // check win condition
  if(currentPlayer() == Player2 &amp;&amp; rankTo == 1){
    setResult(Player2Wins);              // fox has escaped
  } else if(currentPlayer() == Player1 &amp;&amp; !foxCanMove()) {
    setResult(Player1Wins);        // fox can't move
  } else {
    // the other player makes the move now
    setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);
  }
  return true;
}</pre></div><p>Declare a protected <code class="literal">foxCanMove()</code> method and implement it using the following code:</p><div><pre class="programlisting">bool FoxAndHounds::foxCanMove() const
{
  if(emptyByOffset(-1, -1) || emptyByOffset(-1, 1) 
  || emptyByOffset( 1, -1) || emptyByOffset( 1, 1)) return true;
  return false;
}</pre></div><p>Then do the same with <code class="literal">emptyByOffset()</code>:</p><div><pre class="programlisting">bool FoxAndHounds::emptyByOffset(int x, int y) const
{
  const int destCol = m_fox.x()+x;
  const int destRank = m_fox.y()+y;
  if(destCol &lt; 1 || destRank &lt; 1 
  || destCol &gt; board()-&gt;columns() || destRank &gt; board()-&gt;ranks()) return false;
    return (board()-&gt;data(destCol, destRank) == ' ');
}</pre></div><p>Lastly declare a <a id="id316" class="indexterm"/>private <code class="literal">QPoint m_fox</code> member variable.</p><p>The simplest way to test the game is to make two changes to the code. First, in the constructor of the main window class, replace <code class="literal">m_algorithm = new ChessAlgorithm(this)</code> with <code class="literal">m_algorithm = new FoxAndHounds(this)</code>. Second, modify the <code class="literal">viewClicked()</code> slot as follows:</p><div><pre class="programlisting">void MainWindow::viewClicked(const QPoint &amp;field)
{
  if(m_clickPoint.isNull()) {
    // ...
  } else {
    if(field != m_clickPoint) {
      <strong>m_algorithm-&gt;move(m_clickPoint, field);</strong>
    }
    // ...
  }
}</pre></div><p>You can also connect <a id="id317" class="indexterm"/>signals from the algorithm class to custom slots of the view or window to notify about the end of the game and provide a visual hint as to which player should make his move now.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a very simplistic API for implementing chess-like games by introducing the <code class="literal">newGame()</code> and <code class="literal">move()</code> virtual methods to the algorithm class. The former method simply sets everything up. The latter uses simple checks to determine whether a particular move is valid and if the game has ended. We use the <code class="literal">m_fox </code>member variable to track the current position of the fox to be able to quickly determine if it has any valid moves. When the game ends, the <code class="literal">gameOver()</code> signal is emitted and the result of the game can be obtained from the algorithm. You can use the exact same framework for implementing all chess rules.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Have a go hero – implementing the UI around the chess board</h2></div></div></div><p>During the <a id="id318" class="indexterm"/>exercise, we focused on developing the game board view and necessary classes to make the game actually run. But we completely neglected the regular user interface the game might possess, such as toolbars and menus. You can try designing a set of menus and toolbars for the game. Make it possible to start a new game, save a game in progress (say by implementing a FEN serializer), load a saved game (say by leveraging the existing FEN string parser), or choose different game types that will spawn different <code class="literal">ChessAlgorithm</code> subclasses. You can also provide a settings dialog for adjusting the look of the game board. If you feel like it, you can add chess clocks or implement a simple tutorial system that will guide the player through the basics of chess using text and visual hints via the highlight system we implemented.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Have a go hero – connecting a UCI-compliant chess engine</h2></div></div></div><p>If you really <a id="id319" class="indexterm"/>want to test your skills, you can implement a <code class="literal">ChessAlgorithm</code> subclass that will connect to a <strong>Universal Chess Interface</strong> (UCI) chess engine such as StockFish (<a class="ulink" href="http://stockfishchess.org">http://stockfishchess.org</a>) and provide a challenging artificial intelligence opponent for a human player. UCI is the de facto standard for communication between a chess engine and a chess frontend. Its specification is freely available, so you can study it on your own. To talk to a UCI-compliant engine you can use <code class="literal">QProcess</code>, which will spawn the engine as an external process and attach itself to its standard input and standard output. Then you can send commands to the engine by writing to its standard input and read messages from the engine by reading its standard output. To get you started, here is a short snippet of code that starts the engine and attaches to its communication channels:</p><div><pre class="programlisting">class UciEngine : public QObject {
  Q_OBJECT
public:
  UciEngine(QObject *parent = 0) : QObject(parent) { 
    m_uciEngine = new QProcess(this);
    m_uciEngine-&gt;setReadChannel(QProcess:StandardOutput);
    connect(m_uciEngine, SIGNAL(readyRead()), SLOT(readFromEngine()));
  }
public slots:
  void startEngine(const QString &amp;enginePath) {
    m_uciEngine-&gt;start(enginePath);
  }
  void sendCommand(const QString &amp;command) {
    m_uciEngine-&gt;write(command.toLatin1());
  }
private slots:
  void readFromEngine() {
    while(m_uciEngine-&gt;canReadLine()) {
      QString line = QString::fromLatin1(m_uciEngine-&gt;readLine());
      emit messageReceived(line);
    }
  }
signals:
  void messageReceived(QString);
private:
  QProcess *m_uciEngine;
};</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec61"/>OpenGL</h1></div></div></div><p>We are not experts on <a id="id320" class="indexterm"/>OpenGL, so in this part of the chapter we will not teach you to do any fancy stuff with OpenGL and Qt but rather will show you how to enable the use of your OpenGL skills in Qt applications. There are a lot of tutorials and courses on OpenGL out there so if you're not that skilled with OpenGL, you can still benefit from what is described here by employing the knowledge gained here to more easily learn fancy stuff. You can use external materials and a high-level API offered by Qt, which is going to speed up many of the tasks described in the tutorials.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Introduction to OpenGL with Qt</h2></div></div></div><p>There are basically <a id="id321" class="indexterm"/>two ways you can use OpenGL in Qt. The first approach is to use <code class="literal">QOpenGLWidget</code>. This is mostly useful if your application heavily depends on other widgets (for example. the 3D view is only one of the views in your application and is controlled using a bunch of other widgets surrounding the main view). The other way is to use <code class="literal">QOpenGLWindow</code>; this is most useful when the GL window is the dominant or even the only part of the program. Both APIs are very similar; they use instances of the <code class="literal">QOpenGLContext</code> class to access the GL context. The difference is practically only in how they render the scene to the window. <code class="literal">QOpenGLWindow</code> renders directly to the given window, while <code class="literal">QOpenGLWidget</code> first renders to an offscreen buffer that is then rendered to the widget. The advantage of the latter approach is that <code class="literal">QOpenGLWidget</code> can be part of a more complex widget layout while <code class="literal">QOpenGLWindow</code> is usually used as the sole, often fullscreen, window. In this chapter we will be using the more direct approach (<code class="literal">QOpenGLWindow</code>); however, bear in mind that you can do everything described here using the widget too. Just replace the window classes with their widget equivalents and you should be good to go. </p><p>We said that the whole API revolves around the <code class="literal">QOpenGLContext</code> class. It represents the overall state of the GL pipeline, which guides the process of data processing and rendering to a particular device. </p><p>A related concept that needs explanation is the idea of a GL context being "current" in a thread. The way OpenGL calls work is that they do not use any handle to any object containing information on where and how to execute the series of low-level GL calls. Instead, it is assumed that they are executed in the context of the current machine state. The state may dictate whether to render a scene to a screen or to a frame buffer object, which mechanisms are enabled, or the properties of the surface OpenGL is rendering on. Making a context "current" means that all further OpenGL operations issued by a particular thread will be applied to this context. To add to that, a context can be "current" only in one thread at the same time; therefore, it is important to make the context current before making any OpenGL calls and then marking it as available after you are done accessing OpenGL resources. </p><p>
<code class="literal">QOpenGLWindow</code> has a very simple API that hides most of the unnecessary details from the developer. Apart from constructors and a destructor, it provides a small number of very useful methods. First there are auxiliary methods for managing the OpenGL context: <code class="literal">context()</code>, which returns the context, and <code class="literal">makeCurrent()</code> as well as <code class="literal">doneCurrent()</code> for acquiring and releasing the context. The remaining methods of the class are a number of virtual methods we can reimplement to display OpenGL graphics.</p><p>The first method is called <code class="literal">initializeGL()</code>, and it is invoked by the framework once before any painting is actually done so that you can prepare any resources or initialize the context in any way you require.</p><p>Then there are two most <a id="id322" class="indexterm"/>important methods: <code class="literal">resizeGL()</code> and <code class="literal">paintGL()</code>. The first is a callback invoked every time the window is resized. It accepts the width and height of the window as parameters. You can make use of that method by reimplementing it so that you can prepare yourself for the fact that the next call to the other method, <code class="literal">paintGL()</code>, renders to a viewport of a different size. Speaking of <code class="literal">paintGL()</code>, this is the equivalent of <code class="literal">paintEvent()</code> for the widget classes; it gets executed whenever the window needs to be repainted. This is the function where you should put your OpenGL rendering code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Time for action – drawing a triangle using Qt and OpenGL</h1></div></div></div><p>For the first <a id="id323" class="indexterm"/>exercise, we will create a subclass of <a id="id324" class="indexterm"/>
<code class="literal">QOpenGLWindow</code> that renders a triangle using simple OpenGL calls. Create a new project starting with <strong>Empty qmake Project</strong> from the <strong>Other Projects</strong> group as the template. In the project file, put the following content:</p><div><pre class="programlisting">QT = core gui
TARGET = triangle
TEMPLATE = app</pre></div><p>Having the basic project setup ready, let's define a <code class="literal">SimpleGLWindow</code> class as a subclass of <code class="literal">QOpenGLWindow</code> and override the <code class="literal">initializeGL()</code> method to set white as the clear color of our scene. We do this by calling an OpenGL function called <code class="literal">glClearColor</code>. Qt provides a convenience class called <code class="literal">QOpenGLFunctions</code> that takes care of resolving most commonly used OpenGL functions in a platform-independent way. This is the recommended approach to access OpenGLES functions in a platform-independent manner. Our window is going to inherit not only <code class="literal">QOpenGLWindow</code> but also <code class="literal">QOpenGLFunctions</code>. However, since we don't want to allow external access to those functions, we use protected inheritance.</p><div><pre class="programlisting">class SimpleGLWindow : public QOpenGLWindow, protected QOpenGLFunctions {
public:
  SimpleGLWindow(QWindow *parent = 0) : QOpenGLWindow(NoPartialUpdate, parent) { }
protected:
  void initializeGL() {
    initializeOpenGLFunctions();
    glClearColor(1,1,1,0);
  }</pre></div><p>In <code class="literal">initializeGL()</code>, we first call <code class="literal">initializeOpenGLFunctions()</code>, which is a method of the <code class="literal">QOpenGLFunctions</code> class, one of the base classes of our window class. The method takes care of setting up all the functions according to the parameters of the current GL context (thus <a id="id325" class="indexterm"/>it is important to first make the context <a id="id326" class="indexterm"/>current, which luckily is done for us behind the scenes before <code class="literal">initializeGL()</code> is invoked). Then we set the clear color of the scene to white.</p><p>The next step is to reimplement <code class="literal">paintGL()</code> and put the actual drawing code there:</p><div><pre class="programlisting">  void paintGL() {
    glClear(GL_COLOR_BUFFER_BIT);
    glViewport(0, 0, width(), height());
    glBegin(GL_TRIANGLES);
      glColor3f(1, 0, 0);
      glVertex3f( 0.0f, 1.0f, 0.0f);
      glColor3f(0, 1, 0);
      glVertex3f( 1.0f,-1.0f, 0.0f);
      glColor3f(0, 0, 1);
      glVertex3f(-1.0f,-1.0f, 0.0f);
    glEnd();
  }
};</pre></div><p>This function first clears the color buffer and sets the GL viewport of the context to be the size of the window. Then we tell OpenGL to start drawing using triangles with the <code class="literal">glBegin()</code> call and passing <code class="literal">GL_TRIANGLES</code> as the drawing mode. Then we pass three vertices along with their colors to form a triangle. Finally, we inform the pipeline by invoking <code class="literal">glEnd()</code> that we are done drawing using the current mode.</p><p>What is left is a trivial <code class="literal">main()</code> function that sets up the window and starts the event loop. Add a new <strong>C++ Source File</strong>, call it main.cpp, and implement <code class="literal">main()</code> as follows:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QGuiApplication app(argc, argv);
  SimpleGLWindow window;
  window.resize(600,400);
  window.show();
  return app.exec();
}</pre></div><div><img src="img/8874OS_05_13.jpg" alt="Time for action – drawing a triangle using Qt and OpenGL"/></div><div><div><h3 class="title"><a id="tip40"/>Tip</h3><p>You can see the triangle has jagged edges. That's because of the aliasing effect. You can counter it by enabling multisampling for the window, which will make OpenGL render the contents multiple times and then average the result, which acts as antialiasing. To do that, add the following code to the constructor of the window:</p><div><pre class="programlisting">        QSurfaceFormat fmt = format();
        fmt.setSamples(16); // multisampling set to 16
        setFormat(fmt);</pre></div></div></div><p>Drawing colored <a id="id327" class="indexterm"/>triangles is fun, but drawing textured <a id="id328" class="indexterm"/>cubes is even more fun so let's see how we can use OpenGL textures with Qt.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Time for action – scene-based rendering</h1></div></div></div><p>Let's take our <a id="id329" class="indexterm"/>rendering code to a higher level. Putting OpenGL code directly into the <code class="literal">window</code> class requires subclassing the window class and makes the window class more and more complex. Let's follow good programming practice and separate rendering code from window code.</p><p>Create a new class and call it <code class="literal">AbstractGLScene</code>. It is going to be the base class for definitions of OpenGL scenes. You can derive the class (with protected scope) from <code class="literal">QOpenGLFunctions</code> to make accessing different GL functions easier. Make the scene class accept a pointer to <code class="literal">QOpenGLWindow</code>, either in the constructor or through a dedicated setter method. Make sure the pointer is stored in the class for easier access as we are going to rely on that pointer for accessing physical properties of the window. Add methods for querying the window's OpenGL context. You should end up with code similar to the following:</p><div><pre class="programlisting">class AbstractGLScene : protected QOpenGLFunctions {
public:
  AbstractGLScene(QOpenGLWindow *wnd = 0) { m_window = wnd; }
  QOpenGLWindow* window() const { return m_window; }
  QOpenGLContext* context() { return window() ? window()-&gt;context() : 0;
  }
  const QOpenGLContext* context() const { 
      return window() ? window()-&gt;context() : 0; 
  }
private:
  QOpenGLWindow *m_window = nullptr; // C++11 required for assignment
};</pre></div><p>Now the essential part <a id="id330" class="indexterm"/>begins. Add two pure virtual methods called <code class="literal">paint()</code> and <code class="literal">initialize()</code>. Also remember about adding a virtual destructor.</p><div><div><h3 class="title"><a id="tip41"/>Tip</h3><p>Instead of making <code class="literal">initialize()</code> a pure virtual function, you can implement its body in such a way that it will call <code class="literal">initializeOpenGLFunctions()</code> to fulfill the requirements of the <code class="literal">QOpenGFunctions</code> class. Then, subclasses of <code class="literal">AbstractGLScene</code> can make sure the functions are initialized properly by calling the base class implementation of <code class="literal">initialize()</code>.</p></div></div><p>Next, create a subclass of <code class="literal">QOpenGLWindow</code> and call it <code class="literal">SceneGLWindow</code>. Equip it with setter and getter methods to allow the object to operate on an <code class="literal">AbstractGLScene</code> instance.</p><p>Then reimplement the <code class="literal">initializeGL()</code> and <code class="literal">paintGL()</code> methods and make them call appropriate equivalents in the scene:</p><div><pre class="programlisting">void SceneGLWindow::initializeGL() { if(scene()) scene()-&gt;initialize(); }
void SceneGLWindow::paintGL() { if(scene()) scene()-&gt;paint(); }</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec82"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have just set up a class chain that separates the window code from the actual OpenGL scene. The window forwards all calls related to scene contents to the scene object so that when the window is requested to repaint itself, it delegates the task to the scene object. Note that prior to doing that, the window will make the GL context current; therefore, all OpenGL calls the scene makes will be related to that context. You can store the code created in this exercise for later reuse in further exercises and your own projects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Time for action – drawing a textured cube</h1></div></div></div><p>Subclass <a id="id331" class="indexterm"/>
<code class="literal">AbstractGLScene</code> and implement the constructor to match the one from <code class="literal">AbstractGLScene</code>. Add a method to store a <code class="literal">QImage</code> object in the scene that will contain texture data for the cube. Add a <code class="literal">QOpenGLTexture</code> pointer member as well, which will contain the texture, initialize it to 0 in the constructor, and delete it in the destructor. Let's call the image object <code class="literal">m_tex</code> and the texture <code class="literal">m_texture</code>. Now add a <a id="id332" class="indexterm"/>protected <code class="literal">initializeTexture()</code> method and fill it with the following code:</p><div><pre class="programlisting">void initializeTexture() {
  m_texture = new QOpenGLTexture(m_tex.mirrored());
  m_texture-&gt;setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
  m_texture-&gt;setMagnificationFilter(QOpenGLTexture::Linear);
}</pre></div><p>The function first mirrors the image vertically. This is because OpenGL expects the texture to be "upside down". Then we create a <code class="literal">QOpenGLTexture</code> object, passing it our image. Then we set minification and magnification filters so that the texture looks better when it is scaled.</p><p>We are now ready to implement the <code class="literal">initialize()</code> method that will take care of setting up the texture and the scene itself.</p><div><pre class="programlisting">void initialize() {
  AbstractGLScene::initialize();
  m_initialized = true;
  if(!m_tex.isNull()) initializeTexture();
  glClearColor(1,1,1,0);
  glShadeModel(GL_SMOOTH);
}</pre></div><p>We make use of a flag called <code class="literal">m_initialized</code>. This flag is needed to prevent the texture from being set up too early (when no GL context is available yet). Then we check if the texture image is set (using the <code class="literal">QImage::isNull()</code> method); if so, we initialize the texture. Then we set some additional properties of the GL context.</p><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>In the setter for <code class="literal">m_tex</code>, add code that checks if <code class="literal">m_initialized</code> is set to <code class="literal">true</code> and if so, calls <code class="literal">initializeTexture()</code>. This is to make certain that the texture is properly set regardless of the order in which the setter and <code class="literal">initialize()</code> are called. Also remember to set <code class="literal">m_initialized</code> to <code class="literal">false</code> in the constructor.</p></div></div><p>The next step is to prepare the cube data. We will define a special data structure for the cube that groups vertex coordinates and texture data in a single object. To store coordinates, we are going to use classes tailored to that purpose—<code class="literal">QVector3D</code> and <code class="literal">QVector2D</code>.</p><div><pre class="programlisting">struct TexturedPoint {
  QVector3D coord;
  QVector2D uv;
  TexturedPoint(const QVector3D&amp; pcoord, const QVector2D&amp; puv) { coord = pcoord; uv = puv; }
};</pre></div><p>
<code class="literal">QVector&lt;TexturedPoint&gt;</code> will hold information for the whole cube. The vector is initialized with data using the following code:</p><div><pre class="programlisting">void CubeGLScene::initializeCubeData() {
  m_data = {
    // FRONT FACE
    {{-0.5, -0.5,  0.5}, {0, 0}}, {{ 0.5, -0.5,  0.5}, {1, 0}},
    {{ 0.5,  0.5,  0.5}, {1, 1}}, {{-0.5,  0.5,  0.5}, {0, 1}},

    // TOP FACE
    {{-0.5,  0.5,  0.5}, {0, 0}}, {{ 0.5,  0.5,  0.5}, {1, 0}},
    {{ 0.5,  0.5, -0.5}, {1, 1}}, {{-0.5,  0.5, -0.5}, {0, 1}},

    // BACK FACE
    {{-0.5,  0.5, -0.5}, {0, 0}}, {{ 0.5,  0.5, -0.5}, {1, 0}},
    {{ 0.5, -0.5, -0.5}, {1, 1}}, {{-0.5, -0.5, -0.5}, {0, 1}},

    // BOTTOM FACE
    {{-0.5, -0.5, -0.5}, {0, 0}}, {{ 0.5, -0.5, -0.5}, {1, 0}},
    {{ 0.5, -0.5,  0.5}, {1, 1}}, {{-0.5, -0.5,  0.5}, {0, 1}},

    // LEFT FACE
    {{-0.5, -0.5, -0.5}, {0, 0}}, {{-0.5, -0.5,  0.5}, {1, 0}},
    {{-0.5,  0.5,  0.5}, {1, 1}}, {{-0.5,  0.5, -0.5}, {0, 1}},

    // RIGHT FACE
    {{ 0.5, -0.5,  0.5}, {0, 0}}, {{ 0.5, -0.5, -0.5}, {1, 0}},
    {{ 0.5,  0.5, -0.5}, {1, 1}}, {{ 0.5,  0.5,  0.5}, {0, 1}},
  };
}</pre></div><p>The code uses C++11 syntax to operate on the vector. If you have an older compiler, you will have to use <code class="literal">QVector::append()</code> instead.</p><div><pre class="programlisting">m_data.append(TexturedPoint(QVector3D(...), QVector2D(...)));</pre></div><p>The cube consists of six faces and is centered on the origin of the coordinate system. The following image presents the same data in graphical form. Purple figures are texture coordinates in UV coordinate <a id="id333" class="indexterm"/>space.</p><div><img src="img/8874OS_05_14.jpg" alt="Time for action – drawing a textured cube"/></div><p>
<code class="literal">initializeCubeData()</code> should be called from the scene constructor or from the <code class="literal">initialize()</code> method. What <a id="id334" class="indexterm"/>remains is the painting code.</p><div><pre class="programlisting">  void CubeGLScene::paint() {
    glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT);
    glViewport(0, 0, window()-&gt;width(), window()-&gt;height());
    glLoadIdentity();

    glRotatef( 45, 1.0, 0.0, 0.0 );
    glRotatef( 45, 0.0, 1.0, 0.0 );

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    paintCube();
  }</pre></div><p>First we set up the viewport and then we rotate the view. Before calling <code class="literal">paintCube()</code>, which is going to render the <a id="id335" class="indexterm"/>cube itself, we enable depth testing and face culling so that only visible faces are drawn. The <code class="literal">paintCube()</code> routine looks as follows:</p><div><pre class="programlisting">void CubeGLScene::paintCube() {
  if(m_texture)
    m_texture-&gt;bind();
  glEnable(GL_TEXTURE_2D);
  glBegin(GL_QUADS);
  for(int i=0;i&lt;m_data.size();++i) {
    const TexturedPoint &amp;pt = m_data.at(i);
    glTexCoord2d(pt.uv.x(), pt.uv.y());
    glVertex3f(pt.coord.x(), pt.coord.y(), pt.coord.z());
  }
  glEnd();
  glDisable(GL_TEXTURE_2D);
}</pre></div><p>First the texture is bound and texturing is enabled. Then we enter the quad drawing mode and stream in data from our data structure. Finally, we disable texturing again.</p><p>For completeness, here is a <code class="literal">main()</code> function that executes the scene:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QGuiApplication app(argc, argv);
  SceneGLWindow window;
<strong>  QSurfaceFormat fmt;</strong>
<strong>  fmt.setSamples(16);</strong>
<strong>  window.setFormat(fmt);</strong>
  CubeGLScene scene(&amp;window);
  window.setScene(&amp;scene);
  scene.setTexture(QImage(":/texture.jpg"));
  window.resize(600,600);
  window.show();
  return app.exec();
}</pre></div><p>Please note the use of <code class="literal">QSurfaceFormat</code> to enable multisample antialiasing for the scene. We have also put the texture <a id="id336" class="indexterm"/>image into a resource file to avoid problems with the relative path to the file.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Have a go hero – animating a cube</h2></div></div></div><p>Try modifying the <a id="id337" class="indexterm"/>code to make the cube animated. To do that, have the scene <a id="id338" class="indexterm"/>inherit <code class="literal">QObject</code>, add an angle property of type <code class="literal">float</code> to it (remember about the <code class="literal">Q_OBJECT</code> macro). Then modify one of the <code class="literal">glRotatef()</code> lines to use the angle value instead of a constant value. Put the following code in <code class="literal">main()</code> right before calling <code class="literal">app.exec()</code>:</p><div><pre class="programlisting">QPropertyAnimation anim(&amp;scene, "angle");
anim.setStartValue(0);
anim.setEndValue(359);
anim.setDuration(5000);
anim.setLoopCount(-1);
anim.start();</pre></div><p>Remember to put a call to <a id="id339" class="indexterm"/>
<code class="literal">window()-&gt;update()</code> in the setter for the angle <a id="id340" class="indexterm"/>property so that the scene is redrawn.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Modern OpenGL with Qt</h2></div></div></div><p>OpenGL code <a id="id341" class="indexterm"/>shown in the previous section uses a very old technique of streaming vertices one by one into a fixed OpenGL pipeline. Nowadays, modern hardware is much more feature rich and not only does it allow faster processing of vertex data but it also offers the ability to adjust different processing stages with the use of reprogrammable units called shaders. In this section, we will take a look at what Qt has to offer in the domain of a "modern" approach to using OpenGL.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec29"/>Shaders</h3></div></div></div><p>Qt can make use of <a id="id342" class="indexterm"/>shaders through a set of classes based around <code class="literal">QOpenGLShaderProgram</code>. This class allows compiling, linking, and executing shader programs written in GLSL. You can check if your OpenGL implementation supports shaders by <a id="id343" class="indexterm"/>inspecting the result of a static <code class="literal">QOpenGLShaderProgram::hasOpenGLShaderPrograms()</code> call that accepts a pointer to a GL context. All modern hardware and all decent graphics drivers should have some support for shaders. A single shader is represented by an instance of the <code class="literal">QOpenGLShader</code> class. Using it, you can decide on the type of shader, associate, and shader source code. The latter is done by calling <code class="literal">QOpenGLShader::compileSourceCode()</code>, which has a number of overloads for handling different input formats.</p><p>Qt supports all kinds of shaders, with the most common being vertex and fragment shaders. These are both part of the classic OpenGL pipeline. You can see an illustration of the pipeline on the following diagram:</p><div><img src="img/8874OS_05_15.jpg" alt="Shaders"/></div><p>When you have a set of shaders defined, you can assemble a complete program by using <code class="literal">QOpenGLShaderProgram::addShader()</code>. After all shaders are added, you can <code class="literal">link()</code> the program and <code class="literal">bind()</code> it to the current GL context. The program class has a number of methods for setting values of different input parameters—uniforms and attributes both in singular and array versions. Qt provides mappings between its own types (such as <code class="literal">QSize</code> or <code class="literal">QColor</code>) to GLSL <a id="id344" class="indexterm"/>counterparts (for example, <code class="literal">vec2</code> and <code class="literal">vec4</code>) to make the programmer's life even easier.</p><p>A typical code flow for using <a id="id345" class="indexterm"/>shaders for rendering is as follows (first a vertex shader is created and compiled):</p><div><pre class="programlisting">QOpenGLShader vertexShader(QOpenGLShader::Vertex);
QByteArray code = "uniform vec4 color;\n"
    "uniform highp mat4 matrix;\n"
    "void main(void) { gl_Position = gl_Vertex*matrix; }";
vertexShader.compileSourceCode(code);</pre></div><p>The process is repeated for a fragment shader:</p><div><pre class="programlisting">QOpenGLShader fragmentShader(QOpenGLShader::Fragment);
code = "uniform vec4 color;\n"
    "void main(void) { gl_FragColor = color; }";
fragmentShader.compileSourceCode(code);</pre></div><p>Then shaders are linked into a single program in a given GL context:</p><div><pre class="programlisting">QOpenGLShaderProgram program(context);
program.addShader(vertexShader);
program.addShader(fragmentShader);
program.link();</pre></div><p>Whenever the program is used, it should be bound to the current GL context and filled with required data:</p><div><pre class="programlisting">program.bind();
QMatrix4x4 m = …;
QColor color = Qt::red;
program.setUniformValue("matrix", m);
program.setUniformValue("color", color);</pre></div><p>After that, calls activating the <a id="id346" class="indexterm"/>render pipeline are going to use the bound program:</p><div><pre class="programlisting">glBegin(GL_TRIANGLE_STRIP);
…
glEnd();</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Time for action – shaded objects</h1></div></div></div><p>Let's convert our last <a id="id347" class="indexterm"/>program so that it uses shaders. To make the cube better, we will implement a smooth lighting model using the Phong algorithm. At the same time, we will learn to use some helper classes that Qt offers for use with OpenGL.</p><p>The basic goals for this mini-project are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use vertex and fragment shaders for rendering a complex object</li><li class="listitem" style="list-style-type: disc">Handle model, view, and projection matrices</li><li class="listitem" style="list-style-type: disc">Use attribute arrays for faster drawing</li></ul></div><p>Start by creating a new subclass of <code class="literal">AbstractGLScene</code>. Let's give it the following interface:</p><div><pre class="programlisting">class ShaderGLScene : public QObject, public AbstractGLScene {
  Q_OBJECT
public:
  ShaderGLScene(SceneGLWindow *wnd);
  void initialize();
  void paint();
protected:
  void initializeObjectData();
private:
  struct ScenePoint {
    QVector3D coords;
    QVector3D normal;
    ScenePoint(const QVector3D &amp;c, const QVector3D &amp;n);
  };
<strong>  QOpenGLShaderProgram m_shader;</strong>
<strong>  QMatrix4x4 m_modelMatrix;</strong>
<strong>  QMatrix4x4 m_viewMatrix;</strong>
<strong>  QMatrix4x4 m_projectionMatrix;</strong>
  QVector&lt;ScenePoint&gt; m_data;
};</pre></div><p>Significant changes to the class interface in comparison with the previous project have been highlighted. We're not using textures in this project so <code class="literal">TexturedPoint</code> was simplified to <code class="literal">ScenePoint</code> with UV texture coordinates removed.</p><p>We can start implementing the interface with the <code class="literal">initializeObjectData()</code> function. We're not going to go line by line explaining what the body of the method does. You can implement it as you want; it is important that the method fill the <code class="literal">m_data</code> member with information about vertices and their normals.</p><div><div><h3 class="title"><a id="tip43"/>Tip</h3><p>In the sample code that comes with this book, you can find code that loads data from a file in PLY format generated with the Blender 3D program. To export a model from Blender, make sure it consists of just triangles (for that, select the model, go into the Edit mode by pressing <em>Tab</em>, open the <strong>Faces</strong> menu with <em>Ctrl</em> + <em>F</em>, and choose <strong>Triangulate Faces</strong>). Then click on <strong>File</strong> and <strong>Export</strong>; choose <strong>Stanford (.ply)</strong>. You will end up with a text file containing vertex and normal data as well as face definitions for the vertices.</p></div></div><p>You can always reuse the cube object from the previous project. Just be aware that its normals are not <a id="id348" class="indexterm"/>calculated properly for smooth shading; thus, you will have to correct them.</p><p>Before we can set up the shader program, we have to be aware of what the actual shaders look like. Shader code is going to be loaded from external files, so the first step is to add a new file to the project. In Creator, click on <strong>File</strong> and choose <strong>New File or Project</strong>; from the bottom pane, choose <strong>GLSL</strong>, and from the list of available templates choose <strong>Vertex Shader (Desktop OpenGL)</strong>. Call the new file <code class="literal">phong.vert</code> and input the following code:</p><div><pre class="programlisting">uniform highp mat4 modelViewMatrix;
uniform highp mat3 normalMatrix;
uniform highp mat4 projectionMatrix;
uniform highp mat4 mvpMatrix;

attribute highp vec4 Vertex;
attribute mediump vec3 Normal;

varying mediump vec3 N;
varying highp vec3 v;

void main(void) {
  N = normalize(normalMatrix * Normal);
  v = vec3(modelViewMatrix * Vertex);
  gl_Position = mvpMatrix*Vertex;
}</pre></div><p>The code is very simple. We declare four matrices representing different stages of coordinate mapping for the scene. We also define two input attributes—<code class="literal">Vertex</code> and <code class="literal">Normal</code>—which contain the vertex data. The shader is going to output two pieces of data—a normalized vertex normal and a transformed vertex coordinate as seen by the camera. Of course, apart from that we set <code class="literal">gl_Position</code> to be the final vertex coordinate. In each case, we want to be compliant with the OpenGL/ES specification so we prefix each variable declaration with a precision specifier.</p><p>Next, add another file, call it <code class="literal">phong.frag</code>, and make it a Fragment Shader (Desktop OpenGL). The content of the file is a typical ambient, diffuse, and specular calculation:</p><div><pre class="programlisting">struct Material {
  lowp vec3 ka;
  lowp vec3 kd;
  lowp vec3 ks;
  lowp float shininess;
};

struct Light {
  lowp vec4 position;
  lowp vec3 intensity;
};

uniform Material mat;
uniform Light light;
varying mediump vec3 N;
varying highp vec3 v;

void main(void) {
  mediump vec3 n = normalize(N);
  highp vec3 L = normalize(light.position.xyz - v);
  highp vec3 E = normalize(-v);
  mediump vec3 R = normalize(reflect(-L, n));

  lowp float LdotN = dot(L, n);
  lowp float diffuse = max(LdotN, 0.0);
  lowp vec3 spec = vec3(0,0,0);

  if(LdotN &gt; 0.0) {
    float RdotE = max(dot(R, E), 0.0);
    spec = light.intensity*pow(RdotE, mat.shininess);
  }
  vec3 color = light.intensity * (mat.ka + mat.kd*diffuse + mat.ks*spec);
  gl_FragColor = vec4(color, 1.0);
}</pre></div><p>Apart from using the <a id="id349" class="indexterm"/>two varying variables to obtain the interpolated normal (<code class="literal">N</code>) and fragment (<code class="literal">v</code>) position, the shader declares two structures for keeping light and material information. Without going into the details about how the shader itself works, it calculates three components—ambient light, diffused light, and specular reflection—adds them together, and sets that as the fragment color. Since all the per vertex input data is interpolated for each fragment, the final color is calculated individually for each pixel.</p><p>Once we know what the shaders expect, we can set up the shader program object. Let's go through the <code class="literal">initialize()</code> method:</p><div><pre class="programlisting">void initialize() {
  AbstractGLScene::initialize();
  glClearColor(0,0,0,0);</pre></div><p>First we call the base class implementation and set the background color of the scene to black, as shown in the following code:</p><div><pre class="programlisting">  m_shader.addShaderFromSourceCode(QOpenGLShader::Vertex, fileContent("phong.vert"));
  m_shader.addShaderFromSourceCode(QOpenGLShader::Fragment, fileContent("phong.frag"));
  m_shader.link();</pre></div><p>Then we add two shaders to the program reading their source code from external files with the use of a custom helper function called <code class="literal">fileContent()</code>. This function essentially opens a file and returns its content. Then we link the shader program. The <code class="literal">link()</code> function returns a Boolean value but for simplicity we skip the error check here. The next step is to prepare all the input data for the shader, as shown:</p><div><pre class="programlisting">  m_shader.bind();
  m_shader.setAttributeArray("Vertex", GL_FLOAT, m_data.constData(), 3, sizeof(ScenePoint));
  m_shader.enableAttributeArray("Vertex");
  m_shader.setAttributeArray("Normal", GL_FLOAT, &amp;m_data[0].normal, 3, sizeof(ScenePoint)); 
  m_shader.enableAttributeArray("Normal");
  m_shader.setUniformValue("material.ka", QVector3D(0.1, 0, 0.0));
  m_shader.setUniformValue("material.kd", QVector3D(0.7, 0.0, 0.0));
  m_shader.setUniformValue("material.ks", QVector3D(1.0, 1.0, 1.0));
  m_shader.setUniformValue("material.shininess", 128.0f);
  m_shader.setUniformValue("light.position", QVector3D(2, 1, 1));
  m_shader.setUniformValue("light.intensity", QVector3D(1,1,1));</pre></div><p>First the shader program is bound to the current context so that we can operate on it. Then we enable the setup of two attribute arrays—one for vertex coordinates and the other for their normals. We inform the program that an attribute called <code class="literal">Vertex</code> consists of three values of type <code class="literal">GL_FLOAT</code>. The first value is located at <code class="literal">m_data.constData()</code>, and data for the next vertex is located <code class="literal">sizeof(ScenePoint)</code> bytes later than data for the current point. Then we have a similar declaration for the <code class="literal">Normal</code> attribute, with the only exception that the first piece of data is <a id="id350" class="indexterm"/>placed at <code class="literal">&amp;m_data[0].normal</code>. By informing the program about layout of the data, we allow it to quickly read all the vertex information when needed.</p><p>After attribute arrays are set, we pass values for uniform variables to the shader program, which concludes the shader program setup. You will notice that we didn't set values for uniforms representing the various matrices; we will do that separately for each repaint. The <code class="literal">paint()</code> method takes care of setting up all the matrices:</p><div><pre class="programlisting">void ObjectGLScene::paint() {
  m_projectionMatrix.setToIdentity();
  qreal ratio = qreal(window()-&gt;width()) / qreal(window()-&gt;height());
  m_projectionMatrix.perspective(90, ratio, 0.5, 40); // angle, ratio, near plane, far plane
  m_viewMatrix.setToIdentity();
  QVector3D eye = QVector3D(0,0,2);
  QVector3D center = QVector3D(0,0,0);
  QVector3D up = QVector3D(0, 1, 0);
  m_viewMatrix.lookAt(eye, center, up);</pre></div><p>In this method, we make heavy use of the <code class="literal">QMatrix4x4</code> class that represents a 4 x 4 matrix in so-called row-major order, which is suited to use with OpenGL. At the beginning, we reset the projection matrix and use the <code class="literal">perspective()</code> method to give it a perspective transformation based on <a id="id351" class="indexterm"/>current window size. Afterwards, the view matrix is also reset and the <code class="literal">lookAt()</code> method is used to prepare the transformation for the camera; center value indicates the center of the view eye is looking at. The <code class="literal">up</code> vector dictates the vertical orientation of the camera (with respect to the eye position).</p><p>The next couple of lines are similar to what we had in the previous project:</p><div><pre class="programlisting">  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glViewport(0, 0, window()-&gt;width(), window()-&gt;height());
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);</pre></div><p>After that, we do the actual painting of the object:</p><div><pre class="programlisting">  m_modelMatrix.setToIdentity();
  m_modelMatrix.rotate(45, 0, 1, 0);
  QMatrix4x4 modelViewMatrix = m_viewMatrix*m_modelMatrix;
  paintObject(modelViewMatrix);
}</pre></div><p>We start by setting the model matrix, which dictates where the rendered object is positioned relative to the center of the world (in this case, we say it is rotated 45 degrees around the <em>y</em> axis). Then we assemble the model-view matrix (denoting the position of the object relative to the camera) and pass it to the <code class="literal">paintObject()</code> method, as shown:</p><div><pre class="programlisting">void paintCube(const QMatrix4x4&amp; mvMatrix) {
  m_shader.bind();
  m_shader.setUniformValue("projectionMatrix", m_projectionMatrix);
  m_shader.setUniformValue("modelViewMatrix", mvMatrix);
  m_shader.setUniformValue("mvpMatrix", m_projectionMatrix*mvMatrix);
  m_shader.setUniformValue("normalMatrix", mvMatrix.normalMatrix());
  const int pointCount = m_data.size();
  glDrawArrays(GL_TRIANGLES, 0, pointCount);
}</pre></div><p>This method is very easy since most of the work was done when setting up the shader program. First the shader program is activated. Then all required matrices are set as uniforms for the shader. Included is the normal matrix calculated from the model-view matrix. Finally, a call to <code class="literal">glDrawArrays()</code> is issued telling it to render with the <code class="literal">GL_TRIANGLES</code> mode using active arrays, starting from the beginning of the array (offset <code class="literal">0</code>) and reading in the <code class="literal">pointCount</code> entities from the array.</p><p>After you run the project, you should get a result similar to the following one, which happens to contain the <a id="id352" class="indexterm"/>Blender monkey, Suzanne:</p><div><img src="img/8874OS_05_16.jpg" alt="Time for action – shaded objects"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl3sec30"/>GL buffers</h2></div></div></div><p>Using attribute arrays <a id="id353" class="indexterm"/>can speed up programming, but for rendering, all data still <a id="id354" class="indexterm"/>requires to be copied to the graphics card on each use. This can be avoided with OpenGL buffer objects. Qt provides a neat interface for such objects with its <code class="literal">QOpenGLBuffer</code> class. Currently supported buffer types are vertex buffers (where the buffer contains vertex information), index buffers (where the content of the buffer is a set of indexes to other buffers that can be used with <code class="literal">glDrawElements()</code>), and also less commonly used pixel pack buffers and pixel unpack buffers. The buffer is essentially a block of memory that can be uploaded to the graphics card and stored there for faster access. There are different usage patterns available that dictate how and when the buffer is transferred between the host memory and GPU memory. The most common pattern is a one-time upload of vertex information to the GPU that can later be referred to during rendering as many times as needed. Changing an existing application that uses an attribute array to use vertex buffers is very easy. First a buffer needs to be instantiated:</p><div><pre class="programlisting">QOpenGLBuffer vbo(QOpenGLBuffer::VertexBuffer);</pre></div><p>Then its usage pattern needs to be set. In case of a one-time upload, the most appropriate type is <code class="literal">StaticDraw</code>, as shown:</p><div><pre class="programlisting">vbo.setUsagePattern(QOpenGLBuffer::StaticDraw);</pre></div><p>Then the buffer itself has to be created for the current context:</p><div><pre class="programlisting">context-&gt;makeCurrent(this);
vbo.create();</pre></div><p>The next step is to actually <a id="id355" class="indexterm"/>allocate some memory for the buffer:</p><div><pre class="programlisting">vbo.allocate(vertexCount*sizeof(ScenePoint));</pre></div><p>To write data to the buffer, there <a id="id356" class="indexterm"/>are two options. First you can attach the buffer to the application's memory space using a call to <code class="literal">map()</code> and then fill the data using a returned pointer:</p><div><pre class="programlisting">ScenePoint *buffer = static_cast&lt;ScenePoint*&gt;(vbo.map(QOpenGLBuffer::WriteOnly));
assert(buffer!=0);
for(int i=0;i&lt;vbo.size();++i) { buffer[i] = m_data[i]; }
vbo.unmap();</pre></div><p>An alternative approach is to write to the buffer directly using <code class="literal">write()</code>:</p><div><pre class="programlisting">const int spSize = sizeof(ScenePoint);
for(int i=0;i&lt;vbo.size();++i) { vbo.write (i*spSize, &amp;m_data[i], spSize); }</pre></div><p>Finally, the buffer can be used in the shader program in a way similar to an attribute array:</p><div><pre class="programlisting">vbo.bind();
m_shader.setAttributeBuffer("Vertex"", GL_FLOAT, 0, 3, sizeof(ScenePoint));
m_shader.setAttributeBuffer("Normal"", GL_FLOAT, sizeof(QVector3D), 3, sizeof(ScenePoint));</pre></div><p>The result is that all the data is uploaded to the GPU once and then used as needed by the current shader program or <a id="id357" class="indexterm"/>other OpenGL call supporting buffer <a id="id358" class="indexterm"/>objects.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl3sec31"/>Off-screen rendering</h2></div></div></div><p>Sometimes, it is <a id="id359" class="indexterm"/>useful to render a GL scene not to the screen but rather to some image that can be later processed externally or used as a texture in some other part of rendering. For that, the concept of <strong>Framebuffer Objects</strong> (<strong>FBO</strong>) was created. An FBO is a rendering surface that behaves like the regular device frame buffer, with the only exception that the resulting pixels do not land on the screen. An FBO target can <a id="id360" class="indexterm"/>be bound as a texture in an existing scene or dumped as an image to regular computer memory. In Qt, such an entity is represented by a <code class="literal">QOpenGLFramebufferObject</code> class.</p><p>Once you have a current OpenGL context, you can create an instance of <code class="literal">QOpenGLFramebufferObject</code> using one of the available constructors. A mandatory parameter to pass is the size of the canvas (either as a <code class="literal">QSize</code> object or as a pair of integers describing the width and height of the frame). Different constructors accept other parameters such as the type of texture the FBO is to generate or a set of parameters encapsulated in <code class="literal">QOpenGLFramebufferObjectFormat</code>.</p><p>When the object is <a id="id361" class="indexterm"/>created, you can issue a <code class="literal">bind()</code> call on it, which switches the OpenGL pipeline to render to the FBO instead of the default target. A complementary method is <code class="literal">release()</code>, which restores the default rendering target. Afterwards, the FBO can be queried to return the ID of the OpenGL texture (using the <code class="literal">texture()</code> method) or to convert the texture to <code class="literal">QImage</code> (by invoking <code class="literal">toImage()</code>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we learned about using graphics with Qt. You should be aware we have only scratched the surface of Qt capabilities in this regard. What was presented in this chapter will let you implement custom widgets, do some basic painting on images, and render OpenGL scenes. There are many more functionalities that we didn't go through, such as composition modes, paths, SVG handling, and many others. We will come back to some of these features in subsequent chapters, but we will leave most for you to discover on your own.</p><p>In the next chapter, we will learn a more object-oriented approach to do graphics, called Graphics View.</p></div></body></html>