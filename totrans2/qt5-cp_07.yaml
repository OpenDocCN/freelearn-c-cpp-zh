- en: Chapter 7. Parsing JSON and XML Documents to Use Online APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：解析 JSON 和 XML 文档以使用在线 API
- en: 'In this chapter, you''ll find the powerful application, Qt, running on the
    popular Android devices. Following the introduction of Qt application development
    for Android, it also utilizes online APIs, which usually return JSON or XML documents.
    The topics that are covered in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将找到强大的应用程序 Qt 在流行的 Android 设备上运行。在介绍 Android Qt 应用程序开发之后，它还利用在线 API，这些
    API 通常返回 JSON 或 XML 文档。本章涵盖的主题如下：
- en: Setting up Qt for Android
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Qt for Android
- en: Parsing JSON results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 JSON 结果
- en: Parsing XML results
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 XML 结果
- en: Building Qt applications for Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Android 构建Qt应用程序
- en: Parsing JSON in QML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 QML 中解析 JSON
- en: Setting up Qt for Android
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Qt for Android
- en: Qt for Android requires at least an API level 10 (for Android 2.3.3 platforms).
    Most Qt modules are supported, which means your Qt application can be deployed
    on Android with little or no modification. For development, both Qt Widget-based
    applications and Qt Quick applications in Qt Creator are supported on Android.
    However, setting up Qt for Android on a Windows PC is not very straightforward.
    Therefore, before we venture deeper into anything, let's set up the development
    environment for Qt on Android.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Qt for Android 至少需要 API 级别 10（适用于 Android 2.3.3 平台）。大多数 Qt 模块都得到支持，这意味着您的 Qt
    应用程序可以在 Android 上部署，只需进行少量或无需修改。在 Qt Creator 中，支持基于 Qt Widget 的应用程序和 Qt Quick
    应用程序的开发。然而，在 Windows PC 上设置 Qt for Android 并非非常直接。因此，在我们深入之前，让我们先设置 Android 上的
    Qt 开发环境。
- en: 'First, you need to install Qt for Android. If you''re using an online installer,
    remember to select the Android components, as shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装 Qt for Android。如果您使用的是在线安装程序，请记住选择 Android 组件，如下面的截图所示：
- en: '![Setting up Qt for Android](img/4615OS_07_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Qt for Android](img/4615OS_07_01.jpg)'
- en: Here, we only chose **Android armv7**, which enables us to deploy applications
    for ARMv7 Android devices. If you're using an offline installer, download Qt for
    the Android installer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只选择了 **Android armv7**，这使得我们能够部署适用于 ARMv7 Android 设备的应用程序。如果您使用的是离线安装程序，请下载
    Android 安装程序的 Qt。
- en: Now, let's install a **Java Development Kit** (**JDK**). There is no way to
    get rid of Java, since Android heavily depends on it. Also, note that you need
    to install at least Version 6 of JDK, according to [http://doc.qt.io/qt-5/androidgs.html](http://doc.qt.io/qt-5/androidgs.html).
    You can download JDK from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    You also need to set a `JAVA_HOME` environment variable in the JDK installation
    directory, `D:\Program Files\Java\jdk1.8.0_25`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装一个 **Java 开发工具包**（**JDK**）。由于 Android 严重依赖它，所以无法摆脱 Java。此外，请注意，根据 [http://doc.qt.io/qt-5/androidgs.html](http://doc.qt.io/qt-5/androidgs.html)，您需要安装至少
    JDK 版本 6。您可以从 [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
    下载 JDK。您还需要在 JDK 安装目录 `D:\Program Files\Java\jdk1.8.0_25` 中设置一个 `JAVA_HOME` 环境变量。
- en: Now, let's install two kits from Google, the Android SDK and Android NDK. Always
    remember to download the latest version; here we use Android SDK r24.0.2 and Android
    NDK r10b.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装来自 Google 的两个工具包，Android SDK 和 Android NDK。始终记住下载最新版本；这里我们使用 Android
    SDK r24.0.2 和 Android NDK r10b。
- en: 'After you install the Android SDK, run the SDK Manager. Install or update **Android
    SDK Tools**, **Android SDK Platform-tools**, **Android SDK Build-tools**, **Google
    USB Driver**, at least one API level''s **SDK Platform**, and **ARM EABI v7a System
    Image** for the purpose of our task. For this chapter, we installed API 19''s
    **SDK Platform** and **ARM EABI v7a System Image**. Then, edit the `PATH` environment
    variable. Add the path of the platform and SDK tools to it with a semicolon as
    a separator. If `D:\Program Files (x86)\Android\android-sdk` is the path of **Android
    SDK Tools**, it would be as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装 Android SDK 后，运行 SDK 管理器。安装或更新 **Android SDK 工具**、**Android SDK 平台工具**、**Android
    SDK 构建工具**、**Google USB 驱动程序**，至少一个 API 级别的 **SDK 平台**，以及 **ARM EABI v7a 系统镜像**，以完成我们的任务。对于本章，我们安装了
    API 19 的 **SDK 平台**和 **ARM EABI v7a 系统镜像**。然后，编辑 `PATH` 环境变量。使用分号作为分隔符，将平台和 SDK
    工具的路径添加到其中。如果 `D:\Program Files (x86)\Android\android-sdk` 是 **Android SDK 工具**
    的路径，它将如下所示：
- en: '`D:\Program Files (x86)\Android\android-sdk\platform-tools;D:\Program Files
    (x86)\Android\android-sdk\tools`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`D:\Program Files (x86)\Android\android-sdk\platform-tools;D:\Program Files
    (x86)\Android\android-sdk\tools`'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android SDK and NDK can be obtained on the Android developer website, [http://developer.android.com](http://developer.android.com).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK和NDK可以在Android开发者网站上获得，[http://developer.android.com](http://developer.android.com)。
- en: Once you download the NDK, extract the `zip` file to your hard drive, `D:\android-ndk`.
    Then, add an environment variable named `ANDROID_NDK_ROOT` with the value, `D:\android-ndk`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载NDK后，将`zip`文件解压到您的硬盘上，`D:\android-ndk`。然后，添加一个名为`ANDROID_NDK_ROOT`的环境变量，其值为`D:\android-ndk`。
- en: Similar procedures should be applied for Apache Ant. You can download it from
    [http://ant.apache.org/bindownload.cgi](http://ant.apache.org/bindownload.cgi).
    We use Apache Ant 1.9.4 in this book. There is no environment variable that needs
    to be set here. Now, reboot your computer if you're using Windows so that the
    environment variables can be refreshed and loaded correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Apache Ant，也应采用类似步骤。您可以从[http://ant.apache.org/bindownload.cgi](http://ant.apache.org/bindownload.cgi)下载它。本书中使用的是Apache
    Ant 1.9.4。这里不需要设置任何环境变量。现在，如果您使用的是Windows，请重新启动计算机，以便刷新并正确加载环境变量。
- en: Open AVD Manager and create a new virtual device. You'd better choose a smaller
    virtual device such as Nexus S for this exercise, as shown in the following screenshot.
    Feel free to change it if you want, but remember to tick **Use Host GPU**, which
    will make the virtual device use GLES to accelerate the graphics. If you haven't
    turned that on, you'll get an extremely slow virtual device that might even be
    too sluggish to test applications on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开AVD管理器并创建一个新的虚拟设备。对于这个练习，您最好选择一个较小的虚拟设备，如Nexus S，如图所示。如果您想更改它，请随意更改，但请记住勾选**使用主机GPU**，这将使虚拟设备使用GLES来加速图形。如果您没有开启它，您将得到一个极其缓慢的虚拟设备，甚至可能太慢以至于无法在上面测试应用程序。
- en: '![Setting up Qt for Android](img/4615OS_07_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![设置Qt for Android](img/4615OS_07_02.jpg)'
- en: 'Now, open Qt Creator; navigate to **Tools** | **Options**. See if Qt Version
    in **Build & Run** has an Android entry. You have to manually add Qt for Android
    if it''s not there. Then, switch to the **Android** options, set up JDK, Android
    SDK, Android NDK, and Ant, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开Qt Creator；导航到**工具** | **选项**。查看**构建和运行**中的Qt版本是否有Android条目。如果没有，您必须手动添加Qt
    for Android。然后，切换到**Android**选项，设置JDK、Android SDK、Android NDK和Ant，如图所示：
- en: '![Setting up Qt for Android](img/4615OS_07_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![设置Qt for Android](img/4615OS_07_03.jpg)'
- en: The warning for missing architectures can be safely ignored because we won't
    develop applications for MIPS and x86 Android in this chapter. However, pay attention
    to it if you need to deploy your applications on these hardware platforms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缺少架构的警告可以安全忽略，因为我们不会在本章中为MIPS和x86 Android开发应用程序。但是，如果您需要在这些硬件平台上部署应用程序，请注意这一点。
- en: Click on **Apply** and switch to the **Devices** options. There should be a
    **Run on Android** item in the **Device** combobox. An auto-detected **Android
    for armeabi-v7a** is expected if you navigate to **Build & Run** | **Kits** now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**应用**并切换到**设备**选项。在**设备**组合框中应该有一个**在Android上运行**项。如果您现在导航到**构建和运行** | **套件**，应该期望自动检测到**Android
    for armeabi-v7a**。
- en: Now, let's test if we can run a Qt application on our virtual Android device.
    Open AVD Manager and start the virtual device. We start it first because it could
    take a lot of time. Then, open Qt Creator and make a simple application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下我们是否可以在我们的虚拟Android设备上运行Qt应用程序。打开AVD管理器并启动虚拟设备。我们首先启动它，因为它可能需要很长时间。然后，打开Qt
    Creator并创建一个简单的应用程序。
- en: Create a new Qt Widget-based application project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于Qt Widget的应用程序项目。
- en: Select **Android for armeabi-v7a Kit**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Android for armeabi-v7a Kit**。
- en: Edit `mainwindow.ui` and drag a label to `centralWidget`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`mainwindow.ui`并将一个标签拖到`centralWidget`。
- en: Change the **MainWindow** page's layout to **Lay Out Vertically** (or others)
    so that the widgets will be stretched automatically.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主窗口**页面的布局更改为**垂直布局**（或其它）以便小部件可以自动拉伸。
- en: Change the label's text to `Hello Android!` or something else.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签的文本更改为`Hello Android!`或其他内容。
- en: 'Wait for the time-consuming virtual Android device until it''s fully started.
    If it''s not, click on **Run** and wait for a few minutes. You''ll see this application
    running on our virtual Android device. As seen in the following screenshot, the
    Qt for Android development environment is set up successfully. So, we can move
    on and write an application that can use a camera to take photos:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 等待耗时的虚拟Android设备完全启动。如果它没有启动，请点击**运行**并等待几分钟。您将看到此应用程序在我们的虚拟Android设备上运行。如图所示，Qt
    for Android开发环境已成功设置。因此，我们可以继续编写一个可以使用摄像头拍照的应用程序：
- en: '![Setting up Qt for Android](img/4615OS_07_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![设置Qt用于Android](img/4615OS_07_04.jpg)'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Testing an application on a desktop while it's incomplete, and then testing
    it on a mobile platform would save plenty of time compared to testing on the virtual
    Android device all the time. In addition to this, it's much faster to test on
    a real device than a virtual one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序不完整的情况下在桌面上进行测试，然后在实际移动平台上进行测试，与始终在虚拟Android设备上进行测试相比，可以节省大量时间。此外，与虚拟设备相比，在真实设备上进行测试要快得多。
- en: Instead of tolerating a slow emulator, we're going to first develop the application
    on a desktop, then deploy it on an actual Android device and see if there is anything
    mismatched or inappropriate for mobile devices. Make any relevant changes accordingly.
    This could save you plenty of time. However, it still takes a longer time, even
    though the actual Android device is much more responsive than the virtual one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再忍受慢速的模拟器，而是首先在桌面上开发应用程序，然后在实际的Android设备上部署，看看是否有任何不适合移动设备的地方。相应地进行任何相关更改。这可以节省您大量时间。然而，即使实际的Android设备比虚拟设备更响应，这仍然需要更长的时间。
- en: Parsing JSON results
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON结果
- en: There are tons of companies that provide developers APIs to access to their
    services, including the dictionary, weather, and so on. In this chapter, we'll
    use Yahoo! Weather as an example to show you how to use its online API to get
    weather data. For more details about Yahoo! Weather API, refer to [https://developer.yahoo.com/weather/](https://developer.yahoo.com/weather/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多公司为开发者提供API，以访问他们的服务，包括字典、天气等。在本章中，我们将以Yahoo!天气为例，向您展示如何使用其在线API获取天气数据。有关Yahoo!天气API的更多详细信息，请参阅[https://developer.yahoo.com/weather/](https://developer.yahoo.com/weather/)。
- en: Now, let's create a new project named `Weather_Demo`, which is a Qt Widget-based
    application project. As usual, let's first design the UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`Weather_Demo`的新项目，这是一个基于Qt Widget的应用程序项目。像往常一样，让我们首先设计UI。
- en: '![Parsing JSON results](img/4615OS_07_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![解析JSON结果](img/4615OS_07_05.jpg)'
- en: We've removed the menu bar, tool bar, and status bar as we did before. Then,
    we added a **Label**, **Line Edit**, and **Push Button** on top of `centralWidget`.
    Their object names are `woeidLabel`, `woeidEdit`, and `okButton`, respectively.
    After this, another label named `locationLabel` is used to display the location
    returned from the API. The red rectangle is **Horizontal Layout**, which consists
    of `tempLabel` and `windLabel`, which are both **Label** and are separated by
    **Horizontal Spacer**. Append **Label**, whose object name is `attrLabel`, and
    then change its alignment to `AlignRight` and `AlignBottom`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了之前所做的菜单栏、工具栏和状态栏。然后，我们在`centralWidget`的顶部添加了一个**标签**、**行编辑**和**推送按钮**。它们的对象名称分别是`woeidLabel`、`woeidEdit`和`okButton`。之后，另一个名为`locationLabel`的标签用于显示API返回的位置。红色矩形是**水平布局**，由`tempLabel`和`windLabel`组成，它们都是**标签**，并通过**水平间隔**分隔。添加一个名为`attrLabel`的**标签**，然后将其对齐方式更改为`AlignRight`和`AlignBottom`。
- en: '**Where On Earth ID** (**WOEID**) is a 32-bit identifier that is unique and
    nonrepetitive. By using WOEID, we can avoid duplicity. However, this also means
    that we need to find out what WOEID is used for our location. Luckily, there are
    several websites that provide you with easy-to-use online tools to get the WOEID.
    One of them is the Zourbuth project, **Yahoo! WOEID Lookup**, which can be accessed
    at [http://zourbuth.com/tools/woeid/](http://zourbuth.com/tools/woeid/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Where On Earth ID** (**WOEID**) 是一个唯一的32位标识符，且不会重复。通过使用WOEID，我们可以避免重复。然而，这也意味着我们需要找出我们所在位置的WOEID。幸运的是，有几个网站提供了易于使用的在线工具来获取WOEID。其中之一是Zourbuth项目，**Yahoo!
    WOEID Lookup**，可以通过[http://zourbuth.com/tools/woeid/](http://zourbuth.com/tools/woeid/)访问。'
- en: 'Now, let''s move on and focus on the parsing of API results. We created a new
    C++ class, `Weather`, to deal with the Yahoo! Weather API. I''d like to introduce
    you to parsing the **JSON** (**JavaScript Object Notation**) results before XML.
    However, before we cook the `Weather` class, remember to add network to `QT` in
    the project file. In this case, the `Weather_Demo.pro` project file looks like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进，专注于API结果的解析。我们创建了一个新的C++类，`Weather`，用于处理Yahoo!天气API。在介绍如何解析**JSON**（**JavaScript对象表示法**）结果之前，我想先介绍XML。然而，在我们准备`Weather`类之前，请记住在项目文件中添加网络到`QT`。在这种情况下，`Weather_Demo.pro`项目文件看起来如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can write the `Weather` class. Its `weather.h` header file is pasted
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写`Weather`类。它的`weather.h`头文件如下所示：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition to the weather information query, we also use this class to get
    an attribution image, which is stated in the Yahoo! documentation. It is kind
    of trivial in traditional Qt/C++ that we have to use `QNetworkAccessManager` to
    access `QUrl`, because `QJsonDocument` cannot load from `QUrl` directly. Anyway,
    let''s see how we get the result from the Yahoo! Weather API in the `weather.cpp`
    file. The header part includes the following lines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询天气信息之外，我们还使用这个类来获取 Yahoo! 文档中提到的归属图像。在传统的 Qt/C++ 中，我们必须使用 `QNetworkAccessManager`
    来访问 `QUrl` 是一件很平常的事情，因为 `QJsonDocument` 不能直接从 `QUrl` 加载。无论如何，让我们看看如何在 `weather.cpp`
    文件中从 Yahoo! 天气 API 获取结果。头文件部分包括以下行：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, let''s see the constructor of `Weather`. Here, we simply construct the
    `QNetworkAccessManager` object, `naManager`, and connect its signals:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们看看 `Weather` 的构造函数。在这里，我们简单地构建 `QNetworkAccessManager` 对象 `naManager`
    并连接其信号：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `onSSLErrors` slot is simply to let the `QNetworkReply` object ignore all
    the SSL errors. This won't cause any serious problems in this case. However, if
    you're dealing with a secure communication or anything else that needs to validate
    the connection, you may wish to look into the error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSSLErrors` 插槽只是简单地让 `QNetworkReply` 对象忽略所有 SSL 错误。在这种情况下，这不会引起任何严重问题。然而，如果您正在处理需要验证连接的安全通信或其他任何内容，您可能希望查看错误。'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, let's check the `updateData` function before `onQueryFinished`. Here,
    we construct `QUrl`, which is the Yahoo! Weather API's exact address. Note that
    you don't need to use an HTML code for `QUrl`. In fact, it'd be better to use
    a space along with the other symbols directly. After this, similar to the previous
    chapter, we use `QNetworkRequest` to wrap this `QUrl` and dispatch the request
    through `QNetworkAccessManager`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们检查 `onQueryFinished` 之前的 `updateData` 函数。在这里，我们构建 `QUrl`，这是 Yahoo! 天气
    API 的确切地址。请注意，您不需要为 `QUrl` 使用 HTML 代码。实际上，直接使用空格和其他符号会更合适。之后，类似于上一章，我们使用 `QNetworkRequest`
    将此 `QUrl` 封装并通过 `QNetworkAccessManager` 分发请求。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As for the `getAttrImg` function, it's almost the same. The only difference
    is that this function is used to get an attribution image instead of weather information.
    We store the reply as `imgReply` so that we can distinguish the image from the
    weather.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `getAttrImg` 函数，几乎相同。唯一的区别是，这个函数用于获取归属图像而不是天气信息。我们将回复存储为 `imgReply`，这样我们就可以区分图像和天气。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the corresponding `QNetworkReply` object is finished, the `onQueryFinished`
    slot function will be executed, which is shown in the following code. After all
    the pavement, let's see what's inside this function. We can check whether there
    is any error in the reply at the very beginning. Then, if it's `imgReply`, we
    cook `QImage` from the data and emit a signal to send this image out. If none
    of these happen, we'll parse the weather from the JSON reply.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相应的 `QNetworkReply` 对象已完成，则将执行 `onQueryFinished` 插槽函数，如下面的代码所示。在所有铺垫之后，让我们看看这个函数内部的内容。我们可以在一开始就检查回复中是否存在任何错误。然后，如果是
    `imgReply`，我们将从数据中制作 `QImage` 并发出信号以发送此图像。如果这些都没有发生，我们将解析 JSON 回复中的天气信息。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As I mentioned before, it is trivial. First, we read the result from `QNetworkReply`,
    and then use `QJsonDocument::fromJson` to parse the `byte` array as a JSON document.
    If there is an error during the process, we simply print the error string and
    return. Then, we need to get `QJsonObject` contained in `QJsonDocument`. Only
    then can we parse all the information inside it. The formatted result using `560743`
    as the WOEID is shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，这是很平常的。首先，我们从 `QNetworkReply` 中读取结果，然后使用 `QJsonDocument::fromJson` 将
    `byte` 数组解析为 JSON 文档。如果在处理过程中出现错误，我们简单地打印错误字符串并返回。然后，我们需要获取 `QJsonDocument` 中包含的
    `QJsonObject`。只有在这种情况下，我们才能解析其中的所有信息。使用 `560743` 作为 WOEID 的格式化结果如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For details about JSON, visit [http://www.json.org](http://www.json.org).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JSON 的详细信息，请访问 [http://www.json.org](http://www.json.org)。
- en: As you can see, all the information is stored inside `query/results/channel`.
    Therefore, we need to convert it to `QJsonObject`, level by level. As you can
    see in the code, `QJsonObject res` is `channel`. Note that the `value` function
    will return a `QJsonValue` object and you will need to call `toObject()` to make
    it `QJsonObject` before you can use the `value` function to parse the value again.
    After this, it's pretty straightforward. The `locObj` object is the location where
    we use a `for` loop to put the values together, where as `QJsonObject::ConstIterator`
    is just Qt's wrapper of STL `const_iterator`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有信息都存储在`query/results/channel`中。因此，我们需要逐级将其转换为`QJsonObject`。如代码所示，`QJsonObject
    res`是`channel`。请注意，`value`函数将返回一个`QJsonValue`对象，在您可以使用`value`函数再次解析值之前，您需要调用`toObject()`将其转换为`QJsonObject`。之后，操作就相当直接了。`locObj`对象是我们使用`for`循环将值组合在一起的位置，而`QJsonObject::ConstIterator`只是Qt对STL
    `const_iterator`的包装。
- en: To obtain the current temperature, we need to go through a similar journey to
    channel because the temperature is in item/condition/temp, while its unit is `units/temperature`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前温度，我们需要经历与通道类似的旅程，因为温度位于item/condition/temp，而其单位是`units/temperature`。
- en: As for the `wind` section, we use a lazy way to retrieve the data. The `windObj`
    line is not a single value statement; instead, it has several keys and values.
    Therefore, we use a `for` loop to walk through this array and retrieve both of
    its keys along with its value, and simply put them together.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`wind`部分，我们使用一种懒惰的方式来检索数据。`windObj`行不是一个单一值语句；相反，它有几个键和值。因此，我们使用`for`循环遍历这个数组，并检索其键及其值，然后将它们简单地组合在一起。
- en: 'Now, let''s go back to the `MainWindow` class to see how to interact with the
    `Weather` class. The header file of `MainWindow`, which is `mainwindow.h`, is
    pasted here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`MainWindow`类，看看如何与`Weather`类交互。`MainWindow`的头文件`mainwindow.h`在此粘贴：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We declare a `Weather` object pointer, `w`, as the `MainWindow` class''s private
    member. Meanwhile, `onOkButtonClicked` is the handler when `okButton` gets clicked.
    The `onAttrImageDownloaded` and `onWeatherUpdateFinished` functions will be coupled
    with the `Weather` class''s signals. Now, let''s see what''s inside the source
    file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`Weather`对象指针`w`作为`MainWindow`类的私有成员。同时，`onOkButtonClicked`是当`okButton`被点击时的处理程序。`onAttrImageDownloaded`和`onWeatherUpdateFinished`函数将与`Weather`类的信号相关联。现在，让我们看看源文件中有什么：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the constructor, apart from the signals connection and the `w` object's construction,
    we call `getAttrImg` of `w` to retrieve the attribution image. When the image
    is downloaded, the `onAttrImageDownloaded` slot function will be executed where
    the image will be displayed on `attrLabel`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，除了信号连接和`w`对象的构建外，我们调用`w`的`getAttrImg`来检索属性图像。当图像下载完成后，将执行`onAttrImageDownloaded`槽函数，其中图像将在`attrLabel`上显示。
- en: Once the user clicks on `okButton`, the `onOkButtonClicked` slot function gets
    executed, where we call the `updateData` function of the `Weather` class to pass
    the WOEID. Then, when the update is finished, the `updateFinished` signal is emitted
    and `onWeatherUpdateFinished` is executed. We just use these three `QString` objects
    to set the corresponding label's text.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`okButton`时，将执行`onOkButtonClicked`槽函数，其中我们调用`Weather`类的`updateData`函数来传递WOEID。然后，当更新完成后，将发出`updateFinished`信号并执行`onWeatherUpdateFinished`。我们仅使用这三个`QString`对象来设置相应标签的文本。
- en: 'Now, test your application to see if it''s running as shown in this screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试您的应用程序，看看它是否如以下截图所示运行：
- en: '![Parsing JSON results](img/4615OS_07_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![解析JSON结果](img/4615OS_07_06.jpg)'
- en: Parsing XML results
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析XML结果
- en: Although a lot of APIs provide both XML and JSON results, you may still find
    that some of them only offer one format. Besides, you might feel that parsing
    JSON in C++/Qt is not a pleasant process. You may remember how easy it is to parse
    the XML model in QML/Qt Quick. Well, let's see how to do this in C++/Qt.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多API都提供XML和JSON结果，但您可能仍然会发现其中一些只提供一种格式。此外，您可能会觉得在C++/Qt中解析JSON不是一个愉快的体验。您可能还记得在QML/Qt
    Quick中解析XML模型是多么容易。那么，让我们看看如何在C++/Qt中实现这一点。
- en: To make use of an `xml` module, we have to add `xml` to QT in the `project`
    file, the same way we did to network. This time, Qt has provided an XML reader
    class called `QXmlStreamReader` to help us parse the XML documents. The first
    thing we need to do is to change the `updateData` function in the `Weather` class
    to let the Yahoo! Weather API return an XML result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `xml` 模块，我们必须在 `project` 文件中将 `xml` 添加到 QT 中，就像我们添加网络一样。这次，Qt 提供了一个名为 `QXmlStreamReader`
    的 XML 读取器类，以帮助我们解析 XML 文档。我们需要做的第一件事是将 `Weather` 类中的 `updateData` 函数更改为让 Yahoo!
    天气 API 返回 XML 结果。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The changing of `&format=json` to `&format=xml` needs to be done here. In contrast
    to this, there is a lot of work to do in the `onQueryFinished` slot function.
    The old JSON part is commented out so that we can write the XML parsing code.
    The modified function without the comment is shown as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `&format=json` 更改为 `&format=xml` 需要在这里完成。相比之下，在 `onQueryFinished` 槽函数中有很多工作要做。旧的
    JSON 部分被注释掉，这样我们就可以编写 XML 解析代码。不带注释的修改后的函数如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `parseXMLChannel` is a newly created member function. We can use a separate
    function to make our code neat and tidy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`parseXMLChannel` 是一个新创建的成员函数。我们可以使用一个单独的函数来使我们的代码整洁有序。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to declare the `parseXMLChannel` function in the header file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在头文件中声明 `parseXMLChannel` 函数。
- en: 'Its definition is pasted as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其定义如下粘贴：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we walk through `parseXMLChannel` function, I''d like to show you what
    the XML document looks like, shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历 `parseXMLChannel` 函数之前，我想向你展示 XML 文档的样子，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can deduce, the XML structure shares a lot of similarities with the JSON
    document. For instance, all the data we need is still stored in query/results/channel.
    The difference is, however, more significant than you may have expected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所推断，XML 结构与 JSON 文档有很多相似之处。例如，我们所需的所有数据仍然存储在 query/results/channel 中。然而，差异却比你想象的要大。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn XML thoroughly, check the XML tutorial at [http://www.w3schools.com/xml/](http://www.w3schools.com/xml/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要彻底学习 XML，请查看 [http://www.w3schools.com/xml/](http://www.w3schools.com/xml/)
    上的 XML 教程。
- en: In the `onQueryFinished` slot, we use a `while` loop to let `xmlReader` keep
    reading until the end or until an error. The `readNext` function of the `QXmlStreamReader`
    class will read the next token and return its type. `TokenType` is an enum, which
    describes the type of token currently being read. Each time you call `readNext`,
    `QXmlStreamReader` will move forward by one token. If we want to read all the
    data of one element, we may have to read it from the beginning. Therefore, we
    use an `if` statement to ensure that the token is at the starting. In addition
    to this, we test if we're reading the channel now. Then, we call `parseXMLChannel`
    to retrieve all data that we need.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onQueryFinished` 槽中，我们使用一个 `while` 循环让 `xmlReader` 继续读取，直到结束或出现错误。`QXmlStreamReader`
    类的 `readNext` 函数将读取下一个标记并返回其类型。`TokenType` 是一个枚举，它描述了当前正在读取的标记的类型。每次调用 `readNext`
    时，`QXmlStreamReader` 将向前移动一个标记。如果我们想读取一个元素的所有数据，我们可能需要从开始读取。因此，我们使用一个 `if` 语句来确保标记处于起始位置。除此之外，我们还测试我们现在是否正在读取通道。然后，我们调用
    `parseXMLChannel` 来检索我们所需的所有数据。
- en: In the `parseXMLChannel` function, pretty much the same strategy is used. We
    test the `name` element so that we know which stage we are in. One thing worth
    your attention is that all prefixes such as `yweather:` are omitted. Hence, you
    should use `location` instead of `yweather:location`. Other parts are similar
    to their counterparts in JSON, where `QStringRef` is similar to `QJsonValue`.
    Last but not least, `QXmlStreamReader` is a stream reader, which means that it
    reads in order. In other words, we can break the `while` loop after we get `temp`
    in `condition` since `condition` is the last element that we're interested in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `parseXMLChannel` 函数中，基本上采用了相同的策略。我们测试 `name` 元素，以便我们知道我们处于哪个阶段。值得你注意的是，所有前缀，例如
    `yweather:` 都被省略了。因此，你应该使用 `location` 而不是 `yweather:location`。其他部分与 JSON 中的对应部分类似，其中
    `QStringRef` 类似于 `QJsonValue`。最后但同样重要的是，`QXmlStreamReader` 是一个流读取器，这意味着它是按顺序读取的。换句话说，我们可以在获取
    `condition` 中的 `temp` 后跳出 `while` 循环，因为 `condition` 是我们感兴趣的最后一个元素。
- en: After these changes, you can build and run this application again and you should
    expect it to run in the same manner.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，你可以再次构建和运行此应用程序，你应该期望它以相同的方式运行。
- en: Building Qt applications for Android
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Android 的 Qt 应用程序
- en: You may wonder how to build Qt applications for Android devices since this application
    is built for desktop PCs. Well, it's much easier than you thought.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何为Android设备构建Qt应用程序，因为此应用程序是为桌面PC构建的。嗯，这比您想象的要简单得多。
- en: Switch to **Projects** mode.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**项目**模式。
- en: Click on **Add Kit** and select **Android for armeabit-v7a (GCC 4.9 and Qt 5.3.2)**.
    Note that the text may differ a little bit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加工具包**并选择**Android for armeabit-v7a (GCC 4.9 and Qt 5.3.2)**。请注意，文本可能略有不同。
- en: Plug in your phone if you're using it as the target Android device.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用手机作为目标Android设备，请将其连接到计算机。
- en: Open **Command Prompt** and run `adb devices`. Make sure your device is on the
    list.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**命令提示符**并运行`adb devices`。确保您的设备在列表中。
- en: 'Now, click on **Run** and Qt will prompt a dialog asking you to select the
    Android device, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**运行**，Qt将弹出一个对话框，提示您选择Android设备，如下面的截图所示：
- en: '![Building Qt applications for Android](img/4615OS_07_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![为 Android 构建Qt应用程序](img/4615OS_07_07.jpg)'
- en: We choose to run our application on an actual Android device, which is an HTC
    One phone in this case. If you don't have any available Android devices, you may
    have to create a virtual device, as mentioned at the beginning of this chapter.
    For both the options, choose the device and click on the **OK** button.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择在真实的Android设备上运行我们的应用程序，在这个例子中是一个HTC One手机。如果您没有可用的Android设备，您可能不得不创建一个虚拟设备，如本章开头所述。对于这两种选项，选择设备并点击**确定**按钮。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On an actual Android device, you need to go to **Settings** and turn on **USB
    debugging** in **Developer options**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的Android设备上，您需要进入**设置**，然后在**开发者选项**中开启**USB调试**。
- en: As you can see from the following screenshot, the demonstration runs well. It
    definitely needs ongoing improvements and UI optimization before submitting, though.
    However, remember that we designed and built this application for a desktop PC!
    We have just built it for a mobile phone without any modification and it runs
    as expected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，演示运行良好。在提交之前，它确实需要持续改进和UI优化。然而，请记住，我们设计和构建这个应用程序是为了桌面PC！我们只是构建了一个没有修改的移动手机版本，它按预期运行。
- en: '![Building Qt applications for Android](img/4615OS_07_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![为 Android 构建Qt应用程序](img/4615OS_07_08.jpg)'
- en: When you test the application, all the information is printed to the **Application
    Output** panel in Qt Creator. This could be useful when your application runs
    unexpectedly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您测试应用程序时，所有信息都会打印到Qt Creator中的**应用程序输出**面板。这可能对您的应用程序运行异常时很有用。
- en: Parsing JSON in QML
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的JSON解析
- en: Let's rewrite the weather demo in QML. You will find out how easy and elegant
    it is to write such an application in QML. Since the XML part is already covered
    in the previous chapter, we'll focus on parsing JSON this time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用QML重写天气演示。您会发现用QML编写这样的应用程序是多么简单和优雅。由于XML部分在前一章已经介绍过，这次我们将专注于解析JSON。
- en: First, create a new Qt Quick application project named `Weather_QML`. Keep the
    other settings as default, which means we use **Qt Quick Controls**. Remember
    to tick the checkbox of the Android kit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Weather_QML`的新Qt Quick应用程序项目。保持其他设置默认，这意味着我们使用**Qt Quick Controls**。请记住勾选Android工具包的复选框。
- en: 'Create a new QML file named `Weather.qml` to mimic the `Weather` class in the
    previous C++ code. This file is pasted here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Weather.qml`的新QML文件，以模拟之前C++代码中的`Weather`类。此文件内容如下：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first part is just a QML version UI of the previous application. You may
    want to pay attention to the `fontSizeMode` and `minimumPointSize` property in
    `Label`. These properties are newly introduced in Qt 5, and enable the text scale
    to be dynamically adjusted. By setting `Text.Fit` as `fontSizeMode`, it'll shrink
    the text if `height` or `width` is not sufficient for the text, where `minimumPointSize`
    is the minimum point size. The text will get elided if it can't display at a minimum
    size. Similar to the `elide` property, you have to explicitly set the `width`
    and `height` property of `Text` or `Label` to make this dynamic mechanism work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分只是之前应用程序的QML版本UI。您可能需要注意`Label`中的`fontSizeMode`和`minimumPointSize`属性。这些属性是Qt
    5中新引入的，允许文本大小动态调整。通过将`Text.Fit`设置为`fontSizeMode`，如果`height`或`width`不足以容纳文本，它将缩小文本，其中`minimumPointSize`是最小点大小。如果无法以最小大小显示，文本将被截断。类似于`elide`属性，您必须显式设置`Text`或`Label`的`width`和`height`属性，以使这种动态机制生效。
- en: The attribution image is displayed in a slightly different way from C++. We
    utilize the flexibility of Qt Quick to float `Image` on top of the whole item
    by setting only `anchors`. In addition to this, we don't need to use `QNetworkAccessManager`
    to download the image. It's all in one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图像的显示方式与 C++ 略有不同。我们利用 Qt Quick 的灵活性，通过仅设置 `anchors` 将 `Image` 浮动在所有项目之上。此外，我们不需要使用
    `QNetworkAccessManager` 来下载图像。一切都在一个地方。
- en: After the UI part, we create the two JavaScript functions to do the dirty work.
    The `query` function is used to send an `http` request and pass the received data
    to the `parseJSON` function once it's done. Don't get confused by XML in `XMLHttpRequest`;
    it's just a traditional naming convention. Then, we create a `handler` function
    for `onreadystatechanged`, which is to call `parseJSON` when the request is done.
    Note that the `open` function won't send the request, only the `send` function
    does.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 部分之后，我们创建了两个 JavaScript 函数来完成脏活。`query` 函数用于发送 `http` 请求，并在完成后将接收到的数据传递给
    `parseJSON` 函数。不要被 `XMLHttpRequest` 中的 XML 搞混；它只是一个传统的命名约定。然后，我们为 `onreadystatechanged`
    创建一个 `handler` 函数，以便在请求完成后调用 `parseJSON`。请注意，`open` 函数不会发送请求，只有 `send` 函数才会。
- en: It's still short and clean in the `parseJSON` function. `JSON.parse` will return
    a `JSON` object if it is parsed successfully. Therefore, we need to test whether
    its type is `object` before we get into parsing. Then, we just do one more test
    to see whether it has `query` as its property. If so, we can start extracting
    data from `obj`. Unlike its C++ counterpart, we can treat all its keys as its
    properties and use the `dot` operation to access them directly. To shorten the
    operations, we first create a `ch` variable, which is `query/results/channel`.
    Next, we extract the data from the `ch` object. Finally, we change the text directly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `parseJSON` 函数中，代码依然简洁。`JSON.parse` 如果解析成功，将返回一个 `JSON` 对象。因此，在我们开始解析之前，我们需要测试其类型是否为
    `object`。然后，我们再进行一个测试，看看它是否有 `query` 属性。如果有，我们就可以开始从 `obj` 中提取数据。与它的 C++ 对应物不同，我们可以将其所有键视为属性，并使用
    `dot` 操作直接访问它们。为了缩短操作，我们首先创建一个 `ch` 变量，它是 `query/results/channel`。接下来，我们从 `ch`
    对象中提取数据。最后，我们直接更改文本。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ch.location` and `ch.wind` objects can be treated as `QVariantMap` objects.
    Thus, we can use the `for` loop to easily extract the values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch.location` 和 `ch.wind` 对象可以被视为 `QVariantMap` 对象。因此，我们可以使用 `for` 循环轻松提取值。'
- en: 'Let''s edit the `main.qml` file as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式编辑 `main.qml` 文件：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Row` is the same WOEID input panel, for which we don''t create an **OK** button
    this time. Instead, we handle the accepted signal in `onAccepted` by calling the
    `query` function in `weather`, which is a `Weather` element. We set the `inputMethodHints`
    property to `Qt.ImhDigitsOnly`, which is useful on mobile platforms. This application
    should run almost the same as the C++ one or should we say better.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row` 是相同的 WOEID 输入面板，这次我们没有创建一个 **OK** 按钮。相反，我们在 `onAccepted` 中处理接受信号，通过调用
    `weather` 中的 `query` 函数，其中 `weather` 是一个 `Weather` 元素。我们将 `inputMethodHints` 属性设置为
    `Qt.ImhDigitsOnly`，这在移动平台上非常有用。这个应用程序应该几乎与 C++ 版本一样运行，或者我们应该说更好。'
- en: '![Parsing JSON in QML](img/4615OS_07_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![在QML中解析JSON](img/4615OS_07_09.jpg)'
- en: 'The `inputMethodHints` property may seem useless on a desktop; indeed, you
    need to use `inputMask` and `validator` to restrict the acceptable input. However,
    it shows its power on mobiles, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputMethodHints` 属性在桌面上的可能看起来没有用；确实，您需要使用 `inputMask` 和 `validator` 来限制可接受的输入。然而，它在移动设备上展示了其力量，如下所示：'
- en: '![Parsing JSON in QML](img/4615OS_07_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在QML中解析JSON](img/4615OS_07_10.jpg)'
- en: As you can see, `inputMethodHints` not only restricts the input, but it also
    provides a better experience for users. This is also viable in a C++/Qt development;
    you can find the relevant functions to achieve this. The whole point in QML is
    that parsing the JSON and XML documents is easier and tidier than C++.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`inputMethodHints` 不仅限制了输入，还为用户提供了更好的体验。这在 C++/Qt 开发中也是可行的；您可以找到相关的函数来实现这一点。QML
    的整个要点在于解析 JSON 和 XML 文档比 C++ 更容易且更整洁。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After this chapter, you're expected to handle common tasks and write types of
    real-world applications. You'll get your own understanding of Qt Quick and traditional
    Qt. It's also a current trend to write hybrid applications, which make full use
    of both of them by writing the C++ plugins to enhance QML. QML has an unbeatable
    advantage of flexible UI design, which is even more obvious on mobile platforms.
    While the development part is nearing the end, in the next chapter we'll talk
    about how to support multiple languages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将预期处理常见任务并编写真实世界应用的各种类型。你将对 Qt Quick 和传统 Qt 有自己的理解。编写混合应用也是一个当前趋势，通过编写
    C++ 插件来增强 QML，充分利用它们。QML 在灵活的 UI 设计方面具有无与伦比的优势，这在移动平台上尤为明显。尽管开发部分即将结束，但在下一章中，我们将讨论如何支持多种语言。
