- en: Chapter 7. Parsing JSON and XML Documents to Use Online APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll find the powerful application, Qt, running on the
    popular Android devices. Following the introduction of Qt application development
    for Android, it also utilizes online APIs, which usually return JSON or XML documents.
    The topics that are covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Qt for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing XML results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Qt applications for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Qt for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt for Android requires at least an API level 10 (for Android 2.3.3 platforms).
    Most Qt modules are supported, which means your Qt application can be deployed
    on Android with little or no modification. For development, both Qt Widget-based
    applications and Qt Quick applications in Qt Creator are supported on Android.
    However, setting up Qt for Android on a Windows PC is not very straightforward.
    Therefore, before we venture deeper into anything, let's set up the development
    environment for Qt on Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install Qt for Android. If you''re using an online installer,
    remember to select the Android components, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Qt for Android](img/4615OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we only chose **Android armv7**, which enables us to deploy applications
    for ARMv7 Android devices. If you're using an offline installer, download Qt for
    the Android installer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's install a **Java Development Kit** (**JDK**). There is no way to
    get rid of Java, since Android heavily depends on it. Also, note that you need
    to install at least Version 6 of JDK, according to [http://doc.qt.io/qt-5/androidgs.html](http://doc.qt.io/qt-5/androidgs.html).
    You can download JDK from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    You also need to set a `JAVA_HOME` environment variable in the JDK installation
    directory, `D:\Program Files\Java\jdk1.8.0_25`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's install two kits from Google, the Android SDK and Android NDK. Always
    remember to download the latest version; here we use Android SDK r24.0.2 and Android
    NDK r10b.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you install the Android SDK, run the SDK Manager. Install or update **Android
    SDK Tools**, **Android SDK Platform-tools**, **Android SDK Build-tools**, **Google
    USB Driver**, at least one API level''s **SDK Platform**, and **ARM EABI v7a System
    Image** for the purpose of our task. For this chapter, we installed API 19''s
    **SDK Platform** and **ARM EABI v7a System Image**. Then, edit the `PATH` environment
    variable. Add the path of the platform and SDK tools to it with a semicolon as
    a separator. If `D:\Program Files (x86)\Android\android-sdk` is the path of **Android
    SDK Tools**, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`D:\Program Files (x86)\Android\android-sdk\platform-tools;D:\Program Files
    (x86)\Android\android-sdk\tools`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android SDK and NDK can be obtained on the Android developer website, [http://developer.android.com](http://developer.android.com).
  prefs: []
  type: TYPE_NORMAL
- en: Once you download the NDK, extract the `zip` file to your hard drive, `D:\android-ndk`.
    Then, add an environment variable named `ANDROID_NDK_ROOT` with the value, `D:\android-ndk`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar procedures should be applied for Apache Ant. You can download it from
    [http://ant.apache.org/bindownload.cgi](http://ant.apache.org/bindownload.cgi).
    We use Apache Ant 1.9.4 in this book. There is no environment variable that needs
    to be set here. Now, reboot your computer if you're using Windows so that the
    environment variables can be refreshed and loaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Open AVD Manager and create a new virtual device. You'd better choose a smaller
    virtual device such as Nexus S for this exercise, as shown in the following screenshot.
    Feel free to change it if you want, but remember to tick **Use Host GPU**, which
    will make the virtual device use GLES to accelerate the graphics. If you haven't
    turned that on, you'll get an extremely slow virtual device that might even be
    too sluggish to test applications on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Qt for Android](img/4615OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open Qt Creator; navigate to **Tools** | **Options**. See if Qt Version
    in **Build & Run** has an Android entry. You have to manually add Qt for Android
    if it''s not there. Then, switch to the **Android** options, set up JDK, Android
    SDK, Android NDK, and Ant, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Qt for Android](img/4615OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The warning for missing architectures can be safely ignored because we won't
    develop applications for MIPS and x86 Android in this chapter. However, pay attention
    to it if you need to deploy your applications on these hardware platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Apply** and switch to the **Devices** options. There should be a
    **Run on Android** item in the **Device** combobox. An auto-detected **Android
    for armeabi-v7a** is expected if you navigate to **Build & Run** | **Kits** now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test if we can run a Qt application on our virtual Android device.
    Open AVD Manager and start the virtual device. We start it first because it could
    take a lot of time. Then, open Qt Creator and make a simple application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Qt Widget-based application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Android for armeabi-v7a Kit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `mainwindow.ui` and drag a label to `centralWidget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **MainWindow** page's layout to **Lay Out Vertically** (or others)
    so that the widgets will be stretched automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the label's text to `Hello Android!` or something else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the time-consuming virtual Android device until it''s fully started.
    If it''s not, click on **Run** and wait for a few minutes. You''ll see this application
    running on our virtual Android device. As seen in the following screenshot, the
    Qt for Android development environment is set up successfully. So, we can move
    on and write an application that can use a camera to take photos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Qt for Android](img/4615OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing an application on a desktop while it's incomplete, and then testing
    it on a mobile platform would save plenty of time compared to testing on the virtual
    Android device all the time. In addition to this, it's much faster to test on
    a real device than a virtual one.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of tolerating a slow emulator, we're going to first develop the application
    on a desktop, then deploy it on an actual Android device and see if there is anything
    mismatched or inappropriate for mobile devices. Make any relevant changes accordingly.
    This could save you plenty of time. However, it still takes a longer time, even
    though the actual Android device is much more responsive than the virtual one.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tons of companies that provide developers APIs to access to their
    services, including the dictionary, weather, and so on. In this chapter, we'll
    use Yahoo! Weather as an example to show you how to use its online API to get
    weather data. For more details about Yahoo! Weather API, refer to [https://developer.yahoo.com/weather/](https://developer.yahoo.com/weather/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a new project named `Weather_Demo`, which is a Qt Widget-based
    application project. As usual, let's first design the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing JSON results](img/4615OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've removed the menu bar, tool bar, and status bar as we did before. Then,
    we added a **Label**, **Line Edit**, and **Push Button** on top of `centralWidget`.
    Their object names are `woeidLabel`, `woeidEdit`, and `okButton`, respectively.
    After this, another label named `locationLabel` is used to display the location
    returned from the API. The red rectangle is **Horizontal Layout**, which consists
    of `tempLabel` and `windLabel`, which are both **Label** and are separated by
    **Horizontal Spacer**. Append **Label**, whose object name is `attrLabel`, and
    then change its alignment to `AlignRight` and `AlignBottom`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where On Earth ID** (**WOEID**) is a 32-bit identifier that is unique and
    nonrepetitive. By using WOEID, we can avoid duplicity. However, this also means
    that we need to find out what WOEID is used for our location. Luckily, there are
    several websites that provide you with easy-to-use online tools to get the WOEID.
    One of them is the Zourbuth project, **Yahoo! WOEID Lookup**, which can be accessed
    at [http://zourbuth.com/tools/woeid/](http://zourbuth.com/tools/woeid/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on and focus on the parsing of API results. We created a new
    C++ class, `Weather`, to deal with the Yahoo! Weather API. I''d like to introduce
    you to parsing the **JSON** (**JavaScript Object Notation**) results before XML.
    However, before we cook the `Weather` class, remember to add network to `QT` in
    the project file. In this case, the `Weather_Demo.pro` project file looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the `Weather` class. Its `weather.h` header file is pasted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the weather information query, we also use this class to get
    an attribution image, which is stated in the Yahoo! documentation. It is kind
    of trivial in traditional Qt/C++ that we have to use `QNetworkAccessManager` to
    access `QUrl`, because `QJsonDocument` cannot load from `QUrl` directly. Anyway,
    let''s see how we get the result from the Yahoo! Weather API in the `weather.cpp`
    file. The header part includes the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s see the constructor of `Weather`. Here, we simply construct the
    `QNetworkAccessManager` object, `naManager`, and connect its signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `onSSLErrors` slot is simply to let the `QNetworkReply` object ignore all
    the SSL errors. This won't cause any serious problems in this case. However, if
    you're dealing with a secure communication or anything else that needs to validate
    the connection, you may wish to look into the error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, let's check the `updateData` function before `onQueryFinished`. Here,
    we construct `QUrl`, which is the Yahoo! Weather API's exact address. Note that
    you don't need to use an HTML code for `QUrl`. In fact, it'd be better to use
    a space along with the other symbols directly. After this, similar to the previous
    chapter, we use `QNetworkRequest` to wrap this `QUrl` and dispatch the request
    through `QNetworkAccessManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As for the `getAttrImg` function, it's almost the same. The only difference
    is that this function is used to get an attribution image instead of weather information.
    We store the reply as `imgReply` so that we can distinguish the image from the
    weather.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the corresponding `QNetworkReply` object is finished, the `onQueryFinished`
    slot function will be executed, which is shown in the following code. After all
    the pavement, let's see what's inside this function. We can check whether there
    is any error in the reply at the very beginning. Then, if it's `imgReply`, we
    cook `QImage` from the data and emit a signal to send this image out. If none
    of these happen, we'll parse the weather from the JSON reply.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned before, it is trivial. First, we read the result from `QNetworkReply`,
    and then use `QJsonDocument::fromJson` to parse the `byte` array as a JSON document.
    If there is an error during the process, we simply print the error string and
    return. Then, we need to get `QJsonObject` contained in `QJsonDocument`. Only
    then can we parse all the information inside it. The formatted result using `560743`
    as the WOEID is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For details about JSON, visit [http://www.json.org](http://www.json.org).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all the information is stored inside `query/results/channel`.
    Therefore, we need to convert it to `QJsonObject`, level by level. As you can
    see in the code, `QJsonObject res` is `channel`. Note that the `value` function
    will return a `QJsonValue` object and you will need to call `toObject()` to make
    it `QJsonObject` before you can use the `value` function to parse the value again.
    After this, it's pretty straightforward. The `locObj` object is the location where
    we use a `for` loop to put the values together, where as `QJsonObject::ConstIterator`
    is just Qt's wrapper of STL `const_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the current temperature, we need to go through a similar journey to
    channel because the temperature is in item/condition/temp, while its unit is `units/temperature`.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `wind` section, we use a lazy way to retrieve the data. The `windObj`
    line is not a single value statement; instead, it has several keys and values.
    Therefore, we use a `for` loop to walk through this array and retrieve both of
    its keys along with its value, and simply put them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the `MainWindow` class to see how to interact with the
    `Weather` class. The header file of `MainWindow`, which is `mainwindow.h`, is
    pasted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a `Weather` object pointer, `w`, as the `MainWindow` class''s private
    member. Meanwhile, `onOkButtonClicked` is the handler when `okButton` gets clicked.
    The `onAttrImageDownloaded` and `onWeatherUpdateFinished` functions will be coupled
    with the `Weather` class''s signals. Now, let''s see what''s inside the source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, apart from the signals connection and the `w` object's construction,
    we call `getAttrImg` of `w` to retrieve the attribution image. When the image
    is downloaded, the `onAttrImageDownloaded` slot function will be executed where
    the image will be displayed on `attrLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user clicks on `okButton`, the `onOkButtonClicked` slot function gets
    executed, where we call the `updateData` function of the `Weather` class to pass
    the WOEID. Then, when the update is finished, the `updateFinished` signal is emitted
    and `onWeatherUpdateFinished` is executed. We just use these three `QString` objects
    to set the corresponding label's text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test your application to see if it''s running as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing JSON results](img/4615OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Parsing XML results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although a lot of APIs provide both XML and JSON results, you may still find
    that some of them only offer one format. Besides, you might feel that parsing
    JSON in C++/Qt is not a pleasant process. You may remember how easy it is to parse
    the XML model in QML/Qt Quick. Well, let's see how to do this in C++/Qt.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of an `xml` module, we have to add `xml` to QT in the `project`
    file, the same way we did to network. This time, Qt has provided an XML reader
    class called `QXmlStreamReader` to help us parse the XML documents. The first
    thing we need to do is to change the `updateData` function in the `Weather` class
    to let the Yahoo! Weather API return an XML result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The changing of `&format=json` to `&format=xml` needs to be done here. In contrast
    to this, there is a lot of work to do in the `onQueryFinished` slot function.
    The old JSON part is commented out so that we can write the XML parsing code.
    The modified function without the comment is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `parseXMLChannel` is a newly created member function. We can use a separate
    function to make our code neat and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to declare the `parseXMLChannel` function in the header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its definition is pasted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we walk through `parseXMLChannel` function, I''d like to show you what
    the XML document looks like, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can deduce, the XML structure shares a lot of similarities with the JSON
    document. For instance, all the data we need is still stored in query/results/channel.
    The difference is, however, more significant than you may have expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn XML thoroughly, check the XML tutorial at [http://www.w3schools.com/xml/](http://www.w3schools.com/xml/).
  prefs: []
  type: TYPE_NORMAL
- en: In the `onQueryFinished` slot, we use a `while` loop to let `xmlReader` keep
    reading until the end or until an error. The `readNext` function of the `QXmlStreamReader`
    class will read the next token and return its type. `TokenType` is an enum, which
    describes the type of token currently being read. Each time you call `readNext`,
    `QXmlStreamReader` will move forward by one token. If we want to read all the
    data of one element, we may have to read it from the beginning. Therefore, we
    use an `if` statement to ensure that the token is at the starting. In addition
    to this, we test if we're reading the channel now. Then, we call `parseXMLChannel`
    to retrieve all data that we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the `parseXMLChannel` function, pretty much the same strategy is used. We
    test the `name` element so that we know which stage we are in. One thing worth
    your attention is that all prefixes such as `yweather:` are omitted. Hence, you
    should use `location` instead of `yweather:location`. Other parts are similar
    to their counterparts in JSON, where `QStringRef` is similar to `QJsonValue`.
    Last but not least, `QXmlStreamReader` is a stream reader, which means that it
    reads in order. In other words, we can break the `while` loop after we get `temp`
    in `condition` since `condition` is the last element that we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: After these changes, you can build and run this application again and you should
    expect it to run in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Building Qt applications for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder how to build Qt applications for Android devices since this application
    is built for desktop PCs. Well, it's much easier than you thought.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to **Projects** mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add Kit** and select **Android for armeabit-v7a (GCC 4.9 and Qt 5.3.2)**.
    Note that the text may differ a little bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in your phone if you're using it as the target Android device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Command Prompt** and run `adb devices`. Make sure your device is on the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, click on **Run** and Qt will prompt a dialog asking you to select the
    Android device, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building Qt applications for Android](img/4615OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We choose to run our application on an actual Android device, which is an HTC
    One phone in this case. If you don't have any available Android devices, you may
    have to create a virtual device, as mentioned at the beginning of this chapter.
    For both the options, choose the device and click on the **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On an actual Android device, you need to go to **Settings** and turn on **USB
    debugging** in **Developer options**.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the following screenshot, the demonstration runs well. It
    definitely needs ongoing improvements and UI optimization before submitting, though.
    However, remember that we designed and built this application for a desktop PC!
    We have just built it for a mobile phone without any modification and it runs
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building Qt applications for Android](img/4615OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you test the application, all the information is printed to the **Application
    Output** panel in Qt Creator. This could be useful when your application runs
    unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's rewrite the weather demo in QML. You will find out how easy and elegant
    it is to write such an application in QML. Since the XML part is already covered
    in the previous chapter, we'll focus on parsing JSON this time.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new Qt Quick application project named `Weather_QML`. Keep the
    other settings as default, which means we use **Qt Quick Controls**. Remember
    to tick the checkbox of the Android kit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new QML file named `Weather.qml` to mimic the `Weather` class in the
    previous C++ code. This file is pasted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first part is just a QML version UI of the previous application. You may
    want to pay attention to the `fontSizeMode` and `minimumPointSize` property in
    `Label`. These properties are newly introduced in Qt 5, and enable the text scale
    to be dynamically adjusted. By setting `Text.Fit` as `fontSizeMode`, it'll shrink
    the text if `height` or `width` is not sufficient for the text, where `minimumPointSize`
    is the minimum point size. The text will get elided if it can't display at a minimum
    size. Similar to the `elide` property, you have to explicitly set the `width`
    and `height` property of `Text` or `Label` to make this dynamic mechanism work.
  prefs: []
  type: TYPE_NORMAL
- en: The attribution image is displayed in a slightly different way from C++. We
    utilize the flexibility of Qt Quick to float `Image` on top of the whole item
    by setting only `anchors`. In addition to this, we don't need to use `QNetworkAccessManager`
    to download the image. It's all in one.
  prefs: []
  type: TYPE_NORMAL
- en: After the UI part, we create the two JavaScript functions to do the dirty work.
    The `query` function is used to send an `http` request and pass the received data
    to the `parseJSON` function once it's done. Don't get confused by XML in `XMLHttpRequest`;
    it's just a traditional naming convention. Then, we create a `handler` function
    for `onreadystatechanged`, which is to call `parseJSON` when the request is done.
    Note that the `open` function won't send the request, only the `send` function
    does.
  prefs: []
  type: TYPE_NORMAL
- en: It's still short and clean in the `parseJSON` function. `JSON.parse` will return
    a `JSON` object if it is parsed successfully. Therefore, we need to test whether
    its type is `object` before we get into parsing. Then, we just do one more test
    to see whether it has `query` as its property. If so, we can start extracting
    data from `obj`. Unlike its C++ counterpart, we can treat all its keys as its
    properties and use the `dot` operation to access them directly. To shorten the
    operations, we first create a `ch` variable, which is `query/results/channel`.
    Next, we extract the data from the `ch` object. Finally, we change the text directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ch.location` and `ch.wind` objects can be treated as `QVariantMap` objects.
    Thus, we can use the `for` loop to easily extract the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `main.qml` file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Row` is the same WOEID input panel, for which we don''t create an **OK** button
    this time. Instead, we handle the accepted signal in `onAccepted` by calling the
    `query` function in `weather`, which is a `Weather` element. We set the `inputMethodHints`
    property to `Qt.ImhDigitsOnly`, which is useful on mobile platforms. This application
    should run almost the same as the C++ one or should we say better.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing JSON in QML](img/4615OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `inputMethodHints` property may seem useless on a desktop; indeed, you
    need to use `inputMask` and `validator` to restrict the acceptable input. However,
    it shows its power on mobiles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing JSON in QML](img/4615OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `inputMethodHints` not only restricts the input, but it also
    provides a better experience for users. This is also viable in a C++/Qt development;
    you can find the relevant functions to achieve this. The whole point in QML is
    that parsing the JSON and XML documents is easier and tidier than C++.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this chapter, you're expected to handle common tasks and write types of
    real-world applications. You'll get your own understanding of Qt Quick and traditional
    Qt. It's also a current trend to write hybrid applications, which make full use
    of both of them by writing the C++ plugins to enhance QML. QML has an unbeatable
    advantage of flexible UI design, which is even more obvious on mobile platforms.
    While the development part is nearing the end, in the next chapter we'll talk
    about how to support multiple languages.
  prefs: []
  type: TYPE_NORMAL
