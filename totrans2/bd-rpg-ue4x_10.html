<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Leveling, Abilities, and Saving Progress</h1></div></div></div><p>In the previous chapter, we covered how to create and apply equipment to the player, which when equipped, affects the stats of the player. In this chapter, we will allow the player to level up by setting up an experience system for each party member, allowing party members to gain experience from enemies when winning in combat. When each party member gains enough experience, they will level up and their stats will increase at each level that the party member has gained. We will also fix the combat damage settings so that attacks in combat will utilize character stats rather than hardcoded values. Once we have fixed the combat logic, we will then move on to creating an ability for our character that will be activated by gaining a level.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">XP and Leveling source code</li><li class="listitem" style="list-style-type: disc">Data Table starting values</li><li class="listitem" style="list-style-type: disc">Displaying levels and experience in the pause menu</li><li class="listitem" style="list-style-type: disc">Applying the correct damage in combat</li><li class="listitem" style="list-style-type: disc">Setting up the abilities array</li><li class="listitem" style="list-style-type: disc">Abilities logic</li><li class="listitem" style="list-style-type: disc">Saving</li><li class="listitem" style="list-style-type: disc">Loading</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>XP and leveling source code</h1></div></div></div><p>In order to<a id="id535" class="indexterm"/> allow party members to gain experience points from battle, we need to add experience points <a id="id536" class="indexterm"/>(which we will call XP) variables to our code. Moreover, the XP variables need to accumulate to a given XP cap (which we will call MXP for maximum XP), and if this cap is hit, the player will gain a level. The best way to do this is to add these variables to our source code, which we will then apply to every party <a id="id537" class="indexterm"/>member and enemy that<a id="id538" class="indexterm"/> we have in the game. The first thing we will do is add XP and leveling data to our Data classes. Navigate to <strong>UnrealRPG</strong> | <strong>Source</strong> | <strong>Data</strong> and open <code class="literal">FCharacterClassInfo.h</code>. In the <code class="literal">FCharacterClassInfo : public FTableRowBase</code> struct, add <code class="literal">UPROPERTY</code> to <code class="literal">XP</code> that will hold cumulative experience, <code class="literal">MXP</code> that will hold the experience cap to the next level, and <code class="literal">Lvl</code> that will hold the party member's current level:</p><div><pre class="programlisting">UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "ClassInfo")
  int32 XP;

UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "ClassInfo")
  int32 MXP;

UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "ClassInfo")
  int32 Lvl;</pre></div><p>Next, open <code class="literal">FEnemyInfo.h</code>, which is located in the same folder as <code class="literal">FCharacterClassInfo.h</code>. We need to add XP to the enemy's info because each enemy will give a certain amount of XP to party members. In the <code class="literal">FEnemyInfo : public FTableRowBase</code> struct, add a <code class="literal">UPROPERTY</code> to <code class="literal">XP</code>:</p><div><pre class="programlisting">UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "EnemyInfo")
  int32 XP;</pre></div><p>We will now need to use these variables in the <code class="literal">GameCharacter</code> instances of the game. Navigate to <strong>UnrealRPG</strong> | <strong>Source</strong> and open <code class="literal">GameCharacter.h</code>. In the <code class="literal">class RPG_API UGameCharacter : public UObject</code> struct, add <code class="literal">UPROPERTY</code> to <code class="literal">XP</code>, <code class="literal">MXP</code>, and <code class="literal">Lvl</code>:</p><div><pre class="programlisting">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CharacterInfo)
  int32 XP;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CharacterInfo)
  int32 MXP;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CharacterInfo)
  int32 Lvl;</pre></div><p>Open <code class="literal">GameCharacter.cpp</code> so that we set game character instances equal to the party member and enemy data. First, in <code class="literal">UGameCharacter* UGameCharacter::CreateGameCharacter( FCharacterInfo* characterInfo, UObject* outer )</code>, set the character's <code class="literal">XP</code>, <code class="literal">MXP</code>, and <code class="literal">Lvl</code> equal to the party member's data:</p><div><pre class="programlisting">UGameCharacter* UGameCharacter::CreateGameCharacter( FCharacterInfo* characterInfo, UObject* outer )
{
  UGameCharacter* character = NewObject&lt;UGameCharacter&gt;( outer );

  // locate character classes asset
  UDataTable* characterClasses = Cast&lt;UDataTable&gt;( StaticLoadObject( UDataTable::StaticClass(), NULL, TEXT( "DataTable'/Game/Data/CharacterClasses.CharacterClasses'" ) ) );

  if( characterClasses == NULL )
  {
    UE_LOG( LogTemp, Error, TEXT( "Character classes datatable not found!" ) );
  }
  else
  {
    character-&gt;CharacterName = characterInfo-&gt;Character_Name;

    FCharacterClassInfo* row = characterClasses-&gt;FindRow&lt;FCharacterClassInfo&gt;( *( characterInfo-&gt;Class_ID ), TEXT( "LookupCharacterClass" ) );
    character-&gt;ClassInfo = row;

    character-&gt;MHP = character-&gt;ClassInfo-&gt;StartMHP;
    character-&gt;MMP = character-&gt;ClassInfo-&gt;StartMMP;
    character-&gt;HP = character-&gt;MHP;
    character-&gt;MP = character-&gt;MMP;

    character-&gt;ATK = character-&gt;ClassInfo-&gt;StartATK;
    character-&gt;DEF = character-&gt;ClassInfo-&gt;StartDEF;
    character-&gt;LUCK = character-&gt;ClassInfo-&gt;StartLuck;

    character-&gt;XP = character-&gt;ClassInfo-&gt;XP;

    character-&gt;MXP = character-&gt;ClassInfo-&gt;MXP;
    character-&gt;Lvl = character-&gt;ClassInfo-&gt;Lvl;
    character-&gt;isPlayer = true;
  }

  return character;
}</pre></div><p>Next, set each instance of the enemy character's XP equal to the XP enemy data:</p><div><pre class="programlisting">UGameCharacter* UGameCharacter::CreateGameCharacter( FEnemyInfo* enemyInfo, UObject* outer )
{
  UGameCharacter* character = NewObject&lt;UGameCharacter&gt;( outer );

  character-&gt;CharacterName = enemyInfo-&gt;EnemyName;

  character-&gt;ClassInfo = nullptr;

  character-&gt;MHP = enemyInfo-&gt;MHP;
  character-&gt;MMP = 0;
  character-&gt;HP = enemyInfo-&gt;MHP;
  character-&gt;MP = 0;

  character-&gt;ATK = enemyInfo-&gt;ATK;
  character-&gt;DEF = enemyInfo-&gt;DEF;
  character-&gt;LUCK = enemyInfo-&gt;Luck;
  character-&gt;Gold = enemyInfo-&gt;Gold;
  character-&gt;XP = enemyInfo-&gt;XP;

  character-&gt;decisionMaker = new TestDecisionMaker();
  character-&gt;isPlayer = false;

  return character;
}</pre></div><p>We can now add an <a id="id539" class="indexterm"/>XP framework to our combat engine. Open <code class="literal">CombatEngine.h</code>. Add <code class="literal">XPTotal</code> as a public variable:</p><div><pre class="programlisting">public:
  int32 XPTotal;</pre></div><p>The <code class="literal">XPTotal</code> will be responsible for holding the total amount of XP gained from battle if all of the enemies have perished.</p><p>At this point, let's use the XP variables that we created to calculate the amount of XP gained from battle. Open <code class="literal">CombatEngine.cpp</code>. In <code class="literal">bool CombatEngine::Tick( float DeltaSeconds )</code>, add XP to our check for victory section. To do this, we will set the local <code class="literal">XP</code> variable to <code class="literal">0</code>, and <a id="id540" class="indexterm"/>for every enemy in the battle, we will accumulate the total amount of experience in the <code class="literal">XP</code> variable:</p><div><pre class="programlisting">// check for victory
  deadCount = 0;
  int32 Gold = 0;
  int32 XP = 0;
  for( int i = 0; i &lt; this-&gt;enemyParty.Num(); i++ )
  {
    if( this-&gt;enemyParty[i]-&gt;HP &lt;= 0 ) deadCount++;
    Gold += this-&gt;enemyParty[i]-&gt;Gold;
    XP += this-&gt;enemyParty[i]-&gt;XP;
  }</pre></div><p>If all of the party members have died, we will store the total XP of the enemies in our public <code class="literal">XPTotal</code> variable to be used outside this class:</p><div><pre class="programlisting">// all enemies have died, switch to victory phase
  if( deadCount == this-&gt;enemyParty.Num() )
  {
    this-&gt;SetPhase( CombatPhase::CPHASE_Victory );
    GoldTotal = Gold;
    XPTotal = XP;
    return false;
  }</pre></div><p>Lastly, we can add the XP gained to each party member in our game instance. To do this, open <code class="literal">RPGGameMode.cpp</code>. In <code class="literal">void ARPGGameMode::Tick( float DeltaTime )</code>, where we added a check to the victory phase, we will create a <code class="literal">for</code> loop. This <code class="literal">for</code> loop will cycle through every party member, and for each party member, we will set their current XP to be a cumulative of the XP gained from the battle:</p><div><pre class="programlisting">for (int i = 0; i &lt; gameInstance-&gt;PartyMembers.Num(); i++)
{
  gameInstance-&gt;PartyMembers[i]-&gt;XP += this-&gt;currentCombatInstance-&gt;XPTotal;
}</pre></div><p>In this <code class="literal">for</code> loop, we can also check the current XP with the current XP cap for the level the player is currently at. If the current XP of the party member is more than or equal to <code class="literal">MXP</code>, the player will level up, gain increased base stats, and the XP cap to gain the next level (<code class="literal">MXP</code>) will increase:</p><div><pre class="programlisting">if (gameInstance-&gt;PartyMembers[i]-&gt;XP &gt;= gameInstance-&gt;PartyMembers[i]-&gt;MXP){
  gameInstance-&gt;PartyMembers[i]-&gt;Lvl++;
  gameInstance-&gt;PartyMembers[i]-&gt;MHP++;
  gameInstance-&gt;PartyMembers[i]-&gt;MMP++;
  gameInstance-&gt;PartyMembers[i]-&gt;ATK++;
  gameInstance-&gt;PartyMembers[i]-&gt;DEF++;
  gameInstance-&gt;PartyMembers[i]-&gt;LUCK++;
  gameInstance-&gt;PartyMembers[i]-&gt;MXP += gameInstance-&gt;PartyMembers[i]-&gt;MXP;
}</pre></div><p>In this example, we kept <a id="id541" class="indexterm"/>our calculations simple by only allowing the stats to increase by one when the party member gains a level, and setting the cap to the next level to just be double of what the previous level was. If you like, you can come up with more complex calculations specific to your game here. Note that all the calculations used for differentiating stat numbers and for each party member can be done here.</p><p>When you are done, the victory condition will look like this:</p><div><pre class="programlisting">else if( this-&gt;currentCombatInstance-&gt;phase == CombatPhase::CPHASE_Victory )
{
  UE_LOG( LogTemp, Log, TEXT( "Player wins combat" ) );
  URPGGameInstance* gameInstance = Cast&lt;URPGGameInstance&gt;(GetGameInstance());
  gameInstance-&gt;GameGold += this-&gt;currentCombatInstance-&gt;GoldTotal;

  for (int i = 0; i &lt; gameInstance-&gt;PartyMembers.Num(); i++)
  {
    gameInstance-&gt;PartyMembers[i]-&gt;XP += this-&gt;currentCombatInstance-&gt;XPTotal;

    if (gameInstance-&gt;PartyMembers[i]-&gt;XP&gt;= gameInstance-&gt;PartyMembers[i]-&gt;MXP){
      gameInstance-&gt;PartyMembers[i]-&gt;Lvl++;
      gameInstance-&gt;PartyMembers[i]-&gt;MHP++;
      gameInstance-&gt;PartyMembers[i]-&gt;MMP++;
      gameInstance-&gt;PartyMembers[i]-&gt;ATK++;
      gameInstance-&gt;PartyMembers[i]-&gt;DEF++;
      gameInstance-&gt;PartyMembers[i]-&gt;LUCK++;

      gameInstance-&gt;PartyMembers[i]-&gt;MXP +=gameInstance-&gt;PartyMembers[i]-&gt;MXP;
    }

  }

UGameplayStatics::GetPlayerController( GetWorld(), 0 )-&gt;SetActorTickEnabled( true );
}</pre></div><p>At this point, you can compile your source code and restart/open your project in UE4.</p><p>We are now done with <a id="id542" class="indexterm"/>creating the framework for our experience system in our source code, and we can now move on to providing specific starting values for each of these in our game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Data Table starting values</h1></div></div></div><p>In <a id="id543" class="indexterm"/><strong>Content Browser</strong>, open the <strong>CharacterClasses</strong> Data Table by navigating to <strong>Content</strong> | <strong>Data</strong>. Here, we can change the starting values of our party members. For the soldier, we will have the starting XP as 0 because the party member should start with 0 experience. The <strong>MXP</strong> value will be <strong>200</strong>, which means that the Soldier will have to gain 200 experience points before making it to the next level. The <strong>Lvl</strong> value will be at <strong>1</strong> since we want each character to start at level 1:</p><div><img src="img/B04548_10_01.jpg" alt="Data Table starting values"/></div><p>We should now set how much XP our enemies give. In the same folder, open the <strong>Enemies</strong> Data Table, where <a id="id544" class="indexterm"/>we have at least one enemy. For each enemy, we need to set a value for <strong>XP</strong> that will determine how much experience the enemy drops when they are killed. For this particular enemy, we set the <strong>XP</strong> value to <strong>50</strong>:</p><div><img src="img/B04548_10_02.jpg" alt="Data Table starting values"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Displaying levels and experience in the pause menu</h1></div></div></div><p>At this point, if <a id="id545" class="indexterm"/>you test the build, the party members will gain experience from battle and level up accordingly (you will be able to tell by watching the stats grow if a party member has gained enough experience to level up), but we will not yet <a id="id546" class="indexterm"/>display the proper level or experience points of the party members. We can easily do this by binding these values to our pause menu. Navigate to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong>. Open the <strong>Pause_Main</strong> Widget Blueprint. In the <strong>Designer</strong> view, select the <strong>Editable_Soldier_Level</strong> Text Block on the right-hand side of <strong>Soldier Lvl</strong> that we created in <a class="link" href="ch04.html" title="Chapter 4. Pause Menu Framework">Chapter 4</a>, <em>Pause Menu Framework</em>:</p><div><img src="img/B04548_10_03.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>In the <strong>Details</strong> tab under <strong>Content</strong>, create a bind to <a id="id547" class="indexterm"/>that text by clicking on the <strong>Bind</strong> drop-down menu and selecting <strong>+Create Binding</strong>:</p><div><img src="img/B04548_10_04.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>This will automatically<a id="id548" class="indexterm"/> open the graph of the <strong>Get Editable_Soldier_Level_Text</strong> function. In the graph, we need to simply get the variables from the <strong>RPGGameInstance</strong>, like we did before, but this time, we are specifically getting <a id="id549" class="indexterm"/>the current <strong>Lvl</strong> variable and returning it as text:</p><p> </p><div><img src="img/B04548_10_05.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>
</p><p>In this example, we <a id="id550" class="indexterm"/>are only getting the level for one party member (our soldier), which is in an index 0 in the array. If you have more than one party member, you will just need to change the index in your <strong>GET</strong> function to the proper index; for instance, an index of 1 will find the second party member in your array of party members and their stats, and would, therefore, return a different set of stats.</p><p>The only undefined Text Block that we have in our pause menu is the <strong>Editable_Soldier_XP</strong> Text Block located on the right-hand side of the <strong>XP/Next Lvl</strong> text. Select this Text Block, navigate to the <strong>Details</strong> tab, and under <strong>Content</strong>, add a binding for the Text Block, like we did for our last Text Block, and the graph for the function labeled <strong>Get Editable_Soldier_XP_Text</strong> will pop up. Just like the last Text Block, we will get the correct party member's current data; in particular, we will get XP and MXP because we want this Text Block to show the cumulative XP and the XP needed to get to the next level:</p><p> </p><div><img src="img/B04548_10_06.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>
</p><p>You will <a id="id551" class="indexterm"/>notice <a id="id552" class="indexterm"/>that <strong>ReturnNode</strong> can only take one <strong>Return Value</strong> pin, and we have two separate values. We can easily solve this problem using the <strong>Append</strong> function and appending the text. We will find the <strong>Append</strong> function by simply right-clicking on our Blueprint, navigating to <strong>Utilities</strong> | <strong>String</strong>, and selecting <strong>Append</strong>:</p><div><img src="img/B04548_10_07.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>
<strong>Append</strong> takes two strings at a time. Since the Text Block should have a <strong>/</strong> to separate the current XP with the XP needed to make it to the next level, we will need two <strong>Append</strong> functions. For the first <strong>Append</strong>, link <strong>XP</strong> to the <strong>A</strong> pin, and in the <strong>B</strong> pin, simply append a <strong>/</strong>:</p><div><img src="img/B04548_10_08.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>Next, create <a id="id553" class="indexterm"/>another <strong>Append</strong> function, and connect the <strong>Return Value</strong> of the first <strong>Append</strong> function to the <strong>A</strong> pin of the second <strong>Append </strong>function. Then, connect <strong>MXP</strong> to the <strong>B</strong> pin of the second <strong>Append</strong> function in order to have <strong>MXP</strong> append <a id="id554" class="indexterm"/>the last set of strings:</p><div><img src="img/B04548_10_09.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>When you are done, simply connect the <strong>Return Value</strong> of the second <strong>Append</strong> function to the <strong>Return Value</strong> of the <strong>ReturnNode</strong>:</p><div><img src="img/B04548_10_10.jpg" alt="Displaying levels and experience in the pause menu"/></div><p>At this point, if you <a id="id555" class="indexterm"/>test your game by going into battle and leveling <a id="id556" class="indexterm"/>up, you will see that all of your stats will update correctly in the pause menu (the following screenshot is from after we have tested combat and gaining experience with foes):</p><div><img src="img/B04548_10_11.jpg" alt="Displaying levels and experience in the pause menu"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Applying the correct damage in combat</h1></div></div></div><p>In battle, you <a id="id557" class="indexterm"/>will notice that the enemy and the player both do 10 points of damage no matter what. The current attack power and defense do not seem to be calculated. This is because, in <a class="link" href="ch03.html" title="Chapter 3. Exploration and Combat">Chapter 3</a>, <em>Exploration and Combat</em>, when we created the combat actions, we hardcoded the damage to be <code class="literal">target-&gt;HP -= 10</code>, which means that no matter who is attacking, they will deal 10 points of damage to the player. We can easily fix this to use the actual stats of enemies and players by navigating to <strong>Source</strong> | <strong>RPG</strong> | <strong>Combat</strong> | <strong>Actions</strong> and opening <code class="literal">TestCombatAction.cpp</code>. Find <code class="literal">target-&gt;HP -= 10;</code> and replace it with <code class="literal">target-&gt;HP -= (character-&gt;ATK - target-&gt;DEF) &gt;= 0 ? (character-&gt;ATK - target-&gt;DEF):0;</code>.</p><p>This is a ternary operator. When a target is attacked, whether it is a party member or an enemy, the target's HP will go down by the attacker's attack power minus the target's defense power<a id="id558" class="indexterm"/> only if this result ends up being the same or greater than 0. If the result is less than 0, then HP will default to 0. When you are done, <code class="literal">void TestCombatAction::BeginExecuteAction( UGameCharacter* character )</code> will look like this:</p><div><pre class="programlisting">void TestCombatAction::BeginExecuteAction( UGameCharacter* character )
{
  this-&gt;character = character;

  // target is dead, select another target
  if( this-&gt;target-&gt;HP &lt;= 0 )
  {
    this-&gt;target = this-&gt;character-&gt;SelectTarget();
  }

  // no target, just return
  if( this-&gt;target == nullptr )
  {
    return;
  }

  UE_LOG( LogTemp, Log, TEXT( "%s attacks %s" ), *character-&gt;CharacterName, *target-&gt;CharacterName );

  target-&gt;HP -= (character-&gt;ATK - target-&gt;DEF) &gt;= 0 ? (character-&gt;ATK - target-&gt;DEF):0;

  this-&gt;delayTimer = 1.0f;
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Setting up the abilities array</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Exploration and Combat">Chapter 3</a>, <em>Exploration and Combat</em>, we <a id="id559" class="indexterm"/>created a character class info for learned abilities, which was done in <code class="literal">FCharacterClassInfo.h</code>, which is an array used to hold an array of abilities for each character that inherits a class. We need to extend this array so that it is adopted by any game character to hold abilities that they learn throughout the game. To do this, open <code class="literal">GameCharacter.h</code> by navigating to <strong>Source</strong> | <strong>RPG</strong>. In <code class="literal">class RPG_API UGameCharacter : public UObject</code>, add a public <code class="literal">UPROPERTY</code> to learned abilities and allow it to be editable anywhere:</p><div><pre class="programlisting">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CharacterInfo)
  TArray&lt;FString&gt; LearnedAbilities;</pre></div><p>Next, open <code class="literal">GameCharacter.cpp</code> located in the same folder, and set <code class="literal">LearnedAbilities</code> to be equal to <code class="literal">LearnedAbilities</code> from the class info that we created the variable in:</p><div><pre class="programlisting">character-&gt;LearnedAbilities = character-&gt;ClassInfo-&gt;LearnedAbilities;</pre></div><p>This will allow <a id="id560" class="indexterm"/>each instance of a party member to hold its own <code class="literal">LearnedAbilities</code> array that we can now edit either in code or in Blueprint. Your game character will now look like this:</p><div><pre class="programlisting">UGameCharacter* UGameCharacter::CreateGameCharacter( FCharacterInfo* characterInfo, UObject* outer )
{
  UGameCharacter* character = NewObject&lt;UGameCharacter&gt;( outer );

  // locate character classes asset
  UDataTable* characterClasses = Cast&lt;UDataTable&gt;( StaticLoadObject( UDataTable::StaticClass(), NULL, TEXT( "DataTable'/Game/Data/CharacterClasses.CharacterClasses'" ) ) );

  if( characterClasses == NULL )
  {
    UE_LOG( LogTemp, Error, TEXT( "Character classes datatable not found!" ) );
  }
  else
  {
    character-&gt;CharacterName = characterInfo-&gt;Character_Name;

    FCharacterClassInfo* row = characterClasses-&gt;FindRow&lt;FCharacterClassInfo&gt;( *( characterInfo-&gt;Class_ID ), TEXT( "LookupCharacterClass" ) );

    character-&gt;ClassInfo = row;

    character-&gt;MHP = character-&gt;ClassInfo-&gt;StartMHP;
    character-&gt;MMP = character-&gt;ClassInfo-&gt;StartMMP;
    character-&gt;HP = character-&gt;MHP;
    character-&gt;MP = character-&gt;MMP;

    character-&gt;ATK = character-&gt;ClassInfo-&gt;StartATK;
    character-&gt;DEF = character-&gt;ClassInfo-&gt;StartDEF;
    character-&gt;LUCK = character-&gt;ClassInfo-&gt;StartLuck;

    character-&gt;XP = character-&gt;ClassInfo-&gt;XP;

    character-&gt;MXP = character-&gt;ClassInfo-&gt;MXP;
    character-&gt;Lvl = character-&gt;ClassInfo-&gt;Lvl;
    character-&gt;LearnedAbilities = character-&gt;ClassInfo-&gt;LearnedAbilities;
    character-&gt;isPlayer = true;
  }

  return character;
}</pre></div><p>Once done, compile and restart the editor. We can now <a id="id561" class="indexterm"/>create a spot in our game where we can hold and use abilities. In this game, we will choose to use abilities in battle only, but if you want to use abilities elsewhere, for example, outside battle, you can easily accomplish this by following similar steps. Since we will be applying abilities in battle, let's add a new abilities button to our combat interface. In the editor, navigate to <strong>Content</strong> | <strong>Blueprints</strong> | <strong>UI</strong>, and open the <strong>CombatUI</strong> Widget Blueprint.</p><p>In the <strong>Designer</strong> view, create a Combo Box that will allow us to have a drop-down menu with multiple entries, which we will use to hold and select our abilities, and place them in the <strong>characterActions</strong> Canvas Panel:</p><div><img src="img/B04548_10_12.jpg" alt="Setting up the abilities array"/></div><p>Resize the <a id="id562" class="indexterm"/>Combo Box to the same size as that of the <strong>Attack</strong> button, and place it in alignment with the <strong>Attack</strong> button:</p><div><img src="img/B04548_10_13.jpg" alt="Setting up the abilities array"/></div><p>Lastly, rename<a id="id563" class="indexterm"/> the Combo Box to fit to the elements that will be contained in the Combo Box. We can name this <strong>ComboBoxString_Abilities</strong>, and check <strong>Is Variable</strong>:</p><div><img src="img/B04548_10_14.jpg" alt="Setting up the abilities array"/></div><p>Now that we have a Combo Box that can hold abilities, it is now time to populate the Combo Box with appropriate abilities. Open the <strong>CombatUI</strong> Event Graph. Since we are concerned with having the correct abilities that are accessible during battle, it would be best to populate the Combo Box with abilities as soon as the <strong>CombatUI</strong> is created. To do this, create an <strong>Event Construct</strong> by navigating to <strong>Add Event</strong> | <strong>User Interface</strong>:</p><div><img src="img/B04548_10_15.jpg" alt="Setting up the abilities array"/></div><p>Connect the <strong>Event Construct</strong> to <strong>Cast To RPGGameInstance</strong>, which will get all the party members, so that we can get and set the proper abilities:</p><div><img src="img/B04548_10_16.jpg" alt="Setting up the abilities array"/></div><p>What we can do <a id="id564" class="indexterm"/>here is set an ability for one of the party members (in this case, the soldier) by getting an index 0 of the <strong>Party Members</strong> Array. We will give the Soldier an ability called <strong>Attack x2</strong> if the Soldier has reached level 2. To do this, we will get the current level of the target using the <strong>Lvl</strong> variable and compare it with the integer 2 using the <strong>CompareInt</strong> macro:</p><div><img src="img/B04548_10_17.jpg" alt="Setting up the abilities array"/></div><p>If the <strong>Lvl</strong> variable is <a id="id565" class="indexterm"/>more than or equal to 2, we can set the first element of the <strong>LearnedAbilities</strong> array to <strong>Attack x2</strong>:</p><div><img src="img/B04548_10_18.jpg" alt="Setting up the abilities array"/></div><p>After we have populated the array with the new <strong>Attack x2</strong> ability, we can now populate the Combo Box with every ability that we have by simply executing a <strong>ForEachLoop</strong> and cycling through every element of the array, and adding it to the Combo Box using the <strong>Add Option</strong> function by navigating to <strong>Combo Box</strong> | <strong>Add Option</strong>:</p><div><img src="img/B04548_10_19.jpg" alt="Setting up the abilities array"/></div><p>This is a very simple <a id="id566" class="indexterm"/>way to add combat abilities to an abilities drop-down menu in accordance with party member levels. If you want to create more abilities, all you need to do is simply compare your level with another level using the <strong>CompareInt</strong>, and you can add more abilities to the <strong>LearnedAbilities</strong> array. If you end up having additional characters in the game, it is best to create a new Combo Box for each party member, get that party member from whichever index they are in the <strong>Party Members</strong> array, and then add abilities to their own <strong>LearnedAbilities</strong> array like we did with the Soldier.</p><p>You should now be able to test this and see that when the player presses the Combo Box, <strong>Attack x2</strong> will appear if the Soldier party member hits level 2:</p><div><img src="img/B04548_10_20.jpg" alt="Setting up the abilities array"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Abilities logic</h1></div></div></div><p>We can now <a id="id567" class="indexterm"/>create a logic for our <strong>Attack x2</strong> ability. As the name suggests, <strong>Attack x2</strong> should perform an attack that does double damage. Before we apply this sort of logic, we must first create an event that occurs after selecting the ability from the Combo Box and pressing it. Head back into the <strong>Designer</strong> view. In the <strong>Details</strong> tab, navigate to <strong>Events</strong>, and press <strong>+</strong> next to the <strong>OnOpening</strong> event:</p><div><img src="img/B04548_10_21.jpg" alt="Abilities logic"/></div><p>This will <a id="id568" class="indexterm"/>create an <strong>OnOpening</strong> event in your Event Graph. By selecting and clicking on the ability from the Combo Box, we need to first clear all the children from the <strong>Panel</strong> Widget using the <strong>Clear Children</strong> function, similar to what we did by clicking on the <strong>Attack</strong> button. This will prevent multiple buttons of the same target from popping up:</p><div><img src="img/B04548_10_22.jpg" alt="Abilities logic"/></div><p>Next, we will check whether the <strong>Attack x2</strong> ability has been opened by first calling the <strong>Get Selected Option</strong> function located under Combo Box (you will need to turn off <strong>Context Sensitive</strong> for this):</p><div><img src="img/B04548_10_23.jpg" alt="Abilities logic"/></div><p>We set <a id="id569" class="indexterm"/>the <strong>Target</strong> of <strong>Get Selected Option</strong> to the <strong>Get Combo Box String Abilities</strong>:</p><div><img src="img/B04548_10_24.jpg" alt="Abilities logic"/></div><p>Then, check whether the selected option is equal to <strong>Attack x2</strong>:</p><div><img src="img/B04548_10_25.jpg" alt="Abilities logic"/></div><p>If it is equal, this<a id="id570" class="indexterm"/> means that we have selected <strong>Attack x2</strong>, and we will then get the <strong>RPGGameInstance</strong>. However, we need to first check whether the party member has enough MP to use the ability. In this case, we will set the ability to use 10 MP, so let's make sure that the party member has at least 10 MP before using the ability:</p><div><img src="img/B04548_10_26.jpg" alt="Abilities logic"/></div><p>If the player has enough MP to use the ability, we will use a logic that allows the player to perform an attack that does double damage. Since the player will be doing double damage, this means that it will be easy to multiply the <strong>ATK</strong> variable of the player by two; however, we do not want the <strong>ATK</strong> variable to be doubled forever, only for this turn. To do this, it would be best to create a local variable that will temporarily hold the base <strong>ATK</strong> value so that on the next turn, we can reset the <strong>ATK</strong> value back to its normal value. We can easily do this by creating a local integer called <strong>Temp Atk</strong>, and set <strong>Temp Atk</strong> to the party member's <strong>ATK</strong> value:</p><div><img src="img/B04548_10_27.jpg" alt="Abilities logic"/></div><p>Next, we will set <a id="id571" class="indexterm"/>the <strong>ATK</strong> value of the party member to double its value by multiplying it by two, and set the <strong>ATK</strong> variable to the product of that operation:</p><div><img src="img/B04548_10_28.jpg" alt="Abilities logic"/></div><p>We also need to set a Boolean to tell when we have used <strong>Attack x2</strong>. Because if we have used it, we need to subtract MP from the party member, and set our <strong>ATK</strong> variable back to normal. To do this, we need to create a local Boolean, which we will call <code class="literal">attackx2</code>. After we set the attack to be double, set <code class="literal">attackx2</code> to true, and allow the <strong>CombatUI</strong> to show all the available enemy targets by connecting <strong>SET attackx2</strong> to the <strong>Get Character Targets</strong> function:</p><div><img src="img/B04548_10_29.jpg" alt="Abilities logic"/></div><p>Once this is done, we<a id="id572" class="indexterm"/> can reset the <code class="literal">attackx2</code> Boolean to false, set the <strong>ATK</strong> variable back to its normal value, and remove 10 MP from the party member for using the ability. The best place to do this is after the <strong>Event Show Actions Panel</strong> occurs again, when the character actions become visible and the targets become invisible. After the targets become invisible, we will check whether the <code class="literal">attackx2</code> Boolean is true. If it is true, we will set it to false, and then set the <strong>ATK</strong> value equal to the <strong>Temp Atk</strong> value. Then, we subtract 10 from the party member's MP variable:</p><div><img src="img/B04548_10_30.jpg" alt="Abilities logic"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Saving and loading game progress</h1></div></div></div><p>The last thing that <a id="id573" class="indexterm"/>we will focus on is saving and loading game progress. Saving and loading can be done in many ways, but at its heart, saving the progress revolves around specific variables that you would like to save.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec56"/>Saving</h2></div></div></div><p>Most games <a id="id574" class="indexterm"/>save a lot of different variables, such as the level or area the player is in, the player's stats, the player's inventory, and gold. In our example, we will choose to save the player's gold, but using the method that we are about to perform, you can easily figure out how to save all the other progress in the game.</p><p>To start with, create a new Blueprint class in <strong>Content Browser</strong> by navigating to <strong>Content</strong> | <strong>Blueprints</strong>. The <strong>Pick Parent Class</strong> window will pop up, and from <strong>All Classes</strong>, select <strong>SaveGame</strong>:</p><div><img src="img/B04548_10_31.jpg" alt="Saving"/></div><p>Name this class <strong>NewSaveGame</strong>, and open the class. The purpose of this class is to hold the values of <a id="id575" class="indexterm"/>every variable that you would like to save. As mentioned earlier, for this example, we will be saving the gold variable, but if you would like to save more variables, the <strong>NewSaveGame</strong> class that you just created will store those variables as well. At this point, add a new variable to this class from the <strong>Add New</strong> variable in the <strong>My Blueprint</strong> tab. Name it <strong>Gold</strong>, and make its variable an <strong>Integer</strong> type:</p><div><img src="img/B04548_10_32.jpg" alt="Saving"/></div><p>Now that you are done, it is time to find a good spot for the game to be saved and the gold variable to be saved. Since we already have a pause menu and learned how to add buttons to the <a id="id576" class="indexterm"/>pause menu in the previous chapters, it would be easy to create a new button that we can call <strong>Save</strong> in the <strong>Pause_Main</strong> Widget Blueprint and add an <strong>OnClicked</strong> event to it:</p><div><img src="img/B04548_10_33.jpg" alt="Saving"/></div><p>Once you click on <strong>+</strong> next to the <strong>OnClicked</strong> event, the Event Graph will open up, and you will see the <strong>OnClicked</strong> event for your <strong>Save</strong> button. Here, allow the button, when pressed, to create a save game object. To do this, create <strong>Create Save Game Object</strong> whose <strong>Save Game Class</strong> is set to <strong>New Save Game</strong>, and allow it to start when you click on the button:</p><div><img src="img/B04548_10_34.jpg" alt="Saving"/></div><p>Here, we will need <a id="id577" class="indexterm"/>to create a new variable of the <strong>Save Game</strong> type, and we will call this variable <strong>save</strong>:</p><div><img src="img/B04548_10_35.jpg" alt="Saving"/></div><p>Here, we will create a <strong>SET Save</strong> variable in our Blueprint, and pass the <strong>Return Value</strong> of the <strong>Create Save Game Object</strong> function to <strong>SET Save</strong>:</p><div><img src="img/B04548_10_36.jpg" alt="Saving"/></div><p>We will now need<a id="id578" class="indexterm"/> to cast the <strong>NewSaveGame</strong> class so that we can set the <strong>Gold</strong> variable that we created to the game's gold. To do this, cast <strong>SET Save</strong> to <strong>NewSaveGame</strong> by connecting the <strong>Save</strong> value to the <strong>Object</strong> of <strong>Cast To NewSaveGame</strong>:</p><div><img src="img/B04548_10_37.jpg" alt="Saving"/></div><p>Next, allow <strong>Cast To NewSaveGame</strong> to fire off a <strong>Cast To RPGInstance</strong> whose <strong>Object</strong> is a reference to <strong>Get Game Instance</strong>. We are doing this so that we can get an instance of the <strong>GameGold</strong>, so link the <strong>As RPGGame Instance</strong> pin from <strong>Cast To RPGGameInstance</strong> to the <strong>Get GameGold</strong> variable from the RPG instance:</p><div><img src="img/B04548_10_38.jpg" alt="Saving"/></div><p>Now that we are <a id="id579" class="indexterm"/>getting the game gold, we can set the game gold's value to the <strong>Gold</strong> variable from the <strong>NewSaveGame</strong> class by linking the <strong>SET Gold</strong> to fire off when the <strong>RPGGameInstance</strong> is cast, and then linking the <strong>GameGold</strong> value pin to the <strong>Gold</strong> value pin and the <strong>Target</strong> pin of <strong>SET Gold</strong> to the <strong>As New Save Game</strong> pin from <strong>Cast To NewSaveGame</strong>:</p><div><img src="img/B04548_10_39.jpg" alt="Saving"/></div><p>This particular method will allow us to save whatever the current game gold is to our <strong>Gold</strong> variable in the <strong>NewSaveGame</strong> class. Note that if you want to save more variables, set the values of those variables just like you set the value of the <strong>Gold</strong> variable by adding a <strong>SET</strong> node for each individual variable that you have.</p><p>The last thing we will need to do is create a save game slot, which will hold our save game object. To do this, create a <strong>Save Game to Slot</strong> action, which you will find under <strong>Game</strong> in your <strong>Actions</strong> window:</p><div><img src="img/B04548_10_40.jpg" alt="Saving"/></div><p>Create a slot name <a id="id580" class="indexterm"/>for this; in this example, we will use <strong>A</strong> as <strong>Slot Name</strong>. Link the <strong>Save Game Object</strong> pin of <strong>Save Game to Slot</strong> to the <strong>Save</strong> value pin, and allow the <strong>Save Game to Slot</strong> to fire when the <strong>Gold</strong> variable is set:</p><div><img src="img/B04548_10_41.jpg" alt="Saving"/></div><p>We are now done with the saving part of the game. We will now move on to loading a game slot.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec57"/>Loading</h2></div></div></div><p>Just<a id="id581" class="indexterm"/> like saving, loading can be done in a number of ways. In our game, we will simply load the player's save data on launching the game. To do this, open the <strong>FieldPlayer</strong> Blueprint since we know that the FieldPlayer will always exist in our game.</p><p>Next, we will create a <strong>Load</strong> variable of the <strong>Save Game</strong> type similar to what we did when we saved the game, so that we can properly cast the variables and their values from <strong>NewSaveGame</strong>:</p><div><img src="img/B04548_10_42.jpg" alt="Loading"/></div><p>Here, we will create an <strong>Event Begin Play</strong>, and from <strong>Event Begin Play</strong>, we will call the <strong>Does Save Game Exist</strong> function from the <strong>Game</strong> category in the <strong>Actions</strong> window, and under <strong>Slot Name</strong>, we <a id="id582" class="indexterm"/>will look for <strong>A</strong> since we named our save slot <strong>A</strong> in the previous section:</p><div><img src="img/B04548_10_43.jpg" alt="Loading"/></div><p>From <strong>Does Save Game Exist</strong>, we will call a branch; if <strong>Does Save Game Exist</strong> is true, we will call <strong>Load Game from Slot</strong> and its <strong>Slot Name</strong> will also be <strong>A</strong>:</p><div><img src="img/B04548_10_44.jpg" alt="Loading"/></div><p>At this point, we have created a logic where, when the game starts, we check whether the saved game in slot A exists. If it does exist, we load the game from slot A; if it does not exist, we do nothing.</p><p>We can now set the <strong>Load</strong> variable that we created in the beginning of this section whose data type is <strong>Save Game</strong> to the <strong>Return Value</strong> of <strong>Load Game from Slot</strong> and cast it to <strong>NewSaveGame</strong> similar to what we did with our save game data:</p><div><img src="img/B04548_10_45.jpg" alt="Loading"/></div><p>Note that since <a id="id583" class="indexterm"/>we now have access to all the variables in <strong>NewSaveGame</strong>, it means that we have access to the gold value that we saved. So from here, we get the gold value from <strong>Cast To NewSaveGame</strong> so that you have whatever value was stored in <strong>Gold</strong> since the player last saved, and you will need to set the <strong>GameGold</strong> value from <strong>RPGGameInstance</strong> to <strong>Gold</strong> from <strong>NewSaveGame</strong>:</p><div><img src="img/B04548_10_46.jpg" alt="Loading"/></div><p>Just like when we created the saving logic, in this loading logic, if there are any other variables you need to load, you can easily do so by getting more variables from the <strong>NewSaveGame</strong> class and setting it to other variables from the <strong>RPG Game Instance</strong>.</p><p>You can now test this by simply playing the game, doing battle to get the game gold, saving the game with the <strong>Save</strong> button that we created in the pause menu, and then closing the game. When you reopen the game, you will notice that the gold you had when you saved the game is automatically loaded when you start the game. Using this framework, feel free to save other game variables such as your status and inventory</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Summary</h1></div></div></div><p>We now have a solution to allow party members to earn experience, gain levels with enough experience gained, and earn abilities through hitting specific levels. We have also fixed the combat system to allow party members and enemies to do damage based on their stats, as well as allow party members to use abilities in battle. Additionally, you now have the ability to save and load player progress throughout the game. Using the framework covered in this chapter, every party member can level up, and you can easily add more abilities to various party members, use them in battle, and players can save their game at any time and then come back to continue from where they left off.</p><p>At this juncture, you have successfully completed a working framework for a turn-based RPG. You have core gameplay working with the ability to allow a party of characters to explore a world in isometric 3D. You can battle enemies with new-found abilities and equipment and interact with NPCs by conversing with them and buying items and equipment with gold you earned from defeating enemies. And just like most other RPGs, you can level up through gaining experience, as well as save game status so players can come back to continue their games at a later date.</p><p>Your quest is not over yet though! Now that you know the basics, venture off to add more content to your game, like additional enemies, party members, NPCs and equipment. Through this process, create levels of your own using the framework and content you have created for yourself through following this book.</p></div></body></html>