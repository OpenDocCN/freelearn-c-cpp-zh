<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Helpful Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Helpful Utilities</h1></div></div></div><p>In addition to the essential classes introduced in the previous chapters, JUCE includes a range of classes for solving common problems in application development. In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Value</code>, <code class="literal">var</code>, and <code class="literal">ValueTree</code> classes</li><li class="listitem" style="list-style-type: disc">Implementing undo management</li><li class="listitem" style="list-style-type: disc">Adding XML support</li><li class="listitem" style="list-style-type: disc">Understanding how JUCE handles multiple threads</li><li class="listitem" style="list-style-type: disc">Storing the application properties</li><li class="listitem" style="list-style-type: disc">Adding the menu bar controls</li></ul></div><p>By the end of this chapter, you will have an awareness of some of the additional helpful utilities offered by JUCE.</p><div class="section" title="Using the dynamically typed objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Using the dynamically typed objects</h1></div></div></div><p>The<a id="id278" class="indexterm"/> JUCE <code class="literal">Value</code>, <code class="literal">var</code>, and <code class="literal">ValueTree</code> classes are valuable tools for application data storage and handling. The <code class="literal">var</code> class (short for variant) is <a id="id279" class="indexterm"/>designed to store a range of primitive data types including integers, floating-point numbers, and strings (JUCE <code class="literal">String</code> objects). It may also be recursive in the sense that a <code class="literal">var</code> instance can hold an array of <code class="literal">var</code> instances (a JUCE <code class="literal">Array&lt;var&gt;</code> object). In this way, the <code class="literal">var</code> class is similar to the dynamic types supported by many scripting languages such as JavaScript. A <code class="literal">var</code> object may also hold a reference to any kind of <code class="literal">ReferenceCounterObject</code> object or chunks of binary data. All of the following are valid initializations:</p><div class="informalexample"><pre class="programlisting">var anInt = 1;
var aDouble = 1.2345;
var aString = "Hello world!";</pre></div><div class="section" title="Using the Value class"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Using the Value class</h2></div></div></div><p>The<a id="id280" class="indexterm"/>
<code class="literal">Value</code> class<a id="id281" class="indexterm"/> is designed to hold a shared instance of a <code class="literal">var</code> object (by storing the <code class="literal">var</code> in a reference-counted wrapper). A <code class="literal">Value</code> object may have listeners attached using a <code class="literal">Value::Listener</code> function and the same techniques covered in the <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <span class="emphasis"><em>Building User Interfaces</em></span> regarding the listener and broadcaster system employed by the GUI classes. In fact, <code class="literal">Value</code> objects are used by the various <code class="literal">Component</code> subclasses to store any value, such as the text in a <code class="literal">Label</code> object, the position of the thumb in a <code class="literal">Slider</code> object, and so on. As an example, the following code snippets illustrate ways of setting a <code class="literal">Label</code> object's value and a <code class="literal">Slider</code> object's value using its <code class="literal">Value</code> object:</p><div class="informalexample"><pre class="programlisting">// Slider
Slider slider;
slider.getValueObject().setValue (10.0); 
// instead of:
//  slider.setValue (10);

// Label
Label label;
label.getTextValue().setValue ("Hello");
// instead of: 
//  label.setText ("Hello", sendNotification);
</pre></div><p>The<code class="literal"> Value</code> objects are also a way of sharing values, because they can be made to refer to the same underlying data. This can be useful where the same value is displayed in a GUI in different ways, especially in complex and detailed GUI displays. Create a new Introjucer project named <code class="literal">Chapter05_01</code> with a basic window, and replace the <code class="literal">MainComponent.h</code> file with the following:</p><div class="informalexample"><pre class="programlisting">
#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component
{
public:
  MainContentComponent();
  void resized();
  
private:
  Value value;
  Slider slider;
  Label label;
};

#endif  // __MAINCOMPONENT_H__</pre></div><p>Here we store the <code class="literal">Value</code>, <code class="literal">Slider</code>, and <code class="literal">Label</code> objects in our class. Replace the <code class="literal">MainComponent.cpp</code> file with the following:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: value (1.0),
  slider (Slider::LinearHorizontal, Slider::NoTextBox)
{
  label.setEditable (true);
  slider.getValueObject().referTo (value);
  label.getTextValue().referTo (value);
  
  addAndMakeVisible (&amp;slider);
  addAndMakeVisible (&amp;label);
  
  setSize (500, 400);
}

void MainContentComponent::resized()
{
  slider.setBounds (10, 10, getWidth() - 20, 20);
  label.setBounds (10, 40, getWidth() - 20, 20);
}</pre></div><p>Here, we <a id="id282" class="indexterm"/>initialize our <code class="literal">Value</code> object to the value of one, then use the <code class="literal">Value::referTo()</code> function to configure both the <code class="literal">Slider</code> and the <code class="literal">Label</code> objects' values to refer to this same underlying <code class="literal">Value</code> object. Build and <a id="id283" class="indexterm"/>run the application noticing that both the slider and label keep updated with the same value regardless of which one is changed. This is all achieved without us needing to configure our own listeners since JUCE handles all of this internally.</p></div><div class="section" title="Structuring hierarchical data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Structuring hierarchical data</h2></div></div></div><p>Clearly, in <a id="id284" class="indexterm"/>most applications the<a id="id285" class="indexterm"/> data model is much more complex and commonly hierarchical. The <code class="literal">ValueTree</code> class is designed to reflect this using a relatively lightweight, yet powerful implementation. A <code class="literal">ValueTree</code> object holds a tree structure of named <code class="literal">var</code> objects as properties, meaning that nodes in the tree can be almost any data type. The following example illustrates how to store data in a <code class="literal">ValueTree</code> object, and some of the features that make the <code class="literal">ValueTree</code> class so invaluable to JUCE application development.</p><p>Create a new Introjucer project named <code class="literal">Chapter05_02</code> with a basic window. Add a GUI component named <code class="literal">EntryForm</code> in a similar way to previous chapters. First, navigate to the <span class="strong"><strong>Graphics</strong></span> panel for the <code class="literal">EntryForm.cpp</code> file, and change the background color to gray. Now we will <a id="id286" class="indexterm"/>add a form-like page into which we can enter a person's name, age, and address. Add six <code class="literal">Label</code> objects to the <span class="strong"><strong>Subcomponents</strong></span> panel to act as labels for the data with the following contents: <span class="strong"><strong>First name</strong></span>, <span class="strong"><strong>Last name</strong></span>, <span class="strong"><strong>Age</strong></span>, <span class="strong"><strong>Line 1</strong></span>, <span class="strong"><strong>Line 2</strong></span>, and <span class="strong"><strong>Line 3</strong></span>.</p><p>Now add six<a id="id287" class="indexterm"/>
<code class="literal">Label</code> objects with no contents (that is, empty text) adjacent to each of the labels added in the previous step. Set these to have a white, rather than transparent background, and set their <span class="strong"><strong>editing</strong></span> property to <span class="strong"><strong>edit on single-click</strong></span>. Give these the following <span class="strong"><strong>member name</strong></span>, and <span class="strong"><strong>name</strong></span> values as follows: <code class="literal">firstNameField</code>, <code class="literal">lastNameField</code>, <code class="literal">ageField</code>, <code class="literal">line1Field</code>, <code class="literal">line2Field</code>, and <code class="literal">line3Field</code>.</p><p>Finally, add a <span class="strong"><strong>Group Box</strong></span> via the contextual menu accessed by right-clicking (on the Mac, press <span class="emphasis"><em>control</em></span> and click) in the <span class="strong"><strong>Subcomponents</strong></span> editor. Position this to surround the labels related to <span class="strong"><strong>Line 1</strong></span>, <span class="strong"><strong>Line 2</strong></span>, <span class="strong"><strong>Line 3,</strong></span> and their entry fields. This should now look similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/3316_05_01.jpg" alt="Structuring hierarchical data"/></div><p>Now save the project and open it in your IDE. Place an <code class="literal">EntryForm</code> object into the <code class="literal">MainContentComponent</code> object as before, by changing the <code class="literal">MainComponent.h</code> file to contain the following:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"
#include "EntryForm.h"

class MainContentComponent : public Component
{
public:
  MainContentComponent();
  void resized();
  
private:
  EntryForm form;
};
#endif</pre></div><p>Change the <code class="literal">MainComponent.cpp</code> file to contain the following:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  addAndMakeVisible (&amp;form);
  setSize (form.getWidth(), form.getHeight());
}

void MainContentComponent::resized()
{
  form.setBounds (0, 0, getWidth(), getHeight());
}</pre></div><p>We <a id="id288" class="indexterm"/>now need to add <a id="id289" class="indexterm"/>some custom code to the <code class="literal">EntryForm</code> class to get it to store its data in a <code class="literal">ValueTree</code> object. First, add some variables to the class in the <code class="literal">EntryForm.h</code> file in the <code class="literal">[UserVariables]</code> section as follows:</p><div class="informalexample"><pre class="programlisting">//[UserVariables]   -- You can add your own custom variables..
ValueTree personData;

static const Identifier personId;
static const Identifier firstNameId;
static const Identifier lastNameId;
static const Identifier ageId;
static const Identifier addressId;
static const Identifier line1Id;
static const Identifier line2Id;
static const Identifier line3Id;
//[/UserVariables]</pre></div><p>Here we have one <code class="literal">ValueTree</code> object that will store the data and several static <code class="literal">Identifier</code> objects (which we will initialize in the <code class="literal">EntryForm</code> class in a moment) that serve as names for the <code class="literal">ValueTree</code> object structure and its properties. An <code class="literal">Identifier</code> object is effectively a special type of <code class="literal">String</code> object that holds only a limited set of characters, such that it will be valid in other contexts (for example, variable names, XML).</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>It is more efficient to create these <code class="literal">Identifier</code> objects when the application starts rather than create them each time they are needed.</p></div></div><p>In the <code class="literal">EntryForm.cpp</code> file add<a id="id290" class="indexterm"/> the following code to initialize the <code class="literal">Identifier</code> objects to the <code class="literal">[MiscUserCode]</code> section:</p><div class="informalexample"><pre class="programlisting">//[MiscUserCode] You can add your own definitions ...
const Identifier EntryForm::personId = "person";
const Identifier EntryForm::firstNameId = "firstName";
const Identifier EntryForm::lastNameId = "lastName";
const Identifier EntryForm::ageId = "age";
const Identifier EntryForm::addressId = "address";
const Identifier EntryForm::line1Id = "line1";
const Identifier EntryForm::line2Id = "line2";
const Identifier EntryForm::line3Id = "line3";
//[/MiscUserCode]</pre></div><p>In the constructor <a id="id291" class="indexterm"/>we need to initialize the <code class="literal">ValueTree</code> object, so add the following code to the <code class="literal">[Constructor]</code> section:</p><div class="informalexample"><pre class="programlisting">//[Constructor] You can add your own custom stuff here..
personData = ValueTree (personId);
personData.setProperty (firstNameId, String::empty, nullptr);
personData.setProperty (lastNameId, String::empty, nullptr);
personData.setProperty (ageId, String::empty, nullptr);

ValueTree addressData = ValueTree (addressId);
addressData.setProperty (line1Id, String::empty, nullptr);
addressData.setProperty (line2Id, String::empty, nullptr);
addressData.setProperty (line3Id, String::empty, nullptr);
personData.addChild (addressData, -1, nullptr);
//[/Constructor]</pre></div><p>Here we create the main <code class="literal">ValueTree</code> object with the named type <code class="literal">person</code>, and add three properties for the first name, last name, and age. (The graphic layout of our <code class="literal">EntryForm</code> component indicates the hierarchical relationship between the values in this top-level <code class="literal">personData</code> object.) The <code class="literal">nullptr</code> argument in each case indicates that we do not want undo management; we will look at this later in the chapter. We then create another <code class="literal">ValueTree</code> object with the named type <code class="literal">address</code>. Then, we add the three lines of the address as properties and add it as a <span class="strong"><strong>child node</strong></span>
<a id="id292" class="indexterm"/> to the main <code class="literal">ValueTree</code> object. It is in this way that we create tree structures with several <code class="literal">ValueTree</code> objects. The second argument of the call to the <code class="literal">ValueTree::addChild()</code> function indicates the index at which we want<a id="id293" class="indexterm"/> to add the child node. The <code class="literal">-1</code> parameter passed in this case indicates we just want to add it to the end of the list of nodes (but we have only one in any case; therefore, this value is of little importance).</p><p>Finally, we need to update the <code class="literal">ValueTree</code> object when the labels change. Add the following code the appropriate sections:</p><div class="informalexample"><pre class="programlisting">//[UserLabelCode_firstNameField] -- add your label text handling..
personData.setProperty (firstNameId, 
                        labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_firstNameField]
...
//[UserLabelCode_lastNameField] -- add your label text handling..
personData.setProperty (lastNameId, 
                        labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_lastNameField]
...
//[UserLabelCode_ageField] -- add your label text handling..
personData.setProperty (ageId, 
                        labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_ageField]
...
//[UserLabelCode_line1Field] -- add your label text handling..
ValueTree addressData (personData.getChildWithName (addressId));
addressData.setProperty (line1Id, 
                        labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_line1Field]
...
//[UserLabelCode_line2Field] -- add your label text handling..
ValueTree addressData (personData.getChildWithName (addressId));
addressData.setProperty (line2Id, 
                        labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_line2Field]
...
//[UserLabelCode_line3Field] -- add your label text handling..
ValueTree addressData (personData.getChildWithName (addressId));
addressData.setProperty (line3Id, 
                         labelThatHasChanged-&gt;getText(), nullptr);
//[/UserLabelCode_line3Field]</pre></div><p>Build and run the <a id="id294" class="indexterm"/>application and confirm that you can edit the contents of the entry form fields. You may also notice that JUCE automatically implements <span class="strong"><strong>focus ordering</strong></span>,<a id="id295" class="indexterm"/> such that you can use the <span class="emphasis"><em>Tab</em></span> key to move between fields. However, this isn't very useful yet since we don't do anything with the data. In the next section we will add undo management, which will start to show the power of the <code class="literal">ValueTree</code> class.</p></div></div></div>
<div class="section" title="Employing undo management"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Employing undo management</h1></div></div></div><p>JUCE <a id="id296" class="indexterm"/>includes an <code class="literal">UndoManager</code> class to help manage <a id="id297" class="indexterm"/>undo and redo actions. This can be used independently, but works almost automatically if the application's data is stored in a <code class="literal">ValueTree</code> object. To illustrate this we need to make a few changes to the project developed so far. First make some changes in the Introjucer project. Add a <code class="literal">TextButton</code> subcomponent labeled <span class="strong"><strong>Undo</strong></span> and change its <span class="strong"><strong>name</strong></span> and <span class="strong"><strong>member name</strong></span> to <code class="literal">undoButton</code>. In the <span class="strong"><strong>Class </strong></span>panel add the <code class="literal">ValueTree::Listener</code> class to the <span class="strong"><strong>Parent classes</strong></span> property such that it reads:</p><div class="informalexample"><pre class="programlisting">public Component, public ValueTree::Listener</pre></div><p>Save all the files and the project, and open it into your IDE. Add the following code for the <code class="literal">ValueTree::Listener</code> class to the <code class="literal">[UserMethods]</code> section of the <code class="literal">MainComponent.h</code> file. Notice that we add empty function braces except for the <code class="literal">valueTreePropertyChanged()</code> function here since we do not need to add code for the other functions:</p><div class="informalexample"><pre class="programlisting">//[UserMethods]     -- You can add your own custom methods ...
void valueTreePropertyChanged (ValueTree&amp; tree,
                               const Identifier&amp; property);
void valueTreeChildAdded (ValueTree&amp; parentTree,
                          ValueTree&amp; child)       { }
void valueTreeChildRemoved (ValueTree&amp; parentTree,
                            ValueTree&amp; child)     { }
void valueTreeChildOrderChanged (ValueTree&amp; tree) { }
void valueTreeParentChanged (ValueTree&amp; tree)     { }
void valueTreeRedirected (ValueTree&amp; tree)        { }
//[/UserMethods]</pre></div><p>Add an <code class="literal">UndoManager</code> object to the <code class="literal">[UserVariables]</code> section as follows:</p><div class="informalexample"><pre class="programlisting">//[UserVariables]   -- You can add your own custom variables...
UndoManager undoManager;
...</pre></div><p>In the <code class="literal">EntryForm.cpp</code> file add the following code for the <code class="literal">ValueTree::Listener</code> functions to the<code class="literal"> [MiscUserCode]</code> section (notice that we need only one of these functions as we added empty functions to the preceding header file):</p><div class="informalexample"><pre class="programlisting">void EntryForm::valueTreePropertyChanged 
  (ValueTree&amp; tree, const Identifier&amp; property)
{
  if (property == firstNameId) {
    firstNameField-&gt;setText (tree.getProperty (property),
                             dontSendNotification);
  } else if (property == lastNameId) {
      lastNameField-&gt;setText (tree.getProperty (property),
                              dontSendNotification);
  } else if (property == ageId) {
      ageField-&gt;setText (tree.getProperty (property),
                         dontSendNotification);
  } else if (property == line1Id) {
      line1Field-&gt;setText (tree.getProperty (property),
                           dontSendNotification);
  } else if (property == line2Id) {
      line2Field-&gt;setText (tree.getProperty (property),
                           dontSendNotification);
  } else if (property == line3Id) {
      line3Field-&gt;setText (tree.getProperty (property),
                           dontSendNotification);
  }
}</pre></div><p>Add our <code class="literal">EntryForm</code> object<a id="id298" class="indexterm"/> as a listener to the main value tree by adding the following code to the end of the <code class="literal">[Constructor]</code> section:</p><div class="informalexample"><pre class="programlisting">...
personData.addListener (this);
//[/Constructor]</pre></div><p>Each time we call the <code class="literal">ValueTree::setProperty()</code> function we need to pass a pointer to our <code class="literal">UndoManager</code> object. Find each line of code that uses <code class="literal">ValueTree::setProperty()</code>, and change the <code class="literal">nullptr</code> argument to <code class="literal">&amp;undoManager</code>, for example:</p><div class="informalexample"><pre class="programlisting">//[UserLabelCode_firstNameField] -- add your label text handling..
personData.setProperty (firstNameId,
                        labelThatHasChanged-&gt;getText(), 
                        &amp;undoManager);
//[/UserLabelCode_firstNameField]</pre></div><p>Do not use a simple find-and-replace since there are other uses of <code class="literal">nullptr</code> in the code that do not relate to the <code class="literal">ValueTree</code> object and <code class="literal">UndoManager</code> object code. In our application, when we make a change that we want to be undoable, we need to tell the <code class="literal">UndoManager</code> object<a id="id299" class="indexterm"/> what comprises a <span class="strong"><strong>transaction</strong></span>. In some cases it might be appropriate to consider each minor change as a transaction. In other cases it might be more useful to the user to group small changes into a single transaction (for example, changes that occur within a certain time limit, or multiple changes to the same object). We <a id="id300" class="indexterm"/>will make each of the changes in the <code class="literal">EntryForm::labelTextChanged()</code> function a transaction, so add the following code to the <code class="literal">[UserlabelTextChanged_Pre]</code> section:</p><div class="informalexample"><pre class="programlisting">//[UserlabelTextChanged_Pre]
undoManager.beginNewTransaction();
//[/UserlabelTextChanged_Pre]</pre></div><p>Finally, execute the undo action in the <code class="literal">[UserButtonCode_undoButton]</code> section by adding the following code:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_undoButton] -- add your button handler..
undoManager.undo();
//[/UserButtonCode_undoButton]</pre></div><p>This line tells the <code class="literal">UndoManager</code> object to undo the last transaction. Adding redo support is just as straightforward. Build and run the application, and notice that you can now undo changes to the data entry form using the <span class="strong"><strong>Undo</strong></span> button. The <code class="literal">ValueTree</code> class also supports serialization and deserialization via binary or XML formats; this will be outlined in the next section.</p></div>
<div class="section" title="Adding XML support"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Adding XML support</h1></div></div></div><p>JUCE<a id="id301" class="indexterm"/> includes <a id="id302" class="indexterm"/>a range of support for XML parsing and storage. You may have noticed that the Introjucer application uses the XML format to store metadata at the end of some of the autogenerated files (for example, in our <code class="literal">EntryForm.cpp</code> file). In particular, a <code class="literal">ValueTree</code> object can be serialized into XML, and this same XML can be deserialized back into a <code class="literal">ValueTree</code> object (although you can't convert any arbitrary XML to a <code class="literal">ValueTree</code> object without doing some of your own parsing). To add opening and saving capabilities to our project, first we need to add an <span class="strong"><strong>Open…</strong></span> and a <span class="strong"><strong>Save…</strong></span> button in the Introjucer project. Give these the <span class="strong"><strong>name</strong></span> and <span class="strong"><strong>member name</strong></span>
<code class="literal">openButton</code> and <code class="literal">saveButton</code> respectively. Then, in the code we need to perform the conversions to and from XML. In the <code class="literal">[UserButtonCode_saveButton]</code> section add the following code to present the user with a file chooser and save the <code class="literal">ValueTree</code> object's data to an XML file:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_saveButton] -- add your button handler...
FileChooser chooser ("Save person data",
                     File::nonexistent,
                     "*.xml");

if (chooser.browseForFileToSave (true)) {
  File file (chooser.getResult());

  if (file.existsAsFile())
      file.moveToTrash();

  FileOutputStream stream (file);

  ScopedPointer&lt;XmlElement&gt; xml = personData.createXml();
  xml-&gt;writeToStream (stream, String::empty);
}
//[/UserButtonCode_saveButton]</pre></div><p>In the <code class="literal">[UserButtonCode_openButton]</code> section add<a id="id303" class="indexterm"/> the following code to read an XML file back in to the <code class="literal">ValueTree</code> object:</p><div class="informalexample"><pre class="programlisting">//[UserButtonCode_openButton] -- add your button handler...
FileChooser chooser ("Open person data",
                     File::nonexistent,
                     "*.xml");

if (chooser.browseForFileToOpen()) {
  Logger* log = Logger::getCurrentLogger();
  File file (chooser.getResult());

  XmlDocument xmlDoc (file);
  ScopedPointer&lt;XmlElement&gt; xml = xmlDoc.getDocumentElement();

  if (xml == nullptr) {
    log-&gt;writeToLog ("XML error");
    return;
  }

  ValueTree newPerson (ValueTree::fromXml (*xml));

  if (newPerson.getType() != personId) {
    log-&gt;writeToLog ("Invalid person XML");
    return;
  }

  undoManager.beginNewTransaction();
  personData.copyPropertiesFrom (newPerson, &amp;undoManager);

  ValueTree newAddress (newPerson.getChildWithName (addressId));
  ValueTree addressData (personData.getChildWithName (addressId));
  addressData.copyPropertiesFrom (newAddress, &amp;undoManager);
}
//[/UserButtonCode_openButton]</pre></div><p>Here we <a id="id304" class="indexterm"/>load the chosen file as an XML document, and access its document element. We perform two checks on the XML and report an error to the log if necessary:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We check if the XML element was accessed successfully (that is, did not return <code class="literal">nullptr</code>). If this fails the file may not be a valid XML file.</li><li class="listitem" style="list-style-type: disc">We load the XML into a <code class="literal">ValueTree</code> object then check the type of this <code class="literal">ValueTree</code> object to ensure it is the <code class="literal">person</code> data that we expect.</li></ul></div><p>Once the <a id="id305" class="indexterm"/>loaded <code class="literal">ValueTree</code> object is checked successfully, we copy the properties to the stored <code class="literal">ValueTree</code> object as a single <code class="literal">UndoManager</code> object transaction.</p><p>Build and run the application, and check that saving, opening, and all the undo behaviors work as expected. The following screenshot shows how the application window should appear:</p><div class="mediaobject"><img src="graphics/3316_05_02.jpg" alt="Adding XML support"/></div><p>The XML file<a id="id306" class="indexterm"/> produced by this code for the data shown in this screenshot will look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;person firstName="Joe" lastName="Bloggs" age="25"&gt;
  &lt;address line1="1 The Lines" line2="Loop" line3="Codeland"/&gt;
&lt;/person&gt;</pre></div><p>Of course, in a real-world application we would have <span class="strong"><strong>Open</strong></span>, <span class="strong"><strong>Save</strong></span>, and <span class="strong"><strong>Undo</strong></span> commands as menu bar items too (or instead), but we have used buttons here for simplicity. (Adding menu bar controls is covered at the end of this chapter.)</p><p>The <code class="literal">XmlDocument</code> and <code class="literal">XmlElement</code> classes shown here provide broad functionality for parsing and creating XML documents independent of <code class="literal">ValueTree</code> objects.</p></div>
<div class="section" title="Understanding how JUCE handles multiple threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Understanding how JUCE handles multiple threads</h1></div></div></div><p>JUCE includes a <a id="id307" class="indexterm"/>cross-platform interface to operating <a id="id308" class="indexterm"/>system threads using its <code class="literal">Thread</code> class. There are also classes that help with synchronizing inter-thread communication, notably the <code class="literal">CriticalSection</code> class, the <code class="literal">WaitableEvent</code> class, and the <code class="literal">Atomic</code> template classes (for example, <code class="literal">Atomic&lt;int&gt;</code>). Writing multithreaded applications is inherently challenging and it is beyond the scope of this book to serve as an introduction. However, JUCE does make the processes of writing multithreaded applications a little easier. One way in which this is achieved is through providing a consistent interface on all platforms. JUCE will also raise assertions if you do certain things that are likely to lead to some of the common problems (for example, deadlocks and race conditions). The following serves as a basic demonstration; we will create a simple thread that<a id="id309" class="indexterm"/> increments a counter and displays this counter in the GUI. Create a new Introjucer project called <code class="literal">Chapter05_03</code> with a basic window. Open the project in your IDE, and change the <code class="literal">MainComponent.h</code> file to contain the following:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component,
                             public Button::Listener,
                             public Thread
{
public:
  MainContentComponent();
  ~MainContentComponent();
  
  void resized();
  void buttonClicked (Button* button);
  void run();
  
private:
  TextButton startThreadButton;
  TextButton stopThreadButton;
  Label counterLabel;
  int counter;
};
#endif  // __MAINCOMPONENT_H__</pre></div><p>Notice that our class inherits from the <code class="literal">Thread</code> class that requires us to implement the <code class="literal">Thread::run()</code> pure <a id="id310" class="indexterm"/>virtual function (which serves as our thread's entry point). Now replace the code in the <code class="literal">MainComponent.cpp</code> file with the following:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
: Thread ("Counter Thread"),
  startThreadButton ("Start Thread"),
  stopThreadButton ("Stop Thread"),
  counter (0)
{
  addAndMakeVisible (&amp;startThreadButton);
  addAndMakeVisible (&amp;stopThreadButton);
  addAndMakeVisible (&amp;counterLabel);
  
  startThreadButton.addListener (this);
  stopThreadButton.addListener (this);
  
  setSize (500, 400);
}

MainContentComponent::~MainContentComponent()
{
  stopThread (3000);
}

void MainContentComponent::resized()
{
  startThreadButton.setBounds (10, 10, getWidth() - 20, 20);
  stopThreadButton.setBounds (10, 40, getWidth() - 20, 20);
  counterLabel.setBounds (10, 70, getWidth() - 20, 20);
}

void MainContentComponent::buttonClicked (Button* button)
{
  if (&amp;startThreadButton == button) 
    startThread();
  else if (&amp;stopThreadButton == button) 
    stopThread (3000);
}</pre></div><p>The main<a id="id311" class="indexterm"/> thing to notice here is that we must provide a name for our thread by passing a <code class="literal">String</code> object to the <code class="literal">Thread</code> class constructor. In the <code class="literal">buttonClicked()</code> function<a id="id312" class="indexterm"/> we start and stop our thread using the <span class="strong"><strong>Start Thread</strong></span> and <span class="strong"><strong>Stop Thread</strong></span> buttons, respectively. The value of <code class="literal">3000</code> passed to the <code class="literal">Thread::stopThread()</code> function<a id="id313" class="indexterm"/> is a timeout in milliseconds, after which the thread will be forcibly killed (which is unlikely to happen unless these is an error). We also need to implement the <code class="literal">Thread::run()</code> function<a id="id314" class="indexterm"/>, which is where the thread undertakes its work. This is where many of the problems occur. In particular you can't directly update GUI objects from<a id="id315" class="indexterm"/> anything other than the JUCE message thread. This message thread is the main thread on which your application's <code class="literal">initialise()</code> and <code class="literal">shutdown()</code> functions are called (so most of the construction and destruction of your application), where your GUI listener callbacks are called, mouse events are reported, and so on. Effectively, it is the "main" thread (and probably is the executable's main thread in many circumstances). This is why it has been safe to update GUI objects in response to user interactions with other GUI objects. Add the following code to the end of the <code class="literal">MainComponent.cpp</code> file. This should fail as soon as you click on the <span class="strong"><strong>Start Thread</strong></span> button:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::run()
{
  while (!threadShouldExit()) {
<span class="strong"><strong>    counterLabel.setText (String (counter++), </strong></span>
<span class="strong"><strong>                          dontSendNotification);</strong></span>
  }
}</pre></div><p>In a <span class="emphasis"><em>debug</em></span> build, <a id="id316" class="indexterm"/>your code should stop on an assertion. Looking at the JUCE code where the assertion was raised, there will be a comment that will tell you that this action can't be done unless you use a <code class="literal">MessageManagerLock</code> object. (In a <span class="emphasis"><em>release</em></span> build, it may simply crash or cause the application to behave strangely.) To use a <code class="literal">MessageManagerLock</code> object correctly, change the <code class="literal">run()</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::run()
{
  while (!threadShouldExit()) {
    const MessageManagerLock lock (Thread::getCurrentThread());
    
    if (lock.lockWasGained()) {
      counterLabel.setText (String (counter++),
                            dontSendNotification);
    }
  }
}</pre></div><p>Here we create a <code class="literal">MessageManagerLock</code> object, passing it a pointer to the current thread (that is, this thread). If the <code class="literal">MessageManagerLock::lockWasGained()</code> function returns <code class="literal">true</code>, it is safe to manipulate GUI objects. The thread releases the lock as the <code class="literal">MessageManagerLock</code> object goes out of scope (as we come round the <code class="literal">while()</code> loop again). This code also shows the typical structure of a <code class="literal">Thread::run()</code> function; that is, a <code class="literal">while()</code> loop that checks the result of calling the <code class="literal">Thread::threadShouldExit()</code> function and continues to loop unless the thread has been told to exit.</p></div>
<div class="section" title="Storing application properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Storing application properties</h1></div></div></div><p>In this <a id="id317" class="indexterm"/>final example we will implement a simple<a id="id318" class="indexterm"/> application that stores its state in a properties file (that is, settings or preferences) in a standard location on the runtime platform. First create a new Introjucer project named <code class="literal">Chapter05_04</code> with a basic window. Change the <code class="literal">MainComponent.h</code> file to contain the following code:</p><div class="informalexample"><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent   : public Component
{
public:
  MainContentComponent();
  ~MainContentComponent();
  
  void resized();
  
private:
  Label label;
  Slider slider;
  ApplicationProperties appProperties;
};

#endif  // __MAINCOMPONENT_H__</pre></div><p>Here we have a label and a slider; these will represent our simple application properties. Clearly, in a fully developed application, the properties would be presented in a separate window or panel, but the principle is the same.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>The <code class="literal">ApplicationProperties</code> class is a helper class that manages the application properties, saving them to the appropriate location on the user's system.</p></div></div><p>Change the contents of the <code class="literal">MainComponent.cpp</code> file to:</p><div class="informalexample"><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  label.setEditable(true);
  addAndMakeVisible(&amp;label);
  addAndMakeVisible(&amp;slider);
  
  setSize (500, 400);
  
  PropertiesFile::Options options;
  options.applicationName = ProjectInfo::projectName;
  options.folderName = ProjectInfo::projectName;
  options.filenameSuffix = "settings";
  options.osxLibrarySubFolder = "Application Support";
  appProperties.setStorageParameters (options);
  
  PropertiesFile* props = appProperties.getUserSettings();
  
  label.setText (props-&gt;getValue ("label", "&lt;empty&gt;"),
                 dontSendNotification);
  slider.setValue (props-&gt;getDoubleValue ("slider", 0.0));
}

MainContentComponent::~MainContentComponent()
{
  PropertiesFile* props = appProperties.getUserSettings();
  props-&gt;setValue ("label", label.getText());
  props-&gt;setValue ("slider", slider.getValue());
}

void MainContentComponent::resized()
{
  label.setBounds (10, 10, getWidth() - 20, 20);
  slider.setBounds (10, 40, getWidth() - 20, 20);
}</pre></div><p>Here <a id="id319" class="indexterm"/>we<a id="id320" class="indexterm"/> configure the <code class="literal">ApplicationProperties</code> object by passing it our desired application name and folder name (using the name that the Introjucer application will have generated in the <code class="literal">ProjectInfo::projectName</code> constant). We provide a filename suffix (for example, <code class="literal">settings</code>, <code class="literal">xml</code>). To support Mac OS X, it is recommended that you set the <code class="literal">PropertiesFile::Options::osxLibrarySubFolder</code> option since Apple changed their recommendation for the storage of application preferences. This was previously in <code class="literal">Library/Preferences</code>, but Apple now recommends that developers use <code class="literal">Library/Application Support</code>. This is provided for backwards compatibility; all new applications should set this to <code class="literal">Application Support</code>. This setting is harmless for other platforms. It is important to configure these options prior to using the <code class="literal">ApplicationProperties</code> object by passing the options via the <code class="literal">ApplicationProperties::setStorageParameters()</code> function<a id="id321" class="indexterm"/>. In fact, the <code class="literal">ApplicatonProperties</code> class maintains two sets of properties, one for all users and one for the current user. In this example we create only properties for the current user.</p><p>When the application<a id="id322" class="indexterm"/> starts, it tries to access the value of the properties and set the label and slider appropriately. First, we access the user settings <code class="literal">PropertiesFile</code> object using the <code class="literal">ApplicationProperties::getUserSettings()</code> function<a id="id323" class="indexterm"/>. We store a pointer to the <code class="literal">PropertiesFile</code> object that this returns in a regular pointer, as it is owned by <code class="literal">ApplicationProperties</code> object, and we need it only temporarily. (Storing it in a <code class="literal">ScopedPointer</code> object in this case could cause a crash, since the <code class="literal">ScopedPointer</code> object would try eventually to delete an object that it should not really own, since it already has an owner.) Then<a id="id324" class="indexterm"/> we use the <code class="literal">PropertiesFile::getValue()</code> function<a id="id325" class="indexterm"/> to get the text value, and the <code class="literal">PropertiesFile::getDoubleValue()</code> function<a id="id326" class="indexterm"/> to get the double value (there are also the <code class="literal">PropertiesFile::getIntValue()</code>
<a id="id327" class="indexterm"/> and <code class="literal">PropertiesFile::getBoolValue()</code> functions<a id="id328" class="indexterm"/> if needed). Of course, the first time the application starts, these properties will be empty. Each of these property accessors allows you to provide a default value, should the named property not exist. Here we provide <code class="literal">&lt;empty&gt;</code> as the default for the label contents and <code class="literal">0.0</code> as the default for the slider. When the application closes (in this case we know this is happening when the <code class="literal">MainContentComponent</code>  destructor is called) we set the value of the properties to the current state of the label and the slider. This means that when we close the application and reopen it, the slider and the label should appear to retain their state between launches. Build and run the application and test this. The file generated by the <code class="literal">ApplicationProperties</code> object should look something as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;PROPERTIES&gt;
  &lt;VALUE name="label" val="hello"/&gt;
  &lt;VALUE name="slider" val="1.62303665"/&gt;
&lt;/PROPERTIES&gt;</pre></div><p>On Mac OS X this should be in:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong/></span>
<span class="strong"><strong>~/Library/Application Support/Chapter05_04</strong></span>
</pre></div><p>On Windows this should be in:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\\Documents and Settings\USERNAME\Application Data\Chapter05_04</strong></span>
</pre></div><p>where <code class="literal">USERNAME</code> is the name of the currently logged-in user.</p></div>
<div class="section" title="Adding menu bar controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Adding menu bar controls</h1></div></div></div><p>JUCE offers<a id="id329" class="indexterm"/> a means of creating menu bar user interface <a id="id330" class="indexterm"/>controls, as you will have seen, using the Introjucer application, and in the JUCE Demo application in <a class="link" href="ch01.html" title="Chapter 1. Installing JUCE and the Introjucer Application">Chapter 1</a>, <span class="emphasis"><em>Installing JUCE and the Introjucer Application</em></span>. These menu bars may be within a window on all platforms using JUCE's own <code class="literal">MenuBarComponent</code> class, or as a native menu bar at the top of the screen on Mac OS X. To demonstrate this we will add some special commands to the <code class="literal">Chapter05_04</code> project to reset the label and slider in various ways.</p><p>The first requirement for constructing menu bars in JUCE is to create a <span class="strong"><strong>menu bar model</strong></span>
<a id="id331" class="indexterm"/> by creating a subclass of the <code class="literal">MenuBarModel</code> class. First add the <code class="literal">MenuBarModel</code> class as a base class for the <code class="literal">MainContentComponent</code> class in the <code class="literal">MainComponent.h</code> file as highlighted in the following:</p><div class="informalexample"><pre class="programlisting">...
class MainContentComponent   : public Component<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>                               public MenuBarModel</strong></span>
{
...</pre></div><p>The <code class="literal">MenuBarModel</code> class has three pure virtual functions that will be used to populate the menu bar. To add these, add the following three lines to the <code class="literal">public</code> section of the <code class="literal">MainComponent.h</code> file:</p><div class="informalexample"><pre class="programlisting">StringArray getMenuBarNames();
PopupMenu getMenuForIndex (int index, const String&amp; name);
void menuItemSelected (int menuID, int index);</pre></div><p>The <a id="id332" class="indexterm"/>
<code class="literal">getMenuBarNames()</code> function <a id="id333" class="indexterm"/>should return an array of menu names that will appear along the menu bar. The <code class="literal">getMenuForIndex()</code> function<a id="id334" class="indexterm"/> is used to create the actual menu when the user clicks on one of the menu bar names. This should return a <code class="literal">PopupMenu</code> object for a given menu (which can be determined using the menu index or its name). Each menu item should be given a unique ID value that is used to identify the menu item when it is selected. This is described in a moment. The <code class="literal">menuItemSelected()</code> function<a id="id335" class="indexterm"/> will be called when a user selects a particular menu item from one of the menus. Here you are provided with the ID value of the menu item that was selected (and the index of the menu that this menu item was in, if you really need this information). For convenience we should add these IDs as enumerated constants. Add the following code to the end of the <code class="literal">public</code> section of the <code class="literal">MainComponent.h</code> file:</p><div class="informalexample"><pre class="programlisting">...
  enum MenuIDs {
    LabelClear = 1000,
    SliderMin,
    SliderMax
  };
...</pre></div><p>Notice that the first item is given a value of <code class="literal">1000</code>; this is because an ID value of <code class="literal">0</code> (which is otherwise the default) is not valid as an ID. We need to store the <code class="literal">MenuBarComponent</code> object too. Add the code as highlighted below:</p><div class="informalexample"><pre class="programlisting">...
private:
  Label label;
  Slider slider;
<span class="strong"><strong>  MenuBarComponent menuBar;</strong></span>
  ApplicationProperties appProperties;
};</pre></div><p>In the <code class="literal">MainComponent.cpp</code> file, update<a id="id336" class="indexterm"/> the constructor for the <code class="literal">MainContentComponent</code> class as highlighted in the following:</p><div class="informalexample"><pre class="programlisting">...
MainContentComponent::MainContentComponent()
<span class="strong"><strong>: menuBar (this)</strong></span>
{
<span class="strong"><strong>  addAndMakeVisible (&amp;menuBar);</strong></span>
  label.setEditable (true);
...
</pre></div><p>Here we <a id="id337" class="indexterm"/>pass the <code class="literal">this</code> pointer to the <code class="literal">MenuBarComponent</code> object in the initializer list. This is to tell the <code class="literal">MenuBarComponent</code> object which <code class="literal">MenuBarModel</code> to use. Update the <code class="literal">resized()</code> function in the <code class="literal">MainComponent.cpp</code> file to position the components as follows:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::resized()
{
<span class="strong"><strong>  menuBar.setBounds (0, 0, getWidth(), 20);</strong></span>
  label.setBounds (10, <span class="strong"><strong>30</strong></span>, getWidth() - 20, 20);
  slider.setBounds (10, <span class="strong"><strong>60</strong></span>, getWidth() - 20, 20);
}</pre></div><p>This positions the menu bar at the top of the window, filling the whole width of the window. Now we will add the menu bar functionality by implementing the virtual functions from the <code class="literal">MenuBarModel</code> class. Add the following code to the <code class="literal">MainComponent.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">StringArray MainContentComponent::getMenuBarNames()
{
  const char* menuNames[] = { "Label", "Slider", 0 };
  return StringArray (menuNames);
}</pre></div><p>This creates the top-level menu names by returning a <code class="literal">StringArray</code> object containing the names. Here we will have two menus, one to control the label, and the other to control the slider. Next, add the following code to the <code class="literal">MainComponent.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">PopupMenu MainContentComponent::getMenuForIndex 
  (int index, const String&amp; name)
{
  PopupMenu menu;
  
  if (name == "Label")
  {
    menu.addItem (LabelClear, "Clear");
  } else if (name == "Slider") {
    menu.addItem (SliderMin, "Set to minimum");
    menu.addItem (SliderMax, "Set to maximum");
  }
  
  return menu;
}</pre></div><p>This checks <a id="id338" class="indexterm"/>which menu should be populated by inspecting the menu name. The <span class="strong"><strong>Label</strong></span> menu will be <a id="id339" class="indexterm"/>filled with a single item that will be used to clear the label contents. The <span class="strong"><strong>Slider</strong></span> menu will be filled with two items: one to set the slider to its minimum value, and one to set the slider to its maximum value. Notice that this is one place where we use the enumerated constants created earlier. Finally, add the following code to the <code class="literal">MainComponent.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void MainContentComponent::menuItemSelected (int menuID, 
                                             int index)
{
  switch (menuID) {
    case LabelClear:
      label.setText (String::empty, dontSendNotification);
      break;
    case SliderMin:
      slider.setValue (slider.getMinimum());
      break;
    case SliderMax:
      slider.setValue (slider.getMaximum());
      break;
  }
}</pre></div><p>Here we check which menu ID was selected by the user and act accordingly. Build and run the application to check this functionality. An additional example project <code class="literal">Chapter05_04b</code> is provided in the<a id="id340" class="indexterm"/> code bundle that illustrates how to modify this example to use the native menu bar on the Mac OS X platform. A more sophisticated technique for implementing menu bars is to use the JUCE <code class="literal">ApplicationCommandManager</code> class, which is used by the JUCE Demo application and the Introjucer application code to present its menus, issue commands from buttons, and so on. Refer to the JUCE documentation for this class for a complete guide.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>This chapter has introduced a range of additional useful utilities for application development in JUCE. This included using the <code class="literal">ValueTree</code> class and related classes for structuring and storing application data and properties, and adding undo management. This chapter also looked at multithreading support in JUCE, and introduced one final user interface component for adding menu bar controls to JUCE applications. These really are the tip of the iceberg. It is rare to find a JUCE class that is difficult to integrate into your own code. You are encouraged to explore the JUCE documentation to find further classes that will support your development. The JUCE code and classes introduced in this book should have given you an insight into the idioms of JUCE code. This should make discovering and using new JUCE classes relatively straightforward.</p></div></body></html>