<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Steps in Writing a Frontend</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Defining a TOY language</li><li class="listitem">Implementing a lexer</li><li class="listitem">Defining Abstract Syntax Tree</li><li class="listitem">Implementing a parser</li><li class="listitem">Parsing simple expressions</li><li class="listitem">Parsing binary expressions</li><li class="listitem">Invoking a driver for parsing</li><li class="listitem">Running lexer and parser on our TOY language</li><li class="listitem">Defining IR code generation methods for each AST class</li><li class="listitem">Generating IR code for expressions</li><li class="listitem">Generating IR code for functions</li><li class="listitem">Adding IR optimization support</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Introduction</h1></div></div></div><p>In this chapter, you will get to know about how to write a frontend for a language. By making use of a custom-defined TOY language, you will have recipes on how to write a lexer and a parser, and how to generate IR <a id="id67" class="indexterm"/>code from the <strong>Abstract Syntax Tree</strong> (<strong>AST</strong>) generated by the frontend.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Defining a TOY language</h1></div></div></div><p>Before<a id="id68" class="indexterm"/> implementing a lexer and parser, the syntax and grammar of the language need to be determined first. In this chapter, a TOY language is used to demonstrate how a lexer and a parser can be implemented. The purpose of this recipe is to show how a language is skimmed through. For this purpose, the TOY language to be used is simple but meaningful.</p><p>A language typically has some variables, some function calls, some constants, and so on. To keep things simple, our TOY language in consideration has only numeric constants of 32-bit Integer type A, a variable<a id="id69" class="indexterm"/> that need not declare its type (like Python, in contrast to C/C++/Java, which require a type declaration) in the TOY language.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How to do it…</h2></div></div></div><p>The grammar can be defined as follows (the production rules are defined below, with non-terminals <a id="id70" class="indexterm"/>on <strong>Left Hand Side</strong> (<strong>LHS</strong>) and a combination of terminals and non-terminals<a id="id71" class="indexterm"/> on <strong>Right Hand Side</strong> (<strong>RHS</strong>); when LHS is encountered, it yields appropriate RHS defined in the production rule):</p><div><ol class="orderedlist arabic"><li class="listitem">A numeric expression will give a constant number:<div><pre class="programlisting">numeric_expr := number</pre></div></li><li class="listitem">A parenthesis expression will have an expression in between an opening and a closing bracket:<div><pre class="programlisting">paran_expr := '(' expression ')'</pre></div></li><li class="listitem">An identifier expression will either yield an identifier or a function call:<div><pre class="programlisting">identifier_expr
:= identifier
:= identifier '('expr_list ')'</pre></div></li><li class="listitem">If identifier <code class="literal">_expr</code> is a function call, it will either have no arguments or list of arguments separated by a comma:<div><pre class="programlisting">expr_list
:= (empty)
:= expression (',' expression)*</pre></div></li><li class="listitem">There will be some primary expression, the starting point of the grammar, which may yield an identifier expression, a numeric expression, or a parenthesis expression:<div><pre class="programlisting">primary := identifier_expr
:=numeric_expr
:=paran_expr</pre></div></li><li class="listitem">An expression can lead to a binary expression:<div><pre class="programlisting">expression := primary binoprhs</pre></div></li><li class="listitem">A binary operation with RHS can yield combinations of binary operators and expressions:<div><pre class="programlisting">binoprhs := ( binoperator primary )*
binoperators := '+'/'-'/'*'/'/'</pre></div></li><li class="listitem">A function declaration can have grammar as follows:<div><pre class="programlisting">func_decl := identifier '(' identifier_list ')'
identifier_list := (empty)
                        := (identifier)*</pre></div></li><li class="listitem">A function definition is distinguished by a <code class="literal">def</code> keyword followed by a function declaration and an expression that defines its body:<div><pre class="programlisting">function_defn := 'def' func_decl expression</pre></div></li><li class="listitem">Finally, there will be a top level expression that will yield an expression:<div><pre class="programlisting">toplevel_expr := expression  </pre></div></li></ol><div></div><p>An example of the <a id="id72" class="indexterm"/>TOY language based on the previously defined grammar can be written as follows:</p><div><pre class="programlisting">def foo (x , y)
x +y * 16</pre></div><p>Since we have defined the grammar, the next step is to write a lexer and parser for it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Implementing a lexer</h1></div></div></div><p>Lexer is a part of the<a id="id73" class="indexterm"/> first phase in compiling a program. Lexer tokenizes a stream of input in a program. Then parser consumes these tokens to construct an AST. The language to tokenize is generally a context-free language. A token is a string of one or <a id="id74" class="indexterm"/>more characters that are significant as a group. The process of forming tokens from an input stream of characters is called tokenization. Certain delimiters are used to identify groups of words as tokens. There are lexer tools to automate lexical analysis, such as <strong>LEX</strong>. In the TOY lexer demonstrated in the following procedure is a handwritten lexer using C++.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec60"/>Getting ready</h2></div></div></div><p>We must have a basic understanding of the TOY language defined in the recipe. Create a file named <code class="literal">toy.cpp</code> as follows:</p><div><pre class="programlisting">$ vim toy.cpp</pre></div><p>All the code that follows will contain all the lexer, parser, and code generation logic.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec61"/>How to do it…</h2></div></div></div><p>While implementing a lexer, types of tokens are defined to categorize streams of input strings (similar to states of an automata). This can be done<a id="id75" class="indexterm"/> using the <strong>enumeration</strong> (<strong>enum</strong>) type:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vim toy.cpp</pre></div></li><li class="listitem">Write the <code class="literal">enum</code> in the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">enum Token_Type {
EOF_TOKEN = 0,
NUMERIC_TOKEN,
IDENTIFIER_TOKEN,
PARAN_TOKEN,
DEF_TOKEN
};</pre></div><p>Following is the term<a id="id76" class="indexterm"/> list for the preceding example:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">EOF_TOKEN</code>: It states the end of file</li><li class="listitem"><code class="literal">NUMERIC_TOKEN:</code> The current token is of numeric type</li><li class="listitem"><code class="literal">IDENTIFIER_TOKEN:</code> The current token is identifier</li><li class="listitem"><code class="literal">PARAN_TOKEN:</code> The current token is parenthesis</li><li class="listitem"><code class="literal">DEF_TOKEN</code>: The current token <code class="literal">def</code> states that whatever follows is a function definition</li></ul></div></li><li class="listitem">To hold numeric values, a static variable is defined in the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">static int Numeric_Val;</pre></div></li><li class="listitem">To hold the <code class="literal">Identifier</code> string name, a static variable can be defined in the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">    static std::string Identifier_string;</pre></div></li><li class="listitem">Now the lexer function can be defined by using library functions such as <code class="literal">isspace()</code>, <code class="literal">isalpha()</code>, and <code class="literal">fgetc()</code> in the <code class="literal">toy.cpp</code> file, as shown in the following:<div><pre class="programlisting">static int get_token() {
  static int LastChar = ' ';
  
  while(isspace(LastChar))
  LastChar = fgetc(file);
  
  if(isalpha(LastChar)) {
    Identifier_string = LastChar;
    while(isalnum((LastChar = fgetc(file))))
    Identifier_string += LastChar;
    
    if(Identifier_string == "def")
    return DEF_TOKEN;
    return IDENTIFIER_TOKEN;
  }
  
  if(isdigit(LastChar)) {
    std::string NumStr;
    do {
      NumStr += LastChar;
      LastChar = fgetc(file);
    } while(isdigit(LastChar));
    
    Numeric_Val = strtod(NumStr.c_str(), 0);
    return NUMERIC_TOKEN;
  }
  
  if(LastChar == '#') {
    do LastChar = fgetc(file);
    while(LastChar != EOF &amp;&amp; LastChar != '\n'
    &amp;&amp; LastChar != '\r');
    
    if(LastChar != EOF) return get_token();
  }
  
  if(LastChar == EOF) return EOF_TOKEN;
  
  int ThisChar = LastChar;
  LastChar = fgetc(file);
  return ThisChar;
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How it works…</h2></div></div></div><p>The example TOY language defined earlier was as follows:</p><div><pre class="programlisting">def foo (x , y)
x + y * 16</pre></div><p>The lexer will get the <a id="id77" class="indexterm"/>preceding program as input. It will come across the <code class="literal">def</code> keyword and determine that whatever follows is a definition token, and hence returns the enum value <code class="literal">DEF_TOKEN</code>. After this, it will come across the function definition and its arguments. Then, there is an expression that involves two binary operators, two variables, and a numeric constant. How these are stored in data structures is demonstrated in<a id="id78" class="indexterm"/> the following recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec63"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">See more sophisticated and detailed handwritten lexer for the C++ language is written in Clang, at<a id="id79" class="indexterm"/> <a class="ulink" href="http://clang.llvm.org/doxygen/Lexer_8cpp_source.html">http://clang.llvm.org/doxygen/Lexer_8cpp_source.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Defining Abstract Syntax Tree</h1></div></div></div><p>AST is a tree representation of the abstract syntactic structure of the source code of a programming language. The ASTs of programming constructs, such as expressions, flow control statements, and so on, are grouped into operators and operands. ASTs represent relationships between programming constructs, and not the ways they are generated by grammar. ASTs ignore unimportant programming elements such as punctuations and delimiters. ASTs generally contain additional properties of every element in it, which are useful in further compilation phases. Location of source code is one such property, which can be used to throw an error line number if an<a id="id80" class="indexterm"/> error is encountered in determining the correctness of the source code in accordance with the grammar (location, line number, column number, and so on, and other related properties are stored in an object of the <code class="literal">SourceManager</code> class in Clang frontend for C++).</p><p>The AST is used intensively <a id="id81" class="indexterm"/>during semantic analysis, where the compiler checks for correct usage of the elements of the program and the language. The compiler also generates symbol tables based on the AST during semantic analysis. A complete traversal of the tree allows verification of the correctness of the program. After verifying correctness, the AST serves as the base for code generation.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec64"/>Getting ready</h2></div></div></div><p>We must have run the lexer by now to obtain the tokens that will be used in generating the AST. The languages we intend to parse consist of expressions, function definitions, and function declarations. Again we have various types of expressions—variables, binary operators, numeric expressions, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec65"/>How to do it…</h2></div></div></div><p>To define AST structure, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div><p>Below the lexer code, define ASTs.</p></li><li class="listitem"> A <code class="literal">base</code> class is defined for parsing an expression as follows:<div><pre class="programlisting">class BaseAST {
  public :
  virtual ~BaseAST();
};</pre></div><p>Then, several derived classes are defined for every type of expression to be parsed.</p></li><li class="listitem">An AST class for<a id="id82" class="indexterm"/> variable expressions is defined as follows:<div><pre class="programlisting">class VariableAST  : public BaseAST{
  std::string Var_Name;  
// string object to store name of
// the variable.
  public:
  VariableAST (std::string &amp;name) : Var_Name(name) {}  // ..// parameterized constructor of variable AST class to be initialized with the string passed to the constructor.
};</pre></div></li><li class="listitem">The language has some numeric expressions. The <code class="literal">AST</code> class for such numeric expressions can be defined as follows:<div><pre class="programlisting">class NumericAST : public BaseAST {
  int numeric_val;
  public :
  NumericAST (intval) :numeric_val(val)  {}
};</pre></div></li><li class="listitem">For expressions involving binary operation, the <code class="literal">AST</code> class can be defined as follows:<div><pre class="programlisting">Class BinaryAST : public BaseAST {
  std::string Bin_Operator;  // string object to store
  // binary operator
  BaseAST  *LHS, *RHS;  // Objects used to store LHS and   
// RHS of a binary Expression. The LHS and RHS binary   
// operation can be of any type, hence a BaseAST object 
// is used to store them.
  public:
  BinaryAST (std::string op, BaseAST *lhs, BaseAST *rhs ) :
  Bin_Operator(op), LHS(lhs), RHS(rhs) {}  // Constructor
  //to initialize binary operator, lhs and rhs of the binary
  //expression.
};</pre></div></li><li class="listitem">The <code class="literal">AST</code> class for function declaration can be defined as follows:<div><pre class="programlisting">class FunctionDeclAST {
  std::string Func_Name;
  std::vector&lt;std::string&gt; Arguments;
  public:
  FunctionDeclAST(const std::string &amp;name, const       std::vector&lt;std::string&gt; &amp;args) :
  Func_Name(name), Arguments(args) {};
};</pre></div></li><li class="listitem">The <code class="literal">AST</code> class for function definition can be defined as follows:<div><pre class="programlisting">class FunctionDefnAST {
  FunctionDeclAST *Func_Decl;
  BaseAST* Body;
  public:
  FunctionDefnAST(FunctionDeclAST *proto, BaseAST *body) :
  Func_Decl(proto), Body(body) {}
};</pre></div></li><li class="listitem">The <code class="literal">AST</code> class for<a id="id83" class="indexterm"/> function call can be defined as follows:<div><pre class="programlisting">class FunctionCallAST : public BaseAST {
  std::string Function_Callee;
  std::vector&lt;BaseAST*&gt; Function_Arguments;
  public:
  FunctionCallAST(const std::string &amp;callee, std::vector&lt;BaseAST*&gt; &amp;args) :
  Function_Callee(callee), Function_Arguments(args) {}
};</pre></div></li></ol><div></div><p>The basic skeleton of the AST is now ready to use.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How it works…</h2></div></div></div><p>The AST acts as a data structure for storing various information about the tokens given by the lexer. This information is generated in the parser logic and ASTs are filled up according to the type of token being parsed.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec67"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Having generated the AST, we will implement the parser, and only after that will we see an example where both lexer and parser will be invoked. For a more detailed <a id="id84" class="indexterm"/>AST structure of C++ in Clang, refer to: <a class="ulink" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Implementing a parser</h1></div></div></div><p>Parser analyzes a code syntactically according to the rules of the language's grammar. The parsing phase determines if the input code can be used to form a string of tokens according to the defined grammar. A parse tree is constructed in this phase. Parser defines functions to organize language<a id="id85" class="indexterm"/> into a data structure called AST. The parser defined in this recipe uses a recursive decent parser technique which is a top-down parser, and uses mutually recursive functions to build the AST.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec68"/>Getting ready</h2></div></div></div><p>We must have the <a id="id86" class="indexterm"/>custom-defined language, that is the TOY language in this case, and also a stream of tokens generated by the lexer.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How to do it…</h2></div></div></div><p>Define some basic value holders in our TOY parser as shown in the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div></li><li class="listitem">Define a global static variable to hold the current token from the lexer as follows:<div><pre class="programlisting">static int Current_token;</pre></div></li><li class="listitem">Define a function to get the next token from the input stream from the lexer as follows:<div><pre class="programlisting">static void next_token() {
  Current_token =  get_token();
}</pre></div></li><li class="listitem">The next step is to define functions for expression parsing by using the AST data structure defined in the previous section.</li><li class="listitem">Define a generic function to call specific parsing functions according to the types of tokens determined by the lexer, as shown in the following:<div><pre class="programlisting">static BaseAST* Base_Parser() {
  switch (Current_token) {
    default: return 0;
    case IDENTIFIER_TOKEN : return identifier_parser();
    case NUMERIC_TOKEN : return numeric_parser();
    case '(' : return paran_parser();
  }
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How it works…</h2></div></div></div><p>The stream of input is tokenized and fed to the parser. <code class="literal">Current_token</code> holds the token to be processed. The type <a id="id87" class="indexterm"/>of token is known at this stage and the corresponding parser functions are called to initialize ASTs.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec71"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">In next few recipes, you will learn how to parse different expressions. For more detailed <a id="id88" class="indexterm"/>parsing of the C++ language implemented in Clang, refer to it works: <a class="ulink" href="http://clang.llvm.org/doxygen/classclang_1_1Parser.html">http://clang.llvm.org/doxygen/classclang_1_1Parser.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Parsing simple expressions</h1></div></div></div><p>In this recipe, you will learn how to parse a simple expression. A simple expression may consist of numeric <a id="id89" class="indexterm"/>values, identifiers, function calls, a function declaration, and function definitions. For each type of expression, individual parser logic needs to be defined.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec72"/>Getting ready</h2></div></div></div><p>We must have the custom-defined language—that is, the TOY language in this case—and also stream of tokens generated by lexer. We already defined ASTs above. Further, we are going to parse the expression and invoke AST constructors for every type of expression.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How to do it…</h2></div></div></div><p>To parse simple expressions, proceed with the following code flow:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div><p>We already have lexer logic present in the <code class="literal">toy.cpp</code> file. Whatever code follows needs to be appended after the lexer code in the <code class="literal">toy.cpp</code> file.</p></li><li class="listitem">Define the <code class="literal">parser</code> function for numeric expression as follows:<div><pre class="programlisting">static BaseAST *numeric_parser() {
  BaseAST *Result = new NumericAST(Numeric_Val);
  next_token();
  return Result;
}</pre></div></li><li class="listitem">Define the <code class="literal">parser</code> function for an identifier expression. Note that identifier can be a variable reference or a function call. They are distinguished by checking if the<a id="id90" class="indexterm"/> next token is <code class="literal">(</code>. This is implemented as follows:<div><pre class="programlisting">static BaseAST* identifier_parser() {
  std::string IdName = Identifier_string;
  
  next_token();
  
  if(Current_token != '(')
  return new VariableAST(IdName);
  
  next_token();
  
  std::vector&lt;BaseAST*&gt; Args;
  if(Current_token != ')') {
    while(1) {
      BaseAST* Arg = expression_parser();
      if(!Arg) return 0;
      Args.push_back(Arg);
      
      if(Current_token == ')') break;
      
      if(Current_token != ',')
      return 0;
      next_token();
    }
  }
  next_token();
  
  return new FunctionCallAST(IdName, Args);
}</pre></div></li><li class="listitem">Define the <code class="literal">parser</code> function for the function declaration as follows:<div><pre class="programlisting">static FunctionDeclAST *func_decl_parser() {
  if(Current_token != IDENTIFIER_TOKEN)
  return 0;
  
  std::string FnName = Identifier_string;
  next_token();
  
  if(Current_token != '(')
  return 0;
  
  std::vector&lt;std::string&gt; Function_Argument_Names;
  while(next_token() == IDENTIFIER_TOKEN)
  Function_Argument_Names.push_back(Identifier_string);
  if(Current_token != ')')
  return 0;
  
  next_token();
  
  return new FunctionDeclAST(FnName, Function_Argument_Names);
}</pre></div></li><li class="listitem">Define the <code class="literal">parser</code> function<a id="id91" class="indexterm"/> for the function definition as follows:<div><pre class="programlisting">static FunctionDefnAST *func_defn_parser() {
  next_token();
  FunctionDeclAST *Decl = func_decl_parser();
  if(Decl == 0) return 0;
  
  if(BaseAST* Body = expression_parser())
  return new FunctionDefnAST(Decl, Body);
  return 0;
}</pre></div><p>Note that the function called <code class="literal">expression_parser</code>  used in the preceding code, parses the expression. The function can be defined as follows:</p><div><pre class="programlisting">static BaseAST* expression_parser() {
  BaseAST *LHS = Base_Parser();
  if(!LHS) return 0;
  return binary_op_parser(0, LHS);
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How it works…</h2></div></div></div><p>If a numeric token is encountered, the constructor for the numeric expression is invoked and the AST object for the numeric value is returned by the parser, filling up the AST for numeric values with the numeric data.</p><p>Similarly, for identifier expressions, the parsed data will either be a variable or a function call. For function declaration and definitions, the name of the function and function arguments is parsed and the corresponding AST class constructors are invoked.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Parsing binary expressions</h1></div></div></div><p>In this recipe, you will learn <a id="id92" class="indexterm"/>how to parse a binary expression.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec75"/>Getting ready</h2></div></div></div><p>We must have the custom-defined language—that is, the toy language in this case—and also stream of tokens generated by lexer. The binary expression parser requires precedence of binary operators for determining LHS and RHS in order. An STL map can be used to define precedence of binary operators.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How to do it…</h2></div></div></div><p>To parse a binary expression, proceed with the following code flow:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div></li><li class="listitem">Declare a <code class="literal">map</code> for operator precedence to store the precedence at global scope in the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">static std::map&lt;char, int&gt;Operator_Precedence;</pre></div><p>The TOY language for demonstration has 4 operators where precedence of operators is defined as <code class="literal">-</code>&lt; <code class="literal">+</code> &lt; <code class="literal">/</code> &lt; <code class="literal">*</code>.</p></li><li class="listitem">A function to initialize precedence—that is, to store precedence value in <code class="literal">map</code>—can be defined in global scope in the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">static void init_precedence() {
  Operator_Precedence['-'] = 1;
  Operator_Precedence['+'] = 2;
  Operator_Precedence['/'] = 3;
  Operator_Precedence['*'] = 4;
}</pre></div></li><li class="listitem">A helper function to return precedence of binary operator can be defined as follows:<div><pre class="programlisting">static int getBinOpPrecedence() {
  if(!isascii(Current_token))
return -1;
  
  int TokPrec = Operator_Precedence[Current_token];
  if(TokPrec &lt;= 0) return -1;
  return TokPrec;
}</pre></div></li><li class="listitem">Now, the <code class="literal">binary</code> operator parser can be defined as follows:<div><pre class="programlisting">static BaseAST* binary_op_parser(int Old_Prec, BaseAST *LHS) {
  while(1) {
    int Operator_Prec = getBinOpPrecedence();
    
    if(Operator_Prec &lt; Old_Prec)
    return LHS;
    
    int BinOp = Current_token;
    next_token();
    
    BaseAST* RHS = Base_Parser();
    if(!RHS) return 0;
    
    int Next_Prec = getBinOpPrecedence();
    if(Operator_Prec &lt; Next_Prec) {
      RHS = binary_op_parser(Operator_Prec+1, RHS);
      if(RHS == 0) return 0;
    }
    
    LHS = new BinaryAST(std::to_string(BinOp), LHS, RHS);
  }
}</pre></div><p>Here, precedence of <a id="id93" class="indexterm"/>current operator is checked with the precedence of old operator, and the outcome is decided according to LHS and RHS of binary operators. Note that the binary operator parser is recursively called since the RHS can be an expression and not just a single identifier.</p></li><li class="listitem">A <code class="literal">parser</code> function for parenthesis can be defined as follows:<div><pre class="programlisting">static BaseAST* paran_parser() {
  next_token();
  BaseAST* V = expression_parser();
  if (!V) return 0;
  
  if(Current_token != ')')
    return 0;
  return V;
}</pre></div></li><li class="listitem">Some top-level functions acting as wrappers around these <code class="literal">parser</code> functions can be defined as follows:<div><pre class="programlisting">static void HandleDefn() {
  if (FunctionDefnAST *F = func_defn_parser()) {
    if(Function* LF = F-&gt;Codegen()) {
  }
  }
  else {
    next_token();
  }
}

static void HandleTopExpression() {
  if(FunctionDefnAST *F = top_level_parser()) {
    if(Function *LF = F-&gt;Codegen()) {
  }
  }
  else {
    next_token();
  }
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec77"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">All of the remaining recipes in this <a id="id94" class="indexterm"/>chapter pertain to user objects. For detailed parsing of expressions, and for C++ parsing, please<a id="id95" class="indexterm"/> refer to: <a class="ulink" href="http://clang.llvm.org/doxygen/classclang_1_1Parser.html">http://clang.llvm.org/doxygen/classclang_1_1Parser.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Invoking a driver for parsing</h1></div></div></div><p>In this recipe, you will learn how to call the parser function from the main function of our TOY parser.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec78"/>How to do it…</h2></div></div></div><p>To invoke a driver program to start parsing, define the driver function as shown in the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file:<div><pre class="programlisting">$ vi toy.cpp</pre></div></li><li class="listitem">A <code class="literal">Driver</code> function called from the main function, and a parser can now be defined as follows:<div><pre class="programlisting">static void Driver() {
  while(1) {
    switch(Current_token) {
    case EOF_TOKEN : return;
    case ';' : next_token(); break;
    case DEF_TOKEN : HandleDefn(); break;
    default : HandleTopExpression(); break;
  }
  }
}</pre></div></li><li class="listitem">The <code class="literal">main()</code> function to run the whole program can be defined as follows:<div><pre class="programlisting">int main(int argc, char* argv[]) {
  LLVMContext &amp;Context = getGlobalContext();
  init_precedence();
  file = fopen(argv[1], "r");
  if(file == 0) {
    printf("Could not open file\n");
  }
  next_token();
  Module_Ob = new Module("my compiler", Context);
  Driver();
  Module_Ob-&gt;dump();
      return 0;
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How it works…</h2></div></div></div><p>The main function is responsible for calling the lexer and parser so that both can act over a piece of code that is being input to the compiler frontend. From the main function, driver function is invoked to start the process of parsing.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec80"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For details<a id="id96" class="indexterm"/> on how the main function and driver function work for c++ parsing in Clang, refer to <a class="ulink" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp">http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Running lexer and parser on our TOY language</h1></div></div></div><p>Now that<a id="id97" class="indexterm"/> a full-fledged lexer and parser for our TOY language grammar <a id="id98" class="indexterm"/>are defined, it's time to run it on<a id="id99" class="indexterm"/> example TOY language.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec81"/>Getting ready</h2></div></div></div><p>To do this, you should have understanding of TOY language grammar and all the previous recipes of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec82"/>How to do it…</h2></div></div></div><p>Run and test the<a id="id100" class="indexterm"/> Lexer and Parser on TOY Language, as shown in the following:</p><div><ol class="orderedlist arabic"><li class="listitem">First step is to compile the <code class="literal">toy.cpp</code> program into an executable:<div><pre class="programlisting">$ clang++ toy.cpp  -O3 -o toy</pre></div></li><li class="listitem">The <code class="literal">toy</code> executable is our TOY compiler frontend. The <code class="literal">toy</code> language to be parsed is in a file called <code class="literal">example</code>:<div><pre class="programlisting">$ cat example
def foo(x , y)
x + y * 16</pre></div></li><li class="listitem">This file is passed as argument to be processed by the <code class="literal">toy</code> compiler:<div><pre class="programlisting">$ ./toy example</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How it works…</h2></div></div></div><p>The TOY compiler<a id="id101" class="indexterm"/> will open the <code class="literal">example</code> file in read mode. Then, it will tokenize the stream of words. It will come across the def keyword and return <code class="literal">DEF_TOKEN</code>. Then, the <code class="literal">HandleDefn()</code> function will be called, which will store the<a id="id102" class="indexterm"/> function name and the argument. It will recursively check for the type of token and then call the specific token handler functions to store<a id="id103" class="indexterm"/> them into respective ASTs.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec84"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The aforementioned lexer <a id="id104" class="indexterm"/>and parser do not handle errors in syntax except a few trivial ones. To implement Error handling, refer to <a class="ulink" href="http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics">http://llvm.org/docs/tutorial/LangImpl2.html#parser-basics</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Defining IR code generation methods for each AST class</h1></div></div></div><p>Now, since the <a id="id105" class="indexterm"/>AST is ready with all the<a id="id106" class="indexterm"/> necessary information in its data structure, the next phase is to generate LLVM IR. LLVM APIs are used in this code generation. LLVM IR has a predefined format that is generated by the inbuilt APIs of LLVM.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec85"/>Getting ready</h2></div></div></div><p>You must have created the AST from any input code of the TOY language.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec86"/>How to do it…</h2></div></div></div><p>In order to generate LLVM IR, a virtual <code class="literal">CodeGen</code> function is defined in each AST class (the AST classes<a id="id107" class="indexterm"/> were defined earlier<a id="id108" class="indexterm"/> in the AST section; these functions are additional to those classes) as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div></li><li class="listitem">In the <code class="literal">BaseAST</code> class defined earlier, append the <code class="literal">Codegen()</code> functions as follows:<div><pre class="programlisting">class BaseAST {
  …
  …
  virtual Value* Codegen() = 0;
};
class NumericAST : public BaseAST {
  …
  …
  virtual Value* Codegen();
};
class VariableAST : public BaseAST {
  …
  …
  virtual Value* Codegen();
};</pre></div><p>This virtual <code class="literal">Codegen()</code> function is included in every AST class we defined.</p><p>This function returns an LLVM Value object, which represents <strong>Static Single Assignment</strong> (<strong>SSA</strong>) value<a id="id109" class="indexterm"/> in LLVM. A few more static variables are defined that will be used during Codegen.</p></li><li class="listitem">Declare the following static variables in global scope as follows:<div><pre class="programlisting">static Module *Module_Ob;
static IRBuilder&lt;&gt; Builder(getGlobalContext());
static std::map&lt;std::string, Value*&gt;Named_Values;</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec87"/>How it works…</h2></div></div></div><p>The <code class="literal">Module_Ob</code> module contains all the functions and variables in the code.</p><p>The <code class="literal">Builder</code> object helps to generate LLVM IR and keeps track of the current point in the program to insert LLVM instructions. The <code class="literal">Builder</code> object has functions to create new instructions.</p><p>The <code class="literal">Named_Values</code> map<a id="id110" class="indexterm"/> keeps track of all the values defined in the current scope like a symbol table. For our language, this map will <a id="id111" class="indexterm"/>contain function parameters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Generating IR code for expressions</h1></div></div></div><p>In this recipe, you<a id="id112" class="indexterm"/> will see how IR code gets generated for an expression using the compiler frontend.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How to do it…</h2></div></div></div><p>To implement LLVM IR code generation for our TOY language, proceed with the following code flow:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">toy.cpp</code> file as follows:<div><pre class="programlisting">$ vi toy.cpp</pre></div></li><li class="listitem">The function to generate code for numeric values can be defined as follows:<div><pre class="programlisting">Value *NumericAST::Codegen() {
  return ConstantInt::get(Type::getInt32Ty(getGlobalContext()), numeric_val);
}</pre></div><p>In LLVM IR, integer constants are represented by the <code class="literal">ConstantInt</code> class whose numeric value is held by the <code class="literal">APInt</code> class.</p></li><li class="listitem">The function for generating code for variable expressions can be defined as  follows:<div><pre class="programlisting">Value *VariableAST::Codegen() {
  Value *V = Named_Values[Var_Name];
  return V ? V : 0;
}</pre></div></li><li class="listitem">The <code class="literal">Codegen()</code> function for binary expression can be defined as follows:<div><pre class="programlisting">Value *BinaryAST::Codegen() {
  Value *L = LHS-&gt;Codegen();
  Value *R = RHS-&gt;Codegen();
  if(L == 0 || R == 0) return 0;
  
  switch(atoi(Bin_Operator.c_str())) {
    case '+' : return Builder.CreateAdd(L, R, "addtmp");
    case '-' : return Builder.CreateSub(L, R, "subtmp");
    case '*' : return Builder.CreateMul(L, R, "multmp");
    case '/' : return Builder.CreateUDiv(L, R, "divtmp");
    default : return 0;
  }
}</pre></div><p>If the code above emits multiple <code class="literal">addtmp</code> variables, LLVM will automatically provide each one with an increasing, unique numeric suffix.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec89"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The next recipe shows<a id="id113" class="indexterm"/> how to generate IR code for function; we will learn how the code generation actually works.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Generating IR code for functions</h1></div></div></div><p>In this recipe you, will learn <a id="id114" class="indexterm"/>how to generate IR code for a function.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec90"/>How to do it…</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">Codegen()</code> function for the function call can be defined as follows:<div><pre class="programlisting">Value *FunctionCallAST::Codegen() {
  Function *CalleeF =
  Module_Ob-&gt;getFunction(Function_Callee);
  std::vector&lt;Value*&gt;ArgsV;
  for(unsigned i = 0, e = Function_Arguments.size();
  i != e; ++i) {
    ArgsV.push_back(Function_Arguments[i]-&gt;Codegen());
    if(ArgsV.back() == 0) return 0;
  }
  return Builder.CreateCall(CalleeF, ArgsV, "calltmp");
}</pre></div><p>Once we have the function to call, we recursively call the <code class="literal">Codegen()</code> function for each argument that is to be passed in and create an LLVM call instruction.</p></li><li class="listitem">Now that the <code class="literal">Codegen()</code> function for a function call has been defined, it's time to define the <code class="literal">Codegen()</code> functions for declarations and function definitions.<p>The <code class="literal">Codegen()</code> function for<a id="id115" class="indexterm"/> function declarations can be defined as follows:</p><div><pre class="programlisting">Function *FunctionDeclAST::Codegen() {
  std::vector&lt;Type*&gt;Integers(Arguments.size(), Type::getInt32Ty(getGlobalContext()));
  FunctionType *FT = FunctionType::get(Type::getInt32Ty(getGlobalContext()), Integers, false);
  Function *F = Function::Create(FT,  Function::ExternalLinkage, Func_Name, Module_Ob);
  
  if(F-&gt;getName() != Func_Name) {
    F-&gt;eraseFromParent();
    F = Module_Ob-&gt;getFunction(Func_Name);
    
    if(!F-&gt;empty()) return 0;
    
    if(F-&gt;arg_size() != Arguments.size()) return 0;
    
  }
  
  unsigned Idx = 0;
  for(Function::arg_iterator Arg_It = F-&gt;arg_begin(); Idx != Arguments.size(); ++Arg_It, ++Idx) {
    Arg_It-&gt;setName(Arguments[Idx]);
    Named_Values[Arguments[Idx]] = Arg_It;
  }
  
  return F;
}</pre></div><p>The <code class="literal">Codegen()</code> function for function definition can be defined as follows:</p><div><pre class="programlisting">Function *FunctionDefnAST::Codegen() {
  Named_Values.clear();
  
  Function *TheFunction = Func_Decl-&gt;Codegen();
  if(TheFunction == 0) return 0;
  
  BasicBlock *BB = BasicBlock::Create(getGlobalContext(),"entry", TheFunction);
  Builder.SetInsertPoint(BB);
  
  if(Value *RetVal = Body-&gt;Codegen()) {
    Builder.CreateRet(RetVal);
    verifyFunction(*TheFunction);
    return TheFunction;
  }
  
  TheFunction-&gt;eraseFromParent();
  return 0;
}</pre></div></li><li class="listitem">That's it! LLVMIR is now ready. These <code class="literal">Codegen()</code> functions can be called in the wrappers<a id="id116" class="indexterm"/> written to parse top-level expressions as follows:<div><pre class="programlisting">static void HandleDefn() {
  if (FunctionDefnAST *F = func_defn_parser()) {
    if(Function* LF = F-&gt;Codegen()) {
    }
  }
  else {
    next_token();
  }
}
static void HandleTopExpression() {
  if(FunctionDefnAST *F = top_level_parser()) {
    if(Function *LF = F-&gt;Codegen()) {
    }
  }
  else {
    next_token();
  }
}</pre></div><p>So, after parsing successfully, the respective <code class="literal">Codegen()</code> functions are called to generate the LLVM IR. The <code class="literal">dump()</code> function is called to print the generated IR.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec91"/>How it works…</h2></div></div></div><p>The <code class="literal">Codegen()</code> functions use LLVM inbuilt function calls to generate IR. The header files to include for this<a id="id117" class="indexterm"/> purpose are  <code class="literal">llvm/IR/Verifier.h</code>, <code class="literal">llvm/IR/DerivedTypes.h</code>, <code class="literal">llvm/IR/IRBuilder.h</code>, and <code class="literal">llvm/IR/LLVMContext.h</code>, <code class="literal">llvm/IR/Module.h</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">While compiling, this code needs to be linked with LLVM libraries. For this purpose, the <code class="literal">llvm-config</code> tool can be used as follows:<div><pre class="programlisting">llvm-config  --cxxflags  --ldflags  --system-libs  --libs core.</pre></div></li><li class="listitem">For this purpose, the <code class="literal">toy</code> program is recompiled with additional flags as follows:<div><pre class="programlisting">
<strong>$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div></li><li class="listitem">When the <code class="literal">toy</code> compiler is now run on <code class="literal">example</code> code, it will generate LLVM IR as follows:<div><pre class="programlisting">$ ./toy example

define i32 @foo (i32 %x, i32 %y) {
  entry:
  %multmp = muli32 %y, 16
  %addtmp = add i32 %x, %multmp
  reti32 %addtmp
}</pre></div><p>Another <code class="literal">example2</code> file has a function <code class="literal">call.$ cat example2</code>:</p><div><pre class="programlisting">foo(5, 6);</pre></div><p>Its LLVM IR will be dumped as follows:</p><div><pre class="programlisting">$ ./toy example2
define i32 @1 () {
  entry:
  %calltmp = call i32@foo(i32 5, i32 6)
  reti32 %calltmp
}</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec92"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For details on how <code class="literal">Codegen()</code> functions for C++ in Clang, refer to <a class="ulink" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/">http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/CodeGen/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Adding IR optimization support</h1></div></div></div><p>LLVM provides a wide variety of optimization passes. LLVM allows a compiler implementation<a id="id118" class="indexterm"/> to decide which optimizations to use, their order, and so on. In this recipe, you will learn how to add IR optimization support.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec93"/>How to do it…</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To start with the addition of IR optimization support, first of all a static variable for function manager has to be defined as follows:<div><pre class="programlisting">static FunctionPassManager *Global_FP;</pre></div></li><li class="listitem">Then, a function pass manager needs to be defined for the <code class="literal">Module</code> object used previously. This can be done in the <code class="literal">main()</code> function as follows:<div><pre class="programlisting">FunctionPassManager My_FP(TheModule);</pre></div></li><li class="listitem">Now a pipeline of various optimizer passes can be added in the <code class="literal">main()</code> function as follows:<div><pre class="programlisting">My_FP.add(createBasicAliasAnalysisPass());
My_FP.add(createInstructionCombiningPass());
My_FP.add(createReassociatePass());
My_FP.add(createGVNPass());
My_FP.doInitialization();</pre></div></li><li class="listitem">Now the static global function Pass Manager is assigned to this pipeline as follows:<div><pre class="programlisting">Global_FP = &amp;My_FP;
Driver();</pre></div><p>This PassManager has a run method, which we can run on the function IR generated before returning from <code class="literal">Codegen()</code> of the function definition. This is demonstrated as follows:</p><div><pre class="programlisting">Function* FunctionDefnAST::Codegen() {
  Named_Values.clear();
  Function *TheFunction = Func_Decl-&gt;Codegen();
  if (!TheFunction) return 0;
  BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction);
  Builder.SetInsertPoint(BB);
  if (Value* Return_Value = Body-&gt;Codegen()) {
    Builder.CreateRet(Return_Value);
    verifyFunction(*TheFunction);
    Global_FP-&gt;run(*TheFunction);
    returnTheFunction;
  }
  TheFunction-&gt;eraseFromParent();
  return 0;
}</pre></div></li></ol><div></div><p>This is a lot more beneficial as it optimizes the function in place, improving the code generated for the function body.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec94"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">How to add <a id="id119" class="indexterm"/>our own optimization pass and its run method will be demonstrated in the later chapters</li></ul></div></div></div></body></html>