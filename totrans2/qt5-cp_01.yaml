- en: Chapter 1. Creating Your First Qt Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI programming is not as difficult as you think. At least it's not when you
    come to the world of Qt. This book will take you through this world and give you
    an insight into this incredibly amazing toolkit. It doesn't matter whether you've
    heard of it or not, as long as you have essential knowledge of C++ programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will get you comfortable with the development of Qt applications.
    Simple applications are used as a demonstration for you to cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the layout of widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the mechanism of signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting two signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Qt Quick application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting C++ slots to QML signals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t installed Qt 5, refer to [http://www.qt.io/download](http://www.qt.io/download)
    to install the latest version of it. It''s recommended that you install the Community
    version, which is totally free and compliant with GPL/LGPL. Typically, the installer
    will install both **Qt Library** and **Qt Creator** for you. In this book, we
    will use Qt 5.4.0 and Qt Creator 3.3.0\. Later versions may have slight differences
    but the concept remains the same. It''s highly recommended that you install Qt
    Creator if you don''t have it on your computer, because all the tutorials in this
    book are based on it. It is also the official IDE for the development of Qt applications.
    Although you may be able to develop Qt applications with other IDEs, it tends
    to be much more complex. So if you''re ready, let''s go for it by performing the
    following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Open Qt Creator.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **New File** or **Project**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Qt Widgets Application**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the project's name and location. In this case, the project's name is `layout_demo`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may wish to follow the wizard and keep the default values. After this process,
    Qt Creator will generate the skeleton of the project based on your choices. The
    UI files are under the `Forms` directory. When you double-click on a UI file,
    Qt Creator will redirect you to the integrated designer. The mode selector should
    have **Design** highlighted, and the main window should contain several sub-windows
    to let you design the user interface. This is exactly what we are going to do.
    For more details about Qt Creator UI, refer to [http://doc.qt.io/qtcreator/creator-quick-tour.html](http://doc.qt.io/qtcreator/creator-quick-tour.html).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Drag three push buttons from the widget box (widget palette) into the frame
    of **MainWindow** in the center. The default text displayed on these buttons is
    **PushButton**, but you can change the text if you want by double-clicking on
    the button. In this case, I changed the buttons to `Hello`, `Hola`, and `Bonjour`,
    accordingly. Note that this operation won't affect the `objectName` property.
    In order to keep it neat and easy to find, we need to change the `objectName`
    property. The right-hand side of the UI contains two windows. The upper-right
    section includes **Object Inspector** and the lower-right side includes **Property
    Editor**. Just select a push button; you can easily change `objectName` in **Property
    Editor**. For the sake of convenience, I changed these buttons' `objectName` properties
    to `helloButton`, `holaButton`, and `bonjourButton` respectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a good habit to use lowercase for the first letter of `objectName` and
    an uppercase letter for **Class name**. This helps your code to be more readable
    by people who are familiar with this convention.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, it''s time to see what you have done to the user interface of your first
    Qt application. Click on **Run** on the left-hand side panel. It will build the
    project automatically and then run it. It''s amazing to see that the application
    has the exact same interface as the design, isn''t it? If everything is alright,
    the application should appear similar to what is shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/4615OS_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'You may want to look at the source code and see what happened there. So, let''s
    go back to the source code by returning to the **Edit** mode. Click on the **Edit**
    button in the mode selector. Then, double-click on `main.cpp` in the `Sources`
    folder of the **Projects** tree view. The code for `main.cpp` is shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QApplication` class manages the GUI application's control flow and the
    main settings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you don't need to and you probably won't change too much in this file.
    The first line of the main scope just initializes the applications on a user's
    desktop and handles some events. Then there is also an object, `w`, which belongs
    to the `MainWindow` class. As for the last line, it ensures that the application
    won't terminate after execution but will keep in an event loop, so that it is
    able to respond to external events such as mouse clicks and window state changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, let''s see what happens during the initialization of the
    `MainWindow` object, `w`. It is the content of `mainwindow.h`, shown as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may feel a bit surprised seeing a `Q_OBJECT` macro if this is your first
    time writing a Qt application. In the QObject documentation, it says:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*The `Q_OBJECT` macro must appear in the private section of a class definition
    that declares its own signals and slots or that uses other services provided by
    Qt''s meta-object system.*'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Well, this means that `QObject` has to be declared if you're going to use Qt's
    meta-object system and (or) its signals and slots mechanism. The signals and slots,
    which are almost the core of Qt, will be included later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a private member named `ui`, which is a pointer of the `MainWindow`
    class of the `Ui` namespace. Do you remember the UI file we edited before? What
    the magic of Qt does is that it links the UI file and the parental source code.
    We can manipulate the UI through code lines as well as design it in Qt Creator''s
    integrated designer. Finally, let''s look into the construction function of `MainWindow`
    in `mainwindow.cpp`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Did you see where the user interface comes from? It''s the member `setupUi`
    function of `Ui::MainWindow` that initializes it and sets it up for us. You may
    want to check what happens if we change the member function to something like
    this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happened here? The `Hola` button can't be clicked on because we disabled
    it! It has the same effect if the **enabled** box is unchecked in the designer
    instead of writing a statement here. Please apply this change before heading to
    the next topic, because we don't need a disabled push button to do any demonstrations
    in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Changing the layout of widgets
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know how to add and move widgets in the **Design** mode. Now, we
    need to make the UI neat and tidy. I'll show you how to do this step by step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A quick way to delete a widget is to select it and press the **Delete** button.
    Meanwhile, some widgets, such as the menu bar, status bar, and toolbar can't be
    selected, so we have to right-click on them in **Object Inspector** and delete
    them. Since they are useless in this example, it's safe to remove them and we
    can do this for good.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s understand what needs to be done after the removal. You may want
    to keep all these push buttons on the same horizontal axis. To do this, perform
    the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Select all the push buttons either by clicking on them one by one while keeping
    the *Ctrl* key pressed or just drawing an enclosing rectangle containing all the
    buttons.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select **Layout** | **LayOut Horizontally**, The keyboard shortcut
    for this is *Ctrl* + *H*.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the horizontal layout and adjust its `layoutSpacing` by selecting it
    and dragging any of the points around the selection box until it fits best.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hmm…! You may have noticed that the text of the **Bonjour** button is longer
    than the other two buttons, and it should be wider than the others. How do you
    do this? You can change the property of the horizontal layout object's `layoutStretch`
    property in **Property Editor**. This value indicates the stretch factors of the
    widgets inside the horizontal layout. They would be laid out in proportion. Change
    it to `3,3,4`, and there you are. The stretched size definitely won't be smaller
    than the minimum size hint. This is how the zero factor works when there is a
    nonzero natural number, which means that you need to keep the minimum size instead
    of getting an error with a zero divisor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯…！你可能已经注意到**Bonjour**按钮的文本比其他两个按钮长，它应该比其他按钮更宽。你该如何做到这一点？你可以在**属性编辑器**中更改水平布局对象的`layoutStretch`属性。此值表示水平布局内小部件的拉伸因子。它们将按比例排列。将其更改为`3,3,4`，就是这样。拉伸的大小肯定不会小于最小尺寸提示。这就是当存在非零自然数时零因子的作用，这意味着你需要保持最小尺寸，而不是因为零除数而出现错误。
- en: Now, drag **Plain Text Edit** just below, and not inside, the horizontal layout.
    Obviously, it would be neater if we could extend the plain text edit's width.
    However, we don't have to do this manually. In fact, we could change the layout
    of the parent, **MainWindow**. That's it! Right-click on **MainWindow**, and then
    navigate to **Lay out** | **Lay Out Vertically**. Wow! All the children widgets
    are automatically extended to the inner boundary of **MainWindow**; they are kept
    in a vertical order. You'll also find **Layout** settings in the `centralWidget`
    property, which is exactly the same thing as the previous horizontal layout.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**纯文本编辑**拖动到水平布局的下方，而不是内部。显然，如果我们能扩展纯文本编辑的宽度，会看起来更整洁。然而，我们不必手动这样做。实际上，我们可以更改父窗口的布局，即**MainWindow**。就是这样！右键点击**MainWindow**，然后导航到**布局**
    | **垂直布局**。哇！所有子小部件都会自动扩展到**MainWindow**的内边界；它们保持垂直顺序。你也会在`centralWidget`属性中找到**布局**设置，这与之前的水平布局完全相同。
- en: 'The last thing to make this application halfway decent is to change the title
    of the window. `MainWindow` is not the title you want, right? Click on **MainWindow**
    in the object tree. Then, scroll down its properties to find **windowTitle**.
    Name it whatever you want. In this example, I changed it to `Greeting`. Now, run
    the application again and you will see it looks like what is shown in the following
    screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个应用程序变得半 decent 的最后一件事是更改窗口的标题。"MainWindow"不是你想要的标题，对吧？在对象树中点击**MainWindow**。然后，滚动其属性以找到**windowTitle**。给它起个你想的名字。在这个例子中，我将其更改为`Greeting`。现在，再次运行应用程序，你将看到它看起来就像以下截图所示：
- en: '![Changing the layout of widgets](img/4615OS_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![更改小部件布局](img/4615OS_01_02.jpg)'
- en: Understanding the mechanism of signals and slots
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解信号和槽的机制
- en: It is really important to keep your curiosity and to explore what on earth these
    properties do. However, please remember to revert the changes you made to the
    app, as we are about to enter the core part of Qt, that is, signals and slots.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保持好奇心并探索这些属性究竟有什么作用，这一点非常重要。然而，请记住恢复你对应用程序所做的更改，因为我们即将进入Qt的核心部分，即信号和槽。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Signals and slots are used for communication between objects. The signals and
    slots mechanism is a central feature of Qt and probably the part that differs
    the most from the features provided by other frameworks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽用于对象之间的通信。信号和槽机制是Qt的核心特性，可能是与其他框架提供的特性差异最大的部分。
- en: 'Have you ever wondered why a window closes after the **Close** button is clicked
    on? Developers who are familiar with other toolkits would say that the **Close**
    button being clicked on is an event, and this event is bound with a callback function
    that is responsible for closing the window. Well, it''s not quite the same in
    the world of Qt. Since Qt uses a mechanism called signals and slots, it makes
    the callback function weakly coupled to the event. Also, we usually use the terms
    signal and slot in Qt. A signal is emitted when a particular event occurs. A slot
    is a function that is called in response to a particular signal. The following
    simple and schematic diagram helps you understand the relation between signals,
    events, and slots:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经想过为什么在点击**关闭**按钮后窗口会关闭？熟悉其他工具包的开发者会说，点击**关闭**按钮是一个事件，这个事件绑定了一个回调函数，该函数负责关闭窗口。然而，在
    Qt 的世界中，情况并不完全相同。由于 Qt 使用名为信号和槽的机制，它使得回调函数与事件之间的耦合变得较弱。此外，我们通常在 Qt 中使用信号和槽这两个术语。当特定事件发生时发出信号。槽是响应特定信号而被调用的函数。以下简单且示意图有助于您理解信号、事件和槽之间的关系：
- en: '![Understanding the mechanism of signals and slots](img/4615OS_01_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![理解信号和槽的机制](img/4615OS_01_03.jpg)'
- en: Qt has tons of predefined signals and slots, which cover its general purposes.
    However, it's indeed commonplace to add your own slots to handle the target signals.
    You may also be interested in subclassing widgets and writing your own signals,
    which will be covered later. The mechanism of signals and slots was designed to
    be type-safe because of its requirement of the list of the same arguments. In
    fact, the slot may have a shorter arguments list than the signal since it can
    ignore the extras. You can have as many arguments as you want. This enables you
    to forget about the wildcard `void*` type in C and other toolkits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 有大量的预定义信号和槽，涵盖了其通用目的。然而，添加自己的槽来处理目标信号确实是常见的做法。您可能还对子类化小部件并编写自己的信号感兴趣，这将在稍后介绍。由于信号和槽机制要求具有相同参数的列表，因此它被设计为类型安全的。实际上，槽可以比信号具有更短的参数列表，因为它可以忽略额外的参数。您可以拥有尽可能多的参数。这使得您可以在
    C 和其他工具包中忘记通配符 `void*` 类型。
- en: 'Since Qt 5, this mechanism is even safer because we can use a new syntax of
    signals and slots to deal with the connections. A conversion of a piece of code
    is demonstrated here. Let''s see what a typical connect statement in old style
    is:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Qt 5 以来，这种机制变得更加安全，因为我们可以使用新的信号和槽语法来处理连接。这里演示了一段代码的转换。让我们看看旧式风格中典型的连接语句：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be rewritten in a new syntax style:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用新的语法风格重写：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the traditional way of writing code, the verification of signals and slots
    only happens at runtime. In the new style, the compiler can detect the mismatches
    in the types of arguments and the existence of signals and slots at compile time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的代码编写方式中，信号和槽的验证仅在运行时发生。在新风格中，编译器可以在编译时检测参数类型的不匹配以及信号和槽的存在。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As long as it is possible, all `connect` statements are written in the new syntax
    style in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只要可能，本书中的所有 `connect` 语句都使用新的语法风格编写。
- en: 'Now, let''s get back to our application. I''ll show you how to display some
    words in a plain text edit when the **Hello** button is clicked on. First of all,
    we need to create a slot since Qt has already predefined the clicked signal for
    the `QPushButton` class. Edit `mainwindow.h` and add a slot declaration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的应用程序。我将向您展示如何在点击**Hello**按钮时在纯文本编辑器中显示一些文字。首先，我们需要创建一个槽，因为 Qt 已经为
    `QPushButton` 类预定义了点击信号。编辑 `mainwindow.h` 并添加槽声明：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it''s the `slots` keyword that distinguishes slots from ordinary
    functions. I declared it private to restrict access permission. You have to declare
    it a `public` slot if you need to invoke it in an object from other classes. After
    this declaration, we have to implement it in the `mainwindow.cpp` file. The implementation
    of the `displayHello` slot is written as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，是 `slots` 关键字将槽与普通函数区分开来。我将其声明为私有以限制访问权限。如果您需要在其他类的对象中调用它，必须将其声明为 `public`
    槽。在此声明之后，我们必须在 `mainwindow.cpp` 文件中实现它。`displayHello` 槽的实现如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It simply calls a member function of the plain text edit in order to add a
    `Hello` QString to it. `QString` is a core class that Qt has introduced. It provides
    a Unicode character string, which efficiently solves the internationalization
    issue. It''s also convenient to convert a `QString` class to `std::string` and
    vice versa. Besides, just like the other `QObject` classes, `QString` uses an
    implicit sharing mechanism to reduce memory usage and avoid needless copying.
    If you don''t want to get concerned about the scenes shown in the following code,
    just take `QString` as an improved version of `std::string`. Now, we need to connect
    this slot to the signal that the **Hello** push button will emit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用纯文本编辑的一个成员函数，以便向其中添加一个`Hello` QString。`QString`是Qt引入的一个核心类。它提供了一个Unicode字符字符串，有效地解决了国际化问题。它也方便地将`QString`类转换为`std::string`，反之亦然。此外，就像其他`QObject`类一样，`QString`使用隐式共享机制来减少内存使用并避免不必要的复制。如果你不想关心以下代码中显示的场景，只需将`QString`视为`std::string`的改进版本。现在，我们需要将这个槽连接到**Hello**按钮将发出的信号：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What I did is add a `connect` statement to the constructor of `MainWindow`.
    In fact, we can connect signals and slots anywhere and at any time. However, the
    connection only exists after this line gets executed. So, it''s a common practice
    to have lots of `connect` statements in the construction functions instead of
    spreading them out. For a better understanding, run your application and see what
    happens when you click on the **Hello** button. Every time you click, a **Hello**
    text will be appended to the plain text edit. The following screenshot is what
    happened after we clicked on the **Hello** button three times:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的是在`MainWindow`的构造函数中添加了一个`connect`语句。实际上，我们可以在任何地方和任何时候连接信号和槽。然而，连接只有在执行这一行之后才会存在。因此，在构造函数中放置大量的`connect`语句是一种常见的做法。为了更好地理解，运行你的应用程序并看看点击**Hello**按钮时会发生什么。每次点击，都会在纯文本编辑中追加一个**Hello**文本。以下是在我们点击了**Hello**按钮三次之后的截图：
- en: '![Understanding the mechanism of signals and slots](img/4615OS_01_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![理解信号和槽的机制](img/4615OS_01_04.jpg)'
- en: Getting confused? Let me walk you through this. When you clicked on the **Hello**
    button, it emitted a clicked signal. Then, the code inside the `displayHello`
    slot got executed, because we connected the clicked signal of the **Hello** button
    to the `displayHello` slot of `MainWindow`. What the `displayHello` slot did is
    that it simply appended `Hello` to the plain text edit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我带你一步步走过这个过程。当你点击**Hello**按钮时，它发出了一个点击信号。然后，`displayHello`槽中的代码被执行，因为我们把**Hello**按钮的点击信号连接到了`MainWindow`的`displayHello`槽。`displayHello`槽所做的是简单地将`Hello`追加到纯文本编辑中。
- en: 'It may take you some time to fully understand the mechanism of signals and
    slots. Just take your time. I''ll show you another example of how to disconnect
    such a connection after we clicked on the **Hola** button. Similarly, add a declaration
    of the slot to the header file and define it in the source file. I pasted the
    content of the `mainwindow.h` header file, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解信号和槽的机制可能需要一些时间。请慢慢来。在我们点击了**Hola**按钮之后，我会给你展示一个如何断开这种连接的例子。同样，将槽的声明添加到头文件中，并在源文件中定义它。我已经粘贴了`mainwindow.h`头文件的内容，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s only declaring a `onHolaClicked` slot that differed from the original.
    Here''s the content of the source file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是声明了一个与原始版本不同的`onHolaClicked`槽。以下是源文件的内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ll find that the **Hello** button no longer works after you clicked on
    the **Hola** button. This is because in the `onHolaClicked` slot, we just disconnected
    the binding between the clicked signal of `helloButton` and the `displayHello`
    slot of `MainWindow`. Actually, `disconnect` has some overloaded functions and
    can be used in a more destructive way. For example, you may want to disconnect
    all connections between a specific signal sender and a specific receiver:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现点击了**Hola**按钮之后，**Hello**按钮不再工作。这是因为在我们点击了`onHolaClicked`槽之后，我们只是断开了`helloButton`的点击信号和`MainWindow`的`displayHello`槽之间的绑定。实际上，`disconnect`有一些重载函数，可以用更破坏性的方式使用。例如，你可能想要断开特定信号发送者和特定接收者之间的所有连接：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to disconnect all the slots associated with a signal, since a signal
    can be connected to as many slots as you wish, the code can be written like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要断开与一个信号相关联的所有槽，因为一个信号可以连接到任意多个槽，代码可以写成这样：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also disconnect all the signals in an object, whatever slots they might
    be connected to. The following code will disconnect all the signals in `helloButton`,
    which of course includes the clicked signal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like a signal, a slot can be connected to as many signals as you want.
    However, there's no such function to disconnect a specific slot from all the signals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember the signals and slots that you have connected.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the new syntax for traditional connections of signals and slots,
    Qt 5 has offered a new way to simplify such a binding process with C++11 lambda
    expressions. As you may have noticed, it''s kind of tedious to declare a slot
    in the header file, define it in the source code file, and then connect it to
    a signal. It''s worthwhile if the slot has a lot of statements, otherwise it becomes
    time consuming and increases the complexity. Before we go any further, we need
    to turn on C++11 support on Qt. Edit the pro file (`layout_demo.pro` in my example)
    and add the following line to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some old compilers don't support C++11\. If this happens, upgrade
    your compiler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to navigate to **Build** | **Run qmake** to reconfigure the project
    properly. If everything is okay, we can go back to editing the `mainwindow.cpp`
    file. This way, there is no need to declare a slot and define and connect it.
    Just add a `connect` statement to the construction function of `MainWindow`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's very straightforward, isn't it? The third argument is a lambda expression,
    which was added to C++ since C++11.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details about lambda expression, visit [http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'This pair of signal and slot connection is done if you don''t do need to to
    disconnect such a connection. However, if you need, you have to save this connection,
    which is a `QMetaObject::Connection` type. In order to disconnect this connection
    elsewhere, it would be better to declare it as a variable of `MainWindow`. So
    the header file becomes as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, I declared `bonjourConnection` as an object of `QMetaObject::Connection`
    so that we can save the connection dealing with an unnamed slot. Similarly, the
    disconnection happens in `onHolaClicked`, so there won''t be any new `Bonjour`
    text on screen after we click on the **Hola** button. Here is the content of `mainwindow.cpp`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed another new usage of `disconnect`. It takes in a `QMetaObject::Connection`
    object as the only argument. You'll thank this new overloaded function if you're
    going to use the lambda expression as a slot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Connecting two signals
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the weak couplings of the Qt signals and slot mechanisms, it is viable
    to bind signals to each other. It may sound confusing, so let me draw a diagram
    to make it clear:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting two signals](img/4615OS_01_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'When an event triggers a specific signal, this emitted signal could be another
    event, which will emit another specific signal. It is not a very common practice,
    but it tends to be useful when you deal with some complex signals and slot connection
    networks, especially when tons of events lead to the emission of only a few signals.
    Although it definitely increases the complexity of the project, binding these
    signals could simplify the code a lot. Append the following statement to the construction
    function of `MainWindow`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You''ll get two lines in a plain text edit after you click on the **Bonjour**
    button. The first line is **Bonjour** and the second one is **Hello**. Apparently,
    this is because we coupled the clicked signal of the **Bonjour** button with the
    clicked signal of the **Hello** button. The clicked signal of the latter has already
    been coupled with a slot, which results in the new text line, **Hello**. In fact,
    it has the same effect as the following statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basically, connecting two signals is a simplified version of connecting a signal
    and a slot, while the slot is meant to emit another signal. As for priority, the
    slot(s) of the latter signal will be handled when the event loop is returned to
    the object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: However, it is impossible to connect two slots because the mechanism requires
    a signal while a slot is considered a receiver instead of a sender. Therefore,
    if you want to simplify the connection, just wrap these slots as one slot, which
    can be used for connections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Qt Quick application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered how to create a Qt (C++) application. How about giving the
    newly introduced Qt Quick application development a try? Qt Quick was introduced
    in Qt 4.8 and it is now becoming mature in Qt 5\. Because the QML file is usually
    platform-independent, it enables you to develop an application for multiple targets,
    including mobile operating systems with the same code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I''ll show you how to create a simple Qt Quick application
    based on Qt Quick Controls 1.2, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project named `HelloQML`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Qt Quick Application** instead of **Qt Widgets Application**, which
    we chose previously.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Qt Quick Controls 1.2** when the wizard navigates you to **Select Qt
    Quick Components Set**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt Quick Controls has been introduced since Qt 5.1 and is highly recommended
    because it enables you to build a complete and native user interface. You can
    also control the top-level window properties from QML. Getting confused by QML
    and Qt Quick?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QML is a user interface specification and programming language. It allows developers
    and designers alike to create highly performant, fluidly animated, and visually
    appealing applications. QML offers a highly readable, declarative, JSON-like syntax
    with support for imperative JavaScript expressions combined with dynamic property
    bindings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: While Qt Quick is the standard library for QML, it sounds like the relation
    between STL and C++. The difference is that QML is dedicated to user interface
    design and Qt Quick includes a lot of visual types, animations, and so on. Before
    we go any further, I want to inform you that QML is different from C++ but similar
    to JavaScript and JSON.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `main.qml` file under the root of the `Resources` file, `qml.qrc`,
    which Qt Creator has generated for our new Qt Quick project. Let''s see how the
    code should be:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you have ever touched Java or Python, the first two lines won't be too unfamiliar
    to you. It simply imports Qt Quick and Qt Quick Controls, and the number following
    is the version of the library. You may need to change the version if there is
    a newer library. Importing other libraries is a common practice when developing
    Qt Quick applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The body of this QML source file is actually in the JSON style, which enables
    you to understand the hierarchy of the user interface through the code. Here,
    the root item is `ApplicationWindow`, which is basically the same thing as `MainWindow`
    in the previous topics, and we use braces to enclose the statements just like
    in a JSON file. Although you could use a semicolon to mark an ending of a statement
    just like we do in C++, there is no need to do this. As you can see, the property
    definition needs a colon if it's a single-line statement and enclosing braces
    if it contains more than one subproperty.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The statements are kind of self explanatory and they are similar to the properties
    that we saw in the Qt Widgets application. A `qsTr` function is used for internationalization
    and localization. Strings marked by `qsTr` could be translated by Qt Linguist.
    In addition to this, you don't need to care about QString and `std::string` any
    more. All the strings in QML are encoded in the same coding as the QML file and
    the QML file is created in UTF-8 by default.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: As for the signals and slots mechanism in Qt Quick, it's easy if you only use
    QML to write the callback function to the corresponding slot. Here, we execute
    `Qt.quit()` inside the `onTriggered` slot of `MenuItem`. It's viable to connect
    the signal of a QML item to a C++ object's slot, which I'll introduce later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this application in Windows, you can barely find the difference
    between the `Text` item and the `Label` item. However, on some platforms, or when
    you change the system font and/or its color, you''ll find that `Label` follows
    the font and the color scheme of the system, while `Text` doesn''t. Although you
    can use the properties of `Text` to customize the appearance of `Label`, it would
    be better to use the system settings to keep the looks of the application native.
    Well, if you run this application right now, it will appear similar to what is
    shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Qt Quick application](img/4615OS_01_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Because there is no separate UI file for the Qt Quick applications, only a QML
    file, we use the `anchors` property to position the items, and `anchors.centerIn`
    will position the item in the center of the parent. There is an integrated Qt
    Quick Designer in Qt Creator, which could help you design the user interface of
    a Qt Quick application. If you need it, just navigate to **Design** mode when
    you're editing a QML file. However, I suggest you stay in **Edit** mode to understand
    the meaning of each statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Connecting C++ slots to QML signals
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The separation of the user interface and backend allows us to connect C++ slots
    to the QML signals. Although it's possible to write processing functions in QML
    and manipulate interface items in C++, it violates the principle of the separation.
    Therefore, you may want to know how to connect a C++ slot to a QML signal at first.
    As for connecting a QML slot to a C++ signal, I'll introduce that later in this
    book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate this, we need to create a C++ class in the first place
    by right-clicking on the project in the **Projects** panel and selecting **Add
    New…**. Then, click on **C++ Class** in the pop-up window. The newly created class
    should at least inherit from `QObject` by choosing `QObject` as its base class.
    This is because a plain C++ class can''t include Qt''s slots or signals. The header
    file''s content is displayed as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s the content of the source file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The C++ file is the same as the one we dealt with in the previous topics. The
    `onMenuClicked` slot I defined is simply to output the string that passes through
    the signal. Note that you have to include `QDebug` if you want to use the built-in
    functions of `qDebug`, `qWarning`, `qCritical`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The slot is prepared, so we need to add a signal to the QML file. The QML file
    is changed to the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, I specified the ID of the root `ApplicationWindow` item to window
    and declared a signal named `menuClicked`. In addition to this, there is another
    `MenuItem` in the menu file. It emits the `menuClicked` signal of window, using
    its text as the parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's connect the slot in the C++ file to this newly created QML signal.
    Edit the `main.cpp` file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The item in the QML file is accessed as `QObject` in C++ and it could be cast
    to `QQuickItem`. For now, we only need to connect its signal, so `QObject` will
    do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 文件中的项以 `QObject` 的形式在 C++ 中访问，并且它可以被转换为 `QQuickItem`。目前，我们只需要连接其信号，所以
    `QObject` 就足够了。
- en: You may notice that I used the old-style syntax of the `connect` statement.
    This is because QML is dynamic and the C++ compiler can't detect the existence
    of the signal in the QML file. Since things in QML are checked at runtime, it
    doesn't make sense to use the old syntax here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我使用了 `connect` 语句的老式语法。这是因为 QML 是动态的，C++ 编译器无法检测 QML 文件中信号的存在。由于 QML
    中的事物是在运行时检查的，所以在这里使用老式语法是没有意义的。
- en: 'When you run this application and navigate to **File** | **Click Me** in the
    menu bar, you''ll see **Application Output** in Qt Creator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此应用程序并导航到菜单栏中的 **文件** | **点击我** 时，你将在 Qt Creator 中看到 **应用程序输出**：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's review this process again. Triggering the `Click Me` menu item resulted
    in the emission of the window's signal `menuClicked`. This signal passed the text
    of `MenuItem`, which is `Click Me`, to the slot in C++ class `Processor`, and
    the processor `myProcessor` slot `onMenuClicked` printed the string to the **Application
    Output** panel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾这个过程。触发 **点击我** 菜单项导致窗口的信号 `menuClicked` 被发射。这个信号将 `MenuItem` 的文本（`点击我`）传递给
    C++ 类 `Processor` 中的槽，处理器 `myProcessor` 的槽 `onMenuClicked` 将字符串打印到 **应用程序输出**
    面板。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the fundamentals of Qt, which included steps for
    how to create a Qt application. Then, we had a walk-through of both Qt Widgets
    and Qt Quick, and how to change the layout. Finally, we rounded off by covering
    an important concept about the mechanism of signals and slots.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Qt 的基础知识，包括创建 Qt 应用程序的步骤。然后，我们了解了 Qt Widgets 和 Qt Quick 的使用，以及如何更改布局。最后，我们通过介绍关于信号和槽机制的重要概念来结束本章。
- en: In the next chapter, we will have a chance to put this knowledge into practice
    and get started on building a real-world, and of course cross-platform, Qt application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将有机会将所学知识付诸实践，并开始构建一个真实世界、当然也是跨平台的 Qt 应用程序。
