- en: Chapter 12. Scratching the Tip of the Iceberg
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。冰山一角
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with graphs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理图
- en: Visualizing graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化图
- en: Using a true random number generator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真随机数生成器
- en: Using portable math functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可移植的数学函数
- en: Writing test cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: Combining multiple test cases in one test module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个测试模块中组合多个测试用例
- en: Manipulating images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作图像
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Boost is a huge collection of libraries. Some of those libraries are small and
    meant for everyday use and others require a separate book to describe all of their
    features. This chapter is devoted to some of those big libraries and to give you
    some basics to start with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 是一个庞大的库集合。其中一些库很小，适合日常使用，而其他一些则需要单独的书籍来描述它们的所有功能。本章致力于介绍这些大型库，并为你提供一些基础知识以开始使用。
- en: The first two recipes will explain the usage of `Boost.Graph` . It is a big
    library with an insane number of algorithms. We'll see some basics and probably
    the most important part of it visualization of graphs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个菜谱将解释 `Boost.Graph` 的用法。这是一个拥有大量算法的大库。我们将看到一些基础知识，以及它最重要的部分——图的可视化。
- en: We'll also see a very useful recipe for generating true random numbers. This
    is a very important requirement for writing secure cryptography systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到一个非常有用的生成真随机数的菜谱。这对于编写安全的加密系统来说是一个非常重要的要求。
- en: Some C++ standard libraries lack math functions. We'll see how that can be fixed
    using Boost. But the format of this book leaves no space to describe all of the
    functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 C++ 标准库缺少数学函数。我们将看到如何使用 Boost 来解决这个问题。但本书的格式没有足够的空间来描述所有这些函数。
- en: Writing test cases is described in the *Writing test cases* and *Combining multiple
    test cases in one test module* recipes. This is important for any production-quality
    system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试用例在 *编写测试用例* 和 *在一个测试模块中组合多个测试用例* 菜谱中描述。这对于任何生产级系统来说都很重要。
- en: The last recipe is about a library that helped me in many courses during my
    university days. Images can be created and modified using it. I personally used
    it to visualize different algorithms, hide data in images, sign images, and generate
    textures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个菜谱是关于一个在我大学期间帮助我在许多课程中取得成功的库。可以使用它创建和修改图像。我本人用它来可视化不同的算法、在图像中隐藏数据、签名图像和生成纹理。
- en: Unfortunately, even this chapter cannot tell you about all of the Boost libraries.
    Maybe someday I'll write another book... and then a few more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使是这一章也无法告诉你关于所有 Boost 库的信息。也许有一天我会写另一本书...然后是几本更多。
- en: Working with graphs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图
- en: Some tasks require a graphical representation of data. `Boost.Graph` is a library
    that was designed to provide a flexible way of constructing and representing graphs
    in memory. It also contains a lot of algorithms to work with graphs, such as topological
    sort, breadth first search, depth first search, and Dijkstra shortest paths.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些任务需要数据的图形表示。`Boost.Graph` 是一个库，旨在提供一种灵活的方式来在内存中构建和表示图。它还包含许多用于处理图的算法，例如拓扑排序、广度优先搜索、深度优先搜索和
    Dijkstra 最短路径。
- en: Well, let's perform some basic tasks with `Boost.Graph`!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们用 `Boost.Graph` 执行一些基本任务！
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and templates is required for this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，只需要具备基本的 C++ 和模板知识。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we'll describe a graph type, create a graph of that type, add
    some vertexes and edges to the graph, and search for a specific vertex. That should
    be enough to start using `Boost.Graph`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将描述一个图类型，创建该类型的图，向图中添加一些顶点和边，并搜索特定的顶点。这应该足以开始使用 `Boost.Graph`。
- en: 'We start with describing the graph type:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先描述图类型：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we construct it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来构建它：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s use a non portable trick that speeds up graph construction:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个非可移植的技巧来加速图构建：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we are ready to add vertexes to the graph:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好向图中添加顶点了：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is time to connect vertexes with edges:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候用边连接顶点了：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We make a function that searches for a vertex:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写一个搜索顶点的函数：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we will write code that gets iterators to all vertexes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写代码来获取所有顶点的迭代器：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s time to run a search for the required vertex:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候运行搜索以查找所需的顶点了：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we are describing what our graph must look like and upon what types
    it must be based. `boost::adjacency_list` is a class that represents graphs as
    a two-dimensional structure, where the first dimension contains vertexes and the
    second dimension contains edges for that vertex. `boost::adjacency_list` must
    be the default choice for representing a graph; it suits most cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们描述了我们的图必须看起来像什么以及它必须基于什么类型。`boost::adjacency_list`是一个表示图作为二维结构的类，其中第一个维度包含顶点，第二个维度包含该顶点的边。`boost::adjacency_list`必须是表示图的默认选择；它适用于大多数情况。
- en: 'The first template parameter, `boost::adjacency_list`, describes the structure
    used to represent the edge list for each of the vertexes; the second one describes
    a structure to store vertexes. We can choose different STL containers for those
    structures using specific selectors, as listed in the following table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板参数`boost::adjacency_list`描述了用于表示每个顶点的边列表的结构；第二个描述了存储顶点的结构。我们可以使用特定的选择器为这些结构选择不同的STL容器，如下表所示：
- en: '| Selector | STL container |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 选择器 | STL 容器 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boost::vecS` | `std::vector` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `boost::vecS` | `std::vector` |'
- en: '| `boost::listS` | `std::list` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `boost::listS` | `std::list` |'
- en: '| `boost::slistS` | `std::slist` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `boost::slistS` | `std::slist` |'
- en: '| `boost::setS` | `std::set` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `boost::setS` | `std::set` |'
- en: '| `boost::multisetS` | `std::multiset` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multisetS` | `std::multiset` |'
- en: '| `boost::hash_setS` | `std::hash_set` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `boost::hash_setS` | `std::hash_set` |'
- en: The third template parameter is used to make an undirected, directed, or bidirectional
    graph. Use the `boost::undirectedS`, `boost::directedS`, and `boost::bidirectionalS`
    selectors respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个模板参数用于创建无向、有向或双向图。分别使用`boost::undirectedS`、`boost::directedS`和`boost::bidirectionalS`选择器。
- en: The fifth template parameter describes the datatype that will be used as the
    vertex. In our example, we chose `std::string`. We can also support a datatype
    for edges and provide it as a template parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个模板参数描述了将用作顶点的数据类型。在我们的例子中，我们选择了`std::string`。我们也可以支持边的数据类型，并将其作为模板参数提供。
- en: Steps 2 and 3 are trivial, but at step 4 you will see a non portable way to
    speed up graph construction. In our example, we use `std::vector` as a container
    for storing vertexes, so we can force it to reserve memory for the required amount
    of vertexes. This leads to less memory allocations/deallocations and copy operations
    during insertion of vertexes into the graph. This step is non-portable because
    it is highly dependent on the current implementation of `boost::adjacency_list`
    and on the chosen container type for storing vertexes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步和第3步是微不足道的，但在第4步，您将看到一种非可移植的方式来加快图构建。在我们的例子中，我们使用`std::vector`作为存储顶点的容器，因此我们可以强制它为所需数量的顶点保留内存。这导致在将顶点插入图时，内存分配/释放和复制操作更少。这一步是非可移植的，因为它高度依赖于`boost::adjacency_list`的当前实现以及存储顶点的所选容器类型。
- en: At step 4, we see how vertexes can be added to the graph. Note how `boost::graph_traits<graph_type>`
    has been used. The `boost::graph_traits` class is used to get types that are specific
    for a graph type. We'll see its usage and the description of some graph-specific
    types later in this chapter. Step 5 shows what we need do to connect vertexes
    with edges.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们看到如何将顶点添加到图中。注意`boost::graph_traits<graph_type>`的使用。`boost::graph_traits`类用于获取特定于图类型的类型。我们将在本章后面看到其用法和一些特定于图类型的描述。第5步展示了我们需要做什么来通过边连接顶点。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we had provided a datatype for the edges, adding an edge would look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了边的数据类型，添加边的样子如下：
- en: '`boost::add_edge(ansic, guru, edge_t(initialization_parameters), graph)`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::add_edge(ansic, guru, edge_t(initialization_parameters), graph)`'
- en: Note that at step 6 the graph type is a `template` parameter. This is recommended
    to achieve better code reusability and make this function work with other graph
    types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第6步中，图类型是一个`template`参数。这建议为了实现更好的代码重用并使此函数能够与其它图类型一起工作。
- en: At step 7, we see how to iterate over all of the vertexes of the graph. The
    type of vertex iterator is received from `boost::graph_traits`. The function `boost::tie`
    is a part of `Boost.Tuple` and is used for getting values from tuples to the variables.
    So calling `boost::tie(it, end) = boost::vertices(g)` will put the `begin` iterator
    into the `it` variable and the `end` iterator into the `end` variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步，我们看到如何遍历图中的所有顶点。顶点迭代器的类型来自`boost::graph_traits`。函数`boost::tie`是`Boost.Tuple`的一部分，用于从元组中获取值到变量中。因此，调用`boost::tie(it,
    end) = boost::vertices(g)`将`begin`迭代器放入`it`变量中，将`end`迭代器放入`end`变量中。
- en: It may come as a surprise to you, but dereferencing a vertex iterator does not
    return vertex data. Instead, it returns the vertex descriptor `desc`, which can
    be used in `boost::get(boost::vertex_bundle, g)[desc]` to get vertex data, just
    as we have done in step 8\. The vertex descriptor type is used in many of the
    `Boost.Graph` functions; we saw its use in the edge construction function in step
    5.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你感到惊讶，但顶点迭代器的解引用并不返回顶点数据。相反，它返回顶点描述符 `desc`，可以在 `boost::get(boost::vertex_bundle,
    g)[desc]` 中使用以获取顶点数据，就像我们在第 8 步中所做的那样。顶点描述符类型在许多 `Boost.Graph` 函数中使用；我们在第 5 步的边构造函数中看到了它的使用。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As already mentioned, the `Boost.Graph` library contains the implementation
    of many algorithms. You will find many search policies implemented, but we won't
    discuss them in this book. We will limit this recipe to only the basics of the
    graph library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Boost.Graph` 库包含了众多算法的实现。你将发现许多搜索策略已经实现，但在这本书中我们不会讨论它们。我们将仅限于介绍图库的基础知识。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Graph` library is not a part of C++11 and it won''t be a part of
    C++1y. The current implementation does not support C++11 features. If we are using
    vertexes that are heavy to copy, we may gain speed using the following trick:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Graph` 库不是 C++11 的一部分，也不会成为 C++1y 的一部分。当前的实现不支持 C++11 功能。如果我们使用的是难以复制的顶点，我们可以使用以下技巧来提高速度：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It avoids copy constructions of `boost::add_vertex(vertex_data, graph)` and
    uses the default construction with `move` assignment instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它避免了 `boost::add_vertex(vertex_data, graph)` 的复制构造，而是使用带有移动赋值的默认构造。
- en: The efficiency of `Boost.Graph` depends on multiple factors, such as the underlying
    containers types, graph representation, edge, and vertex datatypes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Graph` 的效率取决于多个因素，例如底层容器类型、图表示、边和顶点数据类型。'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Reading the *Visualizing graphs* recipe can help you work more easily with
    graphs. You may also consider reading its official documentation at the following
    link:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于 *可视化图* 的食谱可以帮助你更轻松地处理图。你也可以考虑阅读以下链接中的官方文档：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html](http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html](http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html)'
- en: Visualizing graphs
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化图
- en: 'Making programs that manipulate graphs was never easy because of issues with
    visualization. When we work with STL containers such as `std::map` and `std::vector`,
    we can always print the container''s contents and see what is going on inside.
    But when we work with complex graphs, it is hard to visualize the content in a
    clear way: too many vertexes and too many edges.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可视化问题，制作操作图的程序从未容易过。当我们使用 STL 容器，如 `std::map` 和 `std::vector` 时，我们总能打印容器的内容并查看内部发生的情况。但是，当我们处理复杂的图时，很难以清晰的方式可视化内容：顶点太多，边太多。
- en: In this recipe, we'll take a look at the visualization of `Boost.Graph` using
    the **Graphviz** tool.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨使用 **Graphviz** 工具对 `Boost.Graph` 的可视化。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To visualize graphs, you will need a Graphviz visualization tool. Knowledge
    of the preceding recipe is also required.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化图，你需要一个 Graphviz 可视化工具。还需要了解前面的食谱。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Visualization is done in two phases. In the first phase, we make our program
    output the graph's description in a text format; in the second phase, we import
    the output from the first step to some visualization tool. The numbered steps
    in this recipe are all about the first phase.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化分为两个阶段。在第一阶段，我们让程序以文本格式输出图的描述；在第二阶段，我们将第一步的输出导入到某个可视化工具中。本食谱中的编号步骤都是关于第一阶段的内容。
- en: 'Let''s write the `std::ostream` operator for `graph_type` as done in the preceding
    recipe:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像前一个食谱中那样为 `graph_type` 编写 `std::ostream` 操作符：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `detail::vertex_writer` structure, used in the preceding step, must be
    defined as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的步骤中使用到的 `detail::vertex_writer` 结构必须定义为以下内容：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s all. Now, if we visualize the graph from the previous recipe using
    the `std::cout << graph;` command, the output can be used to create graphical
    pictures using the `dot` command-line utility:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在，如果我们使用 `std::cout << graph;` 命令可视化前一个食谱中的图，输出可以被用来使用 `dot` 命令行工具创建图形图片：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command is depicted in the following figure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如图所示：
- en: '![How to do it...](img/4880OS_12_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4880OS_12_02.jpg)'
- en: We can also use the **Gvedit** or **XDot** programs for visualization if the
    command line frightens you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Boost.Graph` library contains function to output graphs in Graphviz (DOT)
    format. If we write `boost::write_graphviz(out, g)` with two parameters in step
    1, the function will output a graph picture with vertexes numbered from `0`. That's
    not very useful, so we provide an instance of the `vertex_writer` class that outputs
    vertex names.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in step 2, the format of output must be DOT, which is understood
    by the Graphviz tool. You may need to read the Graphviz documentation for more
    info about the DOT format.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to add some data to the edges during visualization, we need to provide
    an instance of the edge visualizer as a fourth parameter to `boost::write_graphviz`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 does not contain `Boost.Graph` or the tools for graph visualization. But
    you do not need to worry—there are a lot of other graph formats and visualization
    tools and `Boost.Graph` can work with plenty of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Working with graphs* recipe contains information about the construction
    of `Boost.Graphs`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find a lot of information about the DOT format and Graphviz at [http://www.graphviz.org/](http://www.graphviz.org/)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost's official documentation for the `Boost.Graph` library contains multiple
    examples and useful information, and can be found at [http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_](http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_)[contents.html](http://contents.html)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a true random number generator
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know of many examples of commercial products that use incorrect methods for
    getting random numbers. It's a shame that some companies still use `rand()` in
    cryptography and banking software.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to get a fully random uniform distribution using `Boost.Random`
    that is suitable for banking software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Knowledge of different types
    of distributions will also be helpful. The code in this recipe requires linking
    against the `boost_random` library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a true random number, we need some help from the operating system
    or processor. This is how it can be done using Boost:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to include the following headers:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Advanced random number providers have different names under different platforms:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we are ready to initialize the generator with `Boost.Random`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s get a uniform distribution that returns a value between 1000 and 65535:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. Now we can get true random numbers using the `random(device)` call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why does the `rand()` function not suit banking? Because it generates pseudo-random
    numbers, which means that the hacker could predict the next generated number.
    This is an issue with all pseudo-random number algorithms. Some algorithms are
    easier to predict and some harder, but it's still possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: That's why we are using `boost::random_device` in this example (see step 3).
    That device gathers information about random events from all around the operating
    system to construct an unpredictable hardware-generated number. The examples of
    such events are delays between pressed keys, delays between some of the hardware
    interruptions, and the internal CPU random number generator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在本例中使用 `boost::random_device`（参见第 3 步）。该设备从整个操作系统中收集关于随机事件的信息，以构建一个不可预测的硬件生成的数字。此类事件的例子包括按键之间的延迟、某些硬件中断之间的延迟以及内部
    CPU 随机数生成器。
- en: Operating systems may have more than one such type of random number generators.
    In our example for POSIX systems, we used `/dev/urandom` instead of the more secure
    `/dev/random` because the latter remains in a blocked state until enough random
    events have been captured by the OS. Waiting for entropy could take seconds, which
    is usually unsuitable for applications. Use `/dev/random` to create long-lifetime
    `GPG/SSL/SSH` keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可能拥有多个此类随机数生成器。在我们的 POSIX 系统示例中，我们使用了 `/dev/urandom` 而不是更安全的 `/dev/random`，因为后者在捕获足够的随机事件之前会保持阻塞状态。等待熵值可能需要几秒钟，这对于应用程序通常是不合适的。使用
    `/dev/random` 来创建长期有效的 `GPG/SSL/SSH` 密钥。
- en: Now that we are done with generators, it's time to move to step 4 and talk about
    distribution classes. If the generator just generates numbers (usually uniformly
    distributed), the distribution class maps one distribution to another. In step
    4, we made a uniform distribution that returns a random number of unsigned short
    type. The parameter `1000` means that distribution must return numbers greater
    or equal to `1000`. We can also provide the maximum number as a second parameter,
    which is by default equal to the maximum value storable in the return type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了生成器的设置，是时候进入第 4 步，讨论分布类。如果生成器只是生成数字（通常是均匀分布），分布类将一个分布映射到另一个。在第 4 步中，我们创建了一个均匀分布，它返回一个无符号短整型的随机数。参数
    `1000` 表示该分布必须返回大于或等于 `1000` 的数字。我们还可以提供一个最大数字作为第二个参数，默认情况下等于返回类型可以存储的最大值。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`Boost.Random` has a huge number of true/pseudo random generators and distributions
    for different needs. Avoid copying distributions and generators; this could turn
    out to be an expensive operation.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Random` 为不同的需求提供了大量的真/伪随机生成器和分布。避免复制分布和生成器；这可能会变成一个昂贵的操作。'
- en: C++11 has support for different distribution classes and generators. You will
    find all of the classes from this example in the `<random>` header in the `std::`
    namespace. The `Boost.Random` libraries do not use C++11 features, and they are
    not really required for that library either. Should you use Boost implementation
    or STL? Boost provides better portability across systems; however, some STL implementations
    may have assembly-optimized implementations and might provide some useful extensions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 支持不同的分布类和生成器。您将在 `std::` 命名空间中的 `<random>` 头文件中找到本示例中的所有类。`Boost.Random`
    库不使用 C++11 功能，并且对于该库来说也不是必需的。您应该使用 Boost 实现，还是 STL？Boost 提供了跨系统的更好可移植性；然而，某些 STL
    实现可能有汇编优化的实现，并可能提供一些有用的扩展。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The official documentation contains a full list of generators and distributions
    with descriptions; it is available at the following link:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含了一个完整的生成器和分布列表及其描述；它可在以下链接中找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html](http://www.boost.org/doc/libs/1_53_0/doc/html)
    [/boost_random.html](http:///boost_random.html)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html](http://www.boost.org/doc/libs/1_53_0/doc/html)
    [/boost_random.html](http:///boost_random.html)'
- en: Using portable math functions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可移植的数学函数
- en: Some projects require specific trigonometric functions, a library for numerically
    solving ordinary differential equations, and working with distributions and constants.
    All of those parts of `Boost.Math` would be hard to fit into even a separate book.
    A single recipe definitely won't be enough. So let's focus on very basic everyday-use
    functions to work with float types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目需要特定的三角函数、用于数值求解常微分方程的库以及与分布和常量一起工作。所有这些 `Boost.Math` 的部分都很难放入甚至是一本书中。一个单独的配方肯定是不够的。所以让我们专注于处理浮点类型的基本日常使用函数。
- en: We'll write a portable function that checks an input value for infinity and
    not-a-number (NaN) values and changes the sign if the value is negative.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个可移植的函数，用于检查输入值是否为无穷大和不是数字（NaN）值，并在值为负时更改其符号。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe. Those who know C99 standard
    will find a lot in common in this recipe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此食谱，需要具备 C++ 的基本知识。那些了解 C99 标准的人会发现本食谱中有许多共同之处。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to check the input value for infinity and NaN values
    and change the sign if the value is negative:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以检查输入值是否为无穷大和 NaN 值，并在值为负时更改符号：
- en: 'We''ll need the following headers:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Asserting for infinity and NaN can be done like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言无穷大和 NaN 可以这样做：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the following code to change the sign:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码来更改符号：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it! Now we can check that `check_float_inputs(std::sqrt(-1.0))` and `check_float_inputs(std::numeric_limits<double>::max()
    * 2.0)` will cause asserts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在我们可以检查 `check_float_inputs(std::sqrt(-1.0))` 和 `check_float_inputs(std::numeric_limits<double>::max()
    * 2.0)` 将导致断言。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Real types have specific values that cannot be checked using equality operators.
    For example, if the variable `v` contains NaN, `assert(v!=v)` may or may not pass
    depending on the compiler.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实数类型有特定的值，无法使用相等运算符进行检查。例如，如果变量 `v` 包含 NaN，`assert(v!=v)` 可能通过或不通过，这取决于编译器。
- en: For such cases, `Boost.Math` provides functions that can reliably check for
    infinity and NaN values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，`Boost.Math` 提供了可以可靠地检查无穷大和 NaN 值的函数。
- en: Step 3 contains the `boost::math::signbit` function, which requires clarification.
    This function returns a signed bit, which is 1 when the number is negative and
    0 when the number is positive. In other words, it returns `true` if the value
    is negative.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步包含 `boost::math::signbit` 函数，需要澄清。此函数返回一个有符号位，当数字为负时为 1，当数字为正时为 0。换句话说，如果值为负，则返回
    `true`。
- en: Looking at step 3 some readers might ask, "Why can't we just multiply by `-1`
    instead of calling `boost::math::changesign`?". We can. But multiplication may
    work slower than `boost::math::changesign` and won't work for special values.
    For example, if your code can work with `nan`, the code in step 3 will be able
    to change the sign of `-nan` and write `nan` to the variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看到第 3 步，一些读者可能会问：“为什么我们不能直接乘以 `-1` 而不是调用 `boost::math::changesign`？”。我们可以。但是乘法可能比
    `boost::math::changesign` 慢，并且对于特殊值不起作用。例如，如果你的代码可以处理 `nan`，第 3 步中的代码将能够改变 `-nan`
    的符号并将 `nan` 写入变量。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Boost.Math` library maintainers recommend wrapping math functions from
    this example in round parenthesis to avoid collisions with C macros. It is better
    to write `(boost::math::isinf)(value)` instead of `boost::math::isinf(value)`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Math` 库维护者建议将此示例中的数学函数用圆括号括起来，以避免与 C 宏冲突。最好写成 `(boost::math::isinf)(value)`
    而不是 `boost::math::isinf(value)`。'
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C99 contains all of the functions described in this recipe. Why do we need them
    in Boost? Well, some compiler vendors think that programmers do not need them,
    so you won't find them in one very popular compiler. Another reason is that the
    `Boost.Math` functions canbe used for classes that behave like numbers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C99 包含了本食谱中描述的所有函数。为什么在 Boost 中需要它们呢？嗯，一些编译器供应商认为程序员不需要它们，所以你不会在一个非常流行的编译器中找到它们。另一个原因是
    `Boost.Math` 函数可以用于像数字一样行为的类。
- en: '`Boost.Math` is a very fast, portable, reliable library.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Math` 是一个非常快速、便携、可靠的库。'
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Boost's official documentation contains lots of interesting examples and tutorials
    that will help you get used to `Boost.Math`; browse to [http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含许多有趣的示例和教程，这些可以帮助你熟悉 `Boost.Math`；浏览到 [http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html)
- en: Writing test cases
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: This recipe and the next one are devoted to auto-testing the `Boost.Test` library,
    which is used by many Boost libraries. Let's get hands-on with it and write some
    tests for our own class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱和下一个食谱致力于自动测试 `Boost.Test` 库，该库被许多 Boost 库使用。让我们动手实践，为我们的类编写一些测试。
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe. The code of this recipe
    requires linking against the static version of the `boost_unit_test_framework`
    library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此食谱，需要具备 C++ 的基本知识。本食谱的代码需要链接到 `boost_unit_test_framework` 库的静态版本。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To be honest, there is more than one test library in Boost. We'll take a look
    at the most functional one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，Boost 中有不止一个测试库。我们将查看功能最强大的一款。
- en: 'To use it, we''ll need to define the macro and include the following header:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用它，我们需要定义宏并包含以下头文件：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each set of tests must be written in the test case:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每组测试都必须在测试用例中编写：
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Checking some function for the `true` result is done as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查某个函数是否返回`true`的结果如下：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Checking for nonequality is implemented in the following way:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查不等性的实现方式如下：
- en: '[PRE23]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Checking for an exception being thrown will look like this:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查抛出异常的代码如下：
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's it! After compilation and linking, we'll get an executable file that
    automatically tests `foo` and outputs test results in a human-readable format.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！编译和链接后，我们将得到一个可执行文件，该文件将自动测试`foo`并以人类可读的格式输出测试结果。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Writing unit tests is easy; you know how the function works and what result
    it should produce in specific situations. So you just check if the expected result
    is the same as the function's actual output. That's what we did in step 3\. We
    know that `f1.is_not_null()` will return `true` and we checked it. At step 4,
    we know that `f1` is not equal to `f2`, so we checked it too. The call to `f1.throws()`
    will produce the `std::logic_error` exception and we check that an exception of
    the expected type is thrown.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试很容易；你知道函数是如何工作的，以及在特定情况下它应该产生什么结果。所以你只需检查预期的结果是否与函数的实际输出相同。这就是我们在步骤3中所做的。我们知道`f1.is_not_null()`将返回`true`，并进行了检查。在步骤4中，我们知道`f1`不等于`f2`，因此也进行了检查。调用`f1.throws()`将产生`std::logic_error`异常，并检查是否抛出了预期类型的异常。
- en: 'At step 2, we are making a test case – a set of checks to validate correct
    behavior of the `foo` structure. We can have multiple test cases in a single source
    file. For example, if we add the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们正在创建一个测试用例——一组检查以验证`foo`结构的正确行为。在单个源文件中我们可以有多个测试用例。例如，如果我们添加以下代码：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code will run along with the `test_no_1` test case. The parameter passed
    to the `BOOST_AUTO_TEST_CASE` macro is just a unique name of the test case that
    will be shown in case of error.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将与`test_no_1`测试用例一起运行。传递给`BOOST_AUTO_TEST_CASE`宏的参数只是测试用例的唯一名称，在出错时会显示。
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is a small difference between the `BOOST_REQUIRE_*` and `BOOST_CHECK_*`
    macros. If the `BOOST_REQUIRE_*` macro check fails, the execution of the current
    test case will stop and `Boost.Test` will run the next test case. However, failing
    `BOOST_CHECK_*` won't stop the execution of the current test case.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_REQUIRE_*`和`BOOST_CHECK_*`宏之间有一个小的区别。如果`BOOST_REQUIRE_*`宏检查失败，当前测试用例的执行将停止，`Boost.Test`将运行下一个测试用例。然而，失败的`BOOST_CHECK_*`不会停止当前测试用例的执行。'
- en: Step 1 requires additional care. Note the `BOOST_TEST_MODULE` macro definition.
    This macro must be defined before including the `Boost.Test` headers, otherwise
    linking of the program will fail. More information can be found in the *See also*
    section of this recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1需要额外的注意。注意`BOOST_TEST_MODULE`宏定义。这个宏必须在包含`Boost.Test`头文件之前定义，否则程序链接将失败。更多信息可以在本食谱的“也见”部分找到。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some readers may wonder, "Why did we write `BOOST_CHECK_NE(f1, f2)` in step
    4 instead of `BOOST_CHECK(f1 != f2)`?". The answer is simple: the macro at step
    4 provides a more readable and verbose output.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想，“为什么我们在步骤4中写`BOOST_CHECK_NE(f1, f2)`而不是`BOOST_CHECK(f1 != f2)`？”答案很简单：步骤4中的宏提供了更易读和更详细的输出。
- en: C++11 lacks support for unit testing. However, the `Boost.Test` library can
    be used to test C++11 code. Remember that the more tests you have, the more reliable
    code you get!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C++11缺乏对单元测试的支持。然而，可以使用`Boost.Test`库来测试C++11代码。记住，你拥有的测试越多，你得到的代码就越可靠！
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: The *Combining multiple test cases in one test module* recipe contains more
    information about testing and the `BOOST_TEST_MODULE` macro
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在一个测试模块中组合多个测试用例”食谱中包含有关测试和`BOOST_TEST_MODULE`宏的更多信息
- en: 'Refer to Boost''s official documentation for a full list of test macros and
    information about advanced features of `Boost.Test`; it''s available at the following
    link:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Boost的官方文档以获取完整的测试宏列表和`Boost.Test`高级特性的信息；它可在以下链接中找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html)'
- en: Combining multiple test cases in one test module
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个测试模块中组合多个测试用例
- en: Writing auto tests is good for your project. But managing test cases is hard
    when the project is large and many developers are working on it. In this recipe,
    we'll take a look at how to run individual tests and how to combine multiple test
    cases in a single module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that two developers are testing the `foo` structure declared in
    the `foo.hpp` header and we wish to give them separate source files to write a
    test to. In that way, the developers won't bother each other and can work in parallel.
    However, the default test run must execute the tests of both developers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. This recipe partially reuses
    code from the previous recipe and it also requires linking against the static
    version of the `boost_unit_test_framework` library.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the code from the previous one. This is a very useful recipe
    for testing large projects; do not underestimate it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the headers in `main.cpp` from the previous recipe, leave only these
    two lines:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s move the tests cases from the previous example into two different source
    files:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's it! Thus compiling and linking all of the sources and both test cases
    will work on program execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the magic is done by the `BOOST_TEST_MODULE` macro. If it is defined
    before `<boost/test/unit_test.hpp>`, `Boost.Test` thinks that this source file
    is the main one and all of the helper testing infrastructure must be placed in
    it. Otherwise, only the test macro will be included from `<boost/test/unit_test.hpp>`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: All of the `BOOST_AUTO_TEST_CASE` tests are run if you link them with the source
    file that contains the `BOOST_TEST_MODULE` macro. When working on a big project,
    each developer may enable compilation and linking of only their own sources. That
    gives independence from other developers and increases the speed of development—no
    need to compile alien sources and run alien tests while debugging.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Boost.Test` library is good because of its ability to run tests selectively.
    We can choose which tests to run and pass them as command-line arguments. For
    example, the following command will run only the `test_no_1` test case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following command will run two test cases:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately, C++11 standard does not have built-in testing support and it
    looks like C++1y won't adopt the classes and methods of `Boost.Test` either.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing test cases* recipe contains more information about the `Boost.Test`
    library. Read Boost's official documentation for more information about `Boost.Test`,
    at [http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/utf.html](http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/utf.html).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brave readers can take a look at some of the test cases from the Boost library.
    Those test cases are allocated in the `libs` subfolder located in the `boost`
    folder. For example, `Boost.LexicalCast` tests cases are allocated at `boost_1_53_0\libs\conversion\test`.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating images
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作图像
- en: I've left you something really tasty for dessert – Boost's **Generic Image Library**
    (**GIL**), which allows you to manipulate images and not care much about image
    formats.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你留了一些真正美味的东西作为甜点——Boost的**通用图像库**（**GIL**），它允许你操作图像而无需过多关注图像格式。
- en: Let's do something simple and interesting with it; let's make a program that
    negates any picture.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它做一些简单而有趣的事情；让我们写一个程序，将任何图片取反。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires basic knowledge of C++, templates, and `Boost.Variant`.
    The example requires linking against the PNG library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++、模板和`Boost.Variant`知识。示例需要链接PNG库。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: For simplicity, we'll be working with only PNG images.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将只处理PNG图像。
- en: 'Let''s start with including the header files:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含头文件开始：
- en: '[PRE31]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we need to define the image types that we wish to work with:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们希望与之工作的图像类型：
- en: '[PRE32]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Opening an existing PNG image can be implemented like this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式实现打开现有PNG图像：
- en: '[PRE33]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to apply the operation to the picture as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将操作应用于图片，如下所示：
- en: '[PRE34]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code line will help you to write an image:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行将帮助你写入图像：
- en: '[PRE35]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s take a look at the modifying operation:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看修改操作：
- en: '[PRE36]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The body of `operator()` consists of getting a channel type:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`operator()`的主体包括获取通道类型：'
- en: '[PRE37]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It also iterates through pixels:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它也遍历像素：
- en: '[PRE38]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s see the results of our program:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们程序的结果：
- en: '![How to do it...](img/4880OS_12_01.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4880OS_12_01.jpg)'
- en: 'The previous picture is the negative of the one that follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片是下一张图片的负片：
- en: '![How to do it...](img/4880OS_12_03.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4880OS_12_03.jpg)'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 2, we are describing the types of images we wish to work with. Those
    images are gray images with 8 and 16 bits per pixel and RGB pictures with 8 and
    16 bits per pixel.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们正在描述我们希望与之工作的图像类型。这些图像是每像素8位和16位的灰度图像以及每像素8位和16位的RGB图片。
- en: The `boost::gil::any_image<img_types>` class is a kind of `Boost.Variant` that
    can hold an image of one of the `img_types` variable. As you may have already
    guessed, `boost::gil::png_read_image` reads images into image variables.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::gil::any_image<img_types>`类是一种`Boost.Variant`，可以持有`img_types`变量之一的图像。正如你可能已经猜到的，`boost::gil::png_read_image`将图像读取到图像变量中。'
- en: The `boost::gil::apply_operation` function at step 4 is almost equal to `boost::apply_visitor`
    from the `Boost.Variant` library. Note the usage of `view(source)`. The `boost::gil::view`
    function constructs a light wrapper around the image that interprets it as a two-dimensional
    array of pixels.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步中的`boost::gil::apply_operation`函数几乎等于`Boost.Variant`库中的`boost::apply_visitor`。注意`view(source)`的使用。`boost::gil::view`函数在图像周围构建一个轻量级包装器，将其解释为二维像素数组。
- en: Do you remember that for `Boost.Variant` we were deriving visitors from `boost::static_visitor`?
    When we are using GIL's version of variant, we need to make a `result_type` typedef
    inside `visitor`. You can see it in step 6.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们为`Boost.Variant`从`boost::static_visitor`派生访问者吗？当我们使用GIL的变体版本时，我们需要在`visitor`内部创建一个`result_type`类型定义。你可以在第6步中看到它。
- en: 'A little bit of theory: images consist of points called pixels. Single images
    have pixels of the same type. However, pixels of different images can differ in
    channel count and color bits for a single channel. A channel represents a primary
    color. In the case of an RGB image, we''ll have a pixel consisting of three channels—red,
    green, and blue. In the case of a gray image, we''ll have a single channel representing
    gray.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一点理论：图像由称为像素的点组成。单个图像具有相同类型的像素。然而，不同图像的像素可能在通道数和单通道颜色位上有所不同。通道表示一种主颜色。在RGB图像的情况下，我们将有一个由三个通道组成的像素——红色、绿色和蓝色。在灰度图像的情况下，我们将有一个表示灰度的单个通道。
- en: Back to our image. In step 2, we described the types of images we wish to work
    with. In step 3, one of those image types is read from file and stored in the
    source variable. In step 4, the `operator()` method of the `negate` visitor is
    instantiated for all image types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的图像。在第2步中，我们描述了我们希望与之工作的图像类型。在第3步中，其中一种图像类型从文件中读取并存储在源变量中。在第4步中，为所有图像类型实例化了`negate`访问者的`operator()`方法。
- en: In step 7, we can see how to get the channel type from the image view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，我们可以看到如何从图像视图中获取通道类型。
- en: In step 8, we iterate through pixels and channels and negate them. Negation
    is done via `max_val - source(x, y)[c]` and the result is written back to the
    image view.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们遍历像素和通道并将它们取反。取反是通过`max_val - source(x, y)[c]`完成的，并将结果写回图像视图。
- en: We write an image back in step 5.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在步骤5中写回一个图像。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has no built-in methods for working with images.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有内置处理图像的方法。
- en: The `Boost.GIL` library is fast and efficient. The compilers optimize its code
    very well and we can even help the optimizer using some of the `Boost.GIL` methods
    to unroll loops. But this chapter talks about only some of the library basics,
    so it is time to stop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.GIL`库运行速度快且效率高。编译器对其代码进行了很好的优化，我们甚至可以使用一些`Boost.GIL`方法来帮助优化器展开循环。但本章只讨论了库的一些基础知识，所以现在是时候停止了。'
- en: See also
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: More information about `Boost.GIL` can be found at Boost's official documentation;
    go to [http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`Boost.GIL`的更多信息可以在Boost的官方文档中找到；请访问[http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html)
- en: See the *Storing multiple chosen types in a variable/container* recipe in [Chapter
    1](ch01.html "Chapter 1. Starting to Write Your Application"), *Starting to Write
    Your Application*, for more information about the `Boost.Variant` library
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第1章](ch01.html "第1章。开始编写您的应用程序")中的*在变量/容器中存储多个选定的类型*配方，以获取有关`Boost.Variant`库的更多信息
