- en: Allocators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配器
- en: We've seen in the preceding chapters that C++ has a love-hate relationship with
    dynamic memory allocation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中看到，C++对动态内存分配有着爱恨交加的关系。
- en: On one hand, dynamic memory allocation from the heap is a "code smell"; chasing
    pointers can hurt a program's performance, the heap can be exhausted unexpectedly
    (leading to exceptions of type `std::bad_alloc`), and manual memory management
    is so subtly difficult that C++11 introduced several different "smart pointer"
    types to manage the complexity (see [Chapter 6](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d),
    *Smart Pointers*). Successive versions of C++ after 2011 have also added a great
    number of non-allocating algebraic data types, such as `tuple`, `optional`, and
    `variant` (see [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*) that can express ownership or containment without ever touching
    the heap.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，从堆中进行动态内存分配是一种“代码异味”；追逐指针可能会损害程序的性能，堆可能会意外耗尽（导致`std::bad_alloc`类型的异常），手动内存管理是如此微妙地困难，以至于C++11引入了多种不同的“智能指针”类型来管理复杂性（参见[第6章](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d)，*智能指针*）。2011年之后的C++连续版本也添加了大量的非分配代数数据类型，如`tuple`、`optional`和`variant`（参见[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，*词汇类型*），这些类型可以在不接触堆的情况下表达所有权或包含关系。
- en: On the other hand, the new smart pointer types do effectively manage the complexity
    of memory management; in modern C++ you can safely allocate and deallocate memory
    without ever using raw `new` or `delete` and without fear of memory leaks. And
    heap allocation is used "under the hood" of many of the new C++ features (`any`,
    `function`, `promise`) just as it continues to be used by many of the old ones
    (`stable_partition`, `vector`).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，新的智能指针类型确实有效地管理了内存管理的复杂性；在现代C++中，你可以安全地分配和释放内存，而无需使用原始的`new`或`delete`，也无需担心内存泄漏。并且堆分配在许多新的C++特性（`any`、`function`、`promise`）的“幕后”使用，就像它继续被许多旧特性（`stable_partition`、`vector`）使用一样。
- en: 'So there''s a conflict here: How can we use these great new features (and the
    old ones) that depend on heap allocation, if we are simultaneously being told
    that good C++ code avoids heap allocation?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里存在冲突：如果我们被告知好的C++代码应避免堆分配，我们如何使用这些伟大的新特性（以及旧特性）呢，这些特性依赖于堆分配？
- en: 'In most cases, you should err on the side of *using the features that C++ provides*.
    If you want a resizeable vector of elements, you *should* be using the default
    `std::vector`, unless you have measured an actual performance problem with using
    it in your case. But there also exists a class of programmers--working in very
    constrained environments such as flight software--who have to avoid touching the
    heap for a very simple reason: "the heap" does not exist on their platforms! In
    these embedded environments, the entire footprint of the program must be laid
    out at compile time. Some such programs simply avoid any algorithm that resembles
    heap allocation--you can never encounter unexpected resource exhaustion if you
    never dynamically allocate resources of any kind! Other such programs do use algorithms
    resembling heap allocation, but require that the "heap" be represented explicitly
    in their program (say, by a very large array of `char` and functions for "reserving"
    and "returning" consecutive chunks of that array).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该偏向于*使用C++提供的特性*。如果你想有一个可调整大小的元素向量，你应该使用默认的`std::vector`，除非你在你的情况下测量了使用它的实际性能问题。但也存在一类程序员——在非常受限的环境中工作，如飞行软件——他们必须避免接触堆，原因很简单：“堆”在他们的平台上不存在！在这些嵌入式环境中，整个程序的整个占用空间必须在编译时确定。有些这样的程序简单地避免任何类似于堆分配的算法——如果你从未动态分配任何类型的资源，你永远不会遇到意外的资源耗尽！其他这样的程序虽然使用类似于堆分配的算法，但要求在他们的程序中显式表示“堆”（比如说，通过一个非常大的`char`数组以及用于“保留”和“返回”该数组连续块的功能）。
- en: It would be extremely unfortunate if programs of this last kind were unable
    to use the features that C++ provides, such as `std::vector` and `std::any`. So,
    ever since the original standard in 1998, the standard library has provided a
    feature known as *allocator-awareness*. When a type or an algorithm is *allocator-aware*,
    it provides a way for the programmer to specify exactly how the type or algorithm
    ought to reserve and return dynamic memory. This "how" is reified into an object
    known as an *allocator*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这类程序无法使用C++提供的功能，如`std::vector`和`std::any`，那将极其不幸。因此，自从1998年的原始标准以来，标准库就提供了一种称为“分配器感知”的功能。当一个类型或算法是“分配器感知”的，它为程序员提供了一种指定类型或算法应该如何保留和返回动态内存的方法。这个“如何”被具体化为一个称为“分配器”的对象。
- en: 'In this chapter we''ll learn:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: The definitions of "allocator" and "memory resource"
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “分配器”和“内存资源”的定义
- en: How to create your own memory resource that allocates out of a static buffer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建自己的内存资源，该资源从静态缓冲区中分配
- en: How to make your own containers "allocator-aware"
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使自己的容器“分配器感知”
- en: The standard memory-resource types from namespace `std::pmr`, and their surprising
    pitfalls
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间`std::pmr`中的标准内存资源类型及其令人惊讶的陷阱
- en: That many of the strange features of the C++11 allocator model are intended
    purely to support `scoped_allocator_adaptor`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11分配器模型中的许多奇怪特性纯粹是为了支持`scoped_allocator_adaptor`
- en: What makes a type a "fancy pointer" type, and where such types might be useful
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使一个类型成为“花哨指针”类型，以及这种类型可能在何处有用
- en: An allocator is a handle to a memory resource
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配器是内存资源的句柄
- en: 'In reading this chapter, you''ll have to keep in mind the difference between
    two fundamental concepts, which I am going to call *memory resource* and *allocator*.
    A *memory resource* (a name inspired by the standard''s own terminology--you might
    find it more natural to call it "a heap") is a long-lived object that can dole
    out chunks of memory on request (usually by carving them out of a big block of
    memory that is owned by the memory resource itself). Memory resources have classically
    object-oriented semantics (see [Chapter 1](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d),
    *Classical Polymorphism and Generic Programming*): you create a memory resource
    once and never move or copy it, and equality for memory resources is generally
    defined by *object identity*. On the other hand, an *allocator* is a short-lived
    handle *pointing* to a memory resource. Allocators have pointer semantics: you
    can copy them, move them around, and generally mess with them as much as you want,
    and equality for allocators is generally defined by whether they point to the
    same memory resource. Instead of saying an allocator "points to" a particular
    memory resource, we might also say that the allocator is "backed by" that memory
    resource; the terms are interchangeable.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，你必须牢记两个基本概念之间的区别，我将称它们为“内存资源”和“分配器”。一个“内存资源”（一个受标准自身术语启发的名字——你可能更愿意称它为“堆”）是一个长期存在的对象，可以在请求时分配内存块（通常是通过从内存资源本身拥有的一个大内存块中切割出来）。内存资源具有经典的面向对象语义（参见[第1章](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d)，*经典多态和泛型编程*）：你创建一个内存资源一次，永远不会移动或复制它，内存资源的相等性通常由*对象身份*定义。另一方面，一个“分配器”是一个指向内存资源的短暂句柄。分配器具有指针语义：你可以复制它们，移动它们，并且通常可以随意操作它们，分配器的相等性通常由它们是否指向相同的内存资源来定义。我们可以说分配器“指向”特定的内存资源，我们也可以说分配器“由”那个内存资源“支持”；这两个术语可以互换使用。
- en: When I talk about "memory resources" and "allocators" in this chapter, I will
    be talking about the preceding concepts. The standard library also has a couple
    of types named `memory_resource` and `allocator`; whenever I'm talking about those
    types I'll be careful to use `typewriter text`. It shouldn't be too confusing.
    The situation is similar to [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*, where we talked about "iterators" and also about `std::iterator`.
    Of course that was easier because I only mentioned `std::iterator` in order to
    tell you never to use it; it has no place in well-written C++ code. In this chapter
    we'll learn that `std::pmr::memory_resource` *does* have a place in certain C++
    programs!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在本章中谈论“内存资源”和“分配器”时，我将谈论前面的概念。标准库还有一些名为`memory_resource`和`allocator`的类型；每当我谈论这些类型时，我会小心地使用`打字机文本`。这不应该太令人困惑。情况与[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，“迭代器和范围”相似，在那里我们谈论了“迭代器”以及`std::iterator`。当然，那更容易，因为我只提到`std::iterator`是为了告诉你永远不要使用它；它在良好的C++代码中没有任何位置。在本章中，我们将了解到`std::pmr::memory_resource`在特定的C++程序中确实有它的位置！
- en: Even though I described an allocator as a handle "pointing to" a memory resource,
    you should notice that sometimes the memory resource in question is a global singleton--one
    example of such a singleton is the global heap, whose accessors are the global
    `operator new` and `operator delete`. Just as a lambda which "captures" a global
    variable doesn't actually capture anything, an allocator backed by the global
    heap doesn't actually need any state. In fact, `std::allocator<T>` is just such
    a stateless allocator type--but we're getting ahead of ourselves here!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我描述了分配器为一个“指向”内存资源的句柄，但你应该注意到，有时所涉及的内存资源是一个全局单例——这类单例的一个例子是全局堆，其访问器是全局的`operator
    new`和`operator delete`。就像一个“捕获”全局变量的lambda实际上并没有捕获任何东西一样，由全局堆支持的分配器实际上不需要任何状态。事实上，`std::allocator<T>`就是这样一种无状态的分配器类型——但我们在这里跑题了！
- en: Refresher - Interfaces versus concepts
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习 - 接口与概念
- en: Recall from [Chapter 1](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d),
    *Classical Polymorphism and Generic Programming*, that C++ offers two mostly incompatible
    ways of dealing with polymorphism. Static, compile-time polymorphism is called
    *generic programming*; it relies on expressing the polymorphic interface as a
    *concept* with many possible *models*, and the code that interacts with the interface
    is expressed in terms of *templates*. Dynamic, runtime polymorphism is called
    *classical polymorphism*; it relies on expressing the polymorphic interface as
    a *base class* with many possible *derived classes*, and the code that interacts
    with the interface is expressed in terms of calls to *virtual methods*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d)，“经典多态与泛型编程”中回忆起，C++提供了两种主要不兼容的处理多态的方法。静态、编译时多态被称为*泛型编程*；它依赖于将多态接口表达为一个*概念*，具有许多可能的*模型*，与接口交互的代码以*模板*的形式表达。动态、运行时多态被称为*经典多态*；它依赖于将多态接口表达为一个*基类*，具有许多可能的*派生类*，与接口交互的代码以对*虚函数*的调用形式表达。
- en: 'In this chapter we''ll have our first (and last) really close encounter with
    generic programming. It is impossible to make sense of C++ allocators unless you
    can hold in your mind two ideas at once: on one hand the *concept* `Allocator`,
    which defines an interface, and on the other hand some particular *model*, such
    as `std::allocator`, that implements behavior conforming to the `Allocator` concept.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将第一次（也是最后一次）真正接近泛型编程。除非你能够同时记住两个想法，否则无法理解C++的分配器：一方面是定义接口的*概念* `Allocator`，另一方面是某些特定的*模型*，例如`std::allocator`，它实现了符合`Allocator`概念的行为。
- en: To complicate matters further, the `Allocator` concept is really a templated
    family of concepts! It would be more accurate to talk about the family of concepts
    `Allocator<T>`; for example, `Allocator<int>` would be the concept defining "an
    allocator that allocates `int` objects," and `Allocator<char>` would be "an allocator
    that allocates `char` objects," and so on. And, for example, the concrete class
    `std::allocator<int>` is a model of the concept `Allocator<int>`, but it is *not*
    a model of `Allocator<char>`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化问题，`Allocator`概念实际上是一个模板化的概念家族！更准确地说，我们应该谈论概念家族`Allocator<T>`；例如，`Allocator<int>`将是定义“分配`int`对象的分配器”的概念，而`Allocator<char>`将是“分配`char`对象的分配器”，等等。例如，具体的类`std::allocator<int>`是概念`Allocator<int>`的一个模型，但它不是`Allocator<char>`的模型。
- en: 'Every allocator of `T` (every `Allocator<T>`) is required to provide a member
    function named `allocate`, such that `a.allocate(n)` returns a pointer to enough
    memory for an array of `n` objects of type `T`. (That pointer will come from the
    memory resource that backs the allocator instance.) It is not specified whether
    the `allocate` member function ought to be static or non-static, nor whether it
    ought to take exactly one parameter (`n`) or perhaps some additional parameters
    with default values. So both of the following class types would be acceptable
    models of `Allocator<int>` in that respect:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型`T`的分配器（每个`Allocator<T>`）都必须提供一个名为`allocate`的成员函数，以便`a.allocate(n)`返回足够内存的指针，用于存储类型为`T`的`n`个对象的数组。（该指针将来自支持分配器实例的内存资源。）没有指定`allocate`成员函数应该是静态的还是非静态的，也没有指定它应该恰好接受一个参数（`n`）或者可能接受一些具有默认值的附加参数。因此，以下两种类类型在这一点上都是`Allocator<int>`的可接受模型：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class designated `int_allocator_2017` is obviously a *simpler* way to model
    `Allocator<int>`, but `int_allocator_2014` is just as correct a model, because
    in both cases the expression `a.allocate(n)` will be accepted by the compiler;
    and that's all we ask for, when we're talking about *generic programming*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类别名为`int_allocator_2017`显然是建模`Allocator<int>`的*更简单*方法，但`int_allocator_2014`也是一个正确的模型，因为在两种情况下，表达式`a.allocate(n)`都将被编译器接受；这就是我们在谈论*泛型编程*时所要求的一切。
- en: 'In contrast, when we do classical polymorphism, we specify a fixed signature
    for each method of the base class, and derived classes are not allowed to deviate
    from that signature:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当我们进行经典多态时，我们为基类的每个方法指定一个固定的签名，并且不允许派生类偏离该签名：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The derived class `classical_derived` is not allowed to add any extra parameters
    onto the signature of the `allocate` method; it's not allowed to change the return
    type; it's not allowed to make the method `static`. The interface is more "locked
    down" with classical polymorphism than it is with generic programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类`classical_derived`不允许在`allocate`方法的签名上添加任何额外的参数；不允许更改返回类型；不允许使方法`static`。与泛型编程相比，接口在经典多态中更加“锁定”。
- en: Because a "locked-down" classical interface is naturally easier to describe
    than a wide-open conceptual one, we'll start our tour of the allocator library
    with C++17's brand-new, classically polymorphic `memory_resource`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“锁定”的经典接口自然比开放的抽象接口更容易描述，因此我们将从C++17的全新、经典多态的`memory_resource`开始我们的分配器库之旅。
- en: Defining a heap with memory_resource
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`memory_resource`定义堆
- en: 'Recall that on resource-constrained platforms, we might not be permitted to
    use "the heap" (for example via `new` and `delete`), because the platform''s runtime
    might not support dynamic memory allocation. But we can make our own little heap--not
    "the heap," just "a heap"--and simulate the effect of dynamic memory allocation
    by writing a couple of functions `allocate` and `deallocate` that reserve chunks
    of a big statically allocated array of `char`, something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在资源受限的平台，我们可能不允许使用“堆”（例如通过`new`和`delete`），因为平台的运行时可能不支持动态内存分配。但我们可以创建自己的小堆——不是“堆”，而是“一个堆”——并通过编写几个函数`allocate`和`deallocate`来模拟动态内存分配的效果，这些函数保留了一个大静态分配的`char`数组的一部分，类似于这样：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To keep the code as simple as possible, I made `deallocate` a no-op. This little
    heap allows the caller to allocate up to 10,000 bytes of memory, and then starts
    throwing `bad_alloc` from then on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码尽可能简单，我将`deallocate`设为无操作。这个小堆允许调用者分配最多10,000字节的内存，然后从此开始抛出`bad_alloc`异常。
- en: 'With a little more investment in the code, we can allow the caller to allocate
    and deallocate an infinite number of times, as long as the total outstanding amount
    of allocated memory doesn''t exceed 10,000 bytes and as long as the caller always
    follows a "last-allocated-first-deallocated" protocol:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码上投入更多，我们可以允许调用者无限次地分配和释放内存，只要分配的内存总量不超过10,000字节，并且只要调用者始终遵循“最后分配的先释放”的协议：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The salient point here is that our heap has some *state* (in this case, `big_buffer`
    and `index`), and a couple of functions that manipulate this state. We've seen
    two different possible implementations of `deallocate` already--and there are
    other possibilities, with additional shared state, that wouldn't be so "leaky"--yet
    the interface, the signatures of `allocate` and `deallocate` themselves, has remained
    constant. This suggests that we could wrap up our state and accessor functions
    into a C++ object; and the wide variety of implementation possibilities plus the
    constancy of our function signatures suggests that we could use some classical
    polymorphism.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里突出的点是，我们的堆有一些*状态*（在这种情况下，`big_buffer`和`index`），以及一些操作这个状态的函数。我们已经看到了`deallocate`的两种不同可能的实现——还有其他可能性，有额外的共享状态，不会那么“漏斗”——然而，接口，`allocate`和`deallocate`函数签名的本身，却保持不变。这表明我们可以将我们的状态和访问函数包装到一个C++对象中；广泛的实现可能性加上我们函数签名的恒定性表明，我们可以使用一些经典的多态。
- en: 'The C++17 allocator model does exactly that. The standard library provides
    the definition of a classically polymorphic base class, `std::pmr::memory_resource`,
    and then we implement our own little heap as a derived class. (In practice we
    might use one of the derived classes provided by the standard library, but let''s
    finish up our little example before talking about those.) The base class `std::pmr::memory_resource`
    is defined in the standard header `<memory_resource>`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C++17分配器模型正是如此。标准库提供了一个经典多态的基类定义，`std::pmr::memory_resource`，然后我们实现我们自己的小堆作为派生类。（在实践中，我们可能会使用标准库提供的派生类之一，但在讨论这些之前，让我们完成我们的小例子。）基类`std::pmr::memory_resource`在标准头文件`<memory_resource>`中定义：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice the curious layer of indirection between the `public` interface of the
    class and the `virtual` implementation. Usually when we''re doing classical polymorphism,
    we have just one set of methods that are both `public` and `virtual`; but in this
    case, we have a `public` non-virtual interface that calls down into the private
    virtual methods. This splitting of the interface from the implementation has a
    few obscure benefits--for example, it prevents any child class from invoking `this->SomeBaseClass::allocate()`
    using the "directly invoke a virtual method non-virtually" syntax--but honestly,
    its main benefit to us is that when we define a derived class, we don''t have
    to use the `public` keyword at all. Because we are specifying only the *implementation*,
    not the interface, all the code we write can be `private`. Here''s our trivial
    little leaky heap:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到类`public`接口和`virtual`实现之间的奇特间接层。通常当我们进行经典的多态时，我们只有一组既是`public`又是`virtual`的方法；但在这个例子中，我们有一个`public`非虚拟接口，它调用到私有的虚拟方法。这种将接口从实现中分离出来的做法带来了一些微妙的好处——例如，它防止任何子类使用“直接调用虚拟方法非虚拟”的语法来调用`this->SomeBaseClass::allocate()`——但老实说，它对我们来说的主要好处是，当我们定义一个派生类时，我们根本不需要使用`public`关键字。因为我们只指定了*实现*，而不是接口，所以我们写的所有代码都可以是`private`的。这就是我们的微不足道的漏斗堆：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the standard library's `std::pmr::memory_resource::allocate` takes
    not only a size in bytes, but also an alignment. We need to make sure that whatever
    pointer we return from `do_allocate` is suitably aligned; for example, if our
    caller is planning to store `int` in the memory we give him, he might ask for
    four-byte alignment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到标准库的`std::pmr::memory_resource::allocate`不仅接受字节数，还接受对齐方式。我们需要确保从`do_allocate`返回的任何指针都适当地对齐；例如，如果我们的调用者计划在我们的提供的内存中存储`int`，他可能会要求四字节对齐。
- en: 'The last thing to notice about our derived class `example_resource` is that
    it represents the actual resources controlled by our "heap"; that is, it actually
    contains, owns, and manages the `big_buffer` out of which it''s allocating memory.
    For any given `big_buffer`, there will be exactly one `example_resource` object
    in our program that manipulates that buffer. Just as we said earlier: objects
    of type `example_resource` are "memory resources," and thus they are *not* intended
    to be copied or moved around; they are classically object-oriented, not value-semantic.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的派生类`example_resource`的最后一点要注意的是，它代表了由我们的“堆”实际控制的资源；也就是说，它实际上包含、拥有和管理从其中分配内存的`big_buffer`。对于任何给定的`big_buffer`，在我们的程序中将有且只有一个`example_resource`对象来操作该缓冲区。正如我们之前所说的：`example_resource`类型的对象是“内存资源”，因此它们*不*打算被复制或移动；它们是经典面向对象的，而不是值语义的。
- en: The standard library provides several species of memory resource, all derived
    from `std::pmr::memory_resource`. Let's look at a few of them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几种内存资源类型，它们都源自 `std::pmr::memory_resource`。让我们看看其中的一些。
- en: Using the standard memory resources
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准内存资源
- en: Memory resources in the standard library come in two flavors. Some of them are
    actual class types, of which you can create instances; and some of them are "anonymous"
    class types accessed only via singleton functions. Generally you can predict which
    is which by thinking about whether two objects of the type could ever possibly
    be "different," or whether the type is basically a singleton anyway.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的内存资源有两种类型。其中一些是实际类类型，你可以创建其实例；还有一些是“匿名”类类型，只能通过单例函数访问。通常，你可以通过思考两个对象是否可能“不同”，或者类型本质上是否是单例来预测它们是哪一种。
- en: 'The simplest memory resource in the `<memory_resource>` header is the "anonymous"
    singleton accessed via `std::pmr::null_memory_resource()`. The definition of this
    function is something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<memory_resource>` 头文件中最简单的内存资源是通过 `std::pmr::null_memory_resource()` 访问的“匿名”单例。这个函数的定义可能类似于以下内容：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the function returns a pointer to the singleton instance. Generally,
    `std::pmr::memory_resource` objects will be manipulated via pointers, because
    the `memory_resource` objects themselves cannot move around.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数返回单例实例的指针。通常，`std::pmr::memory_resource` 对象将通过指针进行操作，因为`memory_resource`
    对象本身无法移动。
- en: '`null_memory_resource` seems fairly useless; all it does is throw an exception
    when you try to allocate from it. However, it can be useful when you start using
    the more complicated memory resources which we''ll see in a moment.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`null_memory_resource` 似乎相当无用；它所做的只是在你尝试从中分配时抛出异常。然而，当你开始使用我们稍后将看到的更复杂的内存资源时，它可能很有用。'
- en: The next most complicated memory resource is the singleton accessed via `std::pmr::new_delete_resource()`;
    it uses `::operator new` and `::operator delete` to allocate and deallocate memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最复杂的内存资源是通过 `std::pmr::new_delete_resource()` 访问的单例；它使用 `::operator new`
    和 `::operator delete` 来分配和释放内存。
- en: 'Now we move on to talking about the named class types. These are resources
    where it makes sense to have multiple resources of identical type in a single
    program. For example, there''s `class std::pmr::monotonic_buffer_resource`. This
    memory resource is fundamentally the same as our `example_resource` from earlier,
    except for two differences: Instead of holding its big buffer as member data (`std::array`-style),
    it just holds a pointer to a big buffer allocated from somewhere else (`std::vector`-style).
    And when its first big buffer runs out, rather than immediately starting to throw
    `bad_alloc`, it will attempt to allocate a *second* big buffer, and allocate chunks
    out of that buffer until *it''s* all gone; at which point it will allocate a third
    big buffer... and so on, until eventually it cannot even allocate any more big
    buffers. As with our `example_resource`, none of the deallocated memory is ever
    freed until the resource object itself is destroyed. There is one useful escape
    valve: If you call the method `a.release()`, the `monotonic_buffer_resource` will
    release all of the buffers it''s currently holding, sort of like calling `clear()`
    on a vector.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈命名类类型。这些是在单个程序中拥有多个相同类型资源是有意义的资源。例如，有 `class std::pmr::monotonic_buffer_resource`。这种内存资源基本上与之前我们的
    `example_resource` 相同，除了两点不同：它不是将其大缓冲区作为成员数据（`std::array` 风格）持有，而是只持有从别处分配的大缓冲区的指针（`std::vector`
    风格）。当其第一个大缓冲区耗尽时，它不会立即开始抛出 `bad_alloc` 异常，而是会尝试分配第二个大缓冲区，并从这个缓冲区中分配块，直到它全部用完；此时，它将分配第三个大缓冲区……以此类推，直到最终它甚至无法再分配任何大缓冲区。与我们的
    `example_resource` 一样，直到资源对象本身被销毁，所有已释放的内存都不会被释放。有一个有用的出口：如果你调用 `a.release()`
    方法，`monotonic_buffer_resource` 将释放它当前持有的所有缓冲区，有点像在向量上调用 `clear()`。
- en: 'When you construct a resource of type `std::pmr::monotonic_buffer_resource`,
    you need to tell it two things: Where is its first big buffer located? and, when
    that buffer is exhausted, who it should ask for another buffer? The first of these
    questions is answered by providing a pair of arguments `void*, size_t` that describes
    the first big buffer (optionally `nullptr`); and the second question is answered
    by providing a `std::pmr::memory_resource*` that points to this resource''s "upstream"
    resource. One sensible thing to pass in for the "upstream" resource would be `std::pmr::new_delete_resource()`,
    so as to allocate new buffers using `::operator new`. Or, another sensible thing
    to pass in would be `std::pmr::null_memory_resource()`, so as to put a hard cap
    on the memory usage of this particular resource. Here''s an example of the latter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构造一个 `std::pmr::monotonic_buffer_resource` 类型的资源时，你需要告诉它两件事：它的第一个大缓冲区在哪里？当该缓冲区耗尽时，它应该向谁请求另一个缓冲区？第一个问题的答案是提供一个
    `void*, size_t` 的参数对，它描述了第一个大缓冲区（可选 `nullptr`）；第二个问题的答案是提供一个指向此资源“上游”资源的 `std::pmr::memory_resource*`。对于“上游”资源，一个合理的传递方式是
    `std::pmr::new_delete_resource()`，以便使用 `::operator new` 分配新的缓冲区。或者，另一个合理的传递方式是
    `std::pmr::null_memory_resource()`，以便对特定资源的内存使用设置一个硬限制。以下是一个后者的示例：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you forget what upstream resource a particular `monotonic_buffer_resource`
    is using, you can always find out by calling `a.upstream_resource()`; that method
    returns a pointer to the upstream resource that was provided to the constructor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了特定的 `monotonic_buffer_resource` 正在使用哪个上游资源，你可以通过调用 `a.upstream_resource()`
    来找出；该方法返回一个指向提供给构造函数的上游资源的指针。
- en: Allocating from a pool resource
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从资源池中分配
- en: The final kind of memory resource provided by the C++17 standard library is
    what's called a "pool resource." A pool resource doesn't just manage one big buffer,
    such as `example_resource`; or even a monotonically increasing chain of buffers,
    such as `monotonic_buffer_resource`. Instead it manages a whole lot of "blocks"
    of various sizes. All the blocks of a given size are stored together in a "pool,"
    so that we can talk about "the pool of blocks of size 4," "the pool of blocks
    of size 16," and so on. When a request comes in for an allocation of size *k*,
    the pool resource will look in the pool of blocks of size *k*, pull one out and
    return it. If the pool for size *k* is empty, then the pool resource will attempt
    to allocate some more blocks from its upstream resource. Also, if a request comes
    in for an allocation so large that we don't even have a pool for blocks of that
    size, then the pool resource is allowed to pass the request directly on to its
    upstream resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 标准库提供的最后一种内存资源被称为“池资源”。池资源不仅仅管理一个大的缓冲区，例如 `example_resource`；甚至不是一个单调递增的缓冲区链，例如
    `monotonic_buffer_resource`。相反，它管理各种大小的“块”。给定大小的所有块都存储在“池”中，因此我们可以谈论“大小为4的块池”、“大小为16的块池”等等。当一个请求到来，需要分配大小为
    *k* 的资源时，池资源会在大小为 *k* 的块池中查找，取出一个并返回。如果大小为 *k* 的池为空，那么池资源将尝试从其上游资源中分配更多的块。此外，如果一个请求到来，需要分配的块大小如此之大，以至于我们甚至没有该大小的块池，那么池资源允许直接将请求传递给其上游资源。
- en: 'Pool resources come in two flavors: *synchronized* and *unsynchronized*, which
    is to say, thread-safe and thread-unsafe. If you''re going to be accessing a pool
    from two different threads concurrently, then you should use `std::pmr::synchronized_pool_resource`,
    and if you''re definitely never going to do that, and you want raw speed, then
    you should use `std::pmr::unsynchronized_pool_resource`. (By the way, `std::pmr::monotonic_buffer_resource`
    is always thread-unsafe; and `new_delete_resource()` is effectively thread-safe,
    since all it does is call `new` and `delete`.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 池资源有两种类型：*同步* 和 *异步*，也就是说，线程安全和线程不安全。如果你将同时从两个不同的线程访问池，那么你应该使用 `std::pmr::synchronized_pool_resource`，如果你肯定永远不会这样做，并且想要原始速度，那么你应该使用
    `std::pmr::unsynchronized_pool_resource`。（顺便说一下，`std::pmr::monotonic_buffer_resource`
    总是线程不安全的；而 `new_delete_resource()` 实际上是线程安全的，因为它只是调用 `new` 和 `delete`。）
- en: 'When you construct a resource of type `std::pmr::synchronized_pool_resource`,
    you need to tell it three things: Which block sizes it should keep in its pools;
    how many blocks it should glom together into a "chunk" when it goes to get more
    blocks from the upstream resource; and who is its upstream resource. Unfortunately,
    the standard interface leaves much to be desired here--so much so that frankly
    I recommend that if these parameters truly matter to you, you should be implementing
    your own derived `memory_resource` and not touching the standard library''s version
    at all. The syntax for expressing these options is also fairly wonky:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个类型为 `std::pmr::synchronized_pool_resource` 的资源时，你需要告诉它三件事情：它应该在池中保留哪些块大小；当它从上游资源获取更多块时，应该将多少块组合成一个“块组”；以及它的上游资源是谁。不幸的是，标准接口在这里留下了很多遗憾——如此之多，以至于坦白地说，我建议如果你真正关心这些参数，你应该实现自己的派生
    `memory_resource`，而不要触及标准库的版本。表达这些选项的语法也相当复杂：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that there is no way to specify exactly which block sizes you want; that's
    left up to the vendor's implementation of `synchronized_pool_resource`. If you're
    lucky, it will choose decent block sizes that match your use-case; but personally
    I wouldn't rely on that assumption. Notice also that there's no way to use different
    upstream resources for the different block sizes, nor a different upstream resource
    for the "fallback" resource that's used when the caller requests an unusually
    sized allocation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无法指定确切的块大小；这留给供应商对 `synchronized_pool_resource` 的实现。如果你很幸运，它可能会选择适合你用例的合理块大小；但个人来说，我不会依赖这个假设。注意，也无法为不同的块大小使用不同的上游资源，也没有为当调用者请求异常大小的分配时使用的“后备”资源使用不同的上游资源。
- en: In short, I would steer clear of the built-in `pool_resource` derived classes
    for the foreseeable future. But the fundamental idea of deriving your own classes
    from `memory_resource` is solid. If you're concerned about memory allocation and
    managing your own little heaps, I'd recommend adopting `memory_resource` into
    your codebase.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在可预见的未来，我会避开内置的 `pool_resource` 派生类。但从 `memory_resource` 派生自己的类的根本思想是稳固的。如果你担心内存分配和管理你自己的小堆，我建议将
    `memory_resource` 纳入你的代码库。
- en: Now, so far we've only been talking about various allocation strategies, as
    "personified" by the different `memory_resource` derived classes. We still need
    to see how to hook `memory_resource` into the algorithms and containers of the
    Standard Template Library. And to do that, we'll have to transition from the classically
    polymorphic world of `memory_resource` back into the value-semantic world of the
    C++03 STL.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到目前为止，我们一直在谈论各种分配策略，这些策略由不同的 `memory_resource` 派生类“体现”。我们仍然需要看看如何将 `memory_resource`
    集成到标准模板库的算法和容器中。为此，我们必须从 `memory_resource` 的经典多态世界过渡到 C++03 STL 的值语义世界。
- en: The 500 hats of the standard allocator
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准分配器的500顶帽子
- en: 'The standard allocator model must have seemed amazing in 2011\. We''re about
    to see how, with just one C++ type, we can accomplish all of the following feats:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 标准分配器模型在 2011 年看起来很神奇。我们将看到，仅使用一种 C++ 类型，我们就可以完成以下所有任务：
- en: Specify a memory resource to be used for allocating memory.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定用于分配内存的内存资源。
- en: Annotate each allocated pointer with some metadata that will be carried along
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个分配的指针上注解一些将随指针一起传递的元数据
- en: for its whole lifetime, all the way to deallocation time.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其整个生命周期内，一直到释放时间。
- en: Associate a container object with a particular memory resource, and make sure
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个容器对象与特定的内存资源关联起来，并确保
- en: that association is "sticky"--this container object will always use the given
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种关联是“粘性的”——这个容器对象将始终使用给定的
- en: heap for its allocations.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为其分配使用堆。
- en: Associate a container *value* with a particular memory resource, meaning
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个容器 *值* 与特定的内存资源关联起来，这意味着
- en: that the container can be efficiently moved around using value semantics without
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器可以使用值语义高效地移动，而无需
- en: forgetting how to deallocate its contents.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 忘记如何释放其内容。
- en: Choose between the two mutually exclusive behaviors above.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述两种互斥行为之间进行选择。
- en: Specify a strategy for allocating memory at all levels of a multi-level
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多级结构的所有级别上指定分配内存的策略
- en: container, such as a vector of vectors.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器，例如向量中的向量。
- en: Redefine what it means to "construct" the contents of a container, so that
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义“构造”容器内容的意义，以便
- en: for example, `vector<int>::resize` could be defined to default-initialize new
    elements instead of zero-initializing them.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`vector<int>::resize` 可以被定义为对新元素进行默认初始化，而不是零初始化。
- en: This is just an *insane* number of hats for any one class type to wear--a massive
    violation of the Single Responsibility Principle. Nevertheless, this is what the
    standard allocator model does; so let's try to explain all these features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于任何单个类类型来说都是一个**疯狂**的帽子数量——这是对单一责任原则的严重违反。尽管如此，这正是标准分配器模型所做的事情；所以让我们尝试解释所有这些特性。
- en: 'Remember that a "standard allocator" is just any class type that satisfies
    the concept `Allocator<T>` for some type `T`. The standard library provides three
    standard allocator types: `std::allocator<T>`, `std::pmr::polymorphic_allocator<T>`,
    and `std::scoped_allocator_adaptor<A...>`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，“标准分配器”只是任何满足某些类型 `T` 的概念 `Allocator<T>` 的类类型。标准库提供了三种标准分配器类型：`std::allocator<T>`、`std::pmr::polymorphic_allocator<T>`
    和 `std::scoped_allocator_adaptor<A...>`。
- en: 'Let''s start by looking at `std::allocator<T>`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `std::allocator<T>`：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`std::allocator<T>` has the member functions `allocate` and `deallocate` that
    are required by the `Allocator<T>` concept. Remember that we are in the world
    of concept-based generic programming now! The classically polymorphic `memory_resource`
    *also* had member functions named `allocate` and `deallocate`, but they always
    returned `void*`, not `T*`. (Also, `memory_resource::allocate()` took two arguments--`bytes`
    and `align`--whereas `allocator<T>::allocate()` takes only one argument. The first
    reason for this is that `allocator<T>` predated the mainstream understanding that
    alignment was a big deal; remember that the `sizeof` operator was inherited from
    C in the 1980s but the `alignof` operator only showed up in C++11\. The second
    reason is that in the context of `std::allocator<T>`, we know that the type of
    the objects being allocated is `T`, and thus the requested alignment must necessarily
    be `alignof(T)`. `std::allocator<T>` doesn''t use that information, because it
    predates `alignof`; but in principle it could, and that''s why the `Allocator<T>`
    concept requires only the signature `a.allocate(n)` instead of `a.allocate(n,
    align)`.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::allocator<T>` 有 `allocate` 和 `deallocate` 成员函数，这些函数是 `Allocator<T>` 概念所要求的。记住，我们现在处于基于概念泛型编程的世界！经典的多态
    `memory_resource` 也**同样**有名为 `allocate` 和 `deallocate` 的成员函数，但它们总是返回 `void*`，而不是
    `T*`。（此外，`memory_resource::allocate()` 接受两个参数——`bytes` 和 `align`——而 `allocator<T>::allocate()`
    只接受一个参数。第一个原因是 `allocator<T>` 产生于对对齐重要性的主流理解之前；记住，`sizeof` 操作符是从20世纪80年代的C语言继承而来的，但
    `alignof` 操作符只出现在C++11中。第二个原因是，在 `std::allocator<T>` 的上下文中，我们知道正在分配的对象类型是 `T`，因此请求的对齐必须是
    `alignof(T)`。`std::allocator<T>` 不使用这个信息，因为它早于 `alignof`；但原则上它可以，这就是为什么 `Allocator<T>`
    概念只要求 `a.allocate(n)` 的签名，而不是 `a.allocate(n, align)` 的原因。）'
- en: The constructor marked `NOTE 1` is important; every allocator needs a templated
    constructor modeled after this one. The constructors following the line marked
    `NOTE 2` are unimportant; the only reason we wrote them explicitly in the code
    is because if we had not written them, they would have been implicitly deleted
    due to the presence of a user-defined constructor (namely, the `NOTE 1` constructor).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `NOTE 1` 的构造函数很重要；每个分配器都需要一个模板构造函数，其模式与此类似。标记为 `NOTE 2` 的后续构造函数并不重要；我们之所以在代码中明确写出它们，仅仅是因为如果我们没有写出它们，由于存在用户定义的构造函数（即
    `NOTE 1` 构造函数），它们将被隐式删除。
- en: 'The idea of any standard allocator is that we can plug it in as the very last
    template type parameter of any standard container ([Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*) and the container will then use that allocator instead of
    its usual mechanisms anytime it needs to allocate memory for any reason. Let''s
    see an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何标准分配器的想法是，我们可以将其作为任何标准容器（[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，*容器动物园*）的最后一个模板类型参数插入，然后容器将在需要为任何原因分配内存时使用该分配器而不是其通常的机制。让我们看一个例子：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here our class `helloworld<int>` models `Allocator<int>`; but we''ve omitted
    the templated constructor. This is fine if we''re dealing only with `vector`,
    because `vector` will allocate only arrays of its element type. However, watch
    what happens if we change the test case to use `list` instead:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的类 `helloworld<int>` 模拟 `Allocator<int>`；但我们省略了模板构造函数。如果我们只处理 `vector`，这是可以的，因为
    `vector` 只会为其元素类型分配数组。然而，如果我们改变测试用例以使用 `list` 代替，看看会发生什么：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Under libc++, this code spews several dozen lines of error messages, which boil
    down to the essential complaint "no known conversion from `helloworld<int>` to
    `helloworld<std::__1::__list_node<int, void *>>`." Recall from the diagram in
    [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container
    Zoo*, that `std::list<T>` stores its elements in nodes that are larger than the
    size of `T` itself. So `std::list<T>` isn't going to be trying to allocate any
    `T` objects; it wants to allocate objects of type `__list_node`. To allocate memory
    for `__list_node` objects, it needs an allocator that models the concept `Allocator<__list_node>`,
    not `Allocator<int>`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 libc++ 下，这段代码会输出几十行错误信息，归结为基本抱怨：“没有已知从 `helloworld<int>` 转换到 `helloworld<std::__1::__list_node<int,
    void *>>` 的转换。”回想一下 [第 4 章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)
    中的图，“容器动物园”，`std::list<T>` 存储其元素在比 `T` 本身更大的节点中。因此，`std::list<T>` 不打算尝试分配任何 `T`
    对象；它想要分配 `__list_node` 类型的对象。为了为 `__list_node` 对象分配内存，它需要一个模拟 `Allocator<__list_node>`
    概念的分配器，而不是 `Allocator<int>`。
- en: 'Internally, the constructor of `std::list<int>` takes our `helloworld<int>`
    and attempts to "rebind" it to allocate `__list_node` objects instead of `int`
    objects. This is accomplished via a *traits class--*a C++ idiom that we first
    encountered in [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`std::list<int>` 的构造函数尝试将我们的 `helloworld<int>` “重新绑定”为分配 `__list_node` 对象而不是
    `int` 对象。这是通过一个 *特性类--* 一个我们在 [第 2 章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，“迭代器和范围”中首次遇到的
    C++ 习语来实现的：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The standard class template `std::allocator_traits<A>` wraps up a lot of information
    about the allocator type `A` into one place, so it's easy to get at. For example,
    `std::allocator_traits<A>::value_type` is an alias for the type `T` whose memory
    is allocated by `A`; and `std::allocator_traits<A>::pointer` is an alias for the
    corresponding pointer type (generally `T*`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标准类模板 `std::allocator_traits<A>` 将关于分配器类型 `A` 的许多信息封装在一个地方，因此很容易访问。例如，`std::allocator_traits<A>::value_type`
    是一个别名，表示由 `A` 分配的内存的类型 `T`；而 `std::allocator_traits<A>::pointer` 是对应指针类型的别名（通常是
    `T*`）。
- en: 'The nested alias template `std::allocator_traits<A>::rebind_alloc<U>` is a
    way of "converting" an allocator from one type `T` to another type `U`. This type
    trait uses metaprogramming to crack open the type `A` and see: first, whether
    `A` has a nested template alias `A::rebind<U>::other` (this is rare), and second,
    whether type `A` can be expressed in the form `Foo<Bar,Baz...>` (where `Baz...`
    is some list of types which might be an empty list). If `A` can be expressed that
    way, then `std::allocator_traits<A>::rebind_alloc<U>` will be a synonym for `Foo<U,Baz...>`.
    Philosophically, this is completely arbitrary; but in practice it works for every
    allocator type you''ll ever see. In particular, it works for `helloworld<int>`--which
    explains why we didn''t have to muck around with providing a nested alias `rebind<U>::other`
    in our `helloworld` class. By providing a sensible default behavior, the `std::allocator_traits`
    template has saved us some boilerplate. This is the reason `std::allocator_traits`
    exists.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套别名模板 `std::allocator_traits<A>::rebind_alloc<U>` 是一种将分配器从一种类型 `T` 转换为另一种类型
    `U` 的方法。这种类型特性使用元编程来打开类型 `A` 并查看：首先，`A` 是否有一个嵌套模板别名 `A::rebind<U>::other`（这种情况很少见），其次，类型
    `A` 是否可以表示为 `Foo<Bar,Baz...>` 的形式（其中 `Baz...` 是一些类型列表，可能是一个空列表）。如果 `A` 可以以这种方式表示，那么
    `std::allocator_traits<A>::rebind_alloc<U>` 将是 `Foo<U,Baz...>` 的同义词。从哲学上讲，这是完全任意的；但在实践中，它适用于你将看到的每个分配器类型。特别是，它适用于
    `helloworld<int>`--这也解释了为什么我们不需要在我们的 `helloworld` 类中提供嵌套别名 `rebind<U>::other`。通过提供合理的默认行为，`std::allocator_traits`
    模板为我们节省了一些样板代码。这就是 `std::allocator_traits` 存在的原因。
- en: You might wonder why `std::allocator_traits<Foo<Bar,Baz...>>::value_type` doesn't
    default to `Bar`. Frankly, I don't know either. It seems like a no-brainer; but
    the standard library doesn't do it. Therefore, every allocator type you write
    (remember now we're talking about classes modeling `Allocator<T>`, and *not* about
    classes derived from `memory_resource`) must provide a nested typedef `value_type`
    that is an alias for `T`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 `std::allocator_traits<Foo<Bar,Baz...>>::value_type` 不默认为 `Bar`。坦白说，我也不知道。这似乎是一个显而易见的事情；但标准库没有这样做。因此，你必须为每个你编写的分配器类型（记住我们现在在谈论模拟
    `Allocator<T>` 的类，而不是从 `memory_resource` 派生的类）提供一个嵌套 typedef `value_type`，它是一个
    `T` 的别名。
- en: 'However, once you''ve defined the nested typedef for `value_type`, you can
    rely on `std::allocator_traits` to infer the correct definitions for its nested
    typedef `pointer` (that is, `T*`), and `const_pointer` (that is, `const T*`),
    and `void_pointer` (that is, `void*`), and so on. If you were following the previous
    discussion of `rebind_alloc`, you might guess that "converting" a pointer type
    like `T*` to `void*` is just as difficult or easy as "converting" an allocator
    type `Foo<T>` to `Foo<void>`; and you''d be correct! The values of these pointer-related
    type aliases are all computed via a *second* standard traits class, `std::pointer_traits<P>`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你为 `value_type` 定义了嵌套类型别名，你就可以依赖 `std::allocator_traits` 来推断其嵌套类型别名 `pointer`（即
    `T*`）、`const_pointer`（即 `const T*`）、`void_pointer`（即 `void*`）等的正确定义。如果你跟随了之前关于
    `rebind_alloc` 的讨论，你可能会猜测将指针类型如 `T*` 转换为 `void*` 与将分配器类型 `Foo<T>` 转换为 `Foo<void>`
    一样困难或容易；你是对的！这些指针相关类型别名的值都是通过第二个标准特性类 `std::pointer_traits<P>` 计算得出的：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This traits class becomes very important when we talk about the next responsibility
    of `Allocator<T>`, which was "annotate each allocated pointer with some metadata
    that will be carried along for its whole lifetime."
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 `Allocator<T>` 的下一个职责时，这个特性类变得非常重要，即“为每个分配的指针添加一些将在其整个生命周期中携带的元数据。”
- en: Carrying metadata with fancy pointers
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与花哨指针一起携带元数据
- en: 'Consider the following high-level design for a memory resource, which should
    remind you very much of `std::pmr::monotonic_buffer_resource`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内存资源的高级设计，这应该会让你非常想起 `std::pmr::monotonic_buffer_resource`：
- en: Keep a list of chunks of memory we've gotten from the system. For each chunk,
    also store an `index` of how many bytes we've allocated from the beginning of
    the chunk; and store a count `freed` of how many bytes we've deallocated from
    this specific chunk.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个我们从系统获取的内存块的列表。对于每个块，还存储从块开始分配的字节数的 `index`；并存储从该特定块中已释放的字节数的计数 `freed`。
- en: When someone calls `allocate(n)`, increment any one of our chunks' `index` by
    the appropriate number of bytes if possible, or get a new chunk from the upstream
    resource if absolutely necessary.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人调用 `allocate(n)` 时，如果可能，增加我们任何一个块的 `index` 以适当的字节数，或者在绝对必要时从上游资源获取一个新的块。
- en: When someone calls `deallocate(p, n)`, figure out which of our chunks `p` came
    from and increment its `freed += n`. If `freed == index`, then the entire chunk
    is empty, so set `freed = index = 0`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人调用 `deallocate(p, n)` 时，找出 `p` 来自我们的哪个块，并增加其 `freed += n`。如果 `freed == index`，则整个块为空，因此将
    `freed = index = 0`。
- en: 'It''s pretty straightforward to turn the foregoing description into code. The
    only problematic item is: in `deallocate(p, n)`, how do we figure out which of
    our chunks `p` came from?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述描述转换为代码相当直接。唯一的问题在于：在 `deallocate(p, n)` 中，我们如何确定 `p` 来自我们的哪个块？
- en: 'This would be easy if we simply recorded the identity of the chunk in the "pointer"
    itself:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在“指针”本身中记录块的标识符，这将很容易：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then in our `deallocate(p, n)` function, all we'd have to do is to look at `p.chunk()`.
    But to make this work, we'd need to change the signature of the `allocate(n)`
    and `deallocate(p, n)` functions so that `deallocate` took a `ChunkyPtr<T>` instead
    of `T*`, and `allocate` returned `ChunkyPtr<T>` instead of `T*`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的 `deallocate(p, n)` 函数中，我们只需查看 `p.chunk()`。但要使这生效，我们需要更改 `allocate(n)`
    和 `deallocate(p, n)` 函数的签名，使 `deallocate` 接受 `ChunkyPtr<T>` 而不是 `T*`，并且 `allocate`
    返回 `ChunkyPtr<T>` 而不是 `T*`。
- en: 'Fortunately, the C++ standard library gives us a way to do this! All we need
    to do is define our own type that models `Allocator<T>` and give it a member typedef
    `pointer` that evaluates to `ChunkyPtr<T>`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++ 标准库为我们提供了一种方法来做这件事！我们只需要定义自己的类型来模拟 `Allocator<T>`，并给它一个成员类型别名 `pointer`，其值为
    `ChunkyPtr<T>`：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The traits classes `std::allocator_traits` and `std::pointer_traits` will take
    care of inferring the other typedefs--such as `void_pointer`, which through the
    magic of `pointer_traits::rebind` will end up as an alias for `ChunkyPtr<void>`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 特性类 `std::allocator_traits` 和 `std::pointer_traits` 将会负责推断其他类型别名--例如 `void_pointer`，它通过
    `pointer_traits::rebind` 的魔法最终会成为 `ChunkyPtr<void>` 的别名。
- en: 'I''ve left out the implementations of the `allocate` and `deallocate` functions
    here because they would depend on the interface of `ChunkyMemoryResource`. We
    might implement `ChunkyMemoryResource` something like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里省略了 `allocate` 和 `deallocate` 函数的实现，因为它们将依赖于 `ChunkyMemoryResource` 的接口。我们可能会像这样实现
    `ChunkyMemoryResource`：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can use our `ChunkyMemoryResource` to allocate memory for standard allocator-aware
    containers like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的`ChunkyMemoryResource`为像这样的标准分配器感知容器分配内存：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, I''ve chosen this example to make it look very simple and straightforward;
    and I''ve left out a lot of the details of the `ChunkyPtr<T>` type itself. If
    you try copying this code yourself, you''ll find that you need to provide `ChunkyPtr`
    with a lot of overloaded operators such as `==`, `!=`, `<`, `++`, `--`, and `-`;
    and you''ll also need to provide a specialization for `ChunkyPtr<void>` that omits
    the overloaded `operator*`. Most of the details are the same as what we covered
    in [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d), *Iterators
    and Ranges*, when we implemented our own iterator type. In fact, every "fancy
    pointer" type is required to be usable as a *random-access iterator*--which means
    that you must provide the five nested typedefs listed at the end of [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*: `iterator_category`, `difference_type`, `value_type`,
    `pointer`, and `reference`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我选择这个例子是为了让它看起来非常简单直接；并且我省略了`ChunkyPtr<T>`类型本身的许多细节。如果你尝试自己复制这段代码，你会发现你需要为`ChunkyPtr`提供许多重载运算符，例如`==`,
    `!=`, `<`, `++`, `--`, 和`-`；你还需要为`ChunkyPtr<void>`提供一个特化，该特化省略了重载的`operator*`。大部分的细节与我们在[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，“迭代器和范围”，当我们实现自己的迭代器类型时所覆盖的内容相同。实际上，每个“花哨指针”类型都必须能够作为*随机访问迭代器*使用——这意味着你必须提供[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，“迭代器和范围”末尾列出的五个嵌套typedef：`iterator_category`,
    `difference_type`, `value_type`, `pointer`, 和`reference`。
- en: 'Finally, if you want to use certain containers such as `std::list` and `std::map`,
    you''ll need to implement a static member function with the surprising name `pointer_to(r)`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想使用某些容器，例如`std::list`和`std::map`，你需要实现一个名为`pointer_to(r)`的静态成员函数：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is because--as you may recall from [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*--a few containers such as `std::list` store their data in
    nodes whose `prev` and `next` pointers need to be able to point *either* to an
    allocated node *or* to a node which is contained within the member data of the
    `std::list` object itself. There are two obvious ways to accomplish this: Either
    every `next` pointer must be stored in a sort of tagged union of a fancy pointer
    and a raw pointer (perhaps a `std::variant` as described in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*), or else we must find a way of encoding a raw pointer *as*
    a fancy pointer. The standard library chose the latter approach. So, whenever
    you write a fancy pointer type, not only must it do all the things required of
    it by the allocator, and not only must it satisfy the requirements of a random-access
    iterator, but it must *also* have a way of representing any arbitrary pointer
    in the program''s address space--at least if you want to use your allocator with
    node-based containers such as `std::list`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为——正如你可能从[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，“容器动物园”中回忆起来——一些容器，例如`std::list`，将它们的数据存储在节点中，这些节点的`prev`和`next`指针需要能够指向*任意*一个已分配的节点*或者*指向包含在`std::list`对象本身成员数据中的节点。有两种明显的方法可以实现这一点：要么每个`next`指针都必须存储在一个带有花哨指针和原始指针（可能是一个`std::variant`，如[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，“词汇类型”中描述的）的标记联合体中，要么我们必须找到一种方法将原始指针*编码*为花哨指针。标准库选择了后者。所以，每当您编写一个花哨指针类型时，它不仅必须完成分配器要求的所有事情，而且它必须满足随机访问迭代器的需求，而且它还必须*也有*一种表示程序地址空间中任何任意指针的方法——至少如果您想使用您的分配器与基于节点的容器，如`std::list`。
- en: Even after jumping through all these hoops, you'll find that (as of press time)
    neither libc++ nor libstdc++ can handle fancy pointers in any container more complicated
    than `std::vector`. They support just enough to work with a single fancy pointer
    type--`boost::interprocess::offset_ptr<T>`, which carries no metadata. And the
    standard continues to evolve; `std::pmr::memory_resource` was newly introduced
    in C++17, and as of this writing it is still not implemented by libc++ nor libstdc++.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使跳过了所有这些障碍，你也会发现（截至出版时间），libc++和libstdc++都无法处理比`std::vector`更复杂的任何容器中的花哨指针。它们只支持足够的操作与单个花哨指针类型一起工作——`boost::interprocess::offset_ptr<T>`，它不携带元数据。而且标准仍在不断发展；`std::pmr::memory_resource`是在C++17中新引入的，截至本文撰写时，它还没有被libc++和libstdc++实现。
- en: 'You may also have noticed the lack of any standard base class for memory resources
    that use fancy pointers. Fortunately, this is easy to write yourself:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了缺少任何使用花哨指针的内存资源的标准基类。幸运的是，这很容易自己编写：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The standard library provides no allocators that use fancy pointers; every library-provided
    allocator type uses raw pointers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库不提供使用花哨指针的分配器；每个库提供的分配器类型都使用原始指针。
- en: Sticking a container to a single memory resource
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器固定到单个内存资源上
- en: 'The next hat worn by the standard allocator model--the next feature controlled
    by `std::allocator_traits`--is the ability to associate specific container objects
    with specific heaps. We used three bullet points to describe this feature earlier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 标准分配器模型戴上的下一个帽子——由`std::allocator_traits`控制的下一个特性——是能够将特定的容器对象与特定的堆关联起来。我们之前用三个项目符号描述了这一特性：
- en: Associate a container object with a particular memory resource, and make sure
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器对象与特定的内存资源关联起来，并确保
- en: that association is "sticky"--this container object will always use the given
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种关联是“粘性的”——这个容器对象将始终使用给定的
- en: heap for its allocations.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用堆进行分配
- en: Associate a container *value* with a particular memory resource, meaning
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器*值*与特定的内存资源关联起来，意味着
- en: that the container can be efficiently moved around using value semantics without
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器可以使用值语义有效地移动，而无需
- en: forgetting how to deallocate its contents.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 忘记如何释放其内容
- en: Choose between the two mutually exclusive behaviors just mentioned.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述两种互斥行为之间进行选择。
- en: 'Let''s look at an example, using `std::pmr::monotonic_buffer_resource` for
    our resource but using a hand-written class type for our allocator type. (Just
    to reassure you that you haven''t missed anything: Indeed, we *still* haven''t
    covered any standard-library-provided allocator types--except for `std::allocator<T>`,
    the trivial stateless allocator that is a handle to the global heap managed by
    `new` and `delete`.)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，使用`std::pmr::monotonic_buffer_resource`作为我们的资源，但使用手写的类类型作为我们的分配器类型。（只是为了让你放心，你确实没有错过任何东西：实际上，我们仍然没有涵盖任何标准库提供的分配器类型——除了`std::allocator<T>`，这是一个平凡的无状态分配器，它是`new`和`delete`管理的全局堆的句柄。）
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here our `Widget` is a classically object-oriented class type; we expect it
    to live at a specific memory address for its entire lifetime. Then, to reduce
    heap fragmentation or to improve cache locality, we've placed a large buffer inside
    each `Widget` object and made the `Widget` use that buffer as the backing store
    for its data members `v` and `lst`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的`Widget`是一个经典的面向对象类类型；我们期望它在整个生命周期中存在于特定的内存地址。然后，为了减少堆碎片或提高缓存局部性，我们在每个`Widget`对象内部放置了一个大缓冲区，并使`Widget`使用该缓冲区作为其数据成员`v`和`lst`的后备存储。
- en: Now look at the `Widget::swap_elems(a, b)` function. It swaps the `v` data members
    of `Widget a` and `Widget b`. You might recall from [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, that a `std::vector` is little more than a pointer to a dynamically
    allocated array, and so *usually* the library can swap two instances of `std::vector`
    by simply swapping their underlying pointers, without moving any of the underlying
    data--making vector swap an O(1) operation instead of an O(*n*) operation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`Widget::swap_elems(a, b)`函数。它交换了`Widget a`和`Widget b`的`v`数据成员。你可能还记得[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，“容器动物园”，其中`std::vector`不过是一个指向动态分配数组的指针，因此通常库可以通过简单地交换它们的底层指针来交换两个`std::vector`实例，而不需要移动任何底层数据——使得向量交换成为O(1)操作而不是O(*n*)操作。
- en: Furthermore, `vector` is smart enough to know that if it swaps pointers, it
    also needs to swap allocators--so that the information about how to deallocate
    travels along with the pointer that will eventually be in need of deallocation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`vector`足够智能，知道如果它交换指针，它还需要交换分配器——这样关于如何释放的信息就会随着最终需要释放的指针一起传递。
- en: But in this case, if the library just swapped the pointers and allocators, it
    would be disastrous! We'd have a vector `a.v` whose underlying array was now "owned"
    by `b.mr`, and vice versa. If we destroyed `Widget b`, then the next time we accessed
    the elements of `a.v` we'd be accessing freed memory. And furthermore, even if
    we never accessed `a.v` again, our program would likely crash when the destructor
    of `a.v` attempted to call the `deallocate` method of the long-dead `b.mr`!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，如果库只是交换了指针和分配器，那将是一场灾难！我们会有一个向量 `a.v`，其底层数组现在“属于”`b.mr`，反之亦然。如果我们销毁
    `Widget b`，那么下次我们访问 `a.v` 的元素时，我们将访问已释放的内存。而且更进一步，即使我们以后再也不访问 `a.v`，当 `a.v` 的析构函数尝试调用早已死亡的
    `b.mr` 的 `deallocate` 方法时，我们的程序很可能会崩溃！
- en: 'Fortunately, the standard library saves us from this fate. One of the responsibilities
    of an allocator-aware container is to appropriately *propagate* its allocator
    on copy-assignment, move-assignment, and swap. For historical reasons this is
    handled by a whole mess of typedefs in the `allocator_traits` class template,
    but in order to *use* allocator propagation correctly, you only have to know a
    couple of things:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准库救了我们于水火。一个分配器感知容器的一个责任是在复制赋值、移动赋值和交换时适当地*传播*其分配器。由于历史原因，这由 `allocator_traits`
    类模板中的大量 typedef 处理，但为了*正确使用*分配器传播，你只需要知道几件事情：
- en: Whether the allocator propagates itself, or whether it sticks firmly to a specific
    container, is a property of the *allocator type*. If you want one allocator to
    "stick" while another propagates, you *must* make them different types.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器是否传播自身，或者是否坚定地粘附在特定的容器上，是*分配器类型*的一个属性。如果你想使一个分配器“粘性”而另一个分配器传播，你必须使它们成为不同的类型。
- en: When an allocator is "sticky," it sticks to a particular (classical, object-oriented)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个分配器“粘性”时，它会粘附在特定的（经典、面向对象的）
- en: container object. Operations that with a non-sticky allocator type would be
    O(1) pointer-swaps may become O(*n*), because "adopting" elements from some other
    allocator's memory space into our own requires allocating room for them in our
    own memory space.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器对象。在非粘性分配器类型下原本是 O(1) 指针交换的操作可能会变成 O(*n*)，因为“采用”来自某个其他分配器内存空间中的元素到我们自己的内存空间中，需要在我们自己的内存空间中为它们分配空间。
- en: Stickiness has a clear use-case (as we have just shown with `Widget`), and
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粘性有明确的用例（正如我们刚刚用 `Widget` 展示的那样），并且
- en: the effects of non-stickiness can be disastrous (again, see `Widget`). Therefore,
    `std::allocator_traits` assumes by default that an allocator type is sticky, unless
    it can tell that the allocator type is *empty* and thus is quite definitely *stateless*.
    The default for *empty* allocator types is effectively non-stickiness.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非粘性的影响可能是灾难性的（再次，参见 `Widget`）。因此，`std::allocator_traits` 默认假设分配器类型是粘性的，除非它能判断出分配器类型是*空的*，因此绝对是*无状态的*。对于*空的*分配器类型，默认实际上是粘性。
- en: 'As a programmer, you basically always want the default: stateless allocators
    might as well propagate, and stateful allocators *probably* don''t have much use
    outside of `Widget`-like scenarios where stickiness is required.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为程序员，你基本上总是想要默认状态：无状态的分配器可以传播，而状态性的分配器*可能*在需要粘性的 `Widget` 类似场景之外没有太多用途。
- en: Using the standard allocator types
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准分配器类型
- en: Let's talk about the allocator types provided by the standard library.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈标准库提供的分配器类型。
- en: '`std::allocator<T>` is the default allocator type; it is the default value
    of the template type parameter to every standard container. So for example when
    you write `std::vector<T>` in your code, that''s secretly the exact same type
    as `std::vector<T, std::allocator<T>>`. As we''ve mentioned before in this chapter,
    `std::allocator<T>` is a stateless empty type; it is a "handle" to the global
    heap managed by `new` and `delete`. Because `std::allocator` is a stateless type,
    `allocator_traits` assumes (correctly) that it should be non-sticky. This means
    that operations such as `std::vector<T>::swap` and `std::vector<T>::operator=`
    are guaranteed to be very efficient pointer-swaps--because any object of type
    `std::vector<T, std::allocator<T>>` always knows how to deallocate memory that
    was originally allocated by any other `std::vector<T, std::allocator<T>>`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::allocator<T>` 是默认的分配器类型；它是每个标准容器模板类型参数的默认值。所以例如，当你代码中写 `std::vector<T>`
    时，这实际上是 `std::vector<T, std::allocator<T>>` 的完全相同类型。正如我们本章前面提到的，`std::allocator<T>`
    是一个无状态的空类型；它是 `new` 和 `delete` 管理的全局堆的“句柄”。由于 `std::allocator` 是一个无状态类型，`allocator_traits`
    假定（正确地）它应该是非粘性的。这意味着操作如 `std::vector<T>::swap` 和 `std::vector<T>::operator=` 保证是非常高效的指针交换操作——因为任何
    `std::vector<T, std::allocator<T>>` 类型的对象总是知道如何释放由任何其他 `std::vector<T, std::allocator<T>>`
    分配的内存。'
- en: '`std::pmr::polymorphic_allocator<T>` is a new addition in C++17\. It is a stateful,
    non-empty type; its one data member is a pointer to a `std::pmr::memory_resource`.
    (In fact, it is almost identical to `WidgetAlloc` in our sample code from earlier
    in this chapter!) Two different instances of `std::pmr::polymorphic_allocator<T>`
    are not necessarily interchangeable, because their pointers might point to completely
    different `memory_resource`s; this means that an object of type `std::vector<T,
    std::pmr::polymorphic_allocator<T>>` does *not* necessarily know how to deallocate
    memory that was originally allocated by some other `std::vector<T, std::pmr::polymorphic_allocator<T>>`.
    That, in turn, means that `std::pmr::polymorphic_allocator<T>` is a "sticky" allocator
    type; and *that* means that operations such as `std::vector<T, std::pmr::polymorphic_allocator<T>>::operator=`
    can end up doing lots of copying.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::pmr::polymorphic_allocator<T>` 是 C++17 中新增的一个类型。它是一个有状态的、非空类型；它有一个数据成员，是一个指向
    `std::pmr::memory_resource` 的指针。（实际上，它与本章早期示例中的 `WidgetAlloc` 几乎相同！）两个不同的 `std::pmr::polymorphic_allocator<T>`
    实例不一定可以互换，因为它们的指针可能指向完全不同的 `memory_resource`；这意味着 `std::vector<T, std::pmr::polymorphic_allocator<T>>`
    类型的对象不一定知道如何释放由其他 `std::vector<T, std::pmr::polymorphic_allocator<T>>` 分配的内存。这反过来意味着
    `std::pmr::polymorphic_allocator<T>` 是一个“粘性”分配器类型；这意味着操作如 `std::vector<T, std::pmr::polymorphic_allocator<T>>::operator=`
    可能会导致大量的复制。'
- en: 'By the way, it''s quite tedious to write out the name of the type `std::vector<T,
    std::pmr::polymorphic_allocator<T>>` over and over. Fortunately, the standard
    library implementors came to the same realization, and so the standard library
    provides type aliases in the `std::pmr` namespace:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，反复写出 `std::vector<T, std::pmr::polymorphic_allocator<T>>` 这个类型名称相当繁琐。幸运的是，标准库实现者得出了相同的认识，因此标准库在
    `std::pmr` 命名空间中提供了类型别名：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Setting the default memory resource
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置默认内存资源
- en: 'The biggest difference between the standard `polymorphic_allocator` and our
    example `WidgetAlloc` is that `polymorphic_allocator` is default-constructible.
    Default-constructibility is arguably an attractive feature of an allocator; it
    means that we can write the second of these two lines instead of the first:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `polymorphic_allocator` 与我们的示例 `WidgetAlloc` 之间最大的区别是 `polymorphic_allocator`
    可以默认构造。默认构造性是一个分配器的有吸引力的特性；这意味着我们可以写出这两行中的第二行而不是第一行：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On the other hand, when you look at that second line, you might wonder, "Where
    is the underlying array actually being allocated?" After all, the main point of
    specifying an allocator is that we want to know where our bytes are coming from!
    That's why the *normal* way to construct a standard `polymorphic_allocator` is
    to pass in a pointer to a `memory_resource`--in fact, this idiom is expected to
    be *so* common that the conversion from `std::pmr::memory_resource*` to `std::pmr::polymorphic_allocator`
    is an implicit conversion. But `polymorphic_allocator` does have a default, zero-argument
    constructor as well. When you default-construct a `polymorphic_allocator`, you
    get a handle to the "default memory resource," which by default is `new_delete_resource()`.
    However, you can change this! The default memory resource pointer is stored in
    a global atomic (thread-safe) variable which can be manipulated with the library
    functions `std::pmr::get_default_resource()` (which returns the pointer) and `std::pmr::set_default_resource()`
    (which assigns a new value to the pointer and returns the previous value).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你看到第二行时，你可能会想，“底层数组实际上是在哪里被分配的？”毕竟，指定分配器的关键点是我们想知道我们的字节是从哪里来的！这就是为什么构建标准`polymorphic_allocator`的*正常*方式是传递一个指向`memory_resource`的指针——实际上，这个习惯用法预计会非常常见，以至于从`std::pmr::memory_resource*`到`std::pmr::polymorphic_allocator`的转换是一个隐式转换。但是`polymorphic_allocator`也有一个默认的无参数构造函数。当你默认构造一个`polymorphic_allocator`时，你得到一个指向“默认内存资源”的句柄，默认情况下是`new_delete_resource()`。然而，你可以改变这个！默认内存资源指针存储在一个全局原子（线程安全）变量中，可以使用库函数`std::pmr::get_default_resource()`（返回指针）和`std::pmr::set_default_resource()`（将新值赋给指针并返回旧值）来操作。
- en: If you want to avoid heap allocation via `new` and `delete` altogether, it might
    make sense to call `std::pmr::set_default_resource(std::pmr::null_memory_resource())`
    at the start of your program. Of course you can't stop any other part of your
    program from going rogue and calling `set_default_resource` itself; and because
    the same global variable is shared by every thread in your program, you might
    run into some very strange behavior if you *try* to modify the default resource
    during the program's execution. There is no way to say "set the default resource
    only for my current thread," for example. Furthermore, calling `get_default_resource()`
    (such as from the default constructor of `polymorphic_allocator`) performs an
    atomic access, which will tend to be marginally slower than if the atomic access
    could have been avoided. Therefore, your best course of action is to avoid the
    default constructor of `polymorphic_allocator`; always be explicit as to which
    memory resource you're trying to use. For absolute foolproofness, you might consider
    simply using the above `WidgetAlloc` instead of `polymorphic_allocator`; having
    *no* default constructor, `WidgetAlloc` flatly cannot be misused.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全想避免通过`new`和`delete`进行堆分配，那么在程序开始时调用`std::pmr::set_default_resource(std::pmr::null_memory_resource())`可能是有意义的。当然，你无法阻止程序的其他部分变得混乱并自行调用`set_default_resource`；并且由于相同的全局变量被程序中的每个线程共享，如果在程序执行期间*尝试*修改默认资源，你可能会遇到一些非常奇怪的行为。例如，无法说“只为我的当前线程设置默认资源”。此外，调用`get_default_resource()`（例如从`polymorphic_allocator`的默认构造函数中）执行原子访问，这通常会比如果可以避免原子访问而稍微慢一些。因此，你最好的行动方案是避免`polymorphic_allocator`的默认构造函数；始终明确你正在尝试使用哪种内存资源。为了绝对的安全，你可能考虑简单地使用上述`WidgetAlloc`而不是`polymorphic_allocator`；由于`WidgetAlloc`没有默认构造函数，它根本不可能被误用。
- en: Making a container allocator-aware
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使容器具有分配器意识
- en: 'Having covered memory resources (heaps) and allocators (handles to heaps),
    let''s turn now to the third leg of the tripod: container classes. Inside each
    allocator-aware container, at least four things have to happen:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了内存资源（堆）和分配器（堆的句柄）之后，现在让我们转向三脚架的第三条腿：容器类。在每一个具有分配器意识的容器内部，至少必须发生以下四件事情：
- en: The container instance must store an allocator instance as member data. (Therefore
    the container must take the type of the allocator as a template parameter; otherwise
    it can't know how much space to reserve for that member variable.)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器实例必须将分配器实例作为成员数据存储。（因此，容器必须将分配器的类型作为模板参数；否则，它不知道为该成员变量预留多少空间。）
- en: The container must provide constructors taking an allocator argument.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器必须提供接受分配器参数的构造函数。
- en: The container must actually use its allocator to allocate and deallocate memory;
    every use of `new` or `delete` must be banished.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器实际上必须使用其分配器来分配和释放内存；任何使用`new`或`delete`的操作都必须被禁止。
- en: The container's move constructor, move assignment operator, and `swap` function
    must all propagate the allocator according to its `allocator_traits`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的移动构造函数、移动赋值运算符和`swap`函数都必须根据其`allocator_traits`传播分配器。
- en: 'Here is a very simple allocator-aware container--a container of just one single
    object, allocated on the heap. This is something like an allocator-aware version
    of `std::unique_ptr<T>` from [Chapter 6](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d),
    *Smart Pointers*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的感知分配器的容器——一个只包含一个对象的容器，在堆上分配。这类似于[第6章](part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d)中*智能指针*的分配器感知版本`std::unique_ptr<T>`：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that where `unique_ptr` uses `T*`, our present code uses `allocator_traits<A>::pointer`;
    and where `make_unique` uses `new` and `delete`, our present code uses the one-two
    punch of `allocator_traits<A>::allocate`/`construct` and `allocator_traits<A>::destroy`/`deallocate`.
    We've already discussed the purpose of `allocate` and `deallocate`--they deal
    with getting memory from the appropriate memory resource. But those chunks of
    memory are just raw bytes; to turn a chunk of memory into a usable object we have
    to construct an instance of `T` at that address. We could use "placement `new`"
    syntax for this purpose; but we'll see in the next section why it's important
    to use `construct` and `destroy` instead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`unique_ptr`使用`T*`的地方，我们当前的代码使用`allocator_traits<A>::pointer`；而`make_unique`使用`new`和`delete`的地方，我们当前的代码使用`allocator_traits<A>::allocate`/`construct`和`allocator_traits<A>::destroy`/`deallocate`的一击两式。我们已经讨论了`allocate`和`deallocate`的目的——它们处理从适当的内存资源获取内存。但是，这些内存块只是原始的字节；为了将一块内存转换成一个可用的对象，我们必须在那个地址构造一个`T`的实例。我们可以使用“placement
    `new`”语法来达到这个目的；但我们将看到在下一节中为什么使用`construct`和`destroy`是重要的。
- en: Finally, before we proceed, notice that the destructor of `uniqueish` checks
    to see whether an allocation exists before trying to deallocate it. This is important
    because it gives us a value of `uniqueish` representing the "empty object"--a
    value that can be constructed without allocating any memory, and that is a suitably
    "moved-from" representation for our type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们继续之前，请注意`uniqueish`析构函数在尝试释放分配之前会检查是否存在分配。这很重要，因为它给我们一个代表“空对象”的`uniqueish`值——一个可以在不分配任何内存的情况下构造的值，并且是我们类型的一个合适的“移动后”表示。
- en: 'Now let''s implement the move operations for our type. We''d like to ensure
    that after you move out of a `uniqueish<T>` object, the moved-from object is "empty."
    Furthermore, if the left-hand object and the right-hand object share the same
    allocator, or if the allocator type is "not sticky," then we''d like to avoid
    calling the move constructor of `T` at all--we''d like to transfer ownership of
    the allocated pointer from the right-hand-side object to the left-hand object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现我们类型的移动操作。我们希望确保在从`uniqueish<T>`对象中移动之后，移动后的对象是“空的”。此外，如果左侧对象和右侧对象使用相同的分配器，或者如果分配器类型是“非粘性的”，那么我们希望根本不调用`T`的移动构造函数——我们希望将分配的指针的所有权从右侧对象转移到左侧对象：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The move *constructor* is just about as simple as it ever was. The only minor
    difference is that we have to remember to construct our `m_allocator` as a copy
    of the right-hand object's allocator.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数就像它曾经一样简单。唯一的细微差别是我们必须记住将我们的`m_allocator`构造为右侧对象分配器的副本。
- en: We could use `std::move` to move the allocator instead of copying it, but I
    didn't think it was worth it for this example. Remember that an allocator is just
    a thin "handle" pointing to the actual memory resource, and that a lot of allocator
    types, such as `std::allocator<T>`, are actually empty. Copying an allocator type
    should always be relatively cheap. Still, using `std::move` here wouldn't have
    hurt.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::move`来移动分配器而不是复制它，但我觉得在这个例子中这样做不值得。记住，分配器只是一个指向实际内存资源的薄“句柄”，并且许多分配器类型，如`std::allocator<T>`，实际上都是空的。复制分配器类型应该总是相对便宜的。尽管如此，在这里使用`std::move`并不会造成伤害。
- en: The move *assignment operator*, on the other hand, is very complicated! The
    first thing we need to do is check whether our allocator type is "sticky" or not.
    Non-stickiness is denoted by having a true value for `propagate_on_container_move_assignment::value`,
    which we abbreviate to "`pocma`." (Actually, the standard says that `propagate_on_container_move_assignment`
    ought to be *exactly* the type `std::true_type`; and GNU's libstdc++ will hold
    you firmly to that requirement. So watch out when defining your own allocator
    types.) If the allocator type is non-sticky, then our most efficient course of
    action for move-assignment is to destroy our current value (if any)--making sure
    to use our old `m_allocator`--and then adopt the right-hand object's pointer along
    with its allocator. Because we adopt the allocator along with the pointer, we
    can be sure that we'll know how to deallocate the pointer down the road.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，移动 *赋值运算符* 非常复杂！我们首先需要做的是检查我们的分配器类型是否是“粘性”的。非粘性通过 `propagate_on_container_move_assignment::value`
    的真值表示，我们将其缩写为 "`pocma`"。（实际上，标准说 `propagate_on_container_move_assignment` 应该是
    `std::true_type` 类型；GNU 的 libstdc++ 会严格遵循这一要求。所以当定义自己的分配器类型时要小心。）如果分配器类型是非粘性的，那么我们移动赋值的最高效做法是销毁我们的当前值（如果有的话）——确保使用我们的旧
    `m_allocator`——然后采用右手对象的指针及其分配器。因为我们同时采用指针和分配器，我们可以确信将来我们会知道如何释放那个指针。
- en: On the other hand, if our allocator type *is* "sticky," then we cannot adopt
    the allocator of the right-hand object. If our current ("stuck") allocator instance
    happens to be equal to the right-hand object's allocator instance, then we can
    adopt the right-hand object's pointer anyway; we already know how to deallocate
    pointers allocated by this particular allocator instance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们的分配器类型 *是* “粘性”的，那么我们就不能采用右手对象的分配器。如果我们的当前（“卡住”）的分配器实例恰好等于右手对象的分配器实例，那么我们无论如何都可以采用右手对象的指针；我们已经知道如何处理由这个特定分配器实例分配的指针。
- en: Finally, if we cannot adopt the right-hand object's allocator instance, and
    our current allocator instance isn't equal to the right-hand object's, then we
    cannot adopt the right-hand object's pointer--because at some point down the road
    we're going to have to free that pointer, and the only way to free that pointer
    is to use the right-hand object's allocator instance, and we're not allowed to
    adopt the right-hand object's allocator instance because our own instance is "stuck."
    In this case, we actually have to allocate a completely new pointer using our
    own allocator instance, and then copy over the data from `rhs.value()` to our
    own value by invoking the move constructor of `T`. This final case is the only
    one where we actually call the move constructor of `T`!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们不能采用右手对象的分配器实例，并且我们的当前分配器实例不等于右手对象的，那么我们就不能采用右手对象的指针——因为将来某个时候我们得释放那个指针，而唯一释放那个指针的方法是使用右手对象的分配器实例，但我们不允许采用右手对象的分配器实例，因为我们的实例是“卡住”的。在这种情况下，我们实际上必须使用自己的分配器实例分配一个全新的指针，然后通过调用
    `T` 的移动构造函数将数据从 `rhs.value()` 复制到我们的值。这种情况是唯一一个我们实际上调用 `T` 的移动构造函数的情况！
- en: Copy assignment follows similar logic for the propagation of the right-hand
    allocator instance, except that it looks at the trait `propagate_on_container_copy_assignment`,
    or "`pocca`."
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值在传播右手分配器实例的逻辑上遵循类似的逻辑，除了它查看特性 `propagate_on_container_copy_assignment`，或称为
    "`pocca`"。
- en: 'Swap is particularly interesting because its final case (when the allocator
    type is "sticky" and the allocator instances are unequal) requires extra allocations:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 交换特别有趣，因为它的最终情况（当分配器类型是“粘性”且分配器实例不相等时）需要额外的分配：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On each of the two lines marked "might throw," we're calling the move assignment
    operator, which in this case might call `emplace`, which will ask the allocator
    for memory. If the underlying memory resource has been exhausted, then `Traits::allocate(m_allocator,
    1)` might well throw an exception--and then we'd be in trouble, for two reasons.
    First, we've already started moving state around and deallocating old memory,
    and we might find it impossible to "unwind" back to a reasonable state. Second,
    and more importantly, `swap` is one of those functions that is so primitive and
    so fundamental that the standard library makes no provision for its failing--for
    example, the `std::swap` algorithm ([Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*) is declared as `noexcept`, which means it *must*
    succeed; it is not allowed to throw an exception.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记为“可能抛出异常”的两行中，我们正在调用移动赋值运算符，在这种情况下可能会调用`emplace`，这将要求分配器分配内存。如果底层内存资源已经耗尽，那么`Traits::allocate(m_allocator,
    1)`可能会抛出异常--然后我们就会遇到麻烦，原因有两个。首先，我们已经开始移动状态并释放旧内存，我们可能发现无法“回滚”到一个合理的状态。其次，更重要的是，`swap`是那些非常基础和原始的函数之一，标准库没有为其失败提供任何处理--例如，`std::swap`算法（[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*）被声明为`noexcept`，这意味着它*必须*成功；它不允许抛出异常。
- en: Thus, if allocation fails during our `noexcept` swap function, we'll see a `bad_alloc`
    exception percolate up through the call stack until it reaches our `noexcept`
    swap function declaration; at which point the C++ runtime will stop unwinding
    and call `std::terminate`, which (unless the programmer has altered its behavior
    via `std::set_terminate`) will cause our program to crash and burn.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果在我们的`noexcept`交换函数中发生分配失败，我们将在调用栈中看到`bad_alloc`异常逐层上升，直到它达到我们的`noexcept`交换函数声明；此时，C++运行时会停止回滚并调用`std::terminate`，除非程序员通过`std::set_terminate`更改其行为，否则这将导致我们的程序崩溃并终止。
- en: The C++17 Standard goes several steps further than this in its specification
    of what *ought* to happen during the swapping of standard container types. First,
    instead of saying that allocation failure during `swap` will result in a call
    to `std::terminate`, the Standard simply says that allocation failure during `swap`
    will result in *undefined behavior*. Second, the Standard does not limit that
    undefined behavior to allocation failure! According to the C++17 Standard, merely
    *calling* `swap` on any standard library container instances whose allocators
    do not compare equally will result in undefined behavior, whether an allocation
    failure would have been encountered or not!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标准在规范标准容器类型交换过程中应该发生的事情方面比这更进一步。首先，标准不是说明`swap`过程中的分配失败将导致调用`std::terminate`，而是简单地说明`swap`过程中的分配失败将导致*未定义行为*。其次，标准并没有将这种未定义行为限制在分配失败上！根据C++17标准，仅仅对任何分配器不平等比较的标准库容器实例调用`swap`将导致未定义行为，无论是否遇到分配失败！
- en: 'In fact, libc++ exploits this optimization opportunity to generate code for
    all standard container `swap` functions that looks roughly like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，libc++利用这个优化机会为所有标准容器`swap`函数生成代码，其大致形式如下：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that if you use this code (as libc++ does) to `swap` two containers with
    unequal allocators, you'll wind up with a mismatch between pointers and their
    allocators, and then your program will probably crash--or worse--the next time
    you try to deallocate one of those pointers using the mismatched allocator. It
    is supremely important that you remember this pitfall when dealing with the C++17
    "convenience" types such as `std::pmr::vector`!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你使用这个代码（如libc++所做）来交换具有不等价分配器的两个容器，你最终会在指针和它们的分配器之间出现不匹配，然后你的程序可能会崩溃--或者更糟--在你下次尝试使用不匹配的分配器释放这些指针时。在处理C++17的“便利”类型，如`std::pmr::vector`时，记住这个陷阱至关重要！
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If your code design allows containers backed by different memory resources
    to be swapped with each other, then you must avoid `std::swap` and instead use
    this safe idiom:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码设计允许不同内存资源支持的容器之间相互交换，那么你必须避免使用`std::swap`，而应使用这个安全的惯用语：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When I say "avoid `std::swap`," I mean "avoid any of the permutative algorithms
    in the STL," including such algorithms as `std::reverse` and `std::sort`. This
    would be quite an undertaking and I do not advise attempting it!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“避免`std::swap`”时，我的意思是“避免STL中的任何排列算法”，包括像`std::reverse`和`std::sort`这样的算法。这将是一项相当大的工作，我不建议尝试这样做！
- en: If your code design allows containers backed by different memory resources to
    be swapped with each other, then really, you *might* want to reconsider your design.
    If you can fix it so that you only ever swap containers that share the same memory
    resource, or if you can avoid stateful and/or sticky allocators entirely, then
    you will never need to think about this particular pitfall.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码设计允许不同内存资源支持的容器之间可以互换，那么实际上，你可能真的需要重新考虑你的设计。如果你能够修复它，使得你只能交换共享相同内存资源的容器，或者如果你可以完全避免有状态的和/或粘性的分配器，那么你就永远不需要考虑这个特定的陷阱。
- en: Propagating downwards with scoped_allocator_adaptor
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过scoped_allocator_adaptor向下传播
- en: In the preceding section, we introduced `std::allocator_traits<A>::construct(a,
    ptr, args...)` and described it as a preferable alternative to the placement-`new`
    syntax `::new ((void*)ptr) T(args...)`. Now we'll see why the author of a particular
    allocator might want to give it different semantics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了`std::allocator_traits<A>::construct(a, ptr, args...)`，并将其描述为比placement-`new`语法`::new
    ((void*)ptr) T(args...)`更可取的替代方案。现在我们将看到为什么某个特定分配器的作者可能希望给它不同的语义。
- en: 'One perhaps obvious way to change the semantics of `construct` for our own
    allocator type would be to make it trivially default-initialize primitive types
    instead of zero-initializing them. That code would look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 改变我们自己的分配器类型`construct`的语义的一个可能明显的方法是，对于原始类型，使其以默认方式初始化，而不是零初始化。代码看起来会是这样：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you can use `std::vector<int, my_allocator<int>>` as a "vector-like" type
    satisfying all the usual invariants of `std::vector<int>`, except that when you
    implicitly create new elements via `v.resize(n)` or `v.emplace_back()`, the new
    elements are created uninitialized, just like stack variables, instead of being
    zero-initialized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`std::vector<int, my_allocator<int>>`作为一个“类似向量”的类型，满足`std::vector<int>`的所有常用不变性，除了当你通过`v.resize(n)`或`v.emplace_back()`隐式创建新元素时，新元素是未初始化的，就像栈变量一样，而不是被零初始化。
- en: In a sense, what we've designed here is an "adaptor" that fits over the top
    of `std::allocator<T>` and modifies its behavior in an interesting way. It would
    be even better if we could modify or "adapt" any arbitrary allocator in the same
    way; to do that, we'd just change our `template<class T>` to `template<class A>`
    and inherit from `A` where the old code inherited from `std::allocator<T>`. Of
    course our new adaptor's template parameter list no longer starts with `T`, so
    we'd have to implement `rebind` ourselves; this path quickly gets into deep metaprogramming,
    so I won't digress to show it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们在这里设计的是一个“适配器”，它覆盖在`std::allocator<T>`之上，并以一种有趣的方式修改其行为。如果我们能够以同样的方式修改或“适配”任何任意的分配器那就更好了；为了做到这一点，我们只需将我们的`template<class
    T>`更改为`template<class A>`，并在旧代码继承自`std::allocator<T>`的地方从`A`继承。当然，我们新的适配器的模板参数列表不再以`T`开头，因此我们不得不自己实现`rebind`；这条路径很快就会进入深层次的元编程，所以我就不展开说明了。
- en: 'However, there''s another useful way we could fiddle with the `construct` method
    for our own allocator type. Consider the following code sample, which creates
    a vector of vectors of `int`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以用另一种有用的方法来调整我们自己的分配器类型的`construct`方法。考虑以下代码示例，它创建了一个`int`类型的向量向量：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Suppose we wanted to "stick" this container to a memory resource of our own
    devising, such as our favorite `WidgetAlloc`. We''d have to write something repetitive
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将这个容器“粘”到我们自己设计的内存资源上，比如我们最喜欢的`WidgetAlloc`。我们不得不写一些重复性的代码，如下所示：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice the repetition of the allocator object's initializer `&mr` at both levels.
    The need to repeat `&mr` makes it difficult to use our vector `vv` in generic
    contexts; for example, we can't easily pass it to a function template to populate
    it with data, because every time the callee would want to `emplace_back` a new
    vector-of-`int`, it would need to know the address `&mr` that is only known to
    the caller. What we'd like to do is wrap up and reify the notion that "every time
    you construct an element of the vector-of-vectors, you need to tack `&mr` onto
    the end of the argument list." And the standard library has us covered!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分配器对象的初始化器`&mr`在两个级别上的重复。需要重复`&mr`使得在泛型上下文中使用我们的向量`vv`变得困难；例如，我们无法轻易将其传递给一个函数模板以填充数据，因为每次被调用者想要`emplace_back`一个新的`int`向量时，它都需要知道只有调用者知道的地址`&mr`。我们想要做的是封装并具体化“每次你构造向量向量的元素时，你都需要将`&mr`附加到参数列表的末尾”的概念。而标准库已经为我们提供了解决方案！
- en: Since C++11, the standard library has provided (in the header named `<scoped_allocator>`)
    a class template called `scoped_allocator_adaptor<A>`. Just like our default-initializing
    "adaptor," `scoped_allocator_adaptor<A>` inherits from `A`, thus picking up all
    of `A`'s behaviors; and then it overrides the `construct` method to do something
    different. Namely, it attempts to figure out whether the `T` object it's currently
    constructing "uses an allocator," and if so, it will pass itself down as an extra
    argument to the constructor of `T`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C++11以来，标准库在名为`<scoped_allocator>`的头文件中提供了一个名为`scoped_allocator_adaptor<A>`的类模板。就像我们的默认初始化“适配器”一样，`scoped_allocator_adaptor<A>`继承自`A`，从而继承了`A`的所有行为；然后它重写了`construct`方法以执行不同的操作。具体来说，它试图弄清楚它当前正在构建的`T`对象是否“使用分配器”，如果是的话，它将把自己作为额外的参数传递给`T`的构造函数。
- en: To decide whether type `T` "uses an allocator," `scoped_allocator_adaptor<A>::construct`
    defers to the type trait `std::uses_allocator_v<T,A>`, which (unless you've specialized
    it, which you probably shouldn't) will be true if and only if `A` is implicitly
    convertible to `T::allocator_type`. If `T` doesn't have an `allocator_type`, then
    the library will assume that `T` doesn't care about allocators, except in the
    special cases of `pair` and `tuple` (which all have special overloads of their
    constructors intended specifically to propagate allocators downward to their members)
    and in the special case of `promise` (which can allocate its shared state with
    an allocator even though it provides no way of referring to that allocator object
    afterward; we say that `promise`'s allocator support is "type-erased" even more
    thoroughly than the examples of type erasure we saw in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '要决定类型`T`是否“使用分配器”，`scoped_allocator_adaptor<A>::construct`会委托给类型特性`std::uses_allocator_v<T,A>`，除非你已对其进行特化（你很可能不应该这样做），否则当且仅当`A`可以隐式转换为`T::allocator_type`时，它将为真。如果`T`没有`allocator_type`，那么库将假设`T`不关心分配器，除了`pair`和`tuple`的特殊情况（它们都有针对特定于成员的分配器传播的构造函数的重载）以及`promise`的特殊情况（即使它没有提供引用该分配器对象的方法，它也可以使用分配器分配其共享状态；我们说`promise`的分配器支持比我们在[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，*词汇类型*中看到的类型擦除示例更彻底地“类型擦除”）。 '
- en: 'For historical reasons, the constructors of allocator-aware types can follow
    either of two different patterns, and `scoped_allocator_adaptor` is smart enough
    to know them both. Older and simpler types (that is, everything except `tuple`
    and `promise`) tend to have constructors of the form `T(args..., A)` where the
    allocator `A` comes at the end. For `tuple` and `promise`, the standard library
    has introduced a new pattern: `T(std::allocator_arg, A, args...)` where the allocator
    `A` comes at the beginning but is preceded by the special tag value `std::allocator_arg`,
    whose sole purpose is to indicate that the next argument in the argument list
    represents an allocator, similarly to how the sole purpose of the tag `std::nullopt`
    is to indicate that an `optional` has no value (see [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*). Just as the standard forbids creating the type `std::optional<std::nullopt_t>`,
    you will also find yourself in a world of trouble if you attempt to create `std::tuple<std::allocator_arg_t>`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，分配器感知类型的构造函数可以遵循两种不同的模式，而`scoped_allocator_adaptor`足够智能，可以知道它们两个。较旧且简单的类型（即除了`tuple`和`promise`之外的所有类型）通常具有形式为`T(args...,
    A)`的构造函数，其中分配器`A`位于末尾。对于`tuple`和`promise`，标准库引入了一种新的模式：`T(std::allocator_arg,
    A, args...)`，其中分配器`A`位于开头，但前面有一个特殊的标记值`std::allocator_arg`，其唯一目的是指示参数列表中的下一个参数代表一个分配器，类似于标记`std::nullopt`的唯一目的是指示`optional`没有值（参见[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，*词汇类型*）。就像标准禁止创建类型`std::optional<std::nullopt_t>`一样，如果你尝试创建`std::tuple<std::allocator_arg_t>`，你也会发现自己陷入麻烦。
- en: 'Using `scoped_allocator_adaptor`, we can rewrite our cumbersome example from
    earlier in a slightly less cumbersome way:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`scoped_allocator_adaptor`，我们可以以前一种稍微不那么繁琐的方式重写我们之前繁琐的例子：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that the allocator type has gotten *more* cumbersome, but the important
    thing is that the `&mr` argument to `emplace_back` has disappeared; we can now
    use `vv` in contexts that expect to be able to push back elements in a natural
    way, without having to remember to add `&mr` all over the place. In our case,
    because we're using our `WidgetAlloc`, which is not default-constructible, the
    symptom of a forgotten `&mr` is a spew of compile-time errors. But you may recall
    from preceding sections in this chapter that `std::pmr::polymorphic_allocator<T>`
    will happily allow you to default-construct it, with potentially disastrous results;
    so if you are planning to use `polymorphic_allocator`, it might also be wise to
    look into `scoped_allocator_adaptor` just in order to limit the number of places
    in which you might forget to specify your allocation strategy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到分配器类型变得更加繁琐，但重要的是 `emplace_back` 的 `&mr` 参数已经消失了；我们现在可以在期望能够以自然方式推送元素的环境中使用
    `vv`，而无需记住到处添加 `&mr`。在我们的情况下，因为我们使用的是我们的 `WidgetAlloc`，它不是默认可构造的，所以忘记 `&mr` 的症状是一系列编译时错误。但你可能还记得，在本章前面的部分中，`std::pmr::polymorphic_allocator<T>`
    会愉快地允许你默认构造它，这可能会产生灾难性的后果；所以如果你计划使用 `polymorphic_allocator`，那么查看 `scoped_allocator_adaptor`
    也可能是明智的，只是为了限制你可能忘记指定分配策略的地方数量。
- en: Propagating different allocators
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传播不同的分配器
- en: 'In my introduction of `scoped_allocator_adaptor<A>`, I left out one more complication.
    The template parameter list isn''t limited to just one allocator type argument!
    You can actually create a scoped-allocator type with multiple allocator type arguments,
    like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我介绍 `scoped_allocator_adaptor<A>` 时，遗漏了一个更复杂的点。模板参数列表不仅限于只有一个分配器类型参数！实际上，你可以创建一个具有多个分配器类型参数的
    scoped-allocator 类型，如下所示：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having set up these typedefs, we proceed to set up three distinct memory resources
    and construct an instance of `scoped_allocator_adaptor` capable of remembering
    all three of the memory resources (because it contains three distinct instances
    of `WidgetAlloc`, one per "level"):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置这些 `typedef` 之后，我们继续设置三个不同的内存资源，并构造一个能够记住所有三个内存资源的 `scoped_allocator_adaptor`
    实例（因为它包含三个不同的 `WidgetAlloc` 实例，每个“级别”一个）：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we can construct an instance of `OuterVector`, passing in our `scoped_allocator_adaptor`
    argument; and that''s all! The overridden `construct` method hidden deep within
    our carefully crafted allocator type takes care of passing the argument `&bm`
    or `&bi` to any constructor that needs one of them:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构造一个 `OuterVector` 的实例，传入我们的 `scoped_allocator_adaptor` 参数；这就全部完成了！我们精心设计的分配器类型中隐藏的
    `construct` 方法会负责将 `&bm` 或 `&bi` 参数传递给需要其中一个的任何构造函数：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, a deeply nested `scoped_allocator_adaptor` is not for the faint
    of heart; and they're really only usable at all if you make a lot of "helper"
    typedefs along the way, as we did in this example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个深度嵌套的 `scoped_allocator_adaptor` 并不是为胆小的人准备的；而且它们只有在沿途创建了很多“辅助” `typedef`
    的情况下才能使用，就像我们在本例中所做的那样。
- en: 'One last note about `std::scoped_allocator_adaptor<A...>`: if the nesting of
    containers goes deeper than the number of allocator types in the template parameter
    list, then `scoped_allocator_adaptor` will act as if the last allocator type in
    its parameter list repeats forever. For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `std::scoped_allocator_adaptor<A...>` 的最后一点说明：如果容器的嵌套深度超过了模板参数列表中分配器类型的数量，那么
    `scoped_allocator_adaptor` 将会像其参数列表中的最后一个分配器类型无限重复一样行事。例如：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We actually relied on this behavior in our very first `scoped_allocator_adaptor`
    example, the one involving `vv`, even though I didn't mention it at the time.
    Now that you know about it, you might want to go back and study that example to
    see where the "repeat forever" behavior is being used, and how you'd change that
    code if you wanted to use a different memory resource for the inner array of `int`
    than for the outer array of `InnerVector`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在第一个 `scoped_allocator_adaptor` 示例中就依赖了这种行为，即涉及 `vv` 的那个示例，尽管当时我没有提到。现在你知道了这一点，你可能想回去研究那个示例，看看“无限重复”的行为在哪里被使用，如果你想要为
    `int` 的内部数组使用不同于外部 `InnerVector` 数组的内存资源，你应该如何修改那段代码。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Allocators are a fundamentally arcane topic in C++, mainly for historical reasons.
    Several different interfaces, with different obscure use-cases, are piled one
    on top of the other; all of them involve intense metaprogramming; and vendor support
    for many of these features, even relatively old C++11 features such as fancy pointers,
    is still lacking.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器是 C++ 中一个基本深奥的话题，主要由于历史原因。几个不同的接口，具有不同的晦涩用途，层层叠叠；所有这些都涉及强烈的元编程；并且许多这些特性（即使是相对较旧的
    C++11 特性，如花哨的指针）的供应商支持仍然不足。
- en: C++17 offers the standard library type `std::pmr::memory_resource` to clarify
    the existing distinction between *memory resources* (a.k.a. *heaps*) and `allocators`
    (a.k.a. *handles* to heaps). Memory resources provide `allocate` and `deallocate`
    methods; allocators provide those methods as well as `construct` and `destroy`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 提供了标准库类型 `std::pmr::memory_resource` 来阐明现有 *内存资源*（即 *堆*）和 `allocators`（即
    *堆的句柄*）之间的区别。内存资源提供 `allocate` 和 `deallocate` 方法；分配器提供这些方法以及 `construct` 和 `destroy`
    方法。
- en: If you implement your own allocator type `A`, it must be a template; its first
    template parameter should be the type `T` that it expects to `allocate`. Your
    allocator type `A` must also have a templated constructor to support "rebinding"
    from `A<U>` to `A<T>`. Just like any other kind of pointer, an allocator type
    must support the `==` and `!=` operators.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了自己的分配器类型 `A`，它必须是一个模板；它的第一个模板参数应该是它期望`分配`的类型 `T`。你的分配器类型 `A` 还必须有一个模板构造函数来支持从
    `A<U>` 到 `A<T>` 的“重新绑定”。就像任何其他类型的指针一样，分配器类型必须支持 `==` 和 `!=` 操作符。
- en: A heap's `deallocate` method is allowed to require additional metadata attached
    to the incoming pointer. C++ handles this via *fancy pointers*. C++17's `std::pmr::memory_resource`
    does not support fancy pointers, but it's easy to implement your own.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的 `deallocate` 方法允许要求附加到传入指针的额外元数据。C++ 通过 *花哨的指针* 来处理这一点。C++17 的 `std::pmr::memory_resource`
    不支持花哨的指针，但实现自己的并不困难。
- en: Fancy pointer types must satisfy all the requirements of random access iterators,
    and must be nullable, and must be convertible to plain raw pointers. If you want
    to use your fancy pointer type with node-based containers such as `std::list`,
    you must give it a static `pointer_to` member function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 花哨指针类型必须满足所有随机访问迭代器的需求，并且必须是可空的，并且必须可转换为普通原始指针。如果你想使用你的花哨指针类型与基于节点的容器，如 `std::list`，你必须给它一个静态的
    `pointer_to` 成员函数。
- en: C++17 distinguishes between "sticky" and "non-sticky" allocator types. Stateless
    allocator types such as `std::allocator<T>` are non-sticky; stateful allocator
    types such as `std::pmr::polymorphic_allocator<T>` are sticky by default. Making
    your own allocator type of a non-default stickiness requires setting all three
    of the member typedefs familiarly known as "POCCA," "POCMA," and "POCS." Sticky
    allocator types such as `std::pmr::polymorphic_allocator<T>` are useful primarily--perhaps
    only--in classical object-oriented situations, where a container object is pinned
    to a particular memory address. Value-oriented programming (with lots of moves
    and swaps) calls for stateless allocator types, or else for everyone in the program
    to use the same heap and a single sticky but *effectively stateless* allocator
    type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 区分了“粘性”和“非粘性”分配器类型。无状态分配器类型，如 `std::allocator<T>`，是非粘性的；有状态分配器类型，如 `std::pmr::polymorphic_allocator<T>`，默认是粘性的。创建一个非默认粘性的自定义分配器类型需要设置三个成员类型别名，通常称为“POCCA”、“POCMA”和“POCS”。粘性分配器类型，如
    `std::pmr::polymorphic_allocator<T>`，主要用于——或许仅用于——经典面向对象的情况，其中容器对象被固定在特定的内存地址上。面向值的编程（涉及大量移动和交换操作）需要无状态分配器类型，或者程序中的每个人都要使用相同的堆和单个粘性但*实际上无状态*的分配器类型。
- en: '`scoped_allocator_adaptor<A...>` can help simplify the usage of deeply nested
    containers that use custom allocators or memory resources. Just about any deeply
    nested container using a non-default allocator type requires a lot of helper typedefs
    to remain even remotely readable.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_allocator_adaptor<A...>` 可以帮助简化使用自定义分配器或内存资源的深层嵌套容器的使用。几乎任何使用非默认分配器类型的深层嵌套容器都需要大量的辅助类型别名来保持可读性。'
- en: 'Swapping two containers with unequal sticky allocators: in theory this invokes
    undefined behavior, and in practice it corrupts memory and segfaults. Don''t do
    it!'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 交换两个具有不同粘性分配器的容器：在理论上这会引发未定义的行为，在实践中会破坏内存并导致段错误。不要这样做！
