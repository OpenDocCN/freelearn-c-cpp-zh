<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Smart Pointers</h1>
                
            
            
                
<p class="calibre2">C++ holds its grip on large swaths of the software industry by virtue of its performance--well-written C++ code runs faster than anything else out there, <em class="calibre22">almost</em> by definition, because C++ gives the programmer almost complete control over the code that is ultimately generated by the compiler.</p>
<p class="calibre2">One of the classic features of low-level, performant code is the use of <em class="calibre22">raw pointers</em> (<kbd class="calibre12">Foo*</kbd>). However, raw pointers come with many pitfalls, such as memory leaks and dangling pointers. The C++11 library's "smart pointer" types can help you avoid these pitfalls at little to no expense.</p>
<p class="calibre2">In this chapter we'll learn the following:</p>
<ul class="calibre14">
<li class="calibre15">The definition of "smart pointer" and how you might write your own</li>
<li class="calibre15">The usefulness of <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> in preventing resource leaks of all types (not just memory leaks)</li>
<li class="calibre15">How <kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd> is implemented, and its implications for memory usage</li>
<li class="calibre15">The meaning and uses of the Curiously Recurring Template Pattern</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The origins of smart pointers</h1>
                
            
            
                
<p class="calibre2">Raw pointers have many uses in C:</p>
<ul class="calibre14">
<li class="calibre15">As a cheap, non-copying view of an object owned by the caller</li>
<li class="calibre15">As a way for the callee to modify an object owned by the caller</li>
<li class="calibre15">As one-half of a pointer/length pair, used for arrays</li>
<li class="calibre15">As an optional argument (either a valid pointer <em class="calibre22">or</em> null)</li>
<li class="calibre15">As a way to manage memory on the heap</li>
</ul>
<p class="calibre2">In C++, we have native references (<kbd class="calibre12">const Foo&amp;</kbd> and <kbd class="calibre12">Foo&amp;</kbd>) to handle the first two bullets; plus, move semantics makes it cheap for a callee to take and pass back a complex object by value in most cases, thus completely avoiding aliasing. In C++17 we can use <kbd class="calibre12">std::string_view</kbd> to address some of the first and third bullet. And we've just seen in <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>, that passing an <kbd class="calibre12">optional&lt;T&gt;</kbd>--or perhaps getting fancy with an <kbd class="calibre12">optional&lt;reference_wrapper&lt;T&gt;&gt;</kbd>--is sufficient to handle the fourth bullet.</p>
<p class="calibre2">This chapter will be concerned with the fifth bullet.</p>
<p class="calibre2">Heap allocation comes with a host of problems in C, and all those problems (and more!) applied to C++ prior to 2011. As of C++11, though, almost all of those problems have disappeared. Let's enumerate them:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Memory leaks</strong>: You might allocate a piece of memory or an object on the heap, and accidentally forget to write the code that frees it.</li>
<li class="calibre15"><strong class="calibre1">Memory leaks</strong>: You might have written that code, but due to an early return or an exception being thrown, the code never runs and the memory remains unfreed!</li>
<li class="calibre15"><strong class="calibre1">Use-after-free</strong>: You take a copy of a pointer to an object on the heap, and then free that object through the original pointer. The holder of the copied pointer doesn't realize that their pointer is no longer valid.</li>
<li class="calibre15"><strong class="calibre1">Heap corruption via pointer arithmetic</strong>: You allocate an array on the heap at address <em class="calibre22">A</em>. Having a raw pointer to an array tempts you to do pointer arithmetic, and in the end you accidentally free a pointer to address <em class="calibre22">A</em>+<em class="calibre22">k</em>. When <em class="calibre22">k</em>=0 (as Murphy's Law ensures it will be, in testing) there is no problem; when <em class="calibre22">k</em>=1 you corrupt your heap and cause a crash.</li>
</ul>
<p class="calibre2">The first two problems are compounded by the fact that heap allocation is semantically allowed to fail--<kbd class="calibre12">malloc</kbd> can return null, <kbd class="calibre12">operator new</kbd> can throw <kbd class="calibre12">std::bad_alloc</kbd>--which means that if you're writing pre-C++11 code that allocates memory, you are probably writing a lot of cleanup code to deal with allocation failure. (In C++, you're "writing" that code whether you know it or not, because the control flow paths due to exception handling are there even if you're not consciously thinking about them.) The upshot of all this is that managing heap-allocated memory in C++ is <em class="calibre22">hard</em>.</p>
<p class="calibre2">Unless you use smart pointers!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Smart pointers never forget</h1>
                
            
            
                
<p class="calibre2">The idea of a "smart pointer" type (not to be confused with a "fancy pointer" type, which we'll cover in <a href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>) is that it's a class--typically a class template--which behaves syntactically just like a pointer, but whose special member functions (construction, destruction, and copying/moving) have additional bookkeeping to ensure certain invariants. For example, we might ensure the following:</p>
<ul class="calibre14">
<li class="calibre15">The pointer's destructor also frees its pointee--helping to solve memory leaks</li>
<li class="calibre15">Maybe the pointer cannot be copied--helping to solve use-after-free</li>
<li class="calibre15">Or maybe the pointer <em class="calibre22">can</em> be copied, but it knows how many copies exist and won't free the pointee until the last pointer to it has been destroyed</li>
<li class="calibre15">Or maybe the pointer can be copied, and you can free the pointee, but if you do, all other pointers to it magically become null</li>
<li class="calibre15">Or maybe the pointer has no built-in <kbd class="calibre12">operator+</kbd>--helping<br class="title-page-name"/>
to solve corruption due to pointer arithmetic</li>
<li class="calibre15">Or maybe you're allowed to adjust the pointer's value arithmetically, but the arithmetic "what object is pointed-to" is managed separately from the identity of "what object is to be freed"</li>
</ul>
<p class="calibre2">The standard smart pointer types are <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd>, <kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd>, and (not really a pointer type, but we'll lump it in with them) <kbd class="calibre12">std::weak_ptr&lt;T&gt;</kbd>. In this chapter we'll cover all three of those types, plus one non-standard smart pointer that you might find useful--and which might become a standard smart pointer type in a future C++ standard!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Automatically managing memory with std::unique_ptr&lt;T&gt;</h1>
                
            
            
                
<p class="calibre2">The fundamental properties of a smart pointer type are simple: it should support <kbd class="calibre12">operator*</kbd>, and it should overload the special member functions to preserve its class invariants, whatever those are.</p>
<p class="calibre2"><kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> supports the same interface as <kbd class="calibre12">T*</kbd>, but with the class invariant that, once you construct a <kbd class="calibre12">unique_ptr</kbd> pointing to a given heap-allocated object, that object <em class="calibre22">will</em> be freed when the destructor <kbd class="calibre12">unique_ptr</kbd> is called. Let's write some code supporting that <kbd class="calibre12">T*</kbd> interface:</p>
<pre class="calibre23">    template&lt;typename T&gt;<br class="title-page-name"/>    class unique_ptr {<br class="title-page-name"/>      T *m_ptr = nullptr;<br class="title-page-name"/>    public:<br class="title-page-name"/>      constexpr unique_ptr() noexcept = default;<br class="title-page-name"/>      constexpr unique_ptr(T *p) noexcept : m_ptr(p) {}<br class="title-page-name"/> <br class="title-page-name"/>      T *get() const noexcept { return m_ptr; }<br class="title-page-name"/>      operator bool() const noexcept { return bool(get()); }<br class="title-page-name"/>      T&amp; operator*() const noexcept { return *get(); }<br class="title-page-name"/>      T* operator-&gt;() const noexcept { return get(); }</pre>
<p class="calibre2">If we stopped here--with just a way to construct a pointer object from a <kbd class="calibre12">T*</kbd> and a way to get the pointer out again--we'd have the <kbd class="calibre12">observer_ptr&lt;T&gt;</kbd> discussed at the end of this chapter. But we'll keep going. We'll add methods <kbd class="calibre12">release</kbd> and <kbd class="calibre12">reset</kbd>:</p>
<pre class="calibre23">      void reset(T *p = nullptr) noexcept {<br class="title-page-name"/>        T *old_p = std::exchange(m_ptr, p);<br class="title-page-name"/>        delete old_p;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      T *release() noexcept {<br class="title-page-name"/>        return std::exchange(m_ptr, nullptr);<br class="title-page-name"/>      }</pre>
<p class="calibre2"><kbd class="calibre12">p.release()</kbd> is just like <kbd class="calibre12">p.get()</kbd>, but in addition to returning a copy of the original raw pointer, it nulls out the contents of <kbd class="calibre12">p</kbd> (without freeing the original pointer, of course, because presumably our caller wants to take ownership of it).</p>
<p class="calibre2"><kbd class="calibre12">p.reset(q)</kbd> <em class="calibre22">does</em> free the current contents of <kbd class="calibre12">p</kbd>, and then puts the raw pointer <kbd class="calibre12">q</kbd> in its place.</p>
<p class="calibre2">Notice that we have implemented both of these member functions in terms of the standard algorithm <kbd class="calibre12">std::exchange</kbd>, which we didn't cover in <a href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator-Pair Algorithms</em>. It's sort of a value-returning version of <kbd class="calibre12">std::swap</kbd>: pass in a new value, get out the former value.</p>
<p class="calibre2">Finally, with these two primitive operations, we can implement the special member functions of <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> so as to preserve our invariant--which, again, is this: once a raw pointer has been acquired by a <kbd class="calibre12">unique_ptr</kbd> object, it will remain valid as long as the <kbd class="calibre12">unique_ptr</kbd> object has the same value, and when that's no longer true--when the <kbd class="calibre12">unique_ptr</kbd> is adjusted to point elsewhere, or destroyed--the raw pointer will be freed correctly. Here are the special member functions:</p>
<pre class="calibre23">      unique_ptr(unique_ptr&amp;&amp; rhs) noexcept {<br class="title-page-name"/>        this-&gt;reset(rhs.release());<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      unique_ptr&amp; operator=(unique_ptr&amp;&amp; rhs) noexcept {<br class="title-page-name"/>        reset(rhs.release());<br class="title-page-name"/>        return *this;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      ~unique_ptr() {<br class="title-page-name"/>        reset();<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">In memory, our <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> will look like this:</p>
<div><img src="img/00017.jpeg" class="calibre41"/></div>
<p class="calibre2">There is one more little helper function we need, so as never to touch raw pointers with our hands:</p>
<pre class="calibre23">    template&lt;typename T, typename... Args&gt;<br class="title-page-name"/>    unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)<br class="title-page-name"/>    {<br class="title-page-name"/>      return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));<br class="title-page-name"/>    }</pre>
<p class="calibre2">With <kbd class="calibre12">unique_ptr</kbd> in our toolbox, we can replace old-style code such as this:</p>
<pre class="calibre23">    struct Widget {<br class="title-page-name"/>      virtual ~Widget();<br class="title-page-name"/>    };<br class="title-page-name"/>    struct WidgetImpl : Widget {<br class="title-page-name"/>      WidgetImpl(int size);<br class="title-page-name"/>    };<br class="title-page-name"/>    struct WidgetHolder {<br class="title-page-name"/>      void take_ownership_of(Widget *) noexcept;<br class="title-page-name"/>    };<br class="title-page-name"/>    void use(WidgetHolder&amp;);<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      Widget *w = new WidgetImpl(30);<br class="title-page-name"/>      WidgetHolder *wh;<br class="title-page-name"/>      try {<br class="title-page-name"/>        wh = new WidgetHolder();<br class="title-page-name"/>      } catch (...) {<br class="title-page-name"/>        delete w;<br class="title-page-name"/>        throw;<br class="title-page-name"/>      }<br class="title-page-name"/>      wh-&gt;take_ownership_of(w);<br class="title-page-name"/>      try {<br class="title-page-name"/>        use(*wh);<br class="title-page-name"/>      } catch (...) {<br class="title-page-name"/>        delete wh;<br class="title-page-name"/>        throw;<br class="title-page-name"/>      }<br class="title-page-name"/>      delete wh;<br class="title-page-name"/>    }</pre>
<p class="calibre2">It can be replaced with modern C++17 code like this:</p>
<pre class="calibre23">    void test() {<br class="title-page-name"/>      auto w = std::make_unique&lt;WidgetImpl&gt;(30);<br class="title-page-name"/>      auto wh = std::make_unique&lt;WidgetHolder&gt;();<br class="title-page-name"/>      wh-&gt;take_ownership_of(w.release());<br class="title-page-name"/>      use(*wh);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that <kbd class="calibre12">unique_ptr&lt;T&gt;</kbd> is yet another application of <strong class="calibre1">RAII</strong>--in this case, quite literally. Although the "interesting" action (the freeing of the underlying raw pointer) still happens during destruction (of the <kbd class="calibre12">unique_ptr</kbd>), the only way you'll get the full benefit of <kbd class="calibre12">unique_ptr</kbd> is if you make sure that whenever you <em class="calibre22">allocate</em> a <em class="calibre22">resource</em>, you also <em class="calibre22">initialize</em> a <kbd class="calibre12">unique_ptr</kbd> to manage it. The <kbd class="calibre12">std::make_unique&lt;T&gt;()</kbd> function shown in the previous section (and introduced to the standard library in C++14) is the key to safe memory management in modern C++.</p>
<p class="calibre2">While it is <em class="calibre22">possible</em> to use <kbd class="calibre12">unique_ptr</kbd> without using <kbd class="calibre12">make_unique</kbd>, you should not do it:</p>
<pre class="calibre23">    std::unique_ptr&lt;Widget&gt; bad(new WidgetImpl(30));<br class="title-page-name"/>    bad.reset(new WidgetImpl(40));<br class="title-page-name"/><br class="title-page-name"/>    std::unique_ptr&lt;Widget&gt; good = std::make_unique&lt;WidgetImpl&gt;(30);<br class="title-page-name"/>    good = std::make_unique&lt;WidgetImpl&gt;(40);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Why C++ doesn't have the finally keyword</h1>
                
            
            
                
<p class="calibre2">Consider again this snippet of code from the preceding section's "pre-modern" code sample:</p>
<pre class="calibre23">    try {<br class="title-page-name"/>      use(*wh);<br class="title-page-name"/>    } catch (...) {<br class="title-page-name"/>      delete wh;<br class="title-page-name"/>      throw;<br class="title-page-name"/>    }<br class="title-page-name"/>    delete wh;</pre>
<p class="calibre2">In other languages such as Java and Python, these semantics might be expressed more compactly using the <kbd class="calibre12">finally</kbd> keyword:</p>
<pre class="calibre23">    try {<br class="title-page-name"/>      use(*wh);<br class="title-page-name"/>    } finally {<br class="title-page-name"/>      delete wh;<br class="title-page-name"/>    }</pre>
<p class="calibre2">C++ doesn't have the <kbd class="calibre12">finally</kbd> keyword, and shows no signs that it will ever enter the language. This is simply due to a philosophical difference between C++ and those other languages: the C++ philosophy is that if you're concerned with <em class="calibre22">enforcing some invariant</em>--such as "this pointer shall always be freed at the end of this block, no matter how we get there"--then you shouldn't ever be writing <em class="calibre22">explicit code</em>, because then there's always a chance for you to write it wrong, and then you'll have bugs.</p>
<p class="calibre2">If you have some <em class="calibre22">invariant</em> that you want to enforce, then the right place to enforce it is <em class="calibre22">in the type system</em>, using constructors, destructors, and other special member functions--the tools of RAII. Then, you can ensure that <em class="calibre22">any possible</em> use of your new type preserves its invariants--such as "the underlying pointer shall be freed whenever it's no longer held by an object of this type"--and when you go to write your business logic, you won't have to write anything explicitly; the code will look simple and yet always--provably--have correct behavior.</p>
<p class="calibre2">So if you find yourself writing code that looks like the preceding example, or if you find yourself wishing you could just write <kbd class="calibre12">finally</kbd>, stop and think: "Should I be using <kbd class="calibre12">unique_ptr</kbd> for this?" or "Should I write an RAII class type for this?"</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Customizing the deletion callback</h1>
                
            
            
                
<p class="calibre2">Speaking of custom RAII types, you might be wondering whether it's possible to use <kbd class="calibre12">std::unique_ptr</kbd> with a customized deletion callback: for example, instead of passing the underlying pointer to <kbd class="calibre12">delete</kbd>, you might want to pass it to <kbd class="calibre12">free()</kbd>. Yes you can!</p>
<p class="calibre2"><kbd class="calibre12">std::unique_ptr&lt;T,D&gt;</kbd> has a second template type parameter: a <em class="calibre22">deletion callback type</em>. The parameter <kbd class="calibre12">D</kbd> defaults to <kbd class="calibre12">std::default_delete&lt;T&gt;</kbd>, which just calls <kbd class="calibre12">operator delete</kbd>, but you can pass in any type you want--typically a user-defined class type with an overloaded <kbd class="calibre12">operator()</kbd>:</p>
<pre class="calibre23">    struct fcloser {<br class="title-page-name"/>      void operator()(FILE *fp) const {<br class="title-page-name"/>        fclose(fp);<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      static auto open(const char *name, const char *mode) {<br class="title-page-name"/>        return std::unique_ptr&lt;FILE, fcloser&gt;(fopen(name, mode));<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void use(FILE *);<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      auto f = fcloser::open("test.txt", "r");<br class="title-page-name"/>      use(f.get());<br class="title-page-name"/>      // f will be closed even if use() throws<br class="title-page-name"/>    }</pre>
<p class="calibre2">Incidentally, notice that the destructor of <kbd class="calibre12">std::unique_ptr</kbd> is carefully written so that it guarantees never to call your callback with a null pointer. This is absolutely critical in the preceding example, because <kbd class="calibre12">fclose(NULL)</kbd> is a special case that means "close all open file handles in the current process"--which is never what you wanted to do!</p>
<p class="calibre2">Observe also that <kbd class="calibre12">std::make_unique&lt;T&gt;()</kbd> only ever takes one template type parameter; there is no <kbd class="calibre12">std::make_unique&lt;T,D&gt;()</kbd>. But the rule to avoid touching raw pointers with your hands is still a good one; that's why our preceding example wraps the <kbd class="calibre12">fopen</kbd> and <kbd class="calibre12">unique_ptr</kbd> construction into a small reusable helper function <kbd class="calibre12">fcloser::open</kbd>, rather than inlining the call to <kbd class="calibre12">fopen</kbd> into the body of <kbd class="calibre12">test</kbd>.</p>
<p class="calibre2">The space for your custom deleter will be allocated in the body of the <kbd class="calibre12">std::unique_ptr&lt;T,D&gt;</kbd> object itself, which means <kbd class="calibre12">sizeof(unique_ptr&lt;T,D&gt;)</kbd> may be bigger than <kbd class="calibre12">sizeof(unique_ptr&lt;T&gt;)</kbd> if <kbd class="calibre12">D</kbd> has any member data:</p>
<div><img src="img/00018.jpeg" class="calibre42"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Managing arrays with std::unique_ptr&lt;T[]&gt;</h1>
                
            
            
                
<p class="calibre2">Another case where <kbd class="calibre12">delete p</kbd> is not the appropriate way to free a raw pointer is if <kbd class="calibre12">p</kbd> is a pointer to the first element of an array; in that case, <kbd class="calibre12">delete [] p</kbd> should be used instead. Fortunately, as of C++14, <kbd class="calibre12">std::unique_ptr&lt;T[]&gt;</kbd> exists and does the right thing in this case (by virtue of the fact that <kbd class="calibre12">std::default_delete&lt;T[]&gt;</kbd> also exists and does the right thing, which is to call <kbd class="calibre12">operator delete[]</kbd>).</p>
<p class="calibre2">An overload of <kbd class="calibre12">std::make_unique</kbd> for array types does exist, although be careful--it assigns a different meaning to its argument! <kbd class="calibre12">std::make_unique&lt;T[]&gt;(n)</kbd> essentially calls <kbd class="calibre12">new T[n]()</kbd>, where the parentheses on the end signify that it's going to value-initialize all the elements; that is, it will zero out primitive types. In the rare case that you don't want this behavior, you'll have to call <kbd class="calibre12">new</kbd> yourself and wrap the return value in a <kbd class="calibre12">std::unique_ptr&lt;T[]&gt;</kbd>, preferably using a helper function as we did in the example in the preceding section (where we used <kbd class="calibre12">fcloser::open</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reference counting with std::shared_ptr&lt;T&gt;</h1>
                
            
            
                
<p class="calibre2">Having completely solved the problem of memory leaks, we now tackle the problem of use-after-free bugs. The essential problem to be solved here is <em class="calibre22">unclear ownership</em>--or rather <kbd class="calibre12">shared ownership</kbd>--of a given resource or chunk of memory. This chunk of memory might have several people looking at it at different times, maybe from different data structures or from different threads, and we want to make sure that all these stakeholders are involved in the decision about when to free it. The ownership of the underlying chunk of memory should be <em class="calibre22">shared</em>.</p>
<p class="calibre2">For this, the standard has provided <kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd>. Its interface appears very similar to <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd>; all of the differences are hidden under the hood, in the implementations of the special member functions.</p>
<p class="calibre2"><kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd> provides an approach to memory management that is often known as <em class="calibre22">reference counting</em>. Each object managed by a <kbd class="calibre12">shared_ptr</kbd> keeps count of how many references to it are in the system--that is, how many stakeholders care about it right now--and as soon as that number drops to zero, the object knows it's time to clean itself up. Of course, it's not really "the object" that cleans itself up; the entity that knows how to count references and clean things up is a small wrapper, or "control block," which is created on the heap whenever you transfer ownership of an object to <kbd class="calibre12">shared_ptr</kbd>. The control block is handled invisibly by the library, but if we were to view its layout in memory, it might look something like this:</p>
<div><img src="img/00019.jpeg" class="calibre43"/></div>
<p class="calibre2">Just as <kbd class="calibre12">unique_ptr</kbd> has <kbd class="calibre12">make_unique</kbd>, the standard library provides <kbd class="calibre12">shared_ptr</kbd> with <kbd class="calibre12">make_shared</kbd> so that you never have to touch raw pointers with your hands. The other advantage of using <kbd class="calibre12">std::make_shared&lt;T&gt;(args)</kbd> to allocate shared objects is that transferring ownership into a <kbd class="calibre12">shared_ptr</kbd> requires allocating additional memory for the control block. When you call <kbd class="calibre12">make_shared</kbd>, the library is permitted to allocate a single chunk of memory that's big enough for both the control block <em class="calibre22">and</em> your <kbd class="calibre12">T</kbd> object, in one allocation. (This is illustrated by the physical placement of the rectangles for <kbd class="calibre12">control_block_impl</kbd> and <kbd class="calibre12">Super</kbd> in the preceding diagram.)</p>
<p class="calibre2">Copying a <kbd class="calibre12">shared_ptr</kbd> increments the "use-count" of its associated control block; destroying a <kbd class="calibre12">shared_ptr</kbd> decrements its use-count. Assigning over the value of a <kbd class="calibre12">shared_ptr</kbd> will decrement the use-count of its old value (if any), and increment the use-count of its new value. Here are some examples of playing with <kbd class="calibre12">shared_ptr</kbd>:</p>
<pre class="calibre23">    std::shared_ptr&lt;X&gt; pa, pb, pc;<br class="title-page-name"/><br class="title-page-name"/>    pa = std::make_shared&lt;X&gt;();<br class="title-page-name"/>    // use-count always starts at 1<br class="title-page-name"/><br class="title-page-name"/>    pb = pa;<br class="title-page-name"/>    // make a copy of the pointer; use-count is now 2<br class="title-page-name"/><br class="title-page-name"/>    pc = std::move(pa);<br class="title-page-name"/>    assert(pa == nullptr);<br class="title-page-name"/>    // moving the pointer keeps the use-count at 2<br class="title-page-name"/><br class="title-page-name"/>    pb = nullptr;<br class="title-page-name"/>    // decrement the use-count back to 1<br class="title-page-name"/>    assert(pc.use_count() == 1);</pre>
<p class="calibre2">The following diagram illustrates an interesting and occasionally useful aspect of <kbd class="calibre12">shared_ptr</kbd>: the ability for two instances of <kbd class="calibre12">shared_ptr</kbd> to refer to the same control block and yet point to different pieces of the memory being managed by that control block:</p>
<div><img src="img/00020.jpeg" class="calibre44"/></div>
<p class="calibre2">The constructor being used in the preceding diagram, which is also used in the <kbd class="calibre12">get_second()</kbd> function, is often called the "aliasing constructor" of <kbd class="calibre12">shared_ptr</kbd>. It takes an existing non-null <kbd class="calibre12">shared_ptr</kbd> object of any type, whose control block will be shared by the newly constructed object. In the following code sample, the message "destroying <kbd class="calibre12">Super</kbd>" will not be printed until <em class="calibre22">after</em> the message "accessing <kbd class="calibre12">Super::second</kbd>":</p>
<pre class="calibre23">    struct Super {<br class="title-page-name"/>      int first, second;<br class="title-page-name"/>      Super(int a, int b) : first(a), second(b) {}<br class="title-page-name"/>      ~Super() { puts("destroying Super"); }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    auto get_second() {<br class="title-page-name"/>      auto p = std::make_shared&lt;Super&gt;(4, 2);<br class="title-page-name"/>      return std::shared_ptr&lt;int&gt;(p, &amp;p-&gt;second);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      std::shared_ptr&lt;int&gt; q = get_second();<br class="title-page-name"/>      puts("accessing Super::second");<br class="title-page-name"/>      assert(*q == 2);<br class="title-page-name"/>    }</pre>
<p class="calibre2">As you can see, once ownership has been transferred into the <kbd class="calibre12">shared_ptr</kbd> system, the responsibility for remembering how to free a managed resource rests entirely on the shoulders of the control block. It isn't necessary for your code to deal in <kbd class="calibre12">shared_ptr&lt;T&gt;</kbd> just because the underlying managed object happens to be of type <kbd class="calibre12">T</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Don't double-manage!</h1>
                
            
            
                
<p class="calibre2">While <kbd class="calibre12">shared_ptr&lt;T&gt;</kbd> has the potential to eliminate nasty double-free bugs from your pointer code, it is sadly all too common for inexperienced programmers to write the same bugs using <kbd class="calibre12">shared_ptr</kbd> simply by over-using the constructors that take raw pointer arguments. Here's an example:</p>
<pre class="calibre23">    std::shared_ptr&lt;X&gt; pa, pb, pc;<br class="title-page-name"/><br class="title-page-name"/>    pa = std::make_shared&lt;X&gt;();<br class="title-page-name"/>      // use-count always starts at 1<br class="title-page-name"/><br class="title-page-name"/>    pb = pa;<br class="title-page-name"/>      // make a copy of the pointer; use-count is now 2<br class="title-page-name"/><br class="title-page-name"/>    pc = std::shared_ptr&lt;X&gt;(pb.get()); // WRONG!<br class="title-page-name"/>      // give the same pointer to shared_ptr again,<br class="title-page-name"/>      // which tells shared_ptr to manage it -- twice!<br class="title-page-name"/>    assert(pb.use_count() == 2);<br class="title-page-name"/>    assert(pc.use_count() == 1);<br class="title-page-name"/><br class="title-page-name"/>    pc = nullptr;<br class="title-page-name"/>      // pc's use-count drops to zero and shared_ptr<br class="title-page-name"/>      // calls "delete" on the X object<br class="title-page-name"/><br class="title-page-name"/>    *pb; // accessing the freed object yields undefined behavior</pre>
<p class="calibre2">Remember that your goal should be never to touch raw pointers with your hands! The place where this code goes wrong is the very first time it calls <kbd class="calibre12">pb.get()</kbd> to fetch the raw pointer out of <kbd class="calibre12">shared_ptr</kbd>.</p>
<p class="calibre2">It would have been correct to call the aliasing constructor here, <kbd class="calibre12">pc = std::shared_ptr&lt;X&gt;(pb, pb.get())</kbd>, but that would have had the same effect as a simple assignment <kbd class="calibre12">pc = pb</kbd>. So another general rule we can state is: if you have to use the word <kbd class="calibre12">shared_ptr</kbd> explicitly in your code, you're doing something out of the ordinary--and perhaps dangerous. <em class="calibre22">Without</em> naming <kbd class="calibre12">shared_ptr</kbd> in your code, you can already allocate and manage heap objects (using <kbd class="calibre12">std::make_shared</kbd>) and manipulate a managed object's use-count by creating and destroying copies of the pointer (using <kbd class="calibre12">auto</kbd> to declare variables as you need them). The one place this rule definitely breaks down is when you sometimes need to declare a class data member of type <kbd class="calibre12">shared_ptr&lt;T&gt;</kbd>; you generally can't do that without writing the name of the type!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Holding nullable handles with weak_ptr</h1>
                
            
            
                
<p class="calibre2">You may have noticed in the previous diagrams, an unexplained data member of the control block marked "weak count". It's time to explain what that is.</p>
<p class="calibre2">Sometimes--it's rare, but sometimes--we have a situation where we're using <kbd class="calibre12">shared_ptr</kbd> to manage the ownership of shared objects, and we'd like to keep a pointer to an object without actually expressing ownership of that object. Of course we could use a raw pointer, reference, or <kbd class="calibre12">observer_ptr&lt;T&gt;</kbd> to express the idea of "non-owning reference," but the danger then would be that the actual owners of the referenced object could decide to free it, and then when we went to dereference our non-owning pointer, we'd visit a freed object and get undefined behavior. <kbd class="calibre12">DangerousWatcher</kbd> in the following code sample illustrates this dangerous behavior:</p>
<pre class="calibre23">    struct DangerousWatcher {<br class="title-page-name"/>      int *m_ptr = nullptr;<br class="title-page-name"/><br class="title-page-name"/>      void watch(const std::shared_ptr&lt;int&gt;&amp; p) {<br class="title-page-name"/>        m_ptr = p.get();<br class="title-page-name"/>      }<br class="title-page-name"/>      int current_value() const {<br class="title-page-name"/>        // By now, *m_ptr might have been deallocated!<br class="title-page-name"/>        return *m_ptr;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">We could alternatively use a <kbd class="calibre12">shared_ptr</kbd> to express the idea of "reference," but of course that would give us an owning reference, making us less of a <kbd class="calibre12">Watcher</kbd> and more of a <kbd class="calibre12">Participant</kbd>:</p>
<pre class="calibre23">    struct NotReallyAWatcher {<br class="title-page-name"/>      std::shared_ptr&lt;int&gt; m_ptr;<br class="title-page-name"/><br class="title-page-name"/>      void watch(const std::shared_ptr&lt;int&gt;&amp; p) {<br class="title-page-name"/>        m_ptr = p;<br class="title-page-name"/>      }<br class="title-page-name"/>      int current_value() const {<br class="title-page-name"/>        // Now *m_ptr cannot ever be deallocated; our<br class="title-page-name"/>        // mere existence is keeping *m_ptr alive!<br class="title-page-name"/>        return *m_ptr;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">What we really want is a non-owning reference that is nevertheless aware of the <kbd class="calibre12">shared_ptr</kbd> system for managing memory, and is able to query the control block and find out whether the referenced object still exists. But by the time we found out that the object existed and went to access it, it might have been deallocated by some other thread! So the primitive operation we need is "atomically get an owning reference (a <kbd class="calibre12">shared_ptr</kbd>) to the referenced object if it exists, or otherwise indicate failure." That is, we don't want a <em class="calibre22">non-owning reference</em>; what we want is a <em class="calibre22">ticket that we can exchange at some future date for an owning reference</em>.</p>
<p class="calibre2">The standard library provides this "ticket for a <kbd class="calibre12">shared_ptr</kbd>" under the name <kbd class="calibre12">std::weak_ptr&lt;T&gt;</kbd>. (It's called "weak" in opposition to the "strong" owning references of <kbd class="calibre12">shared_ptr</kbd>.) Here's an example of how to use <kbd class="calibre12">weak_ptr</kbd> to solve our <kbd class="calibre12">Watcher</kbd> problem:</p>
<pre class="calibre23">    struct CorrectWatcher {<br class="title-page-name"/>      std::weak_ptr&lt;int&gt; m_ptr;<br class="title-page-name"/><br class="title-page-name"/>      void watch(const std::shared_ptr&lt;int&gt;&amp; p) {<br class="title-page-name"/>        m_ptr = std::weak_ptr&lt;int&gt;(p);<br class="title-page-name"/>      }<br class="title-page-name"/>      int current_value() const {<br class="title-page-name"/>        // Now we can safely ask whether *m_ptr has been<br class="title-page-name"/>        // deallocated or not.<br class="title-page-name"/>        if (auto p = m_ptr.lock()) {<br class="title-page-name"/>            return *p;<br class="title-page-name"/>        } else {<br class="title-page-name"/>          throw "It has no value; it's been deallocated!";<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The only two operations you need to know with <kbd class="calibre12">weak_ptr</kbd> are that you can construct a <kbd class="calibre12">weak_ptr&lt;T&gt;</kbd> from a <kbd class="calibre12">shared_ptr&lt;T&gt;</kbd> (by calling the constructor, as shown in the <kbd class="calibre12">watch()</kbd> function), and you can attempt to construct a <kbd class="calibre12">shared_ptr&lt;T&gt;</kbd> from a <kbd class="calibre12">weak_ptr&lt;T&gt;</kbd> by calling <kbd class="calibre12">wptr.lock()</kbd>. If the <kbd class="calibre12">weak_ptr</kbd> has expired, you'll get back a null <kbd class="calibre12">shared_ptr</kbd>.</p>
<p class="calibre2">There's also the member function <kbd class="calibre12">wptr.expired()</kbd>, which can tell you if the <kbd class="calibre12">weak_ptr</kbd> in question has already expired; but notice that it's essentially useless, since even if it returns <kbd class="calibre12">false</kbd> right now, it might return <kbd class="calibre12">true</kbd> a few microseconds later.</p>
<p class="calibre2">The following diagram continues the narrative started in the previous diagram by creating <kbd class="calibre12">weak_ptr</kbd> from <kbd class="calibre12">q</kbd> and then nulling out the <kbd class="calibre12">shared_ptr</kbd> it came from:</p>
<div><img src="img/00021.jpeg" class="calibre40"/></div>
<p class="calibre2">Copying a <kbd class="calibre12">weak_ptr</kbd> increments the weak-count associated with the referenced object's control block, and destroying a <kbd class="calibre12">weak_ptr</kbd> decrements the weak-count. When the use-count hits zero, the system knows it's safe to deallocate the controlled object; but the control block itself will not be deallocated until the weak-count hits zero, at which point we know that there are no more <kbd class="calibre12">weak_ptr</kbd> objects pointing at this control block:</p>
<div><img src="img/00022.jpeg" class="calibre40"/></div>
<p class="calibre2">You might have noticed that <kbd class="calibre12">shared_ptr</kbd> is using the same trick on its <kbd class="calibre12">Deleter</kbd> that we saw in the context of <kbd class="calibre12">std::any</kbd> and <kbd class="calibre12">std::function</kbd> in <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>--it is using <em class="calibre22">type erasure</em>. And, like <kbd class="calibre12">std::any</kbd> and <kbd class="calibre12">std::function</kbd>, <kbd class="calibre12">std::shared_ptr</kbd> provides a "go fish" function--<kbd class="calibre12">std::get_deleter&lt;Deleter&gt;(p)</kbd>--to retrieve the original deleter object. This tidbit will be entirely useless to you in your work; I mention it only to call attention to the importance of type erasure in modern C++. Even <kbd class="calibre12">shared_ptr</kbd>, whose ostensible purpose has nothing to do with erasing types, relies on type erasure in one little corner of its functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Talking about oneself with std::enable_shared_from_this</h1>
                
            
            
                
<p class="calibre2">There's just one more piece of the <kbd class="calibre12">shared_ptr</kbd> ecosystem that we should discuss. We've mentioned the danger of "double-managing" a pointer by creating multiple control blocks. So we might want a way to ask, given a pointer to a heap-allocated object, just who exactly is managing it right now.</p>
<p class="calibre2">The most common use-case for this feature is in object-oriented programming, where a method <kbd class="calibre12">A::foo()</kbd> wants to invoke some external function <kbd class="calibre12">bar()</kbd>, and <kbd class="calibre12">bar()</kbd> needs a pointer back to the <kbd class="calibre12">A</kbd> object. If we weren't worrying about lifetime management, this would be easy; <kbd class="calibre12">A::foo()</kbd> would simply invoke <kbd class="calibre12">bar(this)</kbd>. But let's say our <kbd class="calibre12">A</kbd> is being managed by <kbd class="calibre12">shared_ptr</kbd>, and let's say that <kbd class="calibre12">bar()</kbd> is likely to stash a copy of the <kbd class="calibre12">this</kbd> pointer somewhere internally--maybe we're registering a callback for later, or maybe we're spawning a new thread that will run concurrently while <kbd class="calibre12">A::foo()</kbd> finishes up and returns to its caller. So we need some way to keep <kbd class="calibre12">A</kbd> alive while <kbd class="calibre12">bar()</kbd> is still running.</p>
<p class="calibre2">Clearly <kbd class="calibre12">bar()</kbd> should take a parameter of type <kbd class="calibre12">std::shared_ptr&lt;A&gt;</kbd>; this will keep our <kbd class="calibre12">A</kbd> alive. But within <kbd class="calibre12">A::foo()</kbd>, where do we get that <kbd class="calibre12">shared_ptr</kbd> from? We could give <kbd class="calibre12">A</kbd> a member variable of type <kbd class="calibre12">std::shared_ptr&lt;A&gt;</kbd>, but then <kbd class="calibre12">A</kbd> would be keeping <em class="calibre22">itself</em> alive--it would never die! That's certainly not what we!</p>
<p class="calibre2">A preliminary solution is that <kbd class="calibre12">A</kbd> should keep a member variable of type <kbd class="calibre12">std::weak_ptr&lt;A&gt;</kbd> pointing to itself, and when it invokes <kbd class="calibre12">bar</kbd>, it should do so with <kbd class="calibre12">bar(this-&gt;m_wptr.lock())</kbd>. This has quite a bit of syntactic overhead, though, and besides it's unclear how the pointer <kbd class="calibre12">m_wptr</kbd> ought to get initialized. So, C++ took this idea and built it right into the standard library!</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    class enable_shared_from_this {<br class="title-page-name"/>      weak_ptr&lt;T&gt; m_weak;<br class="title-page-name"/>    public:<br class="title-page-name"/>      enable_shared_from_this(const enable_shared_from_this&amp;) {}<br class="title-page-name"/>      enable_shared_from_this&amp; operator=(const enable_shared_from_this&amp;) {}<br class="title-page-name"/>      shared_ptr&lt;T&gt; shared_from_this() const {<br class="title-page-name"/>        return shared_ptr&lt;T&gt;(m_weak);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The <kbd class="calibre12">std::enable_shared_from_this&lt;A&gt;</kbd> class holds our member variable of type <kbd class="calibre12">std::weak_ptr&lt;A&gt;</kbd>, and exposes the operation "get a <kbd class="calibre12">shared_ptr</kbd> to myself" under the name <kbd class="calibre12">x.shared_from_this()</kbd>. There are a couple of interesting details to notice in the preceding code: First, if you try to call <kbd class="calibre12">x.shared_from_this()</kbd> on an object that isn't currently being managed by the <kbd class="calibre12">shared_ptr</kbd> system, you'll get an exception of type <kbd class="calibre12">std::bad_weak_ptr</kbd>. Second, notice the empty copy constructor and copy assignment operator. Empty braces in this case is <em class="calibre22">not</em> the same thing as <kbd class="calibre12">=default</kbd>! If we had used <kbd class="calibre12">=default</kbd> to make the copy operations defaulted, they would have performed memberwise copying. Every time you made a copy of a managed object, the new object would receive a copy of the original's <kbd class="calibre12">m_weak</kbd>; which isn't what we want here at all. The "identity" of the <kbd class="calibre12">enable_shared_from_this</kbd> portion of a C++ object is tied to its <em class="calibre22">location in memory</em>, and therefore it does not (and should not) follow the rules of copying and value semantics for which we typically strive.</p>
<p class="calibre2">The last question to answer is: how does the member <kbd class="calibre12">m_weak</kbd> (which remember is a <em class="calibre22">private</em> member; we're using the name <kbd class="calibre12">m_weak</kbd> purely for exposition) get initialized in the first place? The answer is that the constructor of <kbd class="calibre12">shared_ptr</kbd> includes some lines of code to detect whether <kbd class="calibre12">T</kbd> publicly inherits from <kbd class="calibre12">enable_shared_from_this&lt;T&gt;</kbd>, and, if so, to set its <kbd class="calibre12">m_weak</kbd> member through some hidden back door. Notice that the inheritance must be <em class="calibre22">public</em> and <em class="calibre22">unambiguous</em>, since the constructor of <kbd class="calibre12">shared_ptr</kbd> is just another user-defined function as far as the rules of C++ are concerned; it can't crack open your class to find its private base classes, or to disambiguate between multiple copies of <kbd class="calibre12">enable_shared_from_this</kbd>.</p>
<p>These restrictions imply that you should only ever inherit from <kbd class="calibre25">enable_shared_from_this</kbd> publicly; that once a class derives from <kbd class="calibre25">enable_shared_from_this</kbd> you should only ever inherit from <em class="calibre29">it</em> publicly; and to keep things simple you probably ought to inherit from <kbd class="calibre25">enable_shared_from_this</kbd> only at the very leaves of your inheritance hierarchy. Of course, if you do not make deep inheritance hierarchies in the first place, following these rules will be fairly easy!</p>
<p class="calibre2">Let's put everything we know about <kbd class="calibre12">enable_shared_from_this</kbd> together into a single example:</p>
<pre class="calibre23">    struct Widget : std::enable_shared_from_this&lt;Widget&gt; {<br class="title-page-name"/>      template&lt;class F&gt;<br class="title-page-name"/>      void call_on_me(const F&amp; f) {<br class="title-page-name"/>        f(this-&gt;shared_from_this());<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      auto sa = std::make_shared&lt;Widget&gt;();<br class="title-page-name"/><br class="title-page-name"/>      assert(sa.use_count() == 1);<br class="title-page-name"/>      sa-&gt;call_on_me([](auto sb) {<br class="title-page-name"/>        assert(sb.use_count() == 2);<br class="title-page-name"/>      });<br class="title-page-name"/><br class="title-page-name"/>      Widget w;<br class="title-page-name"/>      try {<br class="title-page-name"/>        w.call_on_me([](auto) {});<br class="title-page-name"/>      } catch (const std::bad_weak_ptr&amp;) {<br class="title-page-name"/>        puts("Caught!");<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Curiously Recurring Template Pattern</h1>
                
            
            
                
<p class="calibre2">You may already have noticed, but especially after seeing the preceding code sample it should be apparent, that whenever you inherit from <kbd class="calibre12">enable_shared_from_this</kbd> the name of <em class="calibre22">your class</em> always appears in the template parameter list of its own base class! This pattern of "<kbd class="calibre12">X</kbd> inherits from <kbd class="calibre12">A&lt;X&gt;</kbd>" is known as the <strong class="calibre1">Curiously Recurring Template Pattern</strong>, or <strong class="calibre1">CRTP</strong> for short. It's common whenever some aspect of the base class depends on its derived class. For example, in our case the name of the derived class is incorporated into the return type of the <kbd class="calibre12">shared_from_this</kbd> method.</p>
<p class="calibre2">Another common case where the CRTP is warranted is when some <em class="calibre22">behavior</em> of the derived class is incorporated into the behavior provided by the base class. For example, using the CRTP we can write a base class template that provides a value-returning <kbd class="calibre12">operator+</kbd> for any derived class that implements <kbd class="calibre12">operator+=</kbd> and copy-construction. Notice the required <kbd class="calibre12">static_cast</kbd> from <kbd class="calibre12">addable&lt;Derived&gt;</kbd> to <kbd class="calibre12">Derived</kbd>, so that we call the copy constructor of <kbd class="calibre12">Derived</kbd> instead of the copy constructor of the base class <kbd class="calibre12">addable&lt;Derived&gt;</kbd>:</p>
<pre class="calibre23">    template&lt;class Derived&gt;<br class="title-page-name"/>    class addable {<br class="title-page-name"/>    public:<br class="title-page-name"/>      auto operator+(const Derived&amp; rhs) const {<br class="title-page-name"/>        Derived lhs = static_cast&lt;const Derived&amp;&gt;(*this);<br class="title-page-name"/>        lhs += rhs;<br class="title-page-name"/>        return lhs;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">In fact, this is almost exactly the service provided by <kbd class="calibre12">boost::addable</kbd> in the Boost Operators library; except that <kbd class="calibre12">boost::addable</kbd> uses the so-called "Barton-Nackman trick" to make its <kbd class="calibre12">operator+</kbd> a friend free function instead of a member function:</p>
<pre class="calibre23">    template&lt;class Derived&gt;<br class="title-page-name"/>    class addable {<br class="title-page-name"/>    public:<br class="title-page-name"/>      friend auto operator+(Derived lhs, const Derived&amp; rhs) {<br class="title-page-name"/>        lhs += rhs;<br class="title-page-name"/>        return lhs;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Even if you never use <kbd class="calibre12">enable_shared_from_this</kbd> in your codebase, you should be aware of the Curiously Recurring Template Pattern and be able to pull it out of your toolbox whenever you need to "inject" some derived-class behavior into a method of your base class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A final warning</h1>
                
            
            
                
<p class="calibre2">The mini-ecosystem of <kbd class="calibre12">shared_ptr</kbd>, <kbd class="calibre12">weak_ptr</kbd>, and <kbd class="calibre12">enable_shared_from_this</kbd> is one of the coolest parts of modern C++; it can give your code the safety of a garbage-collected language while preserving the speed and deterministic destruction that have always characterized C++. However, be careful not to abuse <kbd class="calibre12">shared_ptr</kbd>! Most of your C++ code shouldn't be using <kbd class="calibre12">shared_ptr</kbd> at all, because you shouldn't be <em class="calibre22">sharing</em> the ownership of heap-allocated objects. Your first preference should always be to avoid heap-allocation altogether (by using value semantics); your second preference should be to make sure each heap-allocated object has a unique owner (by using <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd>); and only if both of those are really impossible should you consider use of shared ownership and <kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Denoting un-special-ness with observer_ptr&lt;T&gt;</h1>
                
            
            
                
<p class="calibre2">We've now seen two or three different smart pointer types (depending on whether you count <kbd class="calibre12">weak_ptr</kbd> as a pointer type in its own right, or more like a ticket for a <kbd class="calibre12">shared_ptr</kbd>). Each of these types carries with it some useful source-level information about lifetime management. For example, just from the function signatures of these two C++ functions, what can we say about their semantics?</p>
<pre class="calibre23">    void remusnoc(std::unique_ptr&lt;Widget&gt; p);<br class="title-page-name"/><br class="title-page-name"/>    std::unique_ptr&lt;Widget&gt; recudorp();</pre>
<p class="calibre2">We see that <kbd class="calibre12">remusnoc</kbd> takes a <kbd class="calibre12">unique_ptr</kbd> by value, which means that ownership of the controlled object is transferred to <kbd class="calibre12">remusnoc</kbd>. When we call this function, we must have <em class="calibre22">unique ownership</em> of a <kbd class="calibre12">Widget</kbd>, and after we call this function, we will no longer be able to access that <kbd class="calibre12">Widget</kbd>. We don't know whether <kbd class="calibre12">remusnoc</kbd> is going to destroy the <kbd class="calibre12">Widget</kbd>, keep it around, or attach it to some other object or thread; but it's explicitly <em class="calibre22">no longer our concern</em>. The <kbd class="calibre12">remusnoc</kbd> function is a <em class="calibre22">consumer</em> of widgets.</p>
<p class="calibre2">More subtly, we can also say that when we call <kbd class="calibre12">remusnoc</kbd>, we must have unique ownership of a <kbd class="calibre12">Widget</kbd> that was allocated with <kbd class="calibre12">new</kbd>, and which it is safe to <kbd class="calibre12">delete</kbd>!</p>
<p class="calibre2">And vice versa: when I call <kbd class="calibre12">recudorp</kbd>, I know that whatever <kbd class="calibre12">Widget</kbd> we receive will be <em class="calibre22">uniquely owned</em> by me. It isn't a reference to someone else's <kbd class="calibre12">Widget</kbd>; it isn't a pointer to some static data. It's explicitly a heap-allocated <kbd class="calibre12">Widget</kbd> owned by me and me alone. Even if the first thing I do with the return value is to call <kbd class="calibre12">.release()</kbd> on it and stuff the raw pointer into some "pre-modern" struct, I can be sure that it is <em class="calibre22">safe</em> to do so, because I am definitely the <em class="calibre22">unique owner</em> of the return value.</p>
<p class="calibre2">What can we say about the semantics of this C++ function?</p>
<pre class="calibre23">    void suougibma(Widget *p);</pre>
<p class="calibre2">It's ambiguous. Maybe this function will take ownership of the passed pointer; maybe it won't. We can tell (we hope) from the documentation of <kbd class="calibre12">suougibma</kbd>, or from certain stylistic conventions in our codebase (such as "a raw pointer shall never denote ownership," which is a reasonable convention), but we can't tell from the signature alone. Another way to express this distinction is to say that <kbd class="calibre12">unique_ptr&lt;T&gt;</kbd> is a <em class="calibre22">vocabulary type</em> for expressing ownership transfer, whereas <kbd class="calibre12">T*</kbd> is not a vocabulary type for anything at all; it's the C++ equivalent of a nonsense word or a Rorschach blot, in that no two people will necessarily agree on what it means.</p>
<p class="calibre2">So, if you find yourself passing around a lot of non-owning pointers in your codebase, you might want a <em class="calibre22">vocabulary type</em> to represent the idea of a non-owning pointer. (Your first step should be to pass references instead of pointers whenever possible, but let's say that you've already exhausted that avenue.) Such a vocabulary type does exist, although it is not (yet) in the C++ standard library: due to Walter Brown, it's called "the world's dumbest smart pointer," and is merely a class-shaped wrapper around a raw non-owning pointer:</p>
<pre class="calibre23">    template&lt;typename T&gt;<br class="title-page-name"/>    class observer_ptr {<br class="title-page-name"/>      T *m_ptr = nullptr;<br class="title-page-name"/>      public:<br class="title-page-name"/>      constexpr observer_ptr() noexcept = default;<br class="title-page-name"/>      constexpr observer_ptr(T *p) noexcept : m_ptr(p) {}<br class="title-page-name"/>  <br class="title-page-name"/>      T *get() const noexcept { return m_ptr; }<br class="title-page-name"/>      operator bool() const noexcept { return bool(get()); }<br class="title-page-name"/>      T&amp; operator*() const noexcept { return *get(); }<br class="title-page-name"/>      T* operator-&gt;() const noexcept { return get(); }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void revresbo(observer_ptr&lt;Widget&gt; p);</pre>
<p class="calibre2">With <kbd class="calibre12">observer_ptr</kbd> in our toolbox, it becomes crystal clear that <kbd class="calibre12">revresbo</kbd> merely <em class="calibre22">observes</em> its argument; it definitely doesn't take ownership of it. In fact, we can assume that it doesn't even keep a copy of the passed-in pointer, because the validity of that pointer would depend on the lifetime of the controlled object, and <kbd class="calibre12">revresbo</kbd> is explicitly claiming not to have any stake in the lifetime of that object. If it wanted a stake in the lifetime of the controlled object, it would ask for that stake explicitly, by requesting <kbd class="calibre12">unique_ptr</kbd> or <kbd class="calibre12">shared_ptr</kbd> from its caller. By requesting <kbd class="calibre12">observer_ptr</kbd>, <kbd class="calibre12">revresbo</kbd> is "opting out" of the whole ownership debate.</p>
<p class="calibre2">As I said, <kbd class="calibre12">observer_ptr</kbd> is not part of the C++17 standard. One of the main objections keeping it out is its terrible name (being as it has nothing to do with the "observer pattern"). There are also many knowledgeable people who would say that <kbd class="calibre12">T*</kbd> <em class="calibre22">should</em> be the vocabulary type for "non-owning pointer," and that all old code using <kbd class="calibre12">T*</kbd> for ownership transfer should be rewritten or at least re-annotated with constructs such as <kbd class="calibre12">owner&lt;T*&gt;</kbd>. This is the approach currently recommended by the editors of the C++ Core Guidelines, including C++ inventor Bjarne Stroustrup. One thing is certain, though: <em class="calibre22">never use raw pointers for ownership transfer!</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we have learned a few things about smart pointers.</p>
<p class="calibre2"><kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> is a vocabulary type for ownership, and for ownership transfer; prefer it over raw <kbd class="calibre12">T*</kbd>. Consider the use of <kbd class="calibre12">observer_ptr</kbd> in situations where ownership is explicitly <em class="calibre22">not</em> being transferred, or where raw <kbd class="calibre12">T*</kbd> might be ambiguous to the reader.</p>
<p class="calibre2"><kbd class="calibre12">std::shared_ptr&lt;T&gt;</kbd> is a good (and standard) tool for dealing with shared ownership, where many different entities are all stakeholders in the lifetime of a single controlled object. <kbd class="calibre12">std::weak_ptr&lt;T&gt;</kbd> is a "ticket for <kbd class="calibre12">shared_ptr</kbd>"; it provides <kbd class="calibre12">.lock()</kbd> instead of <kbd class="calibre12">operator*</kbd>. If your class needs the ability to get <kbd class="calibre12">shared_ptr</kbd> to itself, inherit from <kbd class="calibre12">std::enable_shared_from_this&lt;T&gt;</kbd>. Remember to inherit publicly, and generally speaking, only at the leaves of your inheritance graph. And don't overuse these features in situations that do not absolutely require shared ownership!</p>
<p class="calibre2">Never touch raw pointers with your hands: use <kbd class="calibre12">make_unique</kbd> and <kbd class="calibre12">make_shared</kbd> to create heap-allocated objects and manage them in a single swoop. And remember the Curiously Recurring Template Pattern whenever you need to "inject" derived-class behaviors back into a function provided by your base class.</p>
<p class="calibre2">In the next chapter, we'll talk about a different kind of "sharing": the kind that arises in multi-threaded programming.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            

            
        
    </body></html>