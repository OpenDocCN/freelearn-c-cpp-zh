<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Instant MinGW Starter"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Instant MinGW Starter</h1></div></div></div><p>Welcome to <span class="emphasis"><em>Instant MinGW Starter</em></span>.</p><p>This book has been especially created to provide you with all the information that you need to start developing applications with MinGW software. You will get to know the basic skills to work with MinGW software and discover some tips and tricks for using it.</p><p>This book contains the following sections:</p><p>
<span class="emphasis"><em>So, what is MinGW?</em></span> – This section describes what MinGW actually is, its common components, and what you can do with it.</p><p>
<span class="emphasis"><em>Installation</em></span> – In this section you will learn how to download and install MinGW software with minimum fuss and then set it up so that you can use it as soon as possible.</p><p>
<span class="emphasis"><em>Quick start – Creating your first MinGW project</em></span> – This section will show you how to create a new application with MinGW software step by step. It will be the basis of most your work with MinGW.</p><p>
<span class="emphasis"><em>Top features you'll want to know about</em></span> – Here, you will learn how to perform some tasks with the most important features of MinGW. By the end of this section you will be able to use the GNU Make utility for effectively building your projects, importing existing Visual C++ projects to MinGW software, developing applications based on cross-platform GUI libraries, and configuring several Open Source IDEs with MinGW.</p><p>
<span class="emphasis"><em>People and places you should get to know</em></span> – Every Open Source project is centered around a community. This section provides you with many useful links to the project page and forums, as well as a number of helpful articles and tutorials on MinGW software.</p><div class="section" title="So, what is MinGW?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec03"/>So, what is MinGW?</h1></div></div></div><p>Minimalist GNU for Windows (MinGW) is a native software port of the GNU tool chain for the Microsoft Windows operating system. The base components of MinGW software are compiler, linker, and assembler. This minimal tool set is enough to start developing applications. But MinGW contains some service utilities to make the developing process more effective:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GNU Make</li><li class="listitem" style="list-style-type: disc">GNU Debugger (GDB)</li><li class="listitem" style="list-style-type: disc">GNU profiler</li><li class="listitem" style="list-style-type: disc">Compiler for Windows resource files</li><li class="listitem" style="list-style-type: disc">Header files and libraries for Windows API</li><li class="listitem" style="list-style-type: disc">Collection of archives and packers</li></ul></div><p>These components allow you to develop native 32-bit Windows applications without any proprietary third-party software. All components of MinGW software are produced under GNU General Public License and therefore this is a free software that you can download, use, and change as you want.</p><p>You can develop applications in C, C++, Java, Objective C, Fortran, and Ada programming languages with MinGW software. C++ application development will be described in this book, which is more typical for MinGW usage.</p><p>Besides developing new applications, you can import existing Visual C++ projects to MinGW software. It is easy to integrate MinGW with well-known third-party libraries such as DirectX, Boost, Qt, GTK, OpenGL, and SDL. If you are using any of these libraries, you can compile your application with MinGW.</p><p>MinGW software is very useful for importing Unix and Mac applications to Windows native code. It provides the same instruments that Unix and Mac developers have used in most cases. Also, you can import your MinGW-based applications to any computing platform supported by the GNU toolchain. Therefore, MinGW software is a great instruments' set for developing cross-platform applications.</p><p>Another benefit of MinGW software is modular organization. You can replace most components of the GNU toolchain with your favorite instruments (for example, debugger, profiler, or build automation system). These instruments will be integrated with existing components without any problems. Usage of the MinGW software is the first step to collecting your own developer's instruments' set for comfortable work.</p><p>The compiler efficiency is one of most important parameters for software developers. There are a lot of C++ compilers' benchmarks that are available on the Internet. Unfortunately for us, developers of proprietary compilers are not interested in objective researches of this kind. Fair comparison of available compilers is impossible because of this.</p><p>The MinGW compiler efficiency is abreast to proprietary compiler efficiency today according to benchmarks of independent software developers. You can find one of them at the following website:</p><p>
<a class="ulink" href="http://www.willus.com/ccomp_benchmark.shtml?p9+s6">http://www.willus.com/ccomp_benchmark.shtml?p9+s6</a>
</p><p>The MinGW software releases are more frequent than the proprietary compilers' releases. This means that MinGW is developed and improved more dynamically. For example, the standard features of C++11 have been supported by the GCC compiler earlier than the Visual Studio one. You can find these features at the following website:</p><p>
<a class="ulink" href="http://wiki.apache.org/stdcxx/C++0xCompilerSupport">http://wiki.apache.org/stdcxx/C++0xCompilerSupport</a>
</p><p>Notice that the GNU toolchain is a product of Unix culture. This culture is earlier than GUI applications with access to any function through menus, dialogs, and icons. Unix software has been developed as a suite of little stand alone utilities. Each of these performs only one task, but this execution is optimized very well. Therefore, all these utilities have a text-based interface. This provides the simplest intercommunication mechanism with a command line shell and saves the system resources.</p><p>If the idea of a text-based interface scares you, be relieved because there are a lot of <span class="strong"><strong>Integrated Development Environments</strong></span> (<span class="strong"><strong>IDE</strong></span>) that support MinGW.</p></div></div>
<div class="section" title="Installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec04"/>Installation</h1></div></div></div><p>There are several ways to install MinGW software on your computer. For example, you can compile whole MinGW software by yourself, or you can just install MinGW software distribution with a few clicks. The following steps are the simplest and quickest guide to install MinGW software.</p><div class="section" title="Step 1 – What do I need?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec02"/>Step 1 – What do I need?</h2></div></div></div><p>You need the following configurations on your computer to install MinGW software according to this guide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Disk space of 500 MB </li><li class="listitem" style="list-style-type: disc">An operating system of any version of Microsoft Windows since Windows XP or newer</li><li class="listitem" style="list-style-type: disc">Internet connection</li></ul></div></div><div class="section" title="Step 2 – Downloading MinGW"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec03"/>Step 2 – Downloading MinGW</h2></div></div></div><p>Download a self-extracting archive with the latest version of the MinGW software distribution from the following web page:</p><p>
<a class="ulink" href="http://nuwen.net/mingw.html">http://nuwen.net/mingw.html</a>
</p><p>You will find two types of distribution here: one with Git and one without Git. <span class="strong"><strong>Git</strong></span> is an open source distributed revision control system. I suggest you install the version with Git because it contains Bash command shell. This is a comfortable alternative for the standard Windows Command Prompt. For example, the Bash shell provides the autocomplete function that will complete the typed commands and pathnames by pressing the <span class="emphasis"><em>Tab</em></span> key. Also the command history is available by pressing up and down arrows.</p></div><div class="section" title="Step 3 – Extracting and configuring"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec04"/>Step 3 – Extracting and configuring</h2></div></div></div><p>Run the self-extracting archive. Specify the target directory and click on the <span class="strong"><strong>Extract</strong></span> button.</p><p>Suppose that you choose <code class="literal">C:\</code> as the target directory. The archive will be extracted to <code class="literal">C:\MinGW</code>. I strongly recommend you not to install MinGW software in <code class="literal">C:\Program Files</code>. There are problems with paths containing spaces.</p><p>Run the <code class="literal">set_distro_paths.bat</code> script in <code class="literal">C:\MinGW</code> after the archieve extraction. It will add the MinGW software directory to the <code class="literal">PATH</code> system variable for integration with the Windows Command Prompt and Bash shell. This script does not work properly on Windows Vista and Windows 7. Check the MinGW directory existence in the <code class="literal">PATH</code> variable after executing it.</p></div><div class="section" title="What do you have to get?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec05"/>What do you have to get?</h2></div></div></div><p>Congratulations! You have got the linker, C, and C++ compilers on your computer with header files and libraries for Windows API. Boost, GLEW, SDL, PCRE, Free Type, Vorbis, and many more libraries have been installed too. Moreover, there is profiler, Bash shell, Git, and other utilities.</p><p>There are several other ways to install MinGW software. One of them may be more suitable for your goals.</p></div><div class="section" title="Alternative ways to install MinGW"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Alternative ways to install MinGW</h2></div></div></div><p>The installation process described earlier refers to the unofficial distribution of the MinGW software with additional libraries and utilities. It may seem doubtful for users accustomed to proprietary software, but this is common practice for open source users. The third-party distributions are more usable and complete than official ones in some cases. This is achieved by integrating several relative open source products into one distribution. GNU Linux distribution is a typical sample of this practice.</p><p>You can download and install the official distribution of MinGW software from the following developers' website:</p><p>
<a class="ulink" href="http://www.mingw.org">http://www.mingw.org</a>
</p><p>I recommend you use the <code class="literal">mingw-get</code> installer application with a text-based interface. You can get a list of all the available packages by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mingw-get list</strong></span>
</pre></div><p>Execute the following command to install the necessary packages (for example, GCC, G++, GDB):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mingw-get install gcc g++ gdb</strong></span>
</pre></div><p>A more detailed instruction manual is available at the official MinGW website. You can simply install extensions for MinGW software using the <code class="literal">mingw-get</code> application.</p><p>The 64-bit MinGW software version is available from the <code class="literal">MinGW-w64</code> fork. Fork is an alternative branch of mainstream software development. The goal of any fork is to achieve specific software features. MinGW-w64 is a completely different software package than MinGW with its own staff of developers. However, the basic principles of MinGW and MinGW-w64 are the same. All knowledge gained in this book you can apply to  MinGW-w64 software. The following website is for the MinGW-w64 project:</p><p>
<a class="ulink" href="http://mingw-w64.sourceforge.net">http://mingw-w64.sourceforge.net</a>
</p><p>You can download the archive with MinGW software from here and unpack them. After unpacking you will get a ready-to-use MinGW software.</p><p>The following is the website of a MinGW-w64 software's unofficial distribution:</p><p>
<a class="ulink" href="http://tdm-gcc.tdragon.net">http://tdm-gcc.tdragon.net</a>
</p><p>This distribution provides a more flexible configuration of the installable components than the official one. The installation will be performed through the standard Windows Installation Wizard application.</p><p>MinGW software is supplied with some open source IDE. For example, such integrated product is available on Code::Blocks, official website <a class="ulink" href="http://www.codeblocks.org">http://www.codeblocks.org</a>.</p></div></div>
<div class="section" title="Quick start &#x2013; Creating your first MinGW project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Quick start – Creating your first MinGW project</h1></div></div></div><p>Let's create a simple typical C++ Windows application from scratch. Its interface will consist of a dialog window with two buttons. A click on the first button leads to a display of a message while a click on the second button leads to the application termination. The application contains a resource file with Windows Controls captions, sizes, styles, and fonts.</p><div class="section" title="Step 1 – Adding source files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Step 1 – Adding source files</h2></div></div></div><p>First of all, you must create a source C++ file and name it <code class="literal">main.cpp</code>. This file will contain the main function:</p><div class="informalexample"><pre class="programlisting">#define WIN32_LEAN_AND_MEAN
#include &lt;windows.h&gt;
#include "resource.h"


BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_BTN_QUIT:
                    EndDialog(hwndDlg, 0);
                    return TRUE;

                case IDC_BTN_TEST:
                    MessageBox(hwndDlg, "Message text", "Information", MB_ICONINFORMATION);
                    return TRUE;
            }
    }

    return FALSE;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    return DialogBox(hInstance, MAKEINTRESOURCE(DLG_MAIN), NULL, (DLGPROC)DialogProc);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip01"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The first line is the definition of the <code class="literal">WIN32_LEAN_AND_MEAN</code> macro, which disables the inclusion of rarely-used Windows header files. The next two lines include the header file with the Windows API functions' declaration and the header file with application resources identifiers.</p><p>The <code class="literal">DialogProc</code> function processes messages sent to our modal dialog. These messages contain information about events that occurred. The message identifier is passed to the function in the <code class="literal">uMsg</code> parameter. The <code class="literal">wParam</code> and <code class="literal">lParam</code> parameters are used for additional message-specific information. The <code class="literal">hwndDlg</code> parameter defines the dialog window that has received the message.</p><p>The <code class="literal">DialogProc</code> function processes the following messages:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">WM_CLOSE</code>: This message is caused by a click on the standard close window button.</li><li class="listitem"><code class="literal">WM_COMMAND</code> with the <code class="literal">IDC_BTN_QUIT</code> parameter: This message is caused by a click on the Quit button.</li><li class="listitem"><code class="literal">WM_COMMAND</code> with the <code class="literal">IDC_BTN_TEST</code> parameter: This message is caused by a click on the Test button.</li></ol></div><p>The <code class="literal">WM_CLOSE</code> and <code class="literal">WM_COMMAND</code> with <code class="literal">IDC_BTN_QUIT</code> parameter messages causes the application to terminate. The <code class="literal">WM_COMMAND</code> with the <code class="literal">IDC_BTN_TEST</code> parameter message causes the standard message box displaying.</p><p>The function which is defined next is <code class="literal">WinMain</code>. This function will be called when the application launches. The <code class="literal">DialogBox</code> Windows API function is called here to create a modal dialog window. We pass the <code class="literal">hInstance</code> variable to this function with a handle to the module whose executable file contains the resources of the created dialog. These resources are read-only embedded data in a binary file.</p><p>Next, the <code class="literal">DialogBox</code> function parameter is a pointer to the null-terminated string that specifies the dialog template in the resource data. The <code class="literal">MAKEINTRESOURCE</code> macro is used here to convert the <code class="literal">DLG_MAIN</code> identifier of the integer type to the null-terminated string. This identifier is defined in the <code class="literal">resource.h</code> header file.</p><p>The third parameter of the <code class="literal">DialogBox</code> function is the handle of the parent window that owns the dialog window. This is equal to the <code class="literal">NULL</code> value in our case that means the absence of a parent window.</p><p>The last parameter of the function is a pointer to the dialog window procedure to process messages. We pass the pointer to the <code class="literal">DialogProc</code> function for this parameter.</p><p>User interface elements and their parameters can be described in the resource file. All data from this file will be embedded into executable files and these will be available when the application runs.</p><p>Let's add this resource file to our project (<code class="literal">resource.rc</code>):</p><div class="informalexample"><pre class="programlisting">#include "resource.h"

DLG_MAIN DIALOGEX 6, 5, 138, 75

CAPTION "Typical Windows Application"

FONT 10, "Tahoma"

STYLE 0x10CE0804

BEGIN
  CONTROL "&amp;Message", IDC_BTN_TEST, "Button", 0x10010000, 46, 15, 46, 15
  CONTROL "&amp;Quit", IDC_BTN_QUIT, "Button", 0x10010000, 46, 45, 46, 15
END</pre></div><p>You can see the inclusion of the <code class="literal">resource.h</code> header in the first line of the resource file. The user interface element identifiers are defined in this header file. These identifiers are used to provide access from C++ code to resource data.</p><p>The <code class="literal">DLG_MAIN</code> element of the <code class="literal">DIALOGEX</code> type is defined in the next line. This element represents the dialog template with the position and size dialog window parameters. All statements in the next lines define the appearance of the dialog box and its elements.</p><p>The next line of the resource file contains the <code class="literal">CAPTION</code> statement. This statement defines the title of the dialog box. The <code class="literal">FONT</code> statement defines the font size and typeface for the dialog text font. The <code class="literal">STYLE</code> statement defines the window style of the dialog box.</p><p>The dialog box buttons are defined between the <code class="literal">BEGIN</code> and <code class="literal">END</code> statements. These parameters are defined for each button as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Type of the user interface element (this is equal to <code class="literal">CONTROL</code>)</li><li class="listitem" style="list-style-type: disc">Caption of the element</li><li class="listitem" style="list-style-type: disc">Element identifier</li><li class="listitem" style="list-style-type: disc">Class of the element (this is equal to <code class="literal">Button</code>)</li><li class="listitem" style="list-style-type: disc">Window style of the element</li><li class="listitem" style="list-style-type: disc">Position (x, y) and size (width, height)</li></ul></div><p>The third file is a header for the binding resource identifiers and C++ code (<code class="literal">resource.h</code>):</p><div class="informalexample"><pre class="programlisting">#include &lt;windows.h&gt;

#define DLG_MAIN 100
#define IDC_BTN_TEST 101
#define IDC_BTN_QUIT 102</pre></div><p>The dialog box and buttons' identifiers are specified here.</p></div><div class="section" title="Step 2 – Adding a Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Step 2 – Adding a Makefile</h2></div></div></div><p>The compilation rules are required to build our application. The rules describe algorithms to compile sources and link object files together to assembly executable files and libraries. This kind of algorithm is present in common IDEs, such as Visual Studio. However, it is often hidden inside the graphical user interface and is not available for change. You have the ability to control each step of the building application algorithm with the GNU Make utility.</p><p>You can perform each compilation step manually by calling the compiler and linker from the command line interface. However, the rules in the GNU Make utility file can automate these operations.</p><p>This is the simplest variant of the rules of the GNU Make utility file to build our application (<code class="literal">Makefile</code>):</p><div class="informalexample"><pre class="programlisting">win32-app.exe: main.cpp resource.rc.res.o
  g++ -o win32-app.exe main.cpp resource.rc.res.o

resource.rc.res.o: resource.rc
  windres -o resource.rc.res.o -i resource.rc

clean:
  rm -f *.o win32-app.exe</pre></div><p>Notice that there is a tabulation under each command. Tabulation and spaces are not the same for the GNU Make utility and this is often subjected to criticism.</p><p>The Makefile syntax will be described in detail in the later part of this book. It consists of targets (specified under the colon), and commands for producing these targets at the next line. The file list after the colon consists of files on which the target depends. These files are called prerequisites. The target will be rebuilt by the <code class="literal">make</code> command if one of its prerequisite files has been changed.</p><p>The following targets are specified in this <code class="literal">Makefile</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The final executable file, that is, <code class="literal">win32-app.exe</code></li><li class="listitem" style="list-style-type: disc">The object file with application resources, that is, <code class="literal">resource.rc.res.o</code></li><li class="listitem" style="list-style-type: disc">The utility target to remove temporary files, that is, <code class="literal">clean</code></li></ul></div><p>The MinGW C++ compiler application name is g++. The compiler for the Windows resource files is <code class="literal">windres</code>. Each GNU utility has detailed information about command line options and developers' feedback. Running the GNU utility from the Windows command prompt or Bash shell with the <code class="literal">--help</code> option will lead to displaying this information. This is the example of the same GNU utility run. </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ --help</strong></span>
</pre></div><p>The <code class="literal">clean</code> utility target is required to remove all files generated by the compiler and linker. The <code class="literal">rm</code> command is called to perform this task. You can use the <code class="literal">clean</code> target to rebuild the application after changing source files. Just perform this target and then build your application.</p></div><div class="section" title="Step 3 – Compiling and linking"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Step 3 – Compiling and linking</h2></div></div></div><p>Now we are ready to compile our first application with MinGW software. First of all, you must run the command shell. There are several ways to do this. The simplest one is by launching the command shell from the Windows <span class="strong"><strong>Start</strong></span> menu. Just type the <code class="literal">cmd</code> or <code class="literal">bash</code> command in the menu's <span class="strong"><strong>Search</strong></span> field. Furthermore, there are a lot of file managers with integrated command shells which you will be comfortable to work with. Far Manager is one of these.</p><p>You will see a window with the command line shell. Several useful commands for directory navigation have been installed with MinGW software:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cd &lt;dir&gt;</code>: This command changes the current directory to the specified one.<p>For example, to change the directory to <code class="literal">C:\Projects</code>, type the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /c/Projects</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pwd</code>: This command writes the absolute pathname of the current directory</li><li class="listitem" style="list-style-type: disc"><code class="literal">ls</code>: This command lists the current directory contents</li></ul></div><p>Change the current directory to the project one. The <code class="literal">C:/</code> path equals to the <code class="literal">/c</code> path in the Bash shell. This is due to the specific Unix environment's integration with Windows filesystems. Type the <code class="literal">make</code> command after changing the current directory. This is all that you need to do for compiling and linking applications. You get the executable binary after the GNU Make utility is executed successfully. Retype the <code class="literal">make</code> command to rebuild the application after changing any of the source files. It may be helpful to remove all the files, which were already generated by the compiler and linker, by using the <code class="literal">make</code> <code class="literal">clean</code> command before rebuilding the application.</p></div></div>
<div class="section" title="Top features you'll want to know about"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Top features you'll want to know about</h1></div></div></div><p>Several useful features of MinGW software will be described in detail in this section. You will get detailed knowledge about the most commonly used GNU toolchain utilities, such as C++ compiler, GNU Make, GNU Debugger, and the GNU <code class="literal">gprof</code> profiler. Also the integration of MinGW software with several well-known GUI libraries and IDE systems will be described.</p><div class="section" title="1 – Make utility usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>1 – Make utility usage</h2></div></div></div><p>We created a simple <code class="literal">Makefile</code> in the previous section. Let's explore the GNU Make utility's behavior and the syntax of Makefile in more detail.</p><p>You can run the GNU Make utility from the command shell with the <code class="literal">make</code> command. It will search one of the <code class="literal">Makefile</code>, <code class="literal">GNUmakefile</code>, or <code class="literal">makefile</code> named files and start to build the first line target. For changing this behavior, type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make -f OtherMakefile other_target</strong></span>
</pre></div><p>This leads to reading <code class="literal">OtherMakefile</code> as input file of rules and executing commands to build <code class="literal">other_target</code>.</p><p>In the previous section we created the following <code class="literal">Makefile</code>:</p><div class="informalexample"><pre class="programlisting">win32-app.exe: main.cpp resource.rc.res.o
  g++ -o win32-app.exe main.cpp resource.rc.res.o

resource.rc.res.o: resource.rc
  windres -o resource.rc.res.o -i resource.rc

clean:
  rm -f *.o win32-app.exe</pre></div><p>This works, but it has some problems. First of all the <code class="literal">main.cpp</code> and <code class="literal">resource.rc.res.o</code> files are specified several times. You must rename these in several places if one of these has been changed. This violates one of the most important principles of software development, <span class="strong"><strong>Don't repeat yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>). Variables can help you to avoid this problem. The GNU Make variables are often used to save constant values and change behavior during the build process. Our <code class="literal">Makefile</code> with variables will be as follows:</p><div class="informalexample"><pre class="programlisting">EXE=win32-app.exe
CPP=main.cpp
RES=resource.rc 

$(EXE): $(CPP) $(RES).res.o
  g++ -o $(EXE) $(CPP) $(RES).res.o

$(RES).res.o: $(RES)
  windres  -o $(RES).res.o -i $(RES)

clean:
  rm -f *.o *.exe</pre></div><p>The variable definition contains the name and variable value after the equals sign. You must use the dollar sign before the variable name within parentheses to access its value after the variable definition.</p><p>The source, resource, and executable files are defined as variables in our example. Now you should change the variable value in one place only to rename any of these files.</p><p>GNU Make allows the user to define variables, but there are several special automatic variables. These variables are computed for each rule that is executed. You can use the <code class="literal">$@</code> variable to specify the previously defined target and the <code class="literal">$^</code> variable to specify all the prerequisites of this target. After doing all this <code class="literal">Makefile</code> will look as follows:</p><div class="informalexample"><pre class="programlisting">CPP=main.cpp
RES=resource.rc

win32-app.exe: $(CPP) $(RES).res.o
  g++ -o $@ $^

$(RES).res.o: $(RES)
  windres -o $@ -i $^

clean:
  rm -f *.o *.exe</pre></div><p>The automatic variables can be used just like the user-defined ones. Now output files of g++ and the <code class="literal">windres</code> command are declared with the <code class="literal">$@</code> variable and source files with the <code class="literal">$^</code> one.</p><p>Suppose you want to link your application with a third-party library. The library is supplied with the header file and a dynamic-link or static-link library. You must inform the compiler about these files' paths and the library to link with. The simplest way to do it is using the GNU Make environment variables.</p><p>An environment variable is a variable that comes from the command shell in which GNU Make runs. There are several predefined environment variables with standard names. You can add custom environment variables from your command shell, but the most common practice is to operate with the standard one in <code class="literal">Makefile</code>. Environment variables affect target producing commands in <code class="literal">Makefile</code> (for example, additional compiler options are usually passed through environment variables).</p><p>The following Makefile is a linking example with the static-link boost program options library (the file path of the library is <code class="literal">C:\MinGW\lib\libboost_program_options.a</code>):</p><div class="informalexample"><pre class="programlisting">OBJ=main.o options.o
RES=resource.rc

CXXFLAGS+=-IC:\MinGW\include
LIBS+=-LC:\MinGW\lib -lboost_program_options

win32-app.exe: $(OBJ) $(RES).res.o
  g++ -o $@ $^ $(LIBS)

$(RES).res.o: $(RES)
  windres -o $@ -i $^

clean:
  rm -f *.o *.exe</pre></div><p>
<code class="literal">CXXFLAGS</code> is a predefined environment variable that contains command line options for the C++ compiler. This variable can be used to specify the paths of additional header files required for source compilation. Paths to headers are specified there with the <code class="literal">-I</code> prefix. You can specify several paths separated by a space as follows:</p><div class="informalexample"><pre class="programlisting">CXXFLAGS+=-IC:\first_include_path -IC:\second_include_path</pre></div><p>
<code class="literal">LIBS</code> is a simple variable with a list of static-link libraries to link with. This variable is passed to the C++ compiler explicitly in the <code class="literal">win32-app.exe</code> target producing rule. Libraries to link are specified with the <code class="literal">-l</code> prefix, and without the first three letters (<code class="literal">lib</code>), as well as the suffix (<code class="literal">.a</code>). The full path to linked libraries must be specified too with the <code class="literal">-L</code> prefix.</p><p>The following command is used to print all the predefined GNU Make environment variables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make -p</strong></span>
</pre></div><p>Notice that the additional <code class="literal">options.cpp</code> source file has been added to the project in this example. Also the <code class="literal">CPP</code> variable has been renamed to <code class="literal">OBJ</code> and contains object files list now. GNU Make will compile object files from source files automatically if they have same names (for example, <code class="literal">main.o</code> and <code class="literal">main.cpp</code>).</p><p>The following Makefile is a linking example with a dynamic-link <code class="literal">zlib</code> library (the file path of the library is <code class="literal">C:\MinGW\git\bin\libz.dll</code>):</p><div class="informalexample"><pre class="programlisting">OBJ=main.o
RES=resource.rc

CXXFLAGS+=-IC:\MinGW\include
LIBS+=-LC:\MinGW\git\bin –lz

win32-app.exe: $(OBJ) $(RES).res.o
  $(CXX) -o $@ $^ $(LIBS)

$(RES).res.o: $(RES)
  windres -o $@ -i $^

clean:
  rm -f *.o *.exe</pre></div><p>Dynamic-link libraries are described in the <code class="literal">LIBS</code> variable by the same rules as for static-link libraries.</p><p>
<code class="literal">CXX</code> is an environment variable with the C++ compiler's application name. This is equal to <code class="literal">g++</code> by default.</p><p>You can call the GNU Make utility for the <code class="literal">Makefile</code> subdirectory's processing. This is an example of the root project directory, <code class="literal">Makefile</code>, that performs the GNU Make utility for subdirectories (<code class="literal">foo</code> and <code class="literal">bar</code>):</p><div class="informalexample"><pre class="programlisting">SUBDIRS = foo bar

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

$(SUBDIRS):
  $(MAKE) -C $@</pre></div><p>The <code class="literal">.PHONY</code> rule is a special rule. It is used to specify the fact that the target is not a file. This is required in our case because subdirectories always exist and the GNU Make will not rebuild targets whose files already exist. <code class="literal">MAKE</code> is an environment variable with GNU Make application name. This is equal to <code class="literal">C:\MinGW\bin\make</code> by default if the installation path of MinGW software is equal to <code class="literal">C:\MinGW</code>.</p><p>Makefiles can include comments. All lines starting with the <code class="literal">#</code> symbol will be considered by GNU Make as comments.</p><p>Makefiles can be complex and consists of several separated files. To include external file content in <code class="literal">Makefile</code> use <code class="literal">include</code> directive, for example:</p><div class="informalexample"><pre class="programlisting">include Makefile.mingw</pre></div><p>GNU Make is a great instrument for compiling small projects with a couple of source files and headers. There are more powerful instruments for building complex applications that consist of several libraries and executables. Some of them are based on the GNU Make utility and produce Makefiles as the output (for example, GNU Autotools and CMake). I strongly recommend you to study and use one of these for your daily projects.</p></div><div class="section" title="2 – Compiler options"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>2 – Compiler options</h2></div></div></div><p>The MinGW compiler behavior is highly dependent on command line options. These options are usually set through GNU Make environment variables. The following is a list of commonly used predefined environment variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CC</code>: This variable sets the C compiler in use</li><li class="listitem" style="list-style-type: disc"><code class="literal">CFLAGS</code>: This variable sets the C compiler command line options</li><li class="listitem" style="list-style-type: disc"><code class="literal">CPPFLAGS</code>: This variable sets the C PreProcessor flags, which are used by C and C++ compilers</li><li class="listitem" style="list-style-type: disc"><code class="literal">CXX</code>: This variable sets the C++ compiler in use</li><li class="listitem" style="list-style-type: disc"><code class="literal">CXXFLAGS</code>: This variable sets the C++ compiler command line options</li><li class="listitem" style="list-style-type: disc"><code class="literal">LD</code>: This variable sets the linker in use</li><li class="listitem" style="list-style-type: disc"><code class="literal">LDFLAGS</code>: This variable sets the linker command line options</li><li class="listitem" style="list-style-type: disc"><code class="literal">LDLIBS</code>: This variable sets libraries to link</li></ul></div><p>The following is a list of commonly used MinGW C and C++ compilers' command line options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-o file-name</code>: This gives the name of the compiler output file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code>: This is used for compilation only. The object files will be created without further linking.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-Dname=value</code>: This defines the C preprocessor macro with a specified name and value. The <code class="literal">=value</code> part can be skipped. The default value (equal to 1) will be used instead. The result of this option will be the same as the following declaration in the source file:<div class="informalexample"><pre class="programlisting">#define name value</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">-llibrary-name</code>: This uses the specified dynamic-link or static-link library for linking.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-Idirectory</code>: This uses the directory to search headers by compiler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-Ldirectory</code>: This uses the directory to search dynamic-link libraries for linking.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-g</code>: This produces debugging information to be used by GDB debugger.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-pg</code>: This generates extra code to write profiling information for the <code class="literal">gprof</code> performance analyzer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-Wall</code>: This shows all the compiler's warning messages.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-On</code>: This sets the compiler's optimization level to an <code class="literal">n</code> value. The available levels are <code class="literal">-O0</code>, <code class="literal">-O1</code>, <code class="literal">-O2</code>, <code class="literal">-O3</code>, <code class="literal">-Os</code>, and <code class="literal">-Ofast</code>. The <code class="literal">-O0</code> option disables all optimizations. The <code class="literal">-O3</code> option provides the maximum optimization of code size and execution time. The <code class="literal">-Os</code> option optimizes for code size. The <code class="literal">-Ofast</code> option is the <code class="literal">-O3</code> option with non-accurate math calculation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-std=standard</code>: This uses the specified language standard (example for C++ standard: <code class="literal">-std=C++11</code>).</li></ul></div></div><div class="section" title="3 – Importing the existing Visual C++ project"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>3 – Importing the existing Visual C++ project</h2></div></div></div><p>You can use MinGW software even if you already have your project developed with Visual C++. The importing process from Visual C++ to MinGW is quite simple. All you need is to remove unusable headers and create Makefiles to compile and link existing C++ sources.</p><p>This process will be described in detail in this section by an example application. The application is a simple command-line archiving utility based on the zlib compression library. The boost library is also used for command-line option parsing. The application consists of the <code class="literal">core</code> static-link library and the <code class="literal">z_pack</code> executable. This separation by library and executable is required for complex project linking example with several modules.</p><p>You can see the Visual C++ project structure in the <span class="strong"><strong>Solution Explorer</strong></span> window in the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_01.jpg" alt="3 – Importing the existing Visual C++ project"/></div><p>First of all, let's look at the source code of the <code class="literal">core</code> library. This library contains the implementation of most of the application's functionality. The command-line parsing and compressing mechanisms are implemented here. Each of these mechanisms are encapsulated in a separate class. The <code class="literal">Options</code> class implements the command-line options' parsing. The <code class="literal">Packer</code> class implements the compressing and decompressing algorithms.</p><p>Let's look at the <code class="literal">Options</code> class. The following code shows the class declaration in the <code class="literal">options.h</code> file:</p><div class="informalexample"><pre class="programlisting">namespace po = boost::program_options;
class Options
{
public:
    Options(int argc, char* argv[]);

    std::string GetString(std::string option_name);
    po::options_description&amp; GetDescription();
    bool IsUnzip();
    bool IsComplete();

private:
    po::variables_map options_;
    po::options_description description_;
};</pre></div><p>The following code shows the constructor definition of the <code class="literal">Options</code> class in the <code class="literal">options.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">Options::Options(int argc, char* argv[])
{
    description_.add_options()
        (kHelp.c_str(), "produce help message")
        (kInFile.c_str(), po::value&lt;string&gt;(), "input file name")
        (kOutFile.c_str(), po::value&lt;string&gt;(), "output file name")
        (kUnzip.c_str(), "unzip the archive");

    try
    {
        po::store(po::parse_command_line(argc, argv, description_),
                       options_);
    }
    catch(...)
    {
        cout &lt;&lt; GetDescription() &lt;&lt; "\n";
        exit(1);
    }
}</pre></div><p>The constructor's input parameters are the count of command-line arguments and the vector with arguments' values. First of all the object from the boost library of the <code class="literal">options_description</code> class with the <code class="literal">description_</code> name is configured here with the available command-line arguments. This object is a field of the <code class="literal">Options</code> class.</p><p>All available command-line arguments are defined as global constants of the <code class="literal">string</code> type in the <code class="literal">options.h</code> file:</p><div class="informalexample"><pre class="programlisting">static const std::string kHelp = "help";
static const std::string kInFile = "in";
static const std::string kOutFile = "out";
static const std::string kUnzip = "unzip";</pre></div><p>These arguments with descriptions are passed to the <code class="literal">add_options</code> method of the <code class="literal">description_</code> object to configure it. Now this object stores information about available command-line arguments. After that, arguments passed to the constructor input parameters are parsed and saved to the variables map. This map is an object from the boost library of the <code class="literal">variables_map</code> class with the <code class="literal">options_</code> name. This object is a field of the <code class="literal">Options</code> class.</p><p>The available command-line arguments are printed if any exception occurs in the arguments' parsing operation. The application's termination will be caused with the <code class="literal">exit</code> function in this case.</p><p>The following code is the <code class="literal">GetString</code> method's definition of the <code class="literal">Options</code> class in the <code class="literal">options.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">string Options::GetString(string option_name)
{
    if ( options_.count(option_name) == 0 )
        return string();

    return options_[option_name].as&lt;string&gt;();
}</pre></div><p>The method returns the specified program option value of the <code class="literal">string</code> type or an empty string if the option has not been passed as a command-line argument. I suggest you name command-line arguments as program options after parsing them in the constructor of the <code class="literal">Options</code> class.</p><p>The following  three methods of the <code class="literal">Options</code> class are quite simple. These perform a check on the existence of specific program options or return them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">IsComplete</code> method checks if input and output filenames have been passed as command-line arguments to the application. This method returns the <code class="literal">true</code> value if the filenames exist.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">IsUnzip</code> method checks if the <code class="literal">--unzip</code> command-line argument exists.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GetDescription</code> method returns the reference to the <code class="literal">description_</code> field of the <code class="literal">Options</code> class. You can print available command-line arguments if this object is passed to the <code class="literal">cout</code> standard output stream.</li></ul></div><p>The second class of the core library is <code class="literal">Packer</code>. The compressing and decompressing algorithms are implemented here. This class contains the <code class="literal">Compress</code> and <code class="literal">Decompress</code> static methods. The static class methods may be very helpful to implement algorithms without state and mutable data. You don't need the object of the class to call static methods.</p><p>The following code shows the declaration of the class in the <code class="literal">packer.h</code> file:</p><div class="informalexample"><pre class="programlisting">class Packer
{
public:
  static void Compress(std::string in_file, std::string out_file);
  static void Decompress(std::string in_file, std::string out_file);
};</pre></div><p>The following code shows the <code class="literal">Compress</code> method's definition in the <code class="literal">packer.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void Packer::Compress(string in_file, string out_file)
{
  io::filtering_ostreambuf out;
  out.push(io::zlib_compressor());
  out.push(io::file_sink(out_file.c_str(), ios::binary));
  io::copy(io::file_source(in_file.c_str(), ios::binary), out);
}</pre></div><p>The input parameters of this method are strings with filenames of source and target files.</p><p>The compression is performed with the <code class="literal">copy</code> function from the boost library that copies one stream content to another. The stream of the <code class="literal">file_source</code> class from the boost library is used in this function as input parameter. The copy function produces the object of the <code class="literal">filtering_ostreambuf</code> class with the <code class="literal">out</code> name as the result. The stream of the <code class="literal">file_source</code> class is anonymous and is created from the source filename and stream type. This is the <code class="literal">binary</code> type in our case. The <code class="literal">out</code> object has been configured by the compression filter of the <code class="literal">zlib_compressor</code> type and anonymous stream of the <code class="literal">file_sink</code> boost library class. This anonymous stream represents the target file.</p><p>After performing the <code class="literal">Compress</code> method, the compressed file with the specified target filename will be created.</p><p>The following code shows the <code class="literal">Decompress</code> method's definition of the <code class="literal">Packer</code> class in the <code class="literal">packer.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void Packer::Decompress(std::string in_file, std::string out_file)
{
  io::filtering_istreambuf in;
  in.push(io::zlib_decompressor());
  in.push(io::file_source(in_file.c_str(), ios::binary));
  io::copy(in, io::file_sink(out_file.c_str(), ios::binary));
}</pre></div><p>This method is similar to the <code class="literal">Compress</code> method, but the filter of the <code class="literal">zlib_decompressor</code> type has been used here. The decompressed file with a specified target filename will be created after this method is performed.</p><p>The rest of the <code class="literal">core</code> library source files have been automatically generated by Visual C++.</p><p>Another solution's project is <code class="literal">z_pack</code>. This project binds the <code class="literal">core</code> library classes' functionality in to use them in the complete application. The <code class="literal">z_pack</code> project consist of one source file with the <code class="literal">main</code> function implementation and several autogenerated files by Visual C++.</p><p>The following code shows the <code class="literal">main</code> function's definition in the <code class="literal">z_pack.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
    Options options(argc, argv);

    If ( ! options.IsComplete() )
    {
        cout &lt;&lt; options.GetDescription() &lt;&lt; "\n";
        return 1;
    }

    if ( options.IsUnzip() )
        Packer::Decompress(options.GetString(kInFile), options.GetString(kOutFile));
    else
        Packer::Compress(options.GetString(kInFile), options.GetString(kOutFile));
    return 0;
}</pre></div><p>The input parameters of this function are the same as the <code class="literal">Options</code> class constructor. These are count of command-line arguments and vectors with argument values. First of all the object of the <code class="literal">Options</code> class with the <code class="literal">options</code> name is created here. The next operation is checking the source and target filenames for correctness using the <code class="literal">IsComplete</code> method of the <code class="literal">options</code> object. The available command-line arguments will be printed and the application will be terminated if this checking fails. The specified compression or decompression operation is performed if command-line arguments are correct. The <code class="literal">IsUnzip</code> method of the <code class="literal">options</code> object defines what kind of operation must be performed. The <code class="literal">Compression</code> and <code class="literal">Decompression</code> operations perform as per the <code class="literal">Packer</code> class static methods.</p><p>The input parameters for these methods are available from the <code class="literal">GetString</code> method of the <code class="literal">Options</code> class execution result.</p><p>Full Visual C++ project sources are available in the code bundle uploaded on the Packt website.</p><p>You can build this project and check its functionality. The Visual C++ versions of the boost and zlib libraries are required to compile the project. The comfortable distribution of both libraries is available at the following website:</p><p>
<a class="ulink" href="http://www.boostpro.com/download">http://www.boostpro.com/download</a>
</p><p>You can test the functionality of our example application after building one. Type the following command to compress the existing file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ z_pack.exe --in test.txt --out test.zip</strong></span>
</pre></div><p>The following command is used to decompress the existing archive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ z_pack.exe --unzip --in test.zip --out test.txt</strong></span>
</pre></div><p>Now you have the necessary information about our example Visual C++ project to import it to the MinGW software. The following are step-by-step instructions to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new directory for the MinGW project version with the <code class="literal">core</code> and <code class="literal">z_pack</code> subdirectories.</li><li class="listitem">Copy the <code class="literal">options.h</code>, <code class="literal">options.cpp</code>, <code class="literal">packer.h</code>, and <code class="literal">packer.cpp</code> files to the <code class="literal">core</code> subdirectory.</li><li class="listitem">Copy the <code class="literal">z_pack.cpp</code> file to the <code class="literal">z_pack</code> subdirectory.</li><li class="listitem">Remove the following line from all the files in the project that have the cpp extension:<div class="informalexample"><pre class="programlisting">#include "stdafx.h"</pre></div></li><li class="listitem">Add the following <code class="literal">Makefile</code> to the root project directory:<div class="informalexample"><pre class="programlisting">SUBDIRS = core z_pack

.PHONY: all $(SUBDIRS)

all: $(SUBDIRS)

$(SUBDIRS):
  $(MAKE) -C $@ clean
  $(MAKE) -C $@</pre></div><p>This <code class="literal">Makefile</code> allows you to perform the <code class="literal">make clean</code> and <code class="literal">make</code> commands for the <code class="literal">core</code> and <code class="literal">z_pack</code> subdirectories. The <code class="literal">make</code> command will build your application and the <code class="literal">make</code> <code class="literal">clean</code> command will remove output files generated by the compiler and linker.</p></li><li class="listitem">Add the following <code class="literal">Makefile</code> to the <code class="literal">core</code> subdirectory:<div class="informalexample"><pre class="programlisting">OBJ=options.o packer.o

CXXFLAGS+=-IC:\MinGW\include

libcore.a: $(OBJ)
  ar rcs $@ $^

clean:
  rm -f *.o *.a</pre></div><p>The <code class="literal">ar</code> archive utility is used to maintain the <code class="literal">options.o</code> and <code class="literal">packer.o</code> object files into the <code class="literal">libcore.a</code> archive here. This archive will be used for static linking with the <code class="literal">z_pack</code> executable. The <code class="literal">libcore.a</code> archive is conceptually the same as the Visual C++ static-link library. You can get additional information about the <code class="literal">ar</code> archive utility by the executing following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ar --help</strong></span>
</pre></div></li><li class="listitem">Add the following Makefile to the <code class="literal">z_pack</code> subdirectory:<div class="informalexample"><pre class="programlisting">OBJ=z_pack.o

MINGW_DIR=C:\MinGW
CXXFLAGS+=-I..\core
LIBS+=-L..\core -lcore -L$(MINGW_DIR)\lib -lboost_program_options -lboost_iostreams -L$(MINGW_DIR)\git\bin -lz

z_pack.exe: $(OBJ)
  $(CXX) -o $@ $^ $(LIBS)

clean:
  rm -f *.o *.exe</pre></div><p>Linking with all necessary external libraries (boost and zlib) occurs here because the <code class="literal">ar</code> archive utility does not perform any linking.</p></li><li class="listitem">Type the <code class="literal">make</code> command in the root project directory to build our application.</li></ol></div><p>This is all you need to import our example Visual C++ project to the MinGW software. You will get the <code class="literal">z_pack.exe</code> executable file after building it.</p><p>It is quite simple to change the <code class="literal">libcore.a</code> static-link library to the dynamic-link variant one. All you need is to change the <code class="literal">Makefile</code> files for the <code class="literal">z_pack</code> executable and the <code class="literal">core</code> library.</p><p>The following <code class="literal">Makefile</code> will create the dynamic-link <code class="literal">core</code> library variant:</p><div class="informalexample"><pre class="programlisting">OBJ=options.o packer.o

MINGW_DIR=C:\MinGW
CXXFLAGS+=-I$(MINGW_DIR)\include
LIBS+=-L$(MINGW_DIR)\lib -lboost_program_options -lboost_iostreams -L$(MINGW_DIR)\git\bin -lz

libcore.dll: $(OBJ)
  $(CXX) -shared -o $@ $^ $(LIBS)

clean:
  rm -f *.o *.dll</pre></div><p>The C++ compiler and linker will be called here unlike the static-link <code class="literal">core</code> library variant. Furthermore, the <code class="literal">-shared</code> compiler option must be specified to create the dynamic-link library.</p><p>The following <code class="literal">Makefile</code> is for the <code class="literal">z_pack</code> executable to link with the <code class="literal">core</code> library dynamically:</p><div class="informalexample"><pre class="programlisting">OBJ=z_pack.o

CXXFLAGS+=-I..\core
LIBS+=-L..\core -lcore

z_pack.exe: $(OBJ)
  $(CXX) -o $@ $^ $(LIBS)

clean:
  rm -f *.o *.exe *.dll</pre></div><p>Linking with external libraries (boost and zlib) is not required here because it has occurred in the <code class="literal">core</code> library building.</p><p>You must copy the <code class="literal">libcore.dll</code> library and the <code class="literal">z_pack.exe</code> executable files into one directory to run the application.</p><p>It is important to note that libraries, objects, and executable files compiled with Visual C++ and MinGW software are incompatible. This means that you need the MinGW version of all static-link and dynamic-link libraries that you want to link with your application compiled with MinGW software. You must check the existing MinGW version of all third-party libraries that have been used in your project before importing this to MinGW software.</p></div><div class="section" title="4 – Debugging application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>4 – Debugging application</h2></div></div></div><p>MinGW software contains <span class="strong"><strong>GNU Debugger</strong></span> (<span class="strong"><strong>GDB</strong></span>). This is a standard tool to debug applications developed with MinGW software. You can't use GDB to debug projects compiled with the Visual C++ compiler.</p><p>You can install GDB manually if it doesn't exist in your MinGW software distribution. Perform the following instructions to do the same:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the GDB application archive from the official download page:<p>
<a class="ulink" href="http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb">http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb</a>
</p><p>Some problems might occur with the latest GDB version's launching. Try to install the previous debugger version if you get errors.</p></li><li class="listitem">Extract the downloaded archive to the MinGW software installation directory. I recommend you to extract the archive to <code class="literal">C:\MinGW\git</code> if you have installed MinGW software with Git as described in this book.<p>After installing GDB you can test its functionality by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gdb --help</strong></span>
</pre></div></li></ol></div><p>GDB has been installed correctly if you see the application using information. Now you have the necessary debugger utility to start debugging your MinGW-based application.</p><p>Let's debug the example application with GDB. The application is a simple program with anull-pointer assignment.</p><p>The following code shows the content of the source file named <code class="literal">segfault.cpp</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;string.h&gt;

void bar()
{
  int* pointer = NULL;
  *pointer = 10;
}

void foo()
{
  bar();
}

int main()
{
  foo();

  return 0;
}</pre></div><p>The null-pointer assignment operation occurs in the <code class="literal">bar</code> function. The <code class="literal">bar</code> function is called from <code class="literal">foo</code> and the <code class="literal">foo</code> function is called from the <code class="literal">main</code> function.</p><p>The following <code class="literal">Makefile</code> is to compile the example:</p><div class="informalexample"><pre class="programlisting">OBJ=segfault.o

CXXFLAGS+=-g

segfault.exe: $(OBJ)
  $(CXX) -o $@ $^

clean:
  rm -f *.o *.exe</pre></div><p>The MinGW C++ compiler doesn't include debug information in output binary files by default. We need to add the <code class="literal">-g</code> compiler option to do it in this <code class="literal">Makefile</code>.</p><p>You will get the <code class="literal">segfault.exe</code> executable file with debugging symbols after compilation. It means that GDB can inform you not only about memory addresses but also the names of routines and variables.</p><p>Type the following command to start debugging our example application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gdb segfault.exe</strong></span>
</pre></div><p>To start the application with command-line arguments use the <code class="literal">--args</code> GDB option. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gdb --args z_pack.exe --in test.txt --out test.zip</strong></span>
</pre></div><p>The input and output filenames will be passed to the <code class="literal">z_pack.exe</code> application in this case.</p><p>You will see the GDB command prompt after launching the debugger. Type the <code class="literal">r</code> command to run the loaded application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) r</strong></span>
</pre></div><p>This is the short variant of the <code class="literal">run</code> command. Most of the GDB commands have common and short variants. All future commands will be described with short variants because they are easy to remember and type.</p><p>You will see this program crash message after the application starts running, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_02.jpg" alt="4 – Debugging application"/></div><p>You can see that the program abortion is receiving the <code class="literal">SIGSEGV</code> signal by application. The POSIX system sends this signal to process when it makes an invalid virtual memory reference or segmentation fault. Furthermore the source file's line, where the error has occurred, is displayed here. The following is the sixth line of the <code class="literal">segfault.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">*pointer = 10;</pre></div><p>Our example program execution has stopped after the crash. You can interact with the debugger through the command line when the program is stopped. For example, you can get the <span class="strong"><strong>stack backtrace</strong></span> to explore the nested functions' calls. Type the <code class="literal">bt</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) bt</strong></span>
</pre></div><p>You will see something like the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_03.jpg" alt="4 – Debugging application"/></div><p>You will see called functions' names and source file lines, where these have been called by the program just before it crashed.</p><p>Moreover, you can get a list of source file lines in the error place by the <code class="literal">l</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) l</strong></span>
</pre></div><p>You will see the <code class="literal">bar</code> function source code. Now you have enough information to fix the segmentation fault error.</p><p>To quit from GDB type the <code class="literal">q</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) q</strong></span>
</pre></div><p>And type <code class="literal">y</code> to confirm.</p><p>GDB allows you to set breakpoints to stop program execution in a predefined place. There are several breakpoint types. The simplest types are a breakpoint at entry to the function and a breakpoint at a line in a source file. You need to specify the application source files directory to provide access to these for GDB. The command to start the application debugging in this case will look like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gdb --directory=. segfault.exe</strong></span>
</pre></div><p>The <code class="literal">--directory</code> command-line option defines the source files directory. The current directory has been added in this example (the current directory equals to point symbol).</p><p>All the loaded directories are available by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) show directories</strong></span>
</pre></div><p>The following command is used to set a breakpoint at the <code class="literal">foo</code> function from the <code class="literal">segfault.cpp</code> source file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) b segfault.cpp:foo</strong></span>
</pre></div><p>To set a breakpoint at the fifth line of the <code class="literal">segfault.cpp</code> source file type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) b segfault.cpp:5</strong></span>
</pre></div><p>A list with information about all the current defined breakpoints is available by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) i b</strong></span>
</pre></div><p>You can run our example program after setting breakpoints:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) r</strong></span>
</pre></div><p>Program execution will be stopped at the first breakpoint in the <code class="literal">foo</code> function after that. You can continue execution by using the <code class="literal">c</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) c</strong></span>
</pre></div><p>Type this and the next breakpoint at the fifth line of the <code class="literal">segfault.cpp</code> source file will be achieved. The backtrace information and source file lines are available at each breakpoint.</p><p>Watchpoint is a special breakpoint type to detect read and write variable operations. This command is used to set a watchpoint for the <code class="literal">pointer</code> variable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) aw pointer</strong></span>
</pre></div><p>GDB can set such watchpoints if variables have been defined in the current context. This means that you must stop program execution at the <code class="literal">bar</code> function and then set a watchpoint for its local <code class="literal">pointer</code> variable. The program can be stopped in the <code class="literal">main</code> function to set a watchpoint for any global variable.</p><p>Moreover, you can configure GDB to display a list of variables with the current values at each breakpoint hit. To add the <code class="literal">pointer</code> variable in this list type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) display pointer</strong></span>
</pre></div><p>The value of the <code class="literal">pointer</code> variable will be displayed at the next breakpoint program stop.</p><p>You can disable a breakpoint of any type to prevent the program from stopping at it. The following is the command to do it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) disable 1</strong></span>
</pre></div><p>The specified number is a breakpoint identifier. This identifier is declared in the breakpoints information list.</p><p>To enable the breakpoint type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) enable 1</strong></span>
</pre></div><p>The breakpoint can be removed if it is no longer needed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) d 1</strong></span>
</pre></div><p>There are several useful commands for tracing a program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Continue to run a program until the control reaches a different source line (analogous of trace into):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) s</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Continue to the next source line in the current stack frame (analogous of step over):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) n</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Continue execution until the function in the selected stack frame returns:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(gdb) fin</strong></span>
</pre></div></li></ul></div><p>These commands can be used after the program has run and been stopped by breakpoint.</p><p>You can rebuild your application without debug information to produce release variants of executable files and libraries. But there is a possibility to remove debug information from existing binary files. Use the <code class="literal">strip</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strip segfault.exe</strong></span>
</pre></div><p>GDB is quite useful to debug abnormal program behavior (segmentation faults, for example). But using the same approaches as the test suite and event logging can complete the GDB capabilities for the algorithms' correctness checking.</p></div><div class="section" title="5 – Profiling application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>5 – Profiling application</h2></div></div></div><p>MinGW software contains the gprof performance analyzing tool. This instrument can be useful for tracking down an application's bottlenecks. The gprof tool is a part of the GNU Binutils collection and therefore it is present in all MinGW distributions. You can't use gprof to analyze the performance of applications compiled with Visual C++ compiler.</p><p>Let's profile an example application with gprof. This application reads bytes from a file to an STL <code class="literal">vector</code> type container, sorts them, and writes the result to an output file. The application source code is present in the file named <code class="literal">sorting.cpp</code>.</p><p>The following is the <code class="literal">main</code> function definition:</p><div class="informalexample"><pre class="programlisting">int main()
{
  ReadData();

  SortData();

  WriteResult();

  return 0;
}</pre></div><p>You can see the basic application algorithm in this function. First of all, the data is reading from the input text file. Then the data is sorted and written to the output file. Each of these steps are implemented in the separate function.</p><p>The following code shows the <code class="literal">ReadData</code> function's definition:</p><div class="informalexample"><pre class="programlisting">void ReadData()
{
  ifstream in_file("source.txt", ios::in | ios::binary);

  copy(istream_iterator&lt;char&gt;(in_file), istream_iterator&lt;char&gt;(), 
     back_inserter(gData));
}</pre></div><p>The stream of the <code class="literal">ifstream</code> class with the <code class="literal">in_file</code> name is used here to read the <code class="literal">source.txt</code> input file content. Then the STL <code class="literal">copy</code> algorithm is used to copy the <code class="literal">in_file</code> stream content to the global <code class="literal">gData</code> container of the <code class="literal">vector&lt;char&gt;</code> class. We use the iterator of the <code class="literal">istream_iterator</code> class to access elements of the <code class="literal">in_file</code> stream in the <code class="literal">copy</code> algorithm.</p><p>The <code class="literal">SortData</code> function implements the simplest bubble sort algorithm:</p><div class="informalexample"><pre class="programlisting">void SortData()
{
  char temp;
  size_t size = gData.size();
 
  for (int i = (size - 1); i &gt; 0; i--)
  {
    for (int j = 1; j &lt;= i; j++)
    {
    if (gData[j-1] &gt; gData[j])
    {
      temp = gData[j-1];
      gData[j-1] = gData[j];
      gData[j] = temp;
    }
    }
  }
}</pre></div><p>This sort algorithm processes the elements of the <code class="literal">gData</code> container.</p><p>The following is the <code class="literal">WriteResult</code> function definition:</p><div class="informalexample"><pre class="programlisting">void WriteResult()
{
  ofstream out_file("result.txt", ios::out | ios::binary);
  out_file.write(&amp;gData[0], gData.size());
}</pre></div><p>The stream of the <code class="literal">ofstream</code> class with the <code class="literal">out_file</code> name is used here to write the <code class="literal">gData</code> container content to the output <code class="literal">result.txt</code> file. The <code class="literal">write</code> method of the <code class="literal">out_file</code> stream is called here to perform the file writing operation. An empty file with the <code class="literal">result.txt</code> name will be created to write if this file already exists. The <code class="literal">sorting.cpp</code> file is available in the code bundle uploaded on the Packt website.</p><p>The following is <code class="literal">Makefile</code> for the example application:</p><div class="informalexample"><pre class="programlisting">OBJ=sorting.o

CXXFLAGS+=-pg

sorting.exe: $(OBJ)
  $(CXX) -o $@ $^ $(CXXFLAGS)

clean:
  rm -f *.o *.exe *.out *.dot</pre></div><p>Profiling information is needed for performance analyzing. This information can be generated by an executable file's extra code. The same kind of extra code creation is an optional feature of the compiler and this feature can be specified by the compiler <code class="literal">-pg</code> option. This option must be specified for each object file compilation and final linking. The <code class="literal">CXXFLAGS</code> environment variable is used to do this in our <code class="literal">Makefile</code>.</p><p>You can test our example application after compilation. Just copy any plain text file to project directory with, name it <code class="literal">source.txt</code>, and run the <code class="literal">sorting.exe</code> executable file. You will get the <code class="literal">result.txt</code> file with the sorted source file content after the application finishes its work. Perform the following steps to profile our example application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Launch the application's executable file. After that you will get the <code class="literal">gmon.out</code> file with the profiling data in the current working directory.</li><li class="listitem">Run the gprof utility to interpret the <code class="literal">gmon.out</code> file information and write the result to the <code class="literal">profile.txt</code> output file:<div class="informalexample"><pre class="programlisting">$ gprof -zq sorting.exe &gt; profile.txt</pre></div></li></ol></div><p>These gprof utility options have been used in the preceding:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-z</code> option is required to include all used functions in the output file</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-q</code> option causes a call-graph of the program for a more detailed report</li></ul></div><p>You have got a text report with the profiling data in the <code class="literal">profile.txt</code> file. It can be opened in any text editor. But this text representation of the profiling information is not comfortable to discovery. There are handy tools for visualizing a gprof report.</p><p>For visualization we need the following tools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python 2.7 interpreter</li><li class="listitem" style="list-style-type: disc">Python script to convert the gprof report to dot file format</li><li class="listitem" style="list-style-type: disc">Graphviz package with visualization utilities for dot format</li></ul></div><p>You can download Python version 2.7 from the following official website:</p><p>
<a class="ulink" href="http://python.org/download">http://python.org/download</a>
</p><p>Python can be installed with the standard Windows Installer. To do this just run the downloaded MSI file.</p><p>The script to convert a gprof report text file to dot format is available on the following developer page:</p><p>
<a class="ulink" href="http://code.google.com/p/jrfonseca/wiki/Gprof2Dot">http://code.google.com/p/jrfonseca/wiki/Gprof2Dot</a>
</p><p>This script is a free software and you can use, distribute, and modify it as you want. To install this script copy it to <code class="literal">C:\MinGW\bin</code> or <code class="literal">C:\MinGW\git\bin</code>.</p><p>The Graphviz package is available at the following official website:</p><p>
<a class="ulink" href="http://www.graphviz.org/Download_windows.php">http://www.graphviz.org/Download_windows.php</a>
</p><p>Graphviz can be installed with Windows Installer in the same way as Python interpreter.</p><p>Now you have the necessary scripts and the visualization utility to visualize our profiling results. Perform the following steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the <code class="literal">gprof2dot.py</code> script to get the dot file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gprof2dot.py -s profile.txt &gt; profile.dot</strong></span>
</pre></div><p>This <code class="literal">gprof2dot.py</code> utility option has been used here.</p><p>The <code class="literal">-s</code> option removes functions and templates argument information.</p><p>After that you will get the <code class="literal">profile.dot</code> file with call-graph of the program.</p></li><li class="listitem">Run the <code class="literal">gvedit.exe</code> application. It is available from the <span class="strong"><strong>Start</strong></span> menu of Windows. Go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open</strong></span> from the main menu. Specify the <code class="literal">profile.dot</code> file.</li></ol></div><p>You will see a call-graph of the program as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_04.jpg" alt="5 – Profiling application"/></div><p>You can see a call-graph in the preceding screenshot. Nodes of this graph are represented as colored edges. These nodes represent called functions of the analyzing program. Each edge contains the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Total time %</strong></span> is the percentage of the running time spent in this function and all its children</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Self time %</strong></span> (in brackets) is the percentage of the running time spent in this function alone</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Total calls</strong></span> is the total number of times this function was called (including recursive calls)</li></ul></div><p>Moreover, nodes have temperature-like colors according to the total time percent value. Most time expensive functions display as red (hot-spot) edges and the most cheap ones as dark blue.</p><p>The most execution time of our example application has been spent in the red colored <code class="literal">SortData</code> function. Statistic information about the <code class="literal">SortData</code> function at graph confirms it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Total time is equal to 99.35 percent</li><li class="listitem" style="list-style-type: disc">Self time is equal to 55.81 percent</li><li class="listitem" style="list-style-type: disc">Total calls is equal to 1</li></ul></div><p>We can use the STL <code class="literal">sort</code> algorithm instead of the bubble one to optimize our example application. Let's change the code of the <code class="literal">SortData</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void SortData()
{
  sort(gData.begin(), gData.end());
}</pre></div><p>Now you need to rebuild the application, run the application, and run gprof and the <code class="literal">gprof2dot.py</code> script. Open the resulting dot file in the Graphviz application. You will see the call-graph as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_05.jpg" alt="5 – Profiling application"/></div><p>The red edges disappear from the graph. This means that we don't have any explicit bottleneck. All program execution time has been evenly distributed between several functions.</p><p>You can remove the profiling extra code from executable files and libraries after profiling with the <code class="literal">strip</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strip sorting.exe</strong></span>
</pre></div><p>Profiling is a significant technique that allows you to find and remove bottlenecks in your applications. This may be very helpful for performance analyzing of the complex systems with many components and libraries. MinGW software allows you to include this technique in your software development process in a simple and fast manner.</p></div><div class="section" title="6 – Developing with cross-platform libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>6 – Developing with cross-platform libraries</h2></div></div></div><p>MinGW software allows you to develop applications based on any library compiled with the MinGW C++ compiler. Open source libraries are often supplied in Visual C++ and MinGW compilation variants. Moreover, you can always get the source code of these libraries and build them with your MinGW software. Several well-known open source cross-platform frameworks and toolkits are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Qt framework</li><li class="listitem" style="list-style-type: disc">Gtk+ widget toolkit</li><li class="listitem" style="list-style-type: disc">wxWidgets framework</li></ul></div><p>The same functionality example application will be developed with each of these libraries. The goal of these examples is to show the first steps to deploy and to start working with these libraries.</p><p>Our example application consists of a window with two buttons. A click on the first button leads to the display of a message and a click on the second button leads to the application termination. This functionality is the same as the one described in the <span class="emphasis"><em>Quick start</em></span> section.</p><div class="section" title="The Qt framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>The Qt framework</h3></div></div></div><p>The Qt framework provides not only a cross-platform widget toolkit for GUI development but also contains features for SQL database access, XML parsing, thread management, interaction over a network, and internalization support. The Qt framework has its own container classes such as <code class="literal">Qstring</code> or <code class="literal">QVector</code> and a set of well-known algorithms such as sorting, searching, and copying to process data in these containers that allow you to substitute the capabilities of STL and Boost libraries by the Qt ones. This kind of Qt framework self-sufficiency is of great advantage to develop cross-platform applications. All you need to do to import your Qt application to a new platform is building a Qt framework for this one. There are a lot of platforms that are supported by Qt framework developers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows</li><li class="listitem" style="list-style-type: disc">Mac OS X</li><li class="listitem" style="list-style-type: disc">Linux</li><li class="listitem" style="list-style-type: disc">Solaris</li><li class="listitem" style="list-style-type: disc">Symbian</li><li class="listitem" style="list-style-type: disc">Android (unofficial framework port with the name Ministro)</li></ul></div><p>Let's begin our work with the Qt framework. It is important to note that Qt libraries have been compiled with the specific MinGW software version. Your application must be compiled with the same MinGW version and therefore you must install it. The alternative way is the compilation of Qt libraries sources with your already installed MinGW software, but this variant will not be described in this book. You can find some helpful instructions to do this at the following website:</p><p>
<a class="ulink" href="http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler">http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler</a>
</p><p>All other toolkits described here don't need a specific MinGW software version. The following are instructions to install Qt libraries version 4.6.4 and some necessary software to start developing with it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the MinGW version of the Qt libraries for Windows from the following official website:<p>
<a class="ulink" href="http://qt-project.org/downloads">http://qt-project.org/downloads</a>
</p><p>Note that this library has been compiled with a specific (equal in our case to 4.4) MinGW software version.</p></li><li class="listitem">Install the downloaded Qt libraries with the setup wizard. Run the downloaded exe file to do it.</li><li class="listitem">Download the MinGW software of version 4.4 from the following official download page:<p>
<a class="ulink" href="http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/">http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/</a>
</p><p>You need the file to be named <code class="literal">gcc-full-4.4.0-mingw32-bin-2.tar.lzma</code>. This is an archive with the MinGW compilers' executable files and necessary core libraries.</p></li><li class="listitem">Extract the downloaded MinGW software archive to the directory without spaces in the path (for example, <code class="literal">C:\MinGW4.4</code>).<p>You can use the 7-Zip application to extract the LZMA archive type. This application is available at the following official website:</p><p>
<a class="ulink" href="http://www.7-zip.org/download.html">http://www.7-zip.org/download.html</a>
</p></li><li class="listitem">Download the GNU Binutils for MinGW software from the following official download page:<p>
<a class="ulink" href="http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19">http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19</a>
</p><p>You need the archive to be named <code class="literal">binutils-2.19-2-mingw32-bin.tar.gz</code>.</p></li><li class="listitem">Extract the downloaded GNU Binutils archive to the same directory as the MinGW software. This is <code class="literal">C:\MinGW4.4</code> in our case.</li><li class="listitem">Download the GNU Make utility from the following web page:<p>
<a class="ulink" href="http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3">http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3</a>
</p><p>You need to download the <code class="literal">mingw32-make-3.80.0-3.exe</code> file.</p></li><li class="listitem">Install GNU Make utility to the MinGW software directory (<code class="literal">C:\MinGW4.4</code>). Run the downloaded exe file and use the setup wizard to do it.</li><li class="listitem">Add the installation MinGW software path to the <code class="literal">PATH</code> Windows environment variable. Remove the existing paths of other MinGW software installations from there. The <code class="literal">C:\MinGW4.4\bin</code> path must be added in our example.</li></ol></div><p>Now you have the necessary libraries and specific MinGW software version to start developing an application based on the Qt framework.</p><p>Our example application is implemented in the <code class="literal">main.cpp</code> source file. The following is the <code class="literal">main</code> function definition:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  QApplication application(argc, argv);
  
  QMainWindow* window = CreateWindow();

  CreateMsgButton(window);

  CreateQuitButton(window, application);
  
  return application.exec();
}</pre></div><p>First of all, the object of the <code class="literal">QApplication</code> class named <code class="literal">application</code> is created here. This object is used to manage the application's control flow and main settings. After that, the window of the <code class="literal">QMainWindow</code> class named <code class="literal">window</code> is created by the <code class="literal">CreateWindow</code> function. Two window buttons are created by the <code class="literal">CreateMsgButton</code> and <code class="literal">CreateQuitButton</code> functions. The <code class="literal">exec</code> method of the <code class="literal">application</code> object is called to enter the main event loop when all user interface objects have been created. Now the application starts processing events such as button pressing.</p><p>The following is the <code class="literal">CreateWindow</code> function that encapsulate's the main application window creation:</p><div class="informalexample"><pre class="programlisting">QMainWindow* CreateWindow()
{
  QMainWindow* window = new QMainWindow(0, Qt::Window);
  
  window-&gt;resize(250, 150);
  window-&gt;setWindowTitle("Qt Application");
  window-&gt;show();

  return window;
}</pre></div><p>The main application window is an object of the <code class="literal">QMainWindow</code> class named <code class="literal">window</code> . It is created by a constructor that has two input parameters. The first parameter is of the <code class="literal">QWidget*</code> type. This is a pointer to the window's parent widget. It equals to zero in our case which means that there is no parent widget. The second parameter is of the <code class="literal">Qt::WindowFlags</code> type and defines the window style. It equals to <code class="literal">Qt::Window</code> that matches the standard window appearance with the system frame and title bar.</p><p>After the main window creation its size is set with the <code class="literal">resize</code> method of the <code class="literal">window</code> object. Then the window title is set with the <code class="literal">setWindowTitle</code> method of the <code class="literal">window</code> object. The next action is to make the main window visible by using the <code class="literal">show</code> method of the <code class="literal">window</code> object. The function returns the pointer to the created <code class="literal">window</code> object.</p><p>The following code shows the <code class="literal">CreateMsgButton</code> function that encapsulates the creation of button with message showing action:</p><div class="informalexample"><pre class="programlisting">void CreateMsgButton(QMainWindow* window)
{
  QMessageBox* message = new QMessageBox(window);
  message-&gt;setText("Message text");
  
  QPushButton* button = new QPushButton("Message", window);
  button-&gt;move(85, 40);
  button-&gt;resize(80, 25);
  button-&gt;show();
  QObject::connect(button, SIGNAL(released()), message, SLOT(exec()));
}</pre></div><p>At first, we need to create a message window to display it when we click on the button. This message window is an object of the <code class="literal">QMessageBox</code> class named <code class="literal">message</code>. It is created by a constructor with one input parameter of the <code class="literal">QWidget*</code> type. This is a pointer to the parent widget. The text displayed in the message window is set by the <code class="literal">setText</code> method of the <code class="literal">message</code> object.</p><p>Now we need a button that will be placed at the main window. This button is the object of the <code class="literal">QPushButton</code> class named <code class="literal">button</code>. The constructor with two input parameters is used here to create this object. The first parameter is a string with the button text of the <code class="literal">QString</code> class. The second parameter is the parent widget pointer. The position and size of the <code class="literal">button</code> object are set by the <code class="literal">move</code> and <code class="literal">resize</code> methods. After configuring the button we make it visible by using the <code class="literal">show</code> method.</p><p>Now we need to bind the button press event and message window displaying. The <code class="literal">connect</code> static method of the <code class="literal">QObject</code> class is used here for this goal. It allows to create a connection between the <code class="literal">button</code> object's release signal and the <code class="literal">exec</code> method of the <code class="literal">message</code> object. The <code class="literal">exec</code> method causes the displaying of window with message.</p><p>The following code shows the <code class="literal">CreateQuitButton</code> function that encapsulates the creation of the close application button:</p><div class="informalexample"><pre class="programlisting">void CreateQuitButton(QMainWindow* window, QApplication&amp; application)
{
  QPushButton* quit_button = new QPushButton("Quit", window);
  quit_button-&gt;move(85, 85);
  quit_button-&gt;resize(80, 25);
  quit_button-&gt;show();
  QObject::connect(quit_button, SIGNAL(released()), &amp;application, SLOT(quit()));
}</pre></div><p>This function is similar the <code class="literal">CreateMsgButton</code> function. But the message window isn't created here. The close application button is an object of the <code class="literal">QPushButton</code> class named <code class="literal">quit_button</code>. The <code class="literal">release</code> signal of the <code class="literal">quit_button</code> button is connected to the <code class="literal">quit</code> method of the <code class="literal">application</code> object. This method leads to the application closing with successful code.</p><p>The full <code class="literal">main.cpp</code> file is available in the code bundle uploaded on the Packt website.</p><p>Now you are ready to build an example application. You need to perform the following instructions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a Qt project file with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ qmake -project</strong></span>
</pre></div><p>You will get a file with the <code class="literal">pro</code> extension and name of the current directory.</p></li><li class="listitem">Create <code class="literal">Makefile</code>, service files, and subdirectories with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ qmake</strong></span>
</pre></div></li><li class="listitem">Compile the project with the GNU Make utility:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mingw32-make</strong></span>
</pre></div></li></ol></div><p>The GNU Make utility executable name is <code class="literal">mingw32-make</code> in the official distribution. This one has been installed with the MinGW software of version 4.4.</p><p>You will get the <code class="literal">qt.exe</code> executable file in the <code class="literal">debug</code> subdirectory after compilation.</p><p>This is the debugging version of our example application. Type the following command to build the <code class="literal">release</code> version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mingw32-make release</strong></span>
</pre></div><p>The <code class="literal">qt.exe</code> executable file will be created in the <code class="literal">release</code> subdirectory after this compilation.</p></div><div class="section" title="The Gtk+ widget toolkit"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The Gtk+ widget toolkit</h3></div></div></div><p>Gtk+ is a cross-platform toolkit with many widgets to construct user interfaces. It is important to note that Gtk+ has been written in C language. This toolkit has an object model, but there are no C++ classes and objects. You can use the toolkit in your C++ applications, but it may be helpful to use the gtkmm. The gtkmm is an official C++ interface for Gtk+. The gtkmm interface is not described in this book, but you can get more information about it at the following official website:</p><p>
<a class="ulink" href="http://www.gtkmm.org">http://www.gtkmm.org</a>
</p><p>Gtk+ is a good choice if you are looking for a widget toolkit for user interface creation and you don't need any additional features provided by the Qt framework.</p><p>The following are the instructions to install the Gtk+ widget toolkit:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the all-in-one bundle archive with the Gtk+ widget toolkit from the following official website:<p>
<a class="ulink" href="http://www.gtk.org/download/win32.php">http://www.gtk.org/download/win32.php</a>
</p></li><li class="listitem">Extract the archive to the directory without spaces in the path (for example, <code class="literal">C:\Gtk+</code>).</li><li class="listitem">Add the installation path of the Gtk+ toolkit to the <code class="literal">PATH</code> Windows environment variable. The path, <code class="literal">C:\Gtk+\bin</code>, must be added in our case.</li><li class="listitem">Create a new Windows environment variable named <code class="literal">PKG_CONFIG_PATH</code>. Specify the path to the <code class="literal">pkg-config</code> utility files as a value of this variable. This is <code class="literal">C:\Gtk+\lib\pkgconfig</code> in our case.</li></ol></div><p>Now you have the necessary libraries to start developing applications with the Gtk+ widget toolkit. Unlike the Qt framework you don't need the same MinGW software version as Gtk+ libraries have been compiled with. Any already installed MinGW software can be used to compile your applications.</p><p>Our example application is implemented in the <code class="literal">main.cpp</code> source file. The following is the <code class="literal">main</code> function definition:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  gtk_init(&amp;argc, &amp;argv);

  GtkWidget* window = CreateWindow();

  GtkWidget* box = gtk_vbox_new(FALSE, 0);
  gtk_widget_show(box);

  CreateMsgButton(box);

  CreateQuitButton(box);

  gtk_container_add(GTK_CONTAINER(window), box);
  gtk_widget_show(window);
  gtk_main();

  return 0;
}</pre></div><p>First of all the <code class="literal">gtk_init</code> function is called. It initializes everything that we need to operate with Gtk+ toolkit. Four widgets are created in the <code class="literal">main</code> function after that. There are the main window, vertical box container, and two buttons. The main window is a pointer to the <code class="literal">GtkWidget</code> Gtk+ structure that is created by the <code class="literal">CreateWindow</code> function.</p><p>The box container is needed to place several widgets in the main window (two buttons in our case). This box container is a pointer to the <code class="literal">GtkWidget</code> structure that is created by the <code class="literal">gtk_vbox_new</code> Gtk+ function. This function has two input parameters. The first parameter is of the <code class="literal">gboolean</code> type that defines whether all children widgets are to be given equal space allotments. The second parameter is of the <code class="literal">gint</code> type that defines the number of pixels to place between child widgets. The <code class="literal">gtk_widget_show</code> function is called to make the box container visible.</p><p>Buttons to show messages and close applications are created in the <code class="literal">CreateMsgButton</code> and <code class="literal">CreateQuitButton</code> functions.</p><p>The <code class="literal">gtk_container_add</code> function is used to put one widget into another. The box container has been put into the main window in our case. After that the <code class="literal">window</code> widget is made visible with the <code class="literal">gtk_widget_show</code> function.</p><p>The <code class="literal">gtk_main</code> function leads to run main application loop to process events.</p><p>The following is the <code class="literal">CreateWindow</code> function that creates the main window:</p><div class="informalexample"><pre class="programlisting">GtkWidget* CreateWindow()
{
  GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);

  gtk_window_set_title(GTK_WINDOW(window), "Gtk+ Application");
  g_signal_connect(window, "delete-event",                           G_CALLBACK(gtk_main_quit), NULL);
  g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit),               NULL);

  return window;
}</pre></div><p>The main window of the <code class="literal">GTK_WINDOW_TOPLEVEL</code> type is created here with the <code class="literal">gtk_window_new</code> function. This window type equals to a regular application window. Then the window title is set with the <code class="literal">gtk_window_set_title</code> function.</p><p>Now we must bind the application closing and main window destroy events. This is needed to close the application after the main window closes. The events are named signals in Gtk+ terminology.  The <code class="literal">g_signal_connect</code> macro is used here for signal binding. This macro has four arguments. The first argument is the pointer to the widget that you need to connect to. The second argument is a string with the signal name. The third argument is a callback function that will process this signal. The fourth argument is the pointer to additional signal data.</p><p>There are two signals named <code class="literal">delete-event</code> and <code class="literal">destroy</code> that match the window closing event. The <code class="literal">gtk_main_quit</code> function will be called when these signals occur in our case. This function will stop the application event loop and will lead to the application termination.</p><p>The following is the <code class="literal">CreateMsgButton</code> function that creates the message showing button:</p><div class="informalexample"><pre class="programlisting">void CreateMsgButton(GtkWidget* box)
{
  GtkWidget* button = gtk_button_new_with_label("Message"); 
  gtk_widget_show(button);	
  g_signal_connect(G_OBJECT(button), "clicked",
                     G_CALLBACK(ShowMessage), NULL);
  gtk_container_add(GTK_CONTAINER(box), button);
}</pre></div><p>This function has one input parameter of the pointer to the <code class="literal">GtkWidget</code> structure type. This is used to pass the pointer of the button container widget.</p><p>The button widget is a pointer to the <code class="literal">GtkWidget</code> structure named <code class="literal">button</code>. It is created by the <code class="literal">gtk_button_new_with_label</code> function. This function has only one input parameter with the button label string. After that the button widget is made visible with the <code class="literal">gtk_window_show</code> function. The <code class="literal">clicked</code> signal of the button widget is connected to the <code class="literal">ShowMessage</code> function. The button widget is added to the box container when it has been configured.</p><p>The following is the <code class="literal">ShowMessage</code> function to create and display the message window:</p><div class="informalexample"><pre class="programlisting">void ShowMessage(GtkWidget* widget, gpointer data)
{
  GtkWidget* message = gtk_message_dialog_new((GtkWindow*)data, GTK_DIALOG_MODAL, GTK_MESSAGE_INFO, GTK_BUTTONS_OK, "Message text");
  gtk_dialog_run(GTK_DIALOG(message));
  gtk_widget_destroy(message);
}</pre></div><p>The message window is the Gtk+ dialog widget that has been created with the <code class="literal">gtk_message_dialog_new</code> function. Parent window pointers, dialog flags, message types, dialog buttons, and message text are passed to this function. The <code class="literal">gtk_dialog_run</code> function is called to display the created dialog. This function will return control when the dialog button has been clicked. The <code class="literal">gtk_widget_destroy</code> function at the next line will destroy our message window.</p><p>The following is the <code class="literal">CreateQuitButton</code> function that creates the quit button:</p><div class="informalexample"><pre class="programlisting">void CreateQuitButton(GtkWidget* box)
{
  GtkWidget* button = gtk_button_new_with_label("Quit"); 
  gtk_widget_show(button);	
  g_signal_connect(G_OBJECT(button), "clicked",
                     G_CALLBACK(gtk_main_quit), NULL);
  gtk_container_add(GTK_CONTAINER(box), button);
}</pre></div><p>This is the same as the <code class="literal">CreateMsgButton</code> function, but the button labels differ. Moreover, the <code class="literal">clicked</code> signal of this button is bound with the <code class="literal">gtk_main_quit</code> function. This function will lead to the application termination.</p><p>The full <code class="literal">main.cpp</code> file is available in the code bundle uploaded on the Packt website.</p><p>The following is <code class="literal">Makefile</code> to compile our example application:</p><div class="informalexample"><pre class="programlisting">OBJ=main.o

CXXFLAGS+='pkg-config --cflags gtk+-win32-2.0'
LIBS+='pkg-config --libs gtk+-win32-2.0'

gtk.exe: $(OBJ)
  $(CXX) -o $@ $^ $(LIBS)

clean:
  rm -f *.o *.exe</pre></div><p>The <code class="literal">pkg-config</code> utility from the Gtk+ toolkit is used here to get the compiler and linker Gtk+ specific flags. The grave accent mark means that the wrapped string will be performed as a command and the result of the execution will be returned as a string value.</p><p>The following <code class="literal">pkg-config</code> options have been used here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">--cflags</code>: This prints the preprocessor and compiler flags to compile the application with a specified library</li><li class="listitem" style="list-style-type: disc"><code class="literal">--libs</code>: This prints the linker flags to link the application with a specified library</li></ul></div><p>
<code class="literal">gtk+-win32-2.0</code> is the name of the package with the Gtk+ libraries that we want to link with.</p><p>The results of the <code class="literal">pkg-config</code> utility execution are assigned to the <code class="literal">CXXFLAGS</code> and <code class="literal">LIBS</code> variables.</p><p>Now you have all the source files that are needed to compile our example application. Type the <code class="literal">make</code> command to do this. You will get the <code class="literal">gtk.exe</code> executable file in the current directory.</p></div><div class="section" title="wxWidgets framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>wxWidgets framework</h3></div></div></div><p>The wxWidgets framework contains the widget toolkit for user interface development and features for network programming, threading support, image processing, database support, and HTML and XML processing. The wxWidgets have a set of their own containers and algorithms that can be enough to develop applications with this framework resources only.</p><p>Implementing own user interface elements is common practice for many widget toolkits and frameworks. This is what makes the Qt framework and Gtk+ widget toolkit. wxWidgets unlike these, uses the native platform's user interface elements through the platform's API. Thanks to this, wxWidgets-based applications look and feel like a native one.</p><p>wxWidgets is a good base to develop cross-platform high-quality, native-looking applications for Mac OS X, Windows, Linux, and other Unix family operating systems.</p><p>Several wxWidgets framework versions are available from the official website as source code archives. You can download one of these and build it with your currently installed MinGW software.</p><p>The following are the instructions to install the wxWidgets widget toolkit:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the wxMSV version of wxWidgets from the following official website:<p>
<a class="ulink" href="http://www.wxwidgets.org/downloads">http://www.wxwidgets.org/downloads</a>
</p></li><li class="listitem">Install the downloaded wxWidgets toolkit with the setup wizard. Run the downloaded exe file to do it. We will assume that the <code class="literal">C:\wxWidgets</code> target directory has been specified for example.</li><li class="listitem">Build the wxWidgets toolkit with your already installed MinGW software. Type the following commands to do it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd C:\wxWidgets\build\msw</strong></span>
<span class="strong"><strong>make -f makefile.gcc SHARED=1 UNICODE=1 BUILD=release clean</strong></span>
<span class="strong"><strong>make -f makefile.gcc SHARED=1 UNICODE=1 BUILD=release</strong></span>
</pre></div></li><li class="listitem">Download the <code class="literal">wx-config</code> utility from the developer's page:<p>
<a class="ulink" href="http://code.google.com/p/wx-config-win">http://code.google.com/p/wx-config-win</a>
</p><p>This utility is used to search the wxWidgets toolkit libraries and header files by GNU Make.</p></li><li class="listitem">Copy the <code class="literal">wx-config</code> utility to the wxWidgets installation directory (in our case <code class="literal">C:\wxWidgets</code>).</li><li class="listitem">Add the path to the wxWidgets installation directory and the path to the dynamic-linked libraries in the <code class="literal">PATH</code> Windows environment variable. The <code class="literal">C:\wxWidgets</code> and <code class="literal">C:\wxWidgets\lib\gcc_dll</code> values must be added in our example.</li></ol></div><p>Now you have the necessary libraries to start developing applications with the wxWidgets widget toolkit.</p><p>The example wxWidgets application is implemented in the <code class="literal">main.cpp</code> source file. User classes must be created here unlike the Gtk+ and Qt example application variants. The <code class="literal">MyApp</code> class is the base application class that is derived from the <code class="literal">wxApp</code> wxWidgets library standard class.</p><p>The following is the <code class="literal">MyApp</code> class definition:</p><div class="informalexample"><pre class="programlisting">class MyApp : public wxApp
{
public:
  virtual ~MyApp() {}

private:
  virtual bool OnInit();
};</pre></div><p>The virtual destructor and the <code class="literal">OnInit</code> virtual method are defined here. The virtual destructor is needed here for correct parent class data deleting. All application functionality is implemented in the <code class="literal">OnInit</code> method of the <code class="literal">MyApp</code> class.</p><p>The following is the <code class="literal">OnInit</code> method of the <code class="literal">MyApp</code> class:</p><div class="informalexample"><pre class="programlisting">bool MyApp::OnInit()
{
  MyDialog* dialog = new MyDialog(NULL, 0, _("wxWidgets application"));

  wxSizer* sizer = dialog-&gt;CreateButtonSizer(wxOK | wxCANCEL);
  sizer-&gt;SetDimension(175, 50, 100, 100);

    while ( dialog-&gt;ShowModal() == wxID_OK )
    {
      wxMessageBox(_("Message text"), 
                    _("Information"),
                    wxOK | wxICON_INFORMATION, dialog);
  }

  dialog-&gt;Destroy();
  return true;
}</pre></div><p>The main application window is created here. This window is the object of the <code class="literal">MyDialog</code> class with the <code class="literal">dialog</code> name. The <code class="literal">MyDialog</code> class is a user defined class derived from the <code class="literal">wxDialog</code> widget class. The constructor of the <code class="literal">MyDialog</code> class has three input parameters. These are parent widget pointer, widget identifier, and title bar caption string.</p><p>Then two buttons with <code class="literal">OK</code> and <code class="literal">Cancel</code> captions are created for the <code class="literal">dialog</code> object by the <code class="literal">CreateButtonSizer</code> method. This method has one parameter that defines the standard buttons list to creation. Each of these buttons is represented by the bit flag. The <code class="literal">CreateButtonSizer</code> method returns the pointer to the object of the <code class="literal">wxSizer</code> class with the <code class="literal">sizer</code> name. This object represents the sub-window that contains the buttons. Thanks to the <code class="literal">sizer</code> object the button's position can be changed with the <code class="literal">SetDimensions</code> method. This method has four input parameters. The first two parameters are x and y coordinates and the second two parameters are the width and height of the <code class="literal">sizer</code> subwindow.</p><p>The <code class="literal">ShowModal</code> method of the <code class="literal">dialog</code> object method will be called in a loop after the widget's initialization. This is the main application loop. It will be interrupted when the main application window has been destroyed.</p><p>The information message will be displayed when the button with the <code class="literal">wxID_OK</code> identifier is clicked on. The <code class="literal">wxMessageBox</code> function is used to show an informational message. This function has six input parameters. The four of these are used here and the other two have values by default. The first parameter is a string with the message text. The second parameter is a string with message window caption bar text. The third parameter defines the message window style by bit flags. The fourth parameter is a pointer to the parent widget. The last two parameters are the coordinates of the message window.</p><p>The main application window will be hidden when the button with the <code class="literal">Cancel</code> caption will be clicked. The <code class="literal">Destroy</code> method of the <code class="literal">dialog</code> object is called here to destroy the main application window.</p><p>The following is the <code class="literal">MyDialog</code> class definition:</p><div class="informalexample"><pre class="programlisting">class MyDialog : public wxDialog
{
public:
  MyDialog(wxWindow* parent, wxWindowID id,
              const wxString&amp; title) : wxDialog(parent, id, title) {}
  virtual ~MyDialog() {}
};</pre></div><p>The <code class="literal">MyDialog</code> class is derived from the <code class="literal">wxDialog</code> widget. The class constructor and destructor are defined here. The <code class="literal">MyDialog</code> class constructor just passes input parameters to the parent class constructor.</p><p>You must specify this macro in the <code class="literal">main.cpp</code> source file to create the application instance and start the program:</p><div class="informalexample"><pre class="programlisting">IMPLEMENT_APP(MyApp)</pre></div><p>The full <code class="literal">main.cpp</code> file is available in the code bundle uploaded on the Packt site.</p><p>The following is <code class="literal">Makefile</code> to compile our example application:</p><div class="informalexample"><pre class="programlisting">OBJ=main.o

CXXFLAGS+='wx-config --cxxflags --wxcfg=gcc_dll/mswu'
LIBS+='wx-config --libs --wxcfg=gcc_dll/mswu'

wxwidgets.exe: $(OBJ)
  $(CXX) -o $@ $^ $(LIBS)

clean:
  rm -f *.o *.exe</pre></div><p>The <code class="literal">wx-config</code> utility is used here. This is the <code class="literal">wxWidgets</code> framework's alternative of the <code class="literal">pkg-config</code> utility of Gtk+ toolkit. The <code class="literal">wx-config</code> utility is used here to get the compiler and linker wxWidgets specific flags.</p><p>The next <code class="literal">wx-config</code> utility options have been used here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">--cxxflags</code>: This prints the preprocessor and compiler flags to compile the application with the wxWidget library</li><li class="listitem" style="list-style-type: disc"><code class="literal">--libs</code>: This prints linker flags to link the application with the wxWidget library</li><li class="listitem" style="list-style-type: disc"><code class="literal">--wxcfg</code>: This specifies a relative path to the <code class="literal">build.cfg</code> configuration file</li></ul></div><p>Now you are ready to compile our example application. Type the <code class="literal">make</code> command to do it. You will get the <code class="literal">wxwidgets.exe</code> executable file in the current directory after compilation.</p><p>It is important to note that you can debug and profile your applications based on any of the described toolkit and frameworks with the MinGW software tools (GDB debugger and gprof profiler).</p></div></div><div class="section" title="7 – Integrating with IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>7 – Integrating with IDE</h2></div></div></div><p>MinGW software can be integrated with a lot of well-known free IDE systems. Integration with the following systems will be described here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Code::Blocks</li><li class="listitem" style="list-style-type: disc">Qt Creator</li><li class="listitem" style="list-style-type: disc">Eclipse</li></ul></div><p>Integration in this case means the ability to edit MinGW-based project source code, building this project, and debugging it from the IDE. This integration provides a comfortable interface to interact with the most commonly used MinGW instruments.</p><div class="section" title="Code::Blocks"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Code::Blocks</h3></div></div></div><p>Code::Blocks is an open source cross-platform IDE for developing C and C++ applications. Code::Blocks has an open architecture. Thanks to this, IDE capabilities can be expanded with plugins with significant facilitates software development process.</p><p>Code::Blocks supports a lot of C and C++ compilers and several debuggers. This IDE is a good alternative for the Visual C++ one to develop C++ applications.</p><p>The following are instructions to install and configure the Code::Blocks IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the Code::Blocks IDE distribution with the already integrated MinGW software from the official website:<p>
<a class="ulink" href="http://www.codeblocks.org/downloads/binaries">http://www.codeblocks.org/downloads/binaries</a>
</p></li><li class="listitem">Install the downloaded Code::Blocks distribution. Run the downloaded exe file to do it.</li><li class="listitem">Select additional IDE components in <span class="strong"><strong>Choose Components</strong></span> dialog during installation process.<p>The default installable components will be enough to start developing the C++ application. But you can choose additional languages supporting GNU utilities and IDE plugins.</p></li><li class="listitem">Start installed Code::Blocks system and select <span class="strong"><strong>GNU GCC Compiler</strong></span> to use in the compilers auto-detection dialog.</li></ol></div><p>Now you are ready to use the Code::Blocks IDE system with integrated MinGW software.</p><p>You can install the Code::Blocks IDE without integrated MinGW software if you have already installed it. The following are instructions to set up Code::Blocks working with your already installed MinGW software:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run Code::Blocks IDE.</li><li class="listitem">Select <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Compiler and Debugger...</strong></span> in the main menu. You will see the compiler setting dialog:<div class="mediaobject"><img src="graphics/5626_01_06.jpg" alt="Code::Blocks"/></div></li><li class="listitem">Switch to the Toolchain executables tab. Specify the MinGW software installation directory and its utility executables file names.</li></ol></div><p>Perform the following actions to create a new MinGW based project in Code::Blocks IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run Code::Blocks IDE. You will see the main system window:<div class="mediaobject"><img src="graphics/5626_01_07.jpg" alt="Code::Blocks"/></div><p>You can see the <span class="strong"><strong>Start here</strong></span> tab content in the middle of the window. The main IDE menu is placed at the top of the window. The messages panel is placed at the bottom of the window. The build error messages, build log, debugger messages, and search results will be displayed here.</p></li><li class="listitem">Click on the <span class="strong"><strong>create a new</strong></span> project icon on the <span class="strong"><strong>Start here</strong></span> tab or choose <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project...</strong></span>in the main menu.</li><li class="listitem">We will create a template Windows application in this example. Choose the <span class="strong"><strong>Win32GUI project</strong></span> icon in the <span class="strong"><strong>new from template</strong></span> dialog to do it.</li><li class="listitem">Choose a frame-based type of project in the next dialog.</li><li class="listitem">Specify the project name and path to store its sources.</li><li class="listitem">Select the compiler to build the application in the last dialog. It will be equal to the GNU GCC compiler by default. Leave it unchanged.</li></ol></div><p>You will get template source files of the MinGW-based Windows API application. This application just shows an empty window at launch.</p><p>You can build our example application from the <span class="strong"><strong>Code::Blocks IDE</strong></span> interface. Choose <span class="strong"><strong>Build</strong></span> | <span class="strong"><strong>Build</strong></span> in the main menu or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F9</em></span> to do it. The build log and build messages will be displayed in the messages panel after that. Note what debug variant of build has been performed. You can change it to a release variant by switching the <span class="strong"><strong>Build target</strong></span> combobox in the main menu. The application executable files will be created at the <code class="literal">bin</code> subdirectory of the our project directory.</p><p>Now the application is ready to be run. Choose <span class="strong"><strong>Build</strong></span> | <span class="strong"><strong>Run</strong></span> in the main menu or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F10</em></span> to run the application. You will see the application window and console window , where the standard output stream messages will be displyed.</p><p>Code::Blocks IDE allows you to debug applications with the GDB debugger. First of all you must set breakpoints to stop program execution in specified places. Press the <span class="emphasis"><em>F5</em></span> key to set a breakpoint at the current line in the source file. Press <span class="emphasis"><em>F8</em></span> or choose <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Start</strong></span> from the main menu to start debugging. After that program execution stops at the specified line. Now you can get information about variables, call stack, CPU registers, and threads, or continue execution. All this functionality is available from the <span class="strong"><strong>Debug</strong></span> submenu. You can continue the application debugging with the next line (<span class="emphasis"><em>F7</em></span>) and step into (<span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F7</em></span>) commands.</p></div><div class="section" title="Qt Creator"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Qt Creator</h3></div></div></div><p>Qt Creator is a cross-platform open source IDE, which is part of the Qt software development kit. It includes a source code editor, visual debugger, and forms designer. It supports both MinGW and Visual C++ software.</p><p>Qt Creator is the best choice to develop Qt framework-based C++ applications. But other frameworks, toolkits, and programming languages are supported poorly. This obstacle must be considered when you choose this IDE for your application's development.</p><p>MinGW software and Qt libraries are not present in the Qt Creator IDE distribution and therefore you must install these separately.</p><p>The following are instructions to install and configure Qt Creator IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download Qt Creator IDE distribution from the official website:<p>
<a class="ulink" href="http://qt-project.org/downloads">http://qt-project.org/downloads</a>
</p></li><li class="listitem">Install Qt Creator with the help of the setup wizard. Just run the downloaded exe file to do it. Run the installed Qt Creator IDE. You will see the main system window:<div class="mediaobject"><img src="graphics/5626_01_08.jpg" alt="Qt Creator"/></div><p>The <span class="strong"><strong>Welcome</strong></span> tab content is placed in the middle of the window. You can see the main system menu at the top of the window. The control panel is placed at the left-hand side of the window. The most commonly used commands are available in this panel. Moreover the icons of different Qt Creator IDE modes (Editor, Designer and so on) are placed here. The messages' output panels are available at the bottom of window.</p></li><li class="listitem">Select <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options...</strong></span> in the main menu. You will see the <span class="strong"><strong>Options</strong></span> dialog.</li><li class="listitem">Switch to the <span class="strong"><strong>Build &amp; Run</strong></span> icon in the left-hand side of the dialog panel.</li><li class="listitem">Switch to the <span class="strong"><strong>Qt Versions</strong></span> tab at the top of the dialog window. Now you see the following screenshot:<div class="mediaobject"><img src="graphics/5626_01_09.jpg" alt="Qt Creator"/></div></li><li class="listitem">Click on the <span class="strong"><strong>Add</strong></span> button and specify the path to the <code class="literal">qmake.exe</code> file. This is <code class="literal">C:\Qt\4.6.4\bin\qmake.exe</code> for the default Qt libraries installation path.</li><li class="listitem">Switch to the <span class="strong"><strong>Tool Chains</strong></span> tab at the top of the dialog window. You will see the following screenshot:<div class="mediaobject"><img src="graphics/5626_01_10.jpg" alt="Qt Creator"/></div><p>Qt Creator can find already installed MinGW software automatically, but I recommend you manually add it for detailed configuration.</p></li><li class="listitem">Click on the <span class="strong"><strong>Add</strong></span> button and choose the MinGW variant in the pop-up list.</li><li class="listitem">Click on the <span class="strong"><strong>Browse...</strong></span> button near the <span class="strong"><strong>Compiler path</strong></span> field and specify the path to the <code class="literal">g++.exe</code> file. This is equal to <code class="literal">C:\MinGW4.4\bin\g++.exe</code> if the MinGW software has been installed to the <code class="literal">C:\MinGW4.4</code> directory.</li><li class="listitem">Click on the <span class="strong"><strong>Browse...</strong></span> button near the <span class="strong"><strong>Debugger</strong></span> input field and specify the path to the <code class="literal">gdb.exe</code> file. You can install the GDB debugger separately if your MinGW software distribution doesn't already contain it. The debugger path equals to <code class="literal">C:\MinGW4.4\bin\gdb.exe</code> for our example.</li><li class="listitem">Click on the <span class="strong"><strong>Apply</strong></span> and then <span class="strong"><strong>OK</strong></span> button to complete the configuration.</li></ol></div><p>Now you are ready to use the Qt Creator IDE system integrated with MinGW software and Qt libraries. Note that your MinGW software version must be the same as the MinGW software that has been used to build your installed Qt libraries.</p><p>The following are the instructions to create example Qt-based application with Qt Creator IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New File</strong></span> or <span class="strong"><strong>Project</strong></span> from the main menu. You will see the template application choosing dialog.</li><li class="listitem">Select <span class="strong"><strong>Applications</strong></span> and <span class="strong"><strong>Qt Gui Application</strong></span> variant in the project type selecting fields:<div class="mediaobject"><img src="graphics/5626_01_11.jpg" alt="Qt Creator"/></div></li><li class="listitem">Click on the <span class="strong"><strong>Choose...</strong></span> button.</li><li class="listitem">Specify the project name (for example, <code class="literal">qt</code>) and location to store the source files in the <span class="strong"><strong>Location</strong></span> tab of the <span class="strong"><strong>Qt Gui Application</strong></span> dialog. Click on the <span class="strong"><strong>Next</strong></span> button.</li><li class="listitem">Choose <span class="strong"><strong>Desktop</strong></span> target in the <span class="strong"><strong>Targets</strong></span> tab of the dialog and click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">You can change the default source files and class names in the <span class="strong"><strong>Details</strong></span> tab. I suggest you leave these unchanged for our example application. Just click on the <span class="strong"><strong>Next</strong></span> button.</li><li class="listitem">The subproject and version control can be added in the <span class="strong"><strong>Summary</strong></span> dialog tab. Switch version control to <span class="strong"><strong>None</strong></span> and click on the <span class="strong"><strong>Finish</strong></span> button.</li></ol></div><p>You will get a template of the Qt-based application with the source files located in a specified location.</p><p>Click on the <span class="strong"><strong>Build Project</strong></span> icon at the left-hand side of the control panel or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>B</em></span> to build our example application. The <code class="literal">qt.exe</code> executable file will be created in the <code class="literal">debug</code> subdirectory of the project directory. You can select the debug or release build variant in the control panel's project configuration submenu (this is placed under the <span class="strong"><strong>Run</strong></span> icon).</p><p>Click on the <span class="strong"><strong>Run</strong></span> icon to launch our example application. You will see the empty application window with the status bar and toolbar.</p><p>Qt Creator IDE allows you to debug your applications with the GDB debugger. This is standard procedure to do it; you must specify breakpoints at source file lines and then start debugging. Use the <span class="emphasis"><em>F9</em></span> key to set a breakpoint and the <span class="emphasis"><em>F5</em></span> key to start debugging.</p><p>The variables' current values, call-stack, and watchpoints configuration are available in debugging mode. You can find all this information in the additional panels of Qt Creator main window. Use <span class="strong"><strong>Step Over</strong></span> (<span class="emphasis"><em>F10</em></span>) and <span class="strong"><strong>Step Into</strong></span> (<span class="emphasis"><em>F11</em></span>) <span class="strong"><strong>Debug</strong></span> submenu items to continue application execution.</p></div><div class="section" title="Eclipse"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Eclipse</h3></div></div></div><p>Eclipse is a cross-platform open source IDE with multi-language support. There are a huge amount of plugins that have been developed for this IDE. Eclipse supports many compilers, interpreters, debuggers, version control systems, unit testing frameworks, and so on. You can use Eclipse for developing applications in any popular programming language and framework.</p><p>Eclipse is an excellent IDE for comfortable application developing, but it has been developed in Java and has a massive architecture. Therefore there are high demands on the performance of your computer.</p><p>This is not the Eclipse IDE system distribution that contains the MinGW software. You must install it separately to integrate with Eclipse.</p><p>The following are instructions to install and configure the Eclipse IDE system:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download <span class="strong"><strong>Java Runtime Environment</strong></span> (<span class="strong"><strong>JRE</strong></span>) from the official website:<p>
<a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>
</p></li><li class="listitem">Install it with the setup wizard. Just run the downloaded exe file to do it.</li><li class="listitem">Add the path of the JRE executable files to the <code class="literal">PATH</code> Windows environment variable (for example, <code class="literal">C:\Program Files\Java\jre7\bin</code>).</li><li class="listitem">Download the Eclipse IDE for C/C++ Developers version archive from the official website:<p>
<a class="ulink" href="http://www.eclipse.org/downloads">http://www.eclipse.org/downloads</a>
</p><p>Note what you need the 32-bit Eclipse IDE system version for 32-bit JRE and 64-bit one for 64-bit JRE.</p></li><li class="listitem">Unpack the Eclipse archive to any directory (for example, <code class="literal">C:\Program Files</code>)</li></ol></div><p>Now you are ready to use the Eclipse IDE system. The MinGW software utilities will be integrated automatically thanks to Windows environment variables. Therefore the MinGW <code class="literal">bin</code> subdirectory with executable files must be specified there.</p><p>The following are instructions to create an example application in Eclipse IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run Eclipse IDE. You will see the <span class="strong"><strong>Welcome</strong></span> screen.</li><li class="listitem">Select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>C++ Project</strong></span> from the main menu. You will see the project configuration dialog as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5626_01_12.jpg" alt="Eclipse"/></div></li><li class="listitem">Select the <span class="strong"><strong>Hello world C++ Project</strong></span> item in the <span class="strong"><strong>Project type</strong></span> selection field. Select the <span class="strong"><strong>MinGW GCC</strong></span> item in the <span class="strong"><strong>Toolchains</strong></span> selection field. Click on the <span class="strong"><strong>Next</strong></span> button. You will see the <span class="strong"><strong>Basic Settings</strong></span> dialog. The author, copyright notice, and source files directory can be specified here.</li><li class="listitem">Click on the <span class="strong"><strong>Next</strong></span> button. This is the <span class="strong"><strong>Select Configurations</strong></span> dialog. Debug, release, or both build configurations availability can be selected here.</li><li class="listitem">Click on the <span class="strong"><strong>Finish</strong></span> button.</li></ol></div><p>After that you get a template C++ console project with the source files placed at the <code class="literal">src</code> subdirectory of the project directory. Now you see the Eclipse IDE window as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5626_01_13.jpg" alt="Eclipse"/></div><p>The <span class="strong"><strong>Project Explorer</strong></span> panel is placed at the left-hand side of the window. You can find all the project source files here. The source file editor is placed in the middle part of the window. You can find the messages' output panel at the bottom of the window.</p><p>Select <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>Build Project</strong></span> from the main menu to build our example application. After that the executable file will be created in the <code class="literal">Debug</code> subdirectory of the project directory. You can switch to the release configuration to build the project. Click on the build icon (hammer icon) at the main menu and select <span class="strong"><strong>Release</strong></span> configuration to build. The <code class="literal">Release</code> subdirectory will be created with the compiled executable file.</p><p>Select <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run</strong></span> from the main menu or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F11</em></span> to launch our example application. You will see the result of the application execution in the console output panel at the bottom of the Eclipse window.</p><p>You can debug applications with the Eclipse IDE system. Press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span> key to set the breakpoint at the current line of a source file. After setting the breakpoints select <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Debug</strong></span> from the main menu or press the <span class="emphasis"><em>F11</em></span> key to start debugging. You will see panels with call-stack, variable values, CPU registers values, breakpoints, and loaded modules in the debugging mode. Use the <span class="strong"><strong>Step Over</strong></span> (<span class="emphasis"><em>F6</em></span>) and <span class="strong"><strong>Step Into</strong></span> (<span class="emphasis"><em>F5</em></span>) <span class="strong"><strong>Run</strong></span> submenu items to continue application execution.</p></div></div></div>
<div class="section" title="People and places you should get to know"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>People and places you should get to know</h1></div></div></div><p>There is a lot of information about MinGW software available on the Internet. You will get to know some helpful sources from this section.</p><div class="section" title="MinGW official sites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>MinGW official sites</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Homepage</strong></span>: <a class="ulink" href="http://www.mingw.org">http://www.mingw.org</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manuals</strong></span>: <a class="ulink" href="http://www.mingw.org/wiki/HOWTO">http://www.mingw.org/wiki/HOWTO</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Wiki</strong></span>: <a class="ulink" href="http://www.mingw.org/wiki">http://www.mingw.org/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Source code and binary files</strong></span>: <a class="ulink" href="http://sourceforge.net/projects/mingw/%E2%80%A8files/MinGW">http://sourceforge.net/projects/mingw/files/MinGW</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Available mailing lists</strong></span>: <a class="ulink" href="http://www.mingw.org/lists.shtml">http://www.mingw.org/lists.shtml</a></li></ul></div></div><div class="section" title="MinGW-w64 official sites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>MinGW-w64 official sites</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Homepage</strong></span>: <a class="ulink" href="http://mingw-w64.sourceforge.net">http://mingw-w64.sourceforge.net</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Wiki</strong></span>: <a class="ulink" href="http://sourceforge.net/apps/trac/mingw-w64">http://sourceforge.net/apps/trac/mingw-w64</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Source code and binary files</strong></span>: <a class="ulink" href="http://sourceforge.net/projects/mingw-w64/files">http://sourceforge.net/projects/mingw-w64/files</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Discussion forum</strong></span>: <a class="ulink" href="http://sourceforge.net/projects/mingw-w64/forums/forum/723797">http://sourceforge.net/projects/mingw-w64/forums/forum/723797</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Public support mailing list</strong></span>: <a class="ulink" href="https://lists.sourceforge.net/lists/listinfo/mingw-w64-public">https://lists.sourceforge.net/lists/listinfo/mingw-w64-public</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Support IRC channel</strong></span>: <a class="ulink" href="http://irc://irc.oftc.net/#mingw-w64">irc://irc.oftc.net/#mingw-w64</a></li></ul></div></div><div class="section" title="GNU Compiler Collection official sites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>GNU Compiler Collection official sites</h2></div></div></div><p>You can find a lot of useful information about MinGW utilities on the GCC official site:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Homepage</strong></span>: <a class="ulink" href="http://gcc.gnu.org">http://gcc.gnu.org</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manual and documentation</strong></span>: <a class="ulink" href="http://gcc.gnu.org/onlinedocs">http://gcc.gnu.org/onlinedocs</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Wiki</strong></span>: <a class="ulink" href="http://gcc.gnu.org/wiki">http://gcc.gnu.org/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Available mailing lists</strong></span>: <a class="ulink" href="http://gcc.gnu.org/lists.html">http://gcc.gnu.org/lists.html</a></li></ul></div></div><div class="section" title="GNU Debugger official sites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>GNU Debugger official sites</h2></div></div></div><p>All the information that you need to debug an application with GNU Debugger can be found at the official site:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Homepage</strong></span>: <a class="ulink" href="http://www.gnu.org/software/gdb">http://www.gnu.org/software/gdb</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manual and documentation</strong></span>: <a class="ulink" href="http://www.gnu.org/software/gdb/documentation">http://www.gnu.org/software/gdb/documentation</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Wiki</strong></span>: <a class="ulink" href="http://sourceware.org/gdb/wiki">http://sourceware.org/gdb/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Available mailing lists</strong></span>: <a class="ulink" href="http://www.gnu.org/software/gdb/mailing-lists">http://www.gnu.org/software/gdb/mailing-lists</a></li></ul></div></div><div class="section" title="GNU Make official sites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>GNU Make official sites</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Homepage</strong></span>: <a class="ulink" href="http://www.gnu.org/software/make">http://www.gnu.org/software/make</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manual and documentation</strong></span>: <a class="ulink" href="http://www.gnu.org/software/make/manual/%E2%80%A8html_node/index.html">http://www.gnu.org/software/make/manual/html_node/index.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mailing lists</strong></span>: <code class="email">&lt;<a class="email" href="mailto:bug-make@gnu.org">bug-make@gnu.org</a>&gt;</code>; <code class="email">&lt;<a class="email" href="mailto:help-make@gnu.org">help-make@gnu.org</a>&gt;</code></li></ul></div></div><div class="section" title="Articles and tutorials"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Articles and tutorials</h2></div></div></div><p>Here you can find several useful articles and tutorials for MinGW software usage:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html">http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html</a>: This is a detailed article about gprof profiler usage</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor">http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor</a>: This is quite simple and demonstrative tutorial on GNU Make utility</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html</a>: You will find detailed information about MinGW C++ compiler optimization capabilities</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://gcc.gnu.org/onlinedocs/gcc/Standards.html">http://gcc.gnu.org/onlinedocs/gcc/Standards.html</a>: You can find information about compiler's supporting standards</li></ul></div></div><div class="section" title="Community"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Community</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Largest free and open source-focused IRC network</strong></span>: <a class="ulink" href="http://freenode.net">http://freenode.net</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unofficial distributions</strong></span>: <a class="ulink" href="http://nuwen.net/mingw.html">http://nuwen.net/mingw.html</a>; <a class="ulink" href="http://tdm-gcc.tdragon.net">http://tdm-gcc.tdragon.net</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Several MinGW developers sites</strong></span>: <a class="ulink" href="http://www.willus.com/mingw/colinp">http://www.willus.com/mingw/colinp</a>; <a class="ulink" href="http://www.megacz.com">http://www.megacz.com</a>; <a class="ulink" href="http://rmathew.com">http://rmathew.com</a></li></ul></div></div><div class="section" title="Twitter"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Twitter</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Packt Publishing</strong></span>: <a class="ulink" href="https://twitter.com/packtopensource">https://twitter.com/packtopensource</a></li></ul></div></div></div></body></html>