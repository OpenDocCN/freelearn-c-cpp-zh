<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch05" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 5. Extending Paint Applications with Plugins</h1></div></div></div><p class="calibre9">Plugins enable you to<a id="id222" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> make your application extendable and friendly for other developers. Therefore, in this chapter, we'll guide you in how to write plugins for Qt applications. A paint application demonstrates the recipe for Qt/C++. A simple demonstration shows you how to write a C++ plugin for QML. The topics we will cover in this chapter are listed as follows:</p><div><ul class="itemizedlist"><li class="listitem">Drawing via <code class="literal">QPainter</code></li><li class="listitem">Writing static plugins</li><li class="listitem">Writing dynamic plugins</li><li class="listitem">Merging plugin and main program projects</li><li class="listitem">Creating a C++ plugins for QML applications</li></ul></div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec36" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Drawing via QPainter</h1></div></div></div><p class="calibre9">Before we get started, let me introduce the <code class="literal">QPainter</code> class to you. This class performs low-level painting on <a id="id223" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>widgets and other paint devices. In fact, everything drawn<a id="id224" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> on the screen in a Qt application is the result of <code class="literal">QPainter</code>. It can draw almost anything, including simple lines and aligned text. Thanks to the high-level APIs that Qt has provided, it's extremely easy to use these rich features.</p><p class="calibre9">Qt's paint system consists of <code class="literal">QPainter</code>, <code class="literal">QPaintDevice</code>, and <code class="literal">QPaintEngine</code>. In this chapter, we won't need to deal with the latter two. The relations diagram is sketched as follows:</p><div><img src="img/4615OS_05_01.jpg" alt="Drawing via QPainter" class="calibre54"/></div><p class="calibre9">
<code class="literal">QPainter</code> is used to perform drawing operations, while <a id="id225" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">QPaintDevice</code> is an abstraction of a two-dimensional space that can be painted on by using <code class="literal">QPainter</code>. <code class="literal">QPaintEngine</code> <a id="id226" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>provides the<a id="id227" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> interface that the painter uses to draw onto different types of devices. Note that the <code class="literal">QPaintEngine</code> class is used internally by <code class="literal">QPainter</code> and <code class="literal">QPaintDevice</code>. It's also designed to be hidden from programmers unless they create their own device type.</p><p class="calibre9">So basically, what<a id="id228" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> we need to concentrate on is <code class="literal">QPainter</code>. Let's create a new project and do some exercises in it. The new <code class="literal">painter_demo</code> project is a Qt Widget application. Quickly create it and add a new C++ <code class="literal">Canvas</code> class that inherits from <code class="literal">QWidget</code>. <code class="literal">Canvas</code> is our customized widget whose header file is shown as follows:</p><div><pre class="programlisting">#ifndef CANVAS_H
#define CANVAS_H

#include &lt;QWidget&gt;

class Canvas : public QWidget
{
  Q_OBJECT
  public:
    explicit Canvas(QWidget *parent = 0);

  private:
    QVector&lt;QPointF&gt; m_points;

  protected:
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
};

#endif // CANVAS_H</pre></div><p class="calibre9">The <code class="literal">QVector</code> class<a id="id229" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is a template class that provides a fast and dynamic array. It's fast because the items are stored in adjacent memory locations, which means that the indexing time is constant. Here, we store the <code class="literal">QPointF</code> elements in <code class="literal">m_points</code>, where <code class="literal">QPointF</code> is a class that defines a point using a floating point precision.</p><p class="calibre9">In a <code class="literal">protected</code> scope, there are four event functions. We're familiar with these mouse events. The leading one, which is also the new one, is the<a id="id230" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">paintEvent</code> function. Since we're painting on the widget, <code class="literal">QPainter</code> should only be used inside the <code class="literal">paintEvent</code> function.</p><p class="calibre9">The definitions <a id="id231" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of the functions in <code class="literal">canvas.cpp</code> are shown as follows:</p><div><pre class="programlisting">#include &lt;QStyleOption&gt;
#include &lt;QPainter&gt;
#include &lt;QPaintEvent&gt;
#include &lt;QMouseEvent&gt;
#include "canvas.h"

Canvas::Canvas(QWidget *parent) :
  QWidget(parent)
{
}

void Canvas::paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  QStyleOption opt;
  opt.initFrom(this);
  this-&gt;style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;painter, this);

  painter.setPen(QColor(Qt::black));
  painter.setRenderHint(QPainter::Antialiasing);
  painter.drawPolyline(m_points.data(), m_points.count());
}

void Canvas::mousePressEvent(QMouseEvent *e)
{
  m_points.clear();
  m_points.append(e-&gt;localPos());
  this-&gt;update();
}

void Canvas::mouseMoveEvent(QMouseEvent *e)
{
  m_points.append(e-&gt;localPos());
  this-&gt;update();
}

void Canvas::mouseReleaseEvent(QMouseEvent *e)
{
  m_points.append(e-&gt;localPos());
  this-&gt;update();
}</pre></div><p class="calibre9">First, let's check what's inside the <a id="id232" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">paintEvent</code> function. The first clause is to initialize a <code class="literal">QPainter</code> object, which<a id="id233" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> uses this as <code class="literal">QPaintDevice</code>. Well, there is an alternate way to initialize a <code class="literal">QPainter</code> class, which is demonstrated here:</p><div><pre class="programlisting">QPainter painter;
painter.begin(this);
painter.drawPolyline(m_points.data(), m_points.count());
painter.end();</pre></div><p class="calibre9">If you use the method shown in the preceding code, remember to call the <code class="literal">end()</code> function to destroy <code class="literal">painter</code>. By contrast, if you initialize <code class="literal">QPainter</code> by its constructor, the destructor will automatically call the <code class="literal">end()</code> function. However, the constructor won't return a value indicating whether it was initialized successfully or not. Thus, it'd be better to choose the latter method when dealing with an external <code class="literal">QPaintDevice</code> such as a printer.</p><p class="calibre9">After the initialization, we <a id="id234" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>use <code class="literal">QStyleOption</code>, which contains all the information that the <code class="literal">QStyle</code> functions need to draw a graphical element and make our customized widget style-aware. We simply use the <code class="literal">initFrom</code> function to get the style information. Then, we get the <code class="literal">QStyle</code> function of our widget and draw <code class="literal">QStyle::PE_Widget</code> with <code class="literal">painter</code> using the style options specified by <code class="literal">opt</code>. If we don't write these three lines, we can't change the widget display style, such as the background color.</p><p class="calibre9">Then, we let the painter use a black pen to draw an anti-aliasing polyline on the widget. Here, an overloaded<a id="id235" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">setPen</code> function is used. The <code class="literal">painter.setPen(QColor(Qt::black))</code> function will set a solid-line style pen with a width of <code class="literal">1</code> and the color in black. The <code class="literal">painter.setRenderHint(QPainter::Antialiasing)</code> function will make the drawing smooth.</p><div><div><h3 class="title4"><a id="note17" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">A second argument, <code class="literal">bool</code>, controls the render hint. It's <code class="literal">true</code> by default, which means that you need to turn on the render hint. You can turn off a render hint by passing a <code class="literal">false</code> value, though.</p></div></div><p class="calibre9">A list of the available render hints are shown as follows:</p><div><pre class="programlisting">QPainter::Antialiasing
QPainter::TextAntialiasing
QPainter::SmoothPixmapTransform
QPainter::Qt4CompatiblePainting</pre></div><p class="calibre9">There are also two obsolete hints: <code class="literal">QPainter::HighQualityAntialiasing</code> and <code class="literal">QPainter::NonCosmeticDefaultPen</code>. The first one is replaced by <code class="literal">QPainter::Antialiasing</code> and the second is useless because <code class="literal">QPen</code> is non-cosmetic by default now.</p><p class="calibre9">Finally, the <code class="literal">drawPolyline</code> function<a id="id236" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> will draw a polyline, which is made from the mouse movements, on the <code class="literal">Canvas</code> widget. The first argument is the pointer to a <code class="literal">QPointF</code> or <code class="literal">QPoint</code> array, while the second one is the number of items inside that array.</p><p class="calibre9">Speaking of mouse movements, three mouse event functions are used to track the mouse. In fact, they're pretty self-explanatory. When a mouse press event occurs, purge the points array<a id="id237" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> because it's obviously a new polyline now, and then add the mouse position by invoking a<a id="id238" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">localPos()</code> function. The <code class="literal">localPos()</code> function will return the position of the mouse relative to the widget or item that received the event. Although you can get a global position by the <code class="literal">screenPos()</code> and <code class="literal">globalPos()</code> function, in most cases, we only need a local position. At the end of these event functions, call <code class="literal">update()</code> to repaint the widget to show the mouse moving path as a polyline.</p><p class="calibre9">Now, edit <code class="literal">mainwindow.ui</code> in the <strong class="calibre10">Design</strong> mode. Remove the status bar since we won't use it in this chapter, but keep the menu bar. Drag <strong class="calibre10">Widget</strong> to <code class="literal">centralWidget</code> and rename it as <code class="literal">canvas</code>. Right-click on <code class="literal">canvas</code> and select <strong class="calibre10">Promote to …</strong>, and then fill in <code class="literal">Canvas</code> in <strong class="calibre10">Promoted class name</strong>. Now, click on <strong class="calibre10">Add</strong>, and then on <strong class="calibre10">Promote</strong>. You shouldn't check the <strong class="calibre10">Global include</strong> box because the <code class="literal">canvas.h</code> header file is in our project directory instead of the global include directory.</p><p class="calibre9">Inside <strong class="calibre10">Property</strong>, edit <code class="literal">styleSheet</code>, input <code class="literal">background-color: rgb(255, 255, 255);</code> so that the canvas has a white background. Then, change the <code class="literal">MainWindow</code> class' layout to <strong class="calibre10">Lay Out Horizontally</strong> or <strong class="calibre10">Lay Out Vertically</strong> so that the <code class="literal">canvas</code> widget can fill the whole frame. Give your application a run now; you should expect a simple white painter as follows:</p><div><img src="img/4615OS_05_02.jpg" alt="Drawing via QPainter" class="calibre18"/></div><p class="calibre9">This painter is<a id="id239" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> too simple to hold the old lines. While Qt doesn't provide an API to paint on the old scene, <code class="literal">QImage</code> can get us out of this dilemma. In other words, when the mouse moves, we paint a stroke on a <code class="literal">QImage</code> object, and then paint this <code class="literal">QImage</code> object onto <code class="literal">Canvas</code>.</p><p class="calibre9">The new header file, <code class="literal">canvas.h</code>, is as shown as follows:</p><div><pre class="programlisting">#ifndef CANVAS_H
#define CANVAS_H

#include &lt;QWidget&gt;

class Canvas : public QWidget
{
  Q_OBJECT
  public:
    explicit Canvas(QWidget *parent = 0);

  private:
    QVector&lt;QPointF&gt; m_points;
    QImage image;

    void updateImage();

  protected:
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void resizeEvent(QResizeEvent *);
};

#endif // CANVAS_H</pre></div><p class="calibre9">The differences include the declaration of a <code class="literal">QImage</code> object, <code class="literal">image</code>; private member function, <code class="literal">updateImage()</code>; and a reimplemented function, <code class="literal">resizeEvent(QResizeEvent *)</code>. The <code class="literal">paintEvent(QPaintEvent *)</code> function is also changed to<a id="id240" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> draw the <code class="literal">image</code> object instead, whereas there are more modifications in the <code class="literal">canvas.cpp</code> source file than the header file, whose content is shown here:</p><div><pre class="programlisting">#include &lt;QStyleOption&gt;
#include &lt;QPainter&gt;
#include &lt;QPaintEvent&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QResizeEvent&gt;
#include "canvas.h"

Canvas::Canvas(QWidget *parent) :
  QWidget(parent)
{
}

void Canvas::<strong class="calibre10">paintEvent</strong>(QPaintEvent *e)
{
  QPainter painter(this);

  QStyleOption opt;
  opt.initFrom(this);
  this-&gt;style()-&gt;<strong class="calibre10">drawPrimitive</strong>(QStyle::PE_Widget, &amp;opt, &amp;painter, this);

<strong class="calibre10">  painter.drawImage(e-&gt;rect().topLeft(), image);</strong>
}

void Canvas::updateImage()
{
  QPainter painter(&amp;image);
  painter.setPen(QColor(Qt::black));
  painter.setRenderHint(QPainter::Antialiasing);
  painter.drawPolyline(m_points.data(), m_points.count());
  this-&gt;update();
}

void Canvas::<strong class="calibre10">mousePressEvent</strong>(QMouseEvent *e)
{
  m_points.clear();
  m_points.append(e-&gt;localPos());
  updateImage();
}

void Canvas::<strong class="calibre10">mouseMoveEvent</strong>(QMouseEvent *e)
{
  m_points.append(e-&gt;localPos());
  updateImage();
}

void Canvas::<strong class="calibre10">mouseReleaseEvent</strong>(QMouseEvent *e)
{
  m_points.append(e-&gt;localPos());
  updateImage();
}

void Canvas::<strong class="calibre10">resizeEvent</strong>(QResizeEvent *e)
{
  QImage newImage(e-&gt;size(), QImage::Format_RGB32);
  newImage.fill(Qt::white);
  QPainter painter(&amp;newImage);
  painter.drawImage(0, 0, image);
  image = newImage;
  QWidget::<strong class="calibre10">resizeEvent</strong>(e);
}</pre></div><p class="calibre9">Let's look into the mouse <a id="id241" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>event handlers; after the operation on <code class="literal">m_points</code>, the <code class="literal">updateImage()</code>function is called instead of <code class="literal">update()</code>. Inside the <code class="literal">updateImage()</code> function, we create a <code class="literal">QPainter</code> object using the <code class="literal">QImage</code> object image as <code class="literal">QPaintDevice</code> while the rest of them are just the same as in <code class="literal">paintEvent</code>.</p><p class="calibre9">There is a new member function, though, called <code class="literal">resizeEvent</code>, which is reimplemented from <code class="literal">QWidget</code>. As you can imagine, we change the underlying <code class="literal">QImage</code> object once the widget size changes, which could be as a result of window resizing. Therefore, we simply paint the old image onto the new one. This may cause the loss of a part of the image if the new size<a id="id242" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is smaller than the previous one. You may wish to add <code class="literal">Scroll Area</code> to <code class="literal">MainWindow</code> and make <code class="literal">Canvas</code> the child widget of <code class="literal">Scroll Area</code>. You already know how to do that in QML, while it's similar in Qt/C++. Therefore, just take it as an exercise and implement <code class="literal">Scroll Area</code> for this application.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec37" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Writing static plugins</h1></div></div></div><p class="calibre9">There are two types <a id="id243" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of plugins: static and dynamic. Static plugins are statically linked to the executables, while the dynamic plugins are loaded at runtime. Dynamic plugins exist as the <code class="literal">.dll</code> or <code class="literal">.so</code> files, depending on the platform. Although the static plugins will be built as the <code class="literal">.lib</code> or <code class="literal">.a</code> files, they'll be integrated into an executable file when the main program gets compiled.</p><p class="calibre9">In this topic, we'll get to know how to write a static plugin to extend the application. Serving as an external plugin, it gains the flexibility to change its internal code while it's only required to keep the interface compatible. It's up to you to decide whether the interface should be maintained in the main program or in different plugins. In this example, we'll put the <code class="literal">interface.h</code> file in the main program, <code class="literal">painter_demo</code>. The content of <code class="literal">interface.h</code> is as follows:</p><div><pre class="programlisting">#ifndef INTERFACE_H
#define INTERFACE_H

#include &lt;QtPlugin&gt;
#include &lt;QPainterPath&gt;

class InsertInterface
{
  public:
    virtual ~InsertInterface() {}
    virtual QString name() const = 0;
    virtual QPainterPath getObject(QWidget *parent) = 0;
};


#define InsertInterface_iid "org.qt-project.Qt.PainterDemo.InsertInterface"
Q_DECLARE_INTERFACE(InsertInterface, InsertInterface_iid)

#endif // INTERFACE_H</pre></div><p class="calibre9">As you can see, we declare a<a id="id244" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> pure virtual class, <code class="literal">InsertInterface</code>. In order to avoid errors, you have to declare a virtual destructor. Otherwise, the compiler may complain and abort the <a id="id245" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>compilation. The <code class="literal">QPainterPath</code> class<a id="id246" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> provides a container for common 2D painting operations, including <code class="literal">ellipse</code> and <code class="literal">text</code>. Hence, the return type of <code class="literal">getObject</code> is <code class="literal">QPainterPath</code> ,which can be used directly where the argument, <code class="literal">QWidget</code>, could be useful if there is a newly created dialog to get any input from the user.</p><p class="calibre9">At the end of this file, we declare <code class="literal">InsertInterface</code> as an interface by the <code class="literal">Q_DECLARE_INTERFACE</code> macro, where <code class="literal">InsertInterface_iid</code> is the identifier for the <code class="literal">InsertInterface</code> class. Note that the identifier must be unique, so it's recommended that you use a Java-style naming rule.</p><p class="calibre9">Now, we need to create a new project. Navigate to <strong class="calibre10">Libraries</strong> | <strong class="calibre10">C++ Library</strong>. Then, as shown in the following screenshot, select <strong class="calibre10">Qt Plugin</strong> for <strong class="calibre10">Type</strong> and keep this project inside the main program project folder for the sake of convenience or any concerns:</p><div><img src="img/4615OS_05_03.jpg" alt="Writing static plugins" class="calibre55"/></div><p class="calibre9">Click on <strong class="calibre10">Next</strong> and choose the same Qt kits as the <code class="literal">painter_demo</code> project. In this example, the <code class="literal">build</code> directory is set in the same directory as the <code class="literal">painter_demo</code> project, which is <code class="literal">D:\Projects\build</code>. Therefore, the <code class="literal">build</code> directory of <code class="literal">TextPlugin</code> is <code class="literal">D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Debug</code> and <code class="literal">D:\Projects\build\TextPlugin-Qt_5_4_0_mingw491_32-Release</code> for <code class="literal">Debug</code> and <code class="literal">Release</code>, respectively.</p><div><div><h3 class="title4"><a id="note18" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Furthermore, you can change <strong class="calibre10">Default build directory</strong> in <strong class="calibre10">Tools</strong> | <strong class="calibre10">Options</strong> | <strong class="calibre10">Build &amp; Run</strong> | <strong class="calibre10">General</strong>. In this book, we use <code class="literal">D:/Projects/build/%{CurrentProject:Name}-%{CurrentKit:FileSystemName}-%{CurrentBuild:Name}</code> so that all the builds are organized in one place.</p></div></div><p class="calibre9">Then, fill in <code class="literal">TextPlugin</code> in<a id="id247" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <code class="literal">Class name</code> field, as shown in the following screenshot:</p><div><img src="img/4615OS_05_04.jpg" alt="Writing static plugins" class="calibre55"/></div><p class="calibre9">We need to apply some modifications to the <code class="literal">TextPlugin.pro</code> project file, as displayed here:</p><div><pre class="programlisting">QT       += core gui widgets

TARGET = TextPlugin
TEMPLATE = lib
<strong class="calibre10">CONFIG += plugin static</strong>

<strong class="calibre10">DESTDIR = ../plugins</strong>

SOURCES += textplugin.cpp

<strong class="calibre10">INCLUDEPATH += ../</strong>

HEADERS += textplugin.h
OTHER_FILES += TextPlugin.json</pre></div><p class="calibre9">By adding <a id="id248" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>widgets, we can use some useful classes such as <code class="literal">QMessageBox</code>. We also need to add <code class="literal">static</code> to <code class="literal">CONFIG</code> to declare this a static plugin project. Then, change the <code class="literal">DESTDIR</code> variable to <code class="literal">../plugins</code> so that the plugin is installed to the <code class="literal">plugins</code> directory outside the <code class="literal">build</code> folder. Lastly, we add the upper directory <code class="literal">../</code> to <code class="literal">INCLUDEPATH</code> so that we can include the <code class="literal">interface.h</code> header file in this subproject. The <code class="literal">textplugin.h</code> file is shown as follows:</p><div><pre class="programlisting">#ifndef TEXTPLUGIN_H
#define TEXTPLUGIN_H

#include "interface.h"


class TextPlugin : public QObject,
                   public InsertInterface
{
  Q_OBJECT
  Q_PLUGIN_METADATA(IID "org.qt-project.Qt.PainterDemo.InsertInterface" FILE "TextPlugin.json")
  Q_INTERFACES(InsertInterface)

  public:
    QString name() const;
    QPainterPath getObject(QWidget *parent);
};

#endif // TEXTPLUGIN_H</pre></div><p class="calibre9">We use the <code class="literal">Q_PLUGIN_METADATA</code> macro to specify the unique <code class="literal">IID</code>, which is the same as the one we declared in <code class="literal">interface.h</code>, where <code class="literal">FILE "TextPlugin.json"</code> can be used to contain the metadata for this plugin. In this case, we just keep the <code class="literal">TextPlugin.json</code> file intact. Then, the <code class="literal">Q_INTERFACES</code> macro tells the compiler that this is a plugin for <code class="literal">InsertInterface</code>. In the <code class="literal">public</code> scope, there are just two reimplemented functions. Their definitions are located in the <code class="literal">textplugin.cpp</code> source file, whose content is pasted as follows:</p><div><pre class="programlisting">#include &lt;QInputDialog&gt;
#include "textplugin.h"

QString TextPlugin::name() const
{
  return QString("Text");
}

QPainterPath TextPlugin::getObject(QWidget *parent)
{
  QPainterPath ppath;
  QString text = QInputDialog::getText(parent, QString("Insert Text"), QString("Text"));

  if (!text.isEmpty()) {
    ppath.addText(10, 80, QFont("Cambria", 60), text);
  }
  return ppath;
}</pre></div><p class="calibre9">The <code class="literal">name()</code> function simply returns the name of this plugin, which is <code class="literal">Text</code> in this case. As for <code class="literal">getObject</code>, it constructs a <code class="literal">QPainterPath</code> class that contains the text given by the user via a pop-up dialog, and then returns the <code class="literal">QPainterPath</code> object to the main program. The <code class="literal">addText</code> function will <a id="id249" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>draw the text as a set of closed subpaths<a id="id250" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> created from the font, while the first two arguments define the left end of the baseline for this text.</p><p class="calibre9">This is it for the plugin project. Now, just build it and you should expect a <code class="literal">libTextPlugin.a</code> file to be located under the <code class="literal">plugins</code> directory, while the <code class="literal">plugins</code> directory itself should be located in the parent directory of your project's <code class="literal">build</code> folders, as shown here:</p><div><img src="img/4615OS_05_05.jpg" alt="Writing static plugins" class="calibre56"/></div><p class="calibre9">It doesn't matter much if you put the files under other directories, although this means that you need to do some path modifications relevantly afterwards.</p><p class="calibre9">Now, let's go back to the main program's project, which is <code class="literal">painter_demo</code> in this example. Edit its <code class="literal">painter_demo.pro</code> project file and add the following line to it:</p><div><pre class="programlisting">LIBS     += -L../plugins -lTextPlugin</pre></div><div><div><h3 class="title4"><a id="tip11" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">The working directory during compilation is the <code class="literal">build</code> directory instead of the project source code directory.</p></div></div><p class="calibre9">Then, edit <code class="literal">mainwindow.ui</code> in the <strong class="calibre10">Design</strong> mode; add a menu named <code class="literal">Plugins</code> to the menu bar, whose object name is <code class="literal">menuPlugins</code>.</p><p class="calibre9">Among all the changes<a id="id251" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> made in the main program, the modifications for the <code class="literal">MainWindow</code> class are maximum. Here is the code of the new <code class="literal">mainwindow.h</code> file:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

  public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

  private:
    Ui::MainWindow *ui;

    void loadPlugins();
    void generatePluginMenu(QObject *);

  private slots:
    void onInsertInterface();
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">Still no clue about it? Well, its <code class="literal">mainwindow.cpp</code> source file is pasted here as well:</p><div><pre class="programlisting">#include &lt;QPluginLoader&gt;
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "interface.h"

Q_IMPORT_PLUGIN(TextPlugin)

MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);
  loadPlugins();
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::loadPlugins()
{
  foreach(QObject *plugin, QPluginLoader::staticInstances()) {
    generatePluginMenu(plugin);
  }
}

void MainWindow::generatePluginMenu(QObject *plugin)
{
  InsertInterface *insertInterfacePlugin = qobject_cast&lt;InsertInterface *&gt;(plugin);
  if (insertInterfacePlugin) {
    QAction *action = new QAction(insertInterfacePlugin-&gt;name(), plugin);
    connect(action, &amp;QAction::triggered, this, &amp;MainWindow::onInsertInterface);
    ui-&gt;menuPlugins-&gt;addAction(action);
  }
}

void MainWindow::onInsertInterface()
{
  QAction *action = qobject_cast&lt;QAction *&gt;(sender());
  InsertInterface *insertInterfacePlugin = qobject_cast&lt;InsertInterface *&gt;(action-&gt;parent());
  const QPainterPath ppath = insertInterfacePlugin-&gt;getObject(this);
  if (!ppath.isEmpty()) {
    ui-&gt;canvas-&gt;insertPainterPath(ppath);
  }
}</pre></div><p class="calibre9">You may have figured out that the <code class="literal">Q_IMPORT_PLUGIN</code> macro is used to import the plugin. Yes, it is, but only for static plugins. In the <code class="literal">loadPlugins()</code> function, we walked through all the static plugin instances and added them to the menu by invoking the <code class="literal">generatePluginMenu</code> function.</p><p class="calibre9">Plugins are treated as plain <code class="literal">QOjbect</code> objects at first, and then you can use <code class="literal">qobject_cast</code> to <a id="id252" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>convert them to their own classes. The <code class="literal">qobject_cast</code> class will return a <code class="literal">NULL</code> pointer if it failed. Inside the <code class="literal">if</code> statement, there is a trick to use the plugin successfully later. Instead of calling a simplified and overloaded <code class="literal">addAction</code> function, we can construct <code class="literal">QAction</code> and add it to the menu, because <code class="literal">QAction</code> will have the plugin as its <code class="literal">QObject</code> parent. Therefore, you can see that we convert its parent to the relevant plugin class in the<a id="id253" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">onInsertInterface</code> function. Inside this function, we call the <code class="literal">insertPainterPath</code> function to paint the <code class="literal">QPainterPath</code> class returned by the plugin on <code class="literal">canvas</code>. Of course, we need to declare and define this function in the <code class="literal">Canvas</code> class. Add this statement to the <code class="literal">public</code> domain of the <code class="literal">canvas.h</code> file:</p><div><pre class="programlisting">void insertPainterPath(const QPainterPath &amp;);</pre></div><p class="calibre9">The preceding code's definition in <code class="literal">canvas.cpp</code> is as follows:</p><div><pre class="programlisting">void Canvas::insertPainterPath(const QPainterPath &amp;ppath)
{
  QPainter painter(&amp;image);
  painter.drawPath(ppath);
  this-&gt;update();
}</pre></div><p class="calibre9">The preceding statements should be familiar to you and they're also self-explanatory. Now, build and run this application again; don't forget to change the current active project back to <code class="literal">painter_demo</code> by right-clicking on the <code class="literal">painter_demo</code> project and selecting <strong class="calibre10">Set "painter_demo" as Active Project</strong>. When it runs, click on <strong class="calibre10">Plugins</strong>, select <strong class="calibre10">Text</strong>, input <code class="literal">Plugin!!</code> in the pop-up dialog, and confirm. Then, you'll see the text, <strong class="calibre10">Plugin!!</strong>, painted on the canvas as expected.</p><div><img src="img/4615OS_05_06.jpg" alt="Writing static plugins" class="calibre18"/></div><p class="calibre9">The executable's size grows as well because we statically linked our <code class="literal">TextPlugin</code> project file to it. In <a id="id254" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>addition to this, you have to rebuild the main program if you changed the plugin. Otherwise, the newly generated plugin won't be linked to the executable as it should.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec38" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Writing dynamic plugins</h1></div></div></div><p class="calibre9">Static plugins <a id="id255" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>provide a convenient way to distribute your applications. However, this always requires a rebuild of the main program. By contrast, dynamic plugins are much more flexible since they're linked dynamically. This means the main project, which is <code class="literal">painter_demo</code> in this example, doesn't need to be built with dynamic plugins nor is it required to release its source code. Instead, it only needs to provide an interface and the header file of that interface, and then scan those dynamic plugins at runtime so that they can be loaded.</p><div><div><h3 class="title4"><a id="note19" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Dynamic plugins are commonly seen in complex applications, especially in commercial software such as Adobe Illustrator.</p></div></div><p class="calibre9">Similar to the static plugin we just wrote, we need to create a new Qt Plugin project and we'll call it <code class="literal">EllipsePlugin</code> this time. Although you can write a new interface along with this plugin, here we<a id="id256" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> will just focus on plugin-related topics. So, we just reuse the <code class="literal">InsertInterface</code> class while the <code class="literal">ellipseplugin.pro</code> project file is shown as follows:</p><div><pre class="programlisting">QT       += core gui widgets

TARGET = EllipsePlugin
TEMPLATE = lib
CONFIG += plugin

<strong class="calibre10">DESTDIR = ../plugins</strong>

SOURCES +=  ellipseplugin.cpp \
            ellipsedialog.cpp

HEADERS +=  ellipseplugin.h \
            ellipsedialog.h
OTHER_FILES += EllipsePlugin.json

<strong class="calibre10">INCLUDEPATH += ../</strong>

FORMS += ellipsedialog.ui</pre></div><p class="calibre9">Don't forget to change the <code class="literal">DESTDIR</code> and <code class="literal">INCLUDEPATH</code> variables in the <code class="literal">ellipseplugin.pro</code> file though, they're basically the same as the previous <code class="literal">TextPlugin</code> project.</p><p class="calibre9">Ignoring the source files, forms, and so on, it's basically the same thing with only the removal of <code class="literal">static</code> in <code class="literal">CONFIG</code>. The <code class="literal">ellipseplugin.h</code> header file is shown as follows:</p><div><pre class="programlisting">#ifndef ELLIPSEPLUGIN_H
#define ELLIPSEPLUGIN_H

#include "interface.h"


class EllipsePlugin : public QObject,
                      public InsertInterface
{
  Q_OBJECT
  Q_PLUGIN_METADATA(IID "org.qt-project.Qt.PainterDemo.InsertInterface" FILE "EllipsePlugin.json")
  Q_INTERFACES(InsertInterface)

  public:
    QString name() const;
    QPainterPath getObject(QWidget *parent);

  public slots:
    void onDialogAccepted(qreal x, qreal y, qreal wid, qreal hgt);

  private:
    qreal m_x;
    qreal m_y;
    qreal width;
    qreal height;
};

#endif // ELLIPSEPLUGIN_H</pre></div><p class="calibre9">As you can see in the preceding code, we declare that this is a plugin using <code class="literal">InsertInterface</code> as<a id="id257" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the same in <code class="literal">TextPlugin</code>, whereas the difference is the declaration of an <code class="literal">onDialogAccepted</code> slot function and several <code class="literal">private</code> variables. Accordingly, the <code class="literal">ellipseplugin.cpp</code> file is shown as follows:</p><div><pre class="programlisting">#include "ellipsedialog.h"
#include "ellipseplugin.h"


QString EllipsePlugin::name() const
{
  return QString("Ellipse");
}

QPainterPath EllipsePlugin::getObject(QWidget *parent)
{
  m_x = 0;
  m_y = 0;
  width = 0;
  height = 0;

  EllipseDialog *dlg = new EllipseDialog(parent);
  connect(dlg, &amp;EllipseDialog::accepted, this, &amp;EllipsePlugin::onDialogAccepted);
  dlg-&gt;exec();

  QPainterPath ppath;
  ppath.addEllipse(m_x, m_y, width, height);
  return ppath;
}

void EllipsePlugin::onDialogAccepted(qreal x, qreal y, qreal wid, qreal hgt)
{
  m_x = x;
  m_y = y;
  width = wid;
  height = hgt;
}</pre></div><p class="calibre9">There is nothing special about the <code class="literal">name()</code> function. By contrast, we use the <code class="literal">EllipseDialog</code> custom dialog to get some inputs from the user. Remember to connect all the signals and slots associated with the dialog before executing the <code class="literal">exec()</code> function; otherwise, the slots<a id="id258" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> simply won't be connected. Also, note that the <code class="literal">exec()</code> function <a id="id259" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>will block the event loop and return only after the dialog closes, which is pretty handy for our purposes because we can use the accepted values, such as <code class="literal">m_x</code> and <code class="literal">m_y</code>, to add an ellipse to <code class="literal">QPainterPath</code>.</p><p class="calibre9">As for the <code class="literal">EllipseDialog</code> custom dialog itself, it was created by adding a new Qt Designer Form Class via Qt Creator. Since it's used to provide an interface for the user to specify some parameters, we use <strong class="calibre10">Form Layout</strong> in this dialog. Add <code class="literal">QLabel</code> and <code class="literal">QDoubleSpinBox</code>, as suggested in the following screenshot:</p><div><img src="img/4615OS_05_07.jpg" alt="Writing dynamic plugins" class="calibre57"/></div><p class="calibre9">Accordingly, their <code class="literal">objectName</code> values are <code class="literal">tlXLabel</code>, <code class="literal">tlXDoubleSpinBox</code>, <code class="literal">tlYLabel</code>, <code class="literal">tlYDoubleSpinBox</code>, <code class="literal">widthLabel</code>, <code class="literal">widthDoubleSpinBox</code>, <code class="literal">heightLabel</code>, and <code class="literal">heightDoubleSpinBox</code>. You should also change the <code class="literal">maximum</code> value to <code class="literal">9999.99</code> or something big enough in the <strong class="calibre10">Property</strong> panel of <code class="literal">QDoubleSpinBox</code>.</p><p class="calibre9">In addition to this, also note that there is a removal of the default signal and slot in <strong class="calibre10">Signals &amp; Slots Editor</strong>. Simply delete the <code class="literal">accepted()</code> signal pair of <code class="literal">buttonBox</code> because we need a more <a id="id260" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>advanced handler. In this form class header file, <code class="literal">ellipsedialog.h</code>, we declare a new signal and a new slot:</p><div><pre class="programlisting">#ifndef ELLIPSEDIALOG_H
#define ELLIPSEDIALOG_H

#include &lt;QDialog&gt;

namespace Ui {
  class EllipseDialog;
}

class EllipseDialog : public QDialog
{
  Q_OBJECT

  public:
    explicit EllipseDialog(QWidget *parent = 0);
    ~EllipseDialog();

  signals:
    void accepted(qreal, qreal, qreal, qreal);

  private:
    Ui::EllipseDialog *ui;

  private slots:
    void onAccepted();
};

#endif // ELLIPSEDIALOG_H</pre></div><p class="calibre9">The <code class="literal">accepted(qreal, qreal, qreal, qreal)</code> signal here passes these values back to the plugin, while the <code class="literal">onAccepted()</code> slot handles the <code class="literal">accepted()</code> signal emitted from <code class="literal">buttonBox</code>. They are defined in the <code class="literal">ellipsedialog.cpp</code> source file, as shown in the following code:</p><div><pre class="programlisting">#include "ellipsedialog.h"
#include "ui_ellipsedialog.h"

EllipseDialog::EllipseDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::EllipseDialog)
{
  ui-&gt;setupUi(this);

  connect(ui-&gt;buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;EllipseDialog::onAccepted);
}

EllipseDialog::~EllipseDialog()
{
  delete ui;
}

void EllipseDialog::onAccepted()
{
  emit accepted(ui-&gt;tlXDoubleSpinBox-&gt;value(), ui-&gt;tlYDoubleSpinBox-&gt;value(), ui-&gt;widthDoubleSpinBox-&gt;value(), ui-&gt;heightDoubleSpinBox-&gt;value());
  this-&gt;accept();
}</pre></div><p class="calibre9">Inside the constructor, connect the <code class="literal">accepted()</code> signal of <code class="literal">buttonBox</code> to the <code class="literal">onAccepted()</code> advanced<a id="id261" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> handler slot. In this slot, we emit the <code class="literal">accepted</code> signal, which contains the values that the user has entered. Then, call the <code class="literal">accept()</code> function to close this dialog.</p><p class="calibre9">
<code class="literal">EllipsePlugin</code> is finished at this point. Click on the <strong class="calibre10">Build</strong> button in the panel to build this project. You should expect the output, <code class="literal">EllipsePlugin.dll</code> on Windows, to be located in the same <code class="literal">plugins</code> directory as the previous <code class="literal">TextPlugin</code> project.</p><p class="calibre9">To make use of this dynamic plugin, we need a final step, which is to make the main program load the dynamic plugin(s). What we have to change here is the <code class="literal">loadPlugins()</code> function in <code class="literal">mainwindow.cpp</code>:</p><div><pre class="programlisting">void MainWindow::loadPlugins()
{
  foreach(QObject *plugin, QPluginLoader::staticInstances()) {
    generatePluginMenu(plugin);
  }

  //search and load dynamic plugins
  QDir pluginDir = QDir(qApp-&gt;applicationDirPath());
  #ifdef Q_OS_WIN
  QString dirName = pluginDir.dirName();
  if (dirName.compare(QString("debug"), Qt::CaseInsensitive) == 0 || dirName.compare(QString("release"), Qt::CaseInsensitive) == 0) {
    pluginDir.cdUp();
    pluginDir.cdUp();
  }
  #endif
  pluginDir.cd(QString("plugins"));

  foreach (QString fileName, pluginDir.entryList(QDir::Files)) {
    QPluginLoader loader(pluginDir.absoluteFilePath(fileName));
    QObject *plugin = loader.instance();
    if (plugin) {
      generatePluginMenu(plugin);
    }
  }
}</pre></div><p class="calibre9">In order to use the <code class="literal">QDir</code> class, you may also need to include this:</p><div><pre class="programlisting">#include &lt;QDir&gt;</pre></div><p class="calibre9">The <code class="literal">QDir</code> class will provide<a id="id262" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> access to directory structures and their contents, which we use to locate our <a id="id263" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dynamic plugins. The <code class="literal">qApp</code> macro is a global pointer, referring to this very application instance. It's equivalent to the <code class="literal">QCoreApplication::instance()</code> function and <code class="literal">QApplication::instance()</code> for non-GUI and GUI applications, respectively. On Windows platforms, our <code class="literal">plugins</code> directory is located in the second upper folder of the <code class="literal">build</code> path.</p><p class="calibre9">Then, we just test each file in the <code class="literal">plugins</code> directory, load it, and generate a proper menu entry if it's a loadable plugin. Run this application again; you'll have an <strong class="calibre10">Ellipse</strong> entry inside the <strong class="calibre10">Plugins</strong> menu. It works as expected.</p><div><img src="img/4615OS_05_08.jpg" alt="Writing dynamic plugins" class="calibre58"/></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec39" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Merging plugins and main program projects</h1></div></div></div><p class="calibre9">It is a tedious thing that opens several projects and builds them in order. This is not a big deal given that we<a id="id264" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> have just two plugins and a main program. However, it'll become a serious inefficiency issue once the number of plugins increase. Therefore, it is a better practice to merge the plugins into the main project and get them built in a specified order every time we click on the <strong class="calibre10">Build</strong> button. It's totally feasible<a id="id265" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and is commonly seen in Qt projects.</p><p class="calibre9">Firstly, we move all the files in the <code class="literal">painter_demo</code> directory, except for the <code class="literal">EllipsePlugin</code> and <code class="literal">TextPlugin</code> folders, into a newly created <code class="literal">main</code> folder.</p><p class="calibre9">Then, rename the <code class="literal">painter_demo.pro</code> to <code class="literal">main.pro</code> in the <code class="literal">main</code> folder while creating a new <code class="literal">painter_demo.pro</code> project file outside in the <code class="literal">painter_demo</code> directory. This new <code class="literal">painter_demo.pro</code> project file needs to have contents as shown in the following code:</p><div><pre class="programlisting">TEMPLATE  = subdirs
CONFIG   += ordered
SUBDIRS   = TextPlugin \
            EllipsePlugin \
            main</pre></div><p class="calibre9">The <code class="literal">subdirs</code> project is a special template, which means that this project file won't generate an application or a library. Instead, it tells <code class="literal">qmake</code> to build subdirectories. By adding <code class="literal">ordered</code> to<a id="id266" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">CONFIG</code>, we can ensure that the compiling process follows the exact order according to <code class="literal">SUBDIRS</code>.</p><p class="calibre9">To accomplish this, we need to modify the project files in the two plugins directories. Change the <code class="literal">INCLUDEPATH</code> variable to the following line:</p><div><pre class="programlisting">INCLUDEPATH += ../main</pre></div><p class="calibre9">This change<a id="id267" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is obvious because we moved all the source code into the <code class="literal">main</code> directory. If we don't change <code class="literal">INCLUDEPATH</code>, the compiler will complain that it can't find the <code class="literal">interface.h</code> header file.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec40" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Creating a C++ plugin for QML applications</h1></div></div></div><p class="calibre9">It's not too difficult to write a plugin for Qt/C++ applications, whereas it's somewhat more complex to create <a id="id268" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a plugin for the QML applications. The idea<a id="id269" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is the same, and here we will use a very basic example to demonstrate this topic. Basically, this application will encode the text input as <code class="literal">Base64</code> and display it. The <code class="literal">Base64</code> encoding part is implemented in the C++ plugin.</p><p class="calibre9">This time, we're going to create the plugin project first, and then complete the QML part. Creating a plugin project for a QML application shares the same procedure. Navigate to <strong class="calibre10">Libraries</strong> | <strong class="calibre10">C++ Library</strong>, and then select <strong class="calibre10">Qt Plugin</strong> with the name as <code class="literal">Base64Plugin</code>. Its project file, <code class="literal">Base64Plugin.pro</code>, is pasted here:</p><div><pre class="programlisting">QT       += core qml

TARGET = qmlbase64Plugin
TEMPLATE = lib
CONFIG += plugin

DESTDIR = ../imports/Base64

SOURCES += base64.cpp \
           base64plugin.cpp

HEADERS += base64.h \
           base64plugin.h

OTHER_FILES += \
           qmldir</pre></div><p class="calibre9">We set <code class="literal">DESTDIR</code> to <code class="literal">../imports/Base64</code> for the sake of convenience. You can change this to some other path, but you may need to make some relevant changes later to be able to import this plugin.</p><p class="calibre9">This project <a id="id270" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>consists of two C++ classes. The<a id="id271" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">Base64</code> class will later be <a id="id272" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>exported to QML, whereas <code class="literal">Base64Plugin</code> registers the <code class="literal">Base64</code> class. The former class' <code class="literal">base64.h</code> header file is as follows:</p><div><pre class="programlisting">#ifndef BASE64_H
#define BASE64_H

#include &lt;QObject&gt;

class Base64 : public QObject
{
  Q_OBJECT

  public:
    explicit Base64(QObject *parent = 0);

  public slots:
    QString get(QString);
};

#endif // BASE64_H</pre></div><p class="calibre9">The <code class="literal">base.cpp</code> counterpart defines the <code class="literal">get</code> function, as shown in the following code:</p><div><pre class="programlisting">#include "base64.h"

Base64::Base64(QObject *parent) :
  QObject(parent)
{
}

QString Base64::get(QString in)
{
  return QString::fromLocal8Bit(in.toLocal8Bit().toBase64());
}</pre></div><p class="calibre9">The tricky part is in the <code class="literal">Base64Plugin</code> class, which is not identical to the previous plugin class. Its <code class="literal">base64plugin.h</code> header file is shown here:</p><div><pre class="programlisting">#ifndef BASE64PLUGIN_H
#define BASE64PLUGIN_H

#include &lt;QQmlExtensionPlugin&gt;


class Base64Plugin : public QQmlExtensionPlugin
{
  Q_OBJECT
  Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QmlExtensionInterface")

  public:
    void registerTypes(const char *uri);
};

#endif // BASE64PLUGIN_H</pre></div><p class="calibre9">With the <code class="literal">QQmlExtensionPlugin</code> subclass, we're able to write our own QML plugin. In fact, this class is<a id="id273" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> used to declare the <code class="literal">Base64</code> class for QML. Also note that since <code class="literal">IID</code> in <code class="literal">Q_PLUGIN_METADATA</code> is fixed, you probably don't want to change it. As a subclass, it has to reimplement the <code class="literal">registerTypes</code> function, which simply registers the class(es). The detailed <a id="id274" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>definition is located in the <code class="literal">baseplugin.cpp</code> file whose contents are as shown in the following code:</p><div><pre class="programlisting">#include &lt;QtQml&gt;
#include "base64plugin.h"
#include "base64.h"

void Base64Plugin::registerTypes(const char *uri)
{
  Q_ASSERT(uri == QLatin1String("Base64"));
  qmlRegisterType&lt;Base64&gt;(uri, 1, 0, "Base64");
}</pre></div><p class="calibre9">The <code class="literal">Q_ASSERT</code> macro will ensure that the plugin is located inside the <code class="literal">Base64</code> directory. If not, it'll print a warning message containing the source code, filename, and line number. Note that <code class="literal">uri</code>, which is expected to be <code class="literal">Base64</code> in this case, is the module name for QML. Below this line, <code class="literal">qmlRegisterType</code> is a template function where you need to put the class name, <code class="literal">Base64</code>, inside brackets. These arguments will register the class with <code class="literal">Base64</code> as the QML name with Version 1.0.</p><p class="calibre9">A last piece is needed to declare a loadable plugin, which is the <code class="literal">qmldir</code> file. Note that it has no extension name. This file defines the module name and relevant files in the directory. Here is the content:</p><div><pre class="programlisting">module Base64
plugin qmlbase64Plugin</pre></div><p class="calibre9">We need to put this file in the <code class="literal">../imports/Base64</code> directory, which is the <code class="literal">DESTDIR</code> of <code class="literal">Base64Plugin</code>. Along with a few lines in the QML application project's <code class="literal">main.cpp</code> file, QML can then import a plugin as it imports any other Qt Quick modules.</p><p class="calibre9">It's time to create a new Qt Quick application project now. The project name is simply <code class="literal">QML_Plugin</code> and <a id="id275" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>we move the <code class="literal">Base64Plugin</code> class into the <code class="literal">QML_Plugin</code> directory, which enables the Qt Creator syntax to <a id="id276" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>highlight the <code class="literal">Base64Plugin</code> class. Here is the content of <code class="literal">main.qml</code>:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2
import Base64 1.0

ApplicationWindow {
  visible: true
  width: 180
  height: 100
  title: qsTr("QML Plugin")

  Base64 {
    id: b64
  }

  Column {
    spacing: 6
    anchors {left: parent.left; right: parent.right; top: parent.top; bottom: parent.bottom; leftMargin: 6; rightMargin: 6; topMargin: 6; bottomMargin: 6}
    Label {
      text: "Input"
    }
    TextField {
      id: input
      width: parent.width
      placeholderText: "Input string here"
      onEditingFinished: bt.text = b64.get(text)
    }
    Label {
      text: "Base64 Encoded"
    }
    TextField {
      id: bt
      readOnly: true
      width: parent.width
    }
  }
}</pre></div><p class="calibre9">Remember to state <code class="literal">import Base64 1.0</code> at the very beginning of the code so that our plugin can be loaded. Then, <code class="literal">Base64</code> is just like other QML types we have used before. In the <code class="literal">onEditingFinished</code> handler of <code class="literal">input TextField</code>, we use the <a id="id277" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">get</code> function, which is in the <code class="literal">Base64</code> class, to set <code class="literal">bt.text</code> to the corresponding <code class="literal">Base64</code> class-encoded string.</p><p class="calibre9">You may wonder how a QML <code class="literal">string</code> type is converted to a <code class="literal">QString</code> object. Well, it's implicitly<a id="id278" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> converted between QML and Qt/C++. There are plenty of these conversions for commonly-seen QML data types and Qt data classes. For details, you can look at the Qt documentation to see the full list.</p><p class="calibre9">Another thing is that <a id="id279" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>we need to change <code class="literal">main.cpp</code>, as mentioned before. Similar to the Qt/C++ case, we use the <code class="literal">QDir</code> class to get an application directory and change it to <code class="literal">../imports</code>. Be aware that you should use <code class="literal">addImportPath</code> instead of <code class="literal">addPluginPath</code> to add <code class="literal">../imports</code> to the QML engine's module search path. This is because we use <code class="literal">Base64</code> as a module, which should be located in the <code class="literal">imports</code> path. Meanwhile, the plugin path is for native plugins of imported modules, which are stated in <code class="literal">qmldir</code>. The content of the <code class="literal">main.cpp</code> file is as follows:</p><div><pre class="programlisting">#include &lt;QApplication&gt;
#include &lt;QDir&gt;
#include &lt;QQmlApplicationEngine&gt;

int main(int argc, char *argv[])
{
  QApplication app(argc, argv);

  QQmlApplicationEngine engine;
  QDir pluginDir = app.applicationDirPath();
  pluginDir.cdUp();
  pluginDir.cdUp();
  pluginDir.cd("imports");
  engine.addImportPath(pluginDir.absolutePath());
  engine.load(QUrl(QStringLiteral("qrc:/main.qml")));

  return app.exec();
}</pre></div><p class="calibre9">In order to run this application, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Build <code class="literal">Base64Plugin</code>.</li><li class="listitem1">Copy the <code class="literal">qmldir</code> file into the <code class="literal">../imports/Base64</code> directory (the <code class="literal">imports</code> folder should be located in the same place as <code class="literal">plugins</code>).</li><li class="listitem1">Build and run the <code class="literal">QML_Plugin</code> project.</li></ol></div><p class="calibre9">You can test this application by inputting any string in the first input field and just pressing <em class="calibre14">Enter</em>. One <a id="id280" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>scenario for this application is to encode your e-mail address to avoid a web spider, as shown here:</p><div><img src="img/4615OS_05_09.jpg" alt="Creating a C++ plugin for QML applications" class="calibre59"/></div><p class="calibre9">If the module <a id="id281" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>isn't well located, the application won't show up and it'll complain that <code class="literal">Base64</code> is not installed. If that happens, make sure you add the correct path in <code class="literal">main.cpp</code> and there is a <code class="literal">qmldir</code> file inside the <code class="literal">Base64</code> folder.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch05lvl1sec41" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">It is somewhat difficult to get started on writing plugins. However, after some basic practice, you'll find that it's actually easier than it looks. For Qt Widgets applications, plugins simply extend the application in a flexible way. Meanwhile, they enable developers to devise new forms for QML applications. We also covered using the <code class="literal">subdirs</code> project to manage multiple subprojects. Even if you don't plan to write plugins, this chapter covered painting-related stuff that is crucial for GUI application development, including <code class="literal">QPainter</code>, <code class="literal">paintEvent</code>, and <code class="literal">resizeEvent</code>.</p><p class="calibre9">In the next chapter, we're going to talk about network programming and multithreading in Qt.</p></div></div>



  </body></html>