- en: Chapter 7. Optimizing the Machine Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 优化机器代码
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Eliminating common subexpressions from machine code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从机器代码中消除公共子表达式
- en: Analyzing live intervals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析活跃区间
- en: Allocating registers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器分配
- en: Inserting the prologue-epilogue code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入前导和后继代码
- en: Code emission
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码发射
- en: Tail call optimization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Sibling call optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兄弟调用优化
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The machine code generated so far is yet to be assigned real target architecture
    registers. The registers seen so far have been virtual registers, which are infinite
    in number. The machine code generated is in the SSA form. However, the target
    registers are limited in number. Hence, register allocation algorithms require
    a lot of heuristic calculations to allocate registers in an optimal way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止生成的机器代码尚未分配到真实的目标架构寄存器。到目前为止看到的寄存器都是虚拟寄存器，数量无限。生成的机器代码处于 SSA 形式。然而，目标寄存器的数量是有限的。因此，寄存器分配算法需要大量的启发式计算来以最优方式分配寄存器。
- en: But, before register allocation, there exists opportunities for code optimization.
    The machine code being in the SSA form also makes it easy to apply optimizing
    algorithms. The algorithms for some optimizing techniques, such as machine dead
    code elimination and machine common subexpression elimination, are almost the
    same as in the LLVM IR. The difference lies in the constraints to be checked.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在寄存器分配之前，存在代码优化的机会。机器代码处于 SSA（Static Single Assignment）形式，也使得应用优化算法变得容易。一些优化技术（如机器死代码消除和机器公共子表达式消除）的算法几乎与
    LLVM IR 中的相同。区别在于需要检查的约束条件。
- en: Here, one of the machine code optimization techniques implemented in the LLVM
    trunk code repository—machine CSE— will be discussed so that you can understand
    how algorithms are implemented for machine code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论在 LLVM 主干代码库中实现的一种机器代码优化技术——机器 CSE（Common Subexpression Elimination），以便您了解机器代码的算法是如何实现的。
- en: Eliminating common subexpression from machine code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从机器代码中消除公共子表达式
- en: The aim of the CSE algorithm is to eliminate common subexpressions to make machine
    code compact and remove unnecessary, duplicate code. Let's look at the code in
    the LLVM trunk to understand how it is implemented. The detailed code is in the
    `lib/CodeGen/MachineCSE.cpp` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSE 算法的目的是消除公共子表达式，使机器代码紧凑，并移除不必要的、重复的代码。让我们看看 LLVM 主干中的代码，以了解它是如何实现的。详细代码位于
    `lib/CodeGen/MachineCSE.cpp` 文件中。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'The `MachineCSE` class runs on a machine function, and hence it should inherit
    the `MachineFunctionPass` class. It has various members, such as `TargetInstructionInfo`,
    which is used to get information about the target instruction (used in performing
    CSE); `TargetRegisterInfo`, which is used to get information about the target
    register (whether it belongs to a reserved register class, or to more such similar
    classes; and `MachineDominatorTree`, which is used to get information about the
    dominator tree for the machine block:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MachineCSE` 类在机器函数上运行，因此它应该继承 `MachineFunctionPass` 类。它有各种成员，例如 `TargetInstructionInfo`，用于获取目标指令的信息（用于执行
    CSE）；`TargetRegisterInfo`，用于获取目标寄存器的信息（是否属于保留的寄存器类，或更多此类类似类；以及 `MachineDominatorTree`，用于获取机器块的支配树信息：'
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The constructor for this class is defined as follows, which initializes the
    pass:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类的构造函数定义如下，它初始化了遍历：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `getAnalysisUsage()` function determines which passes will run before this
    pass to get statistics that can be used in this pass:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAnalysisUsage()` 函数确定在当前遍历之前将运行哪些遍历，以获取可用于当前遍历的统计数据：'
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare some helper functions in this pass to check for simple copy propagation
    and trivially dead definitions, check for the liveness of physical registers and
    their definition uses, and so on:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此遍历中声明一些辅助函数以检查简单的复制传播和明显无用的定义，检查物理寄存器的活跃性和它们的定义使用，等等：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Some more helper functions help to determine the legality and profitability
    of the expression being a CSE candidate:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些辅助函数有助于确定表达式作为 CSE 候选者的合法性和盈利性：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s look at the actual implementation of a CSE function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CSE 函数的实际实现：
- en: 'The `runOnMachineFunction()` function is called first as the pass runs:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runOnMachineFunction()` 函数首先被调用，因为该遍历运行：'
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `PerformCSE()` function is called next. It takes the root node of the `DomTree`,
    performs a DFS walk on the `DomTree` (starting from the root node), and populates
    a work list consisting of the nodes of the `DomTree`. After the DFS traverses
    through the `DomTree`, it processes the `MachineBasicBlock` class corresponding
    to each node in the work list:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用 `PerformCSE()` 函数。它接受 `DomTree` 的根节点，在 `DomTree` 上执行 DFS 遍历（从根节点开始），并填充一个包含
    `DomTree` 节点的作业列表。在 DFS 遍历 `DomTree` 之后，它处理作业列表中每个节点对应的 `MachineBasicBlock` 类：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next important function is the `ProcessBlock()` function, which acts on
    the machine basic block. The instructions in the `MachineBasicBlock` class are
    iterated and checked for legality and profitability if they can be a CSE candidate:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个重要的函数是 `ProcessBlock()` 函数，它作用于机器基本块。`MachineBasicBlock` 类中的指令被迭代并检查其合法性及盈利性，如果它们可以成为
    CSE 候选者：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s also look into the legality and profitability functions to determine
    the CSE candidates:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也来看看合法性和盈利函数，以确定 CSE 候选者：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The profitability function is written as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 盈利函数编写如下：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `MachineCSE` pass runs on a machine function. It gets the `DomTree` information
    and then traverses the `DomTree` in the DFS way, creating a work list of nodes
    that are essentially `MachineBasicBlocks`. It then processes each block for CSE.
    In each block, it iterates through all the instructions and checks whether any
    instruction is a candidate for CSE. Then it checks whether it is profitable to
    eliminate the identified expression. Once it has found that the identified CSE
    is profitable to eliminate, it eliminates the `MachineInstruction` class from
    the `MachineBasicBlock` class. It also performs a simple copy propagation of the
    machine instruction. In some cases, the `MachineInstruction` may not be a candidate
    for CSE in its initial run, but may become one after copy propagation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineCSE` 传递在机器函数上运行。它获取 `DomTree` 信息，然后以 DFS 方式遍历 `DomTree`，创建一个由基本 `MachineBasicBlocks`
    构成的节点作业列表。然后它对每个块进行 CSE 处理。在每个块中，它迭代所有指令并检查是否有任何指令是 CSE 候选者。然后它检查消除已识别表达式是否具有盈利性。一旦它发现已识别的
    CSE 消除具有盈利性，它就从 `MachineBasicBlock` 类中消除 `MachineInstruction` 类。它还执行机器指令的简单复制传播。在某些情况下，`MachineInstruction`
    在初始运行时可能不是 CSE 的候选者，但在复制传播后可能成为候选者。'
- en: See more
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看更多
- en: To see more machine code optimization in the SSA form, look into the implementation
    of the machine dead code elimination pass in the `lib/CodeGen/DeadMachineInstructionElim.cpp
    file`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多以 SSA 形式呈现的机器代码优化，请查看 `lib/CodeGen/DeadMachineInstructionElim.cpp` 文件中机器死代码消除传递的实现。
- en: Analyzing live intervals
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析活跃区间
- en: Further on in this chapter, we will be looking into register allocation. Before
    we head to that, however, you must understand the concepts of **live variable**
    and **live interval**. By live intervals, we mean the range in which a variable
    is live, that is, from the point where a variable is defined to its last use.
    For this, we need to calculate the set of registers that are immediately dead
    after the instruction (the last use of a variable), and the set of registers that
    are used by the instruction but not after the instruction. We calculate live variable
    information for each virtual register and physical register in the function. Using
    SSA to sparsely compute the lifetime information for the virtual registers enables
    us to only track the physical registers within a block. Before register allocation,
    LLVM assumes that physical registers are live only within a single basic block.
    This enables it to perform a single, local analysis to resolve physical register
    lifetimes within each basic block. After performing the live variable analysis,
    we have the information required for performing live interval analysis and building
    live intervals. For this, we start numbering the basic block and machine instructions.
    After that live-in values, typically arguments in registers are handled. Live
    intervals for virtual registers are computed for some ordering of the machine
    instructions (*1*, *N*). A live interval is an interval (*i*, *j*) for which a
    variable is live, where *1 >= i >= j > N*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续内容中，我们将探讨寄存器分配。然而，在我们前往那里之前，你必须理解**活动变量**和**活动区间**的概念。通过活动区间，我们指的是变量活跃的范围，即从变量定义点到其最后使用点。为此，我们需要计算指令（变量的最后使用）之后立即失效的寄存器集合，以及指令使用但不在指令之后使用的寄存器集合。我们为函数中的每个虚拟寄存器和物理寄存器计算活动变量信息。使用SSA（Static
    Single Assignment）来稀疏计算虚拟寄存器的生命周期信息，使我们能够仅跟踪块内的物理寄存器。在寄存器分配之前，LLVM假设物理寄存器仅在单个基本块内活跃。这使得它能够执行单个、局部的分析，以在每个基本块内解决物理寄存器的生命周期。在执行活动变量分析后，我们拥有了执行活动区间分析和构建活动区间的所需信息。为此，我们开始对基本块和机器指令进行编号。之后，处理live-in值，通常是寄存器中的参数。对于虚拟寄存器的活动区间，我们将根据机器指令的某种顺序（*1*，*N*）进行计算。活动区间是一个区间（*i*，*j*），其中变量是活跃的，其中*1
    >= i >= j > N*。
- en: In this recipe, we will take a sample program and see how we can list down the
    live intervals for that program. We will look at how LLVM works to calculate these
    intervals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将取一个示例程序，看看我们如何列出该程序的活动区间。我们将查看LLVM是如何计算这些区间的。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, we need a piece of test code on which we will be performing
    live interval analysis. For simplicity, we will use C code and then convert it
    into LLVM IR:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一段用于执行活动区间分析的测试代码。为了简单起见，我们将使用C代码并将其转换为LLVM IR：
- en: 'Write a test program with an `if` - `else` block:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个包含`if` - `else`块的测试程序：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use Clang to convert the C code into IR, and then view the generated IR using
    the `cat` command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Clang将C代码转换为IR，然后使用`cat`命令查看生成的IR：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To list the live intervals, we will need to modify the code of the `LiveIntervalAnalysis.cpp`
    file by adding code to print the live intervals. We will add the following lines
    (marked with a `+` symbol before each added line):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出活动区间，我们需要修改`LiveIntervalAnalysis.cpp`文件的代码，添加打印活动区间的代码。我们将添加以下行（每行前带有`+`符号）：
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build LLVM after modifying the preceding source file, and install it on the
    path.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修改前面的源文件后构建LLVM，并将其安装到路径上。
- en: 'Now compile the test code in the IR form using the `llc` command. You will
    get the live intervals:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用`llc`命令编译测试代码的IR形式。你将得到活动区间：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the preceding example, we saw how live intervals are associated with each
    virtual register. The program points at the beginning and the end of live intervals
    are marked in square brackets. The process of generating these live intervals
    starts from the `LiveVariables::runOnMachineFunction(MachineFunction` `&mf)` function
    in the `lib/CodeGen/LiveVariables.cpp file`, where it assigns the definition and
    usage of the registers using the `HandleVirtRegUse` and `HandleVirtRegDef` functions.
    It gets the `VarInfo` object for the given virtual register using the `getVarInfo`
    function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了活区间与每个虚拟寄存器相关联的方式。程序中的活区间的开始和结束位置用方括号标记。生成这些活区间的过程从 `lib/CodeGen/LiveVariables.cpp`
    文件中的 `LiveVariables::runOnMachineFunction(MachineFunction &mf)` 函数开始，它使用 `HandleVirtRegUse`
    和 `HandleVirtRegDef` 函数分配寄存器的定义和使用。它使用 `getVarInfo` 函数获取给定虚拟寄存器的 `VarInfo` 对象。
- en: The `LiveInterval` and `LiveRange` classes are defined in `LiveInterval.cpp`.
    The functions in this file takes the information on the liveliness of each variable
    and then checks whether they overlap or not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveInterval` 和 `LiveRange` 类在 `LiveInterval.cpp` 中定义。该文件中的函数接收每个变量的活跃信息，然后检查它们是否重叠。'
- en: In the `LiveIntervalAnalysis.cpp` file, we have the implementation of the live
    interval analysis pass, which scans the basic blocks (ordered in a linear fashion)
    in depth-first order, and creates a live interval for each virtual and physical
    register. This analysis is used by the register allocators, which will be discussed
    in next recipe.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LiveIntervalAnalysis.cpp` 文件中，我们有活区间分析传递的实现，它以深度优先的方式遍历基本块（按线性顺序排列），并为每个虚拟和物理寄存器创建一个活区间。这种分析被寄存器分配器使用，将在下一食谱中讨论。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you want to see in detail how the virtual registers for different basic blocks
    get generated, and see the lifetime of these virtual registers, use the `–debug-only=regalloc`
    command-line option with the `llc` tool when compiling the test case. You need
    a debug build of the LLVM for this.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想详细了解不同基本块的虚拟寄存器是如何生成的，以及这些虚拟寄存器的生命周期，请在编译测试用例时使用 `llc` 工具的 `–debug-only=regalloc`
    命令行选项。您需要一个调试版本的 LLVM 才能这样做。
- en: 'To get more detail on live intervals, go through these code files:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取关于实时区间的更多详细信息，请查看以下代码文件：
- en: '`Lib/CodeGen/ LiveInterval.cpp`'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lib/CodeGen/ LiveInterval.cpp`'
- en: '`Lib/CodeGen/ LiveIntervalAnalysis.cpp`'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lib/CodeGen/ LiveIntervalAnalysis.cpp`'
- en: '`Lib/CodeGen/ LiveVariables.cpp`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lib/CodeGen/ LiveVariables.cpp`'
- en: Allocating registers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配寄存器
- en: Register allocation is the task of assigning physical registers to virtual registers.
    Virtual registers can be infinite, but the physical registers for a machine are
    limited. So, register allocation is aimed at maximizing the number of physical
    registers getting assigned to virtual registers. In this recipe, we will see how
    registers are represented in LLVM, how can we tinker with the register information,
    the steps taking place, and built-in register allocators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器分配是将物理寄存器分配给虚拟寄存器的任务。虚拟寄存器可以是无限的，但机器的物理寄存器是有限的。因此，寄存器分配的目标是最大化分配给虚拟寄存器的物理寄存器数量。在本食谱中，我们将了解寄存器在
    LLVM 中的表示方式，如何修改寄存器信息，执行步骤，以及内置的寄存器分配器。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to build and install LLVM.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要构建和安装 LLVM。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To see how registers are represented in LLVM, open the `build-folder/lib/Target/X86/X86GenRegisterInfo.inc`
    file and check out the first few lines, which show that registers are represented
    as integers:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看寄存器在 LLVM 中的表示方式，请打开 `build-folder/lib/Target/X86/X86GenRegisterInfo.inc`
    文件并查看前几行，这些行显示寄存器以整数的形式表示：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For architectures that have registers that share the same physical location,
    check out the `RegisterInfo.td` file of that architecture for alias information.
    Let''s check out the `lib/Target/X86/X86RegisterInfo.td` file. By looking at the
    following code snippet, we see how the `EAX`, `AX`, and `AL` registers are aliased
    (we only specify the smallest register alias):'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有共享相同物理位置的寄存器的架构，请查看该架构的 `RegisterInfo.td` 文件以获取别名信息。让我们查看 `lib/Target/X86/X86RegisterInfo.td`
    文件。通过查看以下代码片段，我们可以看到 `EAX`、`AX` 和 `AL` 寄存器是如何别名的（我们只指定最小的寄存器别名）：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To change the number of physical registers available, go to the `TargetRegisterInfo.td`
    file and manually comment out some of the registers, which are the last parameters
    of the `RegisterClass`. Open the `X86RegisterInfo.cpp` file and remove the registers
    `AH`, `CH`, and `DH`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改可用的物理寄存器数量，请转到`TargetRegisterInfo.td`文件，并手动注释掉一些寄存器，这些寄存器是`RegisterClass`的最后一个参数。打开`X86RegisterInfo.cpp`文件并删除寄存器`AH`、`CH`和`DH`：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you build LLVM, the `.inc` file in the first step will have been changed
    and will not contain the `AH`, `CH`, and DH registers.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您构建LLVM时，第一步中的`.inc`文件将已更改，并且不会包含`AH`、`CH`和`DH`寄存器。
- en: 'Use the test case from the previous recipe, *Analyzing live intervals*, in
    which we performed live interval analysis, and run the register allocation techniques
    provided by LLVM, namely `fast`, `basic`, `greedy`, and `pbqp`. Let''s run two
    of them here and compare the results:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前配方中的测试用例，*分析活动区间*，其中我们执行了活动区间分析，并运行LLVM提供的寄存器分配技术，即`fast`、`basic`、`greedy`和`pbqp`。让我们运行其中两个并比较结果：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, create the `intervalregbasic.s` file as shown:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，创建`intervalregbasic.s`文件，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, run the following command to compare the two files:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以比较两个文件：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `intervalregbqp.s` file:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建`intervalregbqp.s`文件：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, use a `diff` tool and compare the two assemblies side by side.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`diff`工具并逐行比较两个汇编代码。
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The mapping of virtual registers on physical registers can be done in two ways:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟寄存器到物理寄存器的映射可以有两种方式：
- en: '**Direct Mapping**: By making use of the `TargetRegisterInfo` and `MachineOperand`
    classes. This depends on the developer, who needs to provide the location where
    load and store instructions should be inserted in order to get and store values
    in the memory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接映射**：通过使用`TargetRegisterInfo`和`MachineOperand`类。这取决于开发者，开发者需要提供加载和存储指令应插入的位置，以便在内存中获取和存储值。'
- en: '**Indirect Mapping**: This depends on the `VirtRegMap` class to insert loads
    and stores, and to get and set values from the memory. Use the `VirtRegMap::assignVirt2Phys(vreg,
    preg)` function to map a virtual register on a physical one.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间接映射**：这依赖于`VirtRegMap`类来插入加载和存储操作，以及从内存中获取和设置值。使用`VirtRegMap::assignVirt2Phys(vreg,
    preg)`函数将虚拟寄存器映射到物理寄存器上。'
- en: Another important role that the register allocator plays is in SSA form deconstruction.
    As traditional instruction sets do not support the `phi` instruction, we must
    replace it with other instructions to generate the machine code. The traditional
    way was to replace the `phi` instruction with the `copy` instruction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器分配器扮演的另一个重要角色是在SSA形式解构中。由于传统的指令集不支持`phi`指令，我们必须用其他指令替换它以生成机器代码。传统的方法是将`phi`指令替换为`copy`指令。
- en: After this stage, we do the actual mapping on the physical registers. We have
    four implementations of register allocation in LLVM, which have their algorithms
    for mapping the virtual registers on the physical registers. It is not possible
    to cover in detail any of those algorithms here. If you want to try and understand
    them, refer to the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段之后，我们进行实际的物理寄存器映射。LLVM中有四种寄存器分配的实现，它们各自有将虚拟寄存器映射到物理寄存器的算法。这里无法详细涵盖任何这些算法。如果您想尝试理解它们，请参考下一节。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about the algorithms used in LLVM, look through the source codes
    located at `lib/CodeGen/`:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于LLVM中使用的算法的信息，请查看位于`lib/CodeGen/`的源代码：
- en: '`lib/CodeGen/RegAllocBasic.cpp`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/CodeGen/RegAllocBasic.cpp`'
- en: '`lib/CodeGen/ RegAllocFast.cpp`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/CodeGen/ RegAllocFast.cpp`'
- en: '`lib/CodeGen/ RegAllocGreedy.cpp`'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/CodeGen/ RegAllocGreedy.cpp`'
- en: '`lib/CodeGen/ RegAllocPBQP.cpp`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/CodeGen/ RegAllocPBQP.cpp`'
- en: Inserting the prologue-epilogue code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入序言-尾声代码
- en: Inserting the prologue-epilogue code involves stack unwinding, finalizing the
    function layout, saving callee-saved registers and emitting the prologue and epilogue
    code. It also replaces abstract frame indexes with appropriate references. This
    pass runs after the register allocation phase.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 插入序言-尾声代码涉及堆栈展开、最终确定函数布局、保存调用者保留寄存器以及生成序言和尾声代码。它还将抽象帧索引替换为适当的引用。此阶段在寄存器分配阶段之后运行。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The skeleton and the important functions defined in the `PrologueEpilogueInserter`
    class are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PrologueEpilogueInserter`类中定义的骨架和重要函数如下：
- en: 'The prologue epilogue inserter pass runs on a machine function, hence it inherits
    the `MachineFunctionPass` class. Its constructor initializes the pass:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序言-尾随代码插入传递在机器函数上运行，因此它继承了 `MachineFunctionPass` 类。它的构造函数初始化传递：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are various helper functions defined in this class that help insert the
    prologue and epilogue code:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个类中定义了各种辅助函数，这些函数有助于插入序言和尾随代码：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The main function, `insertPrologEpilogCode()`, does the task of inserting the
    prologue and epilogue code:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要函数 `insertPrologEpilogCode()` 的任务是插入序言和尾随代码：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first function to execute in this pass is the `runOnFunction()` function.
    The comments in the code show the various operations carried out, such as calculating
    the call frame size, adjusting the stack variables, inserting the spill code for
    the callee-saved register for modified registers, calculating the actual frame
    offset, inserting the prologue and epilogue code for the function, replacing the
    abstract frame index with the actual offsets, and so on:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个过程中首先执行的是 `runOnFunction()` 函数。代码中的注释显示了执行的各种操作，例如计算调用帧大小、调整栈变量、为修改过的寄存器插入被调用者保存的寄存器的溢出代码、计算实际的帧偏移、为函数插入序言和尾随代码、将抽象帧索引替换为实际偏移量，等等：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The main function that inserts prologue-epilogue code is the `insertPrologEpilogCode()`
    function. This function first takes the `TargetFrameLowering` object and then
    emits a prologue code for that function corresponding to that target. After that,
    for each basic block in that function, it checks whether there is a return statement.
    If there is a return statement, then it emits an epilogue code for that function:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入序言-尾随代码的主要函数是 `insertPrologEpilogCode()` 函数。这个函数首先获取 `TargetFrameLowering`
    对象，然后为该函数生成相应的目标序言代码。之后，对于该函数中的每个基本块，它检查是否存在返回语句。如果有返回语句，则生成该函数的尾随代码：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding code invokes the `emitEpilogue()` and the `emitPrologue()` functions
    in the `TargetFrameLowering` class, which will be discussed in the target-specific
    frame lowering recipes in later chapters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用了 `TargetFrameLowering` 类中的 `emitEpilogue()` 和 `emitPrologue()` 函数，这些将在后续章节中讨论的目标特定帧降低食谱中进行讨论。
- en: Code emission
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码发射
- en: The code emission phase lowers the code from code generator abstractions (such
    as `MachineFunction` class, `MachineInstr` class, and so on) to machine code layer
    abstractions (`MCInst` class, `MCStreamer` class, and so on). The important classes
    in this phase are the target-independent `AsmPrinter` class, target-specific subclasses
    of `AsmPrinter`, and the `TargetLoweringObjectFile` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码发射阶段将代码从代码生成抽象（如 `MachineFunction` 类、`MachineInstr` 类等）降低到机器代码层抽象（如 `MCInst`
    类、`MCStreamer` 类等）。这个阶段的重要类是目标无关的 `AsmPrinter` 类、`AsmPrinter` 的特定目标子类和 `TargetLoweringObjectFile`
    类。
- en: The MC layer is responsible for emitting object files, which consist of labels,
    directives, and instructions; while the `CodeGen` layer consists of `MachineFunctions`,
    `MachineBasicBlock` and `MachineInstructions`. A key class used at this point
    in time is the `MCStreamer` class, which consists of assembler APIs. The `MCStreamer`
    class has functions such as `EmitLabel`, `EmitSymbolAttribute`, `SwitchSection`,
    and so on, which directly correspond to the aforementioned assembly-level directives.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MC 层负责生成包含标签、指令和指令的对象文件；而 `CodeGen` 层由 `MachineFunctions`、`MachineBasicBlock`
    和 `MachineInstructions` 组成。在这个时候使用的一个关键类是 `MCStreamer` 类，它由汇编器 API 组成。`MCStreamer`
    类具有 `EmitLabel`、`EmitSymbolAttribute`、`SwitchSection` 等函数，这些函数直接对应于上述汇编级指令。
- en: 'There are four important things that need to be implemented for the target
    in order to emit code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在目标上发射代码，需要实现四个重要的事情：
- en: Define a subclass of the `AsmPrinter` class for the target. This class implements
    the general lowering process, converting the `MachineFunctions` functions into
    MC label constructs. The `AsmPrinter` base class methods and routines help implement
    a target-specific `AsmPrinter` class. The `TargetLoweringObjectFile` class implements
    much of the common logic for the `ELF`, `COFF`, or `MachO` targets.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标定义 `AsmPrinter` 类的子类。这个类实现了通用降低过程，将 `MachineFunctions` 函数转换为 MC 标签构造。`AsmPrinter`
    基类方法和例程有助于实现特定目标的 `AsmPrinter` 类。`TargetLoweringObjectFile` 类实现了 `ELF`、`COFF`
    或 `MachO` 目标的大部分公共逻辑。
- en: Implement an instruction printer for the target. The instruction printer takes
    an `MCInst` class and renders it into a `raw_ostream` class as text. Most of this
    is automatically generated from the `.td` file (when you specify something like
    add `$dst`, `$src1`, `$src2` in the instructions), but you need to implement routines
    to print operands.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标实现一个指令打印器。指令打印器接受一个`MCInst`类并将其渲染为`raw_ostream`类的文本。大部分内容都是自动从`.td`文件生成的（当你指定指令中的`$dst`、`$src1`、`$src2`等时），但你需要实现打印操作数的例程。
- en: Implement code that lowers a `MachineInstr` class to an `MCInst` `class`, usually
    implemented in `<target>MCInstLower.cpp`. This lowering process is often target-specific,
    and is responsible for turning jump table entries, constant pool indices, global
    variable addresses, and so on into `MCLabels`, as appropriate. The instruction
    printer or the encoder takes the `MCInsts` that are generated.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现将`MachineInstr`类降低到`MCInst`类的代码，通常在`<target>MCInstLower.cpp`中实现。这个降低过程通常是目标特定的，负责将跳转表条目、常量池索引、全局变量地址等转换为适当的`MCLabels`。指令打印器或编码器会接收生成的`MCInsts`。
- en: Implement a subclass of `MCCodeEmitter` that lowers `MCInsts` to machine code
    bytes and relocations. This is important if you want to support direct `.o` file
    emission, or want to implement an assembler for your target.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`MCCodeEmitter`子类，将`MCInsts`降低到机器代码字节和重定位。如果你想要支持直接`.o`文件发射，或者想要为你的目标实现一个汇编器，这是很重要的。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s visit some important functions in the `AsmPrinter` base class in the
    `lib/CodeGen/AsmPrinter/AsmPrinter.cpp` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问`lib/CodeGen/AsmPrinter/AsmPrinter.cpp`文件中的`AsmPrinter`基类的一些重要函数：
- en: '`EmitLinkage()`: This emits the linkage of the given variables or functions:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitLinkage()`: 这会发射给定变量或函数的链接：'
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`EmitGlobalVariable()`: This emits the specified global variable to the `.s`
    file:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitGlobalVariable()`: 这会将指定的全局变量发射到`.s`文件：'
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`EmitFunctionHeader()`: This emits the header of the current function:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitFunctionHeader()`: 这会发射当前函数的头部：'
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`EmitFunctionBody()`: This method emits the body and trailer of a function:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitFunctionBody()`: 这个方法会发射函数的主体和尾部：'
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`EmitJumpTableInfo()`: This prints assembly representations of the jump tables
    used by the current function to the current output stream:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitJumpTableInfo()`: 这会将当前函数使用的跳转表的汇编表示打印到当前输出流：'
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`EmitJumpTableEntry()`: This emits a jump table entry for the specified `MachineBasicBlock`
    class to the current stream:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitJumpTableEntry()`: 这会在当前流中为指定的`MachineBasicBlock`类发射一个跳转表条目：'
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Emit integer types of 8, 16, or 32 bit size:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射8位、16位或32位大小的整型类型：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For detailed implementation on code emission, see the `lib/CodeGen/AsmPrinter/AsmPrinter.cpp`
    file. One important thing to note is that this class uses the `OutStreamer` class
    object to output assembly instructions. The details of target-specific code emission
    will be covered in later chapters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码发射的详细实现，请参阅`lib/CodeGen/AsmPrinter/AsmPrinter.cpp`文件。需要注意的是，这个类使用`OutStreamer`类对象来输出汇编指令。目标特定的代码发射细节将在后面的章节中介绍。
- en: Tail call optimization
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: In this recipe, we will see how **tail call optimization** is done in LLVM.
    Tail call optimization is a technique where the callee reuses the stack of the
    caller instead of adding a new stack frame to the call stack, hence saving stack
    space and the number of returns when dealing with mutually recursive functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何在LLVM中实现**尾调用优化**。尾调用优化是一种技术，其中被调用者重用调用者的栈而不是在调用栈中添加一个新的栈帧，因此节省了栈空间和返回次数，尤其是在处理相互递归函数时。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We need to make sure of the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保以下事项：
- en: The `llc` tool must be installed in `$PATH`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llc`工具必须安装到`$PATH`'
- en: The `tailcallopt` option must be enabled
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须启用`tailcallopt`选项
- en: The test code must have a tail call
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码必须包含尾调用
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Write the test code for checking tail call optimization:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写检查尾调用优化的测试代码：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the `llc` tool with the `–tailcallopt` option on the test code to generate
    the assembly file with the tailcall-optimized code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试代码上运行带有`-tailcallopt`选项的`llc`工具，以生成带有尾调用优化代码的汇编文件：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Display the output generated:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示生成的输出：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using the `llc` tool, generate the assembly again but without using the `-tailcallopt`
    option:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`llc`工具再次生成汇编，但不使用`-tailcallopt`选项：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Display the output using the `cat` command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令显示输出：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compare the two assemblies using a diff tool. We used the meld tool here:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用diff工具比较两个汇编文件。这里我们使用了meld工具：
- en: '![How to do it…](img/image00267.jpeg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/image00267.jpeg)'
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The tail call optimization is a compiler optimization technique, which a compiler
    can use to make a call to a function and take up no additional stack space; we
    don't need to create a new stack frame for this function call. This happens if
    the last instruction executed in a function is a call to another function. A point
    to note is that the caller function now does not need the stack space; it simply
    calls a function (another function or itself) and returns whatever value the called
    function would have returned. This optimization can make recursive calls take
    up constant and limited space. In this optimization, the code might not always
    be in the form for which a tail call is possible. It tries and modifies the source
    to see whether a tail call is possible or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用优化是一种编译器优化技术，编译器可以使用它来调用一个函数而不占用额外的栈空间；我们不需要为这个函数调用创建一个新的栈帧。如果函数中最后执行的指令是调用另一个函数，就会发生这种情况。需要注意的是，调用函数现在不需要栈空间；它只是调用一个函数（另一个函数或自身）并返回被调用函数将返回的任何值。这种优化可以使递归调用占用恒定和有限的空间。在这个优化中，代码可能不一定总是以尾调用可能的形式存在。它尝试并修改源代码以查看是否可以进行尾调用。
- en: 'In the preceding test case, we see that a push-and-pop instruction is added
    due to tail call optimization. In LLVM, the tail call optimization is handled
    by the architecture-specific `ISelLowering.cpp` file; for x86, it is the `X86ISelLowering.cpp`
    file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，我们可以看到由于尾调用优化，增加了一条推入和弹出指令。在LLVM中，尾调用优化由架构特定的`ISelLowering.cpp`文件处理；对于x86，是`X86ISelLowering.cpp`文件：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is used to call the `IsEligibleForTailCallOptimization()`
    function when the `tailcallopt` flag is passed. The `IsEligibleForTailCallOptimization()`
    function decides whether or not the piece of code is eligible for tail call optimization.
    If it is, then the code generator will make the necessary changes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码用于在传递`tailcallopt`标志时调用`IsEligibleForTailCallOptimization()`函数。`IsEligibleForTailCallOptimization()`函数决定这段代码是否适合尾调用优化。如果是，则代码生成器将进行必要的更改。
- en: Sibling call optimisation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兄弟调用优化
- en: In this recipe, we will see how **sibling call optimization** works in LLVM.
    Sibling call optimization can be looked at as an optimized tail call, the only
    constraint being that the functions should share a similar function signature,
    that is, matching return types and matching function arguments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到在LLVM中**兄弟调用优化**是如何工作的。可以将兄弟调用优化看作是优化过的尾调用，唯一的约束是函数应该具有相似的功能签名，即匹配的返回类型和匹配的函数参数。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Write a test case for sibling call optimization, making sure that the caller
    and callee have the same calling conventions (in either C or **fastcc**), and
    that the call in the tail position is a tail call:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个用于兄弟调用优化的测试用例，确保调用者和被调用者具有相同的调用约定（无论是C还是**fastcc**），并且尾位置的调用是尾调用：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Run the `llc` tool to generate the assembly:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`llc`工具生成汇编：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'View the generated assembly using the `cat` command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令查看生成的汇编：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sibling call optimization is a restricted version of tail call optimization
    that can be performed on tail calls without passing the `tailcallopt` option.
    Sibling call optimization works in a similar way to tail call optimization, except
    that the sibling calls are automatically detected and do not need any ABI changes.
    The similarity needed in the function signatures is because when the caller function
    (which calls a tail recursive function) tries to clean up the callee's argument,
    after the callee has done its work, this may lead to memory leak if the callee
    exceeds the argument space to perform a sibling call to a function requiring more
    stack space for arguments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 兄弟调用优化是尾调用优化的一种受限版本，可以在不传递`tailcallopt`选项的情况下对尾调用进行优化。兄弟调用优化的工作方式与尾调用优化类似，不同之处在于兄弟调用会自动检测，并且不需要任何ABI更改。在函数签名中需要的相似性是因为当调用函数（调用尾递归函数的函数）试图清理被调用函数的参数时，在被调用函数完成其工作之后，如果被调用函数超出参数空间以执行对需要更多栈空间参数的函数的兄弟调用，这可能会导致内存泄漏。
