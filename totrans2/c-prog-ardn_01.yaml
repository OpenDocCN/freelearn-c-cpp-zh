- en: Chapter 1. Let's Plug Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino is all about plugging things. We are going to do that in a couple of
    minutes after we have learned a bit more about microcontrollers in general and
    especially the big and amazing Arduino family. This chapter is going to teach
    you how to be totally ready to code, wire, and test things with your new hardware
    friend. Yes, this will happen soon, very soon; now let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: What is a microcontroller?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **microcontroller** is an **integrated circuit** (**IC**) containing all
    main parts of a typical computer, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **processor** is the brain, the part where all decisions are taken and which
    can calculate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memories** are often both spaces where both the core inner-self program and
    the user elements are running (generally called **Read Only Memory** (**ROM**)
    and **Random Access Memory** (**RAM**)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I define peripherals by the self-peripherals contained in a global board; these
    are very different types of integrated circuits with a main purpose: to support
    the processor and to extend its capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs and outputs are the ways of communication between the world (around the
    microcontroller) and the microcontroller itself.
  prefs: []
  type: TYPE_NORMAL
- en: The very first single-chip processor was built and proposed by Intel Corporation
    in 1971 under the name **Intel 4004** . It was a 4-bit **central processing unit**
    (**CPU**).
  prefs: []
  type: TYPE_NORMAL
- en: Since the 70s, things have evolved a lot and we have a lot of processors around
    us. Look around, you'll see your phone, your computer, and your screen. Processors
    or microprocessors drive almost everything.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to microprocessors, microcontrollers provide a way to reduce power
    consumption, size, and cost. Indeed, microprocessors, even if they are faster
    than processors embedded in microcontrollers, require a lot of peripherals to
    be able to work. The high-level of integration provided by a microcontroller makes
    it the friend of embedded systems that are car engine controller, remote controller
    of your TV, desktop equipment including your nice printer, home appliances, games
    of children, mobile phones, and I could continue…
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many families of microcontrollers that I cannot write about in this
    book, not to quote **PICs** ([http://en.wikipedia.org/wiki/PIC_microcontroller](http://en.wikipedia.org/wiki/PIC_microcontroller))
    and **Parallax SX** microcontroller lines. I also want to quote a particular music
    hardware development open source project: **MIDIbox** (PIC-, then STM32-based,
    check [http://www.ucapps.de](http://www.ucapps.de)). This is a very strong and
    robust framework, very tweakable. The Protodeck controller ([http://julienbayle.net/protodeck](http://julienbayle.net/protodeck))
    is based on MIDIbox.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have understood you have a whole computer in your hands, let's
    specifically describe Arduino boards!
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the big Arduino family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino is an open source ([http://en.wikipedia.org/wiki/Open_source](http://en.wikipedia.org/wiki/Open_source))
    singleboard-based microcontroller. It is a very popular platform forked from the
    **Wiring** platform ([http://www.wiring.org.co/](http://www.wiring.org.co/)) and
    firstly designed to popularize the use of electronics in interaction design university
    students' projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the big Arduino family](img/7584_01_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: My Arduino MEGA in my hand
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the Atmel AVR processor ([http://www.atmel.com/products/microcontrollers/avr/default.aspx](http://www.atmel.com/products/microcontrollers/avr/default.aspx))
    and provides many inputs and outputs in only one self-sufficient piece of hardware.
    The official website for the project is [http://www.arduino.cc](http://www.arduino.cc).
  prefs: []
  type: TYPE_NORMAL
- en: The project was started in Italy in 2005 by founders Massimo Banzi and David
    Cuartielles. Today it is one of the most beautiful examples of the open source
    concept, brought to the hardware world and being often used only in the software
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We talk about Arduino family because today we can count around 15 boards ''Arduino-based'',
    which is a funny meta-term to define different type of board designs all made
    using an Atmel AVR processor. The main differences between those boards are the:'
  prefs: []
  type: TYPE_NORMAL
- en: Type of processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form factor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Arduino boards are a bit more powerful, considering calculation speed,
    some other have more memory, some have a lot of inputs/outputs (check the huge
    Arduino Mega), some are intended to be integrated in more complex projects and
    have a very small form factor with very few inputs and outputs… as I used to tell
    my students *each one can find his friend in the Arduino family*. There are also
    boards that include peripherals like Ethernet Connectors or even Bluetooth modules,
    including antennas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic behind this family is the fact we can use the same **Integrated Development
    Environment** (**IDE**) on our computers with any of those boards ([http://en.wikipedia.org/wiki/Integrated_development_environment](http://en.wikipedia.org/wiki/Integrated_development_environment)).
    Some bits need to be correctly setup but this is the very same software and language
    we''ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the big Arduino family](img/7584_01_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some notable Arduino family members: Uno R3, LilyPad, Arduino Ethernet, Arduino
    Mega, Arduino Nano, Arduino Pro, and a prototyping shield'
  prefs: []
  type: TYPE_NORMAL
- en: A very nice but non-exhaustive reference page about this can be found at [http://arduino.cc/en/Main/Hardware](http://arduino.cc/en/Main/Hardware).
  prefs: []
  type: TYPE_NORMAL
- en: 'I especially want you to check the following models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino Uno** is the basic one with a replaceable chipset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino Mega**, 2560 provides a bunch of inputs and outputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino LilyPad**, is wearable as clothes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino Nano**, is very small'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book I'll use an Arduino Mega and Arduino Uno too; but don't
    be afraid, when you've mastered Arduino programming, you'll be able to use any
    of them!
  prefs: []
  type: TYPE_NORMAL
- en: About hardware prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can program and build software quite easily today using a lot of open source
    frameworks for which you can find a lot of helpful communities on the Web. I'm
    thinking about **Processing** (Java-based, check [http://processing.org](http://processing.org)),
    and **openFrameworks** (C++-based, check [http://www.openframeworks.cc](http://www.openframeworks.cc)),
    but there are many others that sometimes use very different paradigms like graphical
    programming languages such as **Pure Data** ([http://puredata.info](http://puredata.info)),
    **Max 6** ([http://cycling74.com/products/max/](http://cycling74.com/products/max/)),
    or **vvvv** ([http://vvvv.org](http://vvvv.org)) for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Because we, the makers, are totally involved in do-it-yourself practices, we
    all want and need to build and design our own tools and it often means hardware
    and electronics tools. We want to extend our computers with sensors, blinking
    lights, and even create standalone gears.
  prefs: []
  type: TYPE_NORMAL
- en: Even for testing very basic things like blinking a **light emitting diode**
    (**LED**), it involves many elements from supplying power to chipset low-level
    programming, from resistors value calculations to voltage-driven quartz clock
    setup. All those steps just gives headache to students and even motivated ones
    can be put off making just a first test.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino appeared and changed everything in the landscape by proposing an inexpensive
    and all-included solution (we have to pay $30 for the Arduino Uno R3), a cross-platform
    toolchain running on Windows, OS X, and Linux, a very easy high-level C language
    and library that can also tweak the low-level bits, and a totally extensible open
    source framework.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, with an all-included small and cute board, an USB cable, and your computer,
    you can learn electronics, program embedded hardware using C language, and blink
    your LED.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware prototyping became (almost) as easy as software prototyping because
    of the high level of integration between the software and the hardware provided
    by the whole framework.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important things to understand here is the prototyping cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![About hardware prototyping](img/7584_01_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One easy hardware prototyping steps list
  prefs: []
  type: TYPE_NORMAL
- en: From our idea to our final render, we usually have to follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to make that LED blink, we have to define several blinking characteristics
    for instance. It will help to precisely define the project, which is a key to
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Then we'll have to sketch a schematic with our Arduino board and our LED; it
    will dig the question, "How are they connected together?"
  prefs: []
  type: TYPE_NORMAL
- en: The firmware programming using C language can directly be started after we have
    sketched the circuit because, as we'll see later, it is directly related to the
    hardware. This is one of the strong powers of Arduino development. You remember?
    The board design has been designed only to make us think about our project and
    not to confuse us with very low-level abstract learning bits.
  prefs: []
  type: TYPE_NORMAL
- en: The upload step is a very important one. It can provide us a lot of information
    especially in case of further troubleshooting. We'll learn that this step doesn't
    require more than a couple of clicks once the board is correctly wired to our
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the subcycle test and fix will occur. We''ll learn by making, by testing,
    and it means by failing too. It is an important part of the process and it will
    teach you a lot. I have to confess something important here: at the time when
    I first began my **bonome** project ([http://julienbayle.net/bonome](http://julienbayle.net/bonome)),
    an RGB monome clone device, I spent two hours fixing a reverse wired LED matrix.
    Now, I know them very well because I failed one day.'
  prefs: []
  type: TYPE_NORMAL
- en: The last step is the coolest one. I mentioned it because we have to keep in
    our mind the final target, the one that will make us happy in the end; it is a
    secret to succeed!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Arduino software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how to make our nice Arduino board work exactly as we
    want it to, we have to understand the global software architecture and the toolchain
    that we'll be using quite soon.
  prefs: []
  type: TYPE_NORMAL
- en: Take your Arduino board in hand. You'll see a rectangle-shaped IC with the word
    ATMEL written on the top; this is the processor.
  prefs: []
  type: TYPE_NORMAL
- en: This processor is the place that will contain the entire program that we'll
    write and that will make things happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we buy (check *Appendix G, List of Components'' Distributors*, and this
    link: [http://arduino.cc/en/Main/Buy](http://arduino.cc/en/Main/Buy)) an Arduino,
    the processor, also named *chipset*, is preburnt. It has been programmed by careful
    people in order to make our life easier. The program already contained in the
    chipset is called the **bootloader** ([http://en.wikipedia.org/wiki/Booting](http://en.wikipedia.org/wiki/Booting)).
    Basically, it takes care of the very first moment of awakening of the processor
    life when you supply it some power. But its major role is the load of our firmware
    ([http://en.wikipedia.org/wiki/Firmware](http://en.wikipedia.org/wiki/Firmware)),
    I mean, our precious compiled program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a small diagram for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Arduino software architecture](img/7584_01_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I like to define it by saying that *the bootloader is the hardware's software
    and the firmware is the user's software*. Indeed, it also has some significance
    because memory spaces in the chipset are not equal for write operations (within
    a specific hardware which we'll discuss in the future sections of this book).
    Using a **programmer**, we cannot overwrite the bootloader (which is safer at
    this point of our reading) but only the firmware. This will be more than enough
    even for advanced purposed, as you'll see all along the book.
  prefs: []
  type: TYPE_NORMAL
- en: Not all Arduino boards' bootloaders are equivalent. Indeed, they have been made
    to be very specific to the hardware part, which provides us more abstraction of
    the hardware; we can focus on higher levels of design because the bootloader provides
    us services such as firmware upload via USB and serial monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now download some required software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FTDI USB drivers**: [http://www.ftdichip.com/Drivers/VCP.htm](http://www.ftdichip.com/Drivers/VCP.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino IDE**: [http://arduino.cc/en/Main/Software](http://arduino.cc/en/Main/Software)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing**: [http://processing.org/download/](http://processing.org/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing is used in this book but isn''t necessary to program and use Arduino
    boards.**'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is the Arduino''s toolchain?**'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we call Arduino's **toolchain** a set of software tools required to
    handle all steps from the C code we are typing in the Arduino IDE on our computer
    to the firmware uploaded on the board. Indeed, the C code you type has to be prepared
    before the compilation step with avr-gcc and avr-g++ compilers. Once the resulting
    object's files are linked by some other programs of the toolchain, into usually
    only one file, you are done. This can later be uploaded to the board. There are
    other ways to use Arduino boards and we'll introduce that in the last chapter
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Arduino development environment (IDE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's find the compressed file downloaded from [http://arduino.cc/en/Main/Software](http://arduino.cc/en/Main/Software)
    in the previous part and let's decompress it on our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the platform, the IDE works equally and even if I'll describe some
    specific bits of three different platforms, I'll only describe the use of the
    IDE and show screenshots from OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn't a typical installation of the IDE because it runs into the **Java
    Virtual Machine** . This means you only have to download it, to decompress it
    somewhere on your system, and then launch it and JAVA will execute the program.
    It is possible to use only the **CLI** (**command-line interface**, the famous
    g33ks window in which you can type the command directly to the system) to build
    your binaries instead of the graphical interface, but at this point, I don't recommend
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, Windows and OS X come with Java installed. If that isn't the case,
    please install it from the `java.com` website page at [http://www.java.com/en/download/](http://www.java.com/en/download/).
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, the process really depends on the distribution you are using, so I
    suggest to check the page [http://www.arduino.cc/playground/Learning/Linux](http://www.arduino.cc/playground/Learning/Linux)
    and if you want to check and install all the environment and dependencies from
    sources, you can also check the page [http://www.arduino.cc/playground/Linux/All](http://www.arduino.cc/playground/Linux/All).
  prefs: []
  type: TYPE_NORMAL
- en: How to launch the environment?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows, let's click on the `.exe` file included in the uncompressed folder.
    On OS X, let's click on the global self-contained package with the pretty Arduino
    logo. On Linux, you'll have to start the Arduino script from the GUI or by typing
    in the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: You have to know that using the IDE you can do everything we will make in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: What does the IDE look like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IDE provides a graphical interface in which you can write your code, debug
    it, compile it, and upload it, basically.
  prefs: []
  type: TYPE_NORMAL
- en: '![What does the IDE look like?](img/7584_01_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The famous Blink code example opened in the Arduino IDE
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six icons from left to right that we have to know very well because
    we''ll use them every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verify** (check symbol): This provides code checking for errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upload** (right-side arrow): This compiles and uploads our code to the Arduino
    board'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New** (small blank page): This creates a new blank sketch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open** (up arrow): This opens a list of all sketches already existing in
    our sketchbook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Save** (down arrow): This saves our sketch in our sketchbook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Monitor** (small magnifying glass): This provides the serial monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each menu item in the top bar provides more options we will discover progressively
    all throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the **Tools** menu deserves closer attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto Format**: This provides code formatting with correct and standard indentations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive Sketch**: This compresses the whole current sketch with all files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Board**: This provides a list of all boards supported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Port**: This provides a list of all serial devices on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmer**: This provides a list of all programmer devices supported and
    used in case of total reprogramming of the AVR chipset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burn Bootloader**: This is the option used when you want to overwrite (or
    even write) a new bootloader on your board.![What does the IDE look like?](img/7584_01_006.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tools menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preferences dialog is also a part we have to learn about right now. As usual,
    the preferences dialog is a place where we don't really need to go often but only
    for changing global parameters of the IDE. You can choose the sketchbook location
    and the Editor language in this dialog. You can also change a couple of bits like
    automatic check-up of IDE updates at start up or Editor font size.
  prefs: []
  type: TYPE_NORMAL
- en: The sketchbook concept will make our life easier. Indeed, the sketchbook is
    a folder where, basically, all your sketches will go. On my personal point of
    view, it is very precious to use it like this because it really organizes things
    for you and you can retrieve your pieces of code easier. Follow me there; you'll
    thank me later.
  prefs: []
  type: TYPE_NORMAL
- en: When we start a sketch from scratch, we basically type the code, verify it,
    upload it, and save it. By saving it, the first time, the IDE creates a folder
    in which it will put all the files related to our current sketch. By clicking
    on the sketch file inside this folder, the Arduino IDE will open and the related
    code will be displayed in the edit/typing part of the window.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done!
  prefs: []
  type: TYPE_NORMAL
- en: Let's install the drivers of the Arduino USB interface on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Arduino drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino boards provide an USB interface. Before we plug the USB cable and link
    the board to our computer, we have to install specific drivers in the latter.
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge difference between Windows and OS X here; basically, OS X doesn't
    require any specific drivers for Arduino Uno or even Mega 2560\. If you are using
    older boards, you'd have to download the latest version of drivers on the FTDI
    website, double-click the package, then follow instructions, and finally, restart
    your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe how it works on Windows-based systems, I mean, Windows 7, Vista,
    and XP.
  prefs: []
  type: TYPE_NORMAL
- en: Installing drivers for Arduino Uno R3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to follow the steps mentioned next to be able to use the Arduino
    Uno R3 and some other boards. Please check the Arduino website for up-to-date
    references.
  prefs: []
  type: TYPE_NORMAL
- en: Plug your board in and wait for Windows to begin the driver installation process.
    After a few moments, the process fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Start menu, and open **Control Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Control Panel**, navigate to **System and Security**. Next, click on **System**.
    Once the **System** window is up, open **Device Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look under **Ports (COM & LPT)**. Check the open port named **Arduino UNO (COMxx)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **the Arduino UNO (COMxx)** port and choose the **Update Driver
    Software** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose the **Browse my computer for driver software** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, navigate and select the Uno''s driver file, named `ArduinoUNO.inf`,
    located in the `Drivers` folder of the Arduino software download (be careful:
    not the `FTDI USB Drivers` subdirectory).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows will finish the driver installation from there and everything will be
    fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing drivers for Arduino Duemilanove, Nano, or Diecimilla
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you connect the board, Windows should initiate the driver installation
    process (if you haven't used the computer with an Arduino board before).
  prefs: []
  type: TYPE_NORMAL
- en: On Windows Vista, the driver should be automatically downloaded and installed.
    (Really, it works!)
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows XP, the **Add New Hardware** wizard will open:'
  prefs: []
  type: TYPE_NORMAL
- en: When asked **Can Windows connect to Windows Update to search for software?**
    select **No, not this time**. Click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Install from a list or specified location (Advanced)** and click on
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that **Search for the best driver in these locations** is checked,
    uncheck **Search removable media**, check **Include this location in the search**,
    and browse to the **drivers/FTDI USB Drivers** directory of the Arduino distribution.
    (The latest version of the drivers can be found on the *FTDI* website.) Click
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wizard will search for the driver and then tell you that a **USB Serial
    Converter** was found. Click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new hardware wizard will appear again. Go through the same steps and select
    the same options and location to search. This time, a **USB Serial Port** will
    be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check that the drivers have been installed by opening **Windows Device
    Manager** (in the **Hardware** tab of the **System** control panel). Look for
    a **USB Serial Port** in the **Ports** section; that's the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our computer can recognize our Arduino board. Let's move to the physical
    world a bit to join together the tangible and intangible worlds.
  prefs: []
  type: TYPE_NORMAL
- en: What is electricity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino is all about electronic, and electronic refers to electricity. This
    may be your first dive into this amazing universe, made of wires and voltages,
    including blinking LEDs and signals. I'm defining several very useful notions
    in this part; you can consider turning down the corner of this page and to come
    back as often as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I'm using the usual analogy of water. Basically, wires are pipes and water
    is electricity itself.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Voltage** is a potential difference. Basically, this difference is created
    and maintained by a generator. This value is expressed in Volt units (the symbol
    is V).'
  prefs: []
  type: TYPE_NORMAL
- en: The direct analogy with hydraulic systems compare the voltage to the difference
    of pressure of water in two points of a pipe. The higher the pressure, the faster
    the water moves, for a constant diameter of pipe of course.
  prefs: []
  type: TYPE_NORMAL
- en: We'll deal with low voltage all throughout this book, which means nothing more
    than 5 V. Very quickly, we'll use 12 V to supply motors and I'll precise that
    each time we do.
  prefs: []
  type: TYPE_NORMAL
- en: When you switch on the generator of closed circuits, it produces and keeps this
    potential difference. Voltage is a difference and has to be measured between two
    points on a circuit. We use voltmeters to measure the voltage.
  prefs: []
  type: TYPE_NORMAL
- en: Current and power
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Current** can be compared to the hydraulic volume flow rate, which is the
    volumetric quantity of flowing water over a time interval.'
  prefs: []
  type: TYPE_NORMAL
- en: The current value is expressed in Ampères (the symbol is A). The higher the
    current, the higher will be the quantity of electricity moving.
  prefs: []
  type: TYPE_NORMAL
- en: A flow rate doesn't require two points to be measured as a difference of pressure;
    we only need one point of the circuit to make our measurement with an equipment
    named Ampere meter.
  prefs: []
  type: TYPE_NORMAL
- en: In all of our applications, we'll deal with **direct current** (**DC**), which
    is different from **alternative current** (**AC**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Power** is a specific notion, which is expressed in Watt (the symbol is W).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a mathematical relationship between voltage, current, and power:'
  prefs: []
  type: TYPE_NORMAL
- en: P = V x I
  prefs: []
  type: TYPE_NORMAL
- en: where, P is the power in Watt, V the voltage in V, and I the current in Ampères.
  prefs: []
  type: TYPE_NORMAL
- en: Are you already feeling better? This analogy has to be understood as a proper
    analogy, but it really helps to understand what we'll make a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: And what are resistors, capacitors, and so on?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the same analogy, **resistors** are small components that slow down
    the flow of current. They are more resistive than any piece of wire you can use;
    they generally dissipate it as heat. They are two passive terminal components
    and aren't polarized, which means you can wire them in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Resistors are defined by their *electrical resistance* expressed in Ohms (the
    symbol is Ω).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a direct mathematical relation between voltage measured at the resistor
    sides, current, and resistance known as the Ohm''s law:'
  prefs: []
  type: TYPE_NORMAL
- en: R = V / I
  prefs: []
  type: TYPE_NORMAL
- en: where R the electrical resistance in Ohms, V the voltage in Volts, and I the
    current in Ampères.
  prefs: []
  type: TYPE_NORMAL
- en: For a constant value of voltage, if the resistance is high, the current is low
    and vice-versa. It is important to have that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: On each resistor, there is a color code showing the resistance value.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of resistors. Some have a constant resistance, some others
    can provide different resistance values depending on physical parameters such
    as temperature, or light intensity for instance.
  prefs: []
  type: TYPE_NORMAL
- en: A **potentiometer** is a variable resistor. You move a slider or rotate a knob
    and the resistance changes. I guess you begin to understand my point…
  prefs: []
  type: TYPE_NORMAL
- en: 'A **capacitor** (or **condenser**) is another type of component used very often.
    The direct analogy is the rubber membrane put in the pipe: no water can pass through
    it, but water can move by stretching it.'
  prefs: []
  type: TYPE_NORMAL
- en: They are also passive two-terminal components but can be polarized. Usually,
    small capacitors aren't.
  prefs: []
  type: TYPE_NORMAL
- en: We usually are saying that capacitors store potential energy by charging. Indeed,
    the rubber membrane itself stores energy while you stretch it; try to release
    the stretched membrane, it will find its first position.
  prefs: []
  type: TYPE_NORMAL
- en: Capacitance is the value defining each capacitor. It is expressed in Farads
    (the symbol is F).
  prefs: []
  type: TYPE_NORMAL
- en: We'll stop here about capacitance calculations because it involves advanced
    mathematics which isn't the purpose of this book. By the way, keep in mind the
    higher the capacitance, more will be the potential the capacitor can store.
  prefs: []
  type: TYPE_NORMAL
- en: A **diode** is again a two-terminal passive component but is polarized. It lets
    the current pass through it only in one direction and stop it in the other. We'll
    see that even in the case of direct current, it can help and make our circuits
    safer in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: LEDs are a specific type of diode. While the current passes through them in
    the correct direction, they glow. This is a nice property we'll use to check if
    our circuit is correctly closed in a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transistor** is the last item I''m describing here because it is a bit more
    complex, but we cannot talk about electronics without quoting it.'
  prefs: []
  type: TYPE_NORMAL
- en: Transistors are semiconductor devices that can amplify and switch electronics
    signals and power, depending on how they are used. They are three-terminal components.
    This is the key active component of almost all modern electronics around us. Microprocessors
    are made of transistors and they can even contain more than 1 billion of them.
  prefs: []
  type: TYPE_NORMAL
- en: Transistors in the Arduino world are often used to drive high current, which
    couldn't pass through the Arduino board itself without burning it. In that case,
    we basically use them as analogue switches. When we need them to close a circuit
    of high currents to drive a motor for instance, we just drive one of their three
    terminals with a 5 V coming from the Arduino and the high current flows through
    it as if it had closed a circuit. In that case, it extends the possibilities of
    the Arduino board, making us able to drive higher currents with our little piece
    of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring things and Fritzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the previous analogy, we can understand well that a circuit needs to be
    closed in order to let the current flow.
  prefs: []
  type: TYPE_NORMAL
- en: Circuits are made with wires, which are basically conductors. A conductor is
    a matter with a resistance near to zero; it lets the current flow easily. Metals
    are usually good conductors. We often use copper wires.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep our wiring operations easy, we often use pins and headers.
    This is a nice way to connect things without using a soldering iron each time!
  prefs: []
  type: TYPE_NORMAL
- en: By the way, there are many ways to wire different components together. For our
    prototyping purpose, we won't design printed circuit board or even use our soldering
    iron; we'll use breadboards!
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring things and Fritzing](img/7584_01_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A breadboard with its buses blue and red and its numerous perforations
  prefs: []
  type: TYPE_NORMAL
- en: Breadboards are the way to rapid prototyping and this is the way to go here.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, breadboards consists of a piece of plastic with many perforations
    in which there are small pieces of conductors allowing to connect wires and components'
    leads inside.
  prefs: []
  type: TYPE_NORMAL
- en: The distance between two perforations is 2.54 mm (equal to 0.1") that is a standard;
    for instance, dual in-line package integrated circuits' leads are all separated
    by this particular distance and thus, you can even put IC on breadboards.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw on the previous screenshot, there are buses and terminals strips.
  prefs: []
  type: TYPE_NORMAL
- en: '**Buses** are series of five perforations in the central part and put in column
    for which the underlying conductors are connected. I have surrounded one bus with
    a green stroke.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminals** are special buses usually used for power supplying the circuit
    and appear in between blue and red lines. Usually, we use blue for ground lines
    and red for voltage source (5 V or 3.3 V in some cases). A whole line of terminals
    has its perforations all connected, providing voltage source and ground easily
    available on all the breadboard without having to use a lot of connection to the
    Arduino. I surrounded 2 of the 4 terminals with red and blue strokes.'
  prefs: []
  type: TYPE_NORMAL
- en: Breadboards provide one of the easiest ways of prototyping without soldering.
    It also means you can use and reuse your breadboards throughout the years!
  prefs: []
  type: TYPE_NORMAL
- en: What is Fritzing?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I discovered the open source **Fritzing** project ([http://fritzing.org](http://fritzing.org))
    when I needed a tool to make my first master classes slideshows schematic around
    the Protodeck controller ([http://julienbayle.net/protodeck](http://julienbayle.net/protodeck))
    I built in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: Fritzing is defined as *an open source initiative to support designers, artists,
    researchers and hobbyists to work creatively with interactive electronics*. It
    sounds as if it had been made for us, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Fritzing's latest versions at [http://fritzing.org/download/](http://fritzing.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Basically, with Fritzing, you can design and sketch electronic circuits. Because
    there are many representations of electronic circuits, this precious tool provides
    two of the classic ones and a PCB design tool too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the first practical work we are going to do, you have to take your
    breadboard, your Arduino, and wire the lead and the resistor exactly as it is
    shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Fritzing?](img/7584_01_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The breadboard view showing our first circuit
  prefs: []
  type: TYPE_NORMAL
- en: The *breadboard view* is the one that looks the most like what we have in front
    of us on the table. You represent all wires and you connect a virtual breadboard
    to your Arduino and directly plug components.
  prefs: []
  type: TYPE_NORMAL
- en: The magic lies in the fact that the schematic is automatically build while you
    are sketching in the breadboard view. And it works both ways! You can make a schematic,
    and Fritzing connect components in the breadboard view. Of course, you'd probably
    have to place the part in a more convenient or aesthetical way, but it works perfectly
    fine. Especially, the **Autorouter** helps you with making all wires more linear
    and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screenshot, you can see the same circuit as before, but shown in
    the *schematic view*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Fritzing?](img/7584_01_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The schematic view representing the circuit diagram
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of components already designed especially for Fritzing and you
    can even create yours quite easily. The page to visit for this purpose is [http://fritzing.org/parts/](http://fritzing.org/parts/).
  prefs: []
  type: TYPE_NORMAL
- en: The native library contains all parts required in all schematics of this book
    from all Arduino boards, to any discrete components and IC too. Indeed, all schematics
    of this book have been made using Fritzing!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to wire things without any soldering iron, and how to
    quietly sketch and check things on your computer before you do it for real on
    your desktop, let's learn a bit about power supply.
  prefs: []
  type: TYPE_NORMAL
- en: Power supply fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned a bit more about electricity before, but how can I supply all my
    circuits in real life?
  prefs: []
  type: TYPE_NORMAL
- en: 'Arduino boards can be supplied in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By our computer via the USB cable (5 V is provided)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By a battery or a direct external **Power Supply Unit** (**PSU**) / Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By attaching a regulated 5 V to the +5 V pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The USB cable contains four cables: two for data communication purpose and
    two for power supply. Those latter are basically used to supply Arduino when you
    are connecting it to the computer via USB.'
  prefs: []
  type: TYPE_NORMAL
- en: USB is a special communication bus that provides 5 V but no more than 500 mA.
    (0.5 A) It means we have to use another supply source in special projects where
    we need a lot of LED, motors, and other devices that drive a lot of current.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What adapter can I use with my Arduino?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arduino Uno and Mega can be directly supplied by DC Adapter but this one *has*
    to respect some characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The output voltage should be between 9 V and 12 V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be able to drive at least 250 mA of current
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a 2.1 mm power plug with center positive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, if you ask yourself about the fact whether to use an adapter or not,
    it means you need more current than the USB's 500 mA (Practically, ask yourself
    this question whether you need around 400 mA).
  prefs: []
  type: TYPE_NORMAL
- en: Using USB or the 2.1 mm power plug with an adapter are the safest ways to use
    Arduino boards for many reasons. The main one is the fact that those two sources
    are (hopefully) clean, which means they deliver a regulated voltage.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you have to change something on the board if you want to use one or
    the other source: a jumper has to be moved to the right position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Power supply fundamentals](img/7584_01_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the left, the jumper is set to USB power supply and on the right, it is set
    to external power supply
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, an idle Arduino board drains around 100 mA and, except in specified
    cases (see [Chapter 9](ch09.html "Chapter 9. Making Things Move and Creating Sounds"),
    *Making Things Move and Creating Sounds*), we''ll use the USB way of supply. This
    is what you have to do now: plug in the USB cable both in the Arduino and your
    computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Arduino IDE too, and let's move further to the hardware *Hello World*
    of our system, I call that the *Hello LED*!
  prefs: []
  type: TYPE_NORMAL
- en: Hello LED!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your Arduino doesn't contain any firmware, the LED probably does nothing.
    If you check the built-in LED on the Arduino board itself, that one should blink.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the control over our external cute LED plugged in the breadboard
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: What do we want to do exactly?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember correctly, this is the first question we have to ask. Of course,
    we bypassed this step a bit especially about the hardware part because I had to
    explain things while you were wiring, but let's continue the prototyping process
    explained in part by checking the code and uploading it.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make our LED blink. But what blink speed ? How much time? Let's say
    we want to make it blink every 250 ms with a one second pause between the blinks.
    And we want to do that infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: If you check the schematic, you can understand that the LED is put between the
    ground, and the line to the digital output pin number 8.
  prefs: []
  type: TYPE_NORMAL
- en: There is a resistor and you now know that it can consume a bit of energy by
    resisting to the current flowing to the LED. We can say the resistor protects
    our LED.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the LED light up, we have to create a flow of current. Sending
    +5 V to the digital output number 8 can do this. That way, there will be a potential
    difference at the two leads of the LED, driving it to be lighted. But the digital
    output shouldn't be at +5 V at each time. We have to control the moment when it
    will provide this voltage. Still okay?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize what we have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the 5 V to the digital output 8 during 250ms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop to drive the digital output 8 during 1s.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart this every time the Arduino is powered
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can I do that using C code?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you followed the previous page correctly, you already have your Arduino board
    wired to the computer via your USB cable on one side, and wired to the breadboard
    on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Now, launch your Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new blank page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you already tested your IDE by loading some examples, or if you already
    wrote some piece of code, you have to click on the *New icon* in order to load
    a blank page, ready to host our `Blink250ms` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Start with a new blank page](img/7584_01_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A nice and attractive blank page
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment according the board we are using
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The IDE has to know with which board it will have to communicate. We will do
    it in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Tools** menu and choose the correct board. The first one is **Arduino
    Uno**:![Setting up the environment according the board we are using](img/7584_01_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the board you are using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we have done that, we have to choose the correct serial port. Go to the
    **Tools** menu again and choose the correct serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On OS X, the correct one begins with **/dev/tty.usbmodem** for both Uno and
    Mega 2560 and with **/dev/tty.usbserial** for older boards.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, the correct port is usually **COM3** (**COM1** and **COM2** are
    often reserved by the operating system). By the way, it can also be **COM4**,
    **COM5**, or whatever else. To be sure, please check the device manager.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Linux, the port is usually **/dev/ttyUSB0**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Setting up the environment according the board we are using](img/7584_01_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Choose the serial port corresponding to your board
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, our IDE can talk to our board. Let's push the code now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write the code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is the complete code. You can find it in the zip file in the
    `Chapter01/Blink250ms/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's comment it a bit. Indeed, we'll learn how to code our own C code in the
    next chapter, then I'll only describe this one and give you some small tips.
  prefs: []
  type: TYPE_NORMAL
- en: First, everything between `/*` and `*/`, and everything after `//` are just
    comments. The first form is used for comments more than one line at a time, and
    the other one is for one line commenting only. You can write any comments like
    that and they won't be considered by the compiler at all. I strongly advice you
    to comment your code; this is another key to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the first part of the code contains one variable declaration and initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see two particular structures between curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first one (`setup()`) is a function that is executed only one time when
    the Arduino board is started (or reseted); this is the place where we are telling
    the board that the pin where the LED is connected is an output, that is, this
    pin will have to drive current while activated.
  prefs: []
  type: TYPE_NORMAL
- en: The second one (`loop()`) is a function executed infinitely when the Arduino
    board is supplied. This is the main part of our code in which we can find the
    steps we wanted to light up the LED for 250 ms and switch off the LED for 1 s,
    repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's upload the code, at last!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you correctly followed and manipulated the hardware and the IDE as explained
    before, we are now ready to upload the code on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Just click on the Upload button in the IDE. You'll see the TX and RX LEDs blinking
    a bit and … your LED on your breadboard should blink as expected. This is our
    very first *HELLO LED!* example and I hope you liked it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to tweak the code a bit, you can replace the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following line, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now upload this new code again and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter itself, we learnt a bit about Arduino and microcontrollers,
    and about electricity too. That will help us in the next chapters in which we
    will talk a lot about circuits.
  prefs: []
  type: TYPE_NORMAL
- en: We also installed the IDE that we will use every time while programming Arduino
    boards and we even tested the first piece of code. We are now able to continue
    our travel by learning more about the C language itself.
  prefs: []
  type: TYPE_NORMAL
