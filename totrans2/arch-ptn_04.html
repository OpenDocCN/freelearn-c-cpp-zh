<html><head></head><body>
        

                            
                    <h1 class="header-title">Enterprise Integration Patterns</h1>
                
            
            
                
<p>This chapter is going to cover deeper topics of enterprise integration patterns. These topics are as follows:</p>
<ul>
<li>Need for integration patterns</li>
<li>Integration scenarios in enterprises</li>
<li>Main challenges in enterprise integration</li>
<li>Getting started with messaging patterns</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Need for integration patterns</h1>
                
            
            
                
<p>Present day enterprises are comprised of thousands of applications. Many of them are commercial, off-the-shelf applications; some of them are in-house applications, and some others are legacy applications that have been part of the enterprise for a very long time. Though there will be thousands of applications, it is impossible for employees to access each one of them separately using separate consoles.</p>
<p>Why are so many applications required in an enterprise? The answer to that question is that each enterprise has thousands of business functions that are impossible to be performed by a single application.Â Even an application such as an ERP can do very limited functions when compared to the actual needs of the enterprise.</p>
<p>Another reason for multiple applications is that spreading various functions across multiple applications ensures a better level of business continuity in the sense that even if one application fails; others will continue to run without causing impediment to business functions.</p>
<p>Vendors in the market have also learned the art of developing applications that are focused on catering to the needs of specific business functions. However, with the change in dynamics of the various business functions, vendors are trying to integrate multiple functions into a single business application. For example, many billing system applications started to incorporate additional functions for accounting. So in short, in the present scenario, it is not possible to define clear boundaries for applications.</p>
<p>Users, such as customers and partners, tend to access various functions without much of a concern about the underlying applications that are involved in performing the function. All these parameters warrant the need for a proper integration mechanism across various applications that are part of the enterprise ecosystem. In the past, integration used to be confined only to applications that exist within an organization.</p>
<p>In the present-day scenario, there are a host of new paradigms such as social media applications, <strong>Internet of Things</strong> (<strong>IoT</strong>) based applications, cloud-based applications, microservices-enabled applications, and so on, to name a few prominent ones. To enable seamless data sharing and support business process across the enterprise, it is necessary for enterprises to ensure that all the applications are integrated. The diverse types of applications have created a need for the enterprises to develop a robust set of capabilities for their integration platform so that they can continue to remain competitive in the present-day dynamics of agile enterprises that are in a constantly changing mode to suit the customer demands and expectations.</p>
<p>There is no shortcut for enterprise integration. It is a very broad and difficult area to handle, but inevitable for the present-day enterprise. Enterprise integration patterns do not provide any ready-made code that can be used for integrating applications. In fact, they suggest proven and tested approaches for solving enterprise integration problems. If used correctly, enterprise integration patterns can help organizations fill up the huge gap that exists between their integration vision and its actual implementation.</p>
<p>In the next section, we will examine the diverse types of scenarios that demand integration in enterprises.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration scenarios in enterprises</h1>
                
            
            
                
<p>The concept of integration is a very broad area. However, some of the most common integration scenarios in enterprises are the following:</p>
<ul>
<li>Information portals</li>
<li>Data replication</li>
<li>Shared business functions</li>
<li>Service-oriented architectures</li>
<li>Distributed business processes</li>
<li>Business-to-business integration</li>
</ul>
<p>There could be several other scenarios in enterprises based on the nature of the business and the domain handled by them. We will examine some of the prominent integration scenarios now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Information portal</h1>
                
            
            
                
<p>Many users in an organization will have the need to access more than one application to perform a single business function. For example, an HR professional may have to access several applications, such as talent acquisition, compensation and benefits, learning and development, talent branding, and so on, to pull out details pertaining to various aspects of talent management. This scenario makes it extremely difficult for them to carry out their daily business functions at pace. This is where the concept of information portals comes to their help. An information portal can access information from diverse systems, aggregate, and present them in a single view. Simple information portals divide the display screen into several zones. Each zone will display data from a specific application. These information portals also have the capability to provide drill down information in one zone based on the information selected by the user in the other zone. An example of an information portal is as follows:</p>
<div><img height="262" width="425" class=" image-border" src="img/03fb8109-c68f-48be-99dd-af235b7293cb.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Data replication</h1>
                
            
            
                
<p>In an enterprise, many applications will have a copy of the same data. For example, customer details could be there in the order management system, billing system, advertising and promotions system, and so on. So, if the address is updated in one system, it is mandatory to ensure that it is updated in other systems also. Replication is one of the techniques to ensure this required consistency. How is data replication done? Many organizations define policies that will ensure that there is continuous synchronization and replication of data at regular intervals of time to ensure that data stays up to date on all the systems. Another technique is to export data into files and import them to other systems. Another technique, called <strong>message-oriented middleware</strong>, is used to embed data records into messages and send them to other applications for synchronization purposes:</p>
<div><img height="322" width="305" class=" image-border" src="img/ab1d1900-b4c8-4c8f-9b05-44bab42eedc3.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Shared business function</h1>
                
            
            
                
<p>If the same set of data is stored in multiple systems, it leads to redundancy of data. The functions that are used to handle this data (such as a customer address in the previous example) could be implemented as a shared business function once and exposed as a service to other systems that have the same set of data.</p>
<p>A <strong>shared business function</strong> can be used as a good functionality to replace redundant data. For example, let us take the case of a customer address that is stored in multiple systems across the organization. Instead of storing the same data in multiple systems, a business function called <kbd>GetCustomerAddress</kbd> could be used by a system to fetch the data from other systems instead of permanently storing it.</p>
<p>The trade-off between the use of redundant data versus shared business functions is based on several criteria. Some of the parameters that define the criteria are the following:</p>
<ul>
<li>Amount of control over the systems where the data is present (in some situations, invoking a <kbd>shared</kbd> function could be a more intensive task than loading data into the database)</li>
<li>Rate of change of data under consideration (for example, a customer address may be needed very frequently whereas it may change only infrequently)</li>
</ul>
<p>The diagram depicting the use of a <kbd>shared</kbd> function is as follows:</p>
<div><img height="347" width="352" class=" image-border" src="img/04678409-fbeb-4195-a154-acded38281c9.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Service-oriented architecture</h1>
                
            
            
                
<p>Shared business functions, which we discussed earlier, are commonly referred to as <em>services</em>. A service is typically a well-defined function that is universally available to perform a specific operation. These services are made available for use by other systems that act as service consumers. Once a set of services are created, it is very important to ensure that they are maintained and made available to other systems in an appropriate manner. The two important aspects of service management are the following:</p>
<ul>
<li><strong>Service discovery</strong>: All services are made available in a centralized service directory through which the other applications can discover them</li>
<li><strong>Service negotiation</strong>: Each service must describe its interface in such a way that other applications in the enterprise can negotiate and set up a communication contract with them</li>
</ul>
<p><strong>Service-oriented</strong> <strong>architecture</strong> (<strong>SOA</strong>) is also a mechanism for application integration, which in turn blurs the line between integration and distributed applications. The SOA was discussed in detail in <a href="45460494-ac40-47e3-9d76-731dd2a48e12.xhtml">Chapter 7</a>, <em>Service-Oriented Architecture (SOA)</em>. The block diagram depicting SOA is as follows:</p>
<div><img height="354" width="194" class=" image-border" src="img/0f57f104-d2f3-45a8-8ff2-dffea73661e2.png"/></div>
<p>Another important aspect of service-oriented architecture is the concept of <strong>enterprise service bus</strong> (<strong>ESB</strong>), which provides connectivity between the sender and receiver components of the SOA in a loosely coupled manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Distributed business process management</h1>
                
            
            
                
<p>As we have already discussed, a single business function can be spread across several applications present in an enterprise. In such situations, it is very important to ensure coordination between the various applications. This can be done by implementing a business process management system. The business process management system will coordinate with all relevant applications that are part of a specific business function and ensure seamless execution. However, in this context, it is important to remember that there exists a very blurred line between business process management and SOA. There is always a possibility that all services are made available as services, and a business process function can be made available as an application to access all services through SOA. The diagram of a distributed process management system is depicted as follows:</p>
<div><img height="289" width="526" class=" image-border" src="img/598a0cc1-d305-4714-866a-a4dd548f800c.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The business-to-business integration</h1>
                
            
            
                
<p>As discussed at the start of the chapter, present-day enterprises need to interact with several components that are external to their ecosystem, such as customers, partners, and so on. These external elements need access to many applications that are a part of the enterprise. For example, in the case of a product organization, there will be several partners who implement the services that are part of the product. In such cases, it is very important for partners to get access to some critical enterprise applications to stay up to date with the new product features, updates, learning resources, product user forums, and groups. The reverse is also true in the sense that the enterprise also relies heavily on certain external organizations for some of their functions, and hence it is important to ensure the flow of data from certain external applications to the enterprise. Such scenarios give rise to situations that warrant a business-to-business integration. This is not a very straightforward situation like an integration of applications within an enterprise. This is primarily due to the fact that when it comes to business-to-business integration, several other aspects of security, legal implications, and governance need to be considered to enable smooth integration. The graphic depicting a business-to-business integration scenario is as follows:</p>
<div><img height="233" width="590" class=" image-border" src="img/4e2fc087-7ef2-4698-8773-5d66b75f264f.png"/></div>
<p>In the next section, we will analyze the various challenges that exist while integrating enterprise applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Main challenges in enterprise integration</h1>
                
            
            
                
<p>Some of the main challenges associated with enterprise application integration are as follows:</p>
<ul>
<li><strong>Networks are slow and unreliable</strong>: Enterprise integration applications need to transfer data from one application to another. These applications may reside in different states, countries, or continents. In such situations, data needs to be transferred through aÂ LANÂ or aÂ WAN, or a combination of both. Transferring data through diverse network topologies and protocols introduces significant transmission delays and other types of interruptions that become a stumbling block in enterprise application integration.</li>
<li><strong>Heterogeneous application platforms</strong>: While integrating multiple applications, it is important to keep in mind that each application will have its own platform and operating system. To ensure seamless integration between such applications, it is vital to ensure that data transfer between applications happens in a format that can be understood by all the applications that are involved. For this to happen, there should be a middleware component that converts data into a generic format understandable by all the applications.</li>
<li><strong>Application updates and upgrades</strong>: Applications that are integrated will constantly keep getting upgraded due to system updates. In some situations, some system upgrades will introduce drastic changes in the overall application. This may impact all other applications that are involved in the integration. It is important for integration solutions to minimize dependencies between various applications that are part of the integration. One of the ways to achieve this is by ensuring loose coupling between the applications.</li>
<li><strong>Security</strong>: Certain applications in domains such as healthcare and insurance are bound by stringent security policies and frameworks. If such applications are involved in the integration process, it is important to adhere to the security guidelines. Otherwise, it will lead to the violation of legal guidelines.</li>
</ul>
<p>Some of the key techniques that are used to overcome the aforementioned challenges are the following:</p>
<div><img height="110" width="173" class=" image-border" src="img/02d68672-1cf3-4044-88b3-ca06ea3c0131.png"/></div>
<p>Let's discuss these techniques briefly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">File transfer</h1>
                
            
            
                
<p>Here, file is the basic mode for transfer of data between applications that need to be integrated. One application will perform a write operation on a file that will be read by the other application. However, for this to happen successfully and create the necessary impact, it is important for the involved applications to agree upon the following parameters about the file:</p>
<ul>
<li>Filename and location</li>
<li>Format of the file</li>
<li>Time at which the file will be written and read</li>
<li>How the file will be deleted</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Shared database</h1>
                
            
            
                
<p>In this case, the database becomes the point at which integration happens. Multiple applications that need to be integrated share a common database schema, which is in the same database. This prevents duplicate data storage and prevents the need for data transfer from one application to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Remote procedure invocation</h1>
                
            
            
                
<p>In this case, integration of applications happens through some functionality that is exposed by one application. The other application(s) access these functionalities remotely as a remote procedure. The process of invoking these functionalities as a remote procedure is called <strong>remote procedure invocation</strong>. Remote procedure invocation occurs in real time and is a synchronous communication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Messaging</h1>
                
            
            
                
<p>In this case, integration of applications happens through messaging. One of the applications publishes a message to a message channel that can be accessed by all other applications. Other applications access the message channel and reach the message at some later point in time. The only criteria here is that the applications that are involved should have a predefined agreement on the message channel and the format of the message that is sent to the channel. In the next section, we will dive deep into the concepts of messaging and how enterprise applications can be integrated using the concept of messaging. In the next section, we will dwell deep into the various types of messaging patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started with messaging patterns</h1>
                
            
            
                
<p>Messaging is a reliable technique that is used for interconnecting applications using the concept of packets called <strong>messages</strong>. These packets are sent to channels, which are logical pathways providing interconnection between the various applications. These channels are also called <strong>queues</strong>. Several messages can be queued up in a channel and can be made accessible to multiple applications at the same point in time. There are two main types of applications in messaging, they are:</p>
<ul>
<li>Sender/producer</li>
<li>Receiver/consumer</li>
</ul>
<p>A sender is an application that sends a message to the channel. A receiver is an application that reads the message that is sent to the channel. Messaging is an asynchronous mode of communication, meaning it is not necessary that the receiver should read the message from the channel as soon as it reaches the channel.</p>
<p>A message could be any kind of data structure, such as an array, string, or object. Every message contains two parts:</p>
<ul>
<li>Header</li>
<li>Body</li>
</ul>
<p>The header contains metadata about the message, such as details of the sender, receiver, timestamp, and so on. This information is used by the messaging system but is usually ignored by the applications. The message body contains the actual data that is sent by the application. The body of the message is ignored by the messaging system but is used by the applications.</p>
<p>Messaging capabilities are provided to a system by a specialized software application called <strong>message-oriented middleware</strong> (<strong>MOM</strong>). MOM is also called aÂ <strong>messaging system</strong>. MOM is required to ensure smooth transmission of messages across applications. One of the main reasons for the existence of MOM is the unreliable state of networks that interconnect the systems. Even if a message is sent by an application, it is not necessary that it reaches the intended destination if the network is not proper. MOM helps to overcome thisÂ network-related limitation and other limitations, and ensures that a message is repeatedly transmitted until it reaches its destination. The communication of applications through messaging is depicted in the following diagram:</p>
<div><img class=" image-border" src="img/e88c15a4-ba46-4a02-8398-361b0d9d6988.png"/></div>
<p>The following are the five steps involved in message transmission:</p>
<div><img height="121" width="288" class=" image-border" src="img/4bab54a5-c168-46e8-b19a-74f71ef6c51e.png"/></div>
<p>In each of these steps, the following activities are performed:</p>
<ol>
<li><strong>Create</strong>: In this step, the sender or producer adds a header and data and creates the message</li>
<li><strong>Send</strong>: In this step, the sender sends out the message to the channel</li>
</ol>
<ol start="3">
<li><strong>Deliver</strong>: In this step, MOM moves the message from the sender's system to the receiver's system making the message available for the receiver</li>
<li><strong>Receive</strong>: In this step, the receiver or consumer reads the message from the channel</li>
<li><strong>Process</strong>: In this step, the receiver extracts the data from the message</li>
</ol>
<p>In the next section, we will examine the prominent messaging patterns that are used in the design of enterprise systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pipe and filter pattern</h1>
                
            
            
                
<p>In many situations, a single event could trigger a series of actions and each will perform a specific function. So, pipe and filter patterns are usedÂ to handle such situations that require complex processing of messages while maintaining flexibility and independence. A large task is split into a series of smaller, sequential, independent tasks (filters) that are connected by channels (pipes). The diagram of the pipe and filter pattern is depicted as follows:</p>
<div><img height="120" width="567" class=" image-border" src="img/cd3f71a2-3eca-469b-82ac-87645a7d3cff.png"/></div>
<p>Each filter has a simple interface that consists of an inbound pipe that receives, processes, and publishes the result to the outbound pipe. The role of a pipe is to connect one filter to the next. In the case of the pipe and filter pattern, all components use the same external interface, and hence they can be present in different solutions. These solutions can be interconnected by means of different pipes. The connection outlet that provides a connection between the pipe and filter is called a <strong>port</strong>. Typically, each filter has one input port and one output port.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message router pattern</h1>
                
            
            
                
<p>This pattern is used in situations where sequential execution of steps may not always be possible. In some situations, the output of a filter may have to be passed to one of the several pipes based on the fulfillment of certain criteria or conditions. In such situations, message router patterns are used. The diagram depicting the message router pattern is as follows:</p>
<div><img class=" image-border" src="img/2f12d258-0441-477d-ad13-480b00b5e7e3.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Message translator pattern</h1>
                
            
            
                
<p>In the beginning of the chapter, we discussed scenarios where there could be a need to integrate certain third-party applications/partner applications to some of the applications that are part of the enterprise. These applications will use diverse data models and may sometimes use totally different data formats for communication. For present-day agile enterprises, it is necessary to use patterns that can interconnect diverse types of applications by converting data from one format to another. This is where theÂ <strong>message translator pattern</strong> plays a key role. TheÂ message translator pattern acts as a special filter between other filters or applications and translates data from one format to another. The diagram depicting theÂ message translator pattern is given as follows:</p>
<div><img class=" image-border" src="img/6ed3f99e-bc54-48e3-bcbf-136d54fee73e.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Message endpoint pattern</h1>
                
            
            
                
<p>Applications in an enterprise communicate with each other by sending messages through a message channel. But the next issue is that there needs to be a mechanism in place that will help applications to connect to the message channel. This is applicable for the sender application to send messages and for the receiver application to receive messages. This is where the message endpoint pattern comes into the picture. The message endpoint acts as a client of the messaging system, which the sender and receiver application can use to send and receive messages. Message endpoint code is accessible to both the application and the MOM's client API. The remaining application knows nothing about message formats, messaging channels, or any other details of the applications with which it is communicating through messaging. It just knows that it has sent some data to another application or that it will receive data from another application. Message endpoint code takes the data, converts it into a message, and sends it to the correct messaging channel. Similarly, on the receiving end, the message endpoint receives the message, extracts the contents, and gives it to the application. The diagram depicting the message endpoint pattern is as follows:</p>
<div><img class=" image-border" src="img/3f01076c-d3f9-4fb6-b55e-aea16d1946b3.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-to-point channel pattern</h1>
                
            
            
                
<p>Consider the scenario in which an application is using messaging to make a remote procedure call. In this situation, it is necessary to ensure that only one receiver will perform the call. This is where the <strong>point-to-point channel</strong> pattern helps us. If a message is sent through a point-to-point channel, it ensures that only one receiver will receive the message. In case the channel has multiple receivers, only one of them will be able to receive the message. If multiple receivers try to consume the message, the channel will make sure that only one of them will be successful in their attempts. But this does not prevent the channel from having multiple receivers and them receiving multiple messages concurrently. The only criteria here is that only one receiver will receive a specific message:</p>
<div><img height="126" width="680" class=" image-border" src="img/c5f7a89b-ab4c-4abf-aa70-2491f1e8c2fb.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Publish-subscribe channel pattern</h1>
                
            
            
                
<p>This pattern will be of use for applications that use messaging to announce events. The announcement of events will involve sending messages to multiple receivers simultaneously. If the message is sent on a publish-subscribeÂ channel, a copy of the message will be sent to each receiver:</p>
<div><img height="306" width="587" class=" image-border" src="img/0035adc9-cfb5-4b78-8c4c-599b05d74cba.png"/></div>
<p>A publish-subscribe channel works basically like a broadcast mechanism. It has one input channel which is split into several output channels, one for each subscriber. When an event is published in the channel, a copy of the message is delivered to each of the output channels that are attached to it. Each output channel has only one subscriber attached to it. Each subscriber can consume the message only once. In this way, each subscriber gets a message only once and the message copies disappear from the channel once they are consumed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Datatype channel pattern</h1>
                
            
            
                
<p>If several types of data are transmitted through a channel, it is important to differentiate the various formats of data. This is where the datatype channel pattern comes in handy. The diagram of a datatype channel pattern is depicted as follows:</p>
<div><img class=" image-border" src="img/3a5f93fc-1daa-4709-9370-858824766d29.png"/></div>
<p>If a datatype channel is used for each type of data, messages on a specific channel will contain only the same type of data. The sender should know the type of data and send it through the appropriate channel for that type of data. The receiver should be able to know the type of data based on the channel from which it received the data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message bus patterns</h1>
                
            
            
                
<p>In enterprises, there will be several disparate systems. These systems should be able to communicate and share data with one another and operate seamlessly for the effective functioning of the enterprise. This is where the message bus pattern comes in handy. The architecture of the message bus pattern is depicted in the following diagram:</p>
<div><img class=" image-border" src="img/89a0d428-a63a-44ef-ace0-e23bce53b1b7.png"/></div>
<p>If the various applications are interconnected using a message bus, it allows them to communicate seamlessly using messages. The following are the main components of a message bus:</p>
<ul>
<li><strong>Common data model</strong></li>
<li><strong>Common command set</strong></li>
<li><strong>Messaging infrastructure</strong>: This component allows the various systems to communicate using a shared set of interfaces</li>
</ul>
<p>The concept of a message bus is very similar to that of a communication bus which is used in a computer. The communication bus facilitates communication among the various components of a computer such as CPU, memory, peripheral devices, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Command message patterns</h1>
                
            
            
                
<p>If an application wants to invoke the functionality provided by another application, the most commonly used method is remote procedure invocation. But if remote procedure invocation has to be used along with the concept of messaging, command message patterns are very useful. The diagram of theÂ <strong>command message</strong> pattern is depicted as follows:</p>
<div><img height="132" width="441" class=" image-border" src="img/48ab2050-00ff-430f-962e-f2112b71a30e.png"/></div>
<p>A command message is a message that is reliably used to invoke a procedure that is running in another application. There is no specific type for aÂ command message. Command messages are normal messages that have a command embedded in them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Event message patterns</h1>
                
            
            
                
<p>Several applications communicate with one another using events. If event-based communication happens from using messages, then event message patterns are used. The event message pattern is depicted in the following diagram:</p>
<div><img height="213" width="436" class=" image-border" src="img/b675b2ad-762b-4724-b6f5-fc78a230a087.png"/></div>
<p>In an event message pattern, if the subject has to announce an event, it will first create an event object. This object is then wrapped in a message and sent on a channel. The observer will receive the event from the channel and process it. Messaging in events does not alter the event notification; it just ensures that the notification reaches the observer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Request-reply pattern</h1>
                
            
            
                
<p>When applications communicate through messaging, it is typically one-way communication. Suppose if the applications want a two-way communication, then a request-reply pattern is used. In a request-reply pattern, the request message and the reply message will have their own channels. The diagram of a request-reply pattern is depicted as follows:</p>
<div><img height="253" width="551" class=" image-border" src="img/e49510e7-dfd4-4bde-b7d2-bde80a4f8e45.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Content-based router pattern</h1>
                
            
            
                
<p>In many enterprises, a single function is spread across several systems. In such situations, it is important to ensure that the message goes through each of the systems that contain the function. In such situations, the content-based router pattern becomes very helpful. The content-based router pattern is depicted as follows:</p>
<div><img height="191" width="473" class=" image-border" src="img/0b0ea4aa-52f2-4a84-8f94-6b8ece299f6f.png"/></div>
<p>The content-based router pattern examines the content of the message and then routes the message onto the correct channel based on the data that is contained in the message. The parameters on which the message is routed could be one of the following:</p>
<ul>
<li>Existence of certain data values in specific fields</li>
<li>Presence or absence of certain fields in the message</li>
</ul>
<p>It is very important to ensure that in a content-based router, the routing function that is implemented in the router should be easy to maintain. It is also possible to maintain a content-based router in the form of a rules engine that calculates the destination channel based on a set of pre-configured rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message filter pattern</h1>
                
            
            
                
<p>In many scenarios, there will be situations in which we are interested in receiving some kind of promotional messages/discounting messages, say for example from an e-commerce website based on a certain product that you may be interested in buying. But this may not be applicable to all messages. So in such situations, it is important to ensure that the unwanted messages get blocked or filtered. In such situations, the message filter pattern becomes very useful. The diagram depicting the message filter pattern is given as follows:</p>
<div><img src="img/08924386-a3c8-4f1a-aa26-35ccfcda4a63.png"/></div>
<p>The message filter has only a single output channel. If the data present in the message matches the specific output criteria that are mentioned by the message filter, the message is routed to the output channel, else it is discarded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Resequencer pattern</h1>
                
            
            
                
<p>When a message routing pattern is used, messages get routed through several systems based on the fulfillment of certain criteria or rules. But when messages pass through several systems, there is a likelihood that they get out of order. In these situations, theÂ <strong>resequencer</strong> pattern comes in handy. The diagram depicting theÂ resequencer pattern is given as follows:</p>
<div><img class=" image-border" src="img/6fe3ffd4-a06f-484b-a006-ce7bca2dd763.png"/></div>
<p>The resequencer is a stateful filter that can be used to reorder messages so that they can be published in a specific sequence to the output channel. The resequencer contains an internal buffer that stores a sequence of messages until the complete sequence is obtained. The in-sequence messages are published immediately to the output channel. The out-of-sequence messages are kept in the internal buffer until they are placed in sequence and then they are sent to the output channel. The resequencer just makes the message in-sequence; it does not generally modify the contents of the message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Polling consumer pattern</h1>
                
            
            
                
<p>There will be several situations in which the application may not always be ready to consume messages. In such situations, the application would like to reach a state of readiness before it starts consuming messages. In such situations, the polling consumer pattern becomes very helpful. The diagram of a polling consumer pattern is depicted as follows:</p>
<div><img height="133" width="495" class=" image-border" src="img/5d9c4c53-a8d1-40ef-bfb8-881c8b3ff469.png"/></div>
<p>In this pattern, the application uses a polling consumer, which makes a call as and when it is ready to receive a message. The polling consumer is also known as a <strong>synchronous receiver</strong>. This is because the receiver thread is in a blocked state until a message is received. Most of the messaging APIs provide a <kbd>receive</kbd> method, which blocks until a message is delivered.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Channel adapter</h1>
                
            
            
                
<p>If applications communicate with the help of messaging, it is necessary to ensure that the applications can connect to the messaging system to send and receive messages. This is where theÂ <strong>channel adapter</strong> is helpful. The diagram depicting theÂ channel adapter pattern is shown as follows:</p>
<div><img height="149" width="515" class=" image-border" src="img/5ae36fb1-af71-4146-a095-16859e79f39a.png"/></div>
<p>A channel adapter should be able to access the application's API or data and publish messages on a channel based on this data. It should also be able to invoke the functionality inside the application and receive messages. The adapter ideally acts as a client to the messaging system. TheÂ channel adapter invokes the functions of the application through an interface that is supplied by the application. This helps an application to remain integrated with a messaging system if it has a proper channel adapter. In the next section, we will focus on mobile integration patterns, that is, patterns that are used for integrating mobile devices to enterprise systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mobile integration pattern</h1>
                
            
            
                
<p>We need a faster way for mobile devices to integrate with enterprise services, and this necessitates the need for a mobile integration pattern. When we talk about the integration of mobile services with enterprises, there are two main possibilities that could arise during the integration:</p>
<ul>
<li>A mobile application that is integrated with some function of the enterprise sends a request message to the enterprise system and gets a response in return</li>
<li>An enterprise system sends a push notification message to a mobile application</li>
</ul>
<p>This flow is shown in the following diagram:</p>
<div><img height="194" width="343" class=" image-border" src="img/e062f8b9-83da-497b-9620-d222772195a9.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Request-response pattern</h1>
                
            
            
                
<p>To define a request-response pattern, it is necessary to ensure that mobile-ready interfaces are present in the enterprise services that are created in the ESB. This pattern provides support for the integration of mobile services in an ESB architecture. A special type of adapter customized for mobile services called a <strong>mobile integration adapter</strong> helps to integrate mobile applications with the mobile-related services that are running in the ESB. The major steps involved in this mobile integration are depicted in the following diagram:</p>
<div><img height="252" width="419" class=" image-border" src="img/d55b340d-4615-48f4-8567-4ff11b773d15.png"/></div>
<p>Here is how the integration happens:</p>
<ol>
<li>As a first step, the mobile adapter sends the inbound request directly to the enterprise service.</li>
<li>Then the enterprise service present in the ESB establishes a connection with the required backend systems to process the inbound request. The ESB also works with the backend systems to get a response.</li>
<li>At last, the ESB sends the response to the mobile adapter which in turn passes the response back to the mobile application.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a push notification pattern</h1>
                
            
            
                
<p>Push notification patterns are used if an enterprise application wants to send push notifications to the mobile devices. The steps involved in defining the push notification are depicted in the following diagram:</p>
<div><img height="295" width="541" class=" image-border" src="img/5cc4d665-0a99-4f7e-b45b-53c05609e9d7.png"/></div>
<p>Enterprise applications typically use a backend service that is running on the mobile integration server to push the notification messages to devices. The following are the main steps in the workflow of the process:</p>
<ol>
<li>The enterprise application sends a push notification to the mobile device using the ESB and mobile backend service</li>
<li>Once the ESB receives the notification, it calls the mobile backend service to send push notifications to the mobile device</li>
<li>Messages pass through the mobile integration server to reach the mobile application and the mobile device</li>
</ol>
<p>At the start of the chapter, we discussed several types of external applications getting integrated with the enterprise systems. In the next section, we will have an overview of the API management pattern. In this section, we will focus briefly on the integration aspects while using microservices/API-based design concepts in architecture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API management pattern</h1>
                
            
            
                
<p>The API management pattern integrates applications with enterprise systems and other cloud-based services using APIs. The following are the main components of the API management pattern:</p>
<ul>
<li>API management portal</li>
<li>API user</li>
<li>Enterprise services</li>
</ul>
<p>The consumer of each API service first sends a request to the API management portal. The API management portal interacts with the enterprise service before sending a response to the consumer. APIs use industry-standard formats for messages such as SOAP for web services and XML or JSON for representational state transfer. The API management portal acts as a simple proxy and helps to forward request and response messages to and from the backend.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>At the start of the chapter, we examined several types of integration scenarios that exist in enterprises. Some of the key integration scenarios that exist in enterprises are the following:</p>
<ul>
<li>Information portals</li>
<li>Data replication</li>
<li>Shared business functions</li>
<li>Service-oriented architectures</li>
<li>Distributed business processes</li>
<li>Business-to-business integration</li>
</ul>
<p>After covering these topics, the main challenges faced in application integration were discussed. The techniques to overcome these challenges were also discussed. In the next section of the chapter, we discussed several types of messaging patterns at length. After messaging patterns, prominent mobile integration patterns were discussed. We concluded the chapter with a brief discussion of the API management pattern, which is the most recent trend in the industry.</p>


            

            
        
    </body></html>