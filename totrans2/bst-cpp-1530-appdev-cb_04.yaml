- en: Chapter 4. Compile-time Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 编译时技巧
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Checking sizes at compile time
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时检查大小
- en: Enabling the usage of templated functions for integral types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用模板函数对整型类型的用法
- en: Disabling templated functions' usage for real types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用模板函数对真实类型的用法
- en: Creating a type from number
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数字创建一个类型
- en: Implementing a type trait
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个类型特性
- en: Selecting an optimal operator for a template parameter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择模板参数的最佳运算符
- en: Getting a type of expression in C++03
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++03中获取表达式的类型
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we'll see some basic examples on how the Boost libraries can
    be used in compile-time checking, for tuning algorithms, and in other metaprogramming
    tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些基本示例，说明如何使用Boost库在编译时检查、调整算法以及在其他元编程任务中。
- en: Some readers may ask, "Why shall we care about compile-time things?". That's
    because the released version of the program is compiled once, and runs multiple
    times. The more we do at compile time, the less work remains for runtime, resulting
    in much faster and reliable programs. Runtime checks are executed only if a part
    of the code with check is executed. Compile-time checks won't give you to compile
    a program with error.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会问，“我们为什么要关心编译时的事情？”这是因为程序的发布版本只编译一次，但运行多次。我们在编译时做得越多，运行时的工作就越少，从而产生更快、更可靠的程序。只有在代码中包含检查的部分被执行时，才会执行运行时检查。编译时检查不会让你编译出一个有错误的程序。
- en: This chapter is possibly one of the most important. Understanding Boost sources
    and other Boost-like libraries is impossible without it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这章可能是最重要的章节之一。没有它，理解Boost源和其他类似Boost的库是不可能的。
- en: Checking sizes at compile time
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时检查大小
- en: 'Let''s imagine that we are writing some serialization function that stores
    values in buffer of a specified size:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在编写一些序列化函数，该函数将值存储在指定大小的缓冲区中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code has the following troubles:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有以下问题：
- en: The size of the buffer is not checked, so it may overflow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区的大小没有被检查，所以它可能会溢出
- en: This function can be used with non-plain old data (POD) types, which would lead
    to incorrect behavior
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数可以与非平凡旧数据（POD）类型一起使用，这可能导致不正确的行为
- en: 'We may partially fix it by adding some asserts, for example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一些断言来部分修复它，例如：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But, this is a bad solution. The `BufSizeV` and `sizeof(value)` values are known
    at compile time, so we can potentially make this code to fail compilation if the
    buffer is too small, instead of having a runtime assert (which may not trigger
    during debug, if function was not called, and may even be optimized out in release
    mode, so very bad things may happen).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是一个不好的解决方案。`BufSizeV`和`sizeof(value)`的值在编译时是已知的，因此我们可以潜在地使代码在缓冲区太小的情况下无法编译，而不是有运行时断言（如果在调试期间没有调用该函数，它可能不会触发，甚至在发布模式下可能被优化掉，所以会发生非常糟糕的事情）。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires some knowledge of C++ templates and the `Boost.Array` library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要一些关于C++模板和`Boost.Array`库的知识。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s use the `Boost.StaticAssert` and `Boost.TypeTraits` libraries to correct
    the solutions, and the output will be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Boost.StaticAssert`和`Boost.TypeTraits`库来纠正解决方案，输出将如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BOOST_STATIC_ASSERT` macro can be used only if an assert expression can
    be evaluated at compile time and implicitly convertible to `bool`. It means that
    you may only use `sizeof()`, static constants, and other constant expressions
    in it. If assert expression will evaluate to `false`, `BOOST_STATIC_ASSERT` will
    stop our program compilation. In case of `serialization()` function, if first
    static assertion fails, it means that someone used that function for a very small
    buffer and that code must be fixed by the programmer. The C++11 standard has a
    `static_assert` keyword that is equivalent to Boost's version.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSERT`宏只能在断言表达式可以在编译时评估并且隐式转换为`bool`的情况下使用。这意味着你只能在其中使用`sizeof()`、静态常量和其他常量表达式。如果断言表达式评估为`false`，`BOOST_STATIC_ASSERT`将停止我们的程序编译。在`serialization()`函数的情况下，如果第一个静态断言失败，这意味着有人为非常小的缓冲区使用了该函数，并且该代码必须由程序员修复。C++11标准有一个与Boost版本等效的`static_assert`关键字。'
- en: 'Here are some more examples:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the `BOOST_STATIC_ASSERT` macro's assert expression has a comma sign in it,
    we must wrap the whole expression in additional brackets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BOOST_STATIC_ASSERT`宏的断言表达式中有逗号符号，我们必须将整个表达式用额外的括号括起来。
- en: The last example is very close to what we can see on the second line of the
    `serialize()` function. So now it is time to know more about the `Boost.TypeTraits`
    library. This library provides a large number of compile-time metafunctions that
    allow us to get information about types and modify types. The metafunctions usages
    look like `boost::function_name<parameters>::value` or `boost::function_name<parameters>::type`.
    The metafunction `boost::is_pod<T>::value` will return `true`, only if `T` is
    a POD type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子非常接近我们在`serialize()`函数的第二行看到的。所以现在是我们更多地了解`Boost.TypeTraits`库的时候了。这个库提供大量编译时元函数，允许我们获取类型信息并修改类型。元函数的使用看起来像`boost::function_name<parameters>::value`或`boost::function_name<parameters>::type`。元函数`boost::is_pod<T>::value`只有在`T`是POD类型时才会返回`true`。
- en: 'Let''s take a look at some more examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多的例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some compilers may compile this code even without the `typename` keyword, but
    such behavior violates the C++ standard, so it is highly recommended to write
    `typename`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器甚至可能在没有`typename`关键字的情况下编译此代码，但这种行为违反了C++标准，因此强烈建议使用`typename`。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `BOOST_STATIC_ASSSERT` macro has a more verbose variant called `BOOST_STATIC_ASSSERT_MSG`
    that will output an error message in the compiler log (or in the IDE window) if
    assertion fails. Take a look at the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSSERT`宏有一个更详细的变体，称为`BOOST_STATIC_ASSSERT_MSG`，如果断言失败，它将在编译器日志（或IDE窗口）中输出错误消息。看看下面的代码：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code will give the following result during compilation on the
    g++ compiler in the C++11 mode:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11模式下，使用g++编译器编译前面的代码将给出以下结果：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Neither `BOOST_STATIC_ASSSERT`, nor `BOOST_STATIC_ASSSERT_MSG`, nor any of the
    type traits library imply runtime penalty. All those functions are executed at
    compile time, and won't add a single assembly instruction in binary file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSSERT`、`BOOST_STATIC_ASSSERT_MSG`以及类型特性库中的任何函数都不会产生运行时惩罚。所有这些函数都是在编译时执行的，不会在二进制文件中添加任何汇编指令。'
- en: The `Boost.TypeTraits` library was partially accepted into the C++11 standard;
    you may thus find traits in the `<type_traits>` header in the `std::` namespace.
    C++11 `<type_traits>` has some functions that do not exist in `Boost.TypeTraits`,
    but some metafunctions exist only in Boost. When there is a similar function in
    Boost and STL, the STL version (in rare cases) may work slightly better because
    of compiler-specific intrinsics usage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.TypeTraits`库部分被纳入C++11标准；因此，你可能会在`std::`命名空间中的`<type_traits>`头文件中找到特性。C++11
    `<type_traits>`有一些函数在`Boost.TypeTraits`中不存在，但一些元函数只在Boost中存在。当Boost和STL中有类似函数时，STL版本（在罕见情况下）可能因为编译器特定的内建函数使用而稍微好一些。'
- en: As we have already mentioned earlier, the `BOOST_STATIC_ASSERT_MSG` macro was
    also accepted into C++11 (and even into C11) as the keyword `static_assert(expression,
    message)`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`BOOST_STATIC_ASSERT_MSG`宏也被纳入C++11（甚至C11）作为`static_assert(expression,
    message)`关键字。
- en: Use the Boost version of those libraries if you need portability across compilers
    or metafunctions that does not exist in STLs `<type_traits>`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要跨编译器的可移植性或STL `<type_traits>`中不存在的元函数，请使用这些库的Boost版本。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipes in this chapter will give you more examples and ideas on how
    static asserts and type traits may be used
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章接下来的食谱将给出更多关于如何使用静态断言和类型特性的例子和想法。
- en: Read the official documentation of `Boost.StaticAssert` for more examples at
    [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta)[ticassert.html](http://ticassert.html)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请阅读`Boost.StaticAssert`的官方文档，以获取更多示例，链接为[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta)[ticassert.html](http://ticassert.html)
- en: Enabling the usage of templated functions for integral types
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用对整型模板函数的使用
- en: 'It''s a common situation, when we have a templated class that implements some
    functionality. Have a look at the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的情况，当我们有一个实现了某些功能的模板类。看看下面的代码片段：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After execution of the preceding code, we have additional two optimized versions
    of that class, one for integral, and another for real types:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码之后，我们有了该类的两个额外的优化版本，一个用于整型，另一个用于实型：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now the question, how to make the compiler to automatically choose the correct
    class for a specified type, arises.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何让编译器自动为指定的类型选择正确的类。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires the knowledge of C++ templates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要了解C++模板的知识。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll be using `Boost.Utility` and `Boost.TypeTraits` to resolve this problem:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Boost.Utility` 和 `Boost.TypeTraits` 来解决这个问题：
- en: 'Let''s start with including headers:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含头文件开始：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s add an additional template parameter with default value to our generic
    implementation:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在通用实现中添加一个具有默认值的额外模板参数：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Modify optimized versions in the following way, so that now they will be treated
    by the compiler as template partial specializations:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改优化版本，这样编译器现在会将它们视为模板部分特化：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And, that''s it! Now the compiler will automatically choose the correct class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！现在编译器将自动选择正确的类：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::enable_if_c` template is a tricky one. It makes use of the **SFINAE**
    (**Substitution Failure Is Not An Error**) principle, which is used during template
    instantiation. Here is how the principle works: if an invalid argument or return
    type is formed during the instantiation of a function or class template, the instantiation
    is removed from the overload resolution set and does not cause a compilation error.
    Now let''s get back to the solution, and we''ll see how it works with different
    types passed to the `data_processor` class as the `T` parameter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::enable_if_c` 模板是一个有点棘手的模板。它利用了 **SFINAE（Substitution Failure Is Not
    An Error**） 原则，该原则在模板实例化过程中被使用。以下是该原则的工作方式：如果在函数或类模板的实例化过程中形成了无效的参数或返回类型，则实例化将从重载解析集中移除，并且不会导致编译错误。现在让我们回到解决方案，看看它是如何与传递给
    `data_processor` 类的 `T` 参数的不同类型一起工作的。'
- en: If we pass an `int` as `T` type, first the compiler will try to instantiate
    template partial specializations, before using our nonspecialized (generic) version.
    When it tries to instantiate a `float` version, the `boost::is_float<T>::value`
    metafunction will return `false`. The `boost::enable_if_c<false>::type` metafunction
    cannot be correctly instantiated (because `boost::enable_if_c<false>` has no `::type`),
    and that is the place where SFINAE will act. Because class template cannot be
    instantiated, and this must be interpreted as not an error, compiler will skip
    this template specialization. Next, partial specialization is the one that is
    optimized for integral types. The `boost::is_integral<T>::value` metafunction
    will return `true`, and `boost::enable_if_c<true>::type` can be instantiated,
    which makes it possible to instantiate the whole `data_processor` specialization.
    The compiler found a matching partial specialization, so it does not need to try
    to instantiate the nonspecialized method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `int` 作为 `T` 类型传递，编译器首先会尝试实例化模板部分特化，然后再使用我们的非特化（通用）版本。当它尝试实例化一个 `float`
    版本时，`boost::is_float<T>::value` 元函数将返回 `false`。`boost::enable_if_c<false>::type`
    元函数无法正确实例化（因为 `boost::enable_if_c<false>` 没有提供 `::type`），这就是 SFINAE 发挥作用的地方。由于类模板无法实例化，这必须被解释为不是错误，编译器将跳过这个模板特化。接下来，部分特化是针对整型类型进行优化的。`boost::is_integral<T>::value`
    元函数将返回 `true`，`boost::enable_if_c<true>::type` 可以实例化，这使得可以实例化整个 `data_processor`
    特化。编译器找到了匹配的部分特化，因此它不需要尝试实例化非特化方法。
- en: Now, let's try to pass some nonarithmetic type (for example, `const char *`),
    and let's see what the compiler will do. First the compiler will try to instantiate
    template partial specializations. The specializations with `is_float<T>::value`
    and `is_integral<T>::value` will fail to instantiate, so the compiler will try
    to instantiate our generic version, and will succeed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试传递一些非算术类型（例如，`const char *`），看看编译器会做什么。首先编译器会尝试实例化模板部分特化。具有 `is_float<T>::value`
    和 `is_integral<T>::value` 的特化将无法实例化，因此编译器将尝试实例化我们的通用版本，并且会成功。
- en: Without `boost::enable_if_c<>`, all the partial specialized versions may be
    instantiated at the same time for any type, which leads to ambiguity and failed
    compilation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `boost::enable_if_c<>`，对于任何类型，所有部分特化的版本都可能同时实例化，这会导致歧义和编译失败。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using templates and compiler reports that cannot choose between two
    template classes of methods, you probably need `boost::enable_if_c<>`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用模板并且编译器报告无法在两个模板类的方法之间进行选择，你可能需要 `boost::enable_if_c<>`。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another version of this method is called `boost::enable_if` (without `_c` at
    the end). Difference between them is that `enable_if_c` accepts constant as a
    template parameter; however, the short version accepts an object that has a `value`
    static member. For example, `boost::enable_if_c<boost::is_integral<T>::value >::type`
    is equal to `boost::enable_if<boost::is_integral<T> >::type>`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一种版本被称为 `boost::enable_if`（末尾没有 `_c`）。它们之间的区别在于 `enable_if_c` 接受常量作为模板参数；然而，简短版本接受一个具有
    `value` 静态成员的对象。例如，`boost::enable_if_c<boost::is_integral<T>::value >::type` 等于
    `boost::enable_if<boost::is_integral<T> >::type>`。
- en: C++11 has an `std::enable_if` defined in the `<type_traits>` header, which behaves
    exactly like `boost::enable_if_c`. No difference between them exists, except that
    Boost's version will work on non C++11 compilers too, providing better portability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 在 `<type_traits>` 头文件中定义了 `std::enable_if`，其行为与 `boost::enable_if_c` 完全相同。它们之间没有区别，除了
    Boost 的版本可以在非 C++11 编译器上工作，提供更好的可移植性。
- en: All the enabling functions are executed only at compile time and do not add
    a performance overhead at runtime. However, adding an additional template parameter
    may produce a bigger class name in `typeid(T).name()`, and add an extremely tiny
    performance overhead when comparing two `typeid()` results on some platforms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有启用函数仅在编译时执行，不会在运行时增加性能开销。然而，添加一个额外的模板参数可能会在 `typeid(T).name()` 中产生更大的类名，并且在某些平台上比较两个
    `typeid()` 结果时可能会增加极小的性能开销。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Next recipes will give you more examples on `enable_if` usage.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例将给出更多关于 `enable_if` 用法的示例。
- en: You may also consult the official documentation of `Boost.Utility`. It contains
    many examples and a lot of useful classes (which are used widely in this book).
    Read about it at [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以查阅 `Boost.Utility` 的官方文档。它包含许多示例和许多有用的类（这些类在这本书中得到了广泛的应用）。请参阅[http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)。
- en: You may also read some articles about template partial specializations at [http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以阅读一些关于模板部分特殊化的文章，请参阅[http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx)。
- en: Disabling templated functions' usage for real types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用模板函数对真实类型的用法
- en: We continue working with Boost metaprogramming libraries. In the previous recipe,
    we saw how to use `enable_if_c` with classes, now it is time to take a look at
    its usage in template functions. Consider the following example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 Boost 元编程库。在前一个示例中，我们看到了如何使用 `enable_if_c` 与类一起使用，现在该看看它在模板函数中的用法了。考虑以下示例。
- en: 'Initially, we had a template function that works with all the available types:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们有一个适用于所有可用类型的模板函数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we write code using `process_data` function, we use an optimized `process_data`
    version for types that do have an `operator +=` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `process_data` 函数编写代码时，我们为具有 `operator +=` 函数的类型使用优化的 `process_data`
    版本：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But, we do not want to change the already written code; instead whenever it
    is possible, we want to force the compiler to automatically use optimized function
    in place of the default one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不想改变已经编写的代码；相反，只要可能，我们希望强制编译器自动使用优化函数来替代默认函数。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe to get an idea of what `boost::enable_if_c` does, and
    for understanding the concept of SFINAE. However, the knowledge of templates is
    still required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前一个示例以了解 `boost::enable_if_c` 的作用，并理解 SFINAE 的概念。然而，仍然需要了解模板知识。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Template magic can be done using the Boost libraries. Let''s see how to do
    it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Boost 库可以完成模板魔法。让我们看看如何做：
- en: 'We will need the `boost::has_plus_assign<T>` metafunction and the `<boost/enable_if.hpp>`
    header:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 `boost::has_plus_assign<T>` 元函数和 `<boost/enable_if.hpp>` 头文件：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we will disable default implementation for types with plus assign operator:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将禁用具有加法赋值运算符的类型的默认实现：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Enable optimized version for types with plus assign operator:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为具有加法赋值运算符的类型启用优化版本：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, users won''t feel the difference, but the optimized version will be used
    wherever possible:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用户不会感觉到差异，但优化版本将在可能的情况下被使用：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::disable_if_c<bool_value>::type` metafunction disables method, if
    `bool_value` equals to `true` (works just like `boost::enable_if_c<!bool_value>::type`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::disable_if_c<bool_value>::type` 元函数在 `bool_value` 等于 `true` 时禁用方法（与
    `boost::enable_if_c<!bool_value>::type` 的工作方式相同）。'
- en: If we pass a class as the second parameter for `boost::enable_if_c` or `boost::disable_if_c`,
    it will be returned via `::type` in case of successful evaluation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个类作为 `boost::enable_if_c` 或 `boost::disable_if_c` 的第二个参数传递，在成功评估的情况下，它将通过
    `::type` 返回。
- en: Let's go through the instantiation of templates step-by-step. If we pass `int`
    as `T` type, first the compiler will search for function overload with required
    signature. Because there is no such function, the next step will be to instantiate
    a template version of this function. For example, the compiler started from our
    second (optimized) version; in that case, it will successfully evaluate the `typename
    boost::enable_if_c<boost::has_plus_assign<T>::value, T>::type` expression, and
    will get the `T` return type. But, the compiler won't stop; it will continue instantiation
    attempts. It'll try to instantiate our first version of function, but will get
    a failure during evaluation of `typename boost::disable_if_c<boost::has_plus_assign<T>::value`.
    This failure won't be treated as an error (refer SFINAE). As you can see, without
    `enable_if_c` and `disable_if_c`, there will be ambiguity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解模板实例化的过程。如果我们传递 `int` 作为 `T` 类型，首先编译器将搜索具有所需签名的函数重载。因为没有这样的函数，下一步将是实例化这个函数的模板版本。例如，编译器从我们的第二个（优化）版本开始；在这种情况下，它将成功评估
    `typename boost::enable_if_c<boost::has_plus_assign<T>::value, T>::type` 表达式，并将得到
    `T` 返回类型。但是，编译器不会停止；它将继续实例化尝试。它将尝试实例化我们的第一个函数版本，但在评估 `typename boost::disable_if_c<boost::has_plus_assign<T>::value>`
    时将失败。这个失败不会被当作错误处理（参考 SFINAE）。正如你所看到的，没有 `enable_if_c` 和 `disable_if_c`，将会有歧义。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As in case of `enable_if_c` and `enable_if`, there is a `disable_if` version
    of the disabling function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `enable_if_c` 和 `enable_if` 一样，禁用函数也有 `disable_if` 版本：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: C++11 has neither `disable_if_c`, nor `disable_if` (you may use `std::enable_if<!bool_value>::type`
    instead).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 既没有 `disable_if_c`，也没有 `disable_if`（你可以使用 `std::enable_if<!bool_value>::type`
    代替）。
- en: As it was mentioned in the previous recipe, all the enabling and disabling functions
    are executed only at compile time, and do not add performance overhead at runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个食谱中提到的，所有启用和禁用函数都仅在编译时执行，不会在运行时增加性能开销。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read this chapter from the beginning to get more examples of compile-time tricks.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读这一章，以获取更多编译时技巧的示例。
- en: Consider reading the `Boost.TypeTraits` official documentation for more examples
    and full list of metafunctions at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑阅读 `Boost.TypeTraits` 的官方文档，以获取更多示例和元函数的完整列表。[http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html)。
- en: The `Boost.Utility` library may provide you more examples of `boost::enable_if`
    usage. Read about it at [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Utility` 库可能为你提供了更多 `boost::enable_if` 的使用示例。更多信息请参阅[http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)。'
- en: Creating a type from number
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数字创建类型
- en: 'We have now seen examples of how we can choose between functions without `boost::enable_if_c`
    usage. Let''s consider the following example, where we have a generic method for
    processing POD datatypes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在没有使用 `boost::enable_if_c` 的情况下选择函数的例子。让我们考虑以下例子，其中我们有一个用于处理 POD 数据类型的泛型方法：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And, we have the same function optimized for sizes 1, 4, and 8 bytes. How do
    we rewrite process function, so that it can dispatch calls to optimized versions?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一个针对 1、4 和 8 字节大小的相同函数的优化版本。我们如何重写 process 函数，以便它可以调用优化版本？
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading at least the first recipe from this chapter is highly recommended, so
    that you will not be confused by all the things that are happening here. Templates
    and metaprogramming shall not scare you (or just get ready to see a lot of them).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 高度推荐至少阅读这一章的第一个食谱，这样你就不会因为这里发生的事情而感到困惑。模板和元编程不应该让你感到害怕（或者准备好看到很多它们）。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are going to see how the size of a template type can be converted to a variable
    of some type, and how that variable can be used for deducing the right function
    overload.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何将模板类型的尺寸转换为某种类型的变量，以及如何使用该变量来推断正确的函数重载。
- en: 'Let''s define our generic and optimized versions of `process_impl` function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义 `process_impl` 函数的通用和优化版本：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we are ready to write process function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写过程函数：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The most interesting part here is `boost::mpl::int_<sizeof(T)>(). sizeof(T)`
    executes at compile time, so its output can be used as a template parameter. The
    class `boost::mpl::int_<>` is just an empty class that holds a compile-time value
    of integral type (in the `Boost.MPL` library, such classes are called Integral
    Constants). It can be implemented as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最有趣的部分是 `boost::mpl::int_<sizeof(T)>(). sizeof(T)` 在编译时执行，因此其输出可以用作模板参数。`boost::mpl::int_<>`
    类只是一个空的类，它持有整型类型的编译时值（在 `Boost.MPL` 库中，这样的类被称为积分常量）。它可以像以下代码所示实现：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We need an instance of this class, that is why we have a round parentheses at
    the end of `boost::mpl::int_<sizeof(T)>()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个此类实例，这就是为什么我们在 `boost::mpl::int_<sizeof(T)>()` 的末尾有一个圆括号。
- en: Now, let's take a closer look at how the compiler will decide which `process_impl`
    function to use. First of all, the compiler will try to match functions that have
    a second parameter and not a template. If `sizeof(T)` is 4, the compiler will
    try to search the function with signatures like `process_impl(T, boost::mpl::int_<8>)`,
    and will find our 4 bytes optimized version from the `detail` namespace. If `sizeof(T)`
    is 34, compiler won't find the function with signature like `process_impl(T, boost::mpl::int_<34>)`,and
    will use a templated variant `process_impl(const T& val, Tag /*ignore*/)`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看编译器将如何决定使用哪个 `process_impl` 函数。首先，编译器将尝试匹配具有第二个参数而不是模板的函数。如果 `sizeof(T)`
    是 4，编译器将尝试搜索具有类似 `process_impl(T, boost::mpl::int_<8>)` 签名的函数，并找到来自 `detail` 命名空间的
    4 字节优化版本。如果 `sizeof(T)` 是 34，编译器将找不到具有类似 `process_impl(T, boost::mpl::int_<34>)`
    签名的函数，并将使用模板变体 `process_impl(const T& val, Tag /*ignore*/)`。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.MPL` library has several data structures for metaprogramming. In
    this recipe, we only scratched a top of the iceberg. You may find the following
    Integral Constant classes from MPL useful:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL` 库有几个元编程的数据结构。在这个菜谱中，我们只是触及了冰山一角。您可能会发现以下来自 MPL 的积分常量类很有用：'
- en: '`bool_`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool_`'
- en: '`int_`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int_`'
- en: '`long_`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_`'
- en: '`size_t`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_t`'
- en: '`char_`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char_`'
- en: All the `Boost.MPL` functions (except the `for_each` runtime function) are executed
    at compile time and won't add runtime overhead. The `Boost.MPL` library is not
    a part of C++11, but many STL libraries implement functions from it for their
    own needs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `Boost.MPL` 函数（除了 `for_each` 运行时函数）都是在编译时执行的，不会增加运行时开销。`Boost.MPL` 库不是 C++11
    的一部分，但许多 STL 库为了满足自己的需求，实现了它的一些函数。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The recipes from [Chapter 8](ch08.html "Chapter 8. Metaprogramming"), *Metaprogramming*,
    will give you more examples of the `Boost.MPL` library usage. If you feel confident,
    you may also try to read its documentation at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 8 章 [Metaprogramming](ch08.html "第 8 章。元编程") 中的菜谱将为您提供更多 `Boost.MPL` 库使用的示例。如果您有信心，您也可以尝试阅读其文档，[http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)。
- en: Read more examples of tags usage at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html)
    and [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html)
    和 [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html)
    上阅读更多关于标签使用的示例。
- en: Implementing a type trait
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类型特性
- en: We need to implement a type trait that returns true if the `std::vector` type
    is passed to it as a template parameter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个类型特性，当它作为模板参数传递 `std::vector` 类型时，返回 true。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basic knowledge of the `Boost.TypeTrait` or STL type traits is required.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些关于 `Boost.TypeTrait` 或 STL 类型特性的基本知识。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s see how to implement a type trait:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现一个类型特性：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Almost all the work is done by the `boost::true_type` and `boost::false_type`
    classes. The `boost::true_type` class has a boolean `::value` static constant
    in it that equals to `true`, the `boost::false_type` class has a boolean `::value`
    static constant in it that equals to `false`. They also have some typedefs, and
    are usually derived from `boost::mpl::integral_c`, which makes it easy to use
    types derived from `true_type/false_type` with `Boost.MPL`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的工作都是由 `boost::true_type` 和 `boost::false_type` 类完成的。`boost::true_type`
    类中有一个布尔 `::value` 静态常量，其值等于 `true`，而 `boost::false_type` 类中有一个布尔 `::value` 静态常量，其值等于
    `false`。它们还有一些 typedef，通常是从 `boost::mpl::integral_c` 派生出来的，这使得使用从 `true_type/false_type`
    派生的类型与 `Boost.MPL` 一起使用变得容易。
- en: Our first `is_stdvector` structure is a generic structure that will be used
    always when template specialized version of such structure is not found. Our second
    `is_stdvector` structure is a template specialization for the `std::vector` types
    (note that it is derived from `true_type`!). So, when we pass vector type to the
    `is_stdvector` structure, template specialized version will be used, otherwise
    generic version will be used, which is derived from `false_type`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个 `is_stdvector` 结构是一个通用的结构，当找不到此类结构的模板特化版本时，总是会被使用。我们的第二个 `is_stdvector`
    结构是 `std::vector` 类型的模板特化（注意，它是从 `true_type` 派生出来的！）所以，当我们向 `is_stdvector` 结构传递向量类型时，将使用模板特化版本，否则将使用通用版本，它是从
    `false_type` 派生出来的。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 3 lines There is no public keyword before `boost::false_type` and `boost::true_type`
    in our trait because we use `struct` keyword, and by default it uses public inheritance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 3 行 在我们的特性中，`boost::false_type` 和 `boost::true_type` 前面没有公共关键字，因为我们使用了 `struct`
    关键字，并且默认使用公共继承。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Those readers who use the C++11 compatible compilers may use the `true_type`
    and `false_type` types declared in the `<type_traits>` header from the `std::`
    namespace for creating their own type traits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用与 C++11 兼容的编译器的读者可以使用 `std::` 命名空间中声明的 `<type_traits>` 头文件中的 `true_type`
    和 `false_type` 类型来创建他们自己的类型特性。
- en: As usual, the Boost version is more portable because it can be used on C++03
    compilers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，Boost 版本更具有可移植性，因为它可以在 C++03 编译器上使用。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Almost all the recipes from this chapter use type traits. Refer to the `Boost.TypeTraits`
    documentation for more examples and information at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i)[ndex.html](http://ndex.html).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的几乎所有配方都使用了类型特性。有关更多示例和信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i)[ndex.html](http://ndex.html)。
- en: Selecting an optimal operator for a template parameter
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择模板参数的最佳运算符
- en: 'Imagine that we are working with classes from different vendors that implement
    different amounts of arithmetic operations and have constructors from integers.
    And, we do want to make a function that increments by one when any class is passed
    to it. Also, we want this function to be effective! Take a look at the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在使用来自不同供应商的类，这些类实现了不同数量的算术运算，并且具有从整数构造函数。我们确实想编写一个函数，当传递任何类给它时，它会增加一个。我们还希望这个函数是有效的！看看下面的代码：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basic knowledge of the C++ templates, and the `Boost.TypeTrait` or STL
    type traits is required.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些关于 C++ 模板和 `Boost.TypeTrait` 或 STL 类型特性的基本知识。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'All the selecting can be done at compile time. This can be achieved using the
    `Boost.TypeTraits` library, as shown in the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选择都可以在编译时完成。这可以通过使用 `Boost.TypeTraits` 库来实现，如下面的步骤所示：
- en: 'Let''s start from making correct functional objects:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从制作正确的函数对象开始：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that we will need a bunch of type traits:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后我们将需要一系列类型特性：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, we are ready to deduce correct functor and use it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们就准备好推导出正确的函数对象并使用它：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the magic is done via the `conditional<bool Condition, class T1, class T2>`
    metafunction. When this metafunction accepts `true` as a first parameter, it returns
    `T1` via the `::type` typedef. When the `boost::conditional` metafunction accepts
    `false` as a first parameter, it returns `T2` via the `::type` typedef. It acts
    like some kind of compile-time `if` statement.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有魔法都是通过 `conditional<bool Condition, class T1, class T2>` 元函数完成的。当这个元函数接受 `true`
    作为第一个参数时，它通过 `::type` typedef 返回 `T1`。当 `boost::conditional` 元函数接受 `false` 作为第一个参数时，它通过
    `::type` typedef 返回 `T2`。它就像某种编译时 `if` 语句。
- en: So, `step0_t` holds a `detail::plus_functor` metafunction and `step1_t` will
    hold `step0_t` or `detail::plus_assignable_functor`. The `step2_t` type will hold
    `step1_t` or `detail::post_inc_functor`. The `step3_t` type will hold `step2_t`
    or `detail::pre_inc_functor`. What each `step*_t` typedef holds is deduced using
    type trait.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`step0_t`包含一个`detail::plus_functor`元函数，而`step1_t`将包含`step0_t`或`detail::plus_assignable_functor`。`step2_t`类型将包含`step1_t`或`detail::post_inc_functor`。`step3_t`类型将包含`step2_t`或`detail::pre_inc_functor`。每个`step*_t`类型定义包含的内容是通过类型特性推导得出的。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is a C++11 version of this function, which can be found in the `<type_traits>`
    header in the `std::` namespace. Boost has multiple versions of this function
    in different libraries, for example, `Boost.MPL` has function `boost::mpl::if_c`,
    which acts exactly like `boost::conditional`. It also has a version `boost::mpl::if_`
    (without `c` at the end), which will call `::type` for its first template argument;
    and if it is derived from `boost::true_type` (or is a `boost::true_type` type),
    it will return its second argument during the `::type` call, otherwise it will
    return the last template parameter. We can rewrite our `inc()` function to use
    `Boost.MPL`, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个C++11版本，可以在`std::`命名空间中的`<type_traits>`头文件中找到。Boost在不同的库中有这个函数的多个版本，例如，`Boost.MPL`有`boost::mpl::if_c`函数，它的工作方式与`boost::conditional`完全相同。它还有一个版本`boost::mpl::if_`（没有`c`结尾），它将为第一个模板参数调用`::type`；如果它派生自`boost::true_type`（或是一个`boost::true_type`类型），在`::type`调用期间将返回其第二个参数，否则将返回最后一个模板参数。我们可以将我们的`inc()`函数重写为使用`Boost.MPL`，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考阅读
- en: The recipe *Enabling the usage of templated functions for integral types*
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食谱*启用模板函数对整型类型的用法*
- en: The recipe *Disabling templated functions' usage for real types*
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食谱*禁用模板函数对真实类型的用法*
- en: The `Boost.TypeTraits` documentation has a full list of available metafunctions.
    Read about it at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.TypeTraits`文档有一个完整的可用元函数列表。请阅读它，网址为[http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html)。'
- en: The recipes from [Chapter 8](ch08.html "Chapter 8. Metaprogramming"), *Metaprogramming*,
    will give you more examples of the `Boost.MPL` library usage. If you feel confident,
    you may also try to read its documentation at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。元编程")中的*元编程*食谱将为你提供更多`Boost.MPL`库使用的示例。如果你感到自信，你也可以尝试阅读其文档，网址为[http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)。'
- en: There is a proposal to add type switch to C++, and you may find it interesting.
    Read about it at [http://www.stroustrup.com/OOPSLA-ty](http://www.stroustrup.com/OOPSLA-ty)[peswitch-draft.pdf](http://peswitch-draft.pdf).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个提议要为C++添加类型切换，你可能对此感兴趣。请阅读它，网址为[http://www.stroustrup.com/OOPSLA-ty](http://www.stroustrup.com/OOPSLA-ty)[peswitch-draft.pdf](http://peswitch-draft.pdf)。
- en: Getting a type of expression in C++03
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++03中获取表达式的类型
- en: In the previous recipes, we saw some examples on `boost::bind` usage. It is
    a good and useful tool with a small drawback; it is hard to store `boost::bind`
    metafunction's functor as a variable in C++03.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们看到了一些关于`boost::bind`使用的示例。这是一个好用的工具，但有一个小缺点；在C++03中很难将`boost::bind`元函数的仿函数作为变量存储。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In C++11, we can use `auto` keyword instead of `???`, and that will work. Is
    there a way to do it in C++03?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，我们可以使用`auto`关键字代替`???`，并且这会起作用。在C++03中有没有办法做到这一点？
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The knowledge of the C++11 `auto` and `decltype` keywords may help you to understand
    this recipe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的`auto`和`decltype`关键字的知识可能有助于你理解这个食谱。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will need a `Boost.Typeof` library for getting return type of expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`Boost.Typeof`库来获取表达式的返回类型：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It just creates a variable with the name `var`, and the value of the expression
    is passed as a second argument. Type of `var` is detected from the type of expression.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是创建了一个名为`var`的变量，并将表达式的值作为第二个参数传递。`var`的类型由表达式的类型检测得出。
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An experienced C++11 reader will note that there are more keywords in the new
    standard for detecting the types of expression. Maybe `Boost.Typeof` has macro
    for them too. Let''s take a look at the following C++11 code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的C++11读者会注意到，新标准中有更多关键字用于检测表达式类型。也许`Boost.Typeof`也有针对它们的宏。让我们看看以下C++11代码：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using `Boost.Typeof`, the preceding code can be written like the following
    code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Boost.Typeof`，前面的代码可以写成以下形式：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: C++11 version's `decltype(expr)` deduces and returns the type of `expr`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 版本的 `decltype(expr)` 会推导并返回 `expr` 的类型。
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using `Boost.Typeof`, the preceding code can be written like the following
    code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Boost.Typeof`，前面的代码可以写成以下形式：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: C++11 has a special syntax for specifying return type at the end of the function
    declaration. Unfortunately, this cannot be emulated in C++03, so we cannot use
    `t1` and `t2` variables in macro.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 在函数声明末尾有特殊的语法来指定返回类型。不幸的是，这在 C++03 中无法模拟，所以我们不能在宏中使用 `t1` 和 `t2` 变量。
- en: 'You can freely use the results of the `BOOST_TYPEOF()` functions in templates
    and in any other compile-time expressions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板和任何其他编译时表达式中自由使用 `BOOST_TYPEOF()` 函数的结果：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But unfortunately, this magic does not always work without help. For example,
    user-defined classes are not always detected, so the following code may fail on
    some compilers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，这种魔法并不总是不需要帮助就能工作。例如，用户定义的类并不总是会被检测到，因此以下代码在某些编译器上可能会失败：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In such situations, you may give `Boost.Typeof` a helping hand and register
    a template:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以给 `Boost.Typeof` 提供帮助，并注册一个模板：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, three most popular compilers correctly detected type even without `BOOST_TYPEOF_REGISTER_TEMPLATE`
    and without C++11.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，三个最受欢迎的编译器即使在没有 `BOOST_TYPEOF_REGISTER_TEMPLATE` 和没有 C++11 的情况下也能正确检测类型。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of `Boost.Typeof` has more examples. Read about it
    at [http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html](http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Typeof` 的官方文档中有更多示例。有关信息请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html](http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html)。'
- en: '*Bjarne Stroustrup* may introduce some of the C++11 features to you. Read about
    it at [http://www.stroustrup.com/C++11FAQ.html](http://www.stroustrup.com/C++11FAQ.html).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bjarne Stroustrup* 可能会向你介绍一些 C++11 的特性。有关信息请参阅[http://www.stroustrup.com/C++11FAQ.html](http://www.stroustrup.com/C++11FAQ.html)。'
