["```cpp\nvoid doSomePainting(QPainter *painter) {\n  painter->drawLine(QPoint(0,0), QPoint(100, 40));\n}\n```", "```cpp\nQFontMetrics fm = painter.fontMetrics();\nQRect rect = fm.boundingRect(\"Game Programming using Qt\");\n```", "```cpp\nQLinearGradient gradient(0, 0, width, height);\ngradient.setColorAt(0,   Qt::yellow);\ngradient.setColorAt(0.5, Qt::red);\ngradient.setColorAt(1.0, Qt::magenta);\nQBrush brush = gradient;\n```", "```cpp\n{\n  QPainter painter(this); // paint on the current object\n  QPen pen = Qt::red;\n  pen.setWidth(2);\n  painter.setPen(pen);\n  painter.setBrush(Qt::yellow);\n  painter.drawRect(0, 0, 100, 50);\n}\n```", "```cpp\nprotected:\n    void paintEvent(QPaintEvent *);\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n  QPainter painter(this);\n}\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n  QPainter painter(this);\n QPen pen(Qt::black);\n pen.setWidth(4);\n painter.setPen(pen);\n QRect r = rect().adjusted(10, 10, -10, -10);\n painter.drawRoundedRect(r, 20, 10);\n}\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n  QPainter painter(this);\n painter.setRenderHint(QPainter::Antialiasing, true);\n  // …\n}\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *) {\n  QPainter painter(this);\n  painter.setRenderHint(QPainter::Antialiasing, true);\n  QPen pen(Qt::black);\n  pen.setWidth(4);\n  painter.setPen(pen);\n  QRect r = rect().adjusted(10, 10, -10, -10);\n  painter.drawRoundedRect(r, 20, 10);\n painter.save();\n r.adjust(2, 2, -2, -2);\n painter.setViewport(r);\n r.moveTo(0, -r.height()/2);\n painter.setWindow(r);\n drawChart(&painter, r);\n painter.restore();\n}\n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect) {\n  painter->setPen(Qt::red);\n  painter->drawLine(0, 0, rect.width(), 0);\n}\n```", "```cpp\nclass Widget : public QWidget\n{\n  // ...\npublic slots:\n void addPoint(unsigned yVal) { m_points << qMax(0u, yVal); update(); }\n void clear() { m_points.clear(); update(); }\nprotected:\n  // ...\n QList<quint16> m_points;\n};\n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect) {\n  painter->setPen(Qt::red);\n  painter->drawLine(0, 0, rect.width(), 0);\n painter->save();\n painter->setRenderHint(QPainter::Antialiasing, false);\n painter->setPen(Qt::blue);\n for(int i=0;i < m_points.size(); ++i) {\n painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n }\n painter->restore();\n}\n```", "```cpp\nfor(int i=0;i<450;++i) w.addPoint(qrand() % 120);\n```", "```cpp\nQ_PROPERTY(int selectionStart READ selectionStart NOTIFY selectionChanged)\nQ_PROPERTY(int selectionEnd READ selectionEnd NOTIFY selectionChanged)\n```", "```cpp\nvoid Widget::mousePressEvent(QMouseEvent *mouseEvent) {\n  m_selectionStart = m_selectionEnd = mouseEvent->pos().x() - 12;\n  emit selectionChanged();\n  update();\n}\nvoid Widget::mouseMoveEvent(QMouseEvent *mouseEvent) {\n  m_selectionEnd = mouseEvent->pos().x() - 12;\n  emit selectionChanged();\n  update();\n}\n```", "```cpp\nvoid Widget::drawSelection(QPainter *painter, const QRect &rect) {\n  if(m_selectionStart < 0 ) return;\n  painter->save();\n  painter->setPen(Qt::NoPen);\n  painter->setBrush(palette().highlight());\n  QRect selectionRect = rect;\n  selectionRect.setLeft(m_selectionStart);\n  selectionRect.setRight(m_selectionEnd);\n  painter->drawRect(selectionRect);\n  painter->restore();\n}\n```", "```cpp\nfor(int i=0; i < m_points.size(); ++i) {\n if(m_selectionStart <= i && m_selectionEnd >=i) {\n painter->setPen(Qt::white);\n } else\n painter->setPen(Qt::blue);\n  painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n}\n```", "```cpp\nbool Widget::event(QEvent *e) {\n  if(e->type() == QEvent::Gesture) {\n    QGestureEvent *gestureEvent = static_cast<QGestureEvent*>(e);\n    QGesture *pan  = gestureEvent->gesture(Qt::PanGesture);\n    if(pan) {\n      handlePanGesture(static_cast<QPanGesture*>(pan));\n    }\n  }\n  return QWidget::event(e);\n}\n```", "```cpp\nQImage trueColor(image.png);\nQImage indexed = trueColor.convertToFormat(QImage::Format_Indexed8);\n```", "```cpp\nQImage indexed = …;\nQVector<QRgb> ct = indexed.colorTable();\nfor(int i=0;i<ct.size();++i) ct[i] = qGray(ct[i]);\nindexed.setColorTable(ct);\n```", "```cpp\nQPixmap px(256, 256);\npx.fill(Qt::transparent);\nQPainter painter(&px);\npainter.setPen(Qt::NoPen);\npainter.setBrush(Qt::blue);\nQRect r = px.rect().adjusted(10, 10, -10, -10);\npainter.drawRect(r);\npainter.setBrush(Qt::red);\npainter.drawEllipse(r);\n```", "```cpp\npainter.drawText(10, 20, \"Drawing some text at (10, 20)\");\n```", "```cpp\npainter.drawText(rect, Qt::AlignLeft|Qt::TextShowMnemonic, \"&ABC\");\n```", "```cpp\nclass TextWidget : public QWidget {\npublic:\n  TextWidget(QWidget *parent = 0) : QWidget(parent) {}\n  void setText(const QString &txt) {\n    m_staticText.setText(txt);\n    update();\n  }\nprotected:\n  void paintEvent(QPaintEvent *) {\n    QPainter painter(this);\n    paitner.drawStaticText(0, 0, m_staticText);\n  }\nprivate:\n  QStaticText m_staticText;\n};\n```", "```cpp\npainter.drawText(rect,\n  \"<div align='center'><b>Disclaimer</b></div>\"\n  \"<div align='justify'>You are using <i>this software</i> \"\n  \"at your own risk. The authors of the software do not give \"\n  \"any warranties that using this software will not ruin your \"\n  \"business.</div>\");\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *pe)\n{\n QRect exposedRect = pe->rect();\n  ...\n drawSelection(&painter, r, exposedRect);\n drawChart(&painter, r, exposedRect);\n  painter.restore();\n}\n```", "```cpp\nvoid Widget::drawSelection(QPainter *painter, const QRect &rect, const QRect &exposedRect)\n{\n    // ...\n    QRect selectionRect = rect;\n    selectionRect.setLeft(m_pressX);\n    selectionRect.setRight(m_releaseX);\n painter->drawRect(selectionRect.intersected(exposedRect));\n    painter->restore();\n}\n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect, const QRect &exposedRect)\n{\n  painter->setPen(Qt::red);\n painter->drawLine(exposedRect.left(), 0, exposedRect.width(), 0);\n  painter->save();\n  painter->setRenderHint(QPainter::Antialiasing, false);\n const int lastPoint = qMin(m_points.size(), exposedRect.right()+1);\n for(int i=exposedRect.left(); i < lastPoint; ++i) {\n    if(m_selectionStart <= i && m_selectionEnd >=i) {\n      painter->setPen(Qt::white);\n    } else\n    painter->setPen(Qt::blue);\n    painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n  }\n    painter->restore();\n}\n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *pe)\n{\n  QRect exposedRect = pe->rect();\n  QPainter painter(this);\n  painter.drawPixmap(exposedRect, pixmap(), exposedRect);\n}\n```", "```cpp\npublic:\n  ChessBoard* board() const;\npublic slots:\n  virtual void newGame();\nsignals:\n  void boardChanged(ChessBoard*);\nprotected:\n  virtual void setupBoard();\n  void setBoard(ChessBoard *board);\n```", "```cpp\nvoid ChessAlgorithm::setBoard(ChessBoard *board)\n{\n    if(board == m_board) return;\n    if(m_board) delete m_board;\n    m_board = board;\n    emit boardChanged(m_board);\n}\n```", "```cpp\nvoid ChessAlgorithm::setupBoard()\n{\n    setBoard(new ChessBoard(8,8, this));\n}\n```", "```cpp\nvoid ChessAlgorithm::newGame()\n{\n    setupBoard();\n}\n```", "```cpp\n  Q_PROPERTY(int ranks READ ranks NOTIFY ranksChanged)\n  Q_PROPERTY(int columns READ columns NOTIFY columnsChanged)\n```", "```cpp\nprotected:\n    void setRanks(int newRanks);\n    void setColumns(int newColumns);\n```", "```cpp\nvoid ChessBoard::setRanks(int newRanks)\n{\n    if(ranks() == newRanks) return;\n    m_ranks = newRanks;\n    emit ranksChanged(m_ranks);\n}\n```", "```cpp\nvoid ChessView::setBoard(ChessBoard *board)\n{\n    if(m_board == board) return;\n\n    if(m_board) {\n    // disconnect all signal-slot connections between m_board and this\n        m_board->disconnect(this);\n    }\n    m_board = board;\n    // connect signals (to be done later)\n    updateGeometry();\n}\n```", "```cpp\nprivate:\n  QPointer<ChessBoard> m_board;\n```", "```cpp\nChessBoard *ChessView::board() const { return m_board; }\n```", "```cpp\nQVector<char> m_boardData;\n```", "```cpp\nvoid ChessBoard::initBoard()\n{\n  m_boardData.fill(' ', ranks()*columns());\n  emit boardReset();\n}\n```", "```cpp\nvoid ChessBoard::setRanks(int newRanks)\n{\n  if(ranks() == newRanks) return;\n  m_ranks = newRanks;\n initBoard();\n  emit ranksChanged(m_ranks);\n}\n\nvoid ChessBoard::setColumns(int newColumns)\n{\n  if(columns() == newColumns) return;\n  m_columns = newColumns;\n initBoard();\n  emit columnsChanged(m_columns);\n}\n```", "```cpp\nchar ChessBoard::data(int column, int rank) const\n{ \n  return m_boardData.at((rank-1)*columns()+(column-1)); \n}\n```", "```cpp\nvoid ChessBoard::setData(int column, int rank, char value)\n{\n  if(setDataInternal(column, rank, value))\n    emit dataChanged(column, rank);\n}\n```", "```cpp\nbool ChessBoard::setDataInternal(int column, int rank, char value)\n{\n  int index = (rank-1)*columns()+(column-1);\n  if(m_boardData.at(index) == value) return false;\n  m_boardData[index] = value;\n  return true;\n}\n```", "```cpp\nsignals:\n  void ranksChanged(int);\n  void columnsChanged(int);\n void dataChanged(int c, int r);\n  void boardReset();\n```", "```cpp\nvoid ChessBoard::movePiece(int fromColumn, int fromRank, int toColumn, int toRank)\n{\n  setData(toColumn, toRank, data(fromColumn, fromRank));\n  setData(fromColumn, fromRank, ' ');\n}\n```", "```cpp\n\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\"\n```", "```cpp\nvoid ChessBoard::setFen(const QString &fen)\n{\n  int index = 0;\n  int skip = 0;\n  const int columnCount = columns();\n  QChar ch;\n  for(int rank = ranks(); rank >0; --rank) {\n    for(int column = 1; column <= columnCount; ++column) {\n      if(skip > 0) {\n        ch = ' ';\n        skip--;\n      } else {\n        ch = fen.at(index++);\n        if(ch.isDigit()) {\n          skip = ch.toLatin1()-'0';\n          ch = ' ';\n          skip--;\n        }\n      }\n      setDataInternal(column, rank, ch.toLatin1());\n    }\n    QChar next = fen.at(index++);\n    if(next != '/' && next != ' ') {\n      initBoard();\n      return; // fail on error\n    }\n  }\n  emit boardReset();\n}\n```", "```cpp\nQ_PROPERTY(QSize fieldSize \n           READ fieldSize WRITE setFieldSize \n           NOTIFY fieldSizeChanged)\n```", "```cpp\nvoid ChessView::setFieldSize(QSize arg)\n{\n    if (m_fieldSize == arg)\n        return;\n\n    m_fieldSize = arg;\n    emit fieldSizeChanged(arg);\n updateGeometry();\n}\n```", "```cpp\nQSize ChessView::sizeHint() const\n{\n    if(!m_board) return QSize(100,100);\n    QSize boardSize = QSize(fieldSize().width() * m_board->columns() +1,\n    m_fieldSize.height() * m_board->ranks()   +1);\n    int rankSize = fontMetrics().width('M')+4;\n    int columnSize = fontMetrics().height()+4;\n    return boardSize+QSize(rankSize, columnSize);\n}\n```", "```cpp\nQRect ChessView::fieldRect(int column, int rank) const\n{\n  if(!m_board) return QRect();\n  const QSize fs = fieldSize();\n  QRect fRect = QRect(QPoint((column-1)*fs.width(), (m_board->ranks()-rank)*fs.height()), fs);\n  // offset rect by rank symbols\n  int offset = fontMetrics().width('M'); // 'M' is the widest letter\n  return fRect.translated(offset+4, 0);\n}\n```", "```cpp\nvoid ChessView::paintEvent(QPaintEvent *event)\n{\n  if(!m_board) return;\n  QPainter painter(this);\n  for(int r = m_board->ranks(); r>0; --r) {\n    painter.save();\n    drawRank(&painter, r);\n    painter.restore();\n  }\n  for(int c = 1; c<=m_board->columns();++c) {\n    painter.save();\n    drawColumn(&painter, c);\n    painter.restore();\n  }\n  for(int r = 1; r<=m_board->ranks();++r) {\n    for(int c = 1; c<=m_board->columns();++c) {\n      painter.save();\n      drawField(&painter, c, r);\n      painter.restore();\n    }\n  }\n}\n```", "```cpp\nvoid ChessView::drawRank(QPainter *painter, int rank)\n{\n  QRect r = fieldRect(1, rank);\n  QRect rankRect = QRect(0, r.top(), r.left(), r.height()).adjusted(2, 0, -2, 0);\n  QString rankText = QString::number(rank);\n  painter->drawText(rankRect, Qt::AlignVCenter|Qt ::AlignRight, rankText);\n}\n\nvoid ChessView::drawColumn(QPainter *painter, int column)\n{\n  QRect r = fieldRect(column, 1);\n  QRect columnRect = QRect(r.left(), r.bottom(), \n    r.width(), height()-r.bottom()).adjusted(0, 2, 0, -2);\n  painter->drawText(columnRect, Qt:: AlignHCenter|Qt::AlignTop, QChar('a'+column-1));\n}\n```", "```cpp\nvoid ChessView::drawField(QPainter *painter, int column, int rank)\n{\n  QRect rect = fieldRect(column, rank);\n  QColor fillColor = (column+rank) % 2 ? palette().\n    color(QPalette::Light) : palette().color(QPalette::Mid);\n  painter->setPen(palette().color(QPalette::Dark));\n  painter->setBrush(fillColor);\n  painter->drawRect(rect);\n}\n```", "```cpp\nChessView *m_view;\nChessAlgorithm *m_algorithm;\n```", "```cpp\nMainWindow::MainWindow(QWidget *parent) :\n  QMainWindow(parent),\n  ui(new Ui::MainWindow)\n{\n  ui->setupUi(this);\n m_view = new ChessView;\n m_algorithm = new ChessAlgorithm(this);\n m_algorithm->newGame();\n m_view->setBoard(m_algorithm->board());\n setCentralWidget(m_view);\n m_view->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);\n m_view->setFieldSize(QSize(50,50));\n  layout()->setSizeConstraint(QLayout::SetFixedSize);\n}\n```", "```cpp\npublic:\n  void setPiece(char type, const QIcon &icon);\n  QIcon piece(char type) const;\nprivate:\n  QMap<char,QIcon> m_pieces;\n```", "```cpp\nvoid ChessView::setPiece(char type, const QIcon &icon)\n{\n  m_pieces.insert(type, icon);\n  update();\n}\n\nQIcon ChessView::piece(char type) const\n{\n  return m_pieces.value(type, QIcon());\n}\n```", "```cpp\nm_view->setPiece('P', QIcon(\":/pieces/Chess_plt45.svg\")); // pawn\nm_view->setPiece('K', QIcon(\":/pieces/Chess_klt45.svg\")); // king\nm_view->setPiece('Q', QIcon(\":/pieces/Chess_qlt45.svg\")); // queen\nm_view->setPiece('R', QIcon(\":/pieces/Chess_rlt45.svg\")); // rook\nm_view->setPiece('N', QIcon(\":/pieces/Chess_nlt45.svg\")); // knight\nm_view->setPiece('B', QIcon(\":/pieces/Chess_blt45.svg\")); // bishop\n\nm_view->setPiece('p', QIcon(\":/pieces/Chess_pdt45.svg\")); // pawn\nm_view->setPiece('k', QIcon(\":/pieces/Chess_kdt45.svg\")); // king\nm_view->setPiece('q', QIcon(\":/pieces/Chess_qdt45.svg\")); // queen\nm_view->setPiece('r', QIcon(\":/pieces/Chess_rdt45.svg\")); // rook\nm_view->setPiece('n', QIcon(\":/pieces/Chess_ndt45.svg\")); // knight\nm_view->setPiece('b', QIcon(\":/pieces/Chess_bdt45.svg\")); // bishop\n```", "```cpp\nvoid ChessView::paintEvent(QPaintEvent *event) \n{\n  // ...\n for(int r = m_board->ranks(); r>0; --r) {\n for(int c = 1; c<=m_board->columns();++c) {\n drawPiece(&painter, c, r);\n }\n }\n}\n```", "```cpp\nvoid ChessView::drawPiece(QPainter *painter, int column, int rank)\n{\n  QRect rect = fieldRect(column, rank);\n  char value = m_board->data(column, rank);\n  if(value != ' ') {\n    QIcon icon = piece(value);\n    if(!icon.isNull()) {\n      icon.paint(painter, rect, Qt::AlignCenter);\n    }\n  }\n}\n```", "```cpp\nvoid ChessAlgorithm::newGame()\n{\n  setupBoard();\n board()->setFen(\n \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\"\n );\n}\n```", "```cpp\nQPoint ChessView::fieldAt(const QPoint &pt) const\n{\n  if(!m_board) return QPoint();\n  const QSize fs = fieldSize();\n    int offset = fontMetrics().width('M')+4; // 'M' is the widest letter\n    if(pt.x() < offset) return QPoint();\n    int c = (pt.x()-offset) / fs.width();\n    int r = pt.y()/fs.height();\n    if(c < 0 || c >= m_board->columns() || r<0 || r >= m_board->ranks()) \n        return QPoint();\n    return QPoint(c+1, m_board->ranks() - r); // max rank - r\n}\n```", "```cpp\nsignals:\n  void clicked(const QPoint &);\n```", "```cpp\nvoid ChessView::mouseReleaseEvent(QMouseEvent *event)\n{\n  QPoint pt = fieldAt(event->pos());\n  if(pt.isNull()) return;\n  emit clicked(pt);\n}\n```", "```cpp\nconnect(m_view, SIGNAL(clicked(QPoint)), this, SLOT(viewClicked(QPoint)));\n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n  if(m_clickPoint.isNull()) {\n    m_clickPoint = field;\n  } else {\n  if(field != m_clickPoint) {\n    m_view->board()->movePiece(\n      m_clickPoint.x(), m_clickPoint.y(), \n      field.x(), field.y()\n    );\n    }\n    m_clickPoint = QPoint();\n  }\n}\n```", "```cpp\nvoid ChessView::setBoard(ChessBoard *board)\n{\n  // ...\n  m_board = board;\n // connect signals\n if(board){\n connect(board, SIGNAL(dataChanged(int,int)), this, SLOT(update()));\n connect(board, SIGNAL(boardReset()), this, SLOT(update()));\n }\n  updateGeometry();\n}\n```", "```cpp\nclass ChessView : public QWidget\n    // ...\npublic:\n class Highlight {\n public:\n Highlight() {}\n virtual ~Highlight() {}\n virtual int type() const { return 0; }\n };\n// ...\n};\n```", "```cpp\nclass FieldHighlight : public Highlight {\npublic:\n  enum { Type = 1 };\n  FieldHighlight(int column, int rank, QColor color)\n    : m_field(column, rank), m_color(color) {}\n  inline int column() const { return m_field.x(); }\n  inline int rank() const { return m_field.y(); }\n  inline QColor color() const { return m_color; }\n  int type() const { return Type; }\nprivate:\n  QPoint m_field;\n  QColor m_color;\n};\n```", "```cpp\npublic:\n  void addHighlight(Highlight *hl);\n  void removeHighlight(Highlight *hl);\n  inline Highlight *highlight(int index) const {return m_highlights.at(index); }\n  inline int highlightCount() const { return m_highlights.size(); }\n```", "```cpp\nvoid ChessView::addHighlight(ChessView::Highlight *hl) \n{ m_highlights.append(hl); update(); }\n\nvoid ChessView::removeHighlight(ChessView::Highlight *hl) \n{ m_highlights.removeOne(hl); update(); }\n```", "```cpp\ndrawHighlights(&painter);\n```", "```cpp\nvoid ChessView::drawHighlights(QPainter *painter)\n{\n  for(int idx=0; idx < highlightCount(); ++idx) {\n    Highlight *hl = highlight(idx);\n    if(hl->type() == FieldHighlight::Type) {\n      FieldHighlight *fhl = static_cast<FieldHighlight*>(hl);\n      QRect rect = fieldRect(fhl->column(), fhl->rank());\n      painter->fillRect(rect, fhl->color());\n    }\n  }\n}\n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n  if(m_clickPoint.isNull()) {\n    if(m_view->board()->data(field.x(), field.y()) != ' ') {\n      m_clickPoint = field;\n      m_selectedField = new ChessView::FieldHighlight(\n field.x(), field.y(), QColor(255, 0, 0, 50)\n );\n m_view->addHighlight(m_selectedField);\n }\n  } else {\n    if(field != m_clickPoint) {\n      m_view->board()->movePiece(\n        m_clickPoint.x(), m_clickPoint.y(), field.x(), field.y()\n      );\n    };\n    m_clickPoint = QPoint();\n    m_view->removeHighlight(m_selectedField);\n delete m_selectedField;\n m_selectedField = 0;\n  }\n}\n```", "```cpp\nclass ChessAlgorithm : public QObject\n{\n  Q_OBJECT\n  Q_ENUMS(Result Player)\n Q_PROPERTY(Result result READ result)\n Q_PROPERTY(Player currentPlayer \n READ currentPlayer \n NOTIFY currentPlayerChanged)\npublic:\n  enum Result { NoResult, Player1Wins, Draw, Player2Wins };\n enum Player { NoPlayer, Player1, Player2 };\n\n  explicit ChessAlgorithm(QObject *parent = 0);\n  ChessBoard* board() const;\n  inline Result result() const { return m_result; }\n  inline Player currentPlayer() const { return m_currentPlayer; }\n\nsignals:\n  void boardChanged(ChessBoard*);\n  void gameOver(Result);\n void currentPlayerChanged(Player);\n\npublic slots:\n  virtual void newGame();\n  virtual bool move(int colFrom, int rankFrom, int colTo, int rankTo);\n bool move(const QPoint &from, const QPoint &to);\n\nprotected:\n  virtual void setupBoard();\n  void setBoard(ChessBoard *board);\n void setResult(Result);\n void setCurrentPlayer(Player);\nprivate:\n  ChessBoard *m_board;\n Result m_result;\n Player m_currentPlayer;\n};\n```", "```cpp\nvoid ChessAlgorithm::setResult(Result value)\n{\n  if(result() == value) return;\n  if(result() == NoResult) {\n     m_result = value;\n     emit gameOver(m_result);\n  } else { m_result = value; }\n}\n\nvoid ChessAlgorithm::setCurrentPlayer(Player value)\n{\n  if(currentPlayer() == value) return;\n  m_currentPlayer = value;\n  emit currentPlayerChanged(m_currentPlayer);\n}\n```", "```cpp\nbool ChessAlgorithm::move(int colFrom, int rankFrom, int colTo, int rankTo)\n{\n  Q_UNUSED(colFrom)\n  Q_UNUSED(rankFrom)\n  Q_UNUSED(colTo)\n  Q_UNUSED(rankTo)\n  return false;\n}\n```", "```cpp\nbool ChessAlgorithm::move(const QPoint &from, const QPoint &to)\n{\n  return move(from.x(), from.y(), to.x(), to.y());\n}\n```", "```cpp\nclass FoxAndHounds : public ChessAlgorithm\n{\npublic:\n  FoxAndHounds(QObject *parent = 0);\n  void newGame();\n  bool move(int colFrom, int rankFrom, int colTo, int rankTo);\n};\n```", "```cpp\nvoid FoxAndHounds::newGame()\n{\n  setupBoard();\n  board()->setFen(\"3p4/8/8/8/8/8/8/P1P1P1P1 w\"); // 'w' - white to move\n  m_fox = QPoint(5,8);\n  setResult(NoResult);\n  setCurrentPlayer(Player1);\n}\n```", "```cpp\nbool FoxAndHounds::move(int colFrom, int rankFrom, int colTo, int rankTo)\n{\n  if(currentPlayer() == NoPlayer) return false;\n\n  // is there a piece of the right color?\n  char source = board()->data(colFrom, rankFrom);\n  if(currentPlayer() == Player1 && source != 'P') return false;\n  if(currentPlayer() == Player2 && source != 'p') return false;\n\n  // both can only move one column right or left\n  if(colTo != colFrom+1 && colTo != colFrom-1) return false;\n\n  // do we move within the board?\n  if(colTo < 1 || colTo > board()->columns()) return false;\n  if(rankTo < 1 || rankTo > board()->ranks()) return false;\n\n  // is the destination field black?\n  if((colTo + rankTo) % 2) return false;\n\n  // is the destination field empty?\n  char destination = board()->data(colTo, rankTo);\n  if(destination != ' ') return false;\n\n  // is white advancing?\n  if(currentPlayer() == Player1 && rankTo <= rankFrom) return false;\n\n  board()->movePiece(colFrom, rankFrom, colTo, rankTo);  // make the move\n  if(currentPlayer() == Player2) {\n    m_fox = QPoint(colTo, rankTo);      // cache fox position\n  }\n  // check win condition\n  if(currentPlayer() == Player2 && rankTo == 1){\n    setResult(Player2Wins);              // fox has escaped\n  } else if(currentPlayer() == Player1 && !foxCanMove()) {\n    setResult(Player1Wins);        // fox can't move\n  } else {\n    // the other player makes the move now\n    setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);\n  }\n  return true;\n}\n```", "```cpp\nbool FoxAndHounds::foxCanMove() const\n{\n  if(emptyByOffset(-1, -1) || emptyByOffset(-1, 1) \n  || emptyByOffset( 1, -1) || emptyByOffset( 1, 1)) return true;\n  return false;\n}\n```", "```cpp\nbool FoxAndHounds::emptyByOffset(int x, int y) const\n{\n  const int destCol = m_fox.x()+x;\n  const int destRank = m_fox.y()+y;\n  if(destCol < 1 || destRank < 1 \n  || destCol > board()->columns() || destRank > board()->ranks()) return false;\n    return (board()->data(destCol, destRank) == ' ');\n}\n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n  if(m_clickPoint.isNull()) {\n    // ...\n  } else {\n    if(field != m_clickPoint) {\n      m_algorithm->move(m_clickPoint, field);\n    }\n    // ...\n  }\n}\n```", "```cpp\nclass UciEngine : public QObject {\n  Q_OBJECT\npublic:\n  UciEngine(QObject *parent = 0) : QObject(parent) { \n    m_uciEngine = new QProcess(this);\n    m_uciEngine->setReadChannel(QProcess:StandardOutput);\n    connect(m_uciEngine, SIGNAL(readyRead()), SLOT(readFromEngine()));\n  }\npublic slots:\n  void startEngine(const QString &enginePath) {\n    m_uciEngine->start(enginePath);\n  }\n  void sendCommand(const QString &command) {\n    m_uciEngine->write(command.toLatin1());\n  }\nprivate slots:\n  void readFromEngine() {\n    while(m_uciEngine->canReadLine()) {\n      QString line = QString::fromLatin1(m_uciEngine->readLine());\n      emit messageReceived(line);\n    }\n  }\nsignals:\n  void messageReceived(QString);\nprivate:\n  QProcess *m_uciEngine;\n};\n```", "```cpp\nQT = core gui\nTARGET = triangle\nTEMPLATE = app\n```", "```cpp\nclass SimpleGLWindow : public QOpenGLWindow, protected QOpenGLFunctions {\npublic:\n  SimpleGLWindow(QWindow *parent = 0) : QOpenGLWindow(NoPartialUpdate, parent) { }\nprotected:\n  void initializeGL() {\n    initializeOpenGLFunctions();\n    glClearColor(1,1,1,0);\n  }\n```", "```cpp\n  void paintGL() {\n    glClear(GL_COLOR_BUFFER_BIT);\n    glViewport(0, 0, width(), height());\n    glBegin(GL_TRIANGLES);\n      glColor3f(1, 0, 0);\n      glVertex3f( 0.0f, 1.0f, 0.0f);\n      glColor3f(0, 1, 0);\n      glVertex3f( 1.0f,-1.0f, 0.0f);\n      glColor3f(0, 0, 1);\n      glVertex3f(-1.0f,-1.0f, 0.0f);\n    glEnd();\n  }\n};\n```", "```cpp\nint main(int argc, char **argv) {\n  QGuiApplication app(argc, argv);\n  SimpleGLWindow window;\n  window.resize(600,400);\n  window.show();\n  return app.exec();\n}\n```", "```cpp\n        QSurfaceFormat fmt = format();\n        fmt.setSamples(16); // multisampling set to 16\n        setFormat(fmt);\n```", "```cpp\nclass AbstractGLScene : protected QOpenGLFunctions {\npublic:\n  AbstractGLScene(QOpenGLWindow *wnd = 0) { m_window = wnd; }\n  QOpenGLWindow* window() const { return m_window; }\n  QOpenGLContext* context() { return window() ? window()->context() : 0;\n  }\n  const QOpenGLContext* context() const { \n      return window() ? window()->context() : 0; \n  }\nprivate:\n  QOpenGLWindow *m_window = nullptr; // C++11 required for assignment\n};\n```", "```cpp\nvoid SceneGLWindow::initializeGL() { if(scene()) scene()->initialize(); }\nvoid SceneGLWindow::paintGL() { if(scene()) scene()->paint(); }\n```", "```cpp\nvoid initializeTexture() {\n  m_texture = new QOpenGLTexture(m_tex.mirrored());\n  m_texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);\n  m_texture->setMagnificationFilter(QOpenGLTexture::Linear);\n}\n```", "```cpp\nvoid initialize() {\n  AbstractGLScene::initialize();\n  m_initialized = true;\n  if(!m_tex.isNull()) initializeTexture();\n  glClearColor(1,1,1,0);\n  glShadeModel(GL_SMOOTH);\n}\n```", "```cpp\nstruct TexturedPoint {\n  QVector3D coord;\n  QVector2D uv;\n  TexturedPoint(const QVector3D& pcoord, const QVector2D& puv) { coord = pcoord; uv = puv; }\n};\n```", "```cpp\nvoid CubeGLScene::initializeCubeData() {\n  m_data = {\n    // FRONT FACE\n    {{-0.5, -0.5,  0.5}, {0, 0}}, {{ 0.5, -0.5,  0.5}, {1, 0}},\n    {{ 0.5,  0.5,  0.5}, {1, 1}}, {{-0.5,  0.5,  0.5}, {0, 1}},\n\n    // TOP FACE\n    {{-0.5,  0.5,  0.5}, {0, 0}}, {{ 0.5,  0.5,  0.5}, {1, 0}},\n    {{ 0.5,  0.5, -0.5}, {1, 1}}, {{-0.5,  0.5, -0.5}, {0, 1}},\n\n    // BACK FACE\n    {{-0.5,  0.5, -0.5}, {0, 0}}, {{ 0.5,  0.5, -0.5}, {1, 0}},\n    {{ 0.5, -0.5, -0.5}, {1, 1}}, {{-0.5, -0.5, -0.5}, {0, 1}},\n\n    // BOTTOM FACE\n    {{-0.5, -0.5, -0.5}, {0, 0}}, {{ 0.5, -0.5, -0.5}, {1, 0}},\n    {{ 0.5, -0.5,  0.5}, {1, 1}}, {{-0.5, -0.5,  0.5}, {0, 1}},\n\n    // LEFT FACE\n    {{-0.5, -0.5, -0.5}, {0, 0}}, {{-0.5, -0.5,  0.5}, {1, 0}},\n    {{-0.5,  0.5,  0.5}, {1, 1}}, {{-0.5,  0.5, -0.5}, {0, 1}},\n\n    // RIGHT FACE\n    {{ 0.5, -0.5,  0.5}, {0, 0}}, {{ 0.5, -0.5, -0.5}, {1, 0}},\n    {{ 0.5,  0.5, -0.5}, {1, 1}}, {{ 0.5,  0.5,  0.5}, {0, 1}},\n  };\n}\n```", "```cpp\nm_data.append(TexturedPoint(QVector3D(...), QVector2D(...)));\n```", "```cpp\n  void CubeGLScene::paint() {\n    glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT);\n    glViewport(0, 0, window()->width(), window()->height());\n    glLoadIdentity();\n\n    glRotatef( 45, 1.0, 0.0, 0.0 );\n    glRotatef( 45, 0.0, 1.0, 0.0 );\n\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    paintCube();\n  }\n```", "```cpp\nvoid CubeGLScene::paintCube() {\n  if(m_texture)\n    m_texture->bind();\n  glEnable(GL_TEXTURE_2D);\n  glBegin(GL_QUADS);\n  for(int i=0;i<m_data.size();++i) {\n    const TexturedPoint &pt = m_data.at(i);\n    glTexCoord2d(pt.uv.x(), pt.uv.y());\n    glVertex3f(pt.coord.x(), pt.coord.y(), pt.coord.z());\n  }\n  glEnd();\n  glDisable(GL_TEXTURE_2D);\n}\n```", "```cpp\nint main(int argc, char **argv) {\n  QGuiApplication app(argc, argv);\n  SceneGLWindow window;\n QSurfaceFormat fmt;\n fmt.setSamples(16);\n window.setFormat(fmt);\n  CubeGLScene scene(&window);\n  window.setScene(&scene);\n  scene.setTexture(QImage(\":/texture.jpg\"));\n  window.resize(600,600);\n  window.show();\n  return app.exec();\n}\n```", "```cpp\nQPropertyAnimation anim(&scene, \"angle\");\nanim.setStartValue(0);\nanim.setEndValue(359);\nanim.setDuration(5000);\nanim.setLoopCount(-1);\nanim.start();\n```", "```cpp\nQOpenGLShader vertexShader(QOpenGLShader::Vertex);\nQByteArray code = \"uniform vec4 color;\\n\"\n    \"uniform highp mat4 matrix;\\n\"\n    \"void main(void) { gl_Position = gl_Vertex*matrix; }\";\nvertexShader.compileSourceCode(code);\n```", "```cpp\nQOpenGLShader fragmentShader(QOpenGLShader::Fragment);\ncode = \"uniform vec4 color;\\n\"\n    \"void main(void) { gl_FragColor = color; }\";\nfragmentShader.compileSourceCode(code);\n```", "```cpp\nQOpenGLShaderProgram program(context);\nprogram.addShader(vertexShader);\nprogram.addShader(fragmentShader);\nprogram.link();\n```", "```cpp\nprogram.bind();\nQMatrix4x4 m = …;\nQColor color = Qt::red;\nprogram.setUniformValue(\"matrix\", m);\nprogram.setUniformValue(\"color\", color);\n```", "```cpp\nglBegin(GL_TRIANGLE_STRIP);\n…\nglEnd();\n```", "```cpp\nclass ShaderGLScene : public QObject, public AbstractGLScene {\n  Q_OBJECT\npublic:\n  ShaderGLScene(SceneGLWindow *wnd);\n  void initialize();\n  void paint();\nprotected:\n  void initializeObjectData();\nprivate:\n  struct ScenePoint {\n    QVector3D coords;\n    QVector3D normal;\n    ScenePoint(const QVector3D &c, const QVector3D &n);\n  };\n QOpenGLShaderProgram m_shader;\n QMatrix4x4 m_modelMatrix;\n QMatrix4x4 m_viewMatrix;\n QMatrix4x4 m_projectionMatrix;\n  QVector<ScenePoint> m_data;\n};\n```", "```cpp\nuniform highp mat4 modelViewMatrix;\nuniform highp mat3 normalMatrix;\nuniform highp mat4 projectionMatrix;\nuniform highp mat4 mvpMatrix;\n\nattribute highp vec4 Vertex;\nattribute mediump vec3 Normal;\n\nvarying mediump vec3 N;\nvarying highp vec3 v;\n\nvoid main(void) {\n  N = normalize(normalMatrix * Normal);\n  v = vec3(modelViewMatrix * Vertex);\n  gl_Position = mvpMatrix*Vertex;\n}\n```", "```cpp\nstruct Material {\n  lowp vec3 ka;\n  lowp vec3 kd;\n  lowp vec3 ks;\n  lowp float shininess;\n};\n\nstruct Light {\n  lowp vec4 position;\n  lowp vec3 intensity;\n};\n\nuniform Material mat;\nuniform Light light;\nvarying mediump vec3 N;\nvarying highp vec3 v;\n\nvoid main(void) {\n  mediump vec3 n = normalize(N);\n  highp vec3 L = normalize(light.position.xyz - v);\n  highp vec3 E = normalize(-v);\n  mediump vec3 R = normalize(reflect(-L, n));\n\n  lowp float LdotN = dot(L, n);\n  lowp float diffuse = max(LdotN, 0.0);\n  lowp vec3 spec = vec3(0,0,0);\n\n  if(LdotN > 0.0) {\n    float RdotE = max(dot(R, E), 0.0);\n    spec = light.intensity*pow(RdotE, mat.shininess);\n  }\n  vec3 color = light.intensity * (mat.ka + mat.kd*diffuse + mat.ks*spec);\n  gl_FragColor = vec4(color, 1.0);\n}\n```", "```cpp\nvoid initialize() {\n  AbstractGLScene::initialize();\n  glClearColor(0,0,0,0);\n```", "```cpp\n  m_shader.addShaderFromSourceCode(QOpenGLShader::Vertex, fileContent(\"phong.vert\"));\n  m_shader.addShaderFromSourceCode(QOpenGLShader::Fragment, fileContent(\"phong.frag\"));\n  m_shader.link();\n```", "```cpp\n  m_shader.bind();\n  m_shader.setAttributeArray(\"Vertex\", GL_FLOAT, m_data.constData(), 3, sizeof(ScenePoint));\n  m_shader.enableAttributeArray(\"Vertex\");\n  m_shader.setAttributeArray(\"Normal\", GL_FLOAT, &m_data[0].normal, 3, sizeof(ScenePoint)); \n  m_shader.enableAttributeArray(\"Normal\");\n  m_shader.setUniformValue(\"material.ka\", QVector3D(0.1, 0, 0.0));\n  m_shader.setUniformValue(\"material.kd\", QVector3D(0.7, 0.0, 0.0));\n  m_shader.setUniformValue(\"material.ks\", QVector3D(1.0, 1.0, 1.0));\n  m_shader.setUniformValue(\"material.shininess\", 128.0f);\n  m_shader.setUniformValue(\"light.position\", QVector3D(2, 1, 1));\n  m_shader.setUniformValue(\"light.intensity\", QVector3D(1,1,1));\n```", "```cpp\nvoid ObjectGLScene::paint() {\n  m_projectionMatrix.setToIdentity();\n  qreal ratio = qreal(window()->width()) / qreal(window()->height());\n  m_projectionMatrix.perspective(90, ratio, 0.5, 40); // angle, ratio, near plane, far plane\n  m_viewMatrix.setToIdentity();\n  QVector3D eye = QVector3D(0,0,2);\n  QVector3D center = QVector3D(0,0,0);\n  QVector3D up = QVector3D(0, 1, 0);\n  m_viewMatrix.lookAt(eye, center, up);\n```", "```cpp\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  glViewport(0, 0, window()->width(), window()->height());\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n  glCullFace(GL_BACK);\n```", "```cpp\n  m_modelMatrix.setToIdentity();\n  m_modelMatrix.rotate(45, 0, 1, 0);\n  QMatrix4x4 modelViewMatrix = m_viewMatrix*m_modelMatrix;\n  paintObject(modelViewMatrix);\n}\n```", "```cpp\nvoid paintCube(const QMatrix4x4& mvMatrix) {\n  m_shader.bind();\n  m_shader.setUniformValue(\"projectionMatrix\", m_projectionMatrix);\n  m_shader.setUniformValue(\"modelViewMatrix\", mvMatrix);\n  m_shader.setUniformValue(\"mvpMatrix\", m_projectionMatrix*mvMatrix);\n  m_shader.setUniformValue(\"normalMatrix\", mvMatrix.normalMatrix());\n  const int pointCount = m_data.size();\n  glDrawArrays(GL_TRIANGLES, 0, pointCount);\n}\n```", "```cpp\nQOpenGLBuffer vbo(QOpenGLBuffer::VertexBuffer);\n```", "```cpp\nvbo.setUsagePattern(QOpenGLBuffer::StaticDraw);\n```", "```cpp\ncontext->makeCurrent(this);\nvbo.create();\n```", "```cpp\nvbo.allocate(vertexCount*sizeof(ScenePoint));\n```", "```cpp\nScenePoint *buffer = static_cast<ScenePoint*>(vbo.map(QOpenGLBuffer::WriteOnly));\nassert(buffer!=0);\nfor(int i=0;i<vbo.size();++i) { buffer[i] = m_data[i]; }\nvbo.unmap();\n```", "```cpp\nconst int spSize = sizeof(ScenePoint);\nfor(int i=0;i<vbo.size();++i) { vbo.write (i*spSize, &m_data[i], spSize); }\n```", "```cpp\nvbo.bind();\nm_shader.setAttributeBuffer(\"Vertex\"\", GL_FLOAT, 0, 3, sizeof(ScenePoint));\nm_shader.setAttributeBuffer(\"Normal\"\", GL_FLOAT, sizeof(QVector3D), 3, sizeof(ScenePoint));\n```"]