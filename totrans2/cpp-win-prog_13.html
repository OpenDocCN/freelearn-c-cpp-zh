<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13. The Registry, Clipboard, Standard Dialogs, and Print Preview</h1></div></div></div><p>This chapter describes the implementation of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The Registry:</strong> A Windows database holding information between application executions.</li><li class="listitem" style="list-style-type: disc"><strong>The Clipboard:</strong> A Windows database holding information that has been cut, copied, and pasted.</li><li class="listitem" style="list-style-type: disc"><strong>The standard dialogs</strong>: This is used for saving and opening documents, for colors and fonts, and for printing.</li><li class="listitem" style="list-style-type: disc"><strong>Print preview:</strong> In the <code class="literal">StandardDocument</code> class, it is possible to view the document on the screen as if it is being printed.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch13lvl1sec69"/>The registry</h1></div></div></div><p>The static write, read, and erase methods in the <code class="literal">Registry</code> class operate on values of the <code class="literal">Integer</code>, <code class="literal">Double</code>, <code class="literal">Boolean</code>, and <code class="literal">String</code> types, as well as memory blocks in the Windows Registry.</p><p>
<strong>Registry.h</strong>:</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Registry { &#13;
    public: &#13;
      static void WriteInteger(String key, const int value); &#13;
      static void WriteDouble(String key, const double value); &#13;
      static void WriteBoolean(String key, const bool value); &#13;
      static void WriteString(String key, const String text); &#13;
&#13;
      static void WriteBuffer(String key, const void* buffer, &#13;
                              int size); &#13;
 &#13;
      static int ReadInteger(String key, const int defaultValue); &#13;
      static double ReadDouble(String key, &#13;
                               const double defaultValue); &#13;
      static bool ReadBoolean(String key, &#13;
                              const bool defaultValue); &#13;
      static String ReadString(String key, &#13;
                               const String defaultText); &#13;
      static void ReadBuffer(String key, void* buffer, int size, &#13;
                             const void* defaultBuffer); &#13;
 &#13;
      static void Erase(String key); &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>Registry.cpp</strong>:</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
</pre><p>The global constant <code class="literal">RegistryFileName</code> holds the path to the registry domain of Small Windows:</p><pre class="programlisting">  const String RegistryFileName = TEXT(".\\SmallWindows.ini"); &#13;
</pre><p>The <code class="literal">WriteInteger</code>, <code class="literal">WriteDouble</code>, and <code class="literal">WriteBoolean</code> functions simply convert the value to a string and call <code class="literal">WriteString</code>:</p><pre class="programlisting">  void Registry::WriteInteger(String key, const int intValue) { &#13;
    WriteBuffer(key, &amp;intValue, sizeof intValue); &#13;
  } &#13;
 &#13;
  void Registry::WriteDouble(String key, &#13;
                             const double doubleValue) { &#13;
    WriteBuffer(key, &amp;doubleValue, sizeof doubleValue); &#13;
  } &#13;
 &#13;
  void Registry::WriteBoolean(String key, const bool boolValue) { &#13;
    WriteBuffer(key, &amp;boolValue, sizeof boolValue); &#13;
  } &#13;
</pre><p>The <code class="literal">WriteString</code> function calls the Win32 API function <code class="literal">WritePrivateProfileString</code>, which writes the string to the registry. All the C++ <code class="literal">String</code> objects need to be converted to zero-terminated C strings (char pointers) by <code class="literal">c_str</code>:</p><pre class="programlisting">  void Registry::WriteString(String key, const String text) { &#13;
    ::WritePrivateProfileString &#13;
        (Application::ApplicationName().c_str(), &#13;
         key.c_str(), text.c_str(), RegistryFileName.c_str()); &#13;
  } &#13;
</pre><p>The <code class="literal">WriteBuffer</code> function calls the Win32 API function <code class="literal">WritePrivateProfileStruct</code>, which writes the memory block to the registry:</p><pre class="programlisting">  void Registry::WriteBuffer(String key, const void* buffer, &#13;
                             int size) { &#13;
    ::WritePrivateProfileStruct &#13;
        (Application::ApplicationName().c_str(), &#13;
         key.c_str(), (void*) buffer, size, &#13;
         RegistryFileName.c_str()); &#13;
  } &#13;
</pre><p>The <code class="literal">ReadInteger</code>, <code class="literal">ReadDouble</code>, and <code class="literal">ReadBoolean</code> functions convert the default value to a string and call <code class="literal">ReadString</code>. The return value of <code class="literal">ReadString</code> is then converted and returned; <code class="literal">_tstoi</code> and <code class="literal">_tstof</code> are the generic versions of the standard C functions <code class="literal">atoi</code> and <code class="literal">atof</code>:</p><pre class="programlisting">  int Registry::ReadInteger(String key, const int defaultValue) { &#13;
    int intValue; &#13;
    ReadBuffer(key, &amp;intValue, sizeof intValue, &amp;defaultValue); &#13;
    return intValue; &#13;
  } &#13;
 &#13;
  double Registry::ReadDouble(String key, &#13;
                              const double defaultValue) { &#13;
    double doubleValue; &#13;
    ReadBuffer(key, &amp;doubleValue, sizeof doubleValue, &#13;
               &amp;defaultValue); &#13;
    return doubleValue; &#13;
  } &#13;
 &#13;
  bool Registry::ReadBoolean(String key, const bool defaultValue){ &#13;
    bool boolValue; &#13;
    ReadBuffer(key, &amp;boolValue, sizeof boolValue, &amp;defaultValue); &#13;
    return boolValue; &#13;
  } &#13;
</pre><p>The <code class="literal">ReadString</code> function calls the Win32 API function <code class="literal">GetPrivateProfileString</code>, which reads the string value to <code class="literal">text</code> and returns the number of characters read. If the number of read characters is greater than zero, the text is converted to a <code class="literal">string</code> object and returned; otherwise, the default text is returned:</p><pre class="programlisting">  String Registry::ReadString(String key, &#13;
                              const String defaultText) { &#13;
    TCHAR text[MAX_PATH]; &#13;
    int count = &#13;
      ::GetPrivateProfileString &#13;
          (Application::ApplicationName().c_str(), key.c_str(), &#13;
           nullptr, text, MAX_PATH, RegistryFileName.c_str()); &#13;
    return (count &gt; 0) ? String(text) : defaultText; &#13;
  } &#13;
</pre><p>The <code class="literal">ReadBuffer</code> function calls the Win32 API function <code class="literal">ReadPrivateProfileStruct</code>, which reads the memory block from the registry. If it returns zero, it means that the reading failed and the default buffer is copied to the buffer:</p><pre class="programlisting">  void Registry::ReadBuffer(String key, void* buffer, int size, &#13;
                            const void* defaultBuffer) { &#13;
    int result = &#13;
      ::GetPrivateProfileStruct &#13;
          (Application::ApplicationName().c_str(), key.c_str(), &#13;
           buffer, size, RegistryFileName.c_str()); &#13;
 &#13;
    if (result == 0) { &#13;
      ::memcpy(buffer, defaultBuffer, size); &#13;
    } &#13;
  } &#13;
</pre><p>When erasing a value from the registry, we call <code class="literal">WritePrivateProfileString</code> with a null pointer instead of a string, which erases the value:</p><pre class="programlisting">  void Registry::Erase(String key) { &#13;
    ::WritePrivateProfileString &#13;
        (Application::ApplicationName().c_str(), &#13;
         key.c_str(),nullptr,RegistryFileName.c_str()); &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec70"/>The Clipboard class</h1></div></div></div><p>The <code class="literal">Clipboard</code> class is an interface to the global Windows Clipboard, which makes it possible to cut, copy, and paste information between different kinds of applications. There are two forms of clipboard operations: ASCII and Unicode text and generic (application-specific) information.</p><p>
<strong>Clipboard.h</strong>:</p><pre class="programlisting">namespace SmallWindows { &#13;
</pre><p>The formats for ASCII and Unicode lines are predefined.</p><pre class="programlisting">  enum {AsciiFormat = CF_TEXT, UnicodeFormat = CF_UNICODETEXT}; &#13;
</pre><p>
<code class="literal">Open</code> and <code class="literal">Close</code> open and close the clipboard. They return <code class="literal">true</code> if they succeed. <code class="literal">Clear</code> clears the clipboard when it has been opened. More specifically, it removes any potential information with the specified format and <code class="literal">Available</code> returns <code class="literal">true</code> if there is information with the format stored on the clipboard.</p><p>Information in different formats may be stored on the clipboard. For instance, when the user copies text in an application, the text may be stored on the clipboard as ASCII and Unicode text, as well as a more advanced application-specific format. <code class="literal">Available</code> returns <code class="literal">true</code> if information is stored on the clipboard with the specified format:</p><pre class="programlisting">  class Clipboard { &#13;
    public: &#13;
      static bool Open(const Window* windowPtr); &#13;
      static bool Close(); &#13;
      static bool Clear(); &#13;
      static bool Available(unsigned int format); &#13;
</pre><p>The <code class="literal">WriteText</code> and <code class="literal">ReadText</code> functions write and read a list of strings, while the <code class="literal">WriteGeneric</code> and <code class="literal">ReadGeneric</code> functions write and read generic information:</p><pre class="programlisting">      template&lt;int Format, class CharType&gt; &#13;
      static bool WriteText(vector&lt;String&gt;&amp; lineList); &#13;
      template&lt;int Format, class CharType&gt; &#13;
      static bool ReadText(vector&lt;String&gt;&amp; lineList); &#13;
 &#13;
      static bool WriteGeneric(unsigned int format, &#13;
                               InfoList&amp; infoList); &#13;
      static bool ReadGeneric(unsigned int format, &#13;
                              InfoList&amp; infoList); &#13;
  }; &#13;
</pre><p>
<strong>Clipboard.cpp</strong>:</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
</pre><p>The <code class="literal">Open</code>, <code class="literal">Close</code>, and <code class="literal">Clear</code> functions call the Win32 API functions <code class="literal">OpenClipboard</code>, <code class="literal">CloseClipboard</code>, and <code class="literal">EmptyClipboard</code>. They all return integer values; a non-zero value indicates success:</p><pre class="programlisting">  bool Clipboard::Open(const Window* windowPtr) { &#13;
    return (::OpenClipboard(windowPtr-&gt;WindowHandle()) != 0); &#13;
  } &#13;
 &#13;
  bool Clipboard::Close() { &#13;
    return (::CloseClipboard() != 0); &#13;
  } &#13;
 &#13;
  bool Clipboard::Clear() { &#13;
    return (::EmptyClipboard() != 0); &#13;
  } &#13;
</pre><p>The <code class="literal">Available</code> function examines whether there is data with the format available on the clipboard by calling the Win32 API function <code class="literal">FormatAvailable</code>:</p><pre class="programlisting">  bool Clipboard::Available(unsigned int format) { &#13;
    return (::IsClipboardFormatAvailable(format) != 0); &#13;
  } &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch13lvl2sec112"/>ASCII and Unicode lines</h2></div></div></div><p>As <code class="literal">WriteText</code> and <code class="literal">ReadText</code> are template methods, they are included in the header file instead of the implementation file. <code class="literal">WriteText</code> takes a list of generic strings and writes them in any format to the clipboard; <code class="literal">AsciiFormat</code> (one byte/character) and <code class="literal">UnicodeFormat</code> (two bytes/character) are predefined.</p><p>
<strong>Clipboard.h</strong>:</p><pre class="programlisting">  template&lt;int Format,class CharType&gt; &#13;
  bool Clipboard::WriteText(vector&lt;String&gt;&amp; lineList) { &#13;
</pre><p>First, we need to find the buffer size, which we calculate by adding the total number of characters in the lines. We also add one for each line since each line also holds a terminating character. The terminating character is the return character (<code class="literal">\r</code>) for each line, except the last line, which is terminated by a zero character (<code class="literal">\0</code>):</p><pre class="programlisting">    int bufferSize = 0; &#13;
 &#13;
    for (String line : lineList) { &#13;
      bufferSize += line.size(); &#13;
    }  &#13;
&#13;
    int listSize = lineList.size(); &#13;
    bufferSize += listSize; &#13;
</pre><p>When we have calculated the buffer size, we can call the Win32 API <code class="literal">GlobalAlloc</code> function to allocate the buffer in the global clipboard. We will later connect it to the format. We use the size of the template character type for the buffer:</p><pre class="programlisting">    HGLOBAL globalHandle = &#13;
      ::GlobalAlloc(GMEM_MOVEABLE, bufferSize * sizeof(CharType)); &#13;
</pre><p>If the allocation succeeds, we receive a handle to the buffer. Since the clipboard and its buffers can be used by several processes at the same time, we need to lock the buffer by calling the Win32 API function <code class="literal">GlobalLock</code>. As long as the buffer is locked, no other processes can access it. When we lock the buffer we receive a pointer to it, which we can use when writing information to the buffer:</p><pre class="programlisting">    if (globalHandle != nullptr) { &#13;
      CharType* buffer = (CharType*) ::GlobalLock(globalHandle); &#13;
 &#13;
      if (buffer != nullptr) { &#13;
        int bufferIndex = 0; &#13;
</pre><p>We write the characters of the line to the buffer, and we add a <code class="literal">return</code> character unless it is the last line in the list:</p><pre class="programlisting">        for (int listIndex = 0; listIndex &lt; listSize;++listIndex) { &#13;
          for (TCHAR tChar : lineList[listIndex]) { &#13;
            buffer[bufferIndex++] = (CharType) tChar; &#13;
          } &#13;
 &#13;
          if (listIndex &lt; (listSize - 1)) { &#13;
            buffer[bufferIndex++] = (CharType) '\r'; &#13;
          } &#13;
        } &#13;
</pre><p>We add a zero character at the end of the buffer to mark its ending:</p><pre class="programlisting">        buffer[bufferIndex] = (CharType) '\0'; &#13;
</pre><p>When the buffer has been loaded with information, we only need to unlock the buffer so that other processes can access it and associate the buffer with the format:</p><pre class="programlisting">        ::GlobalUnlock(globalHandle); &#13;
        ::SetClipboardData(Format, globalHandle); &#13;
</pre><p>Finally, we return <code class="literal">true</code> to indicate that the operation succeeded:</p><pre class="programlisting">        return true; &#13;
      } &#13;
    } &#13;
</pre><p>If we were not able to allocate a buffer to write the line list to, we indicate that the operation did not succeeded by returning <code class="literal">false</code>:</p><pre class="programlisting">    return false; &#13;
  } &#13;
</pre><p>When reading the line list with <code class="literal">ReadText</code>, we use <code class="literal">Format</code> (which usually is <code class="literal">AsciiFormat</code> or <code class="literal">UnicodeFormat</code>) to receive a handle from the clipboard, which we then use to lock the buffer and receive its pointer, which in turn allows to us read from the buffer:</p><pre class="programlisting">  template&lt;int Format,class CharType&gt; &#13;
  bool Clipboard::ReadText(vector&lt;String&gt;&amp; lineList) { &#13;
    HGLOBAL globalHandle = ::GetClipboardData(Format); &#13;
 &#13;
    if (globalHandle != nullptr) { &#13;
      CharType* buffer = (CharType*) ::GlobalLock(globalHandle); &#13;
 &#13;
      if (buffer != nullptr) { &#13;
        String currentLine; &#13;
</pre><p>Note that we have to divide the buffer size with the template character type size (which may be greater than 1) in order to find the number of characters:</p><pre class="programlisting">        int charCount = &#13;
          ::GlobalSize(globalHandle) / (sizeof(CharType)); &#13;
 &#13;
        for (int count = 0; count &lt; charCount; ++count) { &#13;
          CharType cChar = (*buffer++); &#13;
</pre><p>When we encounter a return character (<code class="literal">\r</code>), the current line is finished; we add it to the line list and then clear it in order for it to be ready for the next line:</p><pre class="programlisting">          switch (cChar) { &#13;
            case ((CharType) '\r') : &#13;
              lineList.push_back(currentLine); &#13;
              currentLine.clear(); &#13;
              break; &#13;
</pre><p>When we encounter a return character (<code class="literal">'\0'</code>), we also add the current line to the line list. However, there is no need to clear the current line, since the zero character is the last character in the buffer:</p><pre class="programlisting">            case ((CharType) '\0') : &#13;
              lineList.push_back(currentLine); &#13;
              break; &#13;
</pre><p>If the character is neither a return nor a zero character, we add it to the current line. Note that we read a character of the template <code class="literal">CharType</code> type and convert it to a generic character of the <code class="literal">TCHAR</code> type:</p><pre class="programlisting">            default: &#13;
              currentLine += (TCHAR) cChar; &#13;
              break; &#13;
          } &#13;
        } &#13;
</pre><p>Finally, we unlock the buffer and return <code class="literal">true</code> to indicate that the operation succeeded:</p><pre class="programlisting">        ::GlobalUnlock(globalHandle); &#13;
        return true; &#13;
      } &#13;
    } &#13;
</pre><p>If we do not receive a buffer for the format, we return <code class="literal">false</code> to indicate that the operation did not succeed:</p><pre class="programlisting">    return false; &#13;
  } &#13;
}; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec113"/>Generic information</h2></div></div></div><p>The <code class="literal">WriteGeneric</code> function is actually simpler than the preceding <code class="literal">WriteText</code> function, since it does need to take line lists into consideration. We simply lock the clipboard buffer, write each byte in <code class="literal">infoList</code> to the buffer, unlock the buffer, and associate it with the format.</p><p>
<strong>Clipboard.cpp</strong>:</p><pre class="programlisting">  bool Clipboard::WriteGeneric(unsigned int format, &#13;
                               InfoList&amp; infoList) { &#13;
    int bufferSize = infoList.Size(); &#13;
    HGLOBAL globalHandle = GlobalAlloc(GMEM_MOVEABLE, bufferSize); &#13;
 &#13;
    if (globalHandle != nullptr) { &#13;
      void* buffer = ::GlobalLock(globalHandle); &#13;
</pre><p>The <code class="literal">ToBuffer</code> object in the <code class="literal">InfoList</code> function writes its bytes to the buffer:</p><pre class="programlisting">      if (buffer != nullptr) { &#13;
        infoList.ToBuffer(buffer); &#13;
        ::GlobalUnlock(globalHandle); &#13;
        ::SetClipboardData(format, globalHandle); &#13;
        return true; &#13;
      } &#13;
    } &#13;
</pre><p>If we do not manage to allocate the global buffer, we return <code class="literal">false</code> to indicate that the operation did not succeed:</p><pre class="programlisting">    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">ReadGeneric</code> function locks the clipboard buffer, writes each byte in the buffer to <code class="literal">infoList</code>, unlocks the buffer, and returns <code class="literal">true</code> to indicate that the operation succeeded:</p><pre class="programlisting">  bool Clipboard::ReadGeneric(unsigned int format, &#13;
                              InfoList&amp; infoList) { &#13;
    HGLOBAL globalHandle = ::GetClipboardData(format); &#13;
 &#13;
    if (globalHandle != nullptr) { &#13;
      void *buffer = ::GlobalLock(globalHandle); &#13;
      int bufferSize = ::GlobalSize(globalHandle); &#13;
      infoList.FromBuffer(buffer, bufferSize); &#13;
      ::GlobalUnlock(globalHandle); &#13;
      return true; &#13;
    } &#13;
</pre><p>If we do not receive the global handle, we return <code class="literal">false</code> to indicate that the operation did not succeed:</p><pre class="programlisting">    return false; &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec71"/>Standard dialogs</h1></div></div></div><p>In Windows, it's possible to define <strong>dialogs</strong>. Unlike windows, dialogs are intended to be populated with controls such as buttons, boxes, and text fields. A dialog may be <strong>modal</strong>, which means that the other windows of the application become disabled until the dialog is closed. In the next chapter, we will look into how we build our own dialogs.</p><p>However, in this section, we will look into the Windows <strong>standard </strong>
<strong>dialogs</strong> for saving and opening files, choosing fonts and colors, and printing. Small Windows supports standard dialogs by wrapping the Win32 API function, which provides us with the dialogs.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec114"/>The Save dialog</h2></div></div></div><p>The <code class="literal">SaveDialog</code> function displays the standard  <strong>Save</strong> dialogs.</p><p>
</p><div><img src="img/B05475_13_01.jpg" alt="The Save dialog"/></div><p>
</p><p>The <code class="literal">filter</code> parameters filter the file types to be displayed. Each file format is defined in two parts: the text displayed in the dialog and the default file suffix. The parts are separated by a zero character and the filter is terminated with two zero characters. For instance, consider the following:</p><pre class="programlisting">Word Files (*.wrd)\0*.drw\0Text Files(*.txt)\0*.txt\0\0 &#13;
</pre><p>The <code class="literal">fileSuffixList</code> parameter gives the allowed file suffixes and <code class="literal">saveFlags</code> holds the flags of the operation. The following two flags are available:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PromptBeforeOverwrite</code>: This flag is a warning message that is displayed if the file does already exist</li><li class="listitem" style="list-style-type: disc"><code class="literal">PathMustExist</code>: This flag is an error message that is displayed if the path does not exist</li></ul></div><p>
<strong>StandardDialog.h</strong>:</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Window; &#13;
  class Graphics; &#13;
 &#13;
  class StandardDialog { &#13;
    public: &#13;
      enum SaveFlags {NoSaveFlag = 0, &#13;
                      PromptBeforeOverwrite = OFN_OVERWRITEPROMPT, &#13;
                      PathMustExist = OFN_PATHMUSTEXIST, &#13;
                      NormalSaveFlags = OFN_OVERWRITEPROMPT | &#13;
                                        OFN_PATHMUSTEXIST}; &#13;
 &#13;
      static bool SaveDialog(Window* windowPtr, String&amp; path, &#13;
                             const TCHAR* filter, &#13;
                             const vector&lt;String&gt; fileSuffixList, &#13;
                             StandardDialog::SaveFlags saveFlags = &#13;
                               NormalSaveFlags);  &#13;
</pre><p>
<strong>StandardDialog.cpp</strong>:</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  bool StandardDialog::SaveDialog(Window* windowPtr, String&amp; path, &#13;
                              const TCHAR* filter, &#13;
                              const vector&lt;String&gt; fileSuffixList,  &#13;
                              SaveFlags saveFlags &#13;
                                /* = NormalSaveFlags */) { &#13;
</pre><p>The Win32 API <code class="literal">OPENFILENAME</code> structure <code class="literal">saveFileName</code> is loaded with appropriate values: <code class="literal">hwndOwner</code> is set to the window's handle, <code class="literal">hInstance</code> is set to the application instance handle, <code class="literal">lpstrFilter</code> is set to the <code class="literal">filter</code> parameter, <code class="literal">lpstrFile</code> is set to <code class="literal">pathBuffer</code>, which in turn holds the <code class="literal">path</code> parameter, and <code class="literal">Flags</code> is set to the <code class="literal">saveFlags</code> parameter:</p><pre class="programlisting">    OPENFILENAME saveFileName; &#13;
    memset(&amp;saveFileName, 0, sizeof saveFileName); &#13;
 &#13;
    TCHAR pathBuffer[MAX_PATH]; &#13;
    wcscpy_s(pathBuffer, MAX_PATH, path.c_str()); &#13;
 &#13;
    saveFileName.lStructSize = sizeof saveFileName; &#13;
    saveFileName.hwndOwner = windowPtr-&gt;WindowHandle(); &#13;
    saveFileName.hInstance = Application::InstanceHandle(); &#13;
    saveFileName.lpstrFilter = filter; &#13;
    saveFileName.lpstrFile = pathBuffer; &#13;
    saveFileName.nMaxFile = MAX_PATH; &#13;
    saveFileName.Flags = saveFlags; &#13;
 &#13;
    if (!fileSuffixList.empty()) { &#13;
      saveFileName.lpstrDefExt = fileSuffixList.front().c_str(); &#13;
    } &#13;
    else { &#13;
      saveFileName.lpstrDefExt = nullptr; &#13;
    } &#13;
</pre><p>When <code class="literal">saveFileName</code> is loaded, we call the Win32 API function <code class="literal">GetSaveFileName</code>, which displays the standard <strong>Save</strong> dialog and returns a non-zero value if the user terminates the dialog by clicking on the <strong>Save</strong> button or pressing the <strong>Return</strong> key. In that case, we set the <code class="literal">path</code> parameter to the chosen path, check whether the path ends with one of the suffixes in <code class="literal">fileSuffixList</code>, and return <code class="literal">true</code> if it does. If the path suffix is not present in the list, we display an error message and the saving process starts over again. If the user cancels the process, <code class="literal">false</code> is returned. In fact, the only way for the user to finish the process is to choose a file with a suffix in the list or to cancel the dialog:</p><pre class="programlisting">    while (true) { &#13;
      if (::GetSaveFileName(&amp;saveFileName) != 0) { &#13;
        path = pathBuffer; &#13;
 &#13;
        for (String fileWithSuffix : fileSuffixList) { &#13;
          if (EndsWith(path, TEXT(".") + fileWithSuffix)) { &#13;
            return true; &#13;
          } &#13;
        } &#13;
 &#13;
        windowPtr-&gt;MessageBox(TEXT("Undefined file suffix.")); &#13;
      } &#13;
      else { &#13;
        return false; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec115"/>The Open dialog</h2></div></div></div><p>The <code class="literal">OpenDialog</code> function displays the standard  <strong>Open</strong> dialog.</p><p>
</p><div><img src="img/B05475_13_02.jpg" alt="The Open dialog"/></div><p>
</p><p>The <code class="literal">filter</code> and <code class="literal">fileSuffixList</code> parameters work in the same way as in the preceding <code class="literal">SaveDialog</code> function. There are three flags available:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PromptBeforeCreate</code>: This flag displays a warning message if the file already exists</li><li class="listitem" style="list-style-type: disc"><code class="literal">FileMustExist</code>: The opened file must exist</li><li class="listitem" style="list-style-type: disc"><code class="literal">HideReadOnly</code>: This flag indicates that read-only files are hidden in the dialog</li></ul></div><p>
<strong>OpenDialog.h</strong>:</p><pre class="programlisting">      enum OpenFlags {NoOpenFlag = 0, &#13;
                      PromptBeforeCreate = OFN_CREATEPROMPT, &#13;
                      FileMustExist = OFN_FILEMUSTEXIST, &#13;
                      HideReadOnly = OFN_HIDEREADONLY, &#13;
                      NormalOpenFlags = OFN_CREATEPROMPT | &#13;
                                        OFN_FILEMUSTEXIST | &#13;
                                        OFN_HIDEREADONLY}; &#13;
 &#13;
&#13;
      static bool OpenDialog(Window* windowPtr, String&amp; path, &#13;
                             const TCHAR* filter, &#13;
                             const vector&lt;String&gt; fileSuffixList, &#13;
                             StandardDialog::OpenFlags openFlags = &#13;
                               NormalOpenFlags);  &#13;
</pre><p>The implementation of <code class="literal">OpenDialog</code> is similar to the preceding <code class="literal">SaveDialog</code> function. We use the same <code class="literal">OPENFILENAME</code> structure; the only difference is that we call <code class="literal">GetOpenFileName</code> instead of <code class="literal">GetSaveFileName</code>.</p><p>
<strong>OpenDialog.cpp</strong>:</p><pre class="programlisting">  bool StandardDialog::OpenDialog(Window* windowPtr, String&amp; path, &#13;
                              const TCHAR* filter, &#13;
                              const vector&lt;String&gt; fileSuffixList,  &#13;
                              StandardDialog::OpenFlags openFlags &#13;
                                /*=NormalOpenFlags */){ &#13;
    OPENFILENAME openFileName; &#13;
    memset(&amp;openFileName, 0, sizeof openFileName); &#13;
 &#13;
    TCHAR pathBuffer[MAX_PATH]; &#13;
    wcscpy_s(pathBuffer, MAX_PATH, path.c_str()); &#13;
 &#13;
    openFileName.lStructSize = sizeof openFileName; &#13;
    openFileName.hwndOwner = windowPtr-&gt;WindowHandle(); &#13;
    openFileName.hInstance = Application::InstanceHandle(); &#13;
    openFileName.lpstrFilter = filter; &#13;
    openFileName.lpstrFile = pathBuffer; &#13;
    openFileName.nMaxFile = MAX_PATH; &#13;
    openFileName.Flags = openFlags; &#13;
 &#13;
    if (!fileSuffixList.empty()) { &#13;
      openFileName.lpstrDefExt = fileSuffixList.front().c_str(); &#13;
    } &#13;
    else { &#13;
      openFileName.lpstrDefExt = nullptr; &#13;
    } &#13;
 &#13;
    while (true) { &#13;
      if (::GetOpenFileName(&amp;openFileName) != 0) { &#13;
        path = pathBuffer; &#13;
 &#13;
        for (String fileWithSuffix : fileSuffixList) { &#13;
          if (EndsWith(path, TEXT(".") + fileWithSuffix)) { &#13;
            return true; &#13;
          } &#13;
        } &#13;
 &#13;
        windowPtr-&gt;MessageBox(TEXT("Undefined file suffix.")); &#13;
      } &#13;
      else { &#13;
        return false; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec116"/>The Color dialog</h2></div></div></div><p>The <code class="literal">ColorDialog</code> function displays a standard  <strong>Color</strong> dialog.</p><p>
</p><div><img src="img/B05475_13_03.jpg" alt="The Color dialog"/></div><p>
</p><p>
<strong>StandardDialog.h</strong>:</p><pre class="programlisting">      static COLORREF customColorArray[]; &#13;
      static bool ColorDialog(Window* windowPtr, Color&amp; color); &#13;
</pre><p>The static <code class="literal">COLORREF</code> array <code class="literal">customColorArray</code> is used by the user in the color dialog to store the chosen colors. Since it is static, the <code class="literal">customColorArray</code> array is reused between dialog display sessions.</p><p>The <code class="literal">ColorDialog</code> function uses the Win32 API <code class="literal">CHOOSECOLOR</code> structure to initialize the dialog. The <code class="literal">hwndOwner</code> function is set to the window's handle, <code class="literal">rgbResult</code> is set to the color's <code class="literal">COLORREF</code> field, and <code class="literal">lpCustColors</code> is set to the custom color array. The <code class="literal">CC_RGBINIT</code> and <code class="literal">CC_FULLOPEN</code> flags initialize the dialog with the given color so that it is fully extended.</p><p>
<strong>StandardDialog.cpp</strong>:</p><pre class="programlisting">  COLORREF StandardDialog::customColorArray[16]; &#13;
 &#13;
  bool StandardDialog::ColorDialog(Window* windowPtr, &#13;
                                   Color&amp; color) { &#13;
    CHOOSECOLOR chooseColor; &#13;
    chooseColor.lStructSize = sizeof chooseColor; &#13;
    chooseColor.hwndOwner = windowPtr-&gt;WindowHandle(); &#13;
    chooseColor.hInstance = nullptr; &#13;
    chooseColor.rgbResult = color.ColorRef(); &#13;
    chooseColor.lpCustColors = customColorArray; &#13;
    chooseColor.Flags = CC_RGBINIT | CC_FULLOPEN; &#13;
    chooseColor.lCustData = 0; &#13;
    chooseColor.lpfnHook = nullptr; &#13;
    chooseColor.lpTemplateName = nullptr; &#13;
</pre><p>The Win32 <code class="literal">ChooseColor</code> function displays the <strong>Color</strong> dialog and returns a non-zero value if the user terminates the dialog by clicking on the <strong>OK</strong> button. In that case, we set the chosen color and return <code class="literal">true</code>:</p><pre class="programlisting">    if (::ChooseColor(&amp;chooseColor) != 0) { &#13;
      color.ColorRef() = chooseColor.rgbResult; &#13;
      return true; &#13;
    } &#13;
</pre><p>If the user cancels the dialog, we return <code class="literal">false</code>:</p><pre class="programlisting">    return false; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec117"/>The Font dialog</h2></div></div></div><p>The <code class="literal">FontDialog</code> function displays a standard  <strong>Font</strong> dialog.</p><p>
</p><div><img src="img/B05475_13_04.jpg" alt="The Font dialog"/></div><p>
</p><p>
<strong>StandardDialog.h</strong>:</p><pre class="programlisting">      static bool FontDialog(Window* windowPtr, Font&amp; font); &#13;
</pre><p>
<strong>FontDialog.cpp</strong>:</p><pre class="programlisting">  bool StandardDialog::FontDialog(Window* windowPtr, Font&amp; font) { &#13;
    LOGFONT logFont = font.LogFont(); &#13;
</pre><p>The Win32 API <code class="literal">CHOOSEFONT</code> structure <code class="literal">chooseFont</code> is loaded with appropriate values. The <code class="literal">lpLogFont</code> object is set to the font's <code class="literal">LOGFONT</code> field and <code class="literal">rgbColors</code> is set to the color's <code class="literal">COLORREF</code> field:</p><pre class="programlisting">    CHOOSEFONT chooseFont; &#13;
    memset(&amp;chooseFont, 0, sizeof chooseFont); &#13;
 &#13;
    chooseFont.lStructSize = sizeof(CHOOSEFONT); &#13;
    chooseFont.hInstance = Application::InstanceHandle(); &#13;
    chooseFont.hwndOwner = windowPtr-&gt;WindowHandle(); &#13;
    chooseFont.Flags = CF_INITTOLOGFONTSTRUCT | &#13;
                       CF_SCREENFONTS | CF_EFFECTS; &#13;
    chooseFont.lpLogFont = &amp;logFont; &#13;
    chooseFont.rgbColors = font.FontColor().ColorRef(); &#13;
</pre><p>The Win32 <code class="literal">ChooseFont</code> function displays the <strong>Font</strong> dialog and returns a non-zero value if the user clicks on the <strong>OK</strong> button. In that case, we set the chosen font and color and return <code class="literal">true</code>:</p><pre class="programlisting">    if (::ChooseFont(&amp;chooseFont) != 0) { &#13;
      font.LogFont() = logFont; &#13;
      font.FontColor() = Color(chooseFont.rgbColors); &#13;
      return true; &#13;
    } &#13;
</pre><p>If the user cancels the dialog, we return <code class="literal">false</code>:</p><pre class="programlisting">    return false; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec118"/>The Print dialog</h2></div></div></div><p>The <code class="literal">PrintDialog</code> function displays a standard <strong>Print</strong> dialog.</p><p>
</p><div><img src="img/B05475_13_05.jpg" alt="The Print dialog"/></div><p>
</p><p>If the user clicks on the <strong>Print</strong> button, the chosen print settings are saved in the <code class="literal">PrintDialog</code> parameters:</p><p>
<strong>PrintDialog.h</strong>:</p><pre class="programlisting">      static Graphics* PrintDialog(Window* parentPtr, &#13;
                                   int totalPages, &#13;
                                   int&amp; firstPage, int&amp; lastPage, &#13;
                                   int&amp; copies, bool&amp; sorted); &#13;
  }; &#13;
}; &#13;
</pre><p>The <code class="literal">PrintDialog</code> function loads the Win32 API <code class="literal">PRINTDLG</code> structure <code class="literal">printDialog</code> with appropriate values, <code class="literal">nFromPage</code> and <code class="literal">nToPage</code> are set to the first and last page to be printed (whose default values are 1 and the number of pages respectively), <code class="literal">nMaxPage</code> is set to the number of pages, and <code class="literal">nCopies</code> is set to 1 (the default value).</p><p>
<strong>PrintDialog.cpp</strong>:</p><pre class="programlisting">  Graphics* StandardDialog::PrintDialog(Window* parentPtr, &#13;
                            int totalPages, &#13;
                            int&amp; firstPage, int&amp; lastPage, &#13;
                            int&amp; copies, bool&amp; sorted) { &#13;
    PRINTDLG printDialog; &#13;
    memset(&amp;printDialog, 0, sizeof printDialog); &#13;
     &#13;
    printDialog.lStructSize = sizeof printDialog; &#13;
    printDialog.hwndOwner = parentPtr-&gt;WindowHandle(); &#13;
    printDialog.hDevMode = nullptr; &#13;
    printDialog.hDevNames = nullptr; &#13;
    printDialog.hDC = nullptr; &#13;
    printDialog.Flags = PD_ALLPAGES | PD_COLLATE | &#13;
                        PD_RETURNDC | PD_NOSELECTION; &#13;
    printDialog.nFromPage = 1; &#13;
    printDialog.nToPage = totalPages; &#13;
    printDialog.nMinPage = 1; &#13;
    printDialog.nMaxPage = totalPages; &#13;
    printDialog.nCopies = 1; &#13;
    printDialog.hInstance = nullptr; &#13;
    printDialog.lCustData = 0L; &#13;
    printDialog.lpfnPrintHook = nullptr; &#13;
    printDialog.lpfnSetupHook = nullptr; &#13;
    printDialog.lpPrintTemplateName = nullptr; &#13;
    printDialog.lpSetupTemplateName = nullptr; &#13;
    printDialog.hPrintTemplate = nullptr; &#13;
    printDialog.hSetupTemplate = nullptr; &#13;
</pre><p>The Win32 API function <code class="literal">PrintDlg</code> displays the standard print dialog and returns a non-zero value if the user finishes the dialog by pressing the <strong>Print</strong> button. In that case, the first and last page to be printed, the number of copies, and whether the copies will be sorted are stored in the parameters, and the pointer to the <code class="literal">Graphics</code> object to be used when printing is created and returned.</p><p>If the user has chosen a page interval, we use the <code class="literal">nFromPage</code> and <code class="literal">nToPage</code> fields; otherwise, all pages are selected and we use the <code class="literal">nMinPage</code> and <code class="literal">nMaxPage</code> fields to set the first and last page to be printed:</p><pre class="programlisting">    if (::PrintDlg(&amp;printDialog) != 0) { &#13;
      bool pageIntervalSelected = &#13;
        ((printDialog.Flags &amp; PD_SELECTION) != 0); &#13;
 &#13;
      if (pageIntervalSelected) { &#13;
        firstPage = printDialog.nFromPage; &#13;
        lastPage = printDialog.nToPage; &#13;
      } &#13;
      else { &#13;
        firstPage = printDialog.nMinPage; &#13;
        lastPage = printDialog.nMaxPage; &#13;
      } &#13;
</pre><p>If the <code class="literal">PD_COLLATE</code> flags is present, the user has chosen to sort the pages:</p><pre class="programlisting">      copies = printDialog.nCopies; &#13;
      sorted = (printDialog.Flags &amp; PD_COLLATE) != 0; &#13;
</pre><p>Finally, we create and return a pointer to the <code class="literal">Graphics</code> object to be used when painting to the printer.</p><pre class="programlisting">      return (new Graphics(parentPtr, printDialog.hDC)); &#13;
    } &#13;
</pre><p>If the user terminates the dialog by pressing the <strong>Cancel</strong> button, we return null:</p><pre class="programlisting">    return nullptr; &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec72"/>Print preview</h1></div></div></div><p>The <code class="literal">PrintPreviewDocument</code> class displays the pages of the document parent window. The <code class="literal">OnKeyDown</code> method closes the document when the user presses the <em>
<strong>Esc</strong>
</em> key. The <code class="literal">OnSize</code> method adjusts the physical size of the page so that the page always fits inside the window. The <code class="literal">OnVerticalScroll</code> method shifts the pages when the user scrolls up or down, and <code class="literal">OnPaint</code> calls <code class="literal">OnPrint</code> of the parent document for each page.</p><p>
<strong>PrintPreviewDocument.h</strong>:</p><pre class="programlisting">namespace SmallWindows { &#13;
  class PrintPreviewDocument : Document { &#13;
    public: &#13;
      PrintPreviewDocument(StandardDocument* parentDocument, &#13;
                  int page = 1, Size pageSize = USLetterPortrait); &#13;
      bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                     bool controlPressed); &#13;
</pre><p>The <code class="literal">OnSize</code> function is overridden only to neutralize its functionality in <code class="literal">Document</code>. In <code class="literal">Document</code>, <code class="literal">OnSize</code> modifies the scroll bars, but we do not want that to happen in this class:</p><pre class="programlisting">      void OnSize(Size clientSize) {/* Empty. */} &#13;
      void OnVerticalScroll(WORD flags, WORD thumbPos = 0); &#13;
      void OnPaint(Graphics&amp; graphics) const; &#13;
</pre><p>The <code class="literal">page</code> field holds the current page number and <code class="literal">totalPages</code> holds the total number of pages:</p><pre class="programlisting">    private: &#13;
      void SetHeader(); &#13;
      int page, totalPages; &#13;
  }; &#13;
}; &#13;
</pre><p>
<strong>PrintPreviewDocument.cpp</strong>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>The constructor sets the <code class="literal">page</code> and <code class="literal">totalPages</code> fields to appropriate values.</p><pre class="programlisting">namespace SmallWindows { &#13;
  PrintPreviewDocument::PrintPreviewDocument &#13;
    (StandardDocument* parentDocument, int totalPages /* = 1 */, &#13;
     Size pageSize/* = USLetterPortrait */) &#13;
   :Document(PreviewCoordinate, pageSize, parentDocument), &#13;
    page(1), &#13;
    totalPages(totalPages) { &#13;
</pre><p>The horizontal scroll bar is always set to the width of the window, which means that the user cannot change its setting:</p><pre class="programlisting">    SetHorizontalScrollPosition(0); &#13;
    SetHorizontalScrollPageWidth(pageSize.Width()); &#13;
    SetHorizontalScrollTotalWidth(pageSize.Width()); &#13;
</pre><p>The vertical scroll bar is set to match the number of pages of the document, and the scroll thumb corresponds to one page:</p><pre class="programlisting">    SetVerticalScrollPosition(0); &#13;
    SetVerticalScrollPageHeight(pageSize.Height()); &#13;
    SetVerticalScrollTotalHeight(totalPages * pageSize.Height()); &#13;
 &#13;
    SetHeader(); &#13;
    ShowWindow(true); &#13;
  } &#13;
</pre><p>The header displays the current and total number of pages:</p><pre class="programlisting">  void PrintPreviewDocument::SetHeader() { &#13;
    SetName(TEXT("Print Preview: Page ") + to_String(page) + &#13;
            TEXT(" out of ") + to_String(totalPages)); &#13;
  } &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch13lvl2sec119"/>Keyboard input</h2></div></div></div><p>The <code class="literal">OnKeyDown</code> function is called when the user presses a key. If they press the <em>
<strong>Esc</strong>
</em> key, the preview window is closed and destroyed, and the input focus is returned to the main window of the application. If they press the <em>
<strong>Home</strong>
</em>, <em>
<strong>End</strong>
</em>, <em>
<strong>Page Up</strong>
</em>, or <em>
<strong>Page Down</strong>
</em> keys or the up and down arrow keys, <code class="literal">OnVerticalScroll</code> is called to take the appropriate action:</p><pre class="programlisting">  bool PrintPreviewDocument::OnKeyDown &#13;
         (WORD key, bool shiftPressed, bool controlPressed) { &#13;
    switch (key) { &#13;
      case KeyEscape: { &#13;
          Window* parentWindow = ParentWindowPtr(); &#13;
          ::CloseWindow(WindowHandle()); &#13;
          parentWindow-&gt;SetFocus(); &#13;
        } &#13;
        break; &#13;
 &#13;
      case KeyHome: &#13;
        OnVerticalScroll(SB_TOP); &#13;
        break; &#13;
 &#13;
      case KeyEnd: &#13;
        OnVerticalScroll(SB_BOTTOM); &#13;
        break; &#13;
 &#13;
      case KeyUp: &#13;
      case KeyPageUp: &#13;
        OnVerticalScroll(SB_LINEUP); &#13;
        break; &#13;
 &#13;
      case KeyDown: &#13;
      case KeyPageDown: &#13;
        OnVerticalScroll(SB_LINEDOWN); &#13;
        break; &#13;
    } &#13;
</pre><p>We return <code class="literal">true</code> to indicate that the keyboard input has been used:</p><pre class="programlisting">    return true; &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec120"/>Scroll bar</h2></div></div></div><p>The <code class="literal">OnVerticalScroll</code> function is called when the user scrolls the vertical bar. If they click on the scroll bar itself, above or below the scroll thumb, the previous or next page is displayed. And if they drag the thumb to a new position, the corresponding page is calculated. The <code class="literal">SB_TOP</code> and <code class="literal">SB_BOTTOM</code> cases are included to accommodate the <em>
<strong>Home</strong>
</em> and <em>
<strong>End</strong>
</em> keys from the preceding <code class="literal">OnKeyDown</code> function rather than to accommodate any scroll movements; they set the page to the first or last page:</p><pre class="programlisting">  void PrintPreviewDocument::OnVerticalScroll(WORD flags, &#13;
                                       WORD thumbPos /* = 0 */) { &#13;
    int oldPage = page; &#13;
 &#13;
    switch (flags) { &#13;
      case SB_LINEUP: &#13;
      case SB_PAGEUP: &#13;
        page = max(1, page - 1); &#13;
        break; &#13;
 &#13;
      case SB_LINEDOWN: &#13;
      case SB_PAGEDOWN: &#13;
        page = min(page + 1, totalPages); &#13;
        break; &#13;
 &#13;
      case SB_THUMBTRACK: &#13;
      case SB_THUMBPOSITION: &#13;
        page = (thumbPos / pageSize.Height()) + 1; &#13;
        break; &#13;
 &#13;
      case SB_TOP: &#13;
        page = 1; &#13;
        break; &#13;
 &#13;
&#13;
&#13;
      case SB_BOTTOM: &#13;
        page = totalPages; &#13;
        break; &#13;
    } &#13;
</pre><p>If the scroll movement has resulted in a new page, we set the header and the scroll bar position and invalidate and update the window:</p><pre class="programlisting">    if (oldPage != page) { &#13;
      SetHeader(); &#13;
      SetVerticalScrollPosition((page - 1) * pageSize.Height()); &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">OnPaint</code> function in <code class="literal">PrintPreviewDocument</code> calls <code class="literal">OnPaint</code> in the parent standard document window in order to paint the contents of the preview window:</p><pre class="programlisting">  void PrintPreviewDocument::OnPaint(Graphics&amp; graphics) const { &#13;
    StandardDocument* parentDocument = &#13;
      (StandardDocument*) ParentWindowPtr(); &#13;
    parentDocument-&gt;OnPrint(graphics, page, 1, totalPages); &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec73"/>Summary</h1></div></div></div><p>In this chapter, we looked into the registry, the clipboard, standard dialogs, and print preview. In <a class="link" href="ch14.html" title="Chapter 14. Dialogs, Controls, and Page Setup">Chapter 14</a>, <em>Dialogs, Controls, and Page Setup</em>, we will look into custom dialogs, controls, converters, and page setup.</p></div></body></html>