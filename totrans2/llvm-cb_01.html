<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. LLVM Design and Use</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Understanding modular design</li><li class="listitem">Cross-compiling Clang/LLVM</li><li class="listitem">Converting a C source code to LLVM assembly</li><li class="listitem">Converting IR to LLVM bitcode</li><li class="listitem">Converting LLVM bitcode to target machine assembly</li><li class="listitem">Converting LLVM bitcode back to LLVM assembly</li><li class="listitem">Transforming LLVM IR</li><li class="listitem">Linking LLVM bitcode</li><li class="listitem">Executing LLVM bitcode</li><li class="listitem">Using C frontend Clang</li><li class="listitem">Using the GO frontend</li><li class="listitem">Using DragonEgg</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>In this recipe, you get to know about <strong>LLVM</strong>, its design, and how we can make multiple uses out of the various tools it provides. You will also look into how you can transform a simple C code to the LLVM intermediate representation and how you can transform it into various forms. You will also learn how the code is organized within the LLVM source tree and how can you use it to write a compiler on your own later.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Understanding modular design</h1></div></div></div><p>LLVM is designed as<a id="id0" class="indexterm"/> a set of libraries unlike other compilers such as <strong>GNU Compiler Collection</strong> (<strong>GCC</strong>). In<a id="id1" class="indexterm"/> this recipe, LLVM optimizer will be used to understand this design. As LLVM optimizer's design is library-based, it allows you to order the passes to be run in a specified order. Also, this design allows you to choose which optimization passes you can run—that is, there might be a few optimizations that might not be useful to the type of system you are designing, and only a few optimizations will be specific to the system. When looking at traditional compiler optimizers, they are built as a tightly interconnected mass of code, that is difficult to break down into small parts that you can understand and use easily. In LLVM, you need not know about how the whole system works to know about a specific optimizer. You can<a id="id2" class="indexterm"/> just pick one optimizer and use it without having to worry about other components attached to it.</p><p>Before we go ahead and look into this recipe, we must also know a little about LLVM assembly language. The LLVM code is represented in three forms: in memory compiler <strong>Intermediate Representation</strong> (<strong>IR</strong>), on <a id="id3" class="indexterm"/>disk bitcode representation, and as human readable assembly. LLVM is a <strong>Static Single Assignment</strong> (<strong>SSA</strong>)-based<a id="id4" class="indexterm"/> representation that provides type safety, low level operations, flexibility, and the capability to represent all the high-level languages cleanly. This representation is used throughout all the phases of LLVM compilation strategy. The LLVM representation aims to be a universal IR by being at a low enough level that high-level ideas may be cleanly mapped to it. Also, LLVM assembly language is well formed. If you have any doubts about understanding the LLVM assembly mentioned in this recipe, refer to the link provided in the <em>See</em> <em>also</em> section at the end of this recipe.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>We must have installed the LLVM toolchain on our host machine. Specifically, we need the <a id="id5" class="indexterm"/>
<code class="literal">opt</code> tool.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>We will run two different <a id="id6" class="indexterm"/>optimizations on the same code, one-by-one, and see how it modifies the code according to the optimization we choose.</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, let us write a code we can input for these optimizations. Here we will write it into a file named <code class="literal">testfile.ll:</code><div><pre class="programlisting">
<strong>$ cat testfile.ll</strong>
<strong>define i32 @test1(i32 %A) {</strong>
<strong>  %B = add i32 %A, 0</strong>
<strong>  ret i32 %B</strong>
<strong>}</strong>

<strong>define internal i32 @test(i32 %X, i32 %dead) {</strong>
<strong>  ret i32 %X</strong>
<strong>}</strong>

<strong>define i32 @caller() {</strong>
<strong>  %A = call i32 @test(i32 123, i32 456)</strong>
<strong>  ret i32 %A</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Now, run the <code class="literal">opt</code> tool for<a id="id7" class="indexterm"/> one of the optimizations—that is, for combining the instruction:<div><pre class="programlisting">
<strong>$ opt –S –instcombine testfile.ll –o output1.ll</strong>
</pre></div></li><li class="listitem">View the output to see how <code class="literal">instcombine</code> has worked:<div><pre class="programlisting">
<strong>$ cat output1.ll</strong>
<strong>; ModuleID = 'testfile.ll'</strong>

<strong>define i32 @test1(i32 %A) {</strong>
<strong>  ret i32 %A</strong>
<strong>}</strong>

<strong>define internal i32 @test(i32 %X, i32 %dead) {</strong>
<strong>  ret i32 %X</strong>
<strong>}</strong>

<strong>define i32 @caller() {</strong>
<strong>  %A = call i32 @test(i32 123, i32 456)</strong>
<strong>  ret i32 %A</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Run the opt<a id="id8" class="indexterm"/> command for dead argument elimination optimization:<div><pre class="programlisting">
<strong>$ opt –S –deadargelim testfile.ll –o output2.ll</strong>
</pre></div></li><li class="listitem">View the output, to see how <code class="literal">deadargelim </code>has worked:<div><pre class="programlisting">
<strong>$ cat output2.ll</strong>
<strong>; ModuleID = testfile.ll'</strong>

<strong>define i32 @test1(i32 %A) {</strong>
<strong>  %B = add i32 %A, 0</strong>
<strong>  ret i32 %B</strong>
<strong>}</strong>

<strong>define internal i32 @test(i32 %X) {</strong>
<strong>  ret i32 %X</strong>
<strong>}</strong>

<strong>define i32 @caller() {</strong>
<strong>  %A = call i32 @test(i32 123)</strong>
<strong>  ret i32 %A</strong>
<strong>}</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>In the preceding example, we can see that, for the first command, the <code class="literal">instcombine</code> pass is run, which combines the instructions and hence optimizes <code class="literal">%B = add i32 %A, 0; ret i32 %B</code> to <code class="literal">ret i32 %A</code> without affecting the code.</p><p>In the second case, when the <code class="literal">deadargelim pass</code> is run, we can see that there is no modification in the first<a id="id9" class="indexterm"/> function, but the part of code that was not modified last time gets modified with the function arguments that are not used getting eliminated.</p><p>LLVM optimizer is the tool that provided the user with all the different passes in LLVM. These passes are all written in a similar style. For each of these passes, there is a compiled object file. Object files of different passes are archived into a library. The passes within the library are not strongly connected, and it is the LLVM<a id="id10" class="indexterm"/> <strong>PassManager</strong> that has the information about dependencies among the passes, which it resolves when a pass is executed. The following image shows how each pass can be linked to a specific object file within a specific library. In the following figure, the<a id="id11" class="indexterm"/> <strong>PassA</strong> references<a id="id12" class="indexterm"/> <strong>LLVMPasses.a</strong> for <strong>PassA.o</strong>, whereas the custom pass refers to a different library<a id="id13" class="indexterm"/> <strong>MyPasses.a</strong> for the<a id="id14" class="indexterm"/> <strong>MyPass.o</strong> object file.</p><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><div><img src="img/image00251.jpeg" alt="How it works..."/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>There's more...</h2></div></div></div><p>Similar to the optimizer, the LLVM code generator also makes use of its modular design, splitting the code generation<a id="id15" class="indexterm"/> problem into individual passes: instruction selection, register allocation, scheduling, code layout optimization, and assembly emission. Also, there are many built-in passes that are run by default. It is up to the user to choose which passes to run.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">In the upcoming chapters, we will see how to write our own custom pass, where we can choose which of the optimization passes we want to run and in which order. Also, for a more detailed understanding, refer to <a class="ulink" href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a>.</li><li class="listitem">To understand more about<a id="id16" class="indexterm"/> LLVM assembly language, refer to <a class="ulink" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Cross-compiling Clang/LLVM</h1></div></div></div><p>By cross-compiling we mean building a binary on one platform (for example, x86) that will be run on another platform (for example, ARM). The machine on which we build the binary is called<a id="id17" class="indexterm"/> the host, and the machine on which the generated binary will run is called the target. The compiler that builds code for the same platform on which it is running (the host and target platforms are the same) is called a <a id="id18" class="indexterm"/>
<strong>native assembler</strong>, whereas the compiler that builds code for a target platform different from the host platform is called a<a id="id19" class="indexterm"/> <strong>cross</strong>-<strong>compiler</strong>.</p><p>In this recipe, cross-compilation of LLVM for a platform different than the host platform will be shown, so that you can use the built binaries for the required target platform. Here, cross-compiling will be shown using an example where cross-compilation from host platform x86_64 for target platform ARM will be done. The binaries thus generated can be used on a platform with ARM architecture.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Getting ready</h2></div></div></div><p>The following packages need to be installed on your system (host platform):</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">cmake</code></li><li class="listitem"><code class="literal">ninja-build</code> (from backports in Ubuntu)</li><li class="listitem"><code class="literal">gcc-4.x-arm-linux-gnueabihf</code></li><li class="listitem"><code class="literal">gcc-4.x-multilib-arm-linux-gnueabihf</code></li><li class="listitem"><code class="literal">binutils-arm-linux-gnueabihf</code></li><li class="listitem"><code class="literal">libgcc1-armhf-cross</code></li><li class="listitem"><code class="literal">libsfgcc1-armhf-cross</code></li><li class="listitem"><code class="literal">libstdc++6-armhf-cross</code></li><li class="listitem"><code class="literal">libstdc++6-4.x-dev-armhf-cross</code></li><li class="listitem"><code class="literal">install llvm on your host platform</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><p>To compile for the ARM target from the host architecture, that is <strong>X86_64</strong> here, you need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following <code class="literal">cmake</code> flags to the normal <code class="literal">cmake</code> build for LLVM:<div><pre class="programlisting">
<strong>-DCMAKE_CROSSCOMPILING=True</strong>
<strong>-DCMAKE_INSTALL_PREFIX= path-where-you-want-the-toolchain(optional)</strong>
<strong>-DLLVM_TABLEGEN=&lt;path-to-host-installed-llvm-toolchain-bin&gt;/llvm-tblgen</strong>
<strong>-DCLANG_TABLEGEN=&lt; path-to-host-installed-llvm-toolchain-bin &gt;/clang-tblgen</strong>
<strong>-DLLVM_DEFAULT_TARGET_TRIPLE=arm-linux-gnueabihf</strong>
<strong>-DLLVM_TARGET_ARCH=ARM</strong>
<strong>-DLLVM_TARGETS_TO_BUILD=ARM</strong>
<strong>-DCMAKE_CXX_FLAGS='-target armv7a-linux-gnueabihf -mcpu=cortex-a9 -I/usr/arm-linux-gnueabihf/include/c++/4.x.x/arm-linux-gnueabihf/ -I/usr/arm-linux-gnueabihf/include/ -mfloat-abi=hard -ccc-gcc-name arm-linux-gnueabihf-gcc'</strong>
</pre></div></li><li class="listitem">If using your platform compiler, run:<div><pre class="programlisting">
<strong>$ cmake -G Ninja &lt;llvm-source-dir&gt; &lt;options above&gt;</strong>
</pre></div><p>If using Clang as the cross-compiler, run:</p><div><pre class="programlisting">
<strong>$ CC='clang' CXX='clang++' cmake -G Ninja &lt;source-dir&gt; &lt;options above&gt;</strong>
</pre></div><p>If you have clang/Clang++ on the path, it should work fine.</p></li><li class="listitem">To build LLVM, simply type:<div><pre class="programlisting">
<strong>$ ninja</strong>
</pre></div></li><li class="listitem">After the LLVM/Clang has built successfully, install it with the following command:<div><pre class="programlisting">
<strong>$ ninja install</strong>
</pre></div></li></ol><div></div><p>This will create a <code class="literal">sysroot</code> on the <code class="literal">install-dir</code> location if you have specified the <code class="literal">DCMAKE_INSTALL_PREFIX</code> options</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>The <code class="literal">cmake</code> package<a id="id20" class="indexterm"/> builds the toolchain for the required platform by making the use of option flags passed to <code class="literal">cmake</code>, and the <code class="literal">tblgen</code> tools are used to translate the target description files into C++ code. Thus, by using it, the information about targets is obtained, for example—what instructions are available on the target, the number of registers, and so on.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>If Clang is used as the cross-compiler, there is a problem in the LLVM ARM backend that produces absolute relocations on <strong>position-independent code</strong> (<strong>PIC</strong>), so as a workaround, disable PIC at the moment.</p><p>The ARM libraries will not be available on the host system. So, either download a copy of them or build them on your system.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/> Converting a C source code to LLVM assembly</h1></div></div></div><p>Here we<a id="id21" class="indexterm"/> will convert a C code to intermediate representation in<a id="id22" class="indexterm"/> LLVM using the C frontend Clang.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Getting ready</h2></div></div></div><p>Clang must be installed in the PATH.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Lets create a C code in the <code class="literal">multiply.c</code> file, which will look something like the following:<div><pre class="programlisting">
<strong>$ cat multiply.c</strong>
<strong>int mult() {</strong>
<strong>int a =5;</strong>
<strong>int b = 3;</strong>
<strong>int c = a * b;</strong>
<strong>return c;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Use the following<a id="id23" class="indexterm"/> command to generate LLVM IR from the C code:<div><pre class="programlisting">
<strong>$ clang -emit-llvm -S multiply.c -o multiply.ll</strong>
</pre></div></li><li class="listitem">Have a look at the generated IR:<div><pre class="programlisting">
<strong>$ cat multiply.ll</strong>
<strong>; ModuleID = 'multiply.c'</strong>
<strong>target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong>
<strong>target triple = "x86_64-unknown-linux-gnu"</strong>

<strong>; Function Attrs: nounwind uwtable</strong>
<strong>define i32 @mult() #0 {</strong>
<strong>  %a = alloca i32, align 4</strong>
<strong>  %b = alloca i32, align 4</strong>
<strong>  %c = alloca i32, align 4</strong>
<strong>  store i32 5, i32* %a, align 4</strong>
<strong>  store i32 3, i32* %b, align 4</strong>
<strong>  %1 = load i32* %a, align 4</strong>
<strong>  %2 = load i32* %b, align 4</strong>
<strong>  %3 = mul nsw i32 %1, %2</strong>
<strong>  store i32 %3, i32* %c, align 4</strong>
<strong>  %4 = load i32* %c, align 4</strong>
<strong>  ret i32 %4</strong>
<strong>}</strong>
</pre></div><p>We can also use the <code class="literal">cc1</code> for generating IR:</p><div><pre class="programlisting">
<strong>$ clang -cc1 -emit-llvm testfile.c -o testfile.ll</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How it works...</h2></div></div></div><p>The process of C code getting converted to IR starts with the process of lexing, wherein the C code is broken into a token stream, with each token representing an Identifier, Literal, Operator, and so<a id="id24" class="indexterm"/> on. This stream of tokens is fed to the parser, which builds up an abstract syntax tree with the help of <a id="id25" class="indexterm"/>
<strong>Context free grammar</strong> (<strong>CFG</strong>) for the language. Semantic analysis is done afterwards to check whether the code is semantically correct, and then we generate<a id="id26" class="indexterm"/> code to IR.</p><p>Here we use the Clang<a id="id27" class="indexterm"/> frontend to generate the IR file from C code.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">In the next chapter, we will see how the lexer and parser work and how code<a id="id28" class="indexterm"/> generation is done. To understand the basics of LLVM IR, you can refer to <a class="ulink" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Converting IR to LLVM bitcode</h1></div></div></div><p>In this recipe, you <a id="id29" class="indexterm"/>will learn to generate LLVM bit code from IR. The LLVM bit <a id="id30" class="indexterm"/>code file format (also known as bytecode) is actually two things: a bitstream container format and an encoding of LLVM IR into the container format.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting Ready</h2></div></div></div><p>The <code class="literal">llvm-as</code> tool must be installed in the PATH.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First create an IR code that will be used as input to <code class="literal">llvm-as</code>:<div><pre class="programlisting">
<strong>$ cat test.ll</strong>
<strong>define i32 @mult(i32 %a, i32 %b) #0 {</strong>
<strong>  %1 = mul nsw i32 %a, %b</strong>
<strong>  ret i32 %1</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">To convert LLVM IR in <code class="literal">test.ll</code> to bitcode format, you need to use the following command:<div><pre class="programlisting">
<strong>llvm-as test.ll –o test.bc</strong>
</pre></div></li><li class="listitem">The output is<a id="id31" class="indexterm"/> generated in the <code class="literal">test.bc</code> file, which<a id="id32" class="indexterm"/> is in bit stream format; so, when we want to have a look at output in text format, we get it as shown in the following screenshot:<div><img src="img/image00252.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><p>Since this is a bitcode file, the best way to view its content would be by using the<a id="id33" class="indexterm"/> <code class="literal">hexdump</code> tool. The following screenshot shows the output of <code class="literal">hexdump</code>:</p><div><img src="img/image00253.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>The <code class="literal">llvm-as</code> is the LLVM assembler. It converts the LLVM assembly file that is the LLVM IR into LLVM<a id="id34" class="indexterm"/> bitcode. In the preceding command, it takes the <code class="literal">test.ll</code> file as the input and outputs, and <code class="literal">test.bc</code> as the bitcode file.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>There's more...</h2></div></div></div><p>To encode LLVM IR<a id="id35" class="indexterm"/> into bitcode, the concept of blocks and records is used. Blocks represent regions of bitstream, for example—a function body, symbol table, and so on. Each block has an ID specific to its content (for example, function bodies in LLVM IR are represented by ID 12). Records consist of a record code and an integer value, and they describe the entities within the file such as instructions, global variable descriptors, type descriptions, and so on.</p><p>Bitcode files for LLVM IR might be wrapped in a simple wrapper structure. This structure contains a<a id="id36" class="indexterm"/> simple header that indicates the offset and size of the embedded BC file.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To get a<a id="id37" class="indexterm"/> detailed understanding of the LLVM the bitstream<a id="id38" class="indexterm"/> file format, refer to <a class="ulink" href="http://llvm.org/docs/BitCodeFormat.html#abstract">http://llvm.org/docs/BitCodeFormat.html#abstract</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Converting LLVM bitcode to target machine assembly</h1></div></div></div><p>In this recipe, you <a id="id39" class="indexterm"/>will learn how to<a id="id40" class="indexterm"/> convert the LLVM bitcode file to target specific assembly code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>Getting ready</h2></div></div></div><p>The LLVM static compiler <code class="literal">llc</code> should be in installed from the LLVM toolchain.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The bitcode file created in the previous recipe, <code class="literal">test.bc,</code> can be used as input to <code class="literal">llc</code> here. Using the following command, we can convert LLVM bitcode to assembly code:<div><pre class="programlisting">
<strong>$ llc test.bc –o test.s</strong>
</pre></div></li><li class="listitem">The output is generated in the <code class="literal">test.s</code> file, which is the assembly code. To have a look at that, use the following command lines:<div><pre class="programlisting">
<strong>$ cat test.s</strong>
<strong>.text</strong>
<strong>.file "test.bc"</strong>
<strong>.globl mult</strong>
<strong>.align 16, 0x90</strong>
<strong>.type mult,@function</strong>
<strong>mult:                                   # @mult</strong>
<strong>.cfi_startproc</strong>
<strong># BB#0:</strong>
<strong>Pushq  %rbp</strong>
<strong>.Ltmp0:</strong>
<strong>.cfi_def_cfa_offset 16</strong>
<strong>.Ltmp1:</strong>
<strong>.cfi_offset %rbp, -16</strong>
<strong>movq %rsp, %rbp</strong>
<strong>.Ltmp2:</strong>
<strong>.cfi_def_cfa_register %rbp</strong>
<strong>imull %esi, %edi</strong>
<strong>movl %edi, %eax</strong>
<strong>popq %rbp</strong>
<strong>retq</strong>
<strong>.Ltmp3:</strong>
<strong>.size mult, .Ltmp3-mult</strong>
<strong>.cfi_endproc</strong>
</pre></div></li><li class="listitem">You can also use Clang to dump assembly code from the bitcode file format. By passing the <code class="literal">–S</code> option to Clang, we get <code class="literal">test.s</code> in assembly format when the <code class="literal">test.bc</code> file is in bitstream file format:<div><pre class="programlisting">
<strong>$ clang -S test.bc -o test.s –fomit-frame-pointer # using the clang front end</strong>
</pre></div><p>The <code class="literal">test.s</code> file output is the same as that of the preceding example. We use the additional option <code class="literal">fomit-frame-pointer</code>, as Clang by default does not eliminate the frame pointer whereas <code class="literal">llc</code> eliminates it by default.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How it works...</h2></div></div></div><p>The <code class="literal">llc</code> command compiles LLVM input into assembly language for a specified architecture. If we do <a id="id41" class="indexterm"/>not mention any architecture as in the preceding command, the assembly will be generated for the host machine<a id="id42" class="indexterm"/> where the <code class="literal">llc</code> command is being used. To generate executable from this assembly file, you can use assembler and linker.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>There's more...</h2></div></div></div><p>By specifying <code class="literal">-march=architecture flag</code> in the preceding command, you can specify the target architecture for which the assembly needs to be generated. Using the <code class="literal">-mcpu=cpu flag</code> setting, you can specify a CPU within the architecture to generate code. Also by specifying <code class="literal">-regalloc=basic/greedy/fast/pbqp,</code> you can specify the type of register allocation to be used.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Converting LLVM bitcode back to LLVM assembly</h1></div></div></div><p>In this recipe, you will<a id="id43" class="indexterm"/> convert<a id="id44" class="indexterm"/> LLVM bitcode back to LLVM IR. Well, this is actually possible using the LLVM disassembler tool called<a id="id45" class="indexterm"/> <code class="literal">llvm-dis.</code>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>Getting ready</h2></div></div></div><p>To do this, you need the <code class="literal">llvm-dis</code> tool installed.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How to do it...</h2></div></div></div><p>To see how the bitcode file is getting converted to IR, use the <code class="literal">test.bc</code> file generated in the recipe <em>Converting IR to LLVM Bitcode</em>. The <code class="literal">test.bc</code> file is provided as the input to the <code class="literal">llvm-dis</code> tool. Now proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Using the following command shows how to convert a bitcode file to an the one we had created in the IR file:<div><pre class="programlisting">
<strong>$ llvm-dis test.bc –o test.ll</strong>
</pre></div></li><li class="listitem">Have a look at the generated LLVM IR by the following:<div><pre class="programlisting">
<strong>| $ cat test.ll</strong>
<strong>; ModuleID = 'test.bc'</strong>

<strong>define i32 @mult(i32 %a, i32 %b) #0 {</strong>
<strong>  %1 = mul nsw i32 %a, %b</strong>
<strong>  ret i32 %1</strong>
<strong>}</strong>
</pre></div><p>The output <code class="literal">test.ll</code> file is the same as the one we created in the recipe <em>Converting IR to LLVM Bitcode</em>.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How it works...</h2></div></div></div><p>The <code class="literal">llvm-dis</code> command is<a id="id46" class="indexterm"/> the LLVM disassembler. It takes an LLVM bitcode file and converts it into LLVM assembly language.</p><p>Here, the input file is <code class="literal">test.bc</code>, which is transformed to <code class="literal">test.ll</code> by <code class="literal">llvm-dis</code>.</p><p>If the filename is omitted, <code class="literal">llvm-dis</code> reads its input from standard input.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Transforming LLVM IR</h1></div></div></div><p>In this recipe, we will<a id="id47" class="indexterm"/> see how we can transform the IR from one form to another using the opt tool. We will see different optimizations being applied to IR code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>You need to have the opt tool installed.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><p>The <code class="literal">opt</code> tool runs the transformation pass as in the following command:</p><div><pre class="programlisting">
<strong>$opt –passname input.ll –o output.ll</strong>
</pre></div><div><ol class="orderedlist arabic"><li class="listitem">Let's take an actual example now. We create the LLVM IR equivalent to the C code used in the recipe <em>Converting a C source code to LLVM assembly</em>:<div><pre class="programlisting">
<strong>$ cat multiply.c</strong>
<strong>int mult() {</strong>
<strong>int a =5;</strong>
<strong>int b = 3;</strong>
<strong>int c = a * b;</strong>
<strong>return c;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Converting and outputting it, we get the unoptimized output:<div><pre class="programlisting">
<strong>$ clang -emit-llvm -S multiply.c -o multiply.ll</strong>
<strong>$ cat multiply.ll</strong>
<strong>; ModuleID = 'multiply.c'</strong>
<strong>target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong>
<strong>target triple = "x86_64-unknown-linux-gnu"</strong>

<strong>; Function Attrs: nounwind uwtable</strong>
<strong>define i32 @mult() #0 {</strong>
<strong>  %a = alloca i32, align 4</strong>
<strong>  %b = alloca i32, align 4</strong>
<strong>  %c = alloca i32, align 4</strong>
<strong>  store i32 5, i32* %a, align 4</strong>
<strong>  store i32 3, i32* %b, align 4</strong>
<strong>  %1 = load i32* %a, align 4</strong>
<strong>  %2 = load i32* %b, align 4</strong>
<strong>  %3 = mul nsw i32 %1, %2</strong>
<strong>  store i32 %3, i32* %c, align 4</strong>
<strong>  %4 = load i32* %c, align 4</strong>
<strong>  ret i32 %4</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Now use the<a id="id48" class="indexterm"/> opt tool to transform it to a form where memory is promoted to register:<div><pre class="programlisting">
<strong>$ opt -mem2reg -S multiply.ll -o multiply1.ll</strong>
<strong>$ cat multiply1.ll</strong>
<strong>; ModuleID = 'multiply.ll'</strong>
<strong>target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong>
<strong>target triple = "x86_64-unknown-linux-gnu"</strong>

<strong>; Function Attrs: nounwind uwtable</strong>
<strong>define i32 @mult(i32 %a, i32 %b) #0 {</strong>
<strong>  %1 = mul nsw i32 %a, %b</strong>
<strong>  ret i32 %1</strong>
<strong>}</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>The <code class="literal">opt</code>, LLVM optimizer, and analyzer tools take the <code class="literal">input.ll</code> file as the input and run the pass <code class="literal">passname</code> on it. The output after running the pass is obtained in the <code class="literal">output.ll</code> file that contains the IR code after the transformation. There can be more than one pass passed to the opt tool.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>There's more...</h2></div></div></div><p>When the <code class="literal">–analyze</code> option is passed to opt, it performs various analyses of the input source and prints results usually on the standard output or standard error. Also, the output can be redirected to a file when it is meant to be fed to another program.</p><p>When the –analyze option is not passed to opt, it runs the transformation passes meant to optimize the input file.</p><p>Some of the important transformations are listed as follows, which can be passed as a flag to the opt tool:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">adce</code>: Aggressive Dead Code Elimination</li><li class="listitem"><code class="literal">bb-vectorize</code>: Basic-Block Vectorization</li><li class="listitem"><code class="literal">constprop</code>: Simple constant propagation</li><li class="listitem"><code class="literal">dce</code>: Dead Code Elimination</li><li class="listitem"><code class="literal">deadargelim</code>: Dead Argument Elimination</li><li class="listitem"><code class="literal">globaldce</code>: Dead Global Elimination</li><li class="listitem"><code class="literal">globalopt</code>: Global Variable Optimizer</li><li class="listitem"><code class="literal">gvn</code>: Global Value Numbering</li><li class="listitem"><code class="literal">inline</code>: Function Integration/Inlining</li><li class="listitem"><code class="literal">instcombine</code>: Combine redundant instructions</li><li class="listitem"><code class="literal">licm</code>: Loop Invariant Code Motion</li><li class="listitem"><code class="literal">loop</code>: unswitch: Unswitch loops</li><li class="listitem"><code class="literal">loweratomic</code>: Lower atomic intrinsics to non-atomic form</li><li class="listitem"><code class="literal">lowerinvoke</code>: Lower invokes to calls, for unwindless code generators</li><li class="listitem"><code class="literal">lowerswitch</code>: Lower SwitchInsts to branches</li><li class="listitem"><code class="literal">mem2reg</code>: Promote Memory to Register</li><li class="listitem"><code class="literal">memcpyopt</code>: MemCpy Optimization</li><li class="listitem"><code class="literal">simplifycfg</code>: Simplify the CFG</li><li class="listitem"><code class="literal">sink</code>: Code sinking</li><li class="listitem"><code class="literal">tailcallelim</code>: Tail Call Elimination</li></ul></div><p>Run at least some of the preceding passes to get an understanding of how they work. To get to the appropriate source code on which these passes might be applicable, go to the <code class="literal">llvm/test/Transforms</code> directory. For each of the above mentioned passes, you can see the test codes. Apply the relevant pass<a id="id49" class="indexterm"/> and see how the test code is getting modified.</p><div><h3 class="title"><a id="note03"/>Note</h3><p>To see the mapping of how C code is converted to IR, after converting the C code to IR, as discussed in an earlier recipe <em>Converting a C source code to LLVM assembly</em>, run the <code class="literal">mem2reg</code> pass. It will then help you understand how a C instruction is getting mapped into IR instructions.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Linking LLVM bitcode</h1></div></div></div><p>In this section, you <a id="id50" class="indexterm"/>will link previously generated <code class="literal">.bc</code> files to get one single bitcode file containing all the needed references.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>Getting ready</h2></div></div></div><p>To link the <code class="literal">.bc</code> files, you need the <code class="literal">llvm-link</code> tool.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To show the working of <code class="literal">llvm-link</code>, first write two codes in different files, where one makes a reference to the other:<div><pre class="programlisting">
<strong>$ cat test1.c</strong>
<strong>int func(int a) {</strong>
<strong>a = a*2;</strong>
<strong>return a;</strong>
<strong>}</strong>
<strong>$ cat test2.c</strong>
<strong>#include&lt;stdio.h&gt;</strong>
<strong>extern int func(int a);</strong>
<strong>int main() {</strong>
<strong>int num = 5;</strong>
<strong>num = func(num);</strong>
<strong>printf("number is %d\n", num);</strong>
<strong>return num;</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Using the following formats to convert this C code to bitstream file format, first convert to <code class="literal">.ll</code> files, then from <code class="literal">.ll</code> files to <code class="literal">.bc</code> files:<div><pre class="programlisting">
<strong>$ clang -emit-llvm -S test1.c -o test1.ll</strong>
<strong>$ clang -emit-llvm -S test2.c -o test2.ll</strong>
<strong>$ llvm-as test1.ll -o test1.bc</strong>
<strong>$ llvm-as test2.ll -o test2.bc</strong>
</pre></div><p>We get <code class="literal">test1.bc</code> and <code class="literal">test2.bc</code> with <code class="literal">test2.bc</code> making a reference to <code class="literal">func</code> syntax in the <code class="literal">test1.bc</code> file.</p></li><li class="listitem">Invoke the <code class="literal">llvm-link</code> command in the following way to link the two LLVM bitcode files:<div><pre class="programlisting">
<strong>$ llvm-link test1.bc test2.bc –o output.bc</strong>
</pre></div></li></ol><div></div><p>We provide multiple bitcode files<a id="id51" class="indexterm"/> to the <code class="literal">llvm-link</code> tool, which links them together to generate a single bitcode file. Here, <code class="literal">output.bc</code> is the generated output file. We will execute this bitcode file in the next recipe <em>Executing LLVM bitcode</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How it works...</h2></div></div></div><p>The <code class="literal">llvm-link</code> works using the basic functionality of a linker—that is, if a function or variable referenced in one file is defined in the other file, it is the job of linker to resolve all the references made in a file and defined in the other file. But note that this is not the traditional linker that links various <a id="id52" class="indexterm"/>object files to generate a binary. The <code class="literal">llvm-link</code> tool links bitcode files only.</p><p>In the preceding scenario, it is linking <code class="literal">test1.bc</code> and <code class="literal">test2.bc</code> files to generate the <code class="literal">output.bc</code> file, which has references resolved.</p><div><h3 class="title"><a id="note04"/>Note</h3><p>After linking the bitcode files, we can generate the output as an IR file by giving <code class="literal">–S</code> option to the <code class="literal">llvm-link</code> tool.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Executing LLVM bitcode</h1></div></div></div><p>In this recipe, you will execute<a id="id53" class="indexterm"/> the LLVM bitcode that was generated in previous recipes.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>Getting ready</h2></div></div></div><p>To execute the LLVM bitcode, you need the <code class="literal">lli</code> tool.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>How to do it...</h2></div></div></div><p>We saw in the previous recipe how to create a single bitstream file after linking the two <code class="literal">.bc</code> files with one referencing the other to define <code class="literal">func</code>. By invoking the <code class="literal">lli</code> command in the following way, we can execute the <code class="literal">output.bc</code> file generated. It will display the output on the standard output:</p><div><pre class="programlisting">
<strong>| $ lli output.bc</strong>
<strong>   number is 10</strong>
</pre></div><p>
<code class="literal">The output.bc</code> file is the input to <code class="literal">lli</code>, which will execute the bitcode file and display the output, if any, on the standard output. Here the output is generated as number is <code class="literal">10</code>, which is a result of the execution of the <code class="literal">output.bc</code> file formed by linking <code class="literal">test1.c</code> and <code class="literal">test2.c</code> in the previous recipe. The main function in the <code class="literal">test2.c</code> file calls the function <code class="literal">func</code> in the <code class="literal">test1.c</code> file with integer 5 as the argument to the function. The <code class="literal">func</code> function doubles the input argument and returns the result to main the function that outputs it on the standard output.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec46"/>How it works...</h2></div></div></div><p>The <code class="literal">lli</code> tool <a id="id54" class="indexterm"/>command executes the program present in LLVM bitcode format. It takes the input in LLVM <a id="id55" class="indexterm"/>bitcode format and executes it using a just-in-time compiler, if there is one available for the architecture, or an interpreter.</p><p>If <code class="literal">lli</code> is making use of a just-in-time compiler, then it effectively takes all the code generator options as that of <code class="literal">llc</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec47"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Adding JIT support for a language</em> recipe in <a class="link" title="Chapter 3. Extending the Frontend and Adding JIT Support" href="part0041.xhtml#aid-173721">Chapter 3</a>, <em>Extending the Frontend and Adding JIT support</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Using the C frontend Clang</h1></div></div></div><p>In this recipe, you<a id="id56" class="indexterm"/> will get to know how the Clang frontend can be used for different purposes.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec48"/>Getting ready</h2></div></div></div><p>You will need Clang tool.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec49"/>How to do it…</h2></div></div></div><p>Clang can be used as the high-level compiler driver. Let us show it using an example:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">hello world</code> C code, <code class="literal">test.c</code>:<div><pre class="programlisting">
<strong>$ cat test.c</strong>
<strong>#include&lt;stdio.h&gt;</strong>
<strong>int main() {</strong>
<strong>printf("hello world\n");</strong>
<strong>return 0; }</strong>
</pre></div></li><li class="listitem">Use Clang as a compiler driver to generate the executable <code class="literal">a.out</code> file, which on execution gives the output as expected:<div><pre class="programlisting">
<strong>$ clang test.c</strong>
<strong>$ ./a.out</strong>
<strong>hello world</strong>
</pre></div><p>Here the <code class="literal">test.c</code> file containing C code is created. Using Clang we compile it and produce an executable that on execution gives the desired result.</p></li><li class="listitem">Clang can be used in preprocessor only mode by providing the <code class="literal">–E</code> flag. In the following example, create a C code having a #define directive defining the value of MAX and use this MAX as the size of the array you are going to create:<div><pre class="programlisting">
<strong>$ cat test.c</strong>
<strong>#define MAX 100</strong>
<strong>void func() {</strong>
<strong>int a[MAX];</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Run the preprocessor <a id="id57" class="indexterm"/>using the following command, which gives the output on standard output:<div><pre class="programlisting">
<strong>$ clang test.c -E</strong>
<strong># 1 "test.c"</strong>
<strong># 1 "&lt;built-in&gt;" 1</strong>
<strong># 1 "&lt;built-in&gt;" 3</strong>
<strong># 308 "&lt;built-in&gt;" 3</strong>
<strong># 1 "&lt;command line&gt;" 1</strong>
<strong># 1 "&lt;built-in&gt;" 2</strong>
<strong># 1 "test.c" 2</strong>

<strong>void func() {</strong>
<strong>int a[100];</strong>
<strong>}</strong>
</pre></div><p>In the <code class="literal">test.c</code> file, which will be used in all the subsequent sections of this recipe, MAX is defined to be <code class="literal">100</code>, which on preprocessing is substituted to MAX in <code class="literal">a[MAX]</code>, which becomes <code class="literal">a[100]</code>.</p></li><li class="listitem">You can print the AST for the <code class="literal">test.c</code> file from the preceding example using the following command, which displays the output on standard output:<div><pre class="programlisting">
<strong>| $ clang -cc1 test.c -ast-dump</strong>
<strong>TranslationUnitDecl 0x3f72c50 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;|-TypedefDecl 0x3f73148 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128'|-TypedefDecl 0x3f731a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128'|-TypedefDecl 0x3f73518 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list '__va_list_tag [1]'`-FunctionDecl 0x3f735b8 &lt;test.c:3:1, line:5:1&gt; line:3:6 func 'void ()'`-CompoundStmt 0x3f73790 &lt;col:13, line:5:1&gt;`-DeclStmt 0x3f73778 &lt;line:4:1, col:11&gt;`-VarDecl 0x3f73718 &lt;col:1, col:10&gt; col:5 a 'int [100]'</strong>
</pre></div><p>Here, the <code class="literal">–cc1</code> option ensures that only the compiler front-end should be run, not the driver, and it prints the AST corresponding to the <code class="literal">test.c</code> file code.</p></li><li class="listitem">You can generate<a id="id58" class="indexterm"/> the LLVM assembly for the <code class="literal">test.c</code> file in previous examples, using the following command:<div><pre class="programlisting">
<strong>|$ clang test.c -S -emit-llvm -o -</strong>
<strong>|; ModuleID = 'test.c'</strong>
<strong>|target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong>
<strong>|target triple = "x86_64-unknown-linux-gnu"</strong>
<strong>|</strong>
<strong>|; Function Attrs: nounwind uwtable</strong>
<strong>|define void @func() #0 {</strong>
<strong>|%a = alloca [100 x i32], align 16</strong>
<strong>|ret void</strong>
<strong>|}</strong>
</pre></div><p>The <code class="literal">–S</code> and <code class="literal">–emit-llvm</code> flag ensure the LLVM assembly is generated for the <code class="literal">test.c</code> code.</p></li><li class="listitem">To get machine code use for the same <code class="literal">test.c</code> testcode, pass the <code class="literal">–S</code> flag to Clang. It generates the output on standard output because of the option <code class="literal">–o –</code>:<div><pre class="programlisting">
<strong>|$ clang -S test.c -o -</strong>
<strong>|	.text</strong>
<strong>|	.file	"test.c"</strong>
<strong>|	.globl	func</strong>
<strong>|	.align	16, 0x90</strong>
<strong>|	.type	func,@function</strong>
<strong>|func:                                   # @func</strong>
<strong>|	.cfi_startproc</strong>
<strong>|# BB#0:</strong>
<strong>|	pushq	%rbp</strong>
<strong>|.Ltmp0:</strong>
<strong>|	.cfi_def_cfa_offset 16</strong>
<strong>|.Ltmp1:</strong>
<strong>|	.cfi_offset %rbp, -16</strong>
<strong>|	movq	%rsp, %rbp</strong>
<strong>|.Ltmp2:</strong>
<strong>|	.cfi_def_cfa_register %rbp</strong>
<strong>|	popq	%rbp</strong>
<strong>|	retq</strong>
<strong>|.Ltmp3:</strong>
<strong>|	.size	func, .Ltmp3-func</strong>
<strong>|	.cfi_endproc</strong>
</pre></div></li></ol><div></div><p>When the <code class="literal">–S</code> flag is used alone, machine code is generated by the code generation process of the compiler. Here, on running the command, machine code is output on the standard output as we use <code class="literal">–o –</code> options.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec50"/>How it works...</h2></div></div></div><p>Clang works as a<a id="id59" class="indexterm"/> preprocessor, compiler driver, frontend, and code generator in the preceding examples, thus giving the desired output as per the input flag given to it.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec51"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">This was a basic introduction to how Clang can be used. There are also many other flags that can be passed to Clang, which makes it perform different operation. To see the list, use Clang <code class="literal">–help</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Using the GO frontend</h1></div></div></div><p>The <code class="literal">llgo</code> compiler is the LLVM-based<a id="id60" class="indexterm"/> frontend for Go written in Go language only. Using this frontend, we can generate the LLVM assembly code from a program written in Go.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec52"/>Getting ready</h2></div></div></div><p>You need to download the <code class="literal">llgo</code> binaries or build <code class="literal">llgo</code> from the source code and add the binaries in the <code class="literal">PATH</code> file location as configured.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec53"/>How to do it…</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a Go source file, for example, that will be used for generating the LLVM assembly using <code class="literal">llgo</code>. Create <code class="literal">test.go</code>:<div><pre class="programlisting">
<strong>|$ cat test.go</strong>
<strong>|package main</strong>
<strong>|import "fmt"</strong>
<strong>|func main() {</strong>
<strong>| fmt.Println("Test Message")</strong>
<strong>|}</strong>
</pre></div></li><li class="listitem">Now, use <code class="literal">llgo</code> to get the LLVM assembly:<div><pre class="programlisting">
<strong>$llgo -dump test.go</strong>
<strong>; ModuleID = 'main'</strong>
<strong>target datalayout = "e-p:64:64:64..."</strong>
<strong>target triple = "x86_64-unknown-linux"</strong>
<strong>%0 = type { i8*, i8* }</strong>
<strong>....</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec54"/>How it works…</h2></div></div></div><p>The <code class="literal">llgo</code> compiler is the frontend for the Go language; it takes the <code class="literal">test.go</code> program as its input and<a id="id61" class="indexterm"/> emits the LLVM IR.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec55"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For information about how to<a id="id62" class="indexterm"/> get and install <code class="literal">llgo,</code> refer to <a class="ulink" href="https://github.com/go-llvm/llgo">https://github.com/go-llvm/llgo</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Using DragonEgg</h1></div></div></div><p>Dragonegg is a<a id="id63" class="indexterm"/> gcc plugin that allows gcc to make use of the LLVM optimizer and code generator instead of gcc's own optimizer and code generator.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec56"/>Getting ready</h2></div></div></div><p>You need to have gcc 4.5 or above, with the target machine being <code class="literal">x86-32/x86-64</code> and an ARM processor. Also, you need to download the dragonegg source code and build the <code class="literal">dragonegg.so</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec57"/>How to do It…</h2></div></div></div><p>Do the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a simple <code class="literal">hello world</code> program:<div><pre class="programlisting">
<strong>$ cat testprog.c</strong>
<strong>#include&lt;stdio.h&gt;</strong>
<strong>int main() {</strong>
<strong>printf("hello world");</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Compile this program with your gcc; here we use gcc-4.5:<div><pre class="programlisting">
<strong>$ gcc testprog.c -S -O1 -o -</strong>
<strong>  .file  " testprog.c"</strong>
<strong>  .section  .rodata.str1.1,"aMS",@progbits,1</strong>
<strong>.LC0:</strong>
<strong>  .string  "Hello world!"</strong>
<strong>  .text</strong>
<strong>.globl main</strong>
<strong>  .type  main, @function</strong>
<strong>main:</strong>
<strong>  subq  $8, %rsp</strong>
<strong>  movl  $.LC0, %edi</strong>
<strong>  call  puts</strong>
<strong>  movl  $0, %eax</strong>
<strong>  addq  $8, %rsp</strong>
<strong>  ret</strong>
<strong>  .size  main, .-main</strong>
</pre></div></li><li class="listitem">Using the <code class="literal">-fplugin=path/dragonegg.so</code> flag in the command line of gcc makes gcc<a id="id64" class="indexterm"/> use LLVM's optimizer and LLVM codegen:<div><pre class="programlisting">
<strong>$ gcc testprog.c -S -O1 -o - -fplugin=./dragonegg.so</strong>
<strong>  .file  " testprog.c"</strong>
<strong># Start of file scope inline assembly</strong>
<strong>  .ident  "GCC: (GNU) 4.5.0 20090928 (experimental) LLVM: 82450:82981"</strong>
<strong># End of file scope inline assembly</strong>


<strong>  .text</strong>
<strong>  .align  16</strong>
<strong>  .globl  main</strong>
<strong>  .type  main,@function</strong>
<strong>main:</strong>
<strong>  subq  $8, %rsp</strong>
<strong>  movl  $.L.str, %edi</strong>
<strong>  call  puts</strong>
<strong>  xorl  %eax, %eax</strong>
<strong>  addq  $8, %rsp</strong>
<strong>  ret</strong>
<strong>  .size  main, .-main</strong>
<strong>  .type  .L.str,@object</strong>
<strong>  .section  .rodata.str1.1,"aMS",@progbits,1</strong>
<strong>.L.str:</strong>
<strong>  .asciz  "Hello world!"</strong>
<strong>  .size  .L.str, 13</strong>

<strong>  .section  .note.GNU-stack,"",@progbits</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec58"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To know about<a id="id65" class="indexterm"/> how to get the source code and installation<a id="id66" class="indexterm"/> procedure, refer to <a class="ulink" href="http://dragonegg.llvm.org/">http://dragonegg.llvm.org/</a></li></ul></div></div></div></body></html>