<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Where to Go from Here"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Where to Go from Here</h1></div></div></div><p>We've finally reached the end of our journey for now, but there is far more to learn about game programming. Along the way, we learned how to begin building a game development framework to build on in the future, handle user input with DirectInput and XInput, render 2D graphics and tile-based worlds with Direct2D, add sound and music to our game worlds with DirectSound and XAudio2, and lastly, how to do basic 3D graphics rendering with Direct3D. So, in this chapter, we will take a look at where to go from here in expanding your game development knowledge as well as a handful of important topics that we covered briefly in this book and some that we didn't cover.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clipping</li><li class="listitem" style="list-style-type: disc">Collision detection</li><li class="listitem" style="list-style-type: disc">Artificial Intelligence</li><li class="listitem" style="list-style-type: disc">Physics</li><li class="listitem" style="list-style-type: disc">Multithreaded programming</li><li class="listitem" style="list-style-type: disc">Game design</li><li class="listitem" style="list-style-type: disc">Further reading</li></ul></div><div class="section" title="Culling and clipping"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Culling and clipping</h1></div></div></div><p>We talked briefly about this concept in the previous chapter while working on our <span class="emphasis"><em>Cube</em></span> demo. <span class="strong"><strong>Culling</strong></span> in 2D terms means removing or skipping objects that are not within the bounds of the screen<a id="id415" class="indexterm"/> rather than wasting time drawing things that aren't visible anyway. In <a id="id416" class="indexterm"/>3D terms, the meaning is much the same, but it's obviously a bit more complicated since you have that third dimension to deal with.</p><p>
<span class="strong"><strong>Clipping</strong></span> is the removal of the portions of individual triangles of our game objects that are not seen fully on the screen. The part of the triangle that is off screen is removed. Direct3D handles clipping for us in its graphics pipeline, but the culling is left to us. Culling is the removal or skipping of entire objects in the scene that do not need to be drawn, since they are not currently visible. Direct3D can do backface culling for us though. This is the removal of the back face of a triangle that is facing away from the camera. We can't see it, so we don't need to draw it.</p><p>Culling and clipping<a id="id417" class="indexterm"/> are used in most modern video games. It is a very important <a id="id418" class="indexterm"/>concept because it can give you significant performance gains. The more objects there are in your game world, the longer it will take the computer to loop through and draw every single one of them. So, clipping can save a lot of time.</p><p>This is not the only way of limiting what gets drawn in each frame though. There are other methods used in many games to make sure that objects are not drawn unnecessarily. For example, if there is a wall or other obstruction between the player and an object, we don't need to draw that object since the player can't see it anyway (unless, of course, there is a window or something). This is a little trickier to do. The point is that like with most things, there is more than one way to get the job done.</p></div></div>
<div class="section" title="Collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Collision detection</h1></div></div></div><p>
<span class="strong"><strong>Collision detection</strong></span> is what it sounds like; detecting collisions of objects in your game world. In two <a id="id419" class="indexterm"/>dimensions, it's relatively easy since everything generally has simple square shaped <span class="strong"><strong>bounding boxes</strong></span>. A bounding box is an imaginary <a id="id420" class="indexterm"/>shape around the object that we use to detect collisions. You just test if the bounding boxes of two objects intersect each other, and if so, you know that they have collided. Of course, they are invisible to the player since we never draw our bounding boxes on the screen. However, it could be useful to add code to your game that lets you see the bounding boxes for debugging purposes, and verify that they are working as intended. Another good idea is to add a developer console to your game like those seen in many first-person-shooter games such as <span class="emphasis"><em>Half-Life 2</em></span>.</p><p>In 3D, it gets more complicated. There are various types of bounding boxes that you can use. The commonly used ones are cubical or spherical bounding boxes. The cubic ones don't necessarily need to be perfect cubes. They can essentially be of any size, or have a longer width than height, for example. The spherical variety is usually a perfect sphere around an object but it, could be oblong though if the object is taller than it is wide. The spherical bounding boxes also behave a bit differently since you won't have cases where just the corners of two bounding boxes intersect, since spheres do not have corners like cubes do. You could also use different types of bounding boxes in 2D, of course.</p></div>
<div class="section" title="Artificial Intelligence"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Artificial Intelligence</h1></div></div></div><p>
<span class="strong"><strong>Artificial Intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) refers to the intelligence that we code into the creatures in our game worlds. It is essentially the code that controls the actions of a creature. How smart this code<a id="id421" class="indexterm"/> is determines how smart our creature is. Of <a id="id422" class="indexterm"/>course, this concept is closely linked to <span class="strong"><strong>path finding</strong></span> as well. Path finding is the process of finding a path that will allow the creature to reach its <a id="id423" class="indexterm"/>intended destination. One path finding algorithm is the <code class="literal">A*</code> algorithm (see <a class="ulink" href="http://en.wikipedia.org/wiki/A*_search_algorithm">http://en.wikipedia.org/wiki/A*_search_algorithm</a>).</p><p>Of course, we can't process this based on the geometry of the world. It would be too complicated and take too long. One way of doing this is using <span class="strong"><strong>waypoints</strong></span>. Waypoints are essentially<a id="id424" class="indexterm"/> markers that are scattered about the world in strategic places. For example, an intersection in several paths will be a good place for a waypoint. The path-finding code simply finds the nearest waypoint to the creature's current position, and from there it finds a path from waypoint-to-waypoint that will get it to the desired destination. This is obviously much simpler and faster than trying to compute a path based on the actual geometry of the world.</p></div>
<div class="section" title="Physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Physics</h1></div></div></div><p>Physics is closely tied in with collision detection since collision detection is integral to the physics of your game. If two objects collide, we need to detect this so that we can make them<a id="id425" class="indexterm"/> behave realistically. It will look pretty silly if they both just stopped in their tracks upon colliding, or just kept going as though they were both ghosts.</p><p>Physics is a very complicated subject and relies heavily on mathematics. It is essentially just the use of mathematics to calculate the movement of objects in our game world. Of course, you can tweak your physics a bit if you want in order to achieve different effects. For example, you might make your physics work a little differently if your game has a cartoon-styled world as opposed to a realistic world.</p><p>The bounding boxes that we talked about in the previous section are generally inside the physics system of a game since that's where they are used. The physics system in a game is generally responsible for simulating the physics of objects in the game world. It is also common to give objects a <span class="emphasis"><em>sleep</em></span> state or <span class="emphasis"><em>idle</em></span> state, as it is often called. When the object is in this state, the physics system will ignore the object, and not do any physics simulation for it. This allows you to have physics turned off for a given object until it's needed. This can bring huge performance benefits because physics, being full of mathematics, can be relatively slow to run. The performance benefits increase when you have more objects that are in this state (since they aren't moving or doing anything anyway), and so, you're effectively saving the physics system from doing a lot of unnecessary work. After all, there is no point in wasting time running the physics code on an object that is not moving or doing <a id="id426" class="indexterm"/>anything.</p></div>
<div class="section" title="Multithreaded programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Multithreaded programming</h1></div></div></div><p>Normally, a program has a single thread of execution. A thread is basically code that is being run by one of the cores in a system that has multi-core processors. Most modern processors have this feature, though it should be noted that you can still have multiple threads on a single-core CPU. I wanted to include this topic because multithreading is very useful in processor-intensive applications such as video games.</p><p>Basically, multithreading<a id="id427" class="indexterm"/> lets you have more than one point of execution running in your application at the same time. So, for example, you could have one thread doing some background work such as loading resources (graphics and sounds) in a large world similar to those found in <span class="emphasis"><em>Minecraft</em></span>. As the player moves, the game has to load in the next chunks of the world, and unload the ones that are now too far behind the player. So, you could have one thread that handles loading new world chunks as the player moves around in the world, while the main thread keeps running the game code.</p><p>Of course, you are not limited to just two threads either. It is common for applications to create a group of threads and assign jobs to them. This is handy if there are numerous tasks that need to be done. You just make a thread manager class, and pass in the function that you will call to do the job that needs to be done. The thread manager will look at its threads (collectively known as a <a id="id428" class="indexterm"/>
<span class="strong"><strong>thread pool</strong></span>) and find the one that is idle. If it finds an idle <span class="strong"><strong>worker thread</strong></span>
<a id="id429" class="indexterm"/>, it will start it by running the function you passed in. A worker thread is just a thread that is a member of a thread pool, and it gets its name since it does various jobs for us.</p><p>Running multiple bits of code simultaneously like this can obviously have significant performance benefits. However, multithreaded programming is also a rather tricky subject. You have to make sure that you don't have two threads accessing the same data at the same time, as this can cause big problems.</p></div>
<div class="section" title="Game design"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Game design</h1></div></div></div><p>Game design<a id="id430" class="indexterm"/> might seem fairly simple, but there is a lot more to it than most people think at first. Game design encompasses deciding on the style of your graphics, what the world will look like, the mood, designing the main gameplay mechanics of the game, the overall goal for the player, and the basic story idea. Of course, often there are graphic and sound artists who do the actual work of creating the graphics and sound for the game. But the graphics and sound styles first need to be specified in the game design, or the artists won't know what sort of graphics and sound to create.</p><p>Probably the most important thing about a game is that it is fun. If it is not fun, the players won't play it. However, it's not quite so simple because different players like different types of <a id="id431" class="indexterm"/>games. So, what is fun for one player may not be for another. So don't try to please everyone as this is generally not possible. If you do, you could easily find yourself chasing an unreachable goal.</p><p>In the world of game design, there can be arguments about the most important element. Some will say graphics, and others will say gameplay. However, in reality, they are both very important. Graphics make a game look good, but graphics don't have to be realistic. They can be cartoony or have other styles that don't look realistic. This doesn't make a game bad by any means. A good example of this is Nintendo's <span class="emphasis"><em>The Legend of Zelda: The Wind Waker HD</em></span> that uses a graphical style known as <span class="strong"><strong>toon shading</strong></span> to give its world a cartoony look.</p><p>The final <a id="id432" class="indexterm"/>experience that you get from a game is not down to just graphics, gameplay, or sound. It's a combination of all of the elements that come together to create the final game. Of course, controls are very important because they are the interface between the player and the game. If the interface is weird or doesn't work well, players probably won't play the game much. Sound effects and music set the mood for the game world, and the graphics provide the visuals and contribute to the mood as well.</p><div class="section" title="Game difficulty"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Game difficulty</h2></div></div></div><p>Probably one of the trickiest aspects of game design is the game difficulty. You don't want to make it<a id="id433" class="indexterm"/> too easy, or some players will get bored and quit. Likewise, if you make it too difficult, some players will rage quit. So, how do we deal <a id="id434" class="indexterm"/>with this issue? One way is to make your game have multiple difficulty levels so that the players can select the one they want. Most commonly, they are named <code class="literal">Easy</code>, <code class="literal">Normal</code>, <code class="literal">Hard</code>, and sometimes <code class="literal">Very Hard</code>. Another solution is known as <a id="id435" class="indexterm"/>
<span class="strong"><strong>adaptive difficulty</strong></span>. This is when a game looks at how well the player is doing, and adjusts the difficulty as needed. If the player is doing really well, it will increase the difficulty a bit, and if the player is having trouble, it would decrease it to some extent.</p><p>Another aspect of difficulty is known as <a id="id436" class="indexterm"/>game <span class="strong"><strong>progression</strong></span>. Progression refers to how the difficulty increases as you progress through the game. It should start out increasing slowly and then the rate of increase goes up faster as you move further and further into the game. So obviously, the difficulty should not suddenly shoot up by 100 percent from one level to the next as that will cause frustration in the players.</p><p>This brings us to the idea of challenges. Some games provide challenge levels for the hardcore players to enjoy. This is a good idea, but they shouldn't be so ridiculously hard that it takes forever to beat them. This is just my opinion, but a well-designed challenge should be one where the players can see themselves getting better as they keep making more <a id="id437" class="indexterm"/>attempts at it. If it's one of those levels where you <a id="id438" class="indexterm"/>just try 15 million times until you finally pull it off, sure it's hard, but its not a well-designed challenge because most players will probably give up long before they succeed. Why? It's because they will likely see it as a waste of time.</p><p>So what if you make a cool reward for beating it? Well, some players will try hard to get it then, but on the other hand, some players might not be able to get it even after countless tries, and they will be irritated that they can't get the unlockables. So, a challenge should be hard but reasonable. And as I said, the players should see their performance improving as they keep making more attempts. Seeing that improvement in their performance gives the players a sense of hope. As they do better and better with each attempt, they feel like their goal is getting ever closer. The players feel like they can do it if they just keep trying a little more. On the other hand, a level where you just have to retry 15 million times until you get lucky and pull it off has the opposite effect. If the players does not see any noticeable improvement in their attempts at the level, they will feel that they are not getting any better, and therefore, it is a waste of time to keep trying. The players will lose hope. It is OK to have some really tough challenges, but they should be optional and generally should not have unlockables for beating them. Again, this is just my opinion.</p></div><div class="section" title="Manipulating the player's emotions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Manipulating the player's emotions</h2></div></div></div><p>This brings us to another point that is sometimes a bit overlooked. If you think about it, one of the things that video games do at their core is manipulating the emotions of the player. If the <a id="id439" class="indexterm"/>players become mad, they may quit and <a id="id440" class="indexterm"/>maybe never play the game again. But beyond that kind of thing, manipulating the player's emotions goes much deeper. For example, games make players emotionally connected to certain characters, and make them hate others. Manipulating the player's emotions can be embedded in the basic gameplay mechanics as well. If the player earns rewards regularly, it makes them feel good and also gives them more reason to keep going. On the other hand, a deep and powerful story can do the same thing.</p><p>So, as you can see, there are many tools and problems to overcome in the world of game design. But if you love video games and have a desire to create them, all the work is worth it in the end when you see your finished game in action, and hopefully get lots of good feedback from your fans.</p><p>Lastly, one of the best tips for new game programmers is to start small. Don't get too ambitious because if you bite off more than you can chew, you will likely end up with a project that never gets finished. And those are definitely not the kind of projects we want to make!</p><p>If you do<a id="id441" class="indexterm"/> become an indie developer, congratulations are in order! In this case, you should try to communicate well with your fans. They <a id="id442" class="indexterm"/>will appreciate it a lot, and they are also a source of great ideas that you could potentially integrate into your games.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>As mentioned earlier, don't forget to include error handling in your code. This is extremely important in case the user doesn't have a compatible sound card or video card installed for example. So, when you create your DirectSound / XAudio2 or Direct3D / DirectInput device, make sure that it is not null right after creating it as this obviously won't work very well. Your program will probably crash.</p></div></div></div></div>
<div class="section" title="Further reading"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Further reading</h1></div></div></div><p>In this section, we will look at some excellent books and websites if you are seriously interested in game programming.</p><div class="section" title="Websites"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Websites</h2></div></div></div><p>The SlimDX website— <a class="ulink" href="http://slimdx.org/">http://slimdx.org/</a>—has a documentation section where you can see all of the <a id="id443" class="indexterm"/>SlimDX classes and their members. Unfortunately, it is incomplete at the time of this writing.</p><p>As an alternative to the SlimDX website, you can go to the SharpDX website, <a class="ulink" href="http://sharpdx.org/">http://sharpdx.org/</a>. This <a id="id444" class="indexterm"/>site also has a documentation section, and it is currently more complete than SlimDX's documentation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Most of the classes in SharpDX are the same as their SlimDX counterparts, but there are some differences between these two. SharpDX is just an alternative to SlimDX. So most of the time, you can look at their documentation for help with SlimDX, but sometimes, it might not be accurate with the documentation of SlimDX because of the differences between the two. It's a good resource nonetheless.</p></div></div><p>The GameDev.net website—<a class="ulink" href="http://www.Gamedev.net">http://www.Gamedev.net</a>—is a great resource for game developers. If you get really stuck and need help with something in SlimDX, their forums are an excellent<a id="id445" class="indexterm"/> place to ask questions. They have a lot of articles on the site too.</p><p>This site encompasses much more than just game development with SlimDX and C#. They also have an archive of the older articles since restructuring the site, which can be found at <a class="ulink" href="http://archive.gamedev.net/archive/reference/">http://archive.gamedev.net/archive/reference/</a>
</p><p>The Stack Overflow<a id="id446" class="indexterm"/> website—<a class="ulink" href="http:// http://stackoverflow.com/"> http://stackoverflow.com/</a>—is a place to ask questions, and people can comment on them and help you solve an issue. In fact, I used this site to help me solve a particularly tricky problem that I ran into while creating <a class="link" href="ch05.html" title="Chapter 5. Rendering Simple 3D Graphics">Chapter 5</a>, <span class="emphasis"><em>Rendering Simple 3D Graphics</em></span>, of this book!</p><p>The two websites, <a class="ulink" href="http://braynzarsoft.net/index.php?p=DX11Lessons ">http://braynzarsoft.net/index.php?p=DX11Lessons </a>and <a class="ulink" href="http://www.rastertek.com/tutdx11.html">http://www.rastertek.com/tutdx11.html</a>, have a number of good Direct3D 11 tutorials on them. Just be aware that these tutorials use C++; so, you'll have to figure out how to write the same code in SlimDX. Most objects in SlimDX have the same names as their native C++ counterparts; so, in most cases, this process is fairly easy to carry out.</p><p>The Riemers XNA Tutorials<a id="id447" class="indexterm"/> website— <a class="ulink" href="http://www.riemers.net/">http://www.riemers.net/</a>—has some very nice XNA tutorials for new game programmers, making it a great resource for those just getting into game programming to learn more.</p><p>The ShaderX Books<a id="id448" class="indexterm"/> website— <a class="ulink" href="http://tog.acm.org/resources/shaderx/">http://tog.acm.org/resources/shaderx/</a>—has a series of books called <span class="emphasis"><em>ShaderX</em></span>, and several of them are available as free downloads!</p><p>The NVIDIA Developer Zone<a id="id449" class="indexterm"/> website's page— <a class="ulink" href="http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html">http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html</a>—for the book, <span class="emphasis"><em>GPU Gems</em></span>, has excerpts from the book to give you an idea of what's in it.</p></div><div class="section" title="Books"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Books</h2></div></div></div><p>If you wish to <a id="id450" class="indexterm"/>learn more about the underlying concepts such as how graphics are actually rendered at the lowest levels in game development, check out these two books by André LaMothe:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Tricks of the Windows Game Programming Gurus, André LaMothe, Sams Publishing</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Tricks of the 3D Game Programming Gurus: Advanced Graphics and Rasterization, André LaMothe, Sams Publishing</em></span></li></ul></div><p>Both of these books by André LaMothe are quite excellent. The first one focuses on 2D development, player input with DirectInput, basic AI, collision detection, and more. The second book <a id="id451" class="indexterm"/>provides a very nice primer on the mathematics of 3D video games and focuses on the realm of 3D graphics and much more.</p><p>Next, I'd like to mention a book that I came in contact with in the beginning of this year (2013), and it turned out to be an excellent one: <span class="emphasis"><em>Game Coding Complete: Fourth Edition, Mike McShaffry and David "Rez" Graham, Cengage Learning</em></span>
</p><p>This book is excellent because it covers many things that are left out in lots of books on DirectX. For example, many books teach you how to draw graphics on the screen, but they don't really teach you how to go about building a real game. This book covers many aspects of creating the various systems that are found in every video game. As such, this book is truly invaluable to any serious game programmer wanting to learn all this.</p><p>The book <span class="emphasis"><em>3D Math Primer for Graphics and Game Development</em></span>,<span class="emphasis"><em> Fletcher Dunn</em></span>,<span class="emphasis"><em> Ian Parberry</em></span>,<span class="emphasis"><em> A K Peters/CRC Press</em></span> covers the mathematics of 3D games in great detail, and explains the theory behind the concepts as well.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we covered a handful of miscellaneous topics that we skimmed over in this book. Most of them could fill a book on their own. We looked at clipping and why it's important, and then moved on to collision detection and physics. Then, we took a look at multithreaded programming and its advantages for video games. After that, we took a look at some of the problems and pitfalls of game design. And lastly, we looked at some further reading materials.</p><p>Congratulations on completing the book! May you create many awesome games in the future, and thank you for taking the time to read this book. Good luck with your continuing adventures down the path of game design!</p></div></body></html>