<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Generating Code for Target Architecture"><div class="book" id="1JFUC2-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Generating Code for Target Architecture</h1></div></div></div><p class="calibre7">The code generated by the compiler finally has to execute on the target machines. The abstract form of the LLVM IR helps to generate code for various architectures. The target machine can be anything – CPU, GPU, DSP's, and so on. The target machine has some defining aspects such as the register sets, the instruction set, the calling convention of the function, and the instruction pipeline. These aspects or properties are generated using the <span class="strong"><strong class="calibre2">tablegen</strong></span> tool so that they can be used easily while programming code generation for the machine.</p><p class="calibre7">LLVM has a pipeline structure for the backend, where instructions travel through phases—from the LLVM IR to<a id="id244" class="calibre1"/> <span class="strong"><strong class="calibre2">SelectionDAG</strong></span>, then to<a id="id245" class="calibre1"/> <span class="strong"><strong class="calibre2">MachineDAG</strong></span>, then to <a id="id246" class="calibre1"/>
<span class="strong"><strong class="calibre2">MachineInstr</strong></span>, and finally to <a id="id247" class="calibre1"/>
<span class="strong"><strong class="calibre2">MCInst</strong></span>. The IR is converted to SelectionDAG. SelectionDAG then goes through legalization and optimizations. After this stage, the DAG nodes are mapped to target instructions (instruction selection). The DAG then goes through instruction scheduling, emitting linear sequences of instructions. The virtual registers are then allotted the target machine registers, which involves optimal register allocation minimizing memory spills.</p><p class="calibre7">This chapter describes how to represent target architecture. It also describes how to emit assembly code.</p><p class="calibre7">The topics discussed in this chapter are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Defining registers and register sets</li><li class="listitem">Defining the calling convention</li><li class="listitem">Defining the instruction set</li><li class="listitem">Implementing frame lowering</li><li class="listitem">Selecting an instruction</li><li class="listitem">Printing an instruction</li><li class="listitem">Registering a target</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Generating Code for Target Architecture">
<div class="book" title="Sample backend"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec48" class="calibre1"/>Sample backend</h1></div></div></div><p class="calibre7">To understand target <a id="id248" class="calibre1"/>code generation, we define a simple RISC-type architecture TOY machine with minimal registers, say <code class="email">r0-r3</code>, a stack pointer <code class="email">SP</code>, a link register, <code class="email">LR</code> (for storing the return address); and a <code class="email">CPSR</code> – current state program register. The calling convention of this toy backend is similar to the ARM thumb-like architecture—arguments passed to the function will be stored in register sets <code class="email">r0-r1</code>, and the return value will be stored in <code class="email">r0</code>.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Generating Code for Target Architecture">
<div class="book" title="Sample backend">
<div class="book" title="Defining registers and register sets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec11" class="calibre1"/>Defining registers and register sets</h2></div></div></div><p class="calibre7">Register sets are<a id="id249" class="calibre1"/> defined using the <a id="id250" class="calibre1"/>tablegen tool. Tablegen <a id="id251" class="calibre1"/>helps to maintain large <a id="id252" class="calibre1"/>number of records of domain specific information. It<a id="id253" class="calibre1"/> factors out the common features of these records. This helps in reducing duplication in the description and forms a structural<a id="id254" class="calibre1"/> way of representing domain information. Please visit <a class="calibre1" href="http://llvm.org/docs/TableGen/">http://llvm.org/docs/TableGen/</a> to understand tablegen in detail. <code class="email">TableGen</code> files are interpreted by the <code class="email">TableGen binary: llvm-tblgen</code>.</p><p class="calibre7">We have described our sample backend in the preceding paragraph, which has four registers (<code class="email">r0-r3</code>), a stack register (<code class="email">SP</code>), and a link register (<code class="email">LR</code>). These can be specified in the <code class="email">TOYRegisterInfo.td</code> file. The <code class="email">tablegen</code> function provides the <code class="email">Register</code> class, which can be extended to specify the registers. Create a new file named <code class="email">TOYRegisterInfo.td</code>.</p><p class="calibre7">The registers can be defined by extending the <code class="email">Register</code> class.</p><div class="informalexample"><pre class="programlisting">class TOYReg&lt;bits&lt;16&gt; Enc, string n&gt; : Register&lt;n&gt; {
let HWEncoding = Enc;
let Namespace = "TOY";
}</pre></div><p class="calibre7">The registers <code class="email">r0-r3</code> belong to a general purpose <code class="email">Register</code> class. This can be specified by extending <code class="email">RegisterClass</code>.</p><div class="informalexample"><pre class="programlisting">foreach i = 0-3 in {
def R#i : R&lt;i, "r"#i &gt;;
}

def GRRegs : RegisterClass&lt;"TOY", [i32], 32,
(add R0, R1, R2, R3, SP)&gt;;</pre></div><p class="calibre7">The remainings, register <code class="email">SP</code>, <code class="email">LR</code>, and <code class="email">CPSR</code>, can be defined as follows:</p><div class="informalexample"><pre class="programlisting">def SP : TOYReg&lt;13, "sp"&gt;;
def LR : TOYReg&lt;14, "lr"&gt;;
def CPSR  : TOYReg&lt;16, "cpsr"&gt;;</pre></div><p class="calibre7">When the whole thing is put together, the <code class="email">TOYRegisterInfo.td</code> looks like the following:</p><div class="informalexample"><pre class="programlisting">class TOYReg&lt;bits&lt;16&gt; Enc, string n&gt; : Register&lt;n&gt; {
let HWEncoding = Enc;
let Namespace = "TOY";
}

foreach i = 0-3 in {
def R#i : R&lt;i, "r"#i &gt;;
}

def SP : TOYReg&lt;13, "sp"&gt;;
def LR : TOYReg&lt;14, "lr"&gt;;
def GRRegs : RegisterClass&lt;"TOY", [i32], 32,
(add R0, R1, R2, R3, SP)&gt;;</pre></div><p class="calibre7">We can put this<a id="id255" class="calibre1"/> file in a new folder named <code class="email">TOY</code> in the parent <a id="id256" class="calibre1"/>folder named <code class="email">Target</code> in the llvm's root <a id="id257" class="calibre1"/>directory, which is <code class="email">llvm_root_directory/lib/Target/TOY/ TOYRegisterInfo.td</code>
</p><p class="calibre7">The tablegen <a id="id258" class="calibre1"/>tool <code class="email">llvm-tablegen</code>, processes this <code class="email">.td</code> file to generate the <code class="email">.inc</code> file, which generally has enums generated for these registers. These enums can be used in the <code class="email">.cpp</code> files, in which the registers can be referenced as <code class="email">TOY::R0</code>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Generating Code for Target Architecture">
<div class="book" title="Sample backend">
<div class="book" title="Defining the calling convention"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec12" class="calibre1"/>Defining the calling convention</h2></div></div></div><p class="calibre7">The calling <a id="id259" class="calibre1"/>convention specifies how values are passed to and returned from a function call. Our <code class="email">TOY</code> architecture specifies that two arguments are passed in two registers, <code class="email">r0</code> and <code class="email">r1</code>, while the remaining ones are passed to the stack. Calling convention defined is then used in the Instruction Selection phase by referring to the function pointer.</p><p class="calibre7">While defining a calling convention, we have to represent two sections—one to define the convention return value, and other to define the convention for argument passing. The parent class <code class="email">CallingConv</code> is inherited to define the calling convention.</p><p class="calibre7">In our <code class="email">TOY</code> architecture, the return value is stored in <code class="email">r0</code> register. If there are more arguments, integer values get stored in stack slots that are 4 bytes in size and 4-byte aligned. This can be declared in <code class="email">TOYCallingConv.td</code> as follows:</p><div class="informalexample"><pre class="programlisting">def RetCC_TOY : CallingConv&lt;[
CCIfType&lt;[i32], CCAssignToReg&lt;[R0]&gt;&gt;,
CCIfType&lt;[i32], CCAssignToStack&lt;4, 4&gt;&gt;
]&gt;;</pre></div><p class="calibre7">The argument passing convention can be defined as follows:</p><div class="informalexample"><pre class="programlisting">def CC_TOY : CallingConv&lt;[
CCIfType&lt;[i8, i16], CCPromoteToType&lt;i32&gt;&gt;,
CCIfType&lt;[i32], CCAssignToReg&lt;[R0, R1]&gt;&gt;,
CCIfType&lt;[i32], CCAssignToStack&lt;4, 4&gt;&gt;
]&gt;;</pre></div><p class="calibre7">The preceding<a id="id260" class="calibre1"/> declaration says three things, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the datatype of the arguments is <code class="email">i8</code> or <code class="email">i16</code>, it will get promoted to <code class="email">i32</code></li><li class="listitem">The first two arguments will be stored in register <code class="email">r0</code> and <code class="email">r1</code></li><li class="listitem">If there are more arguments, they will be stored in <code class="email">Stack</code></li></ul></div><p class="calibre7">We also define the callee-saved register since callee-saved registers are used to hold long-lived values that should be preserved across calls.</p><div class="informalexample"><pre class="programlisting">def CC_Save : CalleeSavedRegs&lt;(add R2, R3)&gt;;</pre></div><p class="calibre7">The <code class="email">llvm-tablegen</code> tool generates a <code class="email">TOYCallingConv.inc</code> file after building the project, which will be included in the Instruction Selection phase in the <code class="email">TOYISelLowering.cpp</code> file.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Generating Code for Target Architecture">
<div class="book" title="Sample backend">
<div class="book" title="Defining the instruction set"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec13" class="calibre1"/>Defining the instruction set</h2></div></div></div><p class="calibre7">Architectures have rich <a id="id261" class="calibre1"/>instruction sets to represent various operations supported by the target machine. Typically, three things need to be defined in the target description file when representing the instructions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">operands</li><li class="listitem">the assembly string</li><li class="listitem">the instruction pattern</li></ul></div><p class="calibre7">The specification contains a list of definitions or outputs, and a list of uses or inputs. There can be different operand classes, such as the <code class="email">Register</code> class, and the immediate and more complex <code class="email">register+imm</code> operands.</p><p class="calibre7">For example, we define register to register addition for our Toy machine as follows in <code class="email">TOYInstrInfo.td</code>:</p><div class="informalexample"><pre class="programlisting">def ADDrr : InstTOY&lt;(outs GRRegs:$dst),
(ins GRRegs:$src1, GRRegs:$src2),
"add $dst, $src1,z$src2",
[(set i32:$dst, (add i32:$src1, i32:$src2))]&gt;;</pre></div><p class="calibre7">In the above declaration, the '<code class="email">ins</code>' has two registers <code class="email">$src1</code> and <code class="email">$src2</code> belonging to the general purpose register class, which holds the two operands. The result of the operation will be put into '<code class="email">outs</code>', which is a <code class="email">$dst</code> register belonging to the general purpose <code class="email">Register</code> class. The assembly string is "<code class="email">add $dst, $src1,z$src2</code>". The values of <code class="email">$src1</code>, <code class="email">$src2</code> and <code class="email">$dst</code> will be determined at the time of register allocation. So, an assembly will be generated for <code class="email">add</code> between two registers, like this:</p><div class="informalexample"><pre class="programlisting">add r0, r0, r1</pre></div><p class="calibre7">We saw above how a<a id="id262" class="calibre1"/> simple instruction can be represented using tablegen. Similar to the <code class="email">add register to register</code> instruction, a <code class="email">subtract register from a register</code> instruction can be defined. We leave it to the readers to try it out. A more detailed representation of complex instructions can be examined from the ARM or X86 architecture specifications in the project code.</p></div></div></div>
<div class="book" title="Implementing frame lowering" id="1KEEU1-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec49" class="calibre1"/>Implementing frame lowering</h1></div></div></div><p class="calibre7">Frame lowering involves <a id="id263" class="calibre1"/>emitting function prologue and epilogue. The prologue happens at the beginning of a function. It sets up the stack frame of the called function. The epilogue happens last in a function, it restores the stack frame of the calling (parent) function.</p><p class="calibre7"> The "<code class="email">stack</code>" serves several purposes in the execution of a program, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Keeping track of return address, when calling a function</li><li class="listitem">Storage of local variables in the context of a function call</li><li class="listitem">Passing arguments from the caller to the callee.</li></ul></div><p class="calibre7">Thus there are 2 main functions that need to be defined when implementing frame lowering – <code class="email">emitPrologue()</code> and <code class="email">emitEpilogue()</code>.</p><p class="calibre7">The <code class="email">emitPrologue()</code> function can be defined as follows:</p><div class="informalexample"><pre class="programlisting">void TOYFrameLowering::emitPrologue(MachineFunction &amp;MF) const {
  const TargetInstrInfo &amp;TII = *MF.getSubtarget().getInstrInfo();
  MachineBasicBlock &amp;MBB = MF.front();
  MachineBasicBlock::iterator MBBI = MBB.begin();

  uint64_t StackSize = computeStackSize(MF);
  if (!StackSize) {
    return;
  }
  unsigned StackReg = TOY::SP;
  unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);
  if (OffsetReg) {
    BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBrr), StackReg)
        .addReg(StackReg)
        .addReg(OffsetReg)
        .setMIFlag(MachineInstr::FrameSetup);
  } else {
    BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBri), StackReg)
        .addReg(StackReg)
        .addImm(StackSize)
        .setMIFlag(MachineInstr::FrameSetup);
  }
}</pre></div><p class="calibre7">The above <a id="id264" class="calibre1"/>function moves over<a id="id265" class="calibre1"/> <span class="strong"><strong class="calibre2">Machine Basic Block</strong></span>. It calculates stack size for the function, calculates offset for the stack size, and emits instructions to set up the frame with a stack register.</p><p class="calibre7">Similarly, the <code class="email">emitEpilogue()</code> function can be defined as follows:</p><div class="informalexample"><pre class="programlisting">void TOYFrameLowering::emitEpilogue(MachineFunction &amp;MF,
                                    MachineBasicBlock &amp;MBB) const {
  const TargetInstrInfo &amp;TII = *MF.getSubtarget().getInstrInfo();
  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
  DebugLoc dl = MBBI-&gt;getDebugLoc();
  uint64_t StackSize = computeStackSize(MF);
  if (!StackSize) {
    return;
  }
  unsigned StackReg = TOY::SP;
  unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);
  if (OffsetReg) {
    BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDrr), StackReg)
        .addReg(StackReg)
        .addReg(OffsetReg)
        .setMIFlag(MachineInstr::FrameSetup);
  } else {
    BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDri), StackReg)
        .addReg(StackReg)
        .addImm(StackSize)
        .setMIFlag(MachineInstr::FrameSetup);
  }
}</pre></div><p class="calibre7">The preceding function also calculates stack size, over goes the machine basic block, and sets up the function frame when returning from the function. Please note that the stack here is descending.</p><p class="calibre7">The <code class="email">emitPrologue()</code> function first computes the stack size to determine whether the prologue is required at all. Then it adjusts the stack pointer by calculating the offset. For the <code class="email">emitEpilogue()</code>, it first checks whether the epilogue is required or not. Then it restores the stack pointer to what it was at the beginning of the function.</p><p class="calibre7">For example, consider this input IR:</p><div class="informalexample"><pre class="programlisting">%p = alloca i32, align 4
store i32 2, i32* %p
%b = load i32* %p, align 4
%c = add nsw i32 %a, %b</pre></div><p class="calibre7">The <a id="id266" class="calibre1"/>TOY assembly generated will look like this:</p><div class="informalexample"><pre class="programlisting">sub sp, sp, #4 ; prologue
movw r1, #2
str r1, [sp]
add r0, r0, #2
add sp, sp, #4 ; epilogue</pre></div></div>
<div class="book" title="Lowering instructions"><div class="book" id="1LCVG2-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec50" class="calibre1"/>Lowering instructions</h1></div></div></div><p class="calibre7">In this chapter, we will see the implementation of 3 things – Function call calling convention, Formal argument calling convention, and Return value calling convention. We create a file <code class="email">TOYISelLowering.cpp</code>, and implement Instructions Lowering<a id="id267" class="calibre1"/> in it.</p><p class="calibre7">First, let's look at how a call calling convention can be implemented.</p><div class="informalexample"><pre class="programlisting">SDValue TOYTar-getLoweing::LowerCall(TargetLowering::CallLoweringInfo &amp;CLI, SmallVectorImpl&lt;SDValue&gt; &amp;InVals)
 const {
  SelectionDAG &amp;DAG = CLI.DAG;
  SDLoc &amp;Loc = CLI.DL;
  SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs = CLI.Outs;
  SmallVectorImpl&lt;SDValue&gt; &amp;OutVals = CLI.OutVals;
  SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins = CLI.Ins;
  SDValue Chain = CLI.Chain;
  SDValue Callee = CLI.Callee;
  CallingConv::ID CallConv = CLI.CallConv;
  const bool isVarArg = CLI.IsVarArg;

  CLI.IsTailCall = false;

  if (isVarArg) {
    llvm_unreachable("Unimplemented");
  }

  // Analyze operands of the call, assigning locations to each
  // operand.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), ArgLocs, *DAG.getContext());
  CCInfo.AnalyzeCallOperands(Outs, CC_TOY);

  // Get the size of the outgoing arguments stack space
  // requirement.
  const unsigned NumBytes = CCInfo.getNextStackOffset();

  Chain = DAG.getCALLSEQ_START(Chain,
                               DAG.getIntPtrConstant(NumBytes, Loc, true), Loc);

  SmallVector&lt;std::pair&lt;unsigned, SDValue&gt;, 8&gt; RegsToPass;
  SmallVector&lt;SDValue, 8&gt; MemOpChains;

  // Walk the register/memloc assignments, inserting copies/loads.
  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
    CCValAssign &amp;VA = ArgLocs[i];
    SDValue Arg = OutVals[i];

    // We only handle fully promoted arguments.
    assert(VA.getLocInfo() == CCValAssign::Full &amp;&amp; "Unhandled loc 
    info");

    if (VA.isRegLoc()) {
      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
      continue;
    }

    assert(VA.isMemLoc() &amp;&amp;
           "Only support passing arguments through registers or 
           via the stack");

    SDValue StackPtr = DAG.getRegister(TOY::SP, MVT::i32);
    SDValue PtrOff = DAG.getIntPtrConstant(VA.getLocMemOffset(), 
    Loc);
    PtrOff = DAG.getNode(ISD::ADD, Loc, MVT::i32, StackPtr, 
    PtrOff);
    MemOpChains.push_back(DAG.getStore(Chain, Loc, Arg, PtrOff,
                                       MachinePointerInfo(), false, false, 0));
  }

  // Emit all stores, make sure they occur before the call.
  if (!MemOpChains.empty()) {
    Chain = DAG.getNode(ISD::TokenFactor, Loc, MVT::Other, MemOpChains);
  }

  // Build a sequence of copy-to-reg nodes chained together with
  // token chain
  // and flag operands which copy the outgoing args into the
  // appropriate regs.
  SDValue InFlag;
  for (auto &amp;Reg : RegsToPass) {
    Chain = DAG.getCopyToReg(Chain, Loc, Reg.first, Reg.second, InFlag);
    InFlag = Chain.getValue(1);
  }

  // We only support calling global addresses.
  GlobalAddressSDNode *G = dyn_cast&lt;GlobalAddressSDNode&gt;(Callee);
  assert(G &amp;&amp; "We only support the calling of global address-es");

  EVT PtrVT = getPointerTy(DAG.getDataLayout());
  Callee = DAG.getGlobalAddress(G-&gt;getGlobal(), Loc, PtrVT, 0);

  std::vector&lt;SDValue&gt; Ops;
  Ops.push_back(Chain);
  Ops.push_back(Callee);

  // Add argument registers to the end of the list so that they
  // are known live into the call.
  for (auto &amp;Reg : RegsToPass) {
    Ops.push_back(DAG.getRegister(Reg.first, Reg.second.getValueType()));
  }

  // Add a register mask operand representing the call-preserved
  // registers.
  const uint32_t *Mask;
  const TargetRegisterInfo *TRI = DAG.getSubtarget().getRegisterInfo();
  Mask = TRI-&gt;getCallPreservedMask(DAG.getMachineFunction(), CallConv);

  assert(Mask &amp;&amp; "Missing call preserved mask for calling 
  convention");
  Ops.push_back(DAG.getRegisterMask(Mask));

  if (InFlag.getNode()) {
    Ops.push_back(InFlag);
  }

  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);

  // Returns a chain and a flag for retval copy to use.
  Chain = DAG.getNode(TOYISD::CALL, Loc, NodeTys, Ops);
  InFlag = Chain.getValue(1);

  Chain = DAG.getCALLSEQ_END(Chain, DAG.getIntPtrConstant(NumBytes, Loc, true),
                             DAG.getIntPtrConstant(0, Loc, true), InFlag, Loc);
  if (!Ins.empty()) {
    InFlag = Chain.getValue(1);
  }

  // Handle result values, copying them out of physregs into vregs 
  // that we return.
  return LowerCallResult(Chain, InFlag, CallConv, isVarArg, Ins, 
                         Loc, DAG, InVals);
}</pre></div><p class="calibre7">In the above<a id="id268" class="calibre1"/> function, we first analyzed the operands of the call, assigned a location to each operand, and calculated the size of the argument stack space. Then we scanned the <code class="email">register/memloc</code> assignment and inserted <code class="email">copies</code> and <code class="email">loads</code>. For our sample target, we support passing arguments through registers or via stack (remember the calling convention defined in the previous section). We then emit all the stores making sure they happen before call. We build a sequence of <code class="email">copy-to-reg</code> nodes that copy the outgoing arguments into the appropriate registers. Then, we add a register mask operand representing the call-preserved registers. We return a chain and a flag for return value copy to use and finally handle result values, copying them out of <code class="email">physregs</code> into <code class="email">vregs</code> that we return.</p><p class="calibre7">We will now look at the implementation of a formal argument calling convention.</p><div class="informalexample"><pre class="programlisting">SDValue TOYTargetLowering::LowerFormalArguments(
    SDValue Chain, CallingConv::ID CallConv, bool isVarArg,
    const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins, SDLoc dl, SelectionDAG &amp;DAG,
    SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  MachineRegisterInfo &amp;RegInfo = MF.getRegInfo();

  assert(!isVarArg &amp;&amp; "VarArg not supported");

  // Assign locations to all of the incoming arguments.
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;
  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), ArgLocs, *DAG.getContext());

  CCInfo.AnalyzeFormalArguments(Ins, CC_TOY);

  for (auto &amp;VA : ArgLocs) {
    if (VA.isRegLoc()) {
      // Arguments passed in registers
      EVT RegVT = VA.getLocVT();
      assert(RegVT.getSimpleVT().SimpleTy == MVT::i32 &amp;&amp;
             "Only support MVT::i32 register passing");
      const unsigned VReg =
          RegInfo.createVirtualRegister(&amp;TOY::GRRegsRegClass);
      RegInfo.addLiveIn(VA.getLocReg(), VReg);
      SDValue ArgIn = DAG.getCopyFromReg(Chain, dl, VReg, RegVT);

      InVals.push_back(ArgIn);
      continue;
    }

    assert(VA.isMemLoc() &amp;&amp;
           "Can only pass arguments as either registers or via the 
           stack");

    const unsigned Offset = VA.getLocMemOffset();

    const int FI = MF.getFrameInfo()-&gt;CreateFixedObject(4, Offset, 
    true);
    EVT PtrTy = getPointerTy(DAG.getDataLayout());
    SDValue FIPtr = DAG.getFrameIndex(FI, PtrTy);

    assert(VA.getValVT() == MVT::i32 &amp;&amp;
           "Only support passing arguments as i32");
    SDValue Load = DAG.getLoad(VA.getValVT(), dl, Chain, FIPtr,
                               MachinePointerInfo(), false, false, false, 0);

    InVals.push_back(Load);
  }
  return Chain;
}</pre></div><p class="calibre7">In the above implementation of a formal argument calling convention, we assigned a location to all the incoming arguments. We handle only the arguments passed via a register or a stack. We will now look at the implementation of a return value calling convention.</p><div class="informalexample"><pre class="programlisting">bool TOYTargetLowering::CanLowerReturn(
    CallingConv::ID CallConv, MachineFunction &amp;MF, bool isVarArg,
    const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs, LLVMContext &amp;Context) const {
  SmallVector&lt;CCValAssign, 16&gt; RVLocs;
  CCState CCInfo(CallConv, isVarArg, MF, RVLocs, Context);
  if (!CCInfo.CheckReturn(Outs, RetCC_TOY)) {
    return false;
  }
  if (CCInfo.getNextStackOffset() != 0 &amp;&amp; isVarArg) {
    return false;
  }
  return true;
}

SDValue
TOYTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv, bool isVarArg, const SmallVec torImpl&lt;ISD::OutputArg&gt; &amp; Outs, const SmallVectorImpl&lt;SDValue&gt; const SmallVec torImpl&lt;ISD::OutputArg&gt; &amp; Outs,
  if (isVarArg) {
    report_fatal_error("VarArg not supported");
  }

  // CCValAssign - represent the assignment of
  // the return value to a location
  SmallVector&lt;CCValAssign, 16&gt; RVLocs;

  // CCState - Info about the registers and stack slot.
  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), RVLocs,
                 *DAG.getContext());

  CCInfo.AnalyzeReturn(Outs, RetCC_TOY);

  SDValue Flag;
  SmallVector&lt;SDValue, 4&gt; RetOps(1, Chain);

  // Copy the result values into the output registers.
  for (unsigned i = 0, e = RVLocs.size(); i &lt; e; ++i) {
    CCValAssign &amp;VA = RVLocs[i];
    assert(VA.isRegLoc() &amp;&amp; "Can only return in registers!");

    Chain = DAG.getCopyToReg(Chain, dl, VA.getLocReg(), OutVals[i], Flag);

    Flag = Chain.getValue(1);
    RetOps.push_back(DAG.getRegister(VA.getLocReg(), VA.getLocVT()));
  }

  RetOps[0] = Chain; // Update chain.

  // Add the flag if we have it.
  if (Flag.getNode()) {
    RetOps.push_back(Flag);
  }

  return DAG.getNode(TOYISD::RET_FLAG, dl, MVT::Other, RetOps);
}</pre></div><p class="calibre7">We first see if <a id="id269" class="calibre1"/>we can lower a return. We then gather information about registers and stack slots. We copy the result values in the output registers and finally return a DAG node for a return value.</p></div>
<div class="book" title="Printing an instruction"><div class="book" id="1MBG22-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec51" class="calibre1"/>Printing an instruction</h1></div></div></div><p class="calibre7">Printing an assembly<a id="id270" class="calibre1"/> instruction is an important step in generating target code. Various classes are defined that work as a gateway to the streamers.</p><p class="calibre7">First, we initialize the class for instruction, assigning the operands, the assembly string, pattern, the output variable, and so on in the <code class="email">TOYInstrFormats.td</code> file:</p><div class="informalexample"><pre class="programlisting">class InstTOY&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern&gt;
    : Instruction {
  field bits&lt;32&gt; Inst;
  let Namespace = "TOY";
  dag OutOperandList = outs;
  dag InOperandList = ins;
  let AsmString = asmstr;
  let Pattern = pattern;
  let Size = 4;
}</pre></div><p class="calibre7">Then, we define functions to print operands in <code class="email">TOYInstPrinter.cpp</code>.</p><div class="informalexample"><pre class="programlisting">void TOYInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &amp;O) {
  const MCOperand &amp;Op = MI-&gt;getOperand(OpNo);
  if (Op.isReg()) {
    printRegName(O, Op.getReg());
    return;
  }
  if (Op.isImm()) {
    O &lt;&lt; "#" &lt;&lt; Op.getImm();
    return;
  }
  assert(Op.isExpr() &amp;&amp; "unknown operand kind in printOperand");
  printExpr(Op.getExpr(), O);
}</pre></div><p class="calibre7">This function <a id="id271" class="calibre1"/>simply prints operands, registers, or immediate values, as the case may be.</p><p class="calibre7">We also define a function to print the register names in the same file:</p><div class="informalexample"><pre class="programlisting">void TOYInstPrinter::printRegName(raw_ostream &amp;OS, unsigned RegNo) const {
  OS &lt;&lt; StringRef(getRegisterName(RegNo)).lower();
}</pre></div><p class="calibre7">Next, we define a function to print the instruction:</p><div class="informalexample"><pre class="programlisting">void TOYInstPrinter::printInst(const MCInst *MI, raw_ostream &amp;O,
                               StringRef Annot) {
  printInstruction(MI, O);
  printAnnotation(O, Annot);
}</pre></div><p class="calibre7">Next, we declare and define assembly info as follows:</p><p class="calibre7">We create a <code class="email">TOYMCAsmInfo.h</code> and declare an <code class="email">ASMInfo</code> class:</p><div class="informalexample"><pre class="programlisting">#ifndef TOYTARGETASMINFO_H
#define TOYTARGETASMINFO_H
#include "llvm/MC/MCAsmInfoELF.h"
namespace llvm {
class StringRef;
class Target;
class TOYMCAsmInfo : public MCAsmInfoELF {
  virtual void anchor();

public:
  explicit TOYMCAsmInfo(StringRef TT);
};
} // namespace llvm
#endif</pre></div><p class="calibre7">The constructor<a id="id272" class="calibre1"/> can be defined in <code class="email">TOYMCAsmInfo.cpp</code> as follows:</p><div class="informalexample"><pre class="programlisting">#include "TOYMCAsmInfo.h"
#include "llvm/ADT/StringRef.h"
using namespace llvm;
void TOYMCAsmInfo::anchor() {}
TOYMCAsmInfo::TOYMCAsmInfo(StringRef TT) {
  SupportsDebugInformation = true;
  Data16bitsDirective = "\t.short\t";
  Data32bitsDirective = "\t.long\t";
  Data64bitsDirective = 0;
  ZeroDirective = "\t.space\t";
  CommentString = "#";
  AscizDirective = ".asciiz";
  HiddenVisibilityAttr = MCSA_Invalid;
  HiddenDeclarationVisibilityAttr = MCSA_Invalid;
  ProtectedVisibilityAttr = MCSA_Invalid;
}</pre></div><p class="calibre7">For compilation, we define <code class="email">LLVMBuild.txt</code> as follows:</p><div class="informalexample"><pre class="programlisting">[component_0]
type = Library
name = TOYAsmPrinter
parent = TOY
required_libraries = MC Support
add_to_library_groups = TOY</pre></div><p class="calibre7">Furthermore, we define the <code class="email">CMakeLists.txt</code> file as follows:</p><div class="informalexample"><pre class="programlisting">add_llvm_library(LLVMTOYAsmPrinter
TOYInstPrinter.cpp
)</pre></div><p class="calibre7">When the final compilation takes place, the <code class="email">llc</code> tool—a static compiler—will generate the assembly of the <code class="email">TOY</code> architecture (after registering the TOY architecture with the <code class="email">llc</code> tool).</p><p class="calibre7">To register our <code class="email">TOY</code> target with static compiler <code class="email">llc</code>, follow the steps mentioned below:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, add the entry of the <code class="email">TOY</code> backend to <code class="email">llvm_root_dir/CMakeLists.txt</code>:<div class="informalexample"><pre class="programlisting">set(LLVM_ALL_TARGETS
AArch64
ARM
…
…
TOY
)</pre></div></li><li class="listitem" value="2">Then, add <a id="id273" class="calibre1"/>the <code class="email">toy</code> entry to <code class="email">llvm_root_dir/include/llvm/ADT/Triple.h</code>:<div class="informalexample"><pre class="programlisting">class Triple {
public:
enum ArchType {
UnknownArch,
arm, // ARM (little endian): arm, armv.*, xscale
armeb, // ARM (big endian): armeb
aarch64, // AArch64 (little endian): aarch64
…
…
toy // TOY: toy
};</pre></div></li><li class="listitem" value="3">Add the <code class="email">toy</code> entry to <code class="email">llvm_root_dir/include/llvm/ MC/MCExpr.h</code>:<div class="informalexample"><pre class="programlisting">class MCSymbolRefExpr : public MCExpr {
public:
enum VariantKind {
...
VK_TOY_LO,
VK_TOY_HI,
};</pre></div></li><li class="listitem" value="4">Add the <code class="email">toy</code> entry to <code class="email">llvm_root_dir/include/llvm/ Support/ELF.h</code>:<div class="informalexample"><pre class="programlisting">enum {
EM_NONE = 0, // No machine
EM_M32 = 1, // AT&amp;T WE 32100
…
…
EM_TOY = 220 // whatever is the next number
};</pre></div></li><li class="listitem" value="5">Then, add the <code class="email">toy</code> entry to <code class="email">lib/MC/MCExpr.cpp</code>:<div class="informalexample"><pre class="programlisting">StringRef MCSymbolRefExpr::getVariantKindName(VariantKind
Kind) {
switch (Kind) {
…
…
case VK_TOY_LO: return "TOY_LO";
case VK_TOY_HI: return "TOY_HI";
}
…
}</pre></div></li><li class="listitem" value="6">Next, add<a id="id274" class="calibre1"/> the <code class="email">toy</code> entry to <code class="email">lib/Support/Triple.cpp</code>:<div class="informalexample"><pre class="programlisting">const char *Triple::getArchTypeName(ArchType Kind) {
switch (Kind) {
…
…
case toy: return "toy";
}
const char *Triple::getArchTypePrefix(ArchType Kind) {
switch (Kind) {
…
…
case toy: return "toy";
}
}
Triple::ArchType Triple::getArchTypeForLLVMName(StringRef
Name) {
…
…
.Case("toy", toy)
…
}
static Triple::ArchType parseArch(StringRef ArchName) {
…
…
.Case("toy", Triple::toy)
…
}
static unsigned
getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
…
…
case llvm::Triple::toy:
return 32;
…
…
}
Triple Triple::get32BitArchVariant() const {
…
…
case Triple::toy:
// Already 32-bit.
break;
…
}
Triple Triple::get64BitArchVariant() const {
…
…
case Triple::toy:
T.setArch(UnknownArch);
break;
…
…
}</pre></div></li><li class="listitem" value="7">Add the<a id="id275" class="calibre1"/> <code class="email">toy</code> directory entry to <code class="email">lib/Target/LLVMBuild.txt</code>:<div class="informalexample"><pre class="programlisting">[common]
subdirectories = ARM AArch64 CppBackend Hexagon MSP430 … …
TOY</pre></div></li><li class="listitem" value="8">Create a new file called <code class="email">TOY.h</code> in the <code class="email">lib/Target/TOY</code> folder:<div class="informalexample"><pre class="programlisting">#ifndef TARGET_TOY_H
#define TARGET_TOY_H
#include "MCTargetDesc/TOYMCTargetDesc.h"
#include "llvm/Target/TargetMachine.h"
namespace llvm {
class TargetMachine;
class TOYTargetMachine;
FunctionPass *createTOYISelDag(TOYTargetMachine &amp;TM,
                               CodeGenOpt::Level OptLevel);
} // end namespace llvm;
#endif</pre></div></li><li class="listitem" value="9">Create a new folder called <code class="email">TargetInfo</code> in the <code class="email">lib/Target/TOY</code> folder. Inside that folder, create a new file called <code class="email">TOYTargetInfo.cpp</code>, as follows:<div class="informalexample"><pre class="programlisting">#include "TOY.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/TargetRegistry.h"
using namespace llvm;
Target llvm::TheTOYTarget;
extern "C" void LLVMInitializeTOYTargetInfo() {
  RegisterTarget&lt;Triple::toy&gt; X(TheTOYTarget, "toy", "TOY");
}</pre></div></li><li class="listitem" value="10">In the <a id="id276" class="calibre1"/>same folder, create the <code class="email">CMakeLists.txt</code> file:<div class="informalexample"><pre class="programlisting">add_llvm_library(LLVMTOYInfo TOYTargetInfo.cpp)</pre></div></li><li class="listitem" value="11">Create an <code class="email">LLVMBuild.txt</code> file:<div class="informalexample"><pre class="programlisting">[component_0]
type = Library
name = TOYInfo
parent = TOY
required_libraries = Support
add_to_library_groups = TOY</pre></div></li><li class="listitem" value="12">In the <code class="email">lib/Target/TOY</code> folder, create a file called <code class="email">TOYTargetMachine.cpp</code>:<div class="informalexample"><pre class="programlisting">#include "TOYTargetMachine.h"
#include "TOY.h"
#include "TOYFrameLowering.h"
#include "TOYInstrInfo.h"
#include "TOYISelLowering.h "
#include "TOYSelectionDAGInfo.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/IR/Module.h"
#include "llvm/PassManager.h"
#include "llvm/Support/TargetRegistry.h"
using namespace llvm;

TOYTargetMachine::TOYTargetMachine(const Target &amp;T, StringRef TT, StringRef CPU, StringRef FS, const 
TargetOptions &amp;Options, Reloc::Model RM, CodeModel::Model CM, CodeGenOpt::Level OL)
    : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),
      Subtarget(TT, CPU, FS, *this) {
  initAsmInfo();
}

namespace {
class TOYPassConfig : public TargetPassConfig {
public:
  TOYPassConfig(TOYTargetMachine *TM, PassManagerBase &amp;PM)
      : TargetPassConfig(TM, PM) {}
  TOYTargetMachine &amp;getTOYTargetMachine() const {
    return getTM&lt;TOYTargetMachine&gt;();
  }
  virtual bool addPreISel();
  virtual bool addInstSelector();
  virtual bool addPreEmitPass();
};
} // namespace

TargetPassConfig *TOYTargetMachine::createPassConfig
(PassManagerBase &amp;PM) {
  return new TOYPassConfig(this, PM);
}

bool TOYPassConfig::addPreISel() { return false; }

bool TOYPassConfig::addInstSelector() {
  addPass(createTOYISelDag(getTOYTargetMachine(), 
getOptLevel()));
  return false;
}

bool TOYPassConfig::addPreEmitPass() { return false; }

// Force static initialization.
extern "C" void LLVMInitializeTOYTarget() {
  RegisterTargetMachine&lt;TOYTargetMachine&gt; X(TheTOYTarget);
}
void TOYTargetMachine::addAnalysisPasses(PassManagerBase &amp;PM) {}</pre></div></li><li class="listitem" value="13">Create a <a id="id277" class="calibre1"/>new folder called <code class="email">MCTargetDesc</code> and a new file called <code class="email">TOYMCTargetDesc.h</code>:<div class="informalexample"><pre class="programlisting">#ifndef TOYMCTARGETDESC_H
#define TOYMCTARGETDESC_H
#include "llvm/Support/DataTypes.h"
namespace llvm {
class Target;
class MCInstrInfo;
class MCRegisterInfo;
class MCSubtargetInfo;
class MCContext;
class MCCodeEmitter;
class MCAsmInfo;
class MCCodeGenInfo;
class MCInstPrinter;
class MCObjectWriter;
class MCAsmBackend;
class StringRef;
class raw_ostream;
extern Target TheTOYTarget;

MCCodeEmitter *createTOYMCCodeEmitter(const MCInstrInfo &amp;MCII, const MCRegisterInfo &amp;MRI, const MCSubtargetInfo &amp;STI, MCContext &amp;Ctx);

MCAsmBackend *createTOYAsmBackend(const Target &amp;T, const MCRegisterInfo &amp;MRI, StringRef TT, StringRef CPU);

MCObjectWriter *createTOYELFObjectWriter(raw_ostream &amp;OS, uint8_t OSABI);
} // End llvm namespace
#define GET_REGINFO_ENUM
#include "TOYGenRegisterInfo.inc"
#define GET_INSTRINFO_ENUM
#include "TOYGenInstrInfo.inc"
#define GET_SUBTARGETINFO_ENUM
#include "TOYGenSubtargetInfo.inc"
#endif</pre></div></li><li class="listitem" value="14">Create one<a id="id278" class="calibre1"/> more file, called <code class="email">TOYMCTargetDesc.cpp</code>, in the same folder:<div class="informalexample"><pre class="programlisting">#include "TOYMCTargetDesc.h"
#include "InstPrinter/TOYInstPrinter.h"
#include "TOYMCAsmInfo.h"
#include "llvm/MC/MCCodeGenInfo.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/FormattedStream.h"
#include "llvm/Support/TargetRegistry.h"
#define GET_INSTRINFO_MC_DESC
#include "TOYGenInstrInfo.inc"
#define GET_SUBTARGETINFO_MC_DESC
#include "TOYGenSubtargetInfo.inc"
#define GET_REGINFO_MC_DESC
#include "TOYGenRegisterInfo.inc"
using namespace llvm;

static MCInstrInfo *createTOYMCInstrInfo() {
  MCInstrInfo *X = new MCInstrInfo();
  InitTOYMCInstrInfo(X);
  return X;
}

static MCRegisterInfo *createTOYMCRegisterInfo(StringRef TT) {
  MCRegisterInfo *X = new MCRegisterInfo();
  InitTOYMCRegisterInfo(X, TOY::LR);
  return X;
}

static MCSubtargetInfo *createTOYMCSubtargetInfo(StringRef TT, StringRef CPU, StringRef FS) {
  MCSubtargetInfo *X = new MCSubtargetInfo();
  InitTOYMCSubtargetInfo(X, TT, CPU, FS);
  return X;
}

static MCAsmInfo *createTOYMCAsmInfo(const MCRegisterInfo &amp;MRI, StringRef TT) {
  MCAsmInfo *MAI = new TOYMCAsmInfo(TT);
  return MAI;
}
static MCCodeGenInfo *createTOYMCCodeGenInfo(StringRef TT, Reloc::Model RM, CodeModel::Model CM, CodeGenOpt::Level OL)
 {
  MCCodeGenInfo *X = new MCCodeGenInfo();
  if (RM == Reloc::Default) {
    RM = Reloc::Static;
  }
  if (CM == CodeModel::Default) {
    CM = CodeModel::Small;
  }
  if (CM != CodeModel::Small &amp;&amp; CM != CodeModel::Large) {
    report_fatal_error("Target only supports CodeModel Small or Large");
  }
  X-&gt;InitMCCodeGenInfo(RM, CM, OL);
  return X;
}

static MCInstPrinter *
createTOYMCInstPrinter(const Target &amp;T, unsigned SyntaxVariant,
                       const MCAsmInfo &amp;MAI, const MCInstrInfo &amp; MII, const MCRegisterInfo &amp;MRI, const MCSubtargetInfo &amp;STI) {
  return new TOYInstPrinter(MAI, MII, MRI);
}

static MCStreamer *
createMCAsmStreamer(MCContext &amp;Ctx, formatted_raw_ostream &amp;OS,
                    bool isVerboseAsm, bool useDwarfDirectory,
                    MCInstPrinter *InstPrint, MCCodeEmitter *CE,
                    MCAsmBackend *TAB, bool ShowInst) {
  return createAsmStreamer(Ctx, OS, isVerboseAsm, useD - warfDirectory, InstPrint, CE, TAB, ShowInst);
}

static MCStreamer *createMCStreamer(const Target &amp;T, StringRef TT,
MCContext &amp;Ctx, MCAsmBackend &amp;MAB, raw_ostream &amp;OS,
MCCodeEmitter *Emitter, const MCSubtargetInfo &amp;STI,
bool RelaxAll, bool NoExecStack) {
  return createELFStreamer(Ctx, MAB, OS, Emitter, false, NoExecStack);
}

// Force static initialization.
extern "C" void LLVMInitializeTOYTargetMC() {
  // Register the MC asm info.
  RegisterMCAsmInfoFn X(TheTOYTarget, createTOYMCAsmInfo);
  // Register the MC codegen info.
  TargetRegistry::RegisterMCCodeGenInfo(TheTOYTarget, createTOYMCCodeGenInfo);
  // Register the MC instruction info.
  TargetRegistry::RegisterMCInstrInfo(TheTOYTarget, createTOYMCInstrInfo);
  // Register the MC register info.
  TargetRegistry::RegisterMCRegInfo(TheTOYTarget, createTOYMCRegisterInfo);
  // Register the MC subtarget info.
  TargetRegistry::RegisterMCSubtargetInfo(TheTOYTarget,
                                          createTOYMCSub targetInfo);
  // Register the MCInstPrinter
  TargetRegistry::RegisterMCInstPrinter(TheTOYTarget, createTOYMCInstPrinter);
  // Register the ASM Backend.
  TargetRegistry::RegisterMCAsmBackend(TheTOYTarget, createTOYAsmBackend);
  // Register the assembly streamer.
  TargetRegistry::RegisterAsmStreamer(TheTOYTarget, createMCAsmStreamer);
  // Register the object streamer.
  TargetRegistry::RegisterMCObjectStreamer(TheTOYTarget, createMCStreamer);
  // Register the MCCodeEmitter
  TargetRegistry::RegisterMCCodeEmitter(TheTOYTarget, createTOYMCCodeEmitter);
}</pre></div></li><li class="listitem" value="15">In the<a id="id279" class="calibre1"/> same folder, create an <code class="email">LLVMBuild.txt</code> file:<div class="informalexample"><pre class="programlisting">[component_0]
type = Library
name = TOYDesc
parent = TOY
required_libraries = MC Support TOYAsmPrinter TOYInfo
add_to_library_groups = TOY</pre></div></li><li class="listitem" value="16">Create a CMakeLists.txt file:<div class="informalexample"><pre class="programlisting">add_llvm_library(LLVMTOYDesc
TOYMCTargetDesc.cpp)</pre></div><p class="calibre12">Build the enitre LLVM project, as follows:</p><div class="informalexample"><pre class="programlisting">$ cmake llvm_src_dir –DCMAKE_BUILD_TYPE=Release –
DLLVM_TARGETS_TO_BUILD="TOY"
$ make

Here, we have specified that we are building the LLVM compiler for the toy target. After the build completes, check whether the TOY target appears with the llc command:
$ llc –version
…
…
Registered Targets :
toy – TOY</pre></div></li></ol><div class="calibre21"/></div><p class="calibre7">The<a id="id280" class="calibre1"/> following IR, when given to the <code class="email">llc</code> tool, will generate an assembly as shown:</p><div class="informalexample"><pre class="programlisting">target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32- i16:16:32-i64:32-f64:32-a:0:32-n32"
target triple = "toy"
define i32 @foo(i32 %a, i32 %b){
  %c = add nsw i32 %a, %b
  ret i32 %c
}

$ llc foo.ll

.text
.file "foo.ll"
.globl foo
.type foo,@function
foo: # @foo
# BB#0: # %entry
add r0, r0, r1
b lr
.Ltmp0:
.size foo, .Ltmp0-foo</pre></div><p class="calibre7">To see the details of how to register a target with <code class="email">llc</code>, you can visit <a class="calibre1" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration">http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration</a> and <a class="calibre1" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a> by Chen Chung-Shu and Anoushe Jamshidi.</p></div>
<div class="book" title="Summary" id="1NA0K1-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we had a brief discussion about how a target architecture machine can be represented in LLVM. We saw the ease of using tablegen in organizing data such as register sets, instruction sets, calling conventions, and so on, for a given target. The <code class="email">llvm-tablegen</code> then converts these target descriptor <code class="email">.td</code> fies into enums, which can be used in program logic such as frame lowering, instruction selection, instruction printing, and so on. More detailed and complex architectures like ARM and X86 can give insight on a detailed description of the target.</p><p class="calibre7">In the first chapter, we tried a basic exercise to get hands-on with various tools provided by the LLVM infrastructure. In the subsequent chapters, that is, <a class="calibre1" title="Chapter 2. Building LLVM IR" href="part0018_split_000.html#H5A41-684481f6e3394b1e8596d1aa3001290f">Chapter 2</a>, <span class="strong"><em class="calibre8">Building LLVM IR</em></span>, and <a class="calibre1" title="Chapter 3. Advanced LLVM IR" href="part0028_split_000.html#QMFO1-684481f6e3394b1e8596d1aa3001290f">Chapter 3</a>, <span class="strong"><em class="calibre8">Advanced LLVM IR</em></span>, we used APIs provided by LLVM to emit IRs. Readers can use those APIs in their frontend to convert their language to LLVM IR. In <a class="calibre1" title="Chapter 5. Advanced IR Block Transformations" href="part0041_split_000.html#173722-684481f6e3394b1e8596d1aa3001290f">Chapter 5</a>, <span class="strong"><em class="calibre8">Advanced IR Block Transformations</em></span>, we got used to Pass Pipeline for IR optimization and went through some examples. In <a class="calibre1" title="Chapter 6. IR to Selection DAG phase" href="part0046_split_000.html#1BRPS2-684481f6e3394b1e8596d1aa3001290f">Chapter 6</a>, <span class="strong"><em class="calibre8">IR to Selection DAG Phase</em></span>, readers got familiar with the conversion of IR to selection DAG, which is a step towards emitting machine code. In this final chapter, we saw how to represent sample architecture with tablegen and use it for emitting code.</p><p class="calibre7">After reading this book, we hope that readers become familiar with LLVM infrastructure and are ready to dive deeply into LLVM and create compilers on their own for their custom architecture or a custom language. Happy Compiling!</p></div></body></html>