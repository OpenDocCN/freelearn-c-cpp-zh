- en: Chapter 9. On the Level – Eskimo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。在水平上 – 雪人
- en: '*In our next game, we''ll go over some important features most games require,
    but which are not directly related to gameplay. So we''ll step over the architecture
    side of things and talk about reading and writing data, using scene transitions,
    and creating custom events that your whole application can listen to.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们的下一款游戏中，我们将介绍大多数游戏都需要的一些重要功能，但这些功能与游戏玩法没有直接关系。因此，我们将跳过架构方面，讨论读取和写入数据、使用场景转换以及创建整个应用程序都可以监听的自定义事件。*'
- en: '*But, of course, I''ll add a few gameplay ideas as well!*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*但当然，我还会添加一些游戏玩法想法！*'
- en: 'This time, you''ll learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将学习如何：
- en: Create scene transitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建场景转换
- en: Load external data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载外部数据
- en: Save data using `UserDefault`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UserDefault`保存数据
- en: Create your own game events with the dispatcher
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分发器创建自己的游戏事件
- en: Use the accelerometer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: Reuse Box2D bodies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用Box2D实体
- en: The game – Eskimo
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏 – 雪人
- en: Little Eskimo boy is late for supper. It is your mission, should you choose
    to accept it, to guide the little fella back to his igloo.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 小雪人男孩晚点了晚餐。如果你选择接受这个任务，你的任务是引导这个小家伙回到他的冰屋。
- en: This is a Box2D game, and the controls are very simple. Tilt the device and
    the Eskimo will move. If you tap the screen, the Eskimo switches shape between
    a snow ball and a block of ice, each shape with its own physical characteristics
    and degrees of maneuverability. The ball has a higher friction, for instance,
    and the block of ice has none.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Box2D游戏，控制非常简单。倾斜设备，雪人就会移动。如果你轻触屏幕，雪人会在雪球和冰块之间切换形状，每种形状都有其自身的物理特性和操纵度。例如，球体具有更高的摩擦力，而冰块则没有。
- en: And the only way the Eskimo may reach his destination is by hitting the gravity
    switches spread out all over the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 雪人到达目的地的唯一方式是撞击屏幕上分布的引力开关。
- en: Eskimo combines elements from an arcade game with elements of a puzzle game,
    as each level was planned with one perfect solution in mind as to how to take
    the little Eskimo home. Note, however, that multiple solutions are possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 雪人结合了街机游戏和益智游戏元素，因为每个关卡都是计划好的，有一个完美的解决方案，即如何将小雪人带回家。然而，请注意，存在多种解决方案。
- en: '![The game – Eskimo](img/00034.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![游戏 – 雪人](img/00034.jpeg)'
- en: Download the `4198_09_FINAL_PROJECT.zip` file and run the game when you have
    a chance. Once again, there is no need for extraneous typing as the logic used
    in the game is pretty much old news to you, and we'll go over the new bits in
    depth.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`4198_09_FINAL_PROJECT.zip`文件，并在有机会时运行游戏。再次强调，不需要进行多余的输入，因为游戏中使用的逻辑对你来说几乎都是老生常谈的，我们将深入探讨新内容。
- en: The game settings
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设置
- en: This is a portrait-only game and accelerometer-based, so it should not autorotate.
    It was designed for the regular iPhone and its screen resolution size is set to
    `kResolutionShowAll`, so the screen settings are similar to the ones in our previous
    game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅包含肖像的游戏，基于加速度计，因此它不应该自动旋转。它是为普通iPhone设计的，其屏幕分辨率大小设置为`kResolutionShowAll`，因此屏幕设置与我们的前一款游戏相似。
- en: Designing a game for the iPhone screen and using the `kResolutionShowAll` parameter
    will result in the so-called **letterbox** view when playing the game in screens
    that do not match the iPhone's 1.5 ratio. This means you see borders around the
    game screen. Alternatively, you could use the `kResolutionNoBorders` parameter,
    which results in a **zoom-in** effect, causing the game to play at full screen
    but the areas around the borders will be cropped.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为iPhone屏幕设计游戏并使用`kResolutionShowAll`参数，当在不符合iPhone 1.5比例的屏幕上玩游戏时，将产生所谓的**信箱**视图。这意味着你会在游戏屏幕周围看到边框。或者，你也可以使用`kResolutionNoBorders`参数，这将产生**缩放**效果，使游戏在全屏播放，但边框周围的区域将被裁剪。
- en: 'The following screenshot illustrates these two cases:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了这两种情况：
- en: '![The game settings](img/00035.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设置](img/00035.jpeg)'
- en: The one on the left is the game screen on the iPad, using `kResolutionShowAll`.
    The one on the right uses `kResolutionNoBorders`. Note how the screen is zoomed
    in and cropped on the second one. When using `kResolutionNoBorders`, it's important
    to design your game so that no vital gameplay element appears too close to the
    borders as it may not be displayed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的是iPad上的游戏屏幕，使用`kResolutionShowAll`。右边使用的是`kResolutionNoBorders`。注意第二个屏幕是如何缩放和裁剪的。当使用`kResolutionNoBorders`时，重要的是要设计你的游戏，确保没有关键的游戏元素出现在边框太近的地方，因为它可能不会被显示。
- en: Organizing the game
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织游戏
- en: Once again, there is a `b2Sprite` class, and the `Eskimo` and `Platform` classes
    extend `b2Sprite`. Then there are the regular `Sprite` classes, `GSwitch` (which
    stands for gravity switch) and `Igloo`. The logic runs collision detection between
    these last two and `Eskimo`, but I chose not to have them as sensor bodies because
    I wanted to show you that 2D collision logic for the Cocos2d-x elements can coexist
    with collision logic for the Box2D elements just fine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，有一个`b2Sprite`类，`Eskimo`和`Platform`类扩展了`b2Sprite`。然后是常规的`Sprite`类，`GSwitch`（代表重力开关）和`Igloo`。逻辑在这最后两个和`Eskimo`之间运行碰撞检测，但我选择不将它们作为传感器体，因为我想要展示Cocos2d-x元素和Box2D元素的2D碰撞逻辑可以很好地共存。
- en: 'But most importantly, this game now has three scenes. So far in this book,
    we''ve only used one scene per game. This game''s scene objects will wrap `MenuLayer`,
    `LevelSelectLayer`, and `GameLayer`. Here''s a brief note on all three:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的是，这个游戏现在有三个场景。到目前为止，在这本书中，我们每个游戏只使用了一个场景。这个游戏的场景对象将包装`MenuLayer`、`LevelSelectLayer`和`GameLayer`。以下是关于这三个的简要说明：
- en: In `MenuLayer`, you have the option to play the game, which will take you to
    `LevelSelectLayer` or to play a tutorial for the game, which will take you to
    `GameLayer`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`MenuLayer`中，你可以选择玩游戏，这将带你到`LevelSelectLayer`，或者玩游戏教程，这将带你到`GameLayer`。
- en: In `LevelSelectLayer`, you may choose which available level you want to play,
    and that will take you to `GameLayer`. Or you may go back to `MenuLayer`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`LevelSelectLayer`中，你可以选择你想玩哪个可用关卡，这将带你到`GameLayer`。或者你也可以回到`MenuLayer`。
- en: In `GameLayer`, you play the game, and may go back to `MenuLayer` upon game
    over.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GameLayer`中，你玩游戏，游戏结束后可能会回到`MenuLayer`。
- en: 'The following image illustrates all three scenes in the game:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了游戏中的所有三个场景：
- en: '![Organizing the game](img/00036.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![组织游戏](img/00036.jpeg)'
- en: Using scenes in Cocos2d-x
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Cocos2d-x中使用场景
- en: Scenes are mini applications themselves. If you have experience as an Android
    developer, you may think of scenes as activities. Of all the classes based on
    node, the `Scene` application is the most architecturally relevant, because the
    `Director` class runs a scene, in effect running your application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 场景本身就是小程序。如果你有Android开发经验，你可能会把场景想象成活动。在所有基于节点的类中，`Scene` 应用程序在架构上最为相关，因为`Director`
    类运行场景，实际上就是在运行你的应用程序。
- en: 'Part of the benefit of working with scenes is also part of the drawback: they
    are wholly independent and ignorant of each other. The need to share information
    between scenes will be a major factor when planning your game class structure.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与场景一起工作的部分好处也是部分缺点：它们完全独立且互不干扰。在规划你的游戏类结构时，场景之间共享信息的需求将是一个重要因素。
- en: Also, memory management may become an issue. A currently running scene will
    not give up its ghost until a new scene is up and running. So, when you use transition
    animations, keep in mind that for a few seconds, both scenes will exist in memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内存管理可能成为一个问题。当前正在运行的场景不会放弃其资源，直到一个新的场景启动并运行。因此，当你使用过渡动画时，请记住，在几秒钟内，两个场景都将存在于内存中。
- en: In Eskimo, I initialize scenes in two different ways. With `MenuLayer` and `LevelSelectLayer`,
    each time the user navigates to either one of these scenes, a new layer object
    is created (either a new `MenuLayer` or a new `LevelSelectLayer`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eskimo中，我以两种不同的方式初始化场景。使用`MenuLayer` 和 `LevelSelectLayer`，每次用户导航到这两个场景中的任何一个时，都会创建一个新的层对象（要么是新的`MenuLayer`，要么是新的`LevelSelectLayer`）。
- en: '`GameLayer`, however, is different. It is a singleton `Layer` class that never
    stays out of memory after its first instantiation, therefore speeding up the time
    from level selection to the actual playing. This may not work for every game,
    however. As I mentioned earlier, when transitioning between scenes, both scenes
    stay in memory for a few seconds. But here we are adding to that problem by keeping
    one layer in memory the whole time. Eskimo, however, is not very big memory-wise.
    Note that we could still have the option of creating special conditions for when
    `GameLayer` should be destroyed, and conditions when it should not.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`GameLayer`是不同的。它是一个单例`Layer`类，在第一次实例化后永远不会从内存中消失，因此加快了从关卡选择到实际游戏的时间。但这可能并不适用于每个游戏。正如我之前提到的，在场景之间切换时，两个场景会在内存中持续几秒钟。但在这里，我们通过在整个过程中保持一个层在内存中，增加了这个问题。然而，Eskimo在内存方面并不大。请注意，我们仍然可以选择为`GameLayer`应该被销毁的条件创建特殊条件，以及它不应该销毁的条件。
- en: So let me show you how to create scene transitions. First, with a `Scene` class
    that creates a fresh copy of its `Layer` each time it's created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我来展示如何创建场景过渡。首先，使用一个每次创建时都会创建其 `Layer` 新副本的 `Scene` 类。
- en: Time for action – creating a scene transition
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 - 创建场景过渡
- en: You have, of course, been using scenes all along.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然一直在使用场景。
- en: 'Hidden in `AppDelegate.cpp`, you''ve had lines like:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate.cpp` 中隐藏着类似的行：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, in order to change scenes, all you need to do is tell the `Director` class
    which scene you wish it to run. Cocos2d-x will then get rid of all the content
    in the current scene, if any (all their destructors will be called), and a new
    layer will be instantiated and wrapped inside the new `Scene`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了更改场景，你只需要告诉 `Director` 类你希望它运行哪个场景。Cocos2d-x 将会移除当前场景中的所有内容（如果有的话，所有它们的析构函数都会被调用），并实例化一个新的层并将其包裹在新的
    `Scene` 中。
- en: 'Breaking the steps down a little further, this is how you usually create a
    new scene for `Director`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步分解步骤，这是通常为 `Director` 创建新场景的方式：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The static `MenuLayer::scene` method will create a blank scene, and then create
    a new instance of `MenuLayer` and add it as a child to the new scene.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法 `MenuLayer::scene` 将创建一个空白场景，然后创建 `MenuLayer` 的新实例并将其作为子节点添加到新场景中。
- en: 'Now you can tell `Director` to run it as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以告诉 `Director` 运行它，如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The logic changes a little if you wish to use a transition effect. So, inside
    our `MenuLayer.cpp` class, this is how we transition to `LevelSelectLayer`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望使用过渡效果，逻辑会有一些变化。所以，在我们的 `MenuLayer.cpp` 类中，这是如何过渡到 `LevelSelectLayer` 的：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code just described creates a new transition object that will slide in the
    new scene from the right-hand side of the screen to lie on top of the current
    one. The transition will take `0.2` seconds.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的过渡对象，该对象将从屏幕的右侧滑入新场景，并覆盖当前场景。过渡将花费 `0.2` 秒。
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You created a scene transition animation with Cocos2d-x.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用 Cocos2d-x 创建了一个场景过渡动画。
- en: As I mentioned earlier, this form of scene change will cause a new instance
    of the new layer to be created each time, and destroyed each time it's replaced
    by a new scene. So, in our game, `MenuLayer` and `LevelSelectLayer` are instantiated
    and destroyed as many times as the user switches between them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，这种场景更改形式将导致每次都创建一个新的新层实例，并在每次被新场景替换时销毁。所以，在我们的游戏中，`MenuLayer` 和 `LevelSelectLayer`
    会根据用户在它们之间切换的次数被实例化和销毁。
- en: There is also the option to use `pushScene` instead of `replaceScene`. This
    creates a stack of `scene` objects and keeps them all in memory. This stack can
    be navigated with `popScene` and `popToRootScene`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以选择使用 `pushScene` 而不是 `replaceScene`。这会创建一个 `scene` 对象的堆栈，并将它们全部保留在内存中。这个堆栈可以通过
    `popScene` 和 `popToRootScene` 进行导航。
- en: Now let me show you how to do the same thing but with a singleton layer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我来展示如何使用单例层做同样的事情。
- en: It should be no surprise to you by now that you will find many examples of these
    transition classes in the `Tests`, project at `tests/cpp-tests/Classes/TransitionsTest`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能会发现 `Tests` 项目中有很多这些过渡类的例子，在 `tests/cpp-tests/Classes/TransitionsTest`。
- en: Time for action – creating transitions with a singleton Layer class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 - 使用单例层类创建过渡
- en: We first need to make sure the layer in question can only be instantiated once.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确保相关的层只能实例化一次。
- en: 'The `scene` static method in `GameLayer` looks like this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameLayer` 中的 `scene` 静态方法看起来是这样的：'
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This layer receives two parameters when created: the game level it should load
    and the number of levels completed by the player. We create a new `Scene` object
    and add `GameLayer` as its child.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该层在创建时接收两个参数：它应该加载的游戏关卡以及玩家完成的游戏关卡数量。我们创建一个新的 `Scene` 对象并将 `GameLayer` 作为其子节点添加。
- en: 'But take a look at the static `create` method in `GameLayer`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但看看 `GameLayer` 中的静态 `create` 方法：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An `_instance` static property is declared at the top of `GameLayer.cpp` as
    follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameLayer.cpp` 的顶部声明了一个 `_instance` 静态属性，如下所示：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can check, then, if the one instance of `GameLayer` is currently in memory
    and instantiate it if necessary.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以检查，如果 `GameLayer` 的一个实例当前在内存中，并在必要时实例化它。
- en: 'The scene transition to `GameLayer` will look, on the surface, to be exactly
    like the regular kind of transition. So, in `LevelSelectLayer`, we have the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景过渡到 `GameLayer` 表面上看起来与常规过渡完全一样。所以，在 `LevelSelectLayer` 中，我们有以下内容：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have created a `Scene` transition with a `Layer` class that never gets destroyed,
    so we don't have to instantiate new platform and gravity switch sprites with each
    new level.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个带有`Layer`类的`Scene`过渡，该类永远不会被销毁，因此我们不需要为每个新关卡实例化新的平台和重力开关精灵。
- en: There are, of course, problems and limitations with this process. We cannot
    transition between the two `GameLayer` objects, for instance, as we only ever
    have one of these objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个过程当然存在问题和限制。例如，我们不能在这两个`GameLayer`对象之间进行转换，因为我们始终只有一个这样的对象。
- en: There are also some special considerations when leaving `GameLayer` and when
    getting back to it. For instance, we must make sure we have our main loop running
    when we get back to `GameLayer`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开`GameLayer`和返回到它时，也有一些特殊考虑。例如，当我们返回到`GameLayer`时，我们必须确保我们的主循环正在运行。
- en: 'The only way to do that is by unscheduling it whenever leaving `GameLayer`
    and scheduling it again when returning, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的方法是在离开`GameLayer`时取消调度它，并在返回时再次调度，如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Again, architecturally speaking, there are even better options. Possibly the
    best one is creating your own game elements cache, or game manager, with object
    pools and everything that needs instantiating stored inside it. And then have
    this cache be a singleton that every scene can access. This is also the best way
    to share game-relevant data between scenes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从架构的角度来看，还有更好的选择。可能最好的选择是创建自己的游戏元素缓存或游戏管理器，其中包含所有需要实例化的对象，并使其成为一个单例，每个场景都可以访问。这也是在场景之间共享与游戏相关的数据的最佳方式。
- en: Loading external data from a .plist file
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 .plist 文件加载外部数据
- en: Eskimo has only five game levels, plus a tutorial level (feel free to add more).
    The data for these levels exist inside a l`evels.plist` file, stored inside the
    `Resources` folder. A `.plist` file is an XML-formatted data file, and as such
    can be created in any text editor. Xcode, however, offers a nice GUI to edit the
    files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Eskimo 只有五个游戏关卡，还有一个教程关卡（您可以自由添加更多）。这些关卡的数据存储在`Resources`文件夹中的`levels.plist`文件中。`.plist`文件是一个XML格式的数据文件，因此可以在任何文本编辑器中创建。然而，Xcode提供了一个很好的GUI来编辑这些文件。
- en: Let me show you how to create them inside Xcode.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来向您展示如何在Xcode中创建它们。
- en: Time for action – creating a .plist file
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 创建 .plist 文件
- en: You could, of course, create this in any text editor, but Xcode makes it extra
    easy to create and edit `.plist` files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在任何文本编辑器中创建此文件，但Xcode使创建和编辑`.plist`文件变得格外简单。
- en: Inside Xcode, go to **New** | **File...** and then select **Resource** and **Property
    List**. When asked where to save the file, choose any location you want.![Time
    for action – creating a .plist file](img/00037.jpeg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中，转到**新建** | **文件...**，然后选择**资源**和**属性列表**。当被问及保存文件的位置时，选择您想要的任何位置。![动手实践
    – 创建 .plist 文件](img/00037.jpeg)
- en: You need to decide what the **Root** element of your `.plist` file will be—either
    an **Array** or a **Dictionary** (the default) type. For Eskimo, the **Root**
    element is **Array** containing a series of dictionaries, each holding the data
    for a level in the game.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要决定您的`.plist`文件中的**根**元素将是什么——可以是**数组**或**字典**类型（默认）。对于Eskimo，**根**元素是一个包含一系列字典的**数组**，每个字典都包含游戏中的一个关卡的数据。
- en: By selecting the **Root** element, you get a plus sign indicator right next
    to the **Type** declaration. Clicking on this plus sign will add an element to
    **Root**. You can then pick the data type for this new item. The options are **Boolean**,
    **Data**, **Date**, **Number**, **String**, and again **Array** and **Dictionary**.
    The last two can contain subitems in the tree, just like the **Root** element.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**根**元素，您会在**类型**声明旁边看到一个加号指示器。点击此加号将向**根**添加一个元素。然后您可以为此新项目选择数据类型。选项包括**布尔值**、**数据**、**日期**、**数字**、**字符串**，以及再次是**数组**和**字典**。最后两个可以包含树中的子项，就像**根**元素一样。
- en: Keep adding elements to the tree, trying to match the items in the following
    screenshot:![Time for action – creating a .plist file](img/00038.jpeg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续向树中添加元素，尝试匹配以下截图中的项目：![动手实践 – 创建 .plist 文件](img/00038.jpeg)
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You just created a property list file in Xcode. This is XML-structured data
    that Cocos2d-x can load and parse. You've used them already when loading particles
    and sprite sheet information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在Xcode中创建了一个属性列表文件。这是Cocos2d-x可以加载和解析的XML结构化数据。您已经在加载粒子效果和精灵表信息时使用过它们。
- en: Loading the level data
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载关卡数据
- en: In Eskimo, since I only have five levels, I chose to have one `.plist` file
    that contains all levels. This may not be the best option in a larger game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eskimo 中，由于我只有五个级别，我选择使用一个包含所有级别的 `.plist` 文件。这可能不是大型游戏中的最佳选择。
- en: Although Apple devices will load and parse the `.plist` files quickly, the same
    may not be true for other targets. So limit the size of your `.plist` files by
    organizing the data into multiple files. You've probably seen games that divide
    their levels into multiple groups or packs. This is a simple way to create an
    extra preloading screen your game can use to parse level data. This can also be
    used as a means to keep file sizes to a minimum.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然苹果设备可以快速加载和解析 `.plist` 文件，但其他目标可能不一定如此。因此，通过将数据组织到多个文件中来限制 `.plist` 文件的大小。你可能见过将他们的级别分成多个组或包的游戏。这是一种简单的方法，可以为你的游戏创建一个额外的预加载屏幕，用于解析级别数据。这也可以用作将文件大小保持在最小值的方法。
- en: In Eskimo, we could have the `.plist` files containing 10 levels each, for instance,
    and then 10 groups of these, totaling 100 levels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eskimo 中，我们可以有包含 10 个级别的 `.plist` 文件，例如，然后是 10 组这样的文件，总共 100 个级别。
- en: So it's time to load our `.plist` file and parse the data for our levels.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候加载我们的 `.plist` 文件并解析我们级别的数据了。
- en: Time for action – retrieving data from the .plist file
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 从 .plist 文件中检索数据
- en: The level data is loaded in `GameLayer`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 级别数据在 `GameLayer` 中加载。
- en: 'Inside the `GameLayer` constructor, we load the data like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameLayer` 构造函数内部，我们这样加载数据：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Cocos2d-x will take care of mapping `FileUtils` to the correct target. There
    is `FileUtils` for each platform that is supported by the framework and they all
    can be made to work with the `.plist` format. Sweet! If the data in the `.plist`
    file is an **Array**, you must convert it to `ValueVector`; if it's **Dictionary**,
    you must convert it to a `ValueMap`. We'll do that next when we load the data
    for a specific level.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cocos2d-x 将负责将 `FileUtils` 映射到正确的目标。框架支持的每个平台都有一个 `FileUtils`，并且它们都可以与 `.plist`
    格式一起工作。太棒了！如果 `.plist` 文件中的数据是 **数组**，你必须将其转换为 `ValueVector`；如果是 **字典**，你必须将其转换为
    `ValueMap`。我们将在加载特定级别的数据时这样做。
- en: Note
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we divide the levels into multiple `.plist` files, then we would need logic
    to refresh the `_levels` array each time a new `.plist` file is loaded.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们将级别分成多个 `.plist` 文件，那么每次加载一个新的 `.plist` 文件时，我们都需要有逻辑来刷新 `_levels` 数组。
- en: 'Inside the `loadLevel` method, we load the data for the level like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `loadLevel` 方法内部，我们这样加载级别的数据：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the data in the `.plist` file is **Dictionary**, so we must convert the
    data into a `ValueMap`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`.plist` 文件中的数据是 **字典**，因此我们必须将数据转换为 `ValueMap`。
- en: And that's it for the loading and parsing. Now we can proceed to retrieving
    data for our level.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载和解析到此结束。现在我们可以继续检索我们级别的数据。
- en: Each level dictionary starts with the data regarding the level's gravity (a
    level may start with a different gravity value), the start point where the player
    should be placed, and the end point where the igloo should be placed.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个级别字典以关于级别重力的数据（一个级别可能以不同的重力值开始）开始，玩家应该放置的起点，以及冰屋应该放置的终点。
- en: 'These values are retrieved like this in our code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些值在我们的代码中是这样检索的：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this same dictionary, we have an array for platforms and an array for
    gravity switches. These are retrieved like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个相同的字典中，我们有一个平台数组和一个重力开关数组。这些是这样检索的：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These arrays contain even more dictionaries containing data for the creation
    and placement of platforms and gravity switches in each level. This data is passed
    to the corresponding `Platform` and `GSwitch` classes, and boom—you've got yourself
    a level.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些数组包含更多字典，包含每个级别中平台和重力开关的创建和放置数据。这些数据传递给相应的 `Platform` 和 `GSwitch` 类，然后 - 你就得到了一个级别。
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: Parsing and retrieving data from a property list file is a breeze with Cocos2d-x.
    You will always work with either an array of values or a dictionary of values
    and map these to a `ValueVector` or `ValueMap` respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cocos2d-x 解析和检索属性列表文件非常简单。你将始终与值数组或值字典一起工作，并将它们分别映射到 `ValueVector` 或 `ValueMap`。
- en: Saving game data
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存游戏数据
- en: When planning your games, you may soon decide you wish to store data related
    to your application, such as highest score or user preferences. In Cocos2d-x,
    you can do this by simply accessing the `UserDefault` singleton.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你规划你的游戏时，你可能会很快决定你希望存储与你的应用程序相关的数据，例如最高分或用户偏好。在 Cocos2d-x 中，你可以通过简单地访问 `UserDefault`
    单例来实现这一点。
- en: 'With `UserDefault`, you can store integers, floats, doubles, strings, and Boolean
    with just one simple call per each data type, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UserDefault`，你可以通过每个数据类型的一个简单调用来存储整数、浮点数、双精度浮点数、字符串和布尔值，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The other methods are `setFloatForKey`, `setDoubleForKey`, `setStringForKey`,
    and `setBoolForKey`. To retrieve data, you use their respective getters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法有`setFloatForKey`、`setDoubleForKey`、`setStringForKey`和`setBoolForKey`。要检索数据，请使用它们各自的getter。
- en: I'll show you next how to use that in our game.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何在我们的游戏中使用它。
- en: Time for action – storing the completed levels
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 存储完成关卡
- en: Open the `LevelSelectLayer` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LevelSelectLayer`类。
- en: 'This is how the number of levels completed is retrieved from inside the layer''s
    constructor:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是从层构造函数内部检索完成关卡数量的方式：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initially, `_levelsCompleted` will equal `0` if no data is present. So we store
    level 1 as "unlocked". This is how that''s done:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，如果没有数据存在，`_levelsCompleted`将等于`0`。因此，我们将关卡1存储为“解锁”。这是如何做到的：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, whenever we start a new level, we update the number of levels completed
    if the new level number is larger than the value stored.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每次我们开始一个新的关卡时，如果新关卡编号大于存储的值，我们就更新完成关卡的数量。
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You don''t have to flush the data (using `flush`) each time you update every
    single bit in it. You can group multiple updates under one flush, or find a spot
    in your logic where you can safely flush updates before exiting the app. Nodes
    come with extremely helpful methods for this: `onEnter`, `onExit`, `onEnterTransitionDidFinish`,
    and `onExitTransitionDidStart`.'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不必每次更新数据中的每一个位时都刷新数据（使用`flush`）。你可以将多个更新分组在一个刷新中，或者找到你逻辑中的一个安全位置，在退出应用之前安全地刷新更新。节点为此提供了极有帮助的方法：`onEnter`、`onExit`、`onEnterTransitionDidFinish`和`onExitTransitionDidStart`。
- en: '*What just happened?*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: For small bits of data related to your game, settings, and preferences, `UserDefault`
    is an excellent way to store information. Cocos2d-x once again will map this to
    whatever local storage is available in each target system.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与你的游戏、设置和首选项相关的少量数据，`UserDefault`是存储信息的绝佳方式。Cocos2d-x将再次将其映射到每个目标系统可用的本地存储。
- en: Using events in your game
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的游戏中使用事件
- en: Earlier versions of the framework used an Objective-C-inspired feature of notifications.
    But this particular API is already on its way to being deprecated. Instead, you
    should use the all-knowing `Director` and its `Dispatcher` (the same object we've
    been talking to when listening to touch events).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的早期版本使用了一个受Objective-C启发的功能，即通知。但这个特定的API已经走向了被弃用的道路。相反，你应该使用无所不知的`Director`及其`Dispatcher`（这是我们之前在监听触摸事件时一直在与之交谈的对象）。
- en: If you have ever worked with an MVC framework or developed a game AI system,
    you are probably familiar with a design pattern called the **Observer Pattern**.
    This consists of a central message dispatcher object other objects can subscribe
    to (observe) in order to listen to special messages, or order it to dispatch their
    own messages to other subscribers. In other words, it's an event model.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过MVC框架或开发过游戏AI系统，你可能熟悉一个称为**观察者模式**的设计模式。这包括一个中心消息分发对象，其他对象可以订阅（观察）以监听特殊消息，或者指示它将它们自己的消息分发给其他订阅者。换句话说，它是一个事件模型。
- en: With Cocos2d-x, this is done very quickly and easily. Let me give you an example
    used in Eskimo.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cocos2d-x，这做得非常快且简单。让我给你一个在Eskimo中使用的例子。
- en: Time for action – using the event dispatcher
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用事件分发器
- en: If we want the `Platform` sprite to listen to the special notification `NOTIFICATION_GRAVITY_SWITCH`,
    all we need to do is add `Platform` as an observer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让`Platform`精灵监听特殊通知`NOTIFICATION_GRAVITY_SWITCH`，我们只需要将`Platform`添加为观察者。
- en: 'Inside the `Platform` class, in its constructor, you will find these lines:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Platform`类的构造函数中，你会找到这些行：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And yes, it is one line of code! It is best to create a macro for both the
    dispatcher and the add listener code; so, something like this:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，这只是一行代码！最好为分发器和添加监听器代码创建一个宏；所以，可能像这样：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This way the same line of code we used before would look like this:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们之前使用的相同行代码将看起来像这样：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The message (or notification), `NOTIFICATION_GRAVITY_SWITCH`, is created as
    a static string in `GameLayer`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息（或通知）`NOTIFICATION_GRAVITY_SWITCH`在`GameLayer`中作为一个静态字符串创建：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The one-line call to the `Director` class's dispatcher tells it that the `Platform`
    objects will listen to this defined message, and when such a message is dispatched,
    every `Platform` object will call the `onGravityChanged` method. This method does
    not need to be a block as I showed here, but it is more readable to have the handler
    appear as close to the `Add Listener` call as possible. So, simple blocks are
    a good way to organize listeners and their handlers.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对“Director”类调度程序的这一行调用告诉它“平台”对象将监听这个定义的消息，并且当这样的消息被调度时，每个“平台”对象都会调用“onGravityChanged”方法。这个方法不需要像我这里展示的那样是一个块，但将处理程序尽可能靠近“添加监听器”调用是更易读的。因此，简单的块是组织监听器和它们的处理程序的好方法。
- en: 'In the game, each gravity switch is color coded, and when the Eskimo hits a
    switch, the platform''s texture changes to reflect the new gravity by switching
    to the color of the activated gravity switch. This is all done through a simple
    notification we dispatch inside `GameLayer` when a collision with a `GSwitch`
    object is detected inside the main loop. This is how we do that:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏中，每个重力切换都有颜色编码，当Eskimo撞击一个切换时，平台的纹理会改变以反映新的重力，通过切换到激活的重力切换的颜色。这一切都是通过我们在主循环中检测到与“GSwitch”对象的碰撞时在“GameLayer”内部发出的简单通知来完成的。这就是我们这样做的方式：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or, if you are using the macro, use this:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果你使用宏，可以使用以下代码：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also add a `UserData` object in the custom event as a second parameter
    in the dispatch. This can be retrieved from the `EventCustom *` event in the event
    handler, like this:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以在自定义事件中添加一个“UserData”对象作为调度的第二个参数。这可以从事件处理程序中的“EventCustom *”事件中检索，如下所示：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When `Platform` objects are destroyed, the `Node` destructor will take care
    of removing the node as a listener.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当“平台”对象被销毁时，节点析构函数将负责将其作为监听器移除。
- en: '*What just happened?*'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You have just learned how to make your life as a developer much, much easier.
    Adding an application-wide event model to your game is such a powerful way to
    improve flow and interactivity between objects and it's so simple to use that
    I'm sure you'll soon implement this feature in all your games.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何让你的开发者生活变得容易得多。将一个应用程序级的事件模型添加到你的游戏中是一种提高对象之间流动性和交互性的强大方式，而且使用起来非常简单，我相信你很快就会在所有游戏中实现这个功能。
- en: Using the accelerometer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: Now let's move to the few new topics related to gameplay, the first of which
    is the use of accelerometer data. Again, nothing could be simpler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向与游戏玩法相关的一些新主题，首先是使用加速度计数据。同样，这很简单。
- en: Time for action – reading accelerometer data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 读取加速度计数据
- en: Just as you do with `touch` events, you need to tell the framework you want
    to read accelerometer data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你对“触摸”事件所做的那样，你需要告诉框架你想要读取加速度计数据。
- en: 'You tell the framework you wish to use the accelerometer with this one call
    inside any `Layer` class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在任意“层”类中的这个调用告诉框架你希望使用加速度计：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, just as you''ve done with `touch` events, you subscribe to the `accelerometer`
    events from the event dispatcher as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，就像你对“触摸”事件所做的那样，你按照以下方式订阅事件调度程序中的“加速度”事件：
- en: '[PRE26]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In Eskimo, the accelerometer data changes the value of a `Point` vector called
    `_acceleration`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eskimo中，加速度计数据改变了名为“_acceleration”的“点”向量的值。
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This value is then read inside the main loop and used to move the Eskimo. In
    the game, only one axis is updated at a time, depending on the current gravity.
    So you can only ever move the Eskimo on the `X` axis or the `Y` axis with the
    accelerometer data, but never both at the same time.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个值随后在主循环中被读取，并用于移动Eskimo。在游戏中，每次只更新一个轴，这取决于当前的引力。所以你只能使用加速度计数据在“X”轴或“Y”轴上移动Eskimo，但不能同时移动两个轴。
- en: Note
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that there is also a `Z` axis value in the `Acceleration` data.
    It might come in handy someday!
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，在“加速度”数据中还有一个“Z”轴值。将来某天这可能会派上用场！
- en: '*What just happened?*'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Yep. With a couple of lines, you added accelerometer controls to your game.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。用几行代码，你就为你的游戏添加了加速度控制。
- en: It is common practice to add extra filters to these accelerometer values, as
    results may vary between devices. These filters are ratios you apply to acceleration
    to keep values within a certain range. You can also find a variety of formulas
    for these ratios online. But these will depend on how sensitive you need the controls
    to be or how responsive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些加速度值上添加额外的过滤器是一种常见的做法，因为不同设备的结果可能会有所不同。这些过滤器是应用于加速度的比率，以保持值在某个范围内。你还可以在网上找到这些比率的多种公式。但这些都取决于你需要控制有多敏感，或者有多响应。
- en: 'And, in the game, we only update the Eskimo with the accelerometer data if
    the sprite is touching a platform. We can quickly ascertain that by checking whether
    or not the `_player` body has a contact list, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们只有在精灵触摸平台时才更新爱斯基摩人的加速度计数据。我们可以通过检查 `_player` 身体是否有接触列表来快速确定这一点，如下所示：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Reusing b2Bodies
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用 b2Bodies
- en: In Eskimo, we have a pool of `b2Bodies` that are used inside the `Platform`
    objects and we also change the shape of the little Eskimo whenever the player
    taps the screen. This is possible because Box2D makes it very easy to change the
    fixture data of a `b2Body` fixture without having to destroy the actual body.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在爱斯基摩人中，我们有一个 `b2Bodies` 的池，这些 `b2Bodies` 被用于 `Platform` 对象中，并且每当玩家点击屏幕时，我们也改变小爱斯基摩人的形状。这是可能的，因为
    Box2D 使得在不销毁实际身体的情况下更改 `b2Body` 配件的数据变得非常容易。
- en: Let me show you how.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来给你展示一下。
- en: Time for action – changing a b2Body fixture
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 更改 b2Body 配件
- en: All you have to do is make a call to `body->DestroyFixture`. Not surprisingly,
    this should be done outside the simulation step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的只是调用 `body->DestroyFixture`。不出所料，这应该在模拟步骤之外完成。
- en: 'Inside the methods `makeCircleShape` and `makeBoxShape` in the `Eskimo` class,
    you will find these lines:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Eskimo` 类的 `makeCircleShape` 和 `makeBoxShape` 方法中，你会找到以下这些行：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we just state that if there is a fixture for this body, destroy it. We
    can then switch from a box to a circle fixture when the player taps the screen,
    but use the same body throughout.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们只是声明如果这个身体有配件，就销毁它。当玩家点击屏幕时，我们可以从方形配件切换到圆形配件，但使用相同的身体。
- en: 'We use this feature with platforms too. Platforms inside the pool that are
    not being used in the current level are set to inactive as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也使用这个特性来处理平台。池中的平台如果没有在当前关卡中使用，则设置为不活动状态，如下所示：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This removes them from the simulation.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将它们从模拟中移除。
- en: 'And when they are reinitialized to be used in a level, we destroy their existing
    fixture, update it to match the data from the `.plist` file, and set the body
    to active once again. This is how we do that:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它们被重新初始化以用于关卡时，我们销毁它们现有的配件，更新它以匹配 `.plist` 文件中的数据，并将身体再次设置为活动状态。这就是我们这样做的方式：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*What just happened?*'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: So, just as we've been doing with pools of sprites, we can apply the same logic
    to `b2Bodies` and never instantiate anything inside the main loop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像我们一直在对精灵池应用相同的逻辑一样，我们也可以将相同的逻辑应用到 `b2Bodies` 上，而无需在主循环中实例化任何东西。
- en: Now, let's see how Android handles all this level-loading business.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Android 如何处理所有这些关卡加载业务。
- en: Time for action – running the game in Android
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在 Android 上运行游戏
- en: Time to deploy the game to Android.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将游戏部署到 Android 上。
- en: Navigate to the `proj.android` folder and open the file `AndroidManifest.xml`
    in a text editor. Then go to the folder `jni` and open the file `Android.mk` in
    a text editor.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `proj.android` 文件夹，在文本编辑器中打开文件 `AndroidManifest.xml`。然后转到 `jni` 文件夹，在文本编辑器中打开文件
    `Android.mk`。
- en: 'In the `AndroidManifest.xml` file, edit the following line in the `activity`
    tag as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，编辑 `activity` 标签中的以下行，如下所示：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let''s edit the make file, so open the `Android.mk` file and edit the
    lines in `LOCAL_SRC_FILES` to read:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑 make 文件，所以打开 `Android.mk` 文件，并编辑 `LOCAL_SRC_FILES` 中的行，如下所示：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now import the project into Eclipse and build it.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将项目导入 Eclipse 并构建它。
- en: You can now save it and run the game in your Android device.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以保存它并在你的 Android 设备上运行游戏。
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: By now, you should be an expert at running your code in Android and hopefully
    your experience with Eclipse has been a good one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经精通在 Android 上运行你的代码，并且希望你在 Eclipse 上的体验是好的。
- en: And that's all folks!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是全部了！
- en: Play the game. Check out the source code (which is chock-full of comments).
    Add some new levels and make the little Eskimo's life a living hell!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 玩这个游戏。查看源代码（里面满是注释）。添加一些新关卡，让这个小爱斯基摩人的生活变得地狱般艰难！
- en: Have a go hero
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试吧，英雄
- en: The gameplay for Eskimo could be further improved with a few new ideas that
    would force the player to make more errors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些新的想法，Eskimo 的游戏玩法可以进一步改进，这些想法会迫使玩家犯更多的错误。
- en: It is a common feature in these types of games to evaluate the degree of "completeness"
    in which a level was played. There could be a time limit for each level and pick-up
    items for the Eskimo, and the player could be evaluated at the end of each level
    and awarded a bronze, silver, or golden star based on his or her performance.
    And new groups of levels may only be unlocked if a certain number of golden stars
    were acquired.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类游戏中，评估玩家在关卡中所达到的“完整性”程度是一个常见特征。每个关卡可能都有一个时间限制，以及为爱斯基摩人准备的拾取物品，玩家在每关结束时会被评估，并根据其表现获得铜星、银星或金星。而且，只有获得一定数量的金星，才能解锁新的关卡组。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Yes, you have a cool idea for a game, great! But a lot of effort will go into
    structuring and optimizing it. Cocos2d-x can help with both sides of the job.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你有一个很酷的游戏想法，太好了！但是，在结构和优化它上将会投入大量的努力。Cocos2d-x可以帮助你完成这项工作的两个方面。
- en: Yes, scenes can be a bit cumbersome depending on your needs, but they are undisputed
    memory managers. When `Director` kills a scene, it kills it dead.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，场景可能会根据你的需求变得有些繁琐，但它们无疑是无可争议的内存管理器。当`Director`销毁一个场景时，它会彻底销毁它。
- en: Loading external data can not only help with memory size, but also bring in
    more developers into your project, focusing specifically on level design and the
    external data files that create them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 加载外部数据不仅可以帮助减小内存大小，还可以将更多开发者引入你的项目，他们专注于关卡设计和创建它们的外部数据文件。
- en: And events can quickly become a must in the way you structure your games. Pretty
    soon, you will find yourself thinking in terms of events to handle game states
    and menu interactivity, among other things.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，事件可以迅速成为你游戏结构中不可或缺的一部分。很快，你就会发现自己开始用事件来处理游戏状态和菜单交互性，以及其他事情。
- en: Now, let's move to a whole new language!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一种全新的语言！
