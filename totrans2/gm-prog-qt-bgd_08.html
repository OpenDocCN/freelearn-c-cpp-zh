<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Scripting"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Scripting</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>In this chapter, you will learn how to bring scripting facilities to your programs. You will gain knowledge of how to use a language based on JavaScript to implement the logic and details of your game without having to rebuild the main game engine. Although the environment we are going to focus on blends best with Qt applications, if you don't like JavaScript you will be given suggestions about other languages that you can use to make your games scriptable.</em></span></p></blockquote></div><div class="section" title="Why script?"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec117"/>Why script?</h1></div></div></div><p>You might ask <a id="id570" class="indexterm"/>yourself, why should I use any scripting language if I can implement everything I need in C++? There are a number of benefits to providing a scripting environment to your games. Most modern games really consist of two parts. One of them is the main game engine that implements the core of the game (data structures, processing algorithms, and the rendering layer) and exposes an API to the other component, which provides details, behavior patterns, and action flows for the game. This other component is usually written in a scripting language. The main benefit of this is that story designers can work independently from the engine developers and they don't have to rebuild the whole game just to modify some of its parameters or check whether the new quest fits well into the existing story. This makes the development much quicker compared to the monolithic approach. Another benefit is that this development opens the game to modding—skilled end users can extend or modify the game to provide some added value to the game. It's also a way to make additional money on the game by implementing extensions on it on top of the existing scripting API without having to redeploy the complete game binary to every player or to expose new scripting endpoints to boost the creativity of the modders even more. Finally, you can reuse the same game driver for other games and just replace the scripts to obtain a totally different product.</p><p>Qt provides two implementations of a JavaScript-based scripting environment. In this chapter, we will be focusing on Qt Script. In the docs, you can see that the module is marked as "deprecated"; however, it currently provides a richer API (albeit with slower execution) than the other implementation. After we describe Qt Script, we will have a brief look at the other implementation as well. We will not discuss the details of the JavaScript language itself, as there are many good books and websites available out there where you can learn JavaScript. Besides, the JavaScript syntax is very similar to that of C, and you shouldn't <a id="id571" class="indexterm"/>have any problems understanding the scripts that we use in this chapter even if you haven't seen any JavaScript code before.</p></div></div>
<div class="section" title="The basics of Qt Script"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec118"/>The basics of Qt Script</h1></div></div></div><p>To use Qt <a id="id572" class="indexterm"/>Script in your programs, you have to enable the script module for your projects by adding the <code class="literal">QT += script</code> line to the project file.</p><div class="section" title="Evaluating JavaScript expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec150"/>Evaluating JavaScript expressions</h2></div></div></div><p>C++ <a id="id573" class="indexterm"/>compilers do not understand JavaScript. Therefore, to execute any script, you need to have a running interpreter that will parse the script and evaluate it. In Qt, this is done with the <code class="literal">QScriptEngine</code> class. This is a Qt Script runtime that handles the execution of script code and manages all the resources related to scripts. It provides the <code class="literal">evaluate()</code> method, which can be used to execute JavaScript expressions. Let's look at a "Hello World" program in Qt Script:</p><div class="informalexample"><pre class="programlisting">#include &lt;QCoreApplication&gt;
#include &lt;QScriptEngine&gt;

int main(int argc, char **argv) {
  QCoreApplication app(argc, argv);
  QScriptEngine engine;
  engine.evaluate("print('Hello World!')");
  return 0;
}</pre></div><p>This program is very simple. First, it creates an application object that is required for the script environment to function properly, and then it just instantiates <code class="literal">QScriptEngine</code> and invokes evaluate to execute the script source given to it as a parameter. After building and running the program, you will see a well-known <code class="literal">Hello World!</code> printed to the console.</p><p>If you don't get any output, then this probably means that the script didn't get executed properly, possibly because of an error in the script's source code. To verify that, we can extend our simple program to check whether there were any problems with the execution of the script. For this, we can query the engine state with <code class="literal">hasUncaughtExceptions()</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;QCoreApplication&gt;
#include &lt;QScriptEngine&gt;
<span class="strong"><strong>#include &lt;QtDebug&gt;</strong></span>

int main(int argc, char **argv) {
  QCoreApplication app(argc, argv);
  QScriptEngine engine;
  engine.evaluate("print('Hello World!')");
<span class="strong"><strong>  if(engine.hasUncaughtException()) {</strong></span>
<span class="strong"><strong>    QScriptValue exception = engine.uncaughtException();</strong></span>
<span class="strong"><strong>    qDebug() &lt;&lt; exception.toString();</strong></span>
<span class="strong"><strong>  }</strong></span>
  return 0;
}</pre></div><p>The highlighted code checks whether there is an exception and if yes, it fetches the exception object. You can see that its type is <code class="literal">QScriptValue</code>. This is a special type that is used to exchange data between the script engine and the C++ world. It is somewhat similar to <code class="literal">QVariant</code> in the way that it is really a facade for a number of primitive types that the script engine uses internally. One of the types is the type holding errors. We can check whether a script value object is an error using its <code class="literal">isError()</code> method, but in this case, we don't do that since <code class="literal">uncaughtException()</code> is meant to return error objects. Instead, we immediately convert the error to a string representation and dump it to the console using <code class="literal">qDebug()</code>. For example, if you omit the closing single quote in the script source text and run the program, the following message will be displayed:</p><div class="informalexample"><pre class="programlisting">"SyntaxError: Parse error"</pre></div><p>
<code class="literal">QScriptEngine::evaluate()</code> also returns <code class="literal">QScriptValue</code>. This object represents the result of the <a id="id574" class="indexterm"/>evaluated script. You can make a script calculate some value for you that you can later use in your C++ code. For example, the script can calculate the amount of damage done to a creature when it is hit with a particular weapon. Modifying our code to use the result of the script is very simple. All that is required is to store the value returned by <code class="literal">evaluate()</code> and then it can be used elsewhere in the code:</p><div class="informalexample"><pre class="programlisting">QScriptValue result = engine.evaluate("(7+8)/2");
if(engine.hasUncaughtException()) {
  // ...
} else {
  qDebug() &lt;&lt; result.toString();
}</pre></div></div></div>
<div class="section" title="Time for action &#x2013; creating a Qt Script editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec119"/>Time for action – creating a Qt Script editor</h1></div></div></div><p>Let's do a <a id="id575" class="indexterm"/>simple exercise and create a graphical editor to write and execute scripts. Start by creating a new GUI project and implement a main window composed of two plain text edit widgets (<code class="literal">ui-&gt;codeEditor</code> and <code class="literal">ui-&gt;logWindow</code>) that are separated using a vertical splitter. One of the edit boxes will be used as an editor to input code and the other will be used as a console to display script results. Then, add a menu and toolbar to the window and create actions to open (<code class="literal">ui-&gt;actionOpen</code>) and save (<code class="literal">ui-&gt;actionSave</code>) the document, create a new document (<code class="literal">ui-&gt;actionNew</code>), execute the script (<code class="literal">ui-&gt;actionExecute</code>), and to quit the application (<code class="literal">ui-&gt;actionQuit</code>). Remember to add them to the menu and toolbar. As a result, you should receive a window similar to the one shown in <a id="id576" class="indexterm"/>the following screenshot:</p><div class="mediaobject"><img src="graphics/8874OS_08_01.jpg" alt="Time for action – creating a Qt Script editor"/></div><p>Connect the quit action to the <code class="literal">QApplication::quit()</code> slot. Then, create an <code class="literal">openDocument()</code> slot and connect it to the appropriate action. In the slot, use <code class="literal">QFileDialog::getOpenFileName()</code> to ask the user for a document path as follows:</p><div class="informalexample"><pre class="programlisting">void MainWindow::openDocument() {
  QString filePath = QFileDialog::getOpenFileName(this, "Open Document", QDir::homePath(), "JavaScript Documents (*.js)");
  if(filePath.isEmpty()) return;
  open(filePath);
}</pre></div><p>In a similar fashion, implement the <span class="strong"><strong>Save</strong></span> and <span class="strong"><strong>Save As</strong></span> action handlers. Lastly, create the <code class="literal">open(const QString &amp;filePath)</code> slot, make it read the document, and put its contents into the code editor:</p><div class="informalexample"><pre class="programlisting">void MainWindow::open(const QString &amp;filePath) {
  QFile file(filePath);
  if(!file.open(QFile::ReadOnly|QFile::Text)) {
      QMessageBox::critical(this, "Error", "Can't open file.");
      return;
  }
  setWindowFilePath(filePath);
  ui-&gt;codeEditor-&gt;setPlainText(QTextStream(&amp;file).readAll());
  ui-&gt;logWindow-&gt;clear();
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip67"/>Tip</h3><p>The <code class="literal">windowFilePath</code> property of <code class="literal">QWidget</code> can be used to associate a file with a window. You can then use it in actions related to using the file—when saving a document, you can check whether this property is empty and ask the user to provide a filename. Then, you can reset this property when creating a new document or when the user provides a new path for the document.</p></div></div><p>At this point, you <a id="id577" class="indexterm"/>should be able to run the program and use it to create scripts and save and reload them in the editor.</p><p>Now, to execute the scripts, add a <code class="literal">QScriptEngine m_engine</code> member variable to the window class. Create a new slot, call it <code class="literal">run</code>, and connect it to the execute action. Put the following code in the body of the slot:</p><div class="informalexample"><pre class="programlisting">void Main Window::run() {
   ui-&gt;logWindow-&gt;clear();
   QScriptValue result
     = m_engine.evaluate(scriptSourceCode, windowFilePath());
   if(m_engine.hasUncaughtException()) {
     QScriptValue exception = m_engine.uncaughtException();
     QTextCursor cursor = ui-&gt;logWindow-&gt;textCursor();
     QTextCharFormat errFormat;
     errFormat.setForeground(Qt::red);
     cursor.insertText(
       QString("Exception at line %1:")
       .arg(m_engine.uncaughtExceptionLineNumber()),
       errFormat
     );
     cursor.insertText(exception.toString(), errFormat);
     QStringList trace = m_engine.uncaughtExceptionBacktrace();
     errFormat.setForeground(Qt::darkRed);
     for(int i = 0; i &lt; trace.size(); ++i) {
       const QString &amp; traceFrame = trace.at(i);
       cursor.insertBlock();
       cursor.insertText(QString("#%1: %2")
         .arg(i).arg(traceFrame), errFormat);
     }
   } else {
     QTextCursor cursor = ui-&gt;logWindow-&gt;textCursor();
     QTextCharFormat resultFormat;
     resultFormat.setForeground(Qt::blue);
     cursor.insertText(result.toString(), resultFormat);
   }
}</pre></div><p>Build and run the program. To do so, enter the following script in the editor:</p><div class="informalexample"><pre class="programlisting">function factorial(n) {
  if( n &lt; 0 ) return undefined
  if( n == 0 ) return 1
  return n*factorial(n-1)
}

factorial(7)</pre></div><p>Save the script in a file called <code class="literal">factorial.js</code> and then run it. You should get an output as shown in the <a id="id578" class="indexterm"/>following screenshot:</p><div class="mediaobject"><img src="graphics/8874OS_08_02.jpg" alt="Time for action – creating a Qt Script editor"/></div><p>Next, replace the script with the following one:</p><div class="informalexample"><pre class="programlisting">function factorial(n) {
  return N
}

factorial(7)</pre></div><p>Running the script should yield the following result:</p><div class="mediaobject"><img src="graphics/8874OS_08_03.jpg" alt="Time for action – creating a Qt Script editor"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec151"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>The <code class="literal">run()</code> method clears the log window and evaluates the script using the method that we learned earlier in this chapter. If the evaluation is successful, it prints the result in the log window, which is what we see in the first screenshot shown in the previous section.</p><p>In the second attempt, we made an error in the script using a nonexistent variable. Evaluating such code results in an exception. In addition to reporting the actual error, we also use <code class="literal">uncaughtExceptionLineNumber()</code> to report the line that caused the problem. Next, we call the engine's <code class="literal">uncaughtExceptionBacktrace()</code> method, which returns a list of strings containing the backtrace (a stack of function calls) of the problem, which we also print <a id="id579" class="indexterm"/>on the console.</p><p>Let's try another script. The following code defines the local variable <code class="literal">fun</code>, which is assigned an anonymous function that returns a number:</p><div class="informalexample"><pre class="programlisting">var fun = function() { return 42 }</pre></div><p>You can then call <code class="literal">fun()</code> like a regular function as follows:</p><div class="mediaobject"><img src="graphics/8874OS_08_04.jpg" alt="What just happened?"/></div><p>Now, let's look at <a id="id580" class="indexterm"/>what happens if we delete the definition of <code class="literal">fun</code> from the script, but still keep the invocation:</p><div class="mediaobject"><img src="graphics/8874OS_08_05.jpg" alt="What just happened?"/></div><p>We still get the same result even though we didn't define what fun means! This is because the <code class="literal">QScriptEngine</code> object keeps its state across <code class="literal">evaluate()</code> invocations. If you define a variable in a script, it is kept in the current context of the engine. The next time <code class="literal">evaluate()</code> is called, it executes the script in the same context as before; therefore, all variables defined earlier are still valid. Sometimes, this is a desired behavior; however, a malicious script can wreck the context, which can cause trouble for subsequent evaluations in the engine. Therefore, it is usually better to make sure that the engine is left in a clean state after a script is done with the execution.</p></div></div>
<div class="section" title="Time for action &#x2013; sandboxed script evaluation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec120"/>Time for action – sandboxed script evaluation</h1></div></div></div><p>The next <a id="id581" class="indexterm"/>task for us is to modify our script editor so that it cleans up after the execution of each script. As was said, each script is executed in the current context of the engine, so the task of solving the problem boils down to making sure that each script executes in a separate context. Incorporate the following code in the <code class="literal">run()</code> method:</p><div class="informalexample"><pre class="programlisting">void MainWindow::run() {
    ui-&gt;logWindow-&gt;clear();
    QString scriptSourceCode = ui-&gt;codeEditor-&gt;toPlainText();
<span class="strong"><strong>    m_engine.pushContext();</strong></span>
 QScriptValue result = m_engine.evaluate
  (scriptSourceCode, windowFilePath());
    if(m_engine.hasUncaughtException()) {
        // …
    }
<span class="strong"><strong>    m_engine.popContext();</strong></span>
}</pre></div><p>Run the program and repeat the last test to see that <code class="literal">fun</code> no longer persists across executions.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec152"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>When a function is called, a new execution context is pushed to the top of the stack. When the engine tries to resolve an object, it first looks for the object in the topmost context (which is the context of the function call). If it is not found, the engine looks into the next context on the stack and then the next until it finds the object or reaches the bottom of the stack. When the function returns, the context is popped from the stack and all variables defined there are destroyed. You can see how this works using the following script:</p><div class="informalexample"><pre class="programlisting">var foo = 7
function bar() { return foo }
bar()</pre></div><p>When <code class="literal">bar</code> is called, a new context is added to the stack. The script requests for the <code class="literal">foo</code> object, which is not present in the current context, so the engine looks into the surrounding context and finds a definition of <code class="literal">foo</code>. In our code, we follow this behavior by explicitly creating a new context using <code class="literal">pushContext()</code> and then removing it with <code class="literal">popContext()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip68"/>Tip</h3><p>You can retrieve the current context object with <code class="literal">currentContext()</code>.</p></div></div><p>The context has two important objects associated with it: the <code class="literal">activation</code> object and the <code class="literal">this</code> object. The former defines an object where all local variables are stored as the object's properties. If you set any properties on the object before invoking a script, they will be directly available to the script:</p><div class="informalexample"><pre class="programlisting">QScriptContext *context = engine.pushContext();
QScriptValue activationObject = context-&gt;activationObject();
activationObject.setProperty("foo", "bar");
engine.evaluate("print(foo)");</pre></div><p>The <code class="literal">this</code> object works in a similar fashion—it determines the object to be used when the script refers to an <a id="id582" class="indexterm"/>object called <code class="literal">this</code>. Any properties defined in C++ are accessible from the script and the other way round:</p><div class="informalexample"><pre class="programlisting">QScriptContext *context = engine.pushContext();
QScriptValue thisObject = context-&gt;thisObject();
thisObject.setProperty("foo", "bar");
engine.evaluate("print(this.foo)");</pre></div></div></div>
<div class="section" title="Integrating Qt and Qt Script"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec121"/>Integrating Qt and Qt Script</h1></div></div></div><p>So far, we <a id="id583" class="indexterm"/>were only evaluating some standalone scripts that could make use of the features built in JavaScript. Now, it is time to learn to use data from your programs in the scripts.</p><p>This is done by exposing different kinds of entities to and from scripts.</p><div class="section" title="Exposing objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec153"/>Exposing objects</h2></div></div></div><p>The simplest <a id="id584" class="indexterm"/>way to expose data to Qt Script is to take advantage of Qt's meta-object system. Qt Script is able to inspect <code class="literal">QObject</code> instances and detect their properties and methods. To use them in scripts, the object has to be visible to the script execution context. The easiest way to make this happen is to add it to the engine's global object or to some context's activation object. As you remember, all data between the script engine and C++ is exchanged using the <code class="literal">QScriptValue</code> class, so first we have to obtain a script value handle for the C++ object:</p><div class="informalexample"><pre class="programlisting">QScriptEngine engine;
QPushButton *button = new QPushButton("Button");
// …
QScriptValue scriptButton = engine.newQObject(button);
engine.globalObject().setProperty("pushButton", scriptButton);</pre></div><p>
<code class="literal">QScriptEngine::newQObject()</code> creates a script wrapper for an existing <code class="literal">QObject</code> instance. We then set the wrapper as a property of the global object called <code class="literal">pushButton</code>. This makes the button available in the global context of the engine as a JavaScript object. All the properties defined with <code class="literal">Q_PROPERTY</code> are available as properties of the object and every slot is accessible as a method of that object. Using this approach, you can share an existing object between the C++ and JavaScript worlds:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char **argv) {
  QApplication app(argc, argv);
  QScriptEngine engine;
  QPushButton button;
  engine.globalObject().setProperty
  ("pushButton", engine.newQObject(&amp;button));
  QString script = "pushButton.text = 'My Scripted Button'\n"+
                   "pushButton.checkable = true\n" +
                   "pushButton.setChecked(true)"
  engine.evaluate(script);
  return app.exec();
}</pre></div><p>There are cases when you want to provide a rich interface for a class to manipulate it from within C++ easily, but to have a strict control over what can be done using scripting, you want to prevent scripters from using some of the properties or methods of the class.</p><p>For methods, this is quite easy—just don't make them slots. Remember that you can still use them as slots if you use the <code class="literal">connect()</code> variant, which takes a function pointer as an argument.</p><p>For properties, you <a id="id585" class="indexterm"/>can mark a property as accessible or inaccessible from scripts using the <code class="literal">SCRIPTABLE</code> keyword in the <code class="literal">Q_PROPERTY</code> declaration. By default, all properties are scriptable, but you can forbid their exposure to scripts by setting <code class="literal">SCRIPTABLE</code> to <code class="literal">false</code> as shown in the following example:</p><div class="informalexample"><pre class="programlisting">Q_PROPERTY(QString internalName READ internalName SCRIPTABLE false)</pre></div></div></div>
<div class="section" title="Time for action &#x2013; employing scripting for npc AI"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec122"/>Time for action – employing scripting for npc AI</h1></div></div></div><p>Let's <a id="id586" class="indexterm"/>implement a script serving as <span class="strong"><strong>artificial </strong></span><a id="id587" class="indexterm"/>
<span class="strong"><strong>intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) for a nonplayer character in a simple Dungeons &amp; Dragons game. The engine will periodically execute the script, exposing two objects to it—the creature and the player. The script will be able to query the properties of the player and invoke functions on the creature.</p><p>Let's create a new project. We'll start by implementing the C++ class for creatures in our game world. Since both the NPC and player are living entities, we can have a common base class for them. In <a class="link" href="ch04.html" title="Chapter 4. Qt Core Essentials">Chapter 4</a>, <span class="emphasis"><em>Qt Core Essentials</em></span>, we already had a data structure for players, so let's use that as a base by equipping our entities with similar attributes. Implement <code class="literal">LivingEntity</code> as a subclass of <code class="literal">QObject</code> with the following properties:</p><div class="informalexample"><pre class="programlisting">Q_PROPERTY(QString name     READ name        NOTIFY nameChanged)
Q_PROPERTY(char direction   READ direction   NOTIFY directionChanged)
Q_PROPERTY(QPoint position  READ position    NOTIFY positionChanged)
Q_PROPERTY(int hp           READ hp          NOTIFY hpChanged)
Q_PROPERTY(int maxHp        READ maxHp       NOTIFY maxHpChanged)
Q_PROPERTY(int dex          READ dex         NOTIFY dexChanged)
Q_PROPERTY(int baseAttack   READ baseAttack  NOTIFY baseAttackChanged)
Q_PROPERTY(int armor        READ armor       NOTIFY armorChanged)</pre></div><p>You can see that this interface is read only—you cannot modify any of the properties using the <code class="literal">LivingEntity</code> class. Of course, we still need methods to change those values; so, implement <a id="id588" class="indexterm"/>them in the <code class="literal">public</code> interface of the class:</p><div class="informalexample"><pre class="programlisting">public:
  void setName(const QString &amp;newName);
  void setDirection(char newDirection);
  void setPosition(const QPoint &amp;newPosition);
  void setHp(int newHp);
  void setMaxHp(int newMaxHp);
  void setBaseAttack(int newBaseAttack);
  void setArmor(int newArmor);
  void setDex(int newDex);</pre></div><p>When you implement these methods, be sure to emit proper signals when you modify property values. Let's add more methods that correspond to the actions that a creature can take:</p><div class="informalexample"><pre class="programlisting">public:
  void attack(LivingEntity *enemy);
  void dodge();
  void wait();
  bool moveForward();
  bool moveBackward();
  void turnLeft();
  void turnRight();</pre></div><p>The last four methods are simple to implement; for the first three methods, use the following code:</p><div class="informalexample"><pre class="programlisting">void LivingEntity::wait() {  if(hp() &lt; maxHp()) setHp(hp()+1); }
void LivingEntity::dodge() {
    m_armorBonus += dex(); 
    emit armorChanged(armor()); // m_baseArmor + m_armorBonus
}
void LivingEntity::attack(LivingEntity *enemy) {
  if (baseAttack() &lt;=0) return;
  int damage = qrand() % baseAttack();
  int enemyArmor = enemy-&gt;armor();
  int inflictedDamage = qMax(0, damage-enemyArmor);
  enemy-&gt;setHp(qMax(0, enemy-&gt;hp() - inflictedDamage));
}</pre></div><p>Essentially, if the creature chooses to wait, it regains one hit point. If it dodges, this increases its chances to avoid damage when attacked. If it attacks another creature, this inflicts damage based on its own attack and the opponent's defensive score.</p><p>The next step is to implement the subclasses of <code class="literal">LivingEntity</code> so that we can manipulate the objects from Qt Script. To do this, implement the <code class="literal">NPC</code> class as follows:</p><div class="informalexample"><pre class="programlisting">class NPC : public LivingEntity {
  Q_OBJECT
public:
  NPC(QObject *parent = 0) : LivingEntity(parent) {}
public slots:
  void attack(LivingEntity *enemy) { LivingEntity::attack(enemy); }
  void dodge() { LivingEntity::dodge(); }
  void wait() { LivingEntity::wait(); }
  bool moveForward() { return LivingEntity::moveForward(); }
  bool moveBackward() { return LivingEntity::moveBackward(); }
  void turnLeft() { LivingEntity::turnLeft(); }
  void turnRight() { LivingEntity::turnRight(); }
};</pre></div><p>What <a id="id589" class="indexterm"/>remains is to create a simple game engine to test our work. To do this, start by adding a <code class="literal">reset()</code> method to <code class="literal">LivingEntity</code> that will reset the armor bonus before every turn. Then, implement the <code class="literal">GameEngine</code> class:</p><div class="informalexample"><pre class="programlisting">class GameEngine : public QScriptEngine {
public:
  GameEngine(QObject *parent = 0) : QScriptEngine(parent) {
    m_timerId = 0;
    m_player = new LivingCreature(this);
    m_creature = new NPC(this);
    QScriptValue go = globalObject();
    go.setProperty("player", newQObject(m_player));
    go.setProperty("self", newQObject(m_creature));
  }
  LivingCreature *player() const {return m_player; }
  LivingCreature *npc() const { return m_creature; }
  void start(const QString &amp;fileName) {
    if(m_timerId) killTimer(m_timerId);
    m_npcProgram = readScriptFromFile(fileName);
    m_timerId = startTimer(1000);
  }
protected:
  QScriptProgram readScriptFromFile(const QString &amp;fileName) const {
    QFile file(fileName);
    if(!file.open(QFile::ReadOnly|QFile::Text)) return QScriptProgram();
    return QScriptProgram(file.readAll(), fileName);
  }
  void timerEvent(QTimerEvent *te) {
    if(te-&gt;timerId() != m_timerId) return;
    m_creature-&gt;reset();
    m_player-&gt;reset();
    evaluate(m_npcProgram);
  }
private:
  LivingEntity *m_player;
  NPC *m_creature;
  QScriptProgram m_npcProgram;
  int m_timerId;
};</pre></div><p>Finally, write the main function:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char **argv) {
  QCoreApplication app(argc, argv);
  GameEngine engine;
  
  engine.player()-&gt;setMaxHp(50);
  engine.player()-&gt;setHp(50);
  engine.player()-&gt;setDex(10);
  engine.player()-&gt;setBaseAttack(12);
  engine.player()-&gt;setArmor(3);

  engine.npc()-&gt;setMaxHp(100);
  engine.npc()-&gt;setHp(100);
  engine.npc()-&gt;setDex(4);
  engine.npc()-&gt;setBaseAttack(2);
  engine.npc()-&gt;setArmor(1);

  engine.start(argv[1]);
  return app.exec();
}</pre></div><p>You can test the <a id="id590" class="indexterm"/>application using the following script:</p><div class="informalexample"><pre class="programlisting">print("Player HP:", player.hp)
print("Creature HP:", self.hp)
var val = Math.random() * 100
if(val &lt; 50) {
  print("Attack!")
  self.attack(player) 
} else {
  print("Dodge!");
  self.dodge();
}</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec154"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created two classes of objects: <code class="literal">LivingCreature</code>, which is the basic API to read data about a creature, and NPC, which provides a richer API. We obtained this effect by redeclaring the existing functions as slots. This is possible even when the methods are not virtual, as when slots are executed using Qt's meta-object system, they are always treated as if they were virtual methods—a declaration in the derived class always shadows the declaration in the parent class. Having the two classes, we exposed their instances to the scripting environment, and we use a timer to call a user-defined script every second. Of course, this is a very simple approach to scripting, which can easily be abused if the user calls multiple action functions in the script, for example, by calling <code class="literal">attack()</code> many times in one script, the creature can perform multiple strikes on the opponent. Speaking of <code class="literal">attack()</code>, note that it takes a <code class="literal">LivingCreature</code> pointer as its parameter. In the script, we fed it with the player object that corresponds to the needed type in C++. The conversion is done by Qt Script automatically. Therefore, you can define methods by taking <code class="literal">QObject</code> pointers and using them with <code class="literal">QObject</code> instances that are exposed to scripts. In a similar fashion, you can define functions by taking <code class="literal">QVariant</code> or <code class="literal">QScriptValue</code> and passing any value to them in <a id="id591" class="indexterm"/>the script. If the script engine is able to convert the given value to the requested type, it will do so.</p></div><div class="section" title="Have a go hero – extending the Dungeons &amp; Dragons game"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec155"/>Have a go hero – extending the Dungeons &amp; Dragons game</h2></div></div></div><p>Here is a <a id="id592" class="indexterm"/>number of ideas that can be used to extend our small game. The first is to add a script execution for the player as well so that it tries to defend against the creature. For that, you'll need to expose the creature's data using the <code class="literal">LivingCreature</code> API so that it is read only and exposes the player using a read-write interface. There are many ways to obtain it; the easiest is to provide two public <code class="literal">QObject</code> interfaces that operate on a shared pointer as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/8874OS_08_06.jpg" alt="Have a go hero – extending the Dungeons &amp; Dragons game"/></div><p>The API already contains methods to move creatures. You can extend the fighting rules to take into consideration the distance between opponents and their relative orientation (for example, striking from behind usually yields more damage than when standing face-to-face with the enemy). You can even introduce ranged combat. Extend the <code class="literal">LivingCreature</code> interface with the properties and methods that manipulate the creature's inventory. Allow the creature to change its active weapon.</p><p>The final <a id="id593" class="indexterm"/>modification that you can apply is to prevent cheating, using the mechanism described earlier. Instead of executing an action immediately, mark which action the script has chosen (along with its parameters) and only execute that action after the script finishes executing, for example, like this:</p><div class="informalexample"><pre class="programlisting">void timerEvent(QTimerEvent *te) {
  if(te-&gt;timerId() != m_timerId) return;
  m_creature.reset();
  m_player.reset();
  evaluate(m_npcProgram);
  evaluate(m_playerProgram);
<span class="strong"><strong>  m_creature.executeAction();</strong></span>
<span class="strong"><strong>  m_player.executeAction();</strong></span>
}</pre></div><p>Another approach to this would be to assign action points to each creature's every turn and allow the creature to spend them on different actions. If there are not enough points left to execute an action, the script is notified about this and the action fails.</p></div><div class="section" title="Exposing functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec156"/>Exposing functions</h2></div></div></div><p>Until now, we have <a id="id594" class="indexterm"/>been exporting objects to scripts and calling their properties and methods. However, there is also a way to call standalone C++ functions from scripts as well as call functions written in JavaScript from within C++ code. Let's have a look at how this works.</p><div class="section" title="Exposing C++ functions to scripts"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec47"/>Exposing C++ functions to scripts</h3></div></div></div><p>You can <a id="id595" class="indexterm"/>expose a standalone function to Qt Script with <a id="id596" class="indexterm"/>the help of the <code class="literal">QScriptEngine::newFunction()</code> call. It returns <code class="literal">QScriptValue</code> as any function in JavaScript, is also an object, and can be represented by <code class="literal">QScriptValue</code>. In C++, if a function accepts three parameters, you have to pass exactly three parameters when calling it. In JavaScript, this is different—you can always pass any number of parameters to a function, and it is the function's responsibility to do a proper argument validation. Therefore, the actual function that is exported should be wrapped in another function that will do what JavaScript expects from it before calling the actual function. The wrapper function needs to have an interface that is compatible with what <code class="literal">newFunction()</code> expects. It should take two parameters: the script context and the script engine, and it should return <code class="literal">QScriptValue</code>. The <code class="literal">context</code> contains all the information regarding the parameters of the function, including their count. Let's try wrapping a function that takes two integers and returns their sum:</p><div class="informalexample"><pre class="programlisting">int sum(int a, int b) { return a+b; }

QScriptValue sum_wrapper(QScriptContext *context, QScriptEngine *engine) {
  if(context-&gt;argumentCount() != 2) return engine-&gt;undefinedValue();
  QScriptValue arg0 = context-&gt;argument(0);
  QScriptValue arg1 = context-&gt;argument(1);
  if(!arg0.isNumber() || !arg1.isNumber())
  return engine-&gt;undefinedValue();
  return sum(arg0.toNumber()+arg1.toNumber());
}</pre></div><p>Now that we have <a id="id597" class="indexterm"/>the wrapper, we can create a function object <a id="id598" class="indexterm"/>for it and export it to the scripting environment in exactly the same way as we export regular objects—by making it a property of the script's global object:</p><div class="informalexample"><pre class="programlisting">QScriptValue sumFunction = engine.newFunction(sum_wrapper, 2);
engine.globalObject().setProperty("sum", sumFunction);</pre></div><p>The second argument to <code class="literal">newFunction()</code> defines how many arguments the function expects and is retrievable with the function object's length property. This is just for your information, as the caller can pass as many arguments as he/she wants. Try evaluating the following script after exporting the sum function:</p><div class="informalexample"><pre class="programlisting">print("Arguments expected:", sum.length)
print(sum(1,2,3) // sum returns Undefined</pre></div><p>We can make use of such behavior and extend the functionality of our <code class="literal">sum</code> function by making it return a sum of all the parameters passed to it:</p><div class="informalexample"><pre class="programlisting">QScriptValue sum_wrapper(QScriptContext *context, 
  QScriptEngine *engine) {
  int result = 0;
  for(int i=0; i&lt;context-&gt;argumentCount();++i) {
    QScriptValue arg = context-&gt;argument(i);
    result = sum(result, arg.toNumber());
  }
  return result;
}</pre></div><p>Now, you can call the sum with any number of arguments:</p><div class="informalexample"><pre class="programlisting">print(sum());
print(sum(1,2));
print(sum(1,2,3));</pre></div><p>This brings us to an interesting question: can the function have different functionality depending on how many parameters you pass to it? The answer is positive; you can implement the function in any way you want, with the whole power of C++ at hand. There is a specific case for JavaScript when such behavior makes particular sense. This is when the function is supposed to work as a getter and setter for a property. Getters and setters are functions that are called when the script wants to retrieve or set the value of a property in some object. By attaching getters and setters to objects, you can control where the value is stored (if at all) and how it is retrieved. This opens the possibility of adding properties to the <a id="id599" class="indexterm"/>exported Qt objects that have not been declared with the <code class="literal">Q_PROPERTY</code> macro:</p><div class="informalexample"><pre class="programlisting">class CustomObject : public QObject {
  Q_OBJECT
public:
  CustomObject(QObject *parent = 0) : QObject(parent) { m_value = 0; }
  int value() const { return m_value; }
  void setValue(int v) { m_value = v; }
private:
  int m_value;
};

QScriptValue getSetValue(QScriptContext *, QScriptEngine*); // function prototype

int main(int argc, char **argv) {
  QCoreApplication app(argc, argv);
  QScriptEngine engine;
  CustomObject object;
  QScriptValue object_value = engine.newQObject(&amp;object);
  QScriptValue getSetValue_fun = engine.newFunction(getSetValue);
  object_value.setProperty("value", getSetValue_fun,
    QScriptValue::PropertyGetter|QScriptValue::PropertySetter);
  engine.globalObject().setProperty("customObject", object_value);
  engine.evaluate("customObject.value = 42");
  qDebug() &lt;&lt; object.value();
  return 0;
}</pre></div><p>Let's analyze this <a id="id600" class="indexterm"/>code; here, we expose an instance of <code class="literal">CustomObject</code> to the script engine in a standard way. We also set the object's value property to a function, passing an additional value to <code class="literal">setProperty()</code>, which contains a set of flags that tell the scripting environment how it should treat the property. In this case, we tell it that the passed value should be used as a getter and setter for the property. Let's see how the function itself is implemented:</p><div class="informalexample"><pre class="programlisting">QScriptValue getSetValue(QScriptContext *context, QScriptEngine *engine) {
  QScriptValue object = context-&gt;thisObject();
  CustomObject *customObject = qobject_cast&lt;CustomObject*&gt;(object.toQObject());
  if(!customObject) return engine-&gt;undefinedValue();
  if(context-&gt;argumentCount() == 1) {
    // property setter
    customObject-&gt;setValue(context-&gt;argument(0).toNumber());
    return engine-&gt;undefinedValue();
  } else {
    // property getter
    return customObject-&gt;value();
  }
}</pre></div><p>First, we ask the function the context for the value representing the object that the function is called on. Then, we extract a <code class="literal">CustomObject</code> pointer from it using <code class="literal">qobject_cast</code>. Next, we check the number of arguments to the function call. In the case of a setter, the function is passed one parameter—the value to be set to the property. In such a situation, we use a C++ method of the object to apply that value to the object. Otherwise, (no arguments are <a id="id601" class="indexterm"/>passed) the function is used as a getter and we <a id="id602" class="indexterm"/>return the value after fetching it with the C++ method.</p></div><div class="section" title="Exposing script functions to C++"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec48"/>Exposing script functions to C++</h3></div></div></div><p>In the same <a id="id603" class="indexterm"/>way as C++ functions are exported to Qt <a id="id604" class="indexterm"/>Script with the use of <code class="literal">QScriptValue</code>, JavaScript functions can be imported to C++. You can ask for a script value representing a function like any other property. The following code asks the engine for the <code class="literal">Math.pow()</code> function, which performs the power operation on its arguments:</p><div class="informalexample"><pre class="programlisting">QScriptValue powFunction = engine.globalObject().property("Math").property("pow");</pre></div><p>Having <code class="literal">QScriptValue</code> represent a function, you can invoke it using the value's <code class="literal">call()</code> method and pass any parameters as a list of script values:</p><div class="informalexample"><pre class="programlisting">QScriptValueList arguments = { QScriptValue(2), QScriptValue(10) };
QScriptValue result = powFunction.call(QScriptValue(), arguments);
qDebug() &lt;&lt; result.toNumber(); // yields 1024</pre></div><p>The first parameter to <code class="literal">call()</code> is the value that is to be used as the <code class="literal">this</code> object of the function. In this particular case, we pass an empty object since the function is standalone—it does not make any use of its environment. There are situations, however, when you will want to set an existing object here, for example, to allow a function to directly access the existing properties or define new properties of an object.</p><p>Let's use the newly learned functionality to improve our Dungeons &amp; Dragons game in order to use a richer set of scripting functionality that is based on JavaScript functions and properties. The script used will contain a set of functions written in JavaScript that are going to be <a id="id605" class="indexterm"/>stored in the program and called in various situations. We'll be focusing here only on the scripting part. You will surely be able <a id="id606" class="indexterm"/>to fill in the C++ gaps yourself.</p></div></div></div>
<div class="section" title="Time for action &#x2013; storing the script"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec123"/>Time for action – storing the script</h1></div></div></div><p>The first task <a id="id607" class="indexterm"/>is to read the script, extract the needed functions from it, and store them in a safe place. Then, load the project for the game and add a new class with the following code:</p><div class="informalexample"><pre class="programlisting">class AIScript {
public:
  QScriptProgram read(const QString &amp;fileName);
  bool evaluate(const QScriptProgram &amp;program, QScriptEngine *engine);
  QScriptValue initFunction;
  QScriptValue heartbeatFunction;
  QScriptValue defendFunction;
};</pre></div><p>The reading method can have the same content as the original <code class="literal">readScriptFromFile</code> method. The evaluate method looks as follows:</p><div class="informalexample"><pre class="programlisting">bool AIScript::evaluate(const QScriptProgram &amp;program, QScriptEngine *engine) {
  QScriptContext *context = engine-&gt;pushContext();
  QScriptValue activationObject;
  QScriptValue result = engine-&gt;evaluate(program);
  activationObject = context-&gt;activationObject();
  if(!result.isError()) {
    initFunction = activationObject.property("init");
    heartbeatFunction = activationObject.property("heartbeat");
    defendFunction = activationObject.property("defend");
  }
  engine-&gt;popContext();
  return !result.isError();
}</pre></div><p>Modify the <code class="literal">GameEngine</code> class to make use of the new code (remember to add the <code class="literal">m_ai</code> class member):</p><div class="informalexample"><pre class="programlisting">  void start(const QString &amp;fileName) {
    m_ai = AIScript();
    QScriptProgram program = m_ai.read(fileName);
    m_ai.evaluate(program, this);
    qDebug() &lt;&lt; m_ai.initFunction.toString();
    qDebug() &lt;&lt; m_ai.heartbeatFunction.toString();
    qDebug() &lt;&lt; m_ai.defendFunction.toString();
  }</pre></div><p>Run the program by feeding it the following script:</p><div class="informalexample"><pre class="programlisting">function init() {
  print("This is init function")
}

function heartbeat() {
  print("This is heartbeat function")
}

function defend() {
  print("This is defend function")
}</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec157"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>The <code class="literal">AIScript</code> object contains information about the AI for a single entity. The <code class="literal">start()</code> method now loads a script from the file and evaluates it. The script is expected to define a number of functions that are <a id="id608" class="indexterm"/>then retrieved from the activation object and stored in the <code class="literal">AIScript</code> object.</p></div></div>
<div class="section" title="Time for action &#x2013; providing an initialization function"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec124"/>Time for action – providing an initialization function</h1></div></div></div><p>The task for <a id="id609" class="indexterm"/>this exercise is to make it possible for the <a id="id610" class="indexterm"/>AI to initialize itself by invoking the <code class="literal">init()</code> function. Let's get right down to business. Extend the <code class="literal">AIScript</code> structure with yet another field:</p><div class="informalexample"><pre class="programlisting">QScriptValue m_thisObject;</pre></div><p>This object will represent the AI itself. The script will be able to store data or define functions in it. Add the following code to the class as well:</p><div class="informalexample"><pre class="programlisting">void AIScript::initialize(QScriptEngine *engine) {
  m_thisObject = engine-&gt;newObject();
  engine-&gt;pushContext();
  initFunction.call(m_thisObject);
  engine-&gt;popContext();
}</pre></div><p>Add a call to <code class="literal">initialize()</code> at the end of <code class="literal">start()</code>:</p><div class="informalexample"><pre class="programlisting">  void start(const QString &amp;fileName) {
    m_ai = AIScript();
    QScriptProgram program = m_ai.read(fileName);
    evaluate(program, this);
    m_ai.initialize(this);
  }</pre></div><p>Now, run the <a id="id611" class="indexterm"/>program using the following <a id="id612" class="indexterm"/>
<code class="literal">init()</code> function:</p><div class="informalexample"><pre class="programlisting">function init() {
  print("This is init function")
  this.distance = function(p1, p2) {
    // Manhattan distance
    return Math.abs(p1.x-p2.x)+Math.abs(p1.y-p2.y)
  }
  this.actionHistory = []
}</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec158"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In initialize, we prepare the script object with an empty JavaScript object and we call the function stored in <code class="literal">initFunction</code>, passing the script object as this. The function prints a debug statement and defines two properties in this object—one is a function to calculate the Manhattan distance and the other is an empty array where we will store a history of actions that the AI has taken.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip69"/>Tip</h3><p>Manhattan distance is a metric to calculate the distance between objects; this is much faster to calculate than the real Euclidean distance. It is based on the assumption that when traversing a large city with a grid of buildings, one can only follow streets that go along those buildings and take 90 degree turns. The Manhattan distance between positions is then the number of crossings one has to walk through to get from the source to the destination. In C++ and Qt, you can compute this distance easily using the <code class="literal">manhattanLength()</code> method in the <code class="literal">QPoint</code> class.</p></div></div></div></div>
<div class="section" title="Time for action &#x2013; implementing the heartbeat event"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec125"/>Time for action – implementing the heartbeat event</h1></div></div></div><p>The <a id="id613" class="indexterm"/>heart of AI is the heartbeat function that is executed at equal intervals of time to allow the AI to decide about the actions of the object. The script that is executed will have access to the creature that it operates on as well as its environment. It can also use anything that it defines in the <code class="literal">this</code> object. Now, add a heartbeat function to <code class="literal">AIScript</code>:</p><div class="informalexample"><pre class="programlisting">void AIScript::heartbeat(QScriptEngine *engine, QObject *personObject, QObject *otherObject) {
  QScriptValueList params;
  params &lt;&lt; engine-&gt;newQObject(personObject);
  m_thisObject.setProperty("enemy", engine-&gt;newQObject(otherObject));
  heartbeatFunction.call(m_thisObject, params);
  m_thisObject.setProperty("enemy", QScriptValue::UndefinedValue);
}</pre></div><p>Bring the timer back, set it to <code class="literal">start()</code>, and also enable the running heartbeat functionality from within the timer event:</p><div class="informalexample"><pre class="programlisting">void timerEvent(QTimerEvent *te) {
    if(te-&gt;timerId() != m_timerId) return;
    m_creature-&gt;reset();
    m_player-&gt;reset();
    m_ai.heartbeat(this, m_creature, m_player);
}</pre></div><p>Run the <a id="id614" class="indexterm"/>program, giving it the following <code class="literal">heartbeat</code> function:</p><div class="informalexample"><pre class="programlisting">function heartbeat(person) {
  person.attack(this.enemy)
  this.actionHistory.push("ATTACK")
}</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec159"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In <code class="literal">heartbeat</code>, we proceed in similar way as with <code class="literal">init</code>, but here, we pass the creature that the AI works on as a parameter of the function and we set the other entity as the enemy property of the <code class="literal">this</code> object, which makes it accessible to the function. After the call we remove the enemy property from the this object. The function itself performs an attack on the enemy and pushes an entry to the script object history. Unlike a direct invocation of evaluate when making a function call we don't have to push and pop an execution context as it is done for us automatically during <code class="literal">QScriptValue::call</code>.</p></div><div class="section" title="Have a go hero – defending against attacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec160"/>Have a go hero – defending against attacks</h2></div></div></div><p>You may <a id="id615" class="indexterm"/>have noticed that we left out the defend script. Try extending the game by calling a script whenever the subject is attacked by the opponent. In the script, allow the creature to take different defensive stances, such as evading, blocking, or parrying attacks. Make each action have a different influence on the outcome of the strike. Also, apply all the modifications that you made to the original game. Try expanding on the code that was already written by providing additional hooks where scripts are run and adding new actions and objects. How about adding more enemies to the game? What about organizing a contest for the best AI algorithm?</p></div><div class="section" title="Using signals and slots in scripts"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec161"/>Using signals and slots in scripts</h2></div></div></div><p>Qt Script also <a id="id616" class="indexterm"/>offers the capability to use signals and <a id="id617" class="indexterm"/>slots. The slot can be either a C++ method or a JavaScript function. The connection can be made either in C++ or in the script.</p><p>First, let's see how to establish a connection within a script. When a <code class="literal">QObject</code> instance is exposed to a script, the object's signals become the properties of the wrapping object. These properties have a <code class="literal">connect</code> method that accepts a function object that is to be called when the signal is emitted. The receiver can be a regular slot or a JavaScript function. To connect the <code class="literal">clicked()</code> signal of an object called <code class="literal">button</code> to a <code class="literal">clear()</code> slot of another object called <code class="literal">lineEdit</code>, you can use the following statement:</p><div class="informalexample"><pre class="programlisting">button.clicked.connect(lineEdit.clear)</pre></div><p>If the receiver is a standalone function called <code class="literal">clearLineEdit</code>, the call becomes:</p><div class="informalexample"><pre class="programlisting">button.clicked.connect(clearLineEdit)</pre></div><p>You can also connect a signal to an anonymous function that was defined directly in the connection statement:</p><div class="informalexample"><pre class="programlisting">button.clicked.connect(function() { lineEdit.clear() })</pre></div><p>There is additional syntax available where you can define the <code class="literal">this</code> object for the function:</p><div class="informalexample"><pre class="programlisting">var obj = { "name": "FooBar" }
button.clicked.connect(obj, function() { print(this.name) })</pre></div><p>If you need to disconnect a signal from within a script, just replace <code class="literal">connect</code> with <code class="literal">disconnect</code>:</p><div class="informalexample"><pre class="programlisting">button.clicked.disconnect(clearLineEdit)</pre></div><p>Emitting signals from within the script is also easy—just call the signal as a function and pass to it any necessary parameters:</p><div class="informalexample"><pre class="programlisting">spinBox.valueChanged(7)</pre></div><p>To create a <a id="id618" class="indexterm"/>signal-slot connection on the C++ side where the <a id="id619" class="indexterm"/>receiver is a script function, instead of a regular <code class="literal">connect()</code> statement, use <code class="literal">qScriptConnect()</code>. Its first two parameters are identical with the regular call and the two other parameters correspond to a script value that represents an object that is to act as the <code class="literal">this</code> object and a script value that represents a function to be called:</p><div class="informalexample"><pre class="programlisting">QScriptValue function = engine.evaluate("(function() { })");
qScriptConnect(button, SIGNAL(clicked()), QScriptValue(), function);</pre></div><p>In this particular example, we pass an invalid object as the third parameter. In such a case, the <code class="literal">this</code> object will point to the engine's global object.</p><p>As for disconnecting signals, of course, there is <code class="literal">qScriptDisconnect()</code> available.</p></div><div class="section" title="Have a go hero – triggering defense using signals and slots"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec162"/>Have a go hero – triggering defense using signals and slots</h2></div></div></div><p>As a task for <a id="id620" class="indexterm"/>yourself, try modifying the Dungeons &amp; Dragons game so that the defend script function is not called manually by the script engine, but instead is invoked using a signal-slot connection. Have a creature emit the <code class="literal">attacked()</code> signal when it is attacked, and let the script connect a handler to that <a id="id621" class="indexterm"/>signal. Use a variant of connect that defines the <code class="literal">this</code> object for the connection.</p></div><div class="section" title="Creating Qt objects in scripts"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec163"/>Creating Qt objects in scripts</h2></div></div></div><p>Using <a id="id622" class="indexterm"/>existing objects from scripts sometimes is not enough to <a id="id623" class="indexterm"/>get a rich scripting experience. It is also useful to be able to create new Qt objects from within scripts and even return them to C++ so that they can be used by the game engine. There are two ways to approach this problem. Before we describe them, it is important to understand how JavaScript instantiates objects.</p><p>JavaScript has no notion of classes. It constructs objects using prototypes—a prototype is an object whose properties are cloned into the new object. The object is constructed by invoking a constructor, which can be any function. When you invoke a function using the keyword new, the engine creates a new empty object, sets its constructor property to the function serving as the constructor, sets the object prototype to the function's prototype, and finally, invokes the function in the context of the new object, making that function act as a factory function for objects with a particular set of properties. Therefore, to construct objects of the type <code class="literal">QLineEdit</code>, there needs to be a function that can be called as a constructor for objects that behave like Qt's widget to enter a single line of text.</p><p>We already know that functions can be stored in <code class="literal">QScriptValue</code> objects. There are two ways to obtain a function that can act as a constructor for Qt objects. First, we can implement it ourselves:</p><div class="informalexample"><pre class="programlisting">QScriptValue pushbutton_ctor(QScriptContext *context, QScriptEngine *engine) {
    QScriptValue parentValue = context-&gt;argument(0);
    QWidget *parent = qscriptvalue_cast&lt;QWidget*&gt;(parentValue);
    QPushButton *button = new QPushButton(parent);
    QScriptValue buttonValue = engine-&gt;newQObject(button, QScriptEngine::AutoOwnership);
    return buttonValue;
}
QScriptValue buttonConstructor = engine.newFunction(pushbutton_ctor);
engine.globalObject().setProperty("QPushButton", buttonConstructor);</pre></div><p>We did three things here. First, we defined a function that instantiates <code class="literal">QPushButton</code> with a parent passed as the first argument to the function, wraps the object in <code class="literal">QScriptValue</code> (with an extra parameter noting that the environment responsible for deleting the object should be determined by the parent object), and that returns <code class="literal">QScriptValue</code> to the caller. Secondly, we wrapped the function itself into <code class="literal">QScriptValue</code> as we already did earlier with other functions. Finally, we set the function as a property of the global object of the engine so that it is always accessible.</p><p>The second way to obtain a constructor function is to make use of Qt's meta-object system. You can use the following macro to define a constructor function very similar to what we have written manually:</p><div class="informalexample"><pre class="programlisting">Q_SCRIPT_DECLARE_QMETAOBJECT(QPushButton, QWidget*)</pre></div><p>Next, you can use the <code class="literal">QScriptEngine::scriptValueFromQMetaObject()</code> template method to get a script value wrapping that function:</p><div class="informalexample"><pre class="programlisting">QScriptValue pushButtonClass = engine.scriptValueFromQMetaObject&lt;QPushButton&gt;();</pre></div><p>Lastly, you <a id="id624" class="indexterm"/>can set the obtained script value as a constructor in the <a id="id625" class="indexterm"/>script engine just like before. Here is a complete code to make push buttons creatable from within the scripts:</p><div class="informalexample"><pre class="programlisting">#include &lt;QtWidgets&gt;
#include &lt;QScriptEngine&gt;

Q_SCRIPT_DECLARE_QMETAOBJECT(QPushButton, QWidget*)

int main(int argc, char **argv) {
  QApplication app(argc, argv);
  QScriptEngine engine;
  QScriptValue pushButtonClass 
  = engine.scriptValueFromQMetaObject&lt;QPushButton&gt;();
  engine.globalObject().setProperty("QPushButton", pushButtonClass);
  QString script = "pushButton = new QPushButton\n"
                   "pushButton.text = 'Script Button'\n"
                   "pushButton.show()";
  engine.evaluate(script);
  return app.exec();
}</pre></div></div><div class="section" title="Error recovery and debugging"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec164"/>Error recovery and debugging</h2></div></div></div><p>The only error <a id="id626" class="indexterm"/>recovery we've talked about so far is checking whether a script has ended up with an error and executing a script in a dedicated context to prevent polluting the namespace with local variables that are not used anymore. This is already a lot; however, we can do more. First, we can take care of preventing pollution of the global namespace. Pushing and popping the execution context does not prevent a script from modifying the engine's global object, and we should prevent situations when a script, for example, replaces the <code class="literal">Math</code> object or the print function. The solution is to provide your own global object in place of the original one. There are two easy ways to do this. First, you can use the class called <code class="literal">QScriptValueIterator</code> to copy all the properties of the global object to a new object:</p><div class="informalexample"><pre class="programlisting">QScriptValue globalObject = engine.globalObject();
QScriptValue newGO = engine.newObject();
QScriptValueIterator iter(globalObject);
while(iter.hasNext()) {
  iter.next(); newGO.setProperty(iter.key(), iter.value());
}</pre></div><p>Alternatively, you can set the original global object as an internal prototype of the new object:</p><div class="informalexample"><pre class="programlisting">QScriptValue globalObject = engine.globalObject();
QScriptValue newGO = engine.newObject();
newGO.setPrototype(globalObject);</pre></div><p>Either way, you will then need to replace the original global object with the temporary one:</p><div class="informalexample"><pre class="programlisting">engine.setGlobalObject(newGO);</pre></div><p>The other big thing to do when talking about error recovery is to provide debugging capabilities for scripts. Luckily, Qt contains a built-in component to debug scripts. If you build your project with the <code class="literal">QT+=scripttools</code> option, you will gain access to the <code class="literal">QScriptEngineDebugger</code> class. To start using the debugger with a script engine, you need to attach and bind them:</p><div class="informalexample"><pre class="programlisting">QScriptEngine engine;
QScriptEngineDebugger debugger;
debugger.attachTo(&amp;engine);</pre></div><p>Whenever an <a id="id627" class="indexterm"/>uncaught exception occurs, the debugger will kick in and show its window:</p><div class="mediaobject"><img src="graphics/8874OS_08_07.jpg" alt="Error recovery and debugging"/></div><p>You can then set breakpoints in the script, inspect variables or the call stack, and continue or break the execution. A good idea is to incorporate the debugger in your game so that script designers can <a id="id628" class="indexterm"/>use it when developing scripts. Of course, the debugger should not be running with the release version of the game.</p></div><div class="section" title="Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec165"/>Extensions</h2></div></div></div><p>
<code class="literal">QScriptEngine</code> <a id="id629" class="indexterm"/>has the ability to import extensions that provide additional functionality to the scripting environment (for example, a library of utility functions that can be used in different parts of the game without having to redefine them here and there) using the <code class="literal">importExtension()</code> method. The extension can be implemented in JavaScript by providing a set of files that contain scripts, making the extension or in C++ by subclassing <code class="literal">QScriptExtensionPlugin</code>. Now, we will focus on the second approach. Here is how a simple C++ extension looks:</p><div class="informalexample"><pre class="programlisting">class SimpleExtension : public QScriptExtensionPlugin {
  Q_OBJECT
  Q_PLUGIN_METADATA(IID "org.qt- project.Qt.QScriptExtensionInterface")
public:
  SimpleExtension(QObject *parent = 0) : QScriptExtensionPlugin(parent) {}
  QStringList keys() const Q_DECL_OVERRIDE { return QStringList() &lt;&lt; "simple"; }
  void initialize(const QString &amp;key, QScriptEngine *engine) {
    QScriptValue simple = engine-&gt;newObject();
    simple.setProperty("name", "This is text from Simple extension");
    engine-&gt;globalObject().setProperty("Simple", simple);
  }
};</pre></div><p>The extension defined here is simple—it only attaches one property to the engine's global object, which has a name property returning as a text string. You should put the resulting library in a subdirectory called <code class="literal">Simple</code> in a script subdirectory of a directory where your application looks for <a id="id630" class="indexterm"/>plugins (for example, the application where your application binary is placed). Then, you can import the plugin using <code class="literal">importExtension()</code>:</p><div class="informalexample"><pre class="programlisting">QScriptEngine engine;
engine.importExtension("Simple");
engine.evaluate("print(Simple.name)")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip70"/>Tip</h3><p>Refer to the <span class="emphasis"><em>Deploying Plugins</em></span> section of the Qt reference manual for more information about where you can put plugins and how you can tell Qt where to look for them.</p></div></div></div><div class="section" title="The other Qt JavaScript environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec166"/>The other Qt JavaScript environment</h2></div></div></div><p>As mentioned <a id="id631" class="indexterm"/>at the beginning of this chapter, Qt provides two environments to use JavaScript. We already talked about Qt Script; now it is time for us to tell you about its counterpart: <code class="literal">QJSEngine</code>. The newer JavaScript engine in Qt, which is also used for QML, about which you will learn in the next chapter. It has a different internal architecture than Qt Script, but most of what we have taught you also applies to <code class="literal">QJSEngine</code>. The main difference is that the root classes are named differently. Have a look at the following table, which shows equivalent classes for the two engines:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>QtScript</p>
</th><th style="text-align: left" valign="bottom">
<p>QJSEngine</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QScriptEngine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">QJSEngine</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QScriptValue</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">QJSValue</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QScriptContext</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">–</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">QJSEngine</code> class is the equivalent of <code class="literal">QScriptEngine</code>. It also has an <code class="literal">evaluate()</code> method that is used to evaluate scripts. This method can create objects, wrap <code class="literal">QObject</code> instances, and use <code class="literal">QJSValue</code> (the equivalent of <code class="literal">QScriptValue</code>) to store values used in scripts in a way that they can be accessed from C++. You can also see that there is no equivalent to <code class="literal">QScriptContext</code> and thus its functionality is not available in the implementation based <a id="id632" class="indexterm"/>on <code class="literal">QJSEngine</code>. Another missing component is the integrated engine debugger. Also, at the time of writing, there is no easy way to export your own classes to the <code class="literal">QJSEngine</code>-based JavaScript environment to allow the creation of instances of those classes.</p></div></div>
<div class="section" title="Alternatives to JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec126"/>Alternatives to JavaScript</h1></div></div></div><p>Qt Script is an <a id="id633" class="indexterm"/>environment that is designed to be part of the Qt world. Since not everyone knows or likes JavaScript, we will present another language that can easily be used to provide scripting environments for games that are created with Qt. Just be aware that this is not going to be an in-depth description of the environment—we will just show you the basics that can provide foundations for your own research.</p><div class="section" title="Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec167"/>Python</h2></div></div></div><p>A popular language <a id="id634" class="indexterm"/>used for scripting is Python. There are two variants of Qt bindings that are available for Python: PySide and PyQt. PySide is the official <a id="id635" class="indexterm"/>binding that is available under LGPL, but currently, it only work with Qt 4. PyQt is a third-party library that is available under GPL v3 and commercial licenses that have variants for Qt 4 as well as Qt 5. Note that PyQt is not available under LGPL, so for commercial closed-source products you need to obtain a commercial license from Riverbank Computing!</p><p>These bindings allow you to use the Qt API from within Python—you can write a complete Qt application using just Python. However, to call Python code from within C++, you will need a regular Python interpreter. Luckily, it is very easy to embed such an interpreter in a C++ application.</p><p>First, you will need <a id="id636" class="indexterm"/>Python installed along with its development package. For example, for Debian-based systems, it is easiest to simply install the <code class="literal">libpythonX.Y-dev</code> (or a newer) package, where <code class="literal">X</code> and <code class="literal">Y</code> stand for the version of Python:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install libpython3.3-dev</strong></span>
</pre></div><p>Then, you need to tell your program to link it against the library:</p><div class="informalexample"><pre class="programlisting">LIBS += -lpython3.3m
INCLUDEPATH += /usr/include/python3.3m/</pre></div><p>To call Python code from within a Qt app, the simplest way is to use the following code:</p><div class="informalexample"><pre class="programlisting">#include &lt;Python.h&gt;
#include &lt;QtCore&gt;

int main(int argc, char **argv) {
  QApplication app(argc, argv);
  Py_SetProgramName(argv[0]);
  Py_Initialize();
  const char *script = "print(\"Hello from Python\")"
  PyRun_SimpleString(script);
  Py_Finalize();
  return app.exec();
}</pre></div><p>This code initializes a Python interpreter, then invokes a script by passing it directly as a string, and finally, it shuts down the interpreter before invoking Qt's event loop. Such code makes sense only for simple scripting. In real life, you'd want to pass some data to the script or fetch the result. For that, we have to write some more code. As the library exposes the C API only, let's write a nice Qt wrapper for it.</p></div></div>
<div class="section" title="Time for action &#x2013; writing a Qt wrapper for embedding Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec127"/>Time for action – writing a Qt wrapper for embedding Python</h1></div></div></div><p>As the <a id="id637" class="indexterm"/>first task, we will implement the last program <a id="id638" class="indexterm"/>using an object-oriented API. Create a new console project and add the following class to it:</p><div class="informalexample"><pre class="programlisting">#include &lt;Python.h&gt;
#include &lt;QObject&gt;
#include &lt;QString&gt;
class QtPython : public QObject {
  Q_OBJECT
public:
  QtPython(const char *progName, QObject *parent = 0) : QObject(parent) { 
    if(progName != 0) {
        wchar_t buf[strlen(progName+1)];
        mbstowcs(buf, progName, strlen(progName));
        Py_SetProgramName(buf);
    }
    Py_InitializeEx(0);
  }
  ~QtPython() { Py_Finalize(); }
  void run(const QString &amp;program) {
    PyRun_SimpleString(qPrintable(program));
  }
};</pre></div><p>Then, add a <a id="id639" class="indexterm"/>
<code class="literal">main()</code> function as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">#include "qtpython.h"

int main(int argc, char **argv) {
  QtPython python(argv[0]);
  python.run("print('Hello from Python')");
  return 0;
}</pre></div><p>Finally open the <code class="literal">.pro</code> file and tell Qt to link with the Python library. In case of Linux you can use <code class="literal">pkg-config</code> by adding two lines to the file:</p><div class="informalexample"><pre class="programlisting">CONFIG += link_pkgconfig
PKGCONFIG += python-3.3m # adjust the version number to suit your needs</pre></div><p>You might need to install Python library using a call equivalent to <code class="literal">apt-get install libpython3.4-dev</code>. For Windows you need to manually pass information to the compiler:</p><div class="informalexample"><pre class="programlisting">INCLUDEPATH += C:\Python33\include
LIBS += -LC:\Python33\include -lpython33</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec168"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created a class called <code class="literal">QtPython</code> that wraps the Python C API for us.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip71"/>Tip</h3><p>Never use a <code class="literal">Q</code> prefix to call your custom classes, as this prefix is reserved for official Qt classes. This is to make sure that your code will never have a name clash with future code added to Qt. The Qt prefix on the other hand is meant to be used with classes that are extensions to Qt. You probably still shouldn't use it, but the probability of a name clash is much smaller and yields a lesser impact than clashes with an official class. It is best to come up with your own prefix (such as <code class="literal">Qxy</code>, where <code class="literal">x</code> and <code class="literal">y</code> are your initials).</p></div></div><p>The class constructor creates a Python interpreter and the class destructor destroys it. We use <code class="literal">Py_InitializeEx(0)</code>, which has the same functionality as <code class="literal">Py_Initialize()</code>, but it does not apply C signal handlers, as this is not something we would want when embedding Python. Prior to this, we use <code class="literal">Py_SetProgramName()</code> to inform the interpreter of our context. We also defined a <code class="literal">run()</code> method, taking <code class="literal">QString</code> and returning <code class="literal">void</code>. It uses <code class="literal">qPrintable()</code>, which is a convenience function that extracts a C string pointer from a <code class="literal">QString</code> object, which is then fed into <code class="literal">PyRun_SimpleString()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip72"/>Tip</h3><p>Never store the <a id="id640" class="indexterm"/>output of <code class="literal">qPrintable()</code> as it returns an internal pointer to a temporary byte array (this is equivalent to calling <code class="literal">toLocal8Bit().constData()</code> on a string). It is safe to use directly, but the byte array is destroyed immediately afterwards; thus, if you store the pointer in a variable, the data may not be valid later when you try using that pointer.</p></div></div><p>The hardest work when using embedded interpreters is to convert values between C++ and the types that the interpreter expects. With Qt Script, the <code class="literal">QScriptValue</code> type was used for this. We can implement something similar for our Python scripting environment.</p></div></div>
<div class="section" title="Time for action &#x2013; converting data between C++ and Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec128"/>Time for action – converting data between C++ and Python</h1></div></div></div><p>Create a <a id="id641" class="indexterm"/>new class and call it <code class="literal">QtPythonValue</code>. Then, add <a id="id642" class="indexterm"/>the following code to it:</p><div class="informalexample"><pre class="programlisting">#include &lt;Python.h&gt;

class QtPythonValue {
public:
  QtPythonValue() { incRef(Py_None);}
  QtPythonValue(const QtPythonValue &amp;other) { incRef(other.m_value); }
  QtPythonValue&amp; operator=(const QtPythonValue &amp;other) {
    if(m_value == other.m_value) return *this;
    decRef();
    incRef(other.m_value);
    return *this;
  }

  QtPythonValue(int val) {  m_value = PyLong_FromLong(val); }
  QtPythonValue(const QString &amp;str) {
    m_value = PyUnicode_FromString(qPrintable(str));
  }
  ~QtPythonValue() { decRef(); }
  int toInt() const { return PyLong_Check(m_value) ? PyLong_AsLong(m_value) : 0; }
  QString toString() const {
    return PyUnicode_Check(m_value) ? QString::fromUtf8(PyUnicode_AsUTF8(m_value)) : QString(); 
  }
  bool isNone() const { return m_value == Py_None; }

private:
  QtPythonValue(PyObject *ptr) { m_value = ptr; }
  void incRef() { if(m_value) Py_INCREF(m_value); }
  void incRef(PyObject *val) { m_value = val; incRef(); }
  void decRef() { if(m_value) Py_DECREF(m_value); }
  PyObject *m_value;
  friend class QtPython;
};</pre></div><p>Next, let's<a id="id643" class="indexterm"/> modify the <code class="literal">main()</code> function to test our new code:</p><div class="informalexample"><pre class="programlisting">#include "qtpython.h"
#include "qtpythonvalue.h"
#include &lt;QtDebug&gt;

int main(int argc, char *argv[]) {
    QtPython python(argv[0]);
    QtPythonValue integer = 7, string = QStringLiteral("foobar"), none;
    qDebug() &lt;&lt; integer.toInt() &lt;&lt; string.toString() &lt;&lt; none.isNone();
    return 0;
}</pre></div><p>When you run <a id="id644" class="indexterm"/>the program, you will see that the conversion between C++ and Python works correctly in both directions.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec169"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>The <code class="literal">QtPythonValue</code> class wraps a <code class="literal">PyObject</code> pointer (through the <code class="literal">m_value</code> member), providing a nice interface to convert between what the interpreter expects and our Qt types. Let's see how this is done. First, take a look at the three private methods: two versions of <code class="literal">incRef()</code> and one <code class="literal">decRef()</code>. <code class="literal">PyObject</code> contains an internal reference counter that counts the number of handles on the contained value. When that counter drops to <code class="literal">0</code>, the object can be destroyed. Our three methods use adequate Python C API calls to increase or decrease the counter in order to prevent memory leaks and keep Python's garbage collector happy.</p><p>The second important aspect is that the class defines a private constructor that takes a <code class="literal">PyObject</code> pointer, effectively creating a wrapper over the given value. The constructor is private; however, the <code class="literal">QtPython</code> class is declared as a friend of <code class="literal">QtPythonValue</code>, which means that only <code class="literal">QtPython</code> and <code class="literal">QtPythonValue</code> can instantiate values by passing <code class="literal">PyObject</code> pointers to it. Now, let's have a look at public constructors.</p><p>The default <a id="id645" class="indexterm"/>constructor creates an object pointing to a <code class="literal">None</code> value, which is Python's equivalent to the C++ null. The copy constructor and assignment operator are pretty standard, taking care of bookkeeping of the reference counter. Then, we have two constructors—one taking <code class="literal">int</code> and the other taking a <code class="literal">QString</code> value. They use appropriate Python C API calls to obtain a <code class="literal">PyObject</code> representation of the value. Note that these calls already increase the reference count for us, so we don't have to do it ourselves.</p><p>The code ends with a destructor that decreases the reference counter and three methods that provide safe conversions from <code class="literal">QtPythonValue</code> to appropriate Qt/C++ types.</p></div><div class="section" title="Have a go hero – implementing the remaining conversions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec170"/>Have a go hero – implementing the remaining conversions</h2></div></div></div><p>Now, you <a id="id646" class="indexterm"/>should be able to implement other constructors and conversions for <code class="literal">QtPythonValue</code> that operates on the <code class="literal">float</code>, <code class="literal">bool</code>, or even on <code class="literal">QDate</code> and <code class="literal">QTime</code> types. Try implementing them yourself. If needed, have a look at <a class="ulink" href="https://docs.python.org/3/">https://docs.python.org/3/</a> to find appropriate calls that you should use. We'll give you a head start by providing a skeleton implementation of how to convert <code class="literal">QVariant</code> to <code class="literal">QtPythonValue</code>. This is especially important because Python makes use of two types whose equivalents are not available in C++, namely, tuples and dictionaries. We will need them later, so having a proper implementation is crucial. Here is the code:</p><div class="informalexample"><pre class="programlisting">QtPythonValue::QtPythonValue(const QVariant &amp;variant)
{
  switch(variant.type()) {
    case QVariant::Invalid: incRef(Py_None);
    return;
    case QVariant::String: m_value 
      = PyUnicode_FromString(qPrintable(variant.toString()));
    return;
    case QVariant::Int: m_value = PyLong_FromLong(variant.toInt());
    return;
    case QVariant::LongLong: m_value 
      = PyLong_FromLongLong(variant.toLongLong());
    return;
<span class="strong"><strong>    case QVariant::List: {</strong></span>
<span class="strong"><strong>      QVariantList list = variant.toList();</strong></span>
<span class="strong"><strong>      const int listSize = list.size();</strong></span>
<span class="strong"><strong>      PyObject *tuple = PyTuple_New(listSize);</strong></span>
<span class="strong"><strong>      for(int i=0;i&lt;listSize;++i) {</strong></span>
<span class="strong"><strong>        PyTuple_SetItem(tuple, i, QtPythonValue(list.at(i)).m_value);</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>      m_value = tuple;</strong></span>
<span class="strong"><strong>      return;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    case QVariant::Map: {</strong></span>
<span class="strong"><strong>      QVariantMap map = variant.toMap();</strong></span>
<span class="strong"><strong>      PyObject *dict = PyDict_New();</strong></span>
<span class="strong"><strong>      for(QVariantMap::const_iterator iter = map.begin();</strong></span>
<span class="strong"><strong>      iter != map.end(); ++iter) {</strong></span>
<span class="strong"><strong>        PyDict_SetItemString(dict, </strong></span>
<span class="strong"><strong>            qPrintable(iter.key()), </strong></span>
<span class="strong"><strong>            QtPythonValue(iter.value()).m_value</strong></span>
<span class="strong"><strong>        );</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    m_value = dict;</strong></span>
<span class="strong"><strong>    return;</strong></span>
<span class="strong"><strong>  }</strong></span>
  default: incRef(Py_None); return;
  }
}</pre></div><p>The highlighted code shows how to create a tuple (which is a list of arbitrary elements) from <code class="literal">QVariantList</code> and how to create a dictionary (which is an associative array) from <code class="literal">QVariantMap</code>. Try adding constructors by taking <code class="literal">QStringList</code>, <code class="literal">QVariantList</code>, and <code class="literal">QVariantMap</code> directly and returning tuples or a dictionary, respectively.</p><p>We have written <a id="id647" class="indexterm"/>quite a lot of code now, but so far there is no way of binding any data from our programs with Python scripting. Let's change that.</p></div></div>
<div class="section" title="Time for action &#x2013; calling functions and returning values"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec129"/>Time for action – calling functions and returning values</h1></div></div></div><p>The next <a id="id648" class="indexterm"/>task is to provide ways to invoke Python functions and <a id="id649" class="indexterm"/>return values from scripts. Let's start by providing a richer <code class="literal">run()</code> API. Implement the following method in the <code class="literal">QtPython</code> class:</p><div class="informalexample"><pre class="programlisting">QtPythonValue QtPython::run(const QString &amp;program, const QtPythonValue &amp;globals, const QtPythonValue &amp;locals)
{
  PyObject *retVal = PyRun_String(qPrintable(program), 
    Py_file_input, globals.m_value, locals.m_value);
  return QtPythonValue(retVal);
}</pre></div><p>We'll also need a functionality to import Python modules. Add the following methods to the class:</p><div class="informalexample"><pre class="programlisting">QtPythonValue QtPython::import(const QString &amp;name) const {
  return QtPythonValue(PyImport_ImportModule(qPrintable(name)));
}

QtPythonValue QtPython::addModule(const QString &amp;name) const {
  PyObject *retVal = PyImport_AddModule(qPrintable(name));
  Py_INCREF(retVal);
  return QtPythonValue(retVal);
}

QtPythonValue QtPython::dictionary(const QtPythonValue &amp;module) const {
  PyObject *retVal = PyModule_GetDict(module.m_value);
  Py_INCREF(retVal);
  return QtPythonValue(retVal);
}</pre></div><p>The last piece of the code is to extend <code class="literal">QtPythonValue</code> with this code:</p><div class="informalexample"><pre class="programlisting">bool QtPythonValue::isCallable() const {
  return PyCallable_Check(m_value);
}

QtPythonValue QtPythonValue::attribute(const QString &amp;name) const {
  return QtPythonValue(PyObject_GetAttrString(m_value, qPrintable(name)));
}

bool QtPythonValue::setAttribute(const QString &amp;name, const QtPythonValue &amp;value) {
  int retVal = PyObject_SetAttrString(m_value, qPrintable(name), value.m_value);
  return retVal != -1;
}

QtPythonValue QtPythonValue::call(const QVariantList &amp;arguments) const {
  return QtPythonValue(PyObject_CallObject(m_value, QtPythonValue(arguments).m_value));
}

QtPythonValue QtPythonValue::call(const QStringList &amp;arguments) const {
  return QtPythonValue(PyObject_CallObject(m_value, QtPythonValue(arguments).m_value));
}</pre></div><p>Finally, you can <a id="id650" class="indexterm"/>modify <code class="literal">main()</code> to test the new functionality:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char *argv[]) {
  QtPython python(argv[0]);

  QtPythonValue mainModule = python.addModule("__main__");
  QtPythonValue dict = python.dictionary(mainModule);
  python.run("foo = (1, 2, 3)", dict, dict);
  python.run("print(foo)", dict, dict);

  QtPythonValue module = python.import("os");
  QtPythonValue chdir = module.attribute("chdir");
  chdir.call(QStringList() &lt;&lt; "/home");
  QtPythonValue func = module.attribute("getcwd");
  qDebug() &lt;&lt; func.call(QVariantList()).toString();

  return 0;
}</pre></div><p>You can replace <code class="literal">/home</code> with a directory of your choice. Then, you can run the program.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec171"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We did two tests in the last program. First, we used the new <code class="literal">run()</code> method, passing to it the code that is to be executed and two dictionaries that define the current execution context—the first dictionary contains global symbols and the second contains local symbols. The dictionaries come from Python's <code class="literal">__main__</code> module (which among other things, defines the <code class="literal">print</code> function). The <code class="literal">run()</code> method may modify the contents of the two dictionaries—the first call defines the tuple called <code class="literal">foo</code> and the second call prints it to the standard output.</p><p>The second test calls a function from an imported module; in this case, we call two functions from the <code class="literal">os</code> module—the first function, <code class="literal">chdir</code>, changes the current working directory and the other called <code class="literal">getcwd</code> returns the current working directory. The convention is that we should pass a tuple to <code class="literal">call()</code>, where we pass the needed parameters. The first function takes a string as a parameter, therefore, we pass a <code class="literal">QStringList</code> object, assuming that there is a <code class="literal">QtPythonValue</code> constructor that converts <code class="literal">QStringList</code> to a tuple (you need to implement it if you haven't done it already). Since the second function does not take any parameters, we pass an empty tuple to the call. In the same way, you can provide your own modules and call functions from them, query the results, inspect dictionaries, and so on. This is a pretty good start for an embedded Python interpreter. Remember that a proper component should have some error checking code to avoid crashing the whole application.</p><p>You can extend the <a id="id651" class="indexterm"/>functionality of the interpreter in many ways. You can even use PyQt5 to use Qt bindings in scripts, combining Qt/C++ code with Qt/Python code.</p></div><div class="section" title="Have a go hero – wrapping Qt objects into Python objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec172"/>Have a go hero – wrapping Qt objects into Python objects</h2></div></div></div><p>At this point, you should be experienced enough to try and implement a wrapper for the <code class="literal">QObject</code> <a id="id652" class="indexterm"/>instances to expose signals and slots to <a id="id653" class="indexterm"/>Python scripting. If you decide to pursue the goal, <a class="ulink" href="https://docs.python.org/3/">https://docs.python.org/3/</a> will be your best friend, especially the section about extending Python with C++. Remember that <code class="literal">QMetaObject</code> provides information about the properties and methods of Qt objects and <code class="literal">QMetaObject::invokeMethod()</code> allows you to execute a method by its name. This is not an easy task, so don't be hard on yourself if you are not able to complete it. You can always return to it once you gain more experience in using Qt and Python.</p><p>Before you head on to the next chapter, try testing your knowledge about scripting in Qt.</p></div><div class="section" title="Pop quiz – scripting"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec173"/>Pop quiz – scripting</h2></div></div></div><p>Q1. Which is the method that you can use to execute JavaScript statements?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">QScriptEngine::run()</code></li><li class="listitem"><code class="literal">QScriptEngine::evaluate()</code></li><li class="listitem"><code class="literal">QScriptProgram::execute()</code></li></ol></div><p>Q2. What is the name of the class that serves as a bridge to exchange data between Qt Script and C++?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">QScriptContext</code></li><li class="listitem"><code class="literal">QScriptValue</code></li><li class="listitem"><code class="literal">QVariant</code></li></ol></div><p>Q3. What is the name of the class that serves as a bridge that is used to exchange data between Python and C++?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">PyValue</code></li><li class="listitem"><code class="literal">PyObject</code></li><li class="listitem"><code class="literal">QVariant</code></li></ol></div><p>Q4. How do execution contexts work?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">They mark some variables as "executable" to prevent rogue code from being executed.</li><li class="listitem">They allow executing scripts in parallel, improving their speed.</li><li class="listitem">They contain all the variables defined within a function invocation so that a set of variables visible from within a script can be modified without affecting the global environment (called sandboxing).</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec130"/>Summary</h1></div></div></div><p>In this chapter, you learned that providing a scripting environment to your games opens up new possibilities. Implementing a functionality using scripting languages is usually faster than doing the full write-compile-test cycle with C++ and you can even use the skills and creativity of your users who have no understanding of the internals of your game engine to make your games better and more feature-rich. You were shown how to use Qt Script, which blends the C++ and JavaScript worlds together by exposing Qt objects to JavaScript and making cross-language signal-slot connections. If you're not a JavaScript fan, you learned the basics of scripting with Python. There are other scripting languages available (for example Lua) and many of them can be used together with Qt. Using the experience gained in this chapter, you should even be able to bring other scripting environments to your programs, as most embeddable interpreters offer similar approaches to that of Python.</p><p>In the next chapter, you will be introduced to an environment very much like Qt Script in the way that it is heavily based on JavaScript. However, the purpose of using it is completely different—we will be using it to bleed edge-fancy graphics. Welcome to the world of Qt Quick.</p></div></body></html>