# Chapter 8. Working with Hardware

The following topics will be covered in this chapter:

*   Using native code
*   Change the processing using the platform
*   Using the acceleration sensor
*   Keeping the screen on
*   Getting dpi
*   Getting the maximum texture size

# Introduction

Cocos2d-x has a lot of APIs. However, there are no APIs that we need, for example, In-App purchase, push notification, and so on. In this case, we have to create original APIs and need to write Objective-C code for iOS or Java code for Android. In addition, we want to get the device information that it is running on. When we want to adjust for each device, we have to get the device information such as the running application version, device name, dpi on device, and so on. However, doing so is very difficult and confusing. In this chapter, you can write the native code for iOS or Android and get the device information.

# Using native code

In Cocos2d-x, you can write one source for the cross platform. However, you have to write an Objective-C function or a Java function for the dependency process such as a purchase or push notification. If you want to call Java for Android from C++, you have to use **JNI** (**Java Native Interface**). In particular, JNI is very confusing. To call Java from C++, you have to use JNI. In this recipe, we will explain how to call an Objective-C function or a Java function from C++.

## Getting ready

In this case, we will make a new class called `Platform`. You can get the application version by using this class. Before writing code, you will make three files called **Platform.h**, **Platform.mm**, and **Platform.cpp** in your project.

![Getting ready](img/B0561_08_01.jpg)

It is important that you don't add `Platform.cpp` to **Compile Sources** in Xcode. That's why `Platform.cpp` is for an Android target and doesn't need to be built for iOS. If you added it to **Compile Sources**, you have to remove it from there.

![Getting ready](img/B0561_08_02.jpg)

## How to do it...

1.  Firstly, you have to make a header file called `Platform.h` by using the following code:

    [PRE0]

2.  You have to make an execution file called `Platform.mm` for iOS. This code is in Objective-C.

    [PRE1]

3.  You have to make an execution file called `Platform.cpp` for Android. The following code is in C++ and uses Java through JNI:

    [PRE2]

4.  You have to edit `proj.android/jni/Android.mk` to build for Android when you added a new class file in your project.

    [PRE3]

5.  Next, you have to write Java code in `AppActivity.java`. This file is named `pro.android/src/org/cocos2dx/cpp/AppActivity.java`.

    [PRE4]

6.  Finally, you can get a version of your game by using the following code:

    [PRE5]

## How it works...

1.  Firstly, we will look at it for iOS. You will be able to get a version of your game by using Objective-C in `Platform.mm`. You can write C++ and Objective-C in the `.mm` files.
2.  Next, we will look for Android. When you call `Platform::getAppversion` on Android devices, the method in `Platform.cpp` is executed. In this method, you can call the `getAppVersionInJava` method in `AppActivity.java`. by using JNI. C++ can connect Java via JNI. That's why you can only get the application version by using Java.
3.  In Java, you can get the version of your application by using the `onCreate` method. You can set it to a static variable and then, get it from the `getAppVersionInJava` method in Java.

## There's more…

You can use JNI easily by using the `JniHelper` class in Cocos2d-x. How this class manages typos from C++ and creates a bridge between C++ and Java has already been explained. You can use the `JniHelper` class by using the following code:

[PRE6]

You can get the information about the Java method by using `JniHelper::getStaticMethodInfo`. The first argument is a variable of `JniMethodInfo`. The second argument is the name of the class that has the method you want to call. The third argument is the method name. The last argument is the parameter of this method. This parameter is decided by the return value and the arguments. The characters in the bracket are the parameters for the Java method. In this case, this method has no parameters. The characters after the bracket are the return value. `Ljava/lang/String` means that the return value is a string. If you get this parameter easily, you should use the command called `javap`. As the following result will be generated by using this command.

[PRE7]

From the above result, you can see that the parameter for the `getAppVersionInJava` method is `()Ljava/lang/String`;

As mentioned earlier, you can get the information of the Java method as a `t` variable. So, you can call the Java method by using this variable and the following code:

[PRE8]

# Changing the processing using the platform

You can make the program run on specific parts of the source code for each OS. For example, you will change the file name, the file path, or the image scale by the platform. In this recipe, we will introduce the branching code based on the platform of choice in the case of a complication.

## How to do it...

You can change the processing by using the preprocessor as follows:

[PRE9]

## How it works...

Cocos2d-x defined the `CC_TARGET_PLATFORM` value in `CCPlatformConfig.h`. If your game is compiled for Android devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_ANDROID`. If it is compiled for iOS devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_IOS`. Needless to say, there are other values besides Android and iOS. Please check `CCPlatformConfig.h`.

## There's more…

The code that was used in the preprocessor is difficult to read on an editor. Further, you cannot notice the error before compiling your code. You should define a constant value that can be changed by the preprocessor, but you should change the processing by using code as much as possible. You can check the platform by using the `Application` class in Cocos2d-x as follows:

[PRE10]

You can get the value of the platform by using the `Application::getTargetPlatform` method. You will be able to check, not just for iPhone or iPad, but also IOS by using this method.

# Using the acceleration sensor

By using an acceleration sensor on the device, we can make the game more engrossing, by using operations such as shaking and tilting the device. For example, move the ball by tilting the screen, the maze game that aims at the goal, and the skinny panda trying to go on a diet, wherein the players shake the device to play the game. You can get the tilt value and the moving speed of the device by using the accelerometer. If you can use it, your game becomes more unique. In this recipe, we learn how to use the acceleration sensor.

## How to do it...

You can get the x, y, and z axis values from the acceleration sensor by using the following code:

[PRE11]

## How it works...

1.  Firstly, you enable the acceleration sensor by using the `Device::setAccelerometerEnable` method. The methods in the `Device` class are static methods. So, you can directly call a method without an instance like this:

    [PRE12]

2.  You set the event listener for getting the value from the acceleration sensor. In this case, you can get these values by using the lambda function.
3.  Finally, you set the event listener in the event dispatcher.
4.  You can get the value of the x, y, and z axes from the acceleration sensor, if you run this code on the real device. The x axis is the left and the right of the slope. The y axis is before and after of the slope. The z axis is the vertical motion.

## There's more…

The acceleration sensor uses more battery power. When you use it, you set an appropriate interval for when the event occurred. The following code sets the interval as one second.

[PRE13]

### Tip

If the interval is higher, we might miss some tilt inputs. However, if we use a low interval, we will drain a lot of battery.

# Keeping the screen on

You have to keep the device from entering into the sleep mode while playing your game. For example, in your game, the player can control the game and keep the game going by using the accelerometer. The problem is that if the player does not touch the screen while playing with the accelerometer, the device goes to sleep and enters background mode. In this recipe, you can keep the screen on easily.

## How to do it...

You can keep the screen on if you set it to `true` by using the `Device::setKeepScreenOn` method as follows:

[PRE14]

## How it works...

There is a different way for each platform to prevent a device from entering the sleep mode. However, Cocos2d-x can do it for every platform. You can use this method without executing a platform. In the iOS platform, the `setKeepScreenOn` method is as follows:

[PRE15]

In the Android platform, the method is as follows:

[PRE16]

# Getting dpi

There are a lot of **dpi** (**dots per inch**) variations for each device. You can prepare several kinds of images by resolution. You might want to change an image by the dpi running on the device. In this recipe, if you would like to get the dpi that your game is running on, you need to use the Cocos2d-x function.

## How to do it...

You can get dpi of the device game is executing on, by using the `Device::getDPI` method as follows:

[PRE17]

## How it works...

In fact, we checked the dpi of some devices. To use the dpi information, you can further adjust the multiscreen resolution.

| Device | Dpi |
| --- | --- |
| iPhone 6 Plus | 489 |
| iPhone 6 | 326 |
| iPhone 5s | 326 |
| iPhone 4s | 326 |
| iPad Air | 264 |
| iPad 2 | 132 |
| Nexus 5 | 480 |

# Getting the maximum texture size

The maximum texture size that can be used is different for each device. In particular, when you use the texture atlas, you should be careful. That's why a texture atlas that has a lot of images is too large in size. You can't use a texture that is over the maximum size. If you use it, your game will crash. In this recipe, you can get the maximum texture size.

## How to do it...

You can get the max texture size easily by using the following code:

[PRE18]

## How it works...

The Configuration class is a singleton class. This class has some OpenGL variables. OpenGL is a multiplatform API for rendering 2D and 3D vector graphics. It is pretty difficult to use. Cocos2d-x wraps it and makes it easy to use. OpenGL has a lot of information for graphics. The max texture size is one of the variables providing this information. You can get the max texture size of the device that your application is running on.

## There's more…

You can get other OpenGL variables. If you want to check the variables that `Configuration` has, you will use the `Configuration::getInfo` method.

[PRE19]

The result of the log on iPhone 6 Plus:

[PRE20]

If you get each variable, and you check the source code of the `Configuration` class, you can understand them easily.