- en: Chapter 2. Your Point of View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 你的视角
- en: Imagine that you are making a video. You've got your cell phone out, and you
    point it at the area that you want to shoot and press record. You're taking a
    video of the Grand Canyon, so you have to pan the camera around to get the whole
    scene in. Suddenly, a bird flies past the field of view, and you've captured the
    whole scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在制作一个视频。你拿出手机，指向你想拍摄的区域，然后按下录制。你正在拍摄大峡谷的视频，所以你必须移动摄像头来捕捉整个场景。突然，一只鸟飞过了视野，你捕捉到了整个场景。
- en: The preceding scenario is pretty much how games work as well. The game has a
    virtual camera that can be positioned and even moved around. Similarly to the
    video camera on your cell phone, the game camera can only see a part of the game
    world, so sometimes you have to move it around. Any game objects that move in
    front of the camera will be seen by the player.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景基本上就是游戏的工作方式。游戏有一个虚拟摄像头，它可以被定位，甚至可以移动。与你的手机上的视频摄像头类似，游戏摄像头只能看到游戏世界的一部分，所以有时你必须移动它。任何在摄像头前移动的游戏对象都会被玩家看到。
- en: 'This chapter will explain how things are rendered in the game. Rendering is
    the process of actually displaying images on the screen. In order to get your
    get your game onto the screen, you will need to have a solid understating of the
    following terms:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释游戏中的渲染方式。渲染是将图像实际显示在屏幕上的过程。为了将你的游戏显示在屏幕上，你需要对以下术语有一个扎实的理解：
- en: '**Coordinate systems**: The coordinate system is the reference that allows
    you to position objects in the game'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标系**：坐标系是允许你在游戏中定位对象的参考系'
- en: '**Primitives**: Primitives are the fundamental building blocks of the images
    that you see on screen, and OpenGL was designed to work with them'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原语**：原语是你在屏幕上看到的图像的基本构建块，OpenGL被设计用来与它们一起工作'
- en: '**Textures**: Textures are image files that are used to give the objects in
    your game a realistic appearance'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：纹理是用于给你的游戏中的对象赋予逼真外观的图像文件'
- en: By the time you have read this chapter, you will understand how to use images
    to build your game world and display it on the screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到你阅读完这一章时，你将了解如何使用图像来构建你的游戏世界并在屏幕上显示它。
- en: Plotting your revenge
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制你的复仇计划
- en: Okay, so you're not really plotting your revenge. But you are plotting everything
    in your game as if you were putting it all down on a piece of graph paper. Remember
    high-school geometry? You got out your graph paper, drew a couple of lines for
    the *X* and *Y* axis, and the plotted points on the graph. OpenGL works in pretty
    much the same way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你并不是真的在绘制你的复仇计划。但你是在像在一张图纸上放下所有东西一样，在你的游戏中绘制一切。你还记得高中几何吗？你拿出你的图纸，画了几条代表X轴和Y轴的线，然后在图上绘制了点。OpenGL基本上以同样的方式工作。
- en: The OpenGL coordinate system
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenGL坐标系
- en: The OpenGL coordinate system is a standard *X* and *Y* axis system that you
    have most likely learned all your life. You can conceptualize (0, 0) as being
    the center of the screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL坐标系是一个标准的X轴和Y轴坐标系，你很可能一生都在学习它。你可以将(0, 0)概念化为屏幕的中心。
- en: 'Let''s say that we want to display a moving car on the screen. We could start
    by plotting our car at position (5, 5) in the coordinate plane. If we then moved
    the car from (5, 5) to (6, 5), then (7, 5), and so forth, the car would move to
    the right (and eventually leave the screen), as illustrated in the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在屏幕上显示一辆移动的汽车。我们可以从在坐标系中绘制汽车的位置(5, 5)开始。如果我们然后将汽车从(5, 5)移动到(6, 5)，然后到(7,
    5)，以此类推，汽车就会向右移动（最终离开屏幕），如下面的图所示：
- en: '![The OpenGL coordinate system](img/8199OS_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![OpenGL坐标系](img/8199OS_02_01.jpg)'
- en: We haven't been completely honest with you. Since OpenGL is a 3D rendering engine,
    there is actually one more axis called the Z-axis that we haven't discussed. As
    this part of the book focuses on 2D game programming, we will ignore the Z axis
    for now.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对你并不完全诚实。由于OpenGL是一个3D渲染引擎，实际上还有一个我们尚未讨论的Z轴。由于本书的这一部分专注于2D游戏编程，我们将暂时忽略Z轴。
- en: Making your point
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 陈述你的观点
- en: As we learn each concept, we will actually write code to demonstrate each point.
    Speaking of points, we will write code to plot points using OpenGL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们学习每个概念，我们实际上会编写代码来演示每个要点。说到要点，我们将编写代码使用OpenGL绘制点。
- en: We are going to set this project up as a separate project from the actual game.
    We will use this project to demonstrate how to code basic OpenGL tasks. To keep
    this thing as simple as possible, this project will be created as a console project
    in Visual Studio. A console project doesn't have many of the features of a full-blown
    Windows project and therefore, the setup code is much smaller.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个项目设置为一个独立的项目，而不是实际的游戏项目。我们将使用这个项目来演示如何编写基本的OpenGL任务。为了使这个项目尽可能简单，这个项目将在Visual
    Studio中作为一个控制台项目创建。控制台项目没有完整Windows项目的大部分功能，因此，设置代码要小得多。
- en: Start Visual Studio and create a new project. For the project template, choose
    **Win32 Console Application** from the **Visual C++** group of templates. Name
    the project **OpenGLFun**, and click **OK**. Click **Finish** to complete the
    project wizard.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Visual Studio并创建一个新项目。在模板中，从**Visual C++**模板组中选择**Win32控制台应用程序**。将项目命名为**OpenGLFun**，然后点击**OK**。点击**Finish**以完成项目向导。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should notice that the code is much simpler than the code that was created
    in the previous chapter for a full-blown Windows application. We will return to
    using the more complicated code as we continue building the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，代码比上一章为完整Windows应用程序创建的代码要简单得多。随着我们继续构建游戏，我们将回到使用更复杂的代码。
- en: '![Making your point](img/8199OS_02_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![表达你的观点](img/8199OS_02_02.jpg)'
- en: 'Once you have the project created, type following the code into the code window:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了项目，将以下代码输入到代码窗口中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Understanding the code
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解代码
- en: As we will be using the code to demonstrate the fundamentals of OpenGL, we will
    look at it in detail so that you understand what the code is doing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用此代码来演示OpenGL的基本原理，我们将详细查看它，以便你理解代码正在做什么。
- en: Header files
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 头文件
- en: 'This code uses three header files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用三个头文件：
- en: '`stdafx.h`: This header file loads the precompiled header that was created
    by Visual Studio when we created the project'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdafx.h`：此头文件加载Visual Studio在创建项目时创建的预编译头文件'
- en: '`windows.h`: This header file allows the window that renders the OpenGL content
    to be created'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`windows.h`：此头文件允许创建渲染OpenGL内容的窗口'
- en: '`glut.h`: This header file allows us to use the OpenGL Utility Toolkit, which
    simplifies the setup and use of OpenGL'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut.h`：此头文件允许我们使用OpenGL实用工具包，它简化了OpenGL的设置和使用'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will need to download the GLUT files and place them in your project folder.
    Download the files from [http://www.javaforge.com/doc/105278](http://www.javaforge.com/doc/105278).
    Open the zipped file and copy `glut.h`, `glut32.dll`, and `glut32.lib` into the
    folder that contains your source code. You may have to add glut.h to your project
    (right-click on `Header files` | `Add` | `Existing item`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载GLUT文件并将它们放置在项目文件夹中。从[http://www.javaforge.com/doc/105278](http://www.javaforge.com/doc/105278)下载文件。打开压缩文件，将`glut.h`、`glut32.dll`和`glut32.lib`复制到包含你的源代码的文件夹中。你可能需要将`glut.h`添加到你的项目中（右键单击`Header
    files` | `Add` | `Existing item`）。
- en: Initializing OpenGL
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化OpenGL
- en: 'You will notice a function called `initGL`. This function currently contains
    a single line of code whose sole purpose is to set the background color of the
    screen at the start of each frame. This is often referred to as the *clear color*
    because it is the default that OpenGL clears the background to before it begins
    to render additional items:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到一个名为`initGL`的函数。此函数目前包含一行代码，其唯一目的是在每一帧的开始设置屏幕的背景颜色。这通常被称为*清除颜色*，因为OpenGL在开始渲染其他项目之前会将背景清除到默认值：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The four numbers inside the parenthesis define the color, and the opacity of
    the color. The first three numbers represent the amount of red, green, and blue
    (RGB) that will be used to create the color. The fourth number represents the
    opacity (or seen another way, the transparency) of the color. This is also referred
    to as the alpha channel (RGBA). The values above create a black background that
    is 100 percent opaque.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的四个数字定义了颜色及其透明度。前三个数字代表用于创建颜色的红色、绿色和蓝色（RGB）的量。第四个数字代表颜色的透明度（或者从另一个角度来看，透明度）。这通常被称为alpha通道（RGBA）。上面的值创建了一个100%不透明的黑色背景。
- en: All values in OpenGL have a range from 0 to 1\. This means that there will be
    many decimal values, known in C++ as floats. Thus, the range in C++ lingo is from
    `0.0f` to `1.0f`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中的所有值范围从0到1。这意味着会有很多小数，在C++中称为浮点数。因此，在C++术语中，范围是从`0.0f`到`1.0f`。
- en: C++ is different from many languages, which use integers or even hexadecimal
    numbers to express their ranges. For example, many other languages use a range
    of 0 to 255 for each color component. In these cases, integer 0 corresponds to
    `0.0f`, and integer 255 corresponds to `1.0f`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++与许多使用整数甚至十六进制数来表示其范围的许多语言不同。例如，许多其他语言使用0到255的范围来表示每个颜色分量。在这些情况下，整数0对应于`0.0f`，整数255对应于`1.0f`。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To convert an integer of range 0 to 255 to OpenGL's system, use the formula
    *(1/255) * value*, where value is the integer value you are trying to convert.
    Thus, to convert the number 50, you would calculate *(1/255) * 50*, which results
    in 0.1096.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要将范围在0到255之间的整数转换为OpenGL的系统，使用公式`(1/255) * value`，其中`value`是要转换的整数值。因此，要将数字50转换为，您将计算`(1/255)
    * 50`，结果为0.1096。
- en: The main entry point
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主入口点
- en: Every program has to have a starting point, known as the entry point. In our
    program, this is the `_tmain` function. We put this at the very end because C++
    expects the functions that are being used to have been defined before the function
    that calls them. There are various tricks around this, but we'll keep our examples
    simple and just always define `_tmain` as the last function in the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都必须有一个起始点，称为入口点。在我们的程序中，这是`_tmain`函数。我们将其放在代码的最后，因为C++期望被调用的函数在调用它们的函数之前已经定义。关于这一点有各种技巧，但我们将保持示例简单，并始终将`_tmain`定义为代码中的最后一个函数。
- en: 'When we start the program, there are a few things that have to be done to set
    up the environment to render OpenGL. Here is the anatomy of the `_tmain` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动程序时，有一些事情必须做来设置OpenGL渲染的环境。以下是`_tmain`函数的结构：
- en: '`glutCreateWindow("GL Fun")`: This function creates the window that will render
    the OpenGL content. We include the name of the program as a parameter.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glutCreateWindow("GL Fun")`: 这个函数创建了一个用于渲染OpenGL内容的窗口。我们将程序名称作为参数包含在内。'
- en: '`glutInitWindowSize(320, 320)`: This function initializes the size of the window.
    We have specified 320 pixels by 320 pixels. Feel free to try larger (or smaller)
    window sizes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glutInitWindowSize(320, 320)`: 这个函数初始化窗口的大小。我们指定了320像素乘以320像素。您可以自由尝试更大的（或更小的）窗口大小。'
- en: '`glutInitWindowPosition(50, 50)`: This function sets the position of the window''s
    upper-left corner in relation to the device''s screen. In this case, the window
    will start drawing 50 pixels from the left and 50 pixels from the top of the screen.
    Feel free to try other positions.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glutInitWindowPosition(50, 50)`: 这个函数设置窗口左上角相对于设备屏幕的位置。在这种情况下，窗口将从屏幕左侧和顶部各开始绘制50像素。您可以自由尝试其他位置。'
- en: '`glutDisplayFunc(update)`: Remember the previous chapter where we talked about
    the game loop? The game loop is the part of the program that runs over and over
    again (that is, every *frame*). We need to tell GLUT the name of the function
    that we want to run every frame. In this case, we are telling GLUT to use a function
    named `update` (described in the next section).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glutDisplayFunc(update)`: 记得之前章节中我们讨论的游戏循环吗？游戏循环是程序中反复运行的部分（即每一帧）。我们需要告诉GLUT我们想要在每一帧运行的函数的名称。在这种情况下，我们告诉GLUT使用名为`update`的函数（将在下一节中描述）。'
- en: '`initGL()`: This simply calls the `initGL` function that we described earlier.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initGL()`: 这只是调用我们之前描述的`initGL`函数。'
- en: '`glutMainLoop()`: This function starts the main game loop, which in turn will
    call our `update` function every frame. This essentially starts our program, which
    will run in an infinite loop until we close the program.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glutMainLoop()`: 这个函数启动主游戏循环，它反过来会每帧调用我们的`update`函数。这实际上启动了我们的程序，它将在无限循环中运行，直到我们关闭程序。'
- en: '`return 0`: This line is required by the `_tmain` function. It basically tells
    our system that the program has exited and everything is okay. This line of code
    won''t run until we exit the program.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return 0`: 这一行是`_tmain`函数所必需的。它基本上告诉我们的系统程序已退出且一切正常。此行代码将在我们退出程序之前不会运行。'
- en: The update function
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新函数
- en: 'The update function is called every frame. Any work that we want to do will
    have to be coded in this function. The update function currently has three lines
    of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数在每一帧都会被调用。我们想要执行的所有工作都必须在这个函数中编码。更新函数目前有三行代码：
- en: '`glClear(GL_COLOR_BUFFER_BIT)`: The `glClear` function resets the *render buffer*
    to the color that was specified earlier by the `glClearColor` function. The render
    buffer is a separate location in the memory where OpenGL renders objects before
    they are displayed on the screen. Later, when all of the render operations are
    completed, the contents of the buffer are displayed on the screen in one fast
    transfer.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glClear(GL_COLOR_BUFFER_BIT)`: `glClear` 函数将 *渲染缓冲区* 重置为之前由 `glClearColor`
    函数指定的颜色。渲染缓冲区是内存中一个独立的位置，OpenGL 在对象显示在屏幕上之前在这里渲染对象。稍后，当所有的渲染操作完成后，缓冲区的内容将快速传输到屏幕上。'
- en: '`drawPoints()`: This is a function that we wrote to display three points on
    the screen. Later, we will replace this line of code to draw other objects. This
    function is described in the next section.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawPoints()`: 这是一个我们编写的函数，用于在屏幕上显示三个点。稍后，我们将替换这一行代码以绘制其他对象。该函数将在下一节中描述。'
- en: '`glFlush()`: This function flushes the OpenGL buffer, including the back buffer
    that currently holds our render. As a result, the rendering buffer is flushed,
    and all of the contents are rendered to the device screen.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glFlush()`: 这个函数刷新 OpenGL 缓冲区，包括当前持有我们的渲染的后缓冲区。结果，渲染缓冲区被刷新，所有内容都被渲染到设备屏幕上。'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: OpenGL uses two buffers to draw. One is the screen buffer, which is what the
    player currently sees on the computer display. The other is the back buffer, which
    is where we create the objects that we intend to render in the next frame. Once
    we are done creating the render in the back buffer, we quickly swap the contents
    of the back buffer onto the current screen. This occurs so quickly that the player
    cannot detect the swap.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenGL 使用两个缓冲区进行绘制。一个是屏幕缓冲区，这是玩家目前在计算机显示器上看到的。另一个是后缓冲区，这是我们打算在下个帧中渲染的对象所在的地方。一旦我们在后缓冲区中完成创建渲染，我们就快速将后缓冲区的内容交换到当前屏幕上。这个过程发生得如此之快，以至于玩家无法检测到交换。
- en: Drawing the points
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制点
- en: 'The `drawPoints` function does the actual work of determining what to draw,
    and where to draw it. Here is what each line of code does:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawPoints` 函数执行确定绘制什么以及在哪里绘制的实际工作。以下是每行代码的作用：'
- en: '`glBegin(GL_POINTS)`: The call to `glBegin` tells OpenGL to prepare to render
    items to the screen. We also tell OpenGL what we want to render. In our example,
    we are directing OpenGL to interpret the data that we send it as individual points.
    Later, we will learn to render other objects, such as triangles using `GL_TRIANGLES`,
    or rectangles using `GL_QUADS`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glBegin(GL_POINTS)`: `glBegin` 调用告诉 OpenGL 准备将项目渲染到屏幕上。我们还告诉 OpenGL 我们想要渲染什么。在我们的示例中，我们指导
    OpenGL 解释我们发送给它的数据作为单独的点。稍后，我们将学习如何使用 `GL_TRIANGLES` 绘制三角形或使用 `GL_QUADS` 绘制矩形来渲染其他对象。'
- en: '`glColor3f(1.0f, 1.0f, 1.0f)`: As the name suggests, `glColor` sets the color
    of the item that is going to be rendered. Remember, OpenGL uses the RGB color
    system, so the color will be white (0, 0, 0 specified black).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glColor3f(1.0f, 1.0f, 1.0f)`: 如其名所示，`glColor` 设置将要渲染的项目颜色。记住，OpenGL 使用 RGB
    颜色系统，所以颜色将是白色（指定为黑色的是 0, 0, 0）。'
- en: '`glVertex2f(0.1f, -0.6f)`: Each point in OpenGL is known as a *vertex*. This
    code tells OpenGL to render a single point at the coordinates (`0.1, -0.6`). In
    this case, zero means the center of the screen, and one means one unit from the
    center. The settings for the camera determine exactly how far one unit from the
    center actually is on the screen. There are three `glVertex` calls in our example
    code, one for each of the points that we want to render to the screen.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glVertex2f(0.1f, -0.6f)`: 在 OpenGL 中，每个点都称为 *顶点*。这段代码告诉 OpenGL 在坐标 (`0.1,
    -0.6`) 处渲染一个单独的点。在这种情况下，零表示屏幕中心，一表示从中心的一个单位。相机的设置决定了从中心的一个单位实际上在屏幕上有多远。在我们的示例代码中，有三个
    `glVertex` 调用，每个调用对应于我们想要渲染到屏幕上的一个点。'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The names of OpenGL functions give you a clue as to how to use the function.
    For example, `glVertex2f` means that this function takes 2 parameters and they
    will be of type `float`. In comparison, the `glVertex3f` function takes three
    parameters of type `float`.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenGL 函数的命名为你如何使用该函数提供了线索。例如，`glVertex2f` 表示这个函数接受 2 个参数，并且它们将是 `float` 类型。相比之下，`glVertex3f`
    函数接受三个 `float` 类型的参数。
- en: '`glEnd()`: Just like all good things must come to an end, we have to tell OpenGL
    when we are done rendering. That is the purpose of the call to `glEnd`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glEnd()`: 就像所有美好的事物都必须有个结束一样，我们必须告诉 OpenGL 我们何时完成渲染。这就是调用 `glEnd` 的目的。'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You have probably noticed a lot of the use of the lower case letter f; this
    stands for *float*, meaning that a number that may contain a part after the decimal
    point (as opposed to an *integer*, which is always a whole number). So, a number,
    such as `0.0f`, is telling C++ to treat the number zero as a floating point number.
    OpenGL uses a similar naming convention for its functions. For example, the function
    `glVertex2f` indicates that the function requires two floating point numbers (in
    this case, the *x* and *y* coordinates of the point to render).
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到大量使用了小写字母 f；这代表 *float*，意味着一个可能包含小数部分的数字（与总是整数的 *integer* 相反）。所以，一个如
    `0.0f` 的数字告诉 C++ 将数字零视为浮点数。OpenGL 使用类似的命名约定为其函数命名。例如，函数 `glVertex2f` 表示该函数需要两个浮点数（在这种情况下，要渲染的点的
    *x* 和 *y* 坐标）。
- en: Running the program
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行程序
- en: 'Now that you have entered your code, it''s time to see it in action. When you
    run the program (**Debug** | **Start Debugging**), here is what you will see:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经输入了代码，是时候看到它的实际效果了。当你运行程序（**调试** | **开始调试**）时，你会看到以下内容：
- en: '![Running the program](img/8199OS_02_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![运行程序](img/8199OS_02_03.jpg)'
- en: You'll have to look at it closely, but if all went well, you should see three
    white points in the lower-right area of the screen. Congratulations! You have
    rendered your first OpenGL objects!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要仔细观察，但如果一切顺利，你应该能在屏幕的右下角看到三个白色点。恭喜！你已经渲染了你的第一个 OpenGL 对象！
- en: Hopefully, you have been able to follow the code. Think of `_tmain` as a manager
    that controls the program by setting everything up and then calling the `main`
    loop (just like we will do in our game). Then GLUT takes over and calls the `update`
    function every frame. The `update` function initializes the render buffer, draws
    objects to the render buffer, and then transfers the contents of the render buffer
    to the screen. In a game running at 60 frames per second, this entire operation
    will happen 60 times a second!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经能够跟随代码。将 `_tmain` 视为一个管理者，通过设置一切并调用 `main` 循环来控制程序（就像我们将在我们的游戏中做的那样）。然后
    GLUT 接管并每帧调用 `update` 函数。`update` 函数初始化渲染缓冲区，将对象绘制到渲染缓冲区，然后将渲染缓冲区的内容传输到屏幕。在一个每秒运行
    60 帧的游戏中，这个整个操作每秒会发生 60 次！
- en: Stretching your point
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉伸你的点
- en: 'Let''s see how easy it will be to modify GLFun to draw other objects. This
    time we will draw two lines. Add the following function to your code just under
    the `drawPoints` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修改 GLFun 以绘制其他对象有多容易。这次我们将画两条线。在 `drawPoints` 函数下方添加以下函数：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, go to the update function and replace `drawPoints` with a call to `drawLines`.
    The new `update` function will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 `update` 函数并将 `drawPoints` 替换为对 `drawLines` 的调用。新的 `update` 函数将看起来像这样：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that there are four `glVertex` calls. Each pair of vertices
    sets the beginning and ending points of a line. As there are four points defined,
    the result is that two lines are drawn.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有四个 `glVertex` 调用。每一对顶点设置了一条线的起始和结束点。由于定义了四个点，因此结果是画出了两条线。
- en: '![Stretching your point](img/8199OS_02_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![拉伸你的点](img/8199OS_02_04.jpg)'
- en: Getting primitive
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取原语
- en: Basic objects, such as points and lines, are called primitives. It would be
    pretty difficult to create everything out of points and lines, so OpenGL defines
    other primitive shapes that you can use to create more complicated objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本对象，如点和线，被称为原语。如果只用点和线来创建一切将会非常困难，所以 OpenGL 定义了其他原语形状，你可以使用它们来创建更复杂的对象。
- en: In this section, we will dig a little under the hood and find out how OpenGL
    actually creates more realistic images on your screen. It may surprise you that
    a single, geometric figure is used to create everything from the simplest to the
    most complex graphics. So, roll up your sleeves and get ready to get a little
    greasy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入底层，了解 OpenGL 如何在屏幕上创建更逼真的图像。可能会让你惊讶的是，一个单一的几何图形被用来创建从最简单到最复杂的图形。所以，卷起袖子，准备变得有点油腻。
- en: A triangle by any other name
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何名字的三角形
- en: 'Have you ever seen a geodesic dome? Although the dome appears to be spherical,
    it is actually built out of a combination of triangles. It turns out that triangles
    are very easy to put together in such a way that you can add a slight amount of
    curvature to the object. Each triangle can be attached at a slight angle to the
    others, allowing you to create a dome made out of flat triangles. Also, consider
    this: the smaller the triangle, the more convincing the end result!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你见过地理圆顶吗？尽管圆顶看起来是球形的，但它实际上是由三角形的组合构成的。结果是三角形很容易组合在一起，这样你就可以在物体上添加一点曲率。每个三角形可以以轻微的角度附着在其他的三角形上，这样你就可以用平面的三角形制作一个圆顶。此外，考虑这一点：三角形越小，最终结果就越令人信服！
- en: '![A triangle by any other name](img/8199OS_02_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![任何名称的三角形](img/8199OS_02_05.jpg)'
- en: The basic unit that is used to draw all modern graphics is the humble triangle.
    Graphic cards have been specifically engineered to be able to draw triangles—really
    small triangles—really fast. A typical graphics card can draw millions of triangles
    every second. Higher end cards reach billions of triangles per second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用来绘制所有现代图形的基本单位是谦逊的三角形。图形卡被特别设计成能够快速绘制三角形——非常小的三角形。典型的图形卡每秒可以绘制数百万个三角形。高端卡每秒可以达到数十亿个三角形。
- en: '![A triangle by any other name](img/8199OS_02_06a.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![任何名称的三角形](img/8199OS_02_06a.jpg)'
- en: Remember when we drew points and lines earlier? Each point had one vertex, and
    each line had two vertices. Of course, each triangle has three vertices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前画点和线的时候吗？每个点有一个顶点，每条线有两个顶点。当然，每个三角形有三个顶点。
- en: A primitive example
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个原始示例
- en: 'It''s time to take a look at some code in action. Add the following code after
    the `drawLines` function in the GLFun project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看一些代码的实际效果了。在 GLFun 项目中 `drawLines` 函数之后添加以下代码：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then change the middle line of the `update` function to call `drawSolidTriangle`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `update` 函数的中间行更改为调用 `drawSolidTriangle`：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the program, and you will see the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你会看到以下输出：
- en: '![A primitive example](img/8199OS_02_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![一个原始示例](img/8199OS_02_06.jpg)'
- en: You may notice a similarity between the code for `drawSolidTriangle` and `drawPoints`.
    Look closely at the code, and you will see that the three `glVertex` functions
    define the same three points. However, in this case we told OpenGL to draw triangles,
    not points. You should also take a look at the code and make sure you understand
    why the triangle is rendered blue.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 `drawSolidTriangle` 和 `drawPoints` 的代码之间有相似之处。仔细查看代码，你会看到三个 `glVertex`
    函数定义了相同的三个点。然而，在这种情况下，我们告诉 OpenGL 绘制三角形而不是点。你也应该查看代码，确保你理解为什么三角形被渲染成蓝色。
- en: 'Let''s take one more example. Add the following code below the `drawSolidTriangle`
    function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子。在 `drawSolidTriangle` 函数下面添加以下代码：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Be sure to change the middle line in update to call `drawGradientTriangle`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要在 `update` 函数的中间行中更改为调用 `drawGradientTriangle`：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program, and this is what you will see:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，这就是你将看到的内容：
- en: '![A primitive example](img/8199OS_02_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![一个原始示例](img/8199OS_02_07.jpg)'
- en: You will immediately notice that this triangle is filled with a gradient instead
    of a solid color. If you look closely at the code, you will see that a different
    color is being set for each vertex. OpenGL then takes care of interpolating the
    colors between each vertex.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立刻注意到这个三角形填充的是渐变色而不是纯色。如果你仔细查看代码，你会看到每个顶点都被设置了不同的颜色。OpenGL 然后负责在每个顶点之间插值颜色。
- en: From triangles to models
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从三角形到模型
- en: Triangles can be put together in an infinite number of ways to form almost any
    shape imaginable. It is important to understand that triangles are just geometry.
    Triangles are used to build the shape of your object. We call these shapes models.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形可以以无数种方式组合在一起，形成几乎任何可以想象到的形状。重要的是要理解三角形仅仅是几何学的一部分。三角形被用来构建物体的形状。我们把这些形状称为模型。
- en: Building a model using a single triangle at a time would be very time consuming,
    so 3D graphics programs, such as **Maya** and **Blender**, allow you to create
    models out more complex shapes (which are themselves built out of triangles).
    These models can then be loaded into your game and rendered by OpenGL. OpenGL
    literally sends a the list of points to form these triangles directly to the video
    card, which then creates and image out of them on the screen. We will see this
    process in action when we begin to deal with 3D game design.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一次构建一个三角形来构建模型会非常耗时，因此3D图形程序，如**Maya**和**Blender**，允许你创建更复杂的形状（这些形状本身是由三角形构成的）模型。然后可以将这些模型加载到你的游戏中，并由OpenGL渲染。OpenGL实际上将形成这些三角形的点列表直接发送到显卡，然后显卡在屏幕上创建图像。当我们开始处理3D游戏设计时，我们将看到这个过程在实际中的应用。
- en: Introducing textures
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍纹理
- en: Images in games are called textures. Textures allow us to use real world images
    to paint our world. Think about what it would take to create a dirt road. You
    could either color the triangles in exactly the right way to make the overall
    scene look like dirt, or you could apply an actual image (that is, a texture)
    of dirt to the triangles. Which of these do you think would look more realistic?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的图像被称为纹理。纹理允许我们使用现实世界的图像来绘制我们的世界。想想要创建一条土路需要什么。你可以选择用正确的颜色为三角形上色，使整个场景看起来像土，或者你可以将实际的土图像（即纹理）应用到三角形上。你认为哪种方式看起来更逼真？
- en: Using textures to fill the triangles
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理填充三角形
- en: 'Let''s say that you are going to paint your bedroom. You can either use paint
    to color the walls, or you could buy some wallpaper and put that on your walls.
    Using images to add color to our triangles is pretty much like using wallpaper
    to color our bedroom walls. The image is applied to the triangle, giving it a
    more complex appearance than what could be created by color alone:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你打算粉刷你的卧室。你可以选择用油漆给墙壁上色，或者你可以买一些壁纸并将其贴在墙上。使用图像为我们的三角形添加颜色，基本上就像用壁纸给我们的卧室墙壁上色一样。图像被应用到三角形上，使其外观比仅用颜色所能创造出的更加复杂：
- en: '![Using textures to fill the triangles](img/8199OS_02_09a.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_09a.jpg)'
- en: When we want to get really tricky, we use textures to fill the inside of our
    triangles instead of colors. A marble texture has been applied to the triangle
    in the preceding image. You could imagine using this technique to create a marble
    floor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要变得非常巧妙时，我们使用纹理来填充三角形的内部而不是颜色。前一张图像中的三角形已经应用了大理石纹理。你可以想象使用这种技术来创建大理石地板。
- en: 'Remember the car we were working with before? It didn''t look much like a triangle,
    did it? In fact, many real-world objects look more like rectangles than triangles:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前一直在处理的汽车吗？它看起来并不像三角形，对吧？事实上，许多现实世界中的物体看起来更像矩形而不是三角形：
- en: '![Using textures to fill the triangles](img/8199OS_02_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_10.jpg)'
- en: 'It turns out that that all the textures that we use in games are actually rectangles.
    Imagine that the car that we have been dealing with is actually embedded inside
    an invisible rectangle, depicted in the following image as light gray:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们在游戏中使用的所有纹理实际上都是矩形。想象一下，我们一直在处理的汽车实际上嵌入在一个不可见的矩形中，如下面的图像所示，以浅灰色表示：
- en: '![Using textures to fill the triangles](img/8199OS_02_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_11.jpg)'
- en: Most graphic programs use a checkerboard background to indicate the areas of
    the image that are transparent.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图形程序使用棋盘格背景来指示图像中透明的区域。
- en: '![Using textures to fill the triangles](img/8199OS_02_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_12.jpg)'
- en: Using rectangles for all of our shapes solves one big problem that you might
    not have thought of earlier. If you recall, it was very important to position
    the car at exactly (5, 5). To do so, we decided to place the bottom-left corner
    of the car at point (5, 5).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩形来绘制我们所有的形状解决了你可能之前没有考虑过的一个大问题。如果你还记得，将汽车放置在精确的（5，5）位置非常重要。为了做到这一点，我们决定将汽车的左下角放置在点（5，5）。
- en: '![Using textures to fill the triangles](img/8199OS_02_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_13.jpg)'
- en: Looking at the car, it is actually a little difficult to figure out exactly
    where the bottom-left corner would be. Is it the lower left corner of the bumper,
    the tire, or somewhere else?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看着汽车，实际上很难确定左下角的确切位置。是保险杠的左下角、轮胎还是其他地方？
- en: '![Using textures to fill the triangles](img/8199OS_02_14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_14.jpg)'
- en: By embedding the car inside of a rectangle, as we just discussed, the problem
    is immediately solved.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的那样，通过将汽车嵌入矩形中，问题立即得到解决。
- en: '![Using textures to fill the triangles](img/8199OS_02_15.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理填充三角形](img/8199OS_02_15.jpg)'
- en: A matter of reference
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考问题
- en: When working with a texture, it is very important to know what point is being
    used as a reference, usually known as the pivot point. In the following images,
    a black dot is used to represent the pivot point. The pivot point affects two
    critical issues. First, the pivot point determines exactly where the image will
    be placed on the screen. Second, the pivot point is the point on which the image
    will pivot when rotated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理纹理时，知道用作参考的点非常重要，通常被称为旋转中心点。在以下图像中，一个黑点被用来表示旋转中心点。旋转中心点影响两个关键问题。首先，旋转中心点决定了图像将在屏幕上的确切位置。其次，旋转中心点是图像旋转时围绕的点。
- en: 'Compare the two scenarios depicted in the following images:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 比较以下图像中描绘的两个场景：
- en: '![A matter of reference](img/8199OS_02_18.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![参考问题](img/8199OS_02_18.jpg)'
- en: The pivot point for the car in the preceding image has been set to the bottom-left
    corner of the image. The car has been rotated 90 degrees counter-clockwise.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图像中汽车的旋转中心点被设置为图像的左下角。汽车已经逆时针旋转了90度。
- en: '![A matter of reference](img/8199OS_02_19.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![参考问题](img/8199OS_02_19.jpg)'
- en: The pivot point for the car in the preceding image has been set to the center
    of the image. The car has been rotated 90 degrees counter-clockwise. Notice how
    the pivot point affects not only how the car is rotated but also its final position
    in relation to its original position after the rotation is completed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图像中汽车的旋转中心点被设置为图像的中心。汽车已经逆时针旋转了90度。注意旋转中心点不仅影响汽车的旋转方式，还影响旋转完成后与原始位置的关系。
- en: Hanging out in the quad
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在广场上闲逛
- en: So, are you confused yet? First, I tell you that the most basic shape used to
    create images is a triangle, and then I tell you that all textures are actually
    rectangles. Which one is it?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你现在是不是感到困惑了？首先，我告诉你，用于创建图像的最基本形状是三角形，然后我告诉你，所有纹理实际上都是矩形。哪一个是正确的？
- en: 'Just then, your high-school geometry teacher silently walks into the room,
    goes up to the chalkboard that just magically appeared on your wall, and draws
    something like the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这时，你的高中几何老师默默地走进教室，走到刚刚神奇地出现在你墙上的黑板前，画出了以下这样的图：
- en: '![Hanging out in the quad](img/8199OS_02_21.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![在四边形中闲逛](img/8199OS_02_21.jpg)'
- en: 'Of course! You suddenly realize that two triangles can be fit together to form
    a rectangle. In fact, this arrangement is so useful that we have given it a name:
    **quad**.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！你突然意识到两个三角形可以组合在一起形成一个矩形。事实上，这种排列非常有用，以至于我们给它起了一个名字：**四边形**。
- en: When it comes to 2D graphics, the quad is the king.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到2D图形时，四边形是王者。
- en: Coding the quad
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码四边形
- en: 'It''s time to take a look at some code. Add the following code beneath the
    `drawGradientTriangle` function in `GLFun`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看一些代码了。在`GLFun`中的`drawGradientTriangle`函数下方添加以下代码：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As usual, change the middle line in update to call `drawQuad`. Run the program,
    and you will get a pretty green square, er quad! It's important to note that the
    points are defined in order starting from the upper-left corner and then moving
    counter-clockwise in order.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，将更新中的中间行改为调用`drawQuad`。运行程序，你将得到一个漂亮的绿色正方形，或者说是一个四边形！需要注意的是，点是从左上角开始定义的，然后逆时针顺序移动。
- en: '![Coding the quad](img/8199OS_02_22.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![编码四边形](img/8199OS_02_22.jpg)'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order that the points are defined in is known as *winding*. By default,
    a counter-clockwise winding tells OpenGL that the side facing out is the side
    that is considered the front. This helps determine, among other things, whether
    this face should be lit, and it becomes even more significant when we begin working
    in 3D. As it turns out, GLUT simplifies our life so that it doesn't matter if
    we use clockwise or counter-clockwise winding when using GLUT.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 点的定义顺序被称为*环绕*。默认情况下，逆时针环绕告诉OpenGL，面向外的面被认为是正面。这有助于确定许多事情，例如是否应该照亮这个面。当我们开始3D工作时，这一点变得更加重要。实际上，GLUT简化了我们的工作，使得在使用GLUT时，无论是顺时针还是逆时针环绕都不重要。
- en: Rendering a texture
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染纹理
- en: 'Rendering a texture consist of two steps: loading the image and rendering the
    image using an OpenGL primitive. Our final achievement in this chapter will be
    to modify GLFun so that it will render a texture using a quad.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染纹理包括两个步骤：加载图像和使用OpenGL原语渲染图像。我们本章的最终目标将是修改GLFun，使其能够使用四边形渲染纹理。
- en: Loading the texture
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载纹理
- en: Our first step is to create a function to load a texture. As it turns out, this
    isn't all that easy. So, I'm going to give you the code for a function that loads
    a 24-bit BMP file, and we'll treat it like a black box that you can use in your
    own code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个加载纹理的函数。实际上，这并不那么容易。所以，我将给你一个加载24位BMP文件的函数代码，我们将它视为一个黑盒，你可以在自己的代码中使用它。
- en: 'Add this code to the top of your existing `GLFun` code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到现有`GLFun`代码的顶部：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add these lines of code to `initGL`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`initGL`中：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are not going to dissect this piece of code line by line. In brief, it opens
    the image file, extracts the first 54 bytes of the file (the bmp header data),
    and stores the rest of the file as image data. A few OpenGL calls are made to
    assign this data to an OpenGL texture and that's it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐行分析这段代码。简而言之，它打开图像文件，提取文件的前54个字节（bmp头数据），并将文件的其余部分作为图像数据存储。进行了一些OpenGL调用，将这些数据分配给OpenGL纹理，然后完成。
- en: 'You need to have a call that loads the texture in, so add this line of code
    to `_tmain` just after the call to `initGL`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有一个调用加载纹理的函数，所以请将此行代码添加到`_tmain`中，在调用`initGL`之后：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, replace `car.bmp` with the file that you want to load in. Ensure
    that you have placed the appropriate graphic files in the source code folder.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将`car.bmp`替换为你想要加载的文件。确保你已经将适当的图形文件放置在源代码文件夹中。
- en: Texture wrapping
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理包裹
- en: In order to display a texture on the screen, OpenGL maps the texture onto another
    primitive. This process is known as texture wrapping. As textures are rectangular,
    it makes sense to map the texture onto a quad.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上显示纹理，OpenGL将纹理映射到另一个原语上。这个过程被称为纹理包裹。由于纹理是矩形的，将其映射到四边形上是有意义的。
- en: 'The following image shows a texture the way that OpenGL sees it: a rectangle
    with four texture coordinates:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了OpenGL如何看到纹理：一个具有四个纹理坐标的矩形：
- en: '![Texture wrapping](img/8199OS_02_23.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![纹理包裹](img/8199OS_02_23.jpg)'
- en: The upper-left is texture coordinate **0, 0**. The lower-right is texture coordinate
    **1, 1**. You should be able to identify the texture coordinates of the other
    corners.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 左上角是纹理坐标**0, 0**。右下角是纹理坐标**1, 1**。你应该能够识别其他角落的纹理坐标。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It might make it easier to conceptualize OpenGL numbers if you convert them
    to percentage, where 0 is zero percent and 1 is 100 percent. For example, you
    can think of the lower-left corner as being zero percent of the width of the texture
    and one-hundred percent of the height of the texture.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将OpenGL数字转换为百分比可能会更容易理解，其中0表示零百分比，1表示100百分比。例如，你可以将左下角视为纹理宽度的零百分比和纹理高度的百分之百。
- en: 'In order to render a texture, we overlay it (or wrap it) onto a quad. So, let''s
    say we have the following quad defined:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染纹理，我们将其（或包裹）叠加到四边形上。所以，假设我们定义了以下四边形：
- en: '![Texture wrapping](img/8199OS_02_24.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![纹理包裹](img/8199OS_02_24.jpg)'
- en: 'We could map the texture coordinates to the quad coordinates:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将纹理坐标映射到四边形坐标：
- en: '| Texture Coordinate | Maps to | Quad Coordinate |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 纹理坐标 | 映射到 | 四边形坐标 |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0, 0 |   | 0, 0 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0, 0 |   | 0, 0 |'
- en: '| 1, 0 |   | 1, 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1, 0 |   | 1, 0 |'
- en: '| 1, 0 |   | 1, 0 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 1, 0 |   | 1, 0 |'
- en: '| 0, 1 |   | 0, 1 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 0, 1 |   | 0, 1 |'
- en: 'The following figure shows this graphically:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了这一点：
- en: '![Texture wrapping](img/8199OS_02_25.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![纹理包裹](img/8199OS_02_25.jpg)'
- en: In its simplest form, texture wrapping is the process of mapping the corners
    of a texture to the corners of a quad.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，纹理包裹是将纹理的角落映射到四边形的角落的过程。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You will see texture wrapping also referred to as *uv* wrapping. I always tried
    to figure out what *uv* meant! Here''s the real story: *x* and *y* were already
    used to refer to the quad coordinates, and we had to have something else to call
    the texture coordinates, so some bright person said, "Let''s use u and v!"'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到纹理包裹也被称为*uv*包裹。我一直试图弄清楚*uv*代表什么！以下是真实的故事：*x*和*y*已经被用来指代四边形坐标，我们需要有其他东西来称呼纹理坐标，所以某个聪明的人说：“让我们用u和v！”
- en: Creating a textured quad
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建纹理四边形
- en: 'Now, we will write the code to render a textured quad. Add the following function
    to the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写代码来渲染一个纹理四边形。将以下函数添加到代码中：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is what this code does:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: '`glBindTexture(GL_TEXTURE_2D, texture)`: Even if we have thousands of textures
    in a game, OpenGL can only work with one texture a time. The call to `glBindTexture`
    tells OpenGL which texture we are working with right now. Each time a texture
    is created, OpenGL assigns a number to that texture, called the texture handle.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glBindTexture(GL_TEXTURE_2D, texture)`: 即使在一个游戏中我们有成千上万的纹理，OpenGL一次也只能处理一个纹理。`glBindTexture`的调用告诉OpenGL我们现在正在使用哪个纹理。每次创建纹理时，OpenGL都会为该纹理分配一个数字，称为纹理句柄。'
- en: When we loaded our bitmap, we used the `glGenTextures(1, &texture)` command,
    which instructed OpenGL to generate one texture and save the handle into the variable
    called texture. We then pass this value into the `glBindTexture` function, along
    with a flag that tells OpenGL that we are working with a 2D texture.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们加载位图时，我们使用了`glGenTextures(1, &texture)`命令，该命令指示OpenGL生成一个纹理并将句柄保存到名为texture的变量中。然后我们将此值传递给`glBindTexture`函数，同时传递一个标志告诉OpenGL我们正在处理一个2D纹理。
- en: '`glTexCoord2d(0.0, 0.0); glVertex2d(0.0, 0.0)`: We put these two lines together
    because they work together. You should recognize the call to `glVertex2d`. This
    function tells OpenGL how to wrap the texture onto the quad (you should also recognize
    that we are drawing a quad because we set that up in the previous line of code).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glTexCoord2d(0.0, 0.0); glVertex2d(0.0, 0.0)`: 我们将这两行放在一起，因为它们是协同工作的。你应该能认出`glVertex2d`的调用。这个函数告诉OpenGL如何将纹理包裹到四边形上（你也应该能认出我们正在绘制一个四边形，因为我们已经在上一行代码中设置了这一点）。'
- en: 'Each call to `glTexCoord2d` defines a texture coordinate. The very next line
    of code maps the texture coordinate to a quad coordinate. The order is essential:
    first define a texture coordinate, then define the corresponding quad coordinate.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`glTexCoord2d`定义一个纹理坐标。紧接着的下一行代码将纹理坐标映射到四边形坐标。顺序至关重要：首先定义纹理坐标，然后定义相应的四边形坐标。
- en: 'By the way, don''t forget to replace the middle line of code in update with
    the following line of code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，别忘了在update中的中间代码行替换为以下代码行：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, run the program!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序！
- en: '![Creating a textured quad](img/8199OS_02_26.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建纹理四边形](img/8199OS_02_26.jpg)'
- en: Putting the pieces together
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将碎片组合在一起
- en: 'The following image is a composite that illustrates most of the concepts we
    have covered so far. See if you can you identify the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是一个组合，展示了我们迄今为止所涵盖的大部分概念。看看你是否能识别以下内容：
- en: The transparent areas
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明区域
- en: The triangles
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形
- en: The vertices
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点
- en: The pivot point
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轴心点
- en: The texture
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理
- en: The quad
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四边形
- en: '![Putting the pieces together](img/8199OS_02_27.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![将碎片组合在一起](img/8199OS_02_27.jpg)'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has covered the core concepts that are required to display images
    on your screen. We started by discussing the OpenGL coordinate system for a 2D
    game. The coordinate system allows you to place objects on the screen. This was
    followed by a discussion about the camera, OpenGL's way of viewing objects that
    appear on your screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在屏幕上显示图像所需的核心概念。我们首先讨论了2D游戏的OpenGL坐标系。坐标系允许你在屏幕上放置对象。随后讨论了相机，这是OpenGL查看屏幕上出现的对象的方式。
- en: Next, you learned how triangles and quads are used to create simple graphics,
    and how textures can be applied to these primitives to render 2D images to the
    screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何使用三角形和四边形来创建简单的图形，以及如何将这些纹理应用到这些原语上，以将2D图像渲染到屏幕上。
- en: You could finally see an image on your screen that has been rendered by OpenGL.
    As they say, a picture is worth a thousand lines of code!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终可以在屏幕上看到OpenGL渲染的图像。正如他们所说，一张图片胜过千言万语！
- en: In the next chapter, you will learn how to turn your still photography into
    moving pictures through the wonder of animation!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过动画的奇妙之处将你的静态摄影变成动态画面！
