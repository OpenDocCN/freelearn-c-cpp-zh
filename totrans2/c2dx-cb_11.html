<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Taking Advantages</h1></div></div></div><p>The following topics will be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using encrypted sprite sheets</li><li class="listitem" style="list-style-type: disc">Using encrypted zip files</li><li class="listitem" style="list-style-type: disc">Using encrypted SQLite files</li><li class="listitem" style="list-style-type: disc">Creating Observer Pattern</li><li class="listitem" style="list-style-type: disc">Networking with HTTP</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Introduction</h1></div></div></div><p>Until now, we have explained basic technical information in Cocos2d-x. It supports the development of games on a smartphone. Actually, you can create your original games using basic functions of Cocos2d-x. However, if your game is a major hit, cheaters might attempt to crack the code. Therefore, there are cases where encryption is needed to prevent unauthorized access to your game data. Encryption is an important aspect in game development because it helps you to protect your code and prevent people from ruining the overall experience of the game, and it also prevents illegal hacking of game. In this chapter, you will learn how to encrypt your game resources.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Using encrypted sprite sheets</h1></div></div></div><p>It is pretty easy for<a id="id409" class="indexterm"/> a hacker to extract resource files from the application. This is a huge concern for copyright. Sprite sheets can be encrypted very easily using <code class="literal">TexturePacker</code>. In this recipe, you will learn how to encrypt your sprites to protect them from hackers and cheaters.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec232"/>How to do it...</h2></div></div></div><p>To encrypt sprite sheets using <code class="literal">TexturePacker</code>, you need to set it on the left pane of <code class="literal">TexturePacker</code>. Then, you need to follow the steps written here to successfully encrypt your sprite.</p><div><ol class="orderedlist arabic"><li class="listitem">Change the <a id="id410" class="indexterm"/>Texture format to <code class="literal">zlib compr. PVR(.pvr.ccz, Ver.2)</code></li><li class="listitem">Click on the <strong>ContentProtection</strong> icon, and you will see the additional window in which to set the password.</li><li class="listitem">Type the encryption key in the text input area as shown in the following screenshot. You can type in your favorite key. However, it is difficult to type in 32 hex digits and thus, you can just click on the <strong>Create new key</strong> button. After clicking it, you will find that it automatically inputs the <strong>Encryption key</strong>.<div><img src="img/B0561_11_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Take a note of this encryption key. This is the key you will need to decrypt the files that are encrypted.</li><li class="listitem">Finally, you can publish the encrypted sprite sheet.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec233"/>How it works...</h2></div></div></div><p>Now, let's have a<a id="id411" class="indexterm"/> look on how to use these encrypted sprite sheets.</p><div><ol class="orderedlist arabic"><li class="listitem">Add the encrypted sprite sheet to your project as shown in the following image:<div><img src="img/B0561_11_02.jpg" alt="How it works..."/></div></li><li class="listitem">Include the <code class="literal">ZipUtils</code> class in <code class="literal">HelloWorld.cpp</code> to decrypt.<div><pre class="programlisting">#include "ZipUtils.h"</pre></div></li><li class="listitem">Set the encrypting key that is used for encryption by <code class="literal">TexturePacker</code>.<div><pre class="programlisting">ZipUtils::setPvrEncryptionKey (0x5f2c492e, 0x635eaaf8, 0xe5a4ee49, 0x32ffe0cf);</pre></div></li><li class="listitem">Finally, the<a id="id412" class="indexterm"/> sprite is created using the encrypted sprite sheet.<div><pre class="programlisting">Size visibleSize = Director::getInstance()- &gt;getVisibleSize();
Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();

SpriteFrameCache::getInstance()- &gt;addSpriteFramesWithFile("res/encrypted.plist");
auto sprite = Sprite::createWithSpriteFrameName("run_01.png");
sprite-&gt;setPosition(Vec2(visibleSize/2)+origin);
this-&gt;addChild(sprite);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec234"/>There's more…</h2></div></div></div><p>The application has a lot of sprite sheets normally. You can use each encryption key per sprite sheet. But this might create some confusion. You need to use the same key in all the sprite sheets in your application. The first time, you need to click on the <strong>Create new key</strong> button to create the encryption key. Then, you need to click on the <strong>Save as global key</strong> button to save the encryption key as the global key. Next time, when you create a new encrypted sprite sheet, you can set this encryption key as a global key by clicking on the <strong>Use global key</strong> button.</p><p>Now, we will move on to understanding how to check the encrypted sprite sheets. The encrypted sprite sheet's extension is <code class="literal">.ccz</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">Double-click the encrypted file that has the <code class="literal">.ccz</code> extension.</li><li class="listitem">Launch Texture Packer and you will see the window where you need to enter the decryption key, as shown in the following screenshot:<div><img src="img/B0561_11_03.jpg" alt="There's more…"/></div></li><li class="listitem">Enter the<a id="id413" class="indexterm"/> decryption key or click on the <strong>Use global key</strong> button. If you have saved the key as the global key, then click on the <strong>OK</strong> button.</li><li class="listitem">If the key is the correct key, you will see the sprite sheet as shown in the preceding screenshot:</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Using encrypted zip files</h1></div></div></div><p>In a smartphone,  the<a id="id414" class="indexterm"/> game frequently downloads a <code class="literal">zip</code> file from the server to update resources. These assets are generally the main targets for hackers. They can decode these assets to manipulate information in a game system. Hence, security for these assets is very important. In this case, <code class="literal">zip</code> is encrypted to protect against cheaters. In this recipe, you will learn how to unzip an encrypted <code class="literal">zip</code> file with a password.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec235"/>Getting ready</h2></div></div></div><p>Cocos2d-x has an unzip library. However, encryption/decryption is disabled in this library. That's why we have to enable the crypt option in <code class="literal">unzip.cpp</code>. This file's path is <code class="literal">cocos2d/external/unzip/unzip.cpp</code>. You will have to comment out line number 71 of <code class="literal">unzip.cpp</code> to enable the crypt option.</p><div><pre class="programlisting">//#ifndef NOUNCRYPT
//        #define NOUNCRYPT
//#endif</pre></div><p>When we tried to build in Cocos2d-x version 3.7, an error occurred in <code class="literal">unzip.h</code> in line 46, as shown in the following code:</p><div><pre class="programlisting">#include "CCPlatformDefine.h"</pre></div><p>You have to edit the following code to remove this error, as shown:</p><div><pre class="programlisting">#include "platform/CCPlatformDefine.h"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec236"/>How to do it...</h2></div></div></div><p>First, include <a id="id415" class="indexterm"/>the <code class="literal">unzip.h</code> file to use the unzip library in <code class="literal">HelloWorld.cpp</code> as shown in the following code:</p><div><pre class="programlisting">#include "external/unzip/unzip.h"</pre></div><p>Next, let's try to unzip the encrypted zip file with the password. This can be done by adding the following code in <code class="literal">HelloWorld</code>.cpp:</p><div><pre class="programlisting">#define BUFFER_SIZE    8192
#define MAX_FILENAME   512

bool HelloWorld::uncompress(const char* password)
{
    // Open the zip file
    std::string outFileName = FileUtils::getInstance()- 
    &gt;fullPathForFilename("encrypt.zip"); 
    unzFile zipfile = unzOpen(outFileName.c_str()); 
    int ret = unzOpenCurrentFilePassword(zipfile, password); 
    if (ret!=UNZ_OK) { CCLOG("can not open zip file %s", outFileName.c_str()); 
        return false;
    }

    // Get info about the zip file
    unz_global_info global_info;
    if (unzGetGlobalInfo(zipfile, &amp;global_info) != UNZ_OK) {
        CCLOG("can not read file global info of %s", 
        outFileName.c_str());
        unzClose(zipfile);
        return false;
    }

    CCLOG("start uncompressing");

    // Loop to extract all files.
    uLong i;
    for (i = 0; i &lt; global_info.number_entry; ++i) {
        // Get info about current file.
        unz_file_info fileInfo;
        char fileName[MAX_FILENAME];
        if (unzGetCurrentFileInfo(zipfile, &amp;fileInfo, fileName, 
        MAX_FILENAME, nullptr, 0, nullptr,  0) != UNZ_OK) {
            CCLOG("can not read file info");
            unzClose(zipfile);
            return false;
        }

        CCLOG("filename = %s", fileName);

        unzCloseCurrentFile(zipfile);

        // Goto next entry listed in the zip file.
        if ((i+1) &lt; global_info.number_entry) {
            if (unzGoToNextFile(zipfile) != UNZ_OK) {
                CCLOG("can not read next file");
                unzClose(zipfile);
                return false;
            }
        }
    }

    CCLOG("end uncompressing");
    unzClose(zipfile);

    return true;
}</pre></div><p>Finally, you can unzip the encrypted zip file to use this method by specifying the password. If the password is <code class="literal">cocos2d-x</code>, you can unzip with the following code:</p><div><pre class="programlisting">this-&gt;uncompress("cocos2d-x");</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec237"/>How it works...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open the <a id="id416" class="indexterm"/>encrypted zip file using the <code class="literal">unzOpen</code> function, as shown:<div><pre class="programlisting">unzFile zipfile = unzOpen(outFileName.c_str());</pre></div></li><li class="listitem">After opening it with the <code class="literal">unzOpen</code> function, open it again using the <code class="literal">unzOpenCurrentFilePassword</code> function, as shown here:<div><pre class="programlisting">int ret = unzOpenCurrentFilePassword(zipfile, password);
if (ret!=UNZ_OK) {
    CCLOG("can not open zip file %s", outFileName.c_str());
    return false;
}</pre></div></li><li class="listitem">After that, you<a id="id417" class="indexterm"/> can continue in the same way that is used to unzip an unencrypted zip file.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec87"/>Using encrypted SQLite files</h1></div></div></div><p>We often use SQLite to<a id="id418" class="indexterm"/> save the user data or game data. SQLite is a  powerful and useful database. However, there is a database file in your game's sand box. Cheaters will get it from your game and they will edit it to cheat. In this recipe, you will learn how to encrypt your SQLite and prevent cheaters from editing it.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec238"/>Getting ready</h2></div></div></div><p>We will use the <code class="literal">wxSqlite</code> library to encrypt SQLite. This is free software. Firstly, you need to install <code class="literal">wxSqlite</code> in Cocos2d-x and edit some code and set files in Cocos2d-x.</p><div><ol class="orderedlist arabic"><li class="listitem">Download the<a id="id419" class="indexterm"/> <code class="literal">wxSqlite3</code> project's zip file. Visit the following url: <a class="ulink" href="http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download">http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download</a></li><li class="listitem">Expand the zip file.</li><li class="listitem">Create a new folder called <code class="literal">wxsqlite</code> under <code class="literal">cocos2d/external</code>.</li><li class="listitem">Copy <code class="literal">sqlite3/secure/src</code> after expanding the folder to <code class="literal">cocos2d/external/wxsqlite</code> as shown in the following screenshot:<div><img src="img/B0561_11_04.jpg" alt="Getting ready"/></div></li><li class="listitem">Add <code class="literal">sqlite3.h</code> and <code class="literal">sqlite3secure.c</code> in <code class="literal">wxsqlite/src</code> that you added in step 4 to your project, as shown in the following screenshot:<div><img src="img/B0561_11_05.jpg" alt="Getting ready"/></div></li><li class="listitem">Add <code class="literal">-DSQLITE_HAS_CODEC</code> to <code class="literal">Other C Flags</code> in <strong>Build Settings</strong> of Xcode, as <a id="id420" class="indexterm"/>shown in the following screenshot:<div><img src="img/B0561_11_06.jpg" alt="Getting ready"/></div></li><li class="listitem">Create a new file called <code class="literal">Android.mk</code> in <code class="literal">cocos2d/external/wxsqlite</code>, as shown in the following code:<div><pre class="programlisting">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := wxsqlite3_static
LOCAL_MODULE_FILENAME := libwxsqlite3
LOCAL_CFLAGS += -DSQLITE_HAS_CODEC
LOCAL_SRC_FILES := src/sqlite3secure.c
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/src
LOCAL_C_INCLUDES := $(LOCAL_PATH)/src
include $(BUILD_STATIC_LIBRARY)</pre></div></li><li class="listitem">Edit <code class="literal">Android.mk</code> in <code class="literal">cocos2d/cocos/storage/local-storage</code>, as shown in the following code:<div><pre class="programlisting">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE := cocos_localstorage_static

LOCAL_MODULE_FILENAME := liblocalstorage

LOCAL_SRC_FILES := LocalStorage.cpp


LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/..


LOCAL_C_INCLUDES := $(LOCAL_PATH)/../..

LOCAL_CFLAGS += -Wno-psabi
LOCAL_CFLAGS += -DSQLITE_HAS_CODEC
LOCAL_EXPORT_CFLAGS += -Wno-psabi

LOCAL_WHOLE_STATIC_LIBRARIES := cocos2dx_internal_static
LOCAL_WHOLE_STATIC_LIBRARIES += wxsqlite3_static

include $(BUILD_STATIC_LIBRARY)

$(call import-module,.)</pre></div></li><li class="listitem">Edit <code class="literal">LocalStorage.cpp</code> in <code class="literal">cocos2d/cocos/storage/local-storage</code>. Comment<a id="id421" class="indexterm"/> out line 33 and line 180, as shown in the following code.<p>
<code class="literal">LocalStorage.cpp</code> line33:</p><div><pre class="programlisting">//#if (CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID)</pre></div><p>
<code class="literal">LocalStorage.cpp</code> line180:</p><div><pre class="programlisting">//#endif // #if (CC_TARGET_PLATFORM != CC_PLATFORM_ANDROID)</pre></div></li><li class="listitem">Edit <code class="literal">Android.mk</code> in <code class="literal">proj.andorid/jni</code>, as shown in the following code:<div><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                   ../../Classes/HelloWorldScene.cpp \
                   ../../cocos2d/external/wxsqlite/src/sqlite3secure.c

LOCAL_C_INCLUDES := $(LOCAL_PATH)/../../Classes
LOCAL_C_INCLUDES += $(LOCAL_PATH)/../../cocos2d/external/wxsqlite/src/
LOCAL_CFLAGS += -DSQLITE_HAS_CODEC</pre></div></li></ol></div><p>After this, SQLite is encrypted and can be used in your project.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec239"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">You have <a id="id422" class="indexterm"/>to include <code class="literal">sqlite3.h</code> to use SQLite APIs.<div><pre class="programlisting">#include "sqlite3.h"</pre></div></li><li class="listitem">Create the encrypted database, as shown in the following code:<div><pre class="programlisting">std::string dbname = "data.db";
std::string path = FileUtils::getInstance()-&gt;getWritablePath() + dbname;
CCLOG("%s", path.c_str());

sqlite3 *database = nullptr;
if ((sqlite3_open(path.c_str(), &amp;database) != SQLITE_OK)) {
    sqlite3_close(database);
    CCLOG("open error");
} else {
    const char* key = "pass_phrase";
    sqlite3_key(database, key, (int)strlen(key));
    
    // sql: create table
    char create_sql[] = "CREATE TABLE sample ( "
    "               id     INTEGER PRIMARY KEY, "
    "               key    TEXT    NOT NULL,    "
    "               value  INTEGER NOT NULL     "
    "             )                             ";
    
    // create table
    sqlite3_exec(database, create_sql, 0, 0, NULL);
    
    // insert data
    char insert_sql[] = "INSERT INTO sample ( id, key, value )"
    "            values (%d, '%s', '%d')     ";
    
    char insert_record[3][256];
    sprintf(insert_record[0],insert_sql,0,"test",300);
    sprintf(insert_record[1],insert_sql,1,"hoge",100);
    sprintf(insert_record[2],insert_sql,2,"foo",200);
    
    for(int i = 0; i &lt; 3; i++ ) {
        sqlite3_exec(database, insert_record[i], 0, 0, NULL);
    }
    
    sqlite3_reset(stmt);
    sqlite3_finalize(stmt);
    sqlite3_close(database);
}</pre></div></li><li class="listitem">Select the<a id="id423" class="indexterm"/> data from the encrypted database, as shown in the following code:<div><pre class="programlisting">std::string dbname = "data.db";
std::string path = FileUtils::getInstance()-&gt;getWritablePath() + dbname;
CCLOG("%s", path.c_str());

sqlite3 *database = nullptr;
if ((sqlite3_open(path.c_str(), &amp;database) != SQLITE_OK)) {
    sqlite3_close(database);
    CCLOG("open error");
} else {
    const char* key = "pass_phrase";
    sqlite3_key(database, key, (int)strlen(key));
    
    // select data
    sqlite3_stmt *stmt = nullptr;
    
    std::string sql = "SELECT value FROM sample WHERE key='test'";
    if (sqlite3_prepare_v2(database, sql.c_str(), -1, &amp;stmt, NULL) == SQLITE_OK) {
        if (sqlite3_step(stmt) == SQLITE_ROW) {
            int value = sqlite3_column_int(stmt, 0);
            CCLOG("value = %d", value);
        } else {
            CCLOG("error , error=%s", sqlite3_errmsg(database));
        }
    }
    
    sqlite3_reset(stmt);
    sqlite3_finalize(stmt);
    sqlite3_close(database);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec240"/>How it works...</h2></div></div></div><p>Firstly, you have to create the encrypted database with the <code class="literal">pass</code> phrase. To create it, follow these three steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <a id="id424" class="indexterm"/>database normally.</li><li class="listitem">Next, set the pass phrase using the <code class="literal">sqlite3_key</code> function.<div><pre class="programlisting">const char* key = "pass_phrase";
sqlite3_key(database, key, (int)strlen(key));</pre></div></li><li class="listitem">Finally, execute sql to create tables.</li></ol></div><p>After this, you will need the encrypted database file in the application. You can get it from the path that was printed by CCLOG.</p><p>To select data from there, the same method is used. You can get data from the encrypted database using the same pass phrase after opening the database.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec241"/>There's more…</h2></div></div></div><p>You must be wondering whether this database was really encrypted. So let's check it. Open the database using the command line and executing the command as shown:</p><div><pre class="programlisting">
<strong>$ sqlite3 data.db </strong>
<strong>SQLite version 3.8.4.3 2014-04-03 16:53:12</strong>
<strong>Enter ".help" for usage hints.</strong>
<strong>sqlite&gt; .schema</strong>
<strong>Error: file is encrypted or is not a database</strong>
<strong>sqlite&gt;</strong>
</pre></div><p>If the database is encrypted, you will not be able to open it and an error message will pop up, as shown:</p><div><pre class="programlisting">
<strong>"file is encrypted or is not a database".</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Creating Observer Pattern</h1></div></div></div><p>Event Dispatcher is<a id="id425" class="indexterm"/> a mechanism for responding to events such as touching screen, keyboard events and custom events. You can get an event using Event Dispatcher. In addition, you can create <code class="literal">Observer Pattern</code> in the design patterns using it. In this recipe, you will learn how to use Event Dispatcher and how to create Observer Pattern in Cocos2d-x.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec242"/>Getting ready</h2></div></div></div><p>Firstly, we will go<a id="id426" class="indexterm"/> through the details of Observer Pattern. Observer Pattern is a design pattern. When an event occurs, Observer notifies the event about the subjects that are registered in Observer. It is mainly used to implement distributed event handling. Observer Pattern is also a key part in the MVC architecture.</p><div><img src="img/B0561_11_07.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec243"/>How to do it...</h2></div></div></div><p>We will create a count<a id="id427" class="indexterm"/> up label per second in this recipe. When touching a screen, count up labels are created in this position, and then, count up per second using Observer Pattern.</p><div><ol class="orderedlist arabic"><li class="listitem">Create <code class="literal">Count</code> class that is extended <code class="literal">Label</code> class as shown in the following code:<div><pre class="programlisting">Count.h
class Count : public cocos2d::Label
{
private:
    int _count;
    void countUp(float dt);
public:
    ~Count();
    virtual bool init();
    CREATE_FUNC(Count);
};
Count.cpp
Count::~Count()
{
    this-&gt;getEventDispatcher()- &gt;removeCustomEventListeners("TimeCount");
}

bool Count::init()
{
    if (!Label::init()) {
        return false;
    }

    _count = 0;

    this-&gt;setString("0");
    this-&gt;setFontScale(2.0f);

    this-&gt;getEventDispatcher()- &gt;addCustomEventListener("TimeCount", [=](EventCustom* event) { this-&gt;countUp(0); });

    return true;
}

void Count::countUp(float dt)
{
    _count++;
    this-&gt;setString(StringUtils::format("%d", _count));
}</pre></div></li><li class="listitem">Next, when<a id="id428" class="indexterm"/> touching a screen, this label will be created at the touching position and will call the <code class="literal">HelloWorld::countUp</code> method per second using a scheduler as the following code in <code class="literal">HelloWorld.cpp</code>:<div><pre class="programlisting">bool HelloWorld::init()
{
    if ( !Layer::init() )
    {
        return false;
    }

    auto listener = EventListenerTouchOneByOne::create();
    listener-&gt;setSwallowTouches(_swallowsTouches);
    listener-&gt;onTouchBegan = C_CALLBACK_2(HelloWorld::onTouchBegan, this);
    this-&gt;getEventDispatcher()- &gt;addEventListenerWithSceneGraphPriority(listener, this);


    this-&gt;schedule(schedule_selector(HelloWorld::countUp), 1.0f);

    return true;
}

bool HelloWorld::onTouchBegan(cocos2d::Touch *touch, cocos2d::Event *unused_event) {
    auto countLabel = Count::create(); this-&gt;addChild(countLabel); countLabel-&gt;setPosition(touch-&gt;getLocation()); 
    return true; }

void HelloWorld::countUp(float dt)
{
    this-&gt;getEventDispatcher()- &gt;dispatchCustomEvent("TimeCount"); }</pre></div></li><li class="listitem">After building and running this project, when you touch the screen, it will create a count up label at the touching position, and then you will see that the labels are counting up per second at the same time.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec244"/>How it works...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Add the <a id="id429" class="indexterm"/>custom event called <code class="literal">TimeCount</code>. If <code class="literal">TimeCount</code> event occurred, then the <code class="literal">Count::countUp</code> method is called.<div><pre class="programlisting">this-&gt;getEventDispatcher()- &gt;addCustomEventListener("TimeCount", [=](EventCustom* event) {
    this-&gt;countUp(0);
});</pre></div></li><li class="listitem">Don't forget that you need to remove the custom event from <code class="literal">EventDispatcher</code> when the instance of the <code class="literal">Count</code> class is removed. If you forget to do that, then the <code class="literal">zombie</code> instance will be called from <code class="literal">EventDispatcher</code> when the event occurs and your game will crash.<div><pre class="programlisting">this-&gt;getEventDispatcher()- &gt;removeCustomEventListeners("TimeCount");</pre></div></li><li class="listitem">In <code class="literal">HelloWorld.cpp</code>, call the <code class="literal">HelloWorld::countUp</code> method using the scheduler. The <code class="literal">HelloWorld::countUp</code> method calls the custom event called <code class="literal">TimeOut</code>.<div><pre class="programlisting">this-&gt;getEventDispatcher()- &gt;dispatchCustomEvent("TimeCount");</pre></div><p>And then, <code class="literal">EventDispatcher</code> will notify this event to the listed subjects. In this case, the <code class="literal">Count::countUp</code> method is called.</p><div><pre class="programlisting">void Count::countUp(float dt){
    _count++;
    this-&gt;setString(StringUtils::format("%d", _count));
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec245"/>There's more…</h2></div></div></div><p>Using <code class="literal">EventDispatcher</code>, labels count up at the same time. If you use Scheduler instead of <code class="literal">EventDispatcher</code>, you will notice something different.</p><p>Change the <code class="literal">Count::init</code> method as shown in the following code:</p><div><pre class="programlisting">bool Count::init()
{
    if (!Label::init()) {
        return false;
    }

    _count = 0;

    this-&gt;setString("0");
    this-&gt;setFontScale(2.0f);
    this-&gt;schedule(schedule_selector(Count::countUp), 1.0f); 
    return true;
}</pre></div><p>In this code, use a<a id="id430" class="indexterm"/> scheduler by calling the <code class="literal">Count::countUp</code> method per second. You can see that the labels are not counting up at the same time in this way. Each label is counting up per second, however not at the same time. Using Observer Pattern, a lot of subjects can be called at the same time.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Networking with HTTP</h1></div></div></div><p>In recent smartphone<a id="id431" class="indexterm"/> games, we normally use an Internet network to update <a id="id432" class="indexterm"/>data, download resources, and so on. There aren't any games developed without networking. In this recipe, you will learn how to use networking to download resources.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec246"/>Getting ready</h2></div></div></div><p>You have to include the header file of <code class="literal">network/HttpClient</code> to use networking.</p><div><pre class="programlisting"> #include "network/HttpClient.h"</pre></div><p>If you run it on Android devices, you need to edit <code class="literal">proj.android/AndroidManifest.xml</code>.</p><div><pre class="programlisting">&lt;user-permission android:name="android.permission.INTERNET" /&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec247"/>How to do it...</h2></div></div></div><p>In the following code, we will get the response from <a class="ulink" href="http://google.com/">http://google.com/</a> and then, print the response data as a log.</p><div><pre class="programlisting">auto request = new network::HttpRequest();
request-&gt;setUrl("http://google.com/ ");
request-&gt;setRequestType(network::HttpRequest::Type::GET);
request-&gt;setResponseCallback([](network::HttpClient* sender, network::HttpResponse* response){
    if (!response-&gt;isSucceed()) {
        CCLOG("error");
        return;
    }

    std::vector&lt;char&gt;* buffer = response-&gt;getResponseData();
    for (unsigned int i = 0; i &lt;buffer-&gt; size (); i ++) {
        printf("%c", (* buffer)[i]);
    }
    printf("\n");
});

network::HttpClient::getInstance()-&gt;send(request);
request-&gt;release();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec248"/>How it works...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Firstly, create<a id="id433" class="indexterm"/> an <code class="literal">HttpRequest</code> instance. The <code class="literal">HttpRequest</code> class does<a id="id434" class="indexterm"/> not have a <code class="literal">create</code> method. That's why you use <code class="literal">new</code> for creating the instance.<div><pre class="programlisting">auto request = new network::HttpRequest();</pre></div></li><li class="listitem">Specify URL and the request type. In this case, set <a class="ulink" href="http://google.com/">http://google.com/</a> as a request URL and set GET as a request type.<div><pre class="programlisting">request-&gt;setUrl("http://google.com/ "); request-&gt;setRequestType(network::HttpRequest::Type::GET);</pre></div></li><li class="listitem">Set callback function to receive the data from the server. You can check its success using the <code class="literal">HttpResponse::isSucceed</code> method. And then you can get the response data using the <code class="literal">HttpResponse::getResponseData</code> method.<div><pre class="programlisting">request-&gt;setResponseCallback([](network::HttpClient* 
sender, network::HttpResponse* response){ 
    if (!response-&gt;isSucceed()) { 
        CCLOG("error"); 
        return;
    }

    std::vector&lt;char&gt;* buffer = response- &gt;getResponseData(); 
    for (unsigned int i = 0; i &lt;buffer-&gt; size (); i ++) { 
        printf("%c", (* buffer)[i]); 
    }
    printf("\n");
});</pre></div></li><li class="listitem">You can request networking by calling the <code class="literal">HttpClient::send</code> method specifying the instance of the <code class="literal">HttpRequest</code> class. If you are getting a response via the network, then call the callback function as mentioned in Step3.<div><pre class="programlisting">network::HttpClient::getInstance()-&gt;send(request);</pre></div></li><li class="listitem">Finally, you <a id="id435" class="indexterm"/>have to release the instance of <code class="literal">HttpRequest</code>. That's why <a id="id436" class="indexterm"/>you created it by using <code class="literal">new</code>.<div><pre class="programlisting">request-&gt;release();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec249"/>There's more…</h2></div></div></div><p>In this section, you will learn how you can get resources from the network using the <code class="literal">HttpRequest</code> class. In the following code, get the Google log from the network and display it.</p><div><pre class="programlisting">auto request = new network::HttpRequest();
request- &gt;setUrl("https://www.google.co.jp/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png"); 
request-&gt;setRequestType(network::HttpRequest::Type::GET); 
request-&gt;setResponseCallback([&amp;](network::HttpClient* sender, 
network::HttpResponse* response){ 
    if (!response-&gt;isSucceed()) { 
        CCLOG("error");
        return;
    }

    std::vector&lt;char&gt;* buffer = response-&gt;getResponseData(); 
    std::string path = FileUtils::getInstance()-&gt;getWritablePath() 
+ "image.png"; 
    FILE* fp = fopen(path.c_str(), "wb");
    fwrite(buffer-&gt;data(), 1, buffer-&gt;size(), fp);
    fclose(fp);

    auto size = Director::getInstance()-&gt;getWinSize();
    auto sprite = Sprite::create(path);
    sprite-&gt;setPosition(size/2);
    this-&gt;addChild(sprite);
});

network::HttpClient::getInstance()-&gt;send(request);
request-&gt;release();</pre></div><p>You can see the following window after building and running this code.</p><div><img src="img/B0561_11_08.jpg" alt="There's more…"/></div><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>You have to save the original data in the sandbox. You can get the path of the sandbox using the <code class="literal">FileUtils::getWritablePath</code> method.</p></div></div></div></div></body></html>