<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Hello, Small World!</h1></div></div></div><p>This chapter introduces Small Windows by presenting the following two small applications:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first application writes "Hello, Small Windows!" in a window</li><li class="listitem" style="list-style-type: disc">The second application handles circles of different colors in a document window</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Hello, Small Windows!</h1></div></div></div><p>In <em>The C Programming Language</em> by Brian Kernighan and Dennis Richie, the hello-world example was introduced. It was a small program that wrote "hello, world" on the screen. In this section, we shall write a similar program for Small Windows.</p><p>In regular C++, the execution of the application starts with the <code class="literal">main</code> function. In Small Windows, however, <code class="literal">main</code> is hidden in the framework and has been replaced by <code class="literal">MainWindow</code>, whose task is to define the application name and create the main window object. The following <code class="literal">argumentList</code> parameter corresponds to <code class="literal">argc</code> and <code class="literal">argv</code> in main. The <code class="literal">commandShow</code> parameter forwards the system's request regarding the window's appearance:</p><p>
<strong>MainWindow.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "HelloWindow.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("Hello"); &#13;
  Application::MainWindowPtr() = &#13;
    new HelloWindow(windowShow); &#13;
} &#13;
</pre><p>In C++, there are to two character types, <code class="literal">char</code> and <code class="literal">wchar_t</code>, where <code class="literal">char</code> holds a regular character of 1 byte and <code class="literal">wchar_t</code> holds a wide character of larger size, usually 2 bytes. There is also the <code class="literal">string</code> class, which holds a string of <code class="literal">char</code> values, and the <code class="literal">wstring</code> class, which holds a string of <code class="literal">wchar_t</code> values.</p><p>However, in Windows, there is also the generic character type <code class="literal">TCHAR</code>, which is <code class="literal">char</code> or <code class="literal">wchar_t</code>, depending on system settings. There is also the <code class="literal">String</code> class, which holds a string of <code class="literal">TCHAR</code> values. Moreover, <code class="literal">TEXT</code> is a macro that translates a character value to <code class="literal">TCHAR</code> and a text value to an array of <code class="literal">TCHAR</code> values.</p><p>To sum it up, the following table shows character types and string classes:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Regular character</strong></p>
</td><td>
<p><strong>Wide character</strong></p>
</td><td>
<p><strong>Generic character</strong></p>
</td></tr><tr><td>
<p>char</p>
</td><td>
<p>wchar_t</p>
</td><td>
<p>TCHAR</p>
</td></tr><tr><td>
<p>string</p>
</td><td>
<p>wstring</p>
</td><td>
<p>String</p>
</td></tr></tbody></table></div><p>In the applications of this book, we always use the <code class="literal">TCHAR</code> type, the <code class="literal">String</code> class, and the <code class="literal">TEXT</code> macro. The only exception to that rule is clipboard handling in <a class="link" href="ch13.html" title="Chapter 13. The Registry, Clipboard, Standard Dialogs, and Print Preview">Chapter 13</a>, <em>The Registry, Clipboard, Standard Dialogs, and Print Preview</em>.</p><p>Our version of the hello-world program writes "Hello, Small Windows!" in the center of the client area. The client area of the window is that part of the window where it is possible to draw graphical objects. In the following window, the client area is the white area:</p><p>
</p><div><img src="img/image_02_001.jpg" alt="Hello, Small Windows!"/></div><p>
</p><p>The <code class="literal">HelloWindow</code> class extends the Small Windows <code class="literal">Window</code> class. It holds a constructor and the <code class="literal">Draw</code> method. The constructor calls the <code class="literal">Window</code> constructor with suitable information regarding the appearance of the window. The <code class="literal">Draw</code> method is called every time the client area of the window needs to be redrawn:</p><p>
<strong>HelloWindow.h</strong>
</p><pre class="programlisting">class HelloWindow : public Window { &#13;
  public: &#13;
    HelloWindow(WindowShow windowShow); &#13;
    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
}; &#13;
&#13;
</pre><p>The constructor of <code class="literal">HelloWindow</code> calls the constructor of <code class="literal">Window</code> with the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first parameter of the <code class="literal">HelloWindow</code> constructor is the coordinate system. <code class="literal">LogicalWithScroll</code> indicates that each logical unit is one hundredth of a millimeter, regardless of the physical resolution of the screen. The current scroll bar settings are taken into consideration.</li><li class="listitem" style="list-style-type: disc">The second parameter of the <code class="literal">Window</code> constructor is the preferred size of the window. It indicates that a default size should be used.</li><li class="listitem" style="list-style-type: disc">The third parameter is a pointer to the parent window. It is null since the window has no parent window.</li><li class="listitem" style="list-style-type: disc">The fourth and fifth parameters set the window's style, in this case overlapped windows.</li><li class="listitem" style="list-style-type: disc">The last parameter is <code class="literal">windowShow</code>, given by the surrounding system to <code class="literal">MainWindow</code>, which decides the window's initial appearance (minimized, normal, or maximized).</li><li class="listitem" style="list-style-type: disc">Finally, the constructor sets the header of the window by calling the <code class="literal">Window</code> class's <code class="literal">SetHeader</code> method.</li></ul></div><p>
<strong>HelloWindow.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "HelloWindow.h" &#13;
 &#13;
HelloWindow::HelloWindow(WindowShow windowShow) &#13;
 :Window(LogicalWithScroll, ZeroSize, nullptr, &#13;
         OverlappedWindow, NoStyle, windowShow) { &#13;
  SetHeader(TEXT("Hello Window")); &#13;
} &#13;
</pre><p>The <code class="literal">OnDraw</code> method is called every time the client area of the window needs to be redrawn. It obtains the size of the client area and draws the text in its center with black text on a white background. The <code class="literal">SystemFont</code> parameter will make the text appear in the default system font.</p><p>The Small Windows <code class="literal">Color</code> class holds the constants <code class="literal">Black</code> and <code class="literal">White</code>. The <code class="literal">Point</code> class holds a two-dimensional point. The <code class="literal">Size</code> class holds <code class="literal">width</code> and <code class="literal">height</code>. The <code class="literal">Rect</code> class holds a rectangle; more specifically, it holds the four corners of a rectangle:</p><pre class="programlisting">void HelloWindow::OnDraw(Graphics&amp; graphics, &#13;
                         DrawMode /* drawMode */) const { &#13;
  Size clientSize = GetClientSize(); &#13;
  Rect clientRect(Point(0, 0), clientSize);&#13;
 graphics.DrawText(clientRect, TEXT("Hello, Small Windows!"),&#13;
                    SystemFont, Black, White);&#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec11"/>The circle application</h1></div></div></div><p>In this section, we look into a simple circle application. As the name implies, it enables the user to handle circles in a graphical application. The user can add a new circle by pressing the left mouse button. The user can also move an existing circle by dragging it. Moreover, the user can change the color of a circle as well as save and open the document:</p><p>
</p><div><img src="img/image_02_002.jpg" alt="The circle application"/></div><p>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec7"/>The main window</h2></div></div></div><p>As we will see throughout this book, the <code class="literal">MainWindow</code> function always does the same thing: it sets the application name and creates the main window of the application. The name is used by the <strong>Save</strong> and <strong>Open</strong> standard dialogs, the <strong>About</strong> menu item, and the registry.</p><p>The difference between the main window and other windows of the application is that, when the user closes the main window, the application exits. Moreover, when the user selects the <strong>Exit</strong> menu item, the main window is closed, and its destructor is called:</p><p>
<strong>MainWindow.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Circle.h" &#13;
#include "CircleDocument.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, &#13;
                WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("Circle"); &#13;
  Application::MainWindowPtr() = &#13;
    new CircleDocument(windowShow); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec8"/>The CircleDocument class</h2></div></div></div><p>The <code class="literal">CircleDocument</code> class extends the Small Windows <code class="literal">StandardDocument</code> class, which, in turn, extends the <code class="literal">Document</code> and <code class="literal">Window</code> classes. In fact, the <code class="literal">StandardDocument</code> class constitutes a framework, that is, a base class with a set of virtual methods with functionality that we can override and further specify.</p><p>The <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseUp</code> methods are overridden from the <code class="literal">Window</code> class and are called when the user presses or releases one of the mouse buttons. The <code class="literal">OnMouseMove</code> method is called when the user moves the mouse. The <code class="literal">OnDraw</code> method is also overridden from the <code class="literal">Window</code> class and is called every time the window needs to be redrawn.</p><p>The <code class="literal">ClearDocument</code>,<code class="literal"> ReadDocumentFromStream</code>, and <code class="literal">WriteDocumentToStream</code> methods are overridden from the <code class="literal">Standard­Document</code> class and are called when the user creates a new file, opens a file, or saves a file:</p><p>
<strong>CircleDocument.h</strong>
</p><pre class="programlisting">class CircleDocument : public StandardDocument { &#13;
  public: &#13;
    CircleDocument(WindowShow windowShow); &#13;
    ~CircleDocument(); &#13;
 &#13;
    void OnMouseDown(MouseButton mouseButtons, &#13;
                    Point mousePoint, &#13;
                    bool shiftPressed, &#13;
                    bool controlPressed); &#13;
    void OnMouseUp(MouseButton mouseButtons, &#13;
                    Point mousePoint, &#13;
                    bool shiftPressed, &#13;
                    bool controlPressed); &#13;
    void OnMouseMove(MouseButton mouseButtons, &#13;
                    Point mousePoint, &#13;
                    bool shiftPressed, &#13;
                    bool controlPressed); &#13;
 &#13;
    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
 &#13;
    bool ReadDocumentFromStream(String name, &#13;
                           istream&amp; inStream); &#13;
    bool WriteDocumentToStream(String name, &#13;
                           ostream&amp; outStream) const; &#13;
    void ClearDocument(); &#13;
</pre><p>The <code class="literal">DEFINE_BOOL_LISTENER</code> and <code class="literal">DEFINE_VOID_LISTENER</code> macros define <strong>listeners</strong> which are methods without parameters that are called when the user selects a menu item. The only difference between the macros is the return type of the defined methods: <code class="literal">bool</code> or <code class="literal">void</code>.</p><p>In the applications of this book, we use the common standard whereby listeners called in response to user actions are prefixed with <code class="literal">On</code>, for instance, <code class="literal">OnRed</code>, as shown in the following code snippet. The methods that decide whether the menu item should be enabled are suffixed with <code class="literal">Enable</code>, and the methods that decide whether the menu item should be marked with a check mark or a radio button are suffixed with <code class="literal">Check</code> or <code class="literal">Radio</code>.</p><p>In the following application, we define menu items for the red, green, and blue colors. We also define a menu item for the color standard dialog:</p><pre class="programlisting">    DEFINE_VOID_LISTENER(CircleDocument,OnRed); &#13;
    DEFINE_VOID_LISTENER(CircleDocument,OnGreen); &#13;
    DEFINE_VOID_LISTENER(CircleDocument,OnBlue); &#13;
    DEFINE_VOID_LISTENER(CircleDocument,OnColorDialog); &#13;
</pre><p>When the user has chosen one of the colors, red, green, or blue, its corresponding menu item is checked with a radio button. The <code class="literal">RedRadio</code>, <code class="literal">GreenRadio</code>, and <code class="literal">BlueRadio</code> parameters are called before the menu items become visible and return a Boolean value indicating whether the menu item should be marked with a radio button:</p><pre class="programlisting">    DEFINE_BOOL_LISTENER(CircleDocument, RedRadio); &#13;
    DEFINE_BOOL_LISTENER(CircleDocument, GreenRadio); &#13;
    DEFINE_BOOL_LISTENER(CircleDocument, BlueRadio); &#13;
</pre><p>The circle radius is always 500 units, which corresponds to 5 mm:</p><pre class="programlisting">    static const int CircleRadius = 500; &#13;
</pre><p>The <code class="literal">circleList</code> field holds the circles, where the topmost circle is located at the beginning of the list. The <code class="literal">nextColor</code> field holds the color of the next circle to be added by the user. It is initialized to minus 0ne to indicate that no circle is being moved at the beginning. The <code class="literal">moveIndex</code> and <code class="literal">movePoint</code> fields are used by the <code class="literal">OnMouseDown</code> and <code class="literal">OnMouseMove</code> methods to keep track of the circle being moved by the user:</p><pre class="programlisting">  private: &#13;
    vector&lt;Circle&gt; circleList; &#13;
    Color nextColor; &#13;
    int moveIndex = -1; &#13;
    Point movePoint; &#13;
}; &#13;
</pre><p>In the <code class="literal">StandardDocument</code> constructor call, the first two parameters are <code class="literal">LogicalWithScroll</code> and <code class="literal">USLetterPortrait</code>. They indicate that the logical size is hundredths of millimeters and that the client area holds the logical size of a US letter: <em>215.9*279.4 millimeters (8.5*11 inches)</em>. If the window is resized so that the client area becomes smaller than a US letter, scroll bars are added to the window.</p><p>The third parameter sets the file information used by the standard save and open dialogs; the text description is set to <code class="literal">Circle Files</code> and the file suffix is set to <code class="literal">cle</code>. The <code class="literal">nullptr</code> parameter indicates that the window does not have a parent window. The <code class="literal">OverlappedWindow</code> constant parameter indicates that the window should overlap other windows, and the <code class="literal">windowShow</code> parameter is the window's initial appearance passed on from the surrounding system by the <code class="literal">MainWindow</code> class:</p><p>
<strong>CircleDocument.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Circle.h" &#13;
#include "CircleDocument.h" &#13;
 &#13;
CircleDocument::CircleDocument(WindowShow windowShow) &#13;
 :StandardDocument(LogicalWithScroll, USLetterPortrait, &#13;
                   TEXT("Circle Files, cle"), nullptr, &#13;
                   OverlappedWindow, windowShow) { &#13;
</pre><p>The <code class="literal">StandardDocument</code> class adds the standard <strong>File</strong>, <strong>Edit</strong>, and <strong>Help</strong> menus to the window menu bar. The <strong>File</strong> menu holds the <strong>New</strong>, <strong>Open</strong>, <strong>Save</strong>, <strong>Save As</strong>, <strong>Page Setup</strong>, <strong>Print Preview</strong>, and <strong>Exit</strong> items. <strong>Page Setup</strong> and <strong>Print Preview</strong> are optional. The seventh parameter of the <code class="literal">StandardDocument</code> constructor (the default value is <code class="literal">false</code>) indicates their presence. The <strong>Edit</strong> menu holds the <strong>Cut</strong>, <strong>Copy</strong>, <strong>Paste</strong>, and <strong>Delete</strong> items. They are disabled by default; we will not use them in this application. The <strong>Help</strong> menu holds the <strong>About</strong> item, and the application name set in <code class="literal">MainWindow</code> is used to display a message box with a standard message <strong>Circle, version 1.0</strong>.</p><p>We add the standard <strong>File</strong> and <strong>Edit</strong> menus to the menu bar. Then we add the <strong>Color</strong> menu, which is the application-specific menu of this application. Finally, we add the standard <strong>Help</strong> menu and set the menu bar of the document.</p><p>The <strong>Color</strong> menu holds the menu items used to set the circle colors. The <code class="literal">OnRed</code>, <code class="literal">OnGreen</code>, and <code class="literal">OnBlue</code> methods are called when the user selects the menu item, and the <code class="literal">RedRadio</code>, <code class="literal">GreenRadio</code>, and <code class="literal">BlueRadio</code> methods are called before the user selects the <strong>Color</strong> menu in order to decide if the items should be marked with a radio button. The <code class="literal">OnColorDialog</code> method opens a standard color dialog.</p><p>In the <code class="literal">&amp;Red\tCtrl+R</code> text in the following code snippet, the <strong>ampersand</strong> (<strong>&amp;</strong>) indicates that the menu item has a <strong>mnemonic</strong>; that is, the letter R will be underlined and it is possible to select the menu item by pressing <strong>R</strong> after the menu has been opened. The <strong>tabulator character</strong> (<strong>\t</strong>) indicates that the second part of the text defines an <strong>accelerator</strong>; that is, the text <code class="literal">Ctrl+R</code> will occur right-justified in the menu item and the item can be selected by pressing Ctrl+R:</p><pre class="programlisting">  Menu menuBar(this);</pre><p>The <code class="literal">false</code> parameter to <code class="literal">StandardFileMenu</code> indicates that we do not want to include the file menu items.</p><pre class="programlisting">  menuBar.AddMenu(StandardFileMenu(false));</pre><p>The <code class="literal">AddItem</code> method in the <code class="literal">Menu</code> class also takes two more parameters for enabling the menu item and setting a checkbox. However, we do not use them in this application. Therefore, we send null pointers:</p><pre class="programlisting">  Menu colorMenu(this, TEXT("&amp;Color")); &#13;
  colorMenu.AddItem(TEXT("&amp;Red\tCtrl+R"), OnRed, &#13;
                    nullptr, nullptr, RedRadio); &#13;
  colorMenu.AddItem(TEXT("&amp;Green\tCtrl+G"), OnGreen, &#13;
                    nullptr, nullptr, GreenRadio); &#13;
  colorMenu.AddItem(TEXT("&amp;Blue\tCtrl+B"), OnBlue, &#13;
                    nullptr, nullptr, BlueRadio); &#13;
  colorMenu.AddSeparator(); &#13;
  colorMenu.AddItem(TEXT("&amp;Dialog ..."), OnColorDialog); &#13;
  menuBar.AddMenu(colorMenu); &#13;
 &#13;
  menuBar.AddMenu(StandardHelpMenu()); &#13;
  SetMenuBar(menuBar); &#13;
</pre><p>Finally, we read the current color (the color of the next circle to be added) from the registry; red is the default color in case there is no color stored in the registry:</p><pre class="programlisting">  nextColor.ReadColorFromRegistry(TEXT("NextColor"), Red); &#13;
} &#13;
</pre><p>The destructor saves the current color in the registry. In this application, we do not need to perform the destructor's normal tasks such as deallocating memory or closing files:</p><pre class="programlisting">CircleDocument::~CircleDocument() { &#13;
  nextColor.WriteColorToRegistry(TEXT("NextColor")); &#13;
} &#13;
</pre><p>The <code class="literal">ClearDocument</code> method is called when the user selects the <strong>New</strong> menu item. In this case, we just clear the circle list. Every other action, such as redrawing the window or changing its title, is taken care of by the <code class="literal">StandardDocument</code> class:</p><pre class="programlisting">void CircleDocument::ClearDocument() { &#13;
  circleList.clear(); &#13;
} &#13;
</pre><p>The <code class="literal">WriteDocumentToStream</code> method is called by the <code class="literal">StandardDocument</code> class when the user saves a file (by selecting <strong>Save</strong> or <strong>Save As</strong>). It writes the number of circles (the size of the circle list) to the output stream and calls the <code class="literal">WriteCircle</code> method for each circle in order to write their states to the stream:</p><pre class="programlisting">bool CircleDocument::WriteDocumentToStream(String name, &#13;
                          ostream&amp; outStream) const { &#13;
  int size = circleList.size(); &#13;
  outStream.write((char*) &amp;size, sizeof size); &#13;
 &#13;
  for (Circle circle : circleList) { &#13;
    circle.WriteCircle(outStream); &#13;
  } &#13;
 &#13;
  return ((bool) outStream); &#13;
} &#13;
</pre><p>The <code class="literal">ReadDocumentFromStream</code> method is called by the <code class="literal">StandardDocument</code> method when the user opens a file by selecting the <strong>Open</strong> menu item. It reads the number of circles (the size of the circle list) and for each circle it creates a new object of the <code class="literal">Circle</code> class, calls the <code class="literal">ReadCircle</code> method in order to read the state of the circle, and adds the circle object to the <code class="literal">circleList</code> method:</p><pre class="programlisting">bool CircleDocument::ReadDocumentFromStream(String name, &#13;
                                 istream&amp; inStream) { &#13;
  int size; &#13;
  inStream.read((char*) &amp;size, sizeof size); &#13;
&#13;
&#13;
&#13;
 &#13;
  for (int count = 0; count &lt; size; ++count) { &#13;
    Circle circle; &#13;
    circle.ReadCircle(inStream); &#13;
    circleList.push_back(circle); &#13;
  } &#13;
 &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">OnMouseDown</code> method is called when the user presses one of the mouse buttons. First we need to check that they have pressed the left mouse button. If they have, we loop through the circle list and call the <code class="literal">IsClick</code> method for each circle in order to decide whether they have clicked on a circle. Note that the topmost circle is located at the beginning of the list; therefore, we loop from the beginning of the list. If we find a clicked circle, we break the loop.</p><p>If the user has clicked on a circle, we store its index <code class="literal">moveIndex</code> and the current mouse position in <code class="literal">movePoint</code>. Both values are needed by that <code class="literal">OnMouseMove</code> method that will be called when the user moves the mouse:</p><pre class="programlisting">void CircleDocument::OnMouseDown &#13;
           (MouseButton mouseButtons, Point mousePoint, &#13;
            bool shiftPressed /* = false */, &#13;
            bool controlPressed /* = false */) { &#13;
  if (mouseButtons == LeftButton) { &#13;
    moveIndex = -1; &#13;
    int size = circleList.size(); &#13;
 &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (circleList[index].IsClick(mousePoint)) { &#13;
        moveIndex = index; &#13;
        movePoint = mousePoint; &#13;
        break; &#13;
      } &#13;
    } &#13;
</pre><p>However, if the user has not clicked on a circle, we add a new circle. A circle is defined by its center position (<code class="literal">mousePoint</code>), radius (<code class="literal">CircleRadius</code>), and color (<code class="literal">nextColor</code>).</p><p>An invalidated area is a part of the client area that needs to be redrawn. Remember that in Windows, we normally do not draw figures directly. Instead, we call the <code class="literal">Invalidate</code> method to tell the system that an area needs to be redrawn and force the actual redrawing by calling the <code class="literal">UpdateWindow</code> method, which eventually results in a call to the <code class="literal">OnDraw</code> method. The invalidated area is always a rectangle. The <code class="literal">Invalidate</code> method has a second parameter (the default value is <code class="literal">true</code>) indicating that the invalidated area should be cleared.</p><p>Technically, it is painted in the window's client color, which in this case is white. In this way, the previous location of the circle is cleared and the circle is drawn at its new location.</p><p>The <code class="literal">SetDirty</code> method tells the framework that the document has been altered (the document has become <em>dirty</em>), which causes the <strong>Save</strong> menu item to be enabled and the user to be warned if he/she tries to close the window without saving it:</p><pre class="programlisting">    if (moveIndex == -1) { &#13;
      Circle newCircle(mousePoint, CircleRadius, &#13;
                       nextColor); &#13;
      circleList.push_back(newCircle); &#13;
      Invalidate(newCircle.Area()); &#13;
      UpdateWindow(); &#13;
      SetDirty(true); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnMouseMove</code> method is called every time the user moves the mouse with at least one mouse button pressed. We first need to check whether the user is pressing the left mouse button and is clicking on a circle (whether the <code class="literal">moveIndex</code> method does not equal <code class="literal">-1</code>). If the user is, we calculate the distance from the previous mouse event (<code class="literal">OnMouseDown</code> or <code class="literal">OnMouseMove</code>) by comparing the previous and the current mouse position using the <code class="literal">mousePoint</code> method. We update the circle position, invalidate both the old and new area, forcing a redrawing of the invalidated areas with the <code class="literal">UpdateWindow</code> method, and set the dirty flag:</p><pre class="programlisting">void CircleDocument::OnMouseMove &#13;
           (MouseButton mouseButtons, Point mousePoint, &#13;
            bool shiftPressed /* = false */, &#13;
            bool controlPressed /* = false */) { &#13;
  if ((mouseButtons == LeftButton)&amp;&amp;(moveIndex != -1)) { &#13;
    Size distanceSize = mousePoint - movePoint; &#13;
    movePoint = mousePoint; &#13;
 &#13;
    Circle&amp; movedCircle = circleList[moveIndex]; &#13;
    Invalidate(movedCircle.Area()); &#13;
    movedCircle.Center() += distanceSize; &#13;
    Invalidate(movedCircle.Area()); &#13;
 &#13;
    UpdateWindow(); &#13;
    SetDirty(true); &#13;
  } &#13;
} &#13;
</pre><p>Strictly speaking, the <code class="literal">OnMouseUp</code> method could be excluded since the <code class="literal">moveIndex</code> method is set to minus one in the <code class="literal">OnMouseDown</code> method, which is always called before the <code class="literal">OnMouseMove</code> method. However, it has been included for the sake of completeness:</p><pre class="programlisting">void CircleDocument::OnMouseUp &#13;
           (MouseButton mouseButtons, Point mousePoint, &#13;
            bool shiftPressed /* = false */, &#13;
            bool controlPressed /* = false */) { &#13;
  moveIndex = -1; &#13;
} &#13;
</pre><p>The <code class="literal">OnDraw</code> method is called every time the window needs to be (partly or completely) redrawn. The call can be initialized by the system as a response to an event (for instance, the window has been resized) or by an earlier call to the <code class="literal">UpdateWindow</code> method. The <code class="literal">Graphics</code> reference parameter has been created by the framework and can be considered as a toolbox for drawing lines, painting areas, and writing text. However, in this application, we do not write text.</p><p>We iterate through the circle list and, for each circle, call the <code class="literal">Draw</code> method. Note that we do not care about which circles are to be physically redrawn. We simple redraw all circles. However, only the circles located in an area that has been invalidated by a previous call to the <code class="literal">Invalidate</code> method will be physically redrawn.</p><p>The <code class="literal">Draw</code> method has a second parameter indicating the draw mode, which can be <code class="literal">Paint</code> or <code class="literal">Print</code>. The <code class="literal">Paint</code> method indicates that the <code class="literal">OnDraw</code> method is called by the <code class="literal">OnPaint</code> method in the <code class="literal">Window</code> class and that the painting is performed in the window's client area. The <code class="literal">Print</code> method indicates that the <code class="literal">OnDraw</code> method is called by the <code class="literal">OnPrint</code> method and that the painting is sent to a printer. However, in this application, we do not use that parameter:</p><pre class="programlisting">void CircleDocument::OnDraw(Graphics&amp; graphics, &#13;
                            DrawMode /* drawMode */) const { &#13;
  for (Circle circle : circleList) { &#13;
    circle.Draw(graphics); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">RedRadio</code>, <code class="literal">GreenRadio</code>, and <code class="literal">BlueRadio</code> methods are called before the menu items are shown, and the items will be marked with a radio button if they return <code class="literal">true</code>. The <code class="literal">Red</code>, <code class="literal">Green</code>, and <code class="literal">Blue</code> constants are defined in the <code class="literal">Color</code> class:</p><pre class="programlisting">bool CircleDocument::RedRadio() const { &#13;
  return (nextColor == Red); &#13;
} &#13;
 &#13;
bool CircleDocument::GreenRadio() const { &#13;
  return (nextColor == Green); &#13;
} &#13;
 &#13;
bool CircleDocument::BlueRadio() const { &#13;
  return (nextColor == Blue); &#13;
} &#13;
</pre><p>The <code class="literal">OnRed</code>, <code class="literal">OnGreen</code>, and <code class="literal">OnBlue</code> methods are called when the user selects the corresponding menu item. They all set the <code class="literal">nextColor</code> field to an appropriate value:</p><pre class="programlisting">void CircleDocument::OnRed() { &#13;
  nextColor = Red; &#13;
} &#13;
 &#13;
void CircleDocument::OnGreen() { &#13;
  nextColor = Green; &#13;
} &#13;
 &#13;
void CircleDocument::OnBlue() { &#13;
  nextColor = Blue; &#13;
} &#13;
</pre><p>The <code class="literal">OnColorDialog</code> method is called when the user selects the <strong>Color</strong> dialog menu item and displays the standard color dialog. If the user chooses a new color, the <code class="literal">nextcolor</code> method will be given the chosen color value:</p><pre class="programlisting">void CircleDocument::OnColorDialog() { &#13;
  StandardDialog(this, nextColor); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec9"/>The Circle class</h2></div></div></div><p>
<code class="literal">Circle</code> is a class holding the information about a single circle. The default constructor is used when reading a circle from a file. The second constructor is used when creating a new circle. The <code class="literal">IsClick</code> method returns <code class="literal">true</code> if the given point is located inside the circle (to check whether the user has clicked in the circle), the <code class="literal">Area</code> method returns the circle's surrounding rectangle (for invalidation), and the <code class="literal">Draw</code> method is called to redraw the circle:</p><p>
<strong>Circle.h</strong>
</p><pre class="programlisting">class Circle { &#13;
  public: &#13;
    Circle(); &#13;
    Circle(Point center, int radius, Color color); &#13;
 &#13;
    bool WriteCircle(ostream&amp; outStream) const; &#13;
    bool ReadCircle(istream&amp; inStream); &#13;
 &#13;
    bool IsClick(Point point) const; &#13;
    Rect Area() const; &#13;
    void Draw(Graphics&amp; graphics) const; &#13;
 &#13;
    Point Center() const {return center;} &#13;
    Point&amp; Center() {return center;} &#13;
    Color GetColor() {return color;} &#13;
</pre><p>As mentioned in the previous section, a circle is defined by its center position (<code class="literal">center</code>), radius (<code class="literal">radius</code>), and color (<code class="literal">color</code>):</p><pre class="programlisting">  private: &#13;
    Point center; &#13;
    int radius; &#13;
    Color color; &#13;
}; &#13;
</pre><p>The default constructor does not need to initialize the fields since it is called when the user opens a file and the values are read from the file. The second constructor, however, initializes the center point, radius, and color of the circle:</p><p>
<strong>Circle.cpp</strong>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "Circle.h" &#13;
 &#13;
Circle::Circle() { &#13;
  // Empty. &#13;
} &#13;
 &#13;
Circle::Circle(Point center, int radius, Color color) &#13;
 :color(color), &#13;
  center(center), &#13;
  radius(radius) { &#13;
  // Empty. &#13;
} &#13;
</pre><p>The <code class="literal">WriteCircle</code> method writes the color, center point, and radius to the stream. Since <code class="literal">radius</code> is a regular integer, we simply use the C standard function <code class="literal">write</code>, while <code class="literal">Color</code> and <code class="literal">Point</code> have their own methods to write their values to a stream. In the <code class="literal">ReadCircle</code> method, we read the color, center point, and radius from the stream in a similar manner:</p><pre class="programlisting">bool Circle::WriteCircle(ostream&amp; outStream) const { &#13;
  color.WriteColorToStream(outStream); &#13;
  center.WritePointToStream(outStream); &#13;
  outStream.write((char*) &amp;radius, sizeof radius); &#13;
  return ((bool) outStream); &#13;
} &#13;
 &#13;
bool Circle::ReadCircle(istream&amp; inStream) { &#13;
  color.ReadColorFromStream(inStream); &#13;
  center.ReadPointFromStream(inStream); &#13;
  inStream.read((char*) &amp;radius, sizeof radius); &#13;
  return ((bool) inStream); &#13;
} &#13;
</pre><p>The <code class="literal">IsClick</code> method uses Pythagoras' theorem to calculate the distance between the given point and the circle's center point and returns <code class="literal">true</code> if the point is located inside the circle (if the distance is less than or equal to the circle radius):</p><p>
</p><div><img src="img/image_02_003.jpg" alt="The Circle class"/></div><p>
</p><pre class="programlisting"> Circle::IsClick(Point point) const { &#13;
  int width = point.X() - center.X(), &#13;
      height = point.Y() - center.Y(); &#13;
  int distance = (int) sqrt((width * width) + &#13;
                            (height * height)); &#13;
  return (distance &lt;= radius); &#13;
} &#13;
</pre><p>The top-left corner of the resulting rectangle is the center point minus the radius and the bottom-right corner is the center point plus the radius:</p><pre class="programlisting">Rect Circle::Area() const { &#13;
  Point topLeft = center - radius, &#13;
        bottomRight = center + radius; &#13;
  return Rect(topLeft, bottomRight); &#13;
} &#13;
</pre><p>We use the <code class="literal">FillEllipse</code> method (there is no <code class="literal">FillCircle</code> method) of the Small Windows <code class="literal">Graphics</code> class to draw the circle. The circle's border is always black, while its interior color is given by the <code class="literal">color</code> field:</p><pre class="programlisting">void Circle::Draw(Graphics&amp; graphics) const { &#13;
  Point topLeft = center - radius, &#13;
        bottomRight = center + radius; &#13;
  Rect circleRect(topLeft, bottomRight); &#13;
  graphics.FillEllipse(circleRect, Black, color); &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, you looked into two applications in Small Windows: a simple hello-world application and a slightly more advanced circle application, which introduced the framework. You also looked into menus, circle drawing, and mouse handling.</p><p>In <a class="link" href="ch03.html" title="Chapter 3. Building a Tetris Application">Chapter 3</a>, <em>Building a Tetris Application</em>, we will develop a classic Tetris game.</p></div></body></html>