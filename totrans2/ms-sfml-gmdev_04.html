<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Have Thy Gear Ready - Building Game Tools</h1></div></div></div><p>Making games is a fine art. It is entirely possible, of course, to make art with the most basic of tools, but most commonly, developers need a strong toolkit supporting them in order to efficiently and professionally create quick, painless edits to their game. Building the said toolkit is arguably on a par with the difficulty of building the actual game, but the work spent on proper tools offsets the difficulty and frustrations that come with direct file edits.</p><p>In this chapter, we're going to be covering these topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a graphical means of file management</li><li class="listitem" style="list-style-type: disc">File loading in a separate thread</li><li class="listitem" style="list-style-type: disc">Establishing a state and means of controls for map editing</li></ul></div><p>There's lots of ground to cover, so let's get started!</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Use of copyrighted resources</h1></div></div></div><p>As usual, let us give proper thanks to the artists and their assets that made this possible:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Folder Orange</em> by <em>sixsixfive</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/212337/folder-orange">https://openclipart.org/detail/212337/folder-orange</a></li><li class="listitem" style="list-style-type: disc"><em>Generic Document</em> by <em>isendrak</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/212798/generic-document">https://openclipart.org/detail/212798/generic-document</a></li><li class="listitem" style="list-style-type: disc"><em>Tango Media Floppy</em> by <em>warszawianka</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/34579/tango-media-floppy">https://openclipart.org/detail/34579/tango-media-floppy</a></li><li class="listitem" style="list-style-type: disc"><em>Close</em> by <em>danilo</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/215431/close">https://openclipart.org/detail/215431/close</a></li><li class="listitem" style="list-style-type: disc"><em>Hand Prints</em> by <em>kattekrab</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/16340/hand-prints">https://openclipart.org/detail/16340/hand-prints</a></li><li class="listitem" style="list-style-type: disc"><em>Paint Brush with Dark Red Dye</em> by <em>Astro</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11">https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11</a></li><li class="listitem" style="list-style-type: disc"><em>Primary Eraser</em> by <em>dannya</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/199463/primary-eraser">https://openclipart.org/detail/199463/primary-eraser</a></li><li class="listitem" style="list-style-type: disc"><em>Mono Tool Rect Selection</em> by <em>dannya</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/198758/mono-tool-rect-selection">https://openclipart.org/detail/198758/mono-tool-rect-selection</a></li><li class="listitem" style="list-style-type: disc"><em>Color Bucket Red</em> by <em>frankes</em> under the <strong>CC0</strong> license (public domain): <a class="ulink" href="https://openclipart.org/detail/167327/color-bucket-red">https://openclipart.org/detail/167327/color-bucket-red</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>File management</h1></div></div></div><p>The success and usability of the map editor tool is going to rely heavily on one specific interfacing element here, which is file access and management. In order to provide efficient means of file access, loading and saving, we are going to work on developing the means of visually guiding our user through the file system. The entire system consists of a few moving parts. For now, let us solely focus on the interface aspect of this idea.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>File manager interface</h2></div></div></div><p>Before we can successfully work with any kind of map data, it is important to have a comfortable means of loading and saving. This can be offloaded to a file manager interface, which is going to be responsible for displaying directory information. Let us take a look at what ours is going to look like:</p><div><img src="img/image_04_001.jpg" alt="File manager interface"/></div><p>With this goal in mind, let us begin planning a class for it, starting with the header:</p><pre class="programlisting">class GUI_FileManager { 
public: 
  GUI_FileManager(std::string l_name, GUI_Manager* l_guiMgr, 
    StateManager* l_stateMgr); 
  ~GUI_FileManager(); 
 
  void SetDirectory(std::string l_dir); 
  void ParentDirCallback(EventDetails* l_details); 
  void HandleEntries(EventDetails* l_details); 
  void ActionButton(EventDetails* l_details); 
  void CloseButton(EventDetails* l_details); 
  void Hide(); 
  void Show(); 
  void LoadMode(); 
  void SaveMode(); 
  bool IsInSaveMode() const; 
 
  template&lt;class T&gt; 
  void SetActionCallback( 
    void(T::*l_method)(const std::string&amp;), T* l_instance) 
  {...} 
private: 
  void ListFiles(); 
  GUI_Interface* m_interface; 
  std::string m_name; 
  std::string m_dir; 
 
  std::string m_folderEntry; 
  std::string m_fileEntry; 
 
  GUI_Manager* m_guiManager; 
  StateManager* m_stateMgr; 
  StateType m_currentState; 
  std::function&lt;void(std::string)&gt; m_actionCallback; 
  bool m_saveMode; 
}; 
</pre><p>Evidently, this class is a slightly more complex manifestation of a wrapper for a <code class="literal">GUI_Interface</code> instance. It is responsible for keeping track of the current directory we are in, as well as invoking a callback function/method when a file is selected to be loaded or saved. The callback function only takes a string argument, which carries the full path to the file that was selected to be loaded or saved, and can be registered like this:</p><pre class="programlisting">void SetActionCallback( 
  void(T::*l_method)(const std::string&amp;), T* l_instance) 
{ 
  m_actionCallback = 
    [l_instance, l_method](const std::string&amp; l_str) -&gt; void 
    { (l_instance-&gt;*l_method)(l_str); }; 
} 
</pre><p>Nothing too complicated yet. Let us move on to actually implementing the class!</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec4"/>Implementing the file manager</h3></div></div></div><p>With the class definition out of the way, it is time to take a look at the actual code that makes the file manager tick. Let's start by implementing the constructor of this class:</p><pre class="programlisting">GUI_FileManager::GUI_FileManager(std::string l_name, 
  GUI_Manager* l_guiMgr, StateManager* l_stateMgr): 
  m_guiManager(l_guiMgr), m_stateMgr(l_stateMgr), m_name(l_name), 
  m_saveMode(false) 
{ 
  m_guiManager-&gt;LoadInterface(""FileManager.interface"", l_name); 
  m_interface = m_guiManager-&gt;GetInterface(l_name); 
  m_currentState = m_stateMgr-&gt;GetCurrentStateType(); 
  m_folderEntry = m_interface-&gt;GetElement("FolderEntry")-&gt; 
    GetStyleName(); 
  m_fileEntry = m_interface-&gt;GetElement("FileEntry")-&gt; 
    GetStyleName(); 
  m_interface-&gt;RemoveElement("FolderEntry"); 
  m_interface-&gt;RemoveElement("FileEntry"); 
  m_interface-&gt;SetContentRectSize({ 300, 260 }); 
  m_interface-&gt;SetContentOffset({ 0.f, 16.f }); 
  m_interface-&gt;PositionCenterScreen(); 
 
  auto mgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Parent", 
    &amp;GUI_FileManager::ParentDirCallback, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Entries", 
    &amp;GUI_FileManager::HandleEntries, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_ActionButton", 
    &amp;GUI_FileManager::ActionButton, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Close", 
    &amp;GUI_FileManager::CloseButton, this); 
 
  SetDirectory(Utils::GetWorkingDirectory()); 
} 
</pre><p>First, we load the interface and store its pointer in the designated data member. We also want to store the current state of the application, and obtain the style names of the elements, called <code class="literal">FolderEntry</code> and <code class="literal">FileEntry</code>, which are then removed. This makes the interface file a sort of template that gets filled in with all the right information later.</p><p>Once the appropriate content size and offset are set, the interface is positioned in the centre of the screen. We then subscribe to relevant GUI interface events and set our file manager directory as the current directory the application is in.</p><p>The callbacks and interfaces created in this class obviously need to be removed once they are no longer in use. This is where the destructor comes in:</p><pre class="programlisting">GUI_FileManager::~GUI_FileManager() { 
  m_guiManager-&gt;RemoveInterface(m_currentState, m_name); 
  auto events = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Parent""); 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Entries""); 
  events-&gt;RemoveCallback(m_currentState, 
    ""FileManager_ActionButton""); 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Close""); 
} 
</pre><p>Next, it is important for the file manager class to have a way to easily change its current directory:</p><pre class="programlisting">void GUI_FileManager::SetDirectory(std::string l_dir) { 
  m_dir = l_dir; 
  std::replace(m_dir.begin(), m_dir.end(), '''', ''/''); 
  m_interface-&gt;RemoveElementsContaining(""Entry_""); 
  ListFiles(); 
} 
</pre><p>A couple of interesting things happened. Right after the argument is stored; all of the backward slashes in the directory string are replaced with forward slashes, in order to maintain compatibility with multiple other operating systems that do not play well with the former. The interface is then instructed to destroy all elements it has that begin with the <code class="literal">""Entry_""</code> string. This is done in order to clear out all file and directory entries that may already exist. Finally, <code class="literal">ListFiles()</code> method is invoked, which populates the file manager with all of the files and folders inside the new directory. Let' us take a look at how that can be done:</p><pre class="programlisting">void GUI_FileManager::ListFiles() { 
  m_interface-&gt;GetElement(""Directory"")-&gt;SetText(m_dir); 
  auto list = Utils::GetFileList(m_dir, ""*.*"", true); 
  Utils::SortFileList(list); 
  auto ParentDir = m_interface-&gt;GetElement(""ParentDir""); 
  float x = ParentDir-&gt;GetPosition().x; 
  float y = ParentDir-&gt;GetPosition().y+ParentDir-&gt;GetSize().y+1.f; 
  size_t i = 0; 
  for (auto&amp; file : list) { 
    if (file.first == ""."" || file.first == "".."") { continue; } 
    std::string entry = (file.second ? "FEntry_"" : ""Entry_"); 
    m_interface-&gt;AddElement(GUI_ElementType::Label, 
      entry + std::to_string(i)); 
    auto element = m_interface-&gt;GetElement( 
      entry + std::to_string(i)); 
    element-&gt;SetText(file.first); 
    element-&gt;SetPosition({ x, y }); 
    m_guiManager-&gt;LoadStyle((file.second ? 
      m_folderEntry : m_fileEntry), element); 
    y += ParentDir-&gt;GetSize().y + 4.f; 
    ++i; 
  } 
} 
</pre><p>First, the <code class="literal">Directory</code> element is obtained in order to change its text. It represents the full path of the current working directory. The complete file list inside that directory is then obtained, including other folders. After it gets sorted alphabetically and by type, the parent directory element is obtained to calculate the starting coordinates of the first element on the list, which is, in turn, iterated over. Non-physical directories, such as <code class="literal">"."</code> or <code class="literal">".."</code>, are dismissed. A new element is then added to the interface, with an appropriate name that varies depending on whether we are working with a file or a folder. That same element is then updated to have the entry name, be in the right position and have a correct style attached to it. Finally, the <em>y</em> coordinate is incremented for the next element on the list.</p><p>With the directory structure being visually represented, let us take a look at what needs to happen when one of its entries is actually clicked:</p><pre class="programlisting">void GUI_FileManager::HandleEntries(EventDetails* l_details) { 
  if(l_details-&gt;m_guiElement.find("FEntry_")!= std::string::npos){ 
    std::string path = m_dir + 
      m_interface-&gt;GetElement(l_details-&gt;m_guiElement)-&gt;GetText() 
      + ""; 
    SetDirectory(path); 
    m_interface-&gt;UpdateScrollVertical(0); 
  } else if (l_details-&gt;m_guiElement.find("Entry_") != 
    std::string::npos) 
  { 
    m_interface-&gt;GetElement("FileName")-&gt;SetText( 
     m_interface-&gt;GetElement(l_details-&gt;m_guiElement)-&gt;GetText()); 
  } 
} 
</pre><p>The first check here lets us know whether the item clicked on was a directory or a file. In case of a folder click, we want to be able to traverse the filesystem by taking its name and adding it onto our existing directory path. The vertical scroll of the interface is then set back to zero, in order to move the content back up to the top if any scrolling has been done.</p><p>A file click is a simpler matter. All we need to do in that case is obtain the text-field element that holds the filename, and change its contents to the name of the file that was just clicked on.</p><p>All of this works perfectly for forward-traversal, but what if we want to go backwards? The parent directory element helps us out here:</p><pre class="programlisting">void GUI_FileManager::ParentDirCallback(EventDetails* l_details) { 
  auto i = m_dir.find_last_of("/", m_dir.length() - 2); 
  if (i != std::string::npos) { 
    std::string dir = m_dir.substr(0U, i + 1); 
    SetDirectory(dir); 
  } 
} 
</pre><p>Here, it simply comes down to basic string manipulation. The very last instance of the forward slash character is first attempted to be located inside the directory string. If one is found, the string is simply <em>clipped</em> at that point, in order to drop everything that comes after it. The shortened path is then set as the current directory, where the rest of the magic that we've already covered happens.</p><p>The last piece of the puzzle in making this work is handling the button press action:</p><pre class="programlisting">void GUI_FileManager::ActionButton(EventDetails* l_details) { 
  if (m_actionCallback == nullptr) { return; } 
  auto filename = m_interface-&gt;GetElement("FileName")-&gt;GetText(); 
  m_actionCallback(m_dir + filename); 
} 
</pre><p>First, we need to make sure the action callback is actually set. If it is, it gets invoked with the path to the currently selected file as its argument. The only other action button we have to worry about after this point is the close button:</p><pre class="programlisting">void GUI_FileManager::CloseButton(EventDetails* l_details){ 
  Hide(); 
} 
</pre><p>It simply invokes the <code class="literal">Hide()</code> method, which is covered here, along with its counterpart:</p><pre class="programlisting">void GUI_FileManager::Hide() { m_interface-&gt;SetActive(false); } 
 
void GUI_FileManager::Show() { 
  m_interface-&gt;SetActive(true); 
  m_interface-&gt;PositionCenterScreen(); 
  ListFiles(); 
  m_interface-&gt;Focus(); 
} 
</pre><p>When an interface is hidden, it's simply set to inactive. Showing it requires setting it back to being active, except we also want to position it in the absolute centre of the screen in this instance. In addition to that, it is a good idea to refresh its content, as the file structure may have changed while it was hidden. Lastly, the interface is focused, in order to bring it to the front of the drawing queue.</p><p>The final bits of helpful code for this class consist of these methods:</p><pre class="programlisting">bool GUI_FileManager::IsInSaveMode() const { return m_saveMode; } 
void GUI_FileManager::LoadMode() { 
  m_interface-&gt;GetElement("ActionButton")-&gt;SetText("Load"); 
  m_saveMode = false; 
} 
void GUI_FileManager::SaveMode() { 
  m_interface-&gt;GetElement("ActionButton")-&gt;SetText("Save"); 
  m_saveMode = true; 
} 
</pre><p>They help our other classes interface with this one more easily, by allowing them to determine if the file manager is in <code class="literal">Save</code> or <code class="literal">Load</code> mode, and to switch between the two.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Loading files in a separate thread</h2></div></div></div><p>We have covered the threaded worker base class previously in <a class="link" href="ch01.html" title="Chapter 1. Under the Hood - Setting up the Backend">Chapter 1</a>, <em>Under the Hood - Setting up the Backend</em>. This is exactly where it will come in handy. In order to make the application seem more user-friendly, we want to render a nice loading bar that shows progress while the files are being loaded. Let us start by first defining a data type, used to store file paths that need to be loaded:</p><pre class="programlisting">using LoaderPaths = std::vector&lt;std::pair&lt;std::string, size_t&gt;&gt;; 
</pre><p>The <code class="literal">size_t</code> here represents the number of lines that are in the file, which makes it easy for us to determine the current loading progress. With that out of the way, let us work on the header file:</p><pre class="programlisting">class FileLoader : public Worker { 
public: 
  FileLoader(); 
  void AddFile(const std::string&amp; l_file); 
  virtual void SaveToFile(const std::string&amp; l_file); 
 
  size_t GetTotalLines() const; 
  size_t GetCurrentLine() const; 
private: 
 <strong> virtual bool ProcessLine(std::stringstream&amp; l_stream) = 0;</strong>
<strong>virtual void ResetForNextFile();</strong> 
  void Work(); 
  void CountFileLines(); 
 
  LoaderPaths m_files; 
  size_t m_totalLines; 
  size_t m_currentLine; 
}; 
</pre><p>Any <code class="literal">FileLoader</code> class in our code base needs to implement the <code class="literal">ProcessLine</code> method, which simply defines what needs to happen as each individual line of the file is being parsed. If necessary, it can also take advantage of <code class="literal">SaveToFile</code>, which, as the name states, defines the process of writing the class data out, and <code class="literal">ResetForNextFile</code>. The latter method is invoked after every file that has finished loading, in order to give derivative classes a chance to clean up their internal state.</p><p>As far as data members go, we have a list of loader paths that are to be loaded, the number of total lines of all files that are supposed to be parsed, and the number of the current line being read.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec5"/>Implementing the file loader</h3></div></div></div><p>Let us start simply, and cover the one-liner methods first:</p><pre class="programlisting">FileLoader::FileLoader() : m_totalLines(0), m_currentLine(0) {} 
void FileLoader::AddFile(const std::string&amp; l_file) { 
  m_files.emplace_back(l_file, 0); 
} 
size_t FileLoader::GetTotalLines() const{ return m_totalLines; } 
size_t FileLoader::GetCurrentLine() const{ return m_currentLine; } 
void FileLoader::SaveToFile(const std::string&amp; l_file) {} 
void FileLoader::ResetForNextFile() {} 
</pre><p>The constructor simply initializes a few of the class data members to their default values. The <code class="literal">AddFile()</code> method inserts the argument to the file container with the line count <em>zero</em>. The next two methods are simple getters, while the last two are not even implemented, as they are optional.</p><p>Next, let us work on the method that will actually be running in a thread and parse the file information:</p><pre class="programlisting">void FileLoader::Work() { 
  CountFileLines(); 
  if (!m_totalLines) { return; } 
  for (auto&amp; path : m_files) { 
    ResetForNextFile(); 
    std::ifstream file(path.first); 
    std::string line; 
    std::string name; 
    auto linesLeft = path.second; 
    while (std::getline(file, line)) { 
      { 
        sf::Lock lock(m_mutex); 
        ++m_currentLine; 
        --linesLeft; 
      } 
      if (line[0] == '|') { continue; } 
      std::stringstream keystream(line); 
      if (!ProcessLine(keystream)) { 
        { 
          sf::Lock lock(m_mutex); 
          m_currentLine += linesLeft; 
        } 
        break; 
      } 
    } 
    file.close(); 
  } 
  m_files.clear(); 
  Done(); 
} 
</pre><p>First, a private method for counting all file lines is invoked. This is necessary, as we want to be able to calculate our progress, and knowing how much work there is in total is needed for that. If after this method is called, the total number of lines is zero, we simply return as there is nothing to process.</p><p>We then enter a loop that runs once for each file on the list. The class is reset for new file iteration, and a line from the input stream is created. The number of lines remaining to be processed is created, and another loop is entered that will execute once for each line in the file. Our <code class="literal">sf::Mutex</code> object is then locked in order to safely manipulate the two line data members that are used for progress tracking.</p><p>If the first character of our line is a pipe, <code class="literal">|</code>, it means we ran into a commented line and should just skip the current iteration. Otherwise, an <code class="literal">std::stringstream </code>of the current line is created and passed into the pure virtual <code class="literal">ProcessLine()</code> method, which is encapsulated in an <code class="literal">if</code> statement to catch a possible failure, in which case the remainder of lines inside the current file are simply added to the current line counter and the loop is broken out of.</p><p>Once the processing of all files is complete, the <code class="literal">Done()</code> method is invoked in order to terminate the thread and let the outside code know we've finished.</p><p>Another equally as important process is counting the lines of all file entries inside this class:</p><pre class="programlisting">void FileLoader::CountFileLines() { 
  m_totalLines = 0; 
  m_currentLine = 0; 
  for (auto path = m_files.begin(); path != m_files.end();) { 
    if (path-&gt;first.empty()) { 
      path = m_files.erase(path); 
      continue; 
    } 
    std::ifstream file(path-&gt;first); 
    if (!file.is_open()) { 
      path = m_files.erase(path); 
      continue; 
    } 
    file.unsetf(std::ios_base::skipws); 
    { 
      sf::Lock lock(m_mutex); 
      path-&gt;second = static_cast&lt;size_t&gt;(std::count( 
        std::istreambuf_iterator&lt;char&gt;(file), 
        std::istreambuf_iterator&lt;char&gt;(), 
        '\n')); 
      m_totalLines += path-&gt;second; 
    } 
    ++path; 
    file.close(); 
  } 
} 
</pre><p>This one is fairly straightforward. After the two counters are zeroed out, we begin iterating over each path inside the file list. If the name of it is empty, the element is removed. Otherwise, we attempt to open the files. If that fails, the path is also erased. Otherwise, the file stream is requested to not skip whitespaces, and we enter a <code class="literal">sf::Mutex</code> lock, where the number of lines in the file stream is calculated using <code class="literal">std::count</code>, and added to the total line counter. The path iterator is then moved forward, and the file is closed.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>The loading state</h2></div></div></div><p>The last piece of the threaded file loading puzzle is the loading state. In order to avoid other logic going on and simply focus on the graphical progress representation, it's a good idea to just switch to a dedicated state that will handle all loading logic inside it. Let us begin by defining a data type for holding pointers to <code class="literal">FileLoader*</code> instances:</p><pre class="programlisting">using LoaderContainer = std::vector&lt;FileLoader*&gt;; 
</pre><p>The actual loading state header will end up looking something like this:</p><pre class="programlisting">class State_Loading : public BaseState { 
public: 
  ... // Other typical state methods. 
  void SetManualContinue(bool l_continue); 
  void Proceed(EventDetails* l_details); 
private: 
  void UpdateText(const std::string&amp; l_text, float l_percentage); 
  float CalculatePercentage(); 
  LoaderContainer m_loaders; 
  sf::Text m_text; 
  sf::RectangleShape m_rect; 
  unsigned short m_percentage; 
  size_t m_originalWork; 
  bool m_manualContinue; 
}; 
</pre><p>As you can see, we have one event callback method, a couple of helper methods, the container for loader pointers, an instance of <code class="literal">sf::Text</code> and <code class="literal">sf::RectangleShape</code> to represent the loading bar, a number to represent the progress percentage, and the number of lines inside all files we originally started with.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec6"/>Implementing the loading state</h3></div></div></div><p>All of this data needs to be initialized before it being used, so let us take a look at the <code class="literal">OnCreate()</code> method:</p><pre class="programlisting">void State_Loading::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  context-&gt;m_fontManager-&gt;RequireResource("Main"); 
  m_text.setFont(*context-&gt;m_fontManager-&gt;GetResource("Main")); 
  m_text.setCharacterSize(14); 
  m_text.setStyle(sf::Text::Bold); 
 
  sf::Vector2u windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
 
  m_rect.setFillColor(sf::Color(0, 150, 0, 255)); 
  m_rect.setSize(sf::Vector2f(0.f, 16.f)); 
  m_rect.setOrigin(0.f, 8.f); 
  m_rect.setPosition(0.f, windowSize.y / 2.f); 
 
  EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  evMgr-&gt;AddCallback(StateType::Loading, 
    "Key_Space", &amp;State_Loading::Proceed, this); 
} 
</pre><p>Because we are going to be using text, we need to have a font to work with. After one is acquired and all of the stylistic text settings are handled, we set up the rectangle to be exactly in the centre of the screen and register an event callback for proceeding out of the loading state, if the manual continue flag is set to <code class="literal">true</code>.</p><p>Destroying this state also means the event callback and the font need to be released:</p><pre class="programlisting">void State_Loading::OnDestroy() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::Loading, "Key_Space"); 
  context-&gt;m_fontManager-&gt;ReleaseResource("Main"); 
} 
</pre><p>Next, let us take a look at the updated logic:</p><pre class="programlisting">void State_Loading::Update(const sf::Time&amp; l_time) { 
  if (m_loaders.empty()) { 
    if (!m_manualContinue) { Proceed(nullptr); } 
    return; 
  } 
  auto windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
  if (m_loaders.back()-&gt;IsDone()) { 
    m_loaders.back()-&gt;OnRemove(); 
    m_loaders.pop_back(); 
    if (m_loaders.empty()) { 
      m_rect.setSize(sf::Vector2f( 
        static_cast&lt;float&gt;(windowSize.x), 16.f)); 
      UpdateText(".Press space to continue.", 100.f); 
      return; 
    } 
  } 
  if (!m_loaders.back()-&gt;HasStarted()){m_loaders.back()-&gt;Begin();} 
 
  auto percentage = CalculatePercentage(); 
  UpdateText("", percentage); 
  m_rect.setSize(sf::Vector2f( 
    (windowSize.x / 100) * percentage, 16.f)); 
} 
</pre><p>First, a check is made to determine if we are ready to exit the state, given all of the work that has been done. If the manual continue flag is set to <code class="literal">false</code>, we simply invoke the Proceed callback directly by passing <code class="literal">nullptr</code> as the <code class="literal">EventDetails</code> pointer, since it is not used there anyway. The update method is then returned from.</p><p>If we still have some work to do, the first element on the loader list is checked to see if it's done. If it is, the loader is removed, and if it was the last one, the size of the rectangle is set to match the full size of the window on the x axis, which shows full completion. The text in the middle is also updated to let the user know they need to press the spacebar key to continue. Finally, the update method is returned from once again, to prevent further logic from executing.</p><p>If none of those conditions were met, the first element on the loader list is checked to see if it has started its work. If it has not yet started, its <code class="literal">Begin</code> method is invoked. This is quickly followed by the percentage calculation, which is then used to update the text in the middle of the screen and adjust the size of the progress bar rectangle to match said percentage.</p><p>Drawing in this state simply comes down to two calls:</p><pre class="programlisting">void State_Loading::Draw() { 
  sf::RenderWindow* wind = m_stateMgr-&gt; 
    GetContext()-&gt;m_wind-&gt;GetRenderWindow(); 
  wind-&gt;draw(m_rect); 
  wind-&gt;draw(m_text); 
} 
</pre><p>All we need to do here is render the rectangle and the text instances.</p><p>Next, let us take a look at the helper method that updates our text instance:</p><pre class="programlisting">void State_Loading::UpdateText(const std::string&amp; l_text, 
  float l_percentage) 
{ 
  m_text.setString(std::to_string( 
    static_cast&lt;int&gt;(l_percentage)) + "%" + l_text); 
  auto windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
  m_text.setPosition(windowSize.x / 2.f, windowSize.y / 2.f); 
  Utils::CenterSFMLText(m_text); 
} 
</pre><p>After the text string is updated, its position is updated to be directly in the middle of the screen. Since updating its contents may change the bounding box, and thus how it is centered, a helper function inside our <code class="literal">Utils</code> namespace is used to center it properly.</p><p>Next, let us calculate the actual progress of the loading procedure:</p><pre class="programlisting">float State_Loading::CalculatePercentage() { 
  float absolute = 100.f; 
  if (m_loaders.back()-&gt;GetTotalLines()) { 
    float d = (100.f * (m_originalWork - m_loaders.size())) / 
      static_cast&lt;float&gt;(m_originalWork); 
    float current = (100.f * m_loaders.back()-&gt;GetCurrentLine()) / 
      static_cast&lt;float&gt;(m_loaders.back()-&gt;GetTotalLines()); 
    float totalCurrent = current / 
      static_cast&lt;float&gt;(m_originalWork); 
    absolute = d + totalCurrent; 
  } 
  return absolute; 
} 
</pre><p>After an absolute value of <code class="literal">100.f</code> is created, the current progress is calculated by first determining the progress of how many files have been already loaded out of the number we began with, followed by the progress of the current file being calculated and used to determine absolute progress, which is then returned.</p><p>Once all of the work is done, the <code class="literal">Proceed()</code> method is invoked to return to the previous state:</p><pre class="programlisting">void State_Loading::Proceed(EventDetails* l_details) { 
  if (!m_loaders.empty()) { return; } 
  m_stateMgr-&gt;SwitchTo(m_stateMgr-&gt;GetNextToLast()); 
} 
</pre><p>Obviously it needs to check if the list of file loaders is actually empty first. If it is, the state manager is instructed to switch to the state that comes just before this one, which means it is the one that initiated the loading procedure.</p><p>Finally, what would a class be without some helper methods? Let us take a look at them now:</p><pre class="programlisting">void State_Loading::AddLoader(FileLoader* l_loader) { 
  m_loaders.emplace_back(l_loader); 
  l_loader-&gt;OnAdd(); 
} 
bool State_Loading::HasWork() const { return !m_loaders.empty(); } 
void State_Loading::Activate() { 
  m_originalWork = m_loaders.size(); 
} 
</pre></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Creating the map editor state</h1></div></div></div><p>Now we're finally ready to actually tackle the state, in which all of the map editing is going to take place. Let us take a gander at its header file:</p><pre class="programlisting">class State_MapEditor : public BaseState { 
public: 
  ... 
  void ResetSavePath(); 
  void SetMapRedraw(bool l_redraw); 
  void MainMenu(EventDetails* l_details); 
  void MapEditorNew(EventDetails* l_details); 
  void MapEditorLoad(EventDetails* l_details); 
  void MapEditorSave(EventDetails* l_details); 
  void MapEditorSaveAs(EventDetails* l_details); 
  void MapEditorExit(EventDetails* l_details); 
  void MapAction(const std::string&amp; l_name); 
private: 
  void SaveMap(const std::string&amp; l_path); 
  void LoadMap(const std::string&amp; l_path); 
  GUI_FileManager m_files; 
  MapControls m_mapControls; 
  std::string m_mapSavePath; 
  bool m_mapRedraw; 
}; 
</pre><p>This <code class="literal">State_MapEditor</code> class is going to be the frontier that deals with the most general editor events. Note the highlighted data member here. We have not yet covered this class, but it is responsible for handling the finer aspects of control for this application. It will be covered in the next chapter.</p><p>Aside from the <code class="literal">MapControls</code> class, we also have the file manager, a string for the path to a file that is currently being worked on, and a <em>boolean</em> flag that keeps track of whether the game map should be redrawn or not.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Implementing the state</h2></div></div></div><p>As always, let us begin by tackling the construction of all the important data inside this state:</p><pre class="programlisting">void State_MapEditor::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;AddCallback("Key_Escape", 
    &amp;State_MapEditor::MainMenu, this); 
  evMgr-&gt;AddCallback("MapEditor_New", 
    &amp;State_MapEditor::MapEditorNew, this); 
  evMgr-&gt;AddCallback("MapEditor_Load", 
    &amp;State_MapEditor::MapEditorLoad, this); 
  evMgr-&gt;AddCallback("MapEditor_Save", 
    &amp;State_MapEditor::MapEditorSave, this); 
  evMgr-&gt;AddCallback("MapEditor_SaveAs", 
    &amp;State_MapEditor::MapEditorSaveAs, this); 
  evMgr-&gt;AddCallback("MapEditor_Exit", 
    &amp;State_MapEditor::MapEditorExit, this); 
 
  m_files.SetActionCallback(&amp;State_MapEditor::MapAction, this); 
  m_files.SetDirectory(Utils::GetWorkingDirectory() + 
    "media/maps/"); 
  m_files.Hide(); 
  context-&gt;m_guiManager-&gt;LoadInterface( 
    "MapEditorTop.interface", "MapEditorTop"); 
  context-&gt;m_guiManager-&gt;GetInterface("MapEditorTop")-&gt; 
    SetPosition({ 200, 0 }); 
 
  context-&gt;m_particles-&gt;CreateState(StateType::MapEditor); 
} 
</pre><p>After all of the event callbacks are set up, the file manager class is provided with its own callback for either loading or saving a file, as well as the starting directory it needs to be in. In this case, appropriately enough, it is the maps folder. The manager is then hidden, and another interface is loaded and positioned on screen. <code class="literal">MapEditorTop</code> is the control strip on the very top of the screen that has buttons for creating a new map, loading, saving, and exiting the application:</p><p>
</p><div><img src="img/image_04_002.jpg" alt="Implementing the state"/></div><p>
</p><p>Once the state is finished and is about to be destroyed, it needs to remove all call-backs that it set up. This can be done in the <code class="literal">OnDestroy()</code> method:</p><pre class="programlisting">void State_MapEditor::OnDestroy() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto textureMgr = context-&gt;m_textureManager; 
  auto evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "Key_Escape"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_New"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Load"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Save"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_SaveAs"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Exit"); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;GetTileMap()-&gt;SetMapSize({ 0,0 }); 
} 
</pre><p>In addition to callbacks, the map is also purged just before its size is set back to absolute zero. Since we are on the subject of callbacks, let us just cover most of them in a single go:</p><pre class="programlisting">void State_MapEditor::MapEditorNew(EventDetails* l_details) { 
  m_mapControls.NewMap(); 
} 
void State_MapEditor::MapEditorLoad(EventDetails* l_details) { 
  m_files.LoadMode(); 
  m_files.Show(); 
} 
 
void State_MapEditor::MapEditorSave(EventDetails* l_details) { 
  if (m_mapSavePath.empty()) { MapEditorSaveAs(nullptr); return; } 
  SaveMap(m_mapSavePath); 
} 
void State_MapEditor::MapEditorSaveAs(EventDetails* l_details) { 
  m_files.SaveMode(); 
  m_files.Show(); 
} 
 
void State_MapEditor::MapEditorExit(EventDetails* l_details) { 
  m_stateMgr-&gt;SwitchTo(StateType::MainMenu); 
  m_stateMgr-&gt;Remove(StateType::MapEditor); 
} 
</pre><p>When the <strong>New</strong> map button is clicked, we want to invoke a special method of the <code class="literal">MapControls</code> class that will handle it. If the <strong>Load</strong> button is clicked, we simply switch the mode of the file manager to load, and show it on screen.</p><p>Clicking the <strong>Save</strong> button can have two behaviors. First, if we are dealing with a fresh, new map that has not been saved yet, it is the same as clicking the <strong>Save As...</strong> button, which switches the file manager to save mode and shows it on screen. However, if we have loaded a map or have previously saved a new one, the state remembers where it was saved, as well as its name. Prompting the user to enter a filename again would be pointless here, so the map is simply written to the exact same location, with the exact same name.</p><p>Finally, if the <strong>Exit</strong> button is clicked, we simply switch back to the main menu state and remove this one.</p><p>With the UI code out of the way, let us take a look at what needs to happen when a map is being loaded:</p><pre class="programlisting">void State_MapEditor::LoadMap(const std::string&amp; l_path) { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto loading = m_stateMgr-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  context-&gt;m_particles-&gt;PurgeCurrentState(); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;ResetWorker(); 
  context-&gt;m_gameMap-&gt;GetTileMap()-&gt;GetTileSet().ResetWorker(); 
  context-&gt;m_gameMap-&gt;AddFile(l_path); 
  loading-&gt;AddLoader(context-&gt;m_gameMap); 
  loading-&gt;SetManualContinue(false); 
  m_mapRedraw = true; 
  m_mapSavePath = l_path; 
  m_stateMgr-&gt;SwitchTo(StateType::Loading); 
} 
</pre><p>Since we want a nice loading bar to appear as a map is being read in, we are going to be using the loading state. After it is obtained, both the particle system and the map are purged. The map, which inherits from the <code class="literal">FileLoader</code> class, is then reset. The file path that was provided as an argument is then added to it to be loaded, and the loading state itself is set up to automatically dismiss itself once the loading is done. At the same time, we make sure that the map is going to be re-drawn as the map editor state resumes, and that it remembers the path of the map if it is to be saved later. Finally, we can switch to the loading state.</p><p>Next, let us work on the code that is responsible for saving the map:</p><pre class="programlisting">void State_MapEditor::SaveMap(const std::string&amp; l_path) { 
  m_stateMgr-&gt;GetContext()-&gt;m_gameMap-&gt;SaveToFile(l_path); 
  m_mapSavePath = l_path; 
} 
</pre><p>This is much simpler than the previous method. The path is simply passed to the <code class="literal">SaveToFile</code> method of the game map class, and stored for later use.</p><p>The actual callback of the file manager that mediates between the load and save methods can be implemented like :</p><pre class="programlisting">void State_MapEditor::MapAction(const std::string&amp; l_path) { 
  if(m_files.IsInSaveMode()) { SaveMap(l_path); } 
  else { LoadMap(l_path); } 
  m_files.Hide(); 
} 
</pre><p>Depending on the mode the file manager is in, the appropriate method is called with the path being passed in as the argument. The actual interface is then hidden.</p><p>Because we want to re-draw the map after it was loaded, the perfect place for that logic is inside the <code class="literal">Activate()</code> method, as it gets called right when a state is switched to:</p><pre class="programlisting">void State_MapEditor::Activate() { 
  if (!m_mapRedraw) { return; } 
  auto map = m_stateMgr-&gt;GetContext()-&gt;m_gameMap; 
  map-&gt;Redraw(); 
  m_mapControls.SetTileSheetTexture( 
    map-&gt;GetTileSet()-&gt;GetTextureName()); 
  m_mapRedraw = false; 
} 
</pre><p>If the <code class="literal">m_mapRedraw</code> flag is not on, there is no need to do anything at this point. Otherwise, we want to redraw the map and provide the <code class="literal">mapControls</code> class with the tile-sheet texture name, so that it can perform its own logic, such as, for example, tile selection.</p><p>Next, let us take a look at what needs to be updated while the application is in this state:</p><pre class="programlisting">void State_MapEditor::Update(const sf::Time&amp; l_time) { 
  auto context = m_stateMgr-&gt;GetContext(); 
  m_mapControls.Update(l_time.asSeconds()); 
  context-&gt;m_gameMap-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_systemManager-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_particles-&gt;Update(l_time.asSeconds()); 
} 
</pre><p>Alongside the <code class="literal">mapControls</code> class, the game map, ECS system manager, and the particle system also need to be updated, because we are going to be using all of these classes while building maps. Predictably enough, these are the same objects that also need to be drawn:</p><pre class="programlisting">void State_MapEditor::Draw() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto window = context-&gt;m_wind-&gt;GetRenderWindow(); 
  auto from = (m_mapControls.DrawSelectedLayers() ? 
    m_mapControls.GetSelectionOptions()-&gt;GetLowestLayer() : 0); 
  auto to = (m_mapControls.DrawSelectedLayers() ? 
    m_mapControls.GetSelectionOptions()-&gt;GetHighestLayer() 
    : Sheet::Num_Layers - 1); 
  for (auto i = from; i &lt;= to; ++i) { 
    context-&gt;m_gameMap-&gt;Draw(i); 
    context-&gt;m_systemManager-&gt;Draw(context-&gt;m_wind, i); 
    context-&gt;m_particles-&gt;Draw(*window, i); 
  } 
  if(!m_mapControls.DrawSelectedLayers()) { 
    context-&gt;m_particles-&gt;Draw(*window, -1); 
  } 
  m_mapControls.Draw(window); 
} 
</pre><p>Note the <code class="literal">from</code> and <code class="literal">to</code> variables. The <code class="literal">mapControl</code> class is going to provide us with a way to switch between layers/elevations, so we need to obtain that information before anything is rendered, in order to make sure only the appropriate layers are drawn on screen. <code class="literal">DrawSelectedLayers</code> simply returns a <em>boolean</em> value that determines whether or not all layers should be drawn, or just the selected ones. Once the loop has iterated over the appropriate elevations, we make sure to draw the remaining particles that are above the maximum elevation, provided, of course, everything needs to be rendered. This is topped off by the map controls being drawn over everything else.</p><p>For other outside communications with this class, we provide two basic setter methods:</p><pre class="programlisting">void State_MapEditor::ResetSavePath() { m_mapSavePath = ""; } 
void State_MapEditor::SetMapRedraw(bool l_redraw) { 
  m_mapRedraw = l_redraw; 
} 
</pre><p>These are going to be used inside the control classes to communicate events, such as a new map being created, or it needing to be re-drawn.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Building the control mechanism</h1></div></div></div><p>While building maps, the user tends to run into situations where they need more than just a tile being placed where the mouse clicks. It would definitely be useful to have tools that would enable them to freely pan around, select chunks of the map for deletion or copying, erase them and so on. Our control class is going to serve this exact purpose. It will provide a set of tools that can be used for multiple different situations:</p><pre class="programlisting">enum class ControlMode{None, Pan, Brush, Bucket, Eraser, Select}; 
</pre><p>The preceding control mode enumeration represents a couple of the most common tools that come in a variety of different pieces of software. We're going to implement some of them here, and leave the rest up to you! In the end, we should have a control interface that looks a little like this:</p><div><img src="img/image_04_003.jpg" alt="Building the control mechanism"/></div><p>Let us get to actually writing out the header for the control class. For clarity, we are going to be discussing its methods and data members separately, starting with the member functions:</p><pre class="programlisting">class MapControls { 
public: 
  MapControls(Window* l_window, EventManager* l_eventManager, 
    StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, 
    EntityManager* l_entityMgr, ParticleSystem* l_particles, 
    sf::View&amp; l_view); 
  ~MapControls(); 
 
  void Update(float l_dT); 
  void Draw(sf::RenderWindow* l_window); 
 
  void NewMap(); 
  void SetTileSheetTexture(const std::string&amp; l_sheet); 
  ControlMode GetMode() const; 
  bool IsInAction() const; 
  bool IsInSecondary() const; 
  GUI_SelectionOptions* GetSelectionOptions(); 
 
  sf::Vector2i GetMouseTileStart()const; 
  sf::Vector2i GetMouseTile()const; 
  sf::Vector2f GetMouseDifference()const; 
 
  bool DrawSelectedLayers()const; 
  void ToggleDrawingSelectedLayers(); 
 
  void MouseClick(EventDetails* l_details); 
  void MouseRelease(EventDetails* l_details); 
  void MouseWheel(EventDetails* l_details); 
  void ToolSelect(EventDetails* l_details); 
  void DeleteTiles(EventDetails* l_details); 
  void NewMapCreate(EventDetails* l_details); 
  void NewMapClose(EventDetails* l_details); 
 
  void SelectMode(ControlMode l_mode); 
  void RedrawBrush(); 
private: 
  void UpdateMouse(); 
  void PanUpdate(); 
  void BrushUpdate(); 
  void BucketUpdate(); 
  void EraserUpdate(); 
  void SelectionUpdate(); 
   
  void PlaceBrushTiles(); 
  void ResetZoom(); 
  void ResetTools(); 
  ... 
}; 
</pre><p>In addition to all of the helper methods for setting and getting the class parameters, we have a whole bunch of event callbacks, as well as individual update methods for every kind of map tool we're going to be working with. Next, let us take a look at the data members we are going to be working with:</p><pre class="programlisting">class MapControls { 
private: 
  ... 
  // Mode and mouse/layer flags. 
  ControlMode m_mode; 
  bool m_action; 
  bool m_secondaryAction; 
  bool m_rightClickPan; 
  bool m_drawSelectedLayers; 
  // Mouse information. 
  sf::Vector2i m_mousePosition; 
  sf::Vector2i m_mouseStartPosition; 
  sf::Vector2f m_mouseDifference; 
  sf::Vector2i m_mouseTilePosition; 
  sf::Vector2i m_mouseTileStartPosition; 
  float m_zoom; 
  // Brush information, and map bounds. 
  TileMap m_brush; 
  sf::RenderTexture m_brushTexture; 
  sf::RectangleShape m_brushDrawable; 
  sf::RectangleShape m_mapBoundaries; 
  // Other interfaces used here. 
  GUI_MapTileSelector m_tileSelector; 
  GUI_SelectionOptions m_selectionOptions; 
  GUI_Interface* m_mapSettings; 
  // Ties to other classes. 
  Window* m_window; 
  EventManager* m_eventManager; 
  StateManager* m_stateManager; 
  Map* m_map; 
  GUI_Manager* m_guiManager; 
  EntityManager* m_entityManager; 
  ParticleSystem* m_particleSystem; 
  sf::View&amp; m_view; 
}; 
</pre><p>Alongside the <code class="literal">ControlMode</code> that this class is currently in, we are also going to be storing a couple of flags. The <code class="literal">m_action</code> flag will be used with tools, as well as <code class="literal">m_secondaryAction</code>. The former simply denotes whether the left mouse button is pressed or not, while the latter is used with an action that can only happen once the mouse position has changed. This will prove useful when we are trying to optimize certain things to not happen, unless they absolutely have to. The last two flags signify whether we are currently right-click panning, and whether only the selected layers should be drawn on screen.</p><p>Below that, there are a couple of 2D vectors, used to store mouse information, such as its current position, where a left-click first happened, the difference between the current and last frame in the mouse position, its current position in tile coordinates, and its starting position in tile coordinates. Additionally, we also have a floating point value for the current zoom factor.</p><p>For the brush that will be used to paint with, we simply use a <code class="literal">TileMap</code> structure, just like the game map class does. Since the brush is going to have to be drawn on screen, we need to store a texture for it, as well as another drawable object that will be used to show it. Finally, a <code class="literal">sf::RectangleShape</code> type is going to more than suffice for showing the boundaries of the map on screen.</p><p>Additional code separation, especially when code is becoming quite lengthy, is always a good idea. For this purpose, other non-general-control logic is going to be spread out into two additional interface classes: a tile selector, and the selection options. A tile selector is a simple window that shows the entire tile-sheet and allows the user to select tiles they want to paint with, while selection options is a separate interface that provides us with a myriad of settings that can be tweaked when specific things on screen are selected. Both of these classes are going to be covered in the next chapter.</p><p>Lastly, we have another interface, named <code class="literal">m_mapSettings</code>, the logic of which is going to be handled within the <code class="literal">MapControls</code> class. When creating new maps, we need a neat little window that is going to allow us to configure the size of the map, its default friction value, and the name of the tile-sheet it is going to be using. This is exactly the purpose the map settings interface is going to serve.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Implementing controls</h2></div></div></div><p>There are quite a few data members to initialize, so let us take a look at how the constructor manages it:</p><pre class="programlisting">MapControls::MapControls(Window* l_window, EventManager* l_eventManager, 
  StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, 
  EntityManager* l_entityMgr, ParticleSystem* l_particles, 
  sf::View&amp; l_view): 
  /* Storing arguments first. */ 
  m_window(l_window), m_eventManager(l_eventManager), 
  m_stateManager(l_stateManager), m_map(l_map), 
  m_guiManager(l_gui), m_entityManager(l_entityMgr), 
  m_particleSystem(l_particles), m_view(l_view), 
  /* Setting up initial data member values. */ 
  m_mode(ControlMode::Pan), m_action(false), 
  m_secondaryAction(false), m_rightClickPan(false), 
  m_zoom(1.f), m_brush(sf::Vector2u(1, 1), *l_map-&gt;GetTileSet()), 
  m_drawSelectedLayers(false), 
  /* Initializing other interface classes. */ 
  m_tileSelector(l_eventManager, l_gui, 
    l_gui-&gt;GetContext()-&gt;m_textureManager), 
  m_mapSettings(nullptr), 
  m_selectionOptions(l_eventManager, l_gui, this, 
    &amp;m_tileSelector, l_map, &amp;m_brush, l_entityMgr, l_particles) 
{ ... } 
</pre><p>As you can see, there is quite a lot going on here. Let us zip through it section by section. Right after the arguments of the constructor are processed, we set up the data members of this class to hold their initial values. Shortly after that, the custom interface classes get set up, with all the necessary arguments being passed to their constructors. For now, we are not going to be worrying about them, as they will be covered in the next chapter.</p><p>Let us take a look at the actual constructor body next:</p><pre class="programlisting">MapControls::MapControls(...) 
{ 
  ... // All of the callbacks gets set up. 
  m_guiManager-&gt;LoadInterface("MapEditorTools.interface", 
    "MapEditorTools"); 
  m_guiManager-&gt;GetInterface("MapEditorTools")-&gt; 
    SetPosition({ 0.f, 16.f }); 
  m_guiManager-&gt;LoadInterface("MapEditorNewMap.interface", 
    "MapEditorNewMap"); 
  m_mapSettings = m_guiManager-&gt;GetInterface("MapEditorNewMap"); 
  m_mapSettings-&gt;PositionCenterScreen(); 
  m_mapSettings-&gt;SetActive(false); 
 
  m_brush.SetTile(0, 0, 0, 0); 
  m_brushDrawable.setFillColor({ 255, 255, 255, 200 }); 
  m_brushDrawable.setOutlineColor({ 255, 0, 0, 255 }); 
  m_brushDrawable.setOutlineThickness(-1.f); 
  m_mapBoundaries.setPosition({ 0.f, 0.f }); 
  m_mapBoundaries.setFillColor({ 0,0,0,0 }); 
  m_mapBoundaries.setOutlineColor({255, 50, 50, 255}); 
  m_mapBoundaries.setOutlineThickness(-1.f); 
 
  auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_mapSettings-&gt;GetElement("SheetDropdown"))-&gt;GetMenu(); 
  dropdown-&gt;PurgeEntries(); 
  auto names = Utils::GetFileList(Utils::GetWorkingDirectory() + 
    "media/Tilesheets/", "*.tilesheet"); 
  for (auto&amp; entity : names) { 
    dropdown-&gt;AddEntry(entity.first.substr( 
      0, entity.first.find(".tilesheet"))); 
  } 
  dropdown-&gt;Redraw(); 
} 
</pre><p>Right after all event callbacks get set up, we begin working on the interfaces. The actual tools interface is loaded and positioned on screen, as well as the new map settings window, which we are going to keep track of by storing its pointer as one of our data members. It gets positioned in the centre of the screen and set as inactive for the time being.</p><p>The next segment simply deals with the stylistic aspects of the brush drawable, as well as the map boundaries rectangle. These values can obviously be customized to look completely different.</p><p>Lastly, we need to make sure to populate the drop-down element for sheet selection inside the new map settings interface. After the element is obtained and cleared of all other entries, the list of all filenames that are of type <code class="literal">.tilesheet</code> inside the appropriate location is obtained and iterated over, stripping away the file format from each one and adding it to the drop-down list, which is then re-drawn to reflect all changes.</p><p>Keep in mind that all interfaces and callbacks that were created here need to be removed, which is all that happens in the destructor. For that specific reason, we are not going to be covering that here, as it is redundant.</p><p>Let us take a look at what needs to happen when this class is being updated:</p><pre class="programlisting">void MapControls::Update(float l_dT) { 
  m_mapBoundaries.setSize(sf::Vector2f( 
    m_map-&gt;GetTileMap()-&gt;GetMapSize() * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size))); 
  UpdateMouse(); 
  if (m_mode == ControlMode::Pan || m_rightClickPan){PanUpdate();} 
  else if (m_mode == ControlMode::Brush) { BrushUpdate(); } 
  else if (m_mode == ControlMode::Bucket) { BucketUpdate(); } 
  else if (m_mode == ControlMode::Eraser) { EraserUpdate(); } 
  else if (m_mode == ControlMode::Select) { SelectionUpdate(); } 
} 
</pre><p>First, we handle any possible changes in size of the map class. The map boundary rectangle is updated here to reflect them. Next, we must make sure the mouse is updated properly. All of that logic is contained within the <code class="literal">UpdateMouse</code> method, which is invoked here. Finally, depending on the current <code class="literal">ControlMode</code>, we need to invoke the appropriate update method for the specific tool that is selected. The pan tool is special in a way, because it will be updated when it is selected as a tool, and when the right mouse button is being pressed as well.</p><p>Drawing all of these objects may be simpler than you think:</p><pre class="programlisting">void MapControls::Draw(sf::RenderWindow* l_window) { 
  l_window-&gt;draw(m_mapBoundaries); 
  if (m_mode == ControlMode::Brush) { 
    l_window-&gt;draw(m_brushDrawable); 
  } 
  m_selectionOptions.Draw(l_window); 
} 
</pre><p>In this specific instance, all we need to render is the rectangle of the <code class="literal">mapBoundaries</code>, the brush, if the <code class="literal">ControlMode</code> is set to <code class="literal">Brush</code>, and the <code class="literal">SelectionOptions</code> class, which has its own <code class="literal">Draw</code> method. More on that will be covered in the next chapter.</p><p>Next, let us implement everything necessary to keep track of all the relevant mouse information:</p><pre class="programlisting">void MapControls::UpdateMouse() { 
  auto mousePos = m_eventManager-&gt;GetMousePos( 
    m_window-&gt;GetRenderWindow()); 
  m_mouseDifference = sf::Vector2f(mousePos - m_mousePosition); 
  m_mouseDifference *= m_zoom; 
  m_mousePosition = mousePos; 
  auto view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); 
  auto mouseGlobal=viewPos+(sf::Vector2f(m_mousePosition)*m_zoom); 
  auto newPosition = sf::Vector2i( 
    floor(mouseGlobal.x / Sheet::Tile_Size), 
    floor(mouseGlobal.y / Sheet::Tile_Size) 
  ); 
 
  if (m_mouseTilePosition != newPosition &amp;&amp; m_action) { 
    m_secondaryAction = true; 
  } 
  m_mouseTilePosition = newPosition; 
} 
</pre><p>After the current mouse position is obtained, it is used to compute the coordinate difference between the current frame and the previous one.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Since the mouse difference is expressed in <strong>global coordinates</strong>, we must remember to multiply them by the <em>zoom factor</em>.</p></div></div><p>The mouse position is then stored for the next frame, so this process can take place all over again. The current <code class="literal">sf::View</code> is then obtained for calculating the current <strong>global</strong> position of the camera. From this, we can calculate the global mouse position (adjusted for zoom, of course), and the mouse tile position, which is simply the tile that's being pointed at.</p><p>The current mouse tile position is then checked against the calculated result for being different. If it is, and the left mouse button is currently being pressed (as shown by the <code class="literal">m_action</code> data member), the secondary action flag is turned on. The mouse tile position is then stored for the next frame.</p><p>The next method in the mouse variety deals with left and right clicks, and can be implemented like so:</p><pre class="programlisting">void MapControls::MouseClick(EventDetails* l_details) { 
  if (l_details-&gt;m_hasBeenProcessed) { return; } 
  if (l_details-&gt;m_keyCode != 
    static_cast&lt;int&gt;(MouseButtonType::Left)) 
  { 
    m_rightClickPan = true; 
    return; 
  } 
  m_mousePosition = m_eventManager-&gt;GetMousePos( 
    m_window-&gt;GetRenderWindow()); 
  m_mouseStartPosition = m_mousePosition; 
 
  auto view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); 
  auto mouseGlobal = viewPos + (sf::Vector2f(m_mousePosition) 
    * m_zoom); 
  m_mouseTileStartPosition = sf::Vector2i( 
    floor(mouseGlobal.x / Sheet::Tile_Size), 
    floor(mouseGlobal.y / Sheet::Tile_Size) 
  ); 
 
  if (!m_selectionOptions.MouseClick(mouseGlobal)) { return; } 
 
  m_action = true; 
  m_secondaryAction = true; 
} 
</pre><p>Because something else may have already processed a mouse event, we need to check for the event details that get submitted as an argument. We do not want to accidentally paint some tiles on the map if we are simply interacting with an interface, for example. Next, the key code of the event is checked to see whether it is the left mouse button. If it is not, all we need to worry about is setting the right-click pan flag to <code class="literal">true</code> and returning.</p><p>If we indeed have a left-click, on the other hand, the current mouse position is stored as both the starting and the current positions. A very similar process to updating the mouse takes place here, leading to the calculation of the global mouse coordinates. They are then passed into the <code class="literal">MouseClick()</code> method of the selection options class, which returns a <em>boolean</em> flag, signifying whether any entities or particle emitters have been selected. We will be dealing with that in the next chapter. If that is not the case, however, both the action and secondary action flags are set to <code class="literal">true</code> in order to use the currently selected tool.</p><p>In the same way that for every action there is an equal and opposite reaction, for each click we need to have a release:</p><pre class="programlisting">void MapControls::MouseRelease(EventDetails* l_details) { 
  if (l_details-&gt;m_keyCode != 
    static_cast&lt;int&gt;(MouseButtonType::Left)) 
  { 
    m_rightClickPan = false; 
    return; 
  } 
  m_action = false; 
  m_secondaryAction = false; 
  m_selectionOptions.MouseRelease(); 
} 
</pre><p>All we need to worry about here is resetting all of the action flags that are used while the mouse is active. This includes the right-click panning, and both action flags. The selection options interface also needs to be notified of a release.</p><p>A neat little feature that is going to help out a lot is being able to zoom in and out. It is handled here as an event:</p><pre class="programlisting">void MapControls::MouseWheel(EventDetails* l_details) { 
  if (l_details-&gt;m_hasBeenProcessed) { return; } 
  float factor = 0.05f; 
  factor *= l_details-&gt;m_mouseWheelDelta; 
  factor = 1.f - factor; 
  m_view.zoom(factor); 
  m_zoom *= factor; 
} 
</pre><p>If this event has not already been processed by something else, we proceed to calculate the amount of zoom that needs to happen. A <code class="literal">float factor</code> value is defined here, and is multiplied by the change in the mouse wheel position. In order for it to be treated as a scale factor, it is subtracted from <code class="literal">1.f</code>, and then used to zoom in the view. Finally, in order to keep track of the current zoom value, we must multiply it by the said scale factor.</p><p>The next event we need to worry about is one of the tools being selected:</p><pre class="programlisting">void MapControls::ToolSelect(EventDetails* l_details) { 
  auto mode = ControlMode::None; 
  if (l_details-&gt;m_name == "MapEditor_PanTool") { 
    mode = ControlMode::Pan; 
  } else if (l_details-&gt;m_name == "MapEditor_BrushTool") { 
    mode = ControlMode::Brush; 
  } else if (l_details-&gt;m_name == "MapEditor_PaintTool") { 
    mode = ControlMode::Bucket; 
  } else if (l_details-&gt;m_name == "MapEditor_EraserTool") { 
    mode = ControlMode::Eraser; 
  } else if (l_details-&gt;m_name == "MapEditor_SelectTool") { 
    mode = ControlMode::Select; 
  } 
  SelectMode(mode); 
} 
</pre><p>This is quite simple, as we basically map the names of elements to their <code class="literal">ControlMode</code> counter-parts. The appropriate mode is then selected on the bottom.</p><p>Speaking of tools, each one of them has their own individual update method. Let us begin by taking a look at how the pan tool is updated:</p><pre class="programlisting">void MapControls::PanUpdate() { 
  if (!m_action &amp;&amp; !m_rightClickPan) { return; } 
  if (m_mouseDifference == sf::Vector2f(0.f, 0.f)) { return; } 
  m_view.setCenter(m_view.getCenter() + 
    (sf::Vector2f(0.f, 0.f) - sf::Vector2f(m_mouseDifference))); 
} 
</pre><p>We obviously do not want the screen to move if the mouse is not being clicked, or if the mouse position delta between frames is absolute zero. Given that both those conditions are satisfied, however, all we need to do is move the centre of the view to a different location. This location is calculated by adding its current position with the mouse position difference, which has to have its sign flipped. We do this, because as the mouse is clicked and moved left, for example, the view needs to shift right in order to feel natural. The same is true for the <em>x</em> axis.</p><p>In the case of a brush tool, the logic goes like this:</p><pre class="programlisting">void MapControls::BrushUpdate() { 
  auto tilePos = sf::Vector2f( 
    static_cast&lt;float&gt;(m_mouseTilePosition.x * Sheet::Tile_Size), 
    static_cast&lt;float&gt;(m_mouseTilePosition.y * Sheet::Tile_Size) 
  ); 
  m_brushDrawable.setPosition(tilePos); 
  PlaceBrushTiles(); 
} 
</pre><p>First, the global position of the tile the mouse is over currently is calculated, which the brush drawable is set to match. Doing it like this creates a feel of the brush being locked to a grid. Another method is then invoked for placing the tiles:</p><pre class="programlisting">void MapControls::PlaceBrushTiles() { 
  if (!m_action || !m_secondaryAction) { return; } 
  m_map-&gt;GetTileMap()-&gt;PlotTileMap(m_brush, 
    m_mouseTilePosition, m_selectionOptions.GetLowestLayer()); 
  auto size = m_brush.GetMapSize(); 
  auto from = sf::Vector3i(m_mouseTilePosition.x, 
    m_mouseTilePosition.y, m_selectionOptions.GetLowestLayer()); 
  auto to = sf::Vector3i(m_mouseTilePosition.x + size.x - 1, 
    m_mouseTilePosition.y + size.y - 1, 
    m_selectionOptions.GetHighestLayer()); 
  m_map-&gt;Redraw(from, to); 
  m_secondaryAction = false; 
  // Set it to false in order to avoid multiple placements. 
} 
</pre><p>The first and most obvious check here is to make sure that both the primary and secondary actions are on. We do not want to be placing tiles if the mouse is not being clicked, or if it already has been clicked, but is still at the same location. Otherwise, we are good to go on painting, which begins by the brush tile map being placed on the game maps tile map at the current mouse tile position, starting at the lowest layer currently selected by the selection options. Even though we may be able to shift through elevations at ease, we still need to tell this method about the lowest current elevation selected, because the brush tile map itself still begins at elevation <em>0</em>.</p><p>After the map has been updated, the tile coordinate range to be redrawn is calculated and passed to the <code class="literal">MapControls</code> class to be rendered on screen. We do not want to re-draw the whole map, as that would take more time and introduce latency. Lastly, the secondary action flag is set to <code class="literal">false</code> in order to indicate that a placement has been made at these coordinates already.</p><p>The next tool we need to update is the selection box:</p><pre class="programlisting">void MapControls::SelectionUpdate() { 
  m_selectionOptions.SelectionUpdate(); 
} 
</pre><p>As you can see, all of that logic is handled by the <code class="literal">SelectionOptions</code> class. For now, we simply need to worry about invoking this method</p><p>The same <code class="literal">SelectionOptions</code> interface may be responsible for manipulating our brush, which means we need to have a method for redrawing it to reflect changes:</p><pre class="programlisting">void MapControls::RedrawBrush() { 
  auto brushSize = m_brush.GetMapSize(); 
  auto brushRealSize = brushSize * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto textureSize = m_brushTexture.getSize(); 
  if (brushRealSize.x != textureSize.x || 
    brushRealSize.y != textureSize.y) 
  { 
    if (!m_brushTexture.create(brushRealSize.x, brushRealSize.y)) 
    { /* Error Message. */ } 
  } 
 
  m_brushTexture.clear({ 0, 0, 0, 0 }); 
 
  for (auto x = 0; x &lt; brushSize.x; ++x) { 
    for (auto y = 0; y &lt; brushSize.y; ++y) { 
      for (auto layer = 0; layer &lt; Sheet::Num_Layers; ++layer) { 
        auto tile = m_brush.GetTile(x, y, layer); 
        if (!tile) { continue; } 
        auto info = tile-&gt;m_properties; 
        if (!info) { continue; } 
        info-&gt;m_sprite.setPosition(sf::Vector2f( 
          x * Sheet::Tile_Size, y * Sheet::Tile_Size)); 
        m_brushTexture.draw(info-&gt;m_sprite); 
      } 
    } 
  } 
 
  m_brushTexture.display(); 
  m_brushDrawable.setTexture(&amp;m_brushTexture.getTexture()); 
  m_brushDrawable.setSize(sf::Vector2f(brushRealSize)); 
  m_brushDrawable.setTextureRect( 
    sf::IntRect(sf::Vector2i(0, 0), sf::Vector2i(brushRealSize))); 
} 
</pre><p>First, the real pixel brush size is calculated from the size of its tile map. If it does not match the current dimensions of the texture that represents it, the texture needs to be re-created. Once that is taken care of, the texture is cleared to all transparent pixels, and we begin iterating over each tile and layer inside said brush. Given it is a valid tile that has proper ties to an information structure that holds its sprite for rendering, the latter is set to the correct position on the texture and drawn to it.</p><p>Once this is done, the texture's display method is invoked to show all the changes, and the drawable object of the brush is bound to the texture again. The drawables size and texture rectangle is also reset, because the dimensions of the texture could have changed.</p><p>In this type of an application, it's important to have a quick and easy way of deleting something that's currently selected. For this, we're going to be processing the event that's bound to the <em>Delete</em> key on your keyboard:</p><pre class="programlisting">void MapControls::DeleteTiles(EventDetails* l_details) { 
  if (m_mode != ControlMode::Select) { return; } 
  m_selectionOptions.RemoveSelection(l_details); 
} 
</pre><p>This is a very simple callback. It simply checks if the current <code class="literal">ControlMode</code> is selected, and passes its details to another callback that belongs to the <code class="literal">selectionOptions</code> class. It will be dealing with all removals.</p><p>When a new tool is being selected, we must reset all data members we work with to their initial values in order to avoid weird bugs. This is where the <code class="literal">ResetTools()</code> method comes in:</p><pre class="programlisting">void MapControls::ResetTools() { 
  auto defaultVector = sf::Vector2i(-1, -1); 
  m_mouseTilePosition = defaultVector; 
  m_mouseTileStartPosition = defaultVector; 
  m_selectionOptions.Reset(); 
  m_tileSelector.Hide(); 
} 
</pre><p>It simply resets certain mouse data to a default uninitialized state. The <code class="literal">m_selectionOptions Reset()</code> method is also invoked, so that it can deal with its own resetting. Lastly, the <code class="literal">tileSelector</code> interface is hidden here as well.</p><p>Another useful little method is for resetting the zoom of the current view to a normal level:</p><pre class="programlisting">void MapControls::ResetZoom() { 
  m_view.zoom(1.f / m_zoom); 
  m_zoom = 1.f; 
} 
</pre><p>By dividing <code class="literal">1.f</code> by the current zoom factor, we obtain a scale value, which, when scaled by, the view returns to its normal state.</p><p>Next, let us see what needs to happen in order for this class to change its <code class="literal">ControlMode</code>:</p><pre class="programlisting">void MapControls::SelectMode(ControlMode l_mode) { 
  ResetTools(); 
  m_mode = l_mode; 
  if (m_mode == ControlMode::Brush) { RedrawBrush(); } 
  m_selectionOptions.SetControlMode(m_mode); 
} 
</pre><p>After the tools are reset, the mode passed in as the argument is stored. If the mode being applied is a brush, it needs to be re-drawn. Lastly, the <code class="literal">selectionOptions</code> class is notified of the mode change, so that it can perform its own logic.</p><p>Finally, one of the last key pieces of code is the creation of a new map:</p><pre class="programlisting">void MapControls::NewMapCreate(EventDetails* l_details) { 
  auto s_x = m_mapSettings-&gt;GetElement("Size_X")-&gt;GetText(); 
  auto s_y = m_mapSettings-&gt;GetElement("Size_Y")-&gt;GetText(); 
  auto friction = m_mapSettings-&gt; 
    GetElement("Friction")-&gt;GetText(); 
  auto selection = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_mapSettings-&gt;GetElement("SheetDropdown"))-&gt; 
    GetMenu()-&gt;GetSelected(); 
  if (selection.empty()) { return; } 
 
  auto context = m_guiManager-&gt;GetContext(); 
  auto editorState = m_stateManager-&gt; 
    GetState&lt;State_MapEditor&gt;(StateType::MapEditor); 
  m_particleSystem-&gt;PurgeCurrentState(); 
  m_map-&gt;PurgeMap(); 
  editorState-&gt;ResetSavePath(); 
 
  m_map-&gt;GetTileMap()-&gt;SetMapSize 
    sf::Vector2u(std::stoi(s_x), std::stoi(s_y))); 
  m_map-&gt;GetDefaultTile()-&gt;m_friction = 
    sf::Vector2f(std::stof(friction), std::stof(friction)); 
  m_map-&gt;GetTileSet()-&gt;ResetWorker(); 
  m_map-&gt;GetTileSet()-&gt;AddFile(Utils::GetWorkingDirectory() + 
    "media/Tilesheets/" + selection + ".tilesheet"); 
  m_map-&gt;GetTileSet()-&gt;SetName(selection + ".tilesheet"); 
 
  auto loading = m_stateManager-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  loading-&gt;AddLoader(context-&gt;m_gameMap-&gt;GetTileSet()); 
  loading-&gt;SetManualContinue(false); 
  editorState-&gt;SetMapRedraw(true); 
  m_mapSettings-&gt;SetActive(false); 
  m_stateManager-&gt;SwitchTo(StateType::Loading); 
} 
</pre><p>First, we obtain the size values from the text-fields of the map settings interface. In addition to that, we also grab the friction value, as well as the current selection of the tile-sheet drop–down menu. If the latter is empty, we simply return, as no tile-sheet has been selected.</p><p>If we do proceed, the particle system and the map both need to be purged. The <code class="literal">MapEditor</code> state is then notified to reset its save path, which forces the user to re-enter a filename when saving.</p><p>The map's size is then set up, alongside the default friction value. The selected tile-sheet file is added for further loading in a separate thread, and its name is registered inside the game map's internal <code class="literal">TileSet</code> data member.</p><p>Finally, the loading state is obtained, the tile-set is added to it, and the manual continue flag is set to <code class="literal">false</code>, in order to make the loading screen simply go back to the current state after it is done. The new map settings interface is then hidden, and we can finally switch to the loading state.</p><p>In case a mistake happens, the user must have a way to close the new <code class="literal">m_mapSettings</code> interface:</p><pre class="programlisting">void MapControls::NewMapClose(EventDetails* l_details) { 
  m_mapSettings-&gt;SetActive(false); 
} 
</pre><p>This callback gets invoked when the <strong>close</strong> button of the interface is pressed. All it does is simply hiding it.</p><p>Finally, we have a bunch of setters and getters that do not add up to much on their own, but are useful in the long run:</p><pre class="programlisting">void MapControls::NewMap() { m_mapSettings-&gt;SetActive(true); } 
void MapControls::SetTileSheetTexture(const std::string&amp; l_sheet) { 
  m_tileSelector.SetSheetTexture(l_sheet); 
} 
ControlMode MapControls::GetMode() const { return m_mode; } 
bool MapControls::IsInAction() const { return m_action; } 
bool MapControls::IsInSecondary() const{return m_secondaryAction;} 
GUI_SelectionOptions* MapControls::GetSelectionOptions() { 
  return &amp;m_selectionOptions; 
} 
sf::Vector2i MapControls::GetMouseTileStart() const { 
  return m_mouseTileStartPosition; 
} 
sf::Vector2i MapControls::GetMouseTile() const { 
  return m_mouseTilePosition; 
} 
sf::Vector2f MapControls::GetMouseDifference() const { 
  return m_mouseDifference; 
} 
bool MapControls::DrawSelectedLayers() const { 
  return m_drawSelectedLayers; 
} 
void MapControls::ToggleDrawingSelectedLayers() { 
  m_drawSelectedLayers = !m_drawSelectedLayers; 
} 
</pre><p>You may have noticed that we have not yet covered the bucket and eraser tools. This is what is usually referred to as homework, which should serve as good practice:</p><pre class="programlisting">void MapControls::BucketUpdate() { /* IMPLEMENT */ } 
void MapControls::EraserUpdate() { /* IMPLEMENT */ } 
</pre><p>Keep in mind that as we have not yet implemented everything that makes the map editor tick, this should probably wait until the next chapter is wrapped up.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we have introduced and implemented the concept of graphical file management, as well as laid the foundations for one of the most important tools a small RPG-style game uses. There is still a lot left to do before we can start reaping the benefits of having proper tools. In the next chapter, we will be covering the finishing touches of the map editor, as well as implementing a different tool for managing entities. See you there!</p></div></div></div></body></html>