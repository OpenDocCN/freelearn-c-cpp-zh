<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 4. Have Thy Gear Ready - Building Game Tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/><span class="koboSpan" id="kobo.1.1">Chapter 4. Have Thy Gear Ready - Building Game Tools</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Making games is a fine art. </span><span class="koboSpan" id="kobo.2.2">It is entirely possible, of course, to make art with the most basic of tools, but most commonly, developers need a strong toolkit supporting them in order to efficiently and professionally create quick, painless edits to their game. </span><span class="koboSpan" id="kobo.2.3">Building the said toolkit is arguably on a par with the difficulty of building the actual game, but the work spent on proper tools offsets the difficulty and frustrations that come with direct file edits.</span></p><p><span class="koboSpan" id="kobo.3.1">In this chapter, we're going to be covering these topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Building a graphical means of file management</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">File loading in a separate thread</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Establishing a state and means of controls for map editing</span></li></ul></div><p><span class="koboSpan" id="kobo.7.1">There's lots of ground to cover, so let's get started!</span></p><div class="section" title="Use of copyrighted resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/><span class="koboSpan" id="kobo.8.1">Use of copyrighted resources</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">As usual, let us give proper thanks to the artists and their assets that made this possible:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">Folder Orange</span></em></span><span class="koboSpan" id="kobo.11.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">sixsixfive</span></em></span><span class="koboSpan" id="kobo.13.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">CC0</span></strong></span><span class="koboSpan" id="kobo.15.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/212337/folder-orange"><span class="koboSpan" id="kobo.16.1">https://openclipart.org/detail/212337/folder-orange</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">Generic Document</span></em></span><span class="koboSpan" id="kobo.18.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">isendrak</span></em></span><span class="koboSpan" id="kobo.20.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.21.1">CC0</span></strong></span><span class="koboSpan" id="kobo.22.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/212798/generic-document"><span class="koboSpan" id="kobo.23.1">https://openclipart.org/detail/212798/generic-document</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">Tango Media Floppy</span></em></span><span class="koboSpan" id="kobo.25.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.26.1">warszawianka</span></em></span><span class="koboSpan" id="kobo.27.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">CC0</span></strong></span><span class="koboSpan" id="kobo.29.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/34579/tango-media-floppy"><span class="koboSpan" id="kobo.30.1">https://openclipart.org/detail/34579/tango-media-floppy</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.31.1">Close</span></em></span><span class="koboSpan" id="kobo.32.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.33.1">danilo</span></em></span><span class="koboSpan" id="kobo.34.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">CC0</span></strong></span><span class="koboSpan" id="kobo.36.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/215431/close"><span class="koboSpan" id="kobo.37.1">https://openclipart.org/detail/215431/close</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.38.1">Hand Prints</span></em></span><span class="koboSpan" id="kobo.39.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.40.1">kattekrab</span></em></span><span class="koboSpan" id="kobo.41.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.42.1">CC0</span></strong></span><span class="koboSpan" id="kobo.43.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/16340/hand-prints"><span class="koboSpan" id="kobo.44.1">https://openclipart.org/detail/16340/hand-prints</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.45.1">Paint Brush with Dark Red Dye</span></em></span><span class="koboSpan" id="kobo.46.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">Astro</span></em></span><span class="koboSpan" id="kobo.48.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.49.1">CC0</span></strong></span><span class="koboSpan" id="kobo.50.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11"><span class="koboSpan" id="kobo.51.1">https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.52.1">Primary Eraser</span></em></span><span class="koboSpan" id="kobo.53.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">dannya</span></em></span><span class="koboSpan" id="kobo.55.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">CC0</span></strong></span><span class="koboSpan" id="kobo.57.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/199463/primary-eraser"><span class="koboSpan" id="kobo.58.1">https://openclipart.org/detail/199463/primary-eraser</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.59.1">Mono Tool Rect Selection</span></em></span><span class="koboSpan" id="kobo.60.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.61.1">dannya</span></em></span><span class="koboSpan" id="kobo.62.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.63.1">CC0</span></strong></span><span class="koboSpan" id="kobo.64.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/198758/mono-tool-rect-selection"><span class="koboSpan" id="kobo.65.1">https://openclipart.org/detail/198758/mono-tool-rect-selection</span></a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em><span class="koboSpan" id="kobo.66.1">Color Bucket Red</span></em></span><span class="koboSpan" id="kobo.67.1"> by </span><span class="emphasis"><em><span class="koboSpan" id="kobo.68.1">frankes</span></em></span><span class="koboSpan" id="kobo.69.1"> under the </span><span class="strong"><strong><span class="koboSpan" id="kobo.70.1">CC0</span></strong></span><span class="koboSpan" id="kobo.71.1"> license (public domain): </span><a class="ulink" href="https://openclipart.org/detail/167327/color-bucket-red"><span class="koboSpan" id="kobo.72.1">https://openclipart.org/detail/167327/color-bucket-red</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="File management"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/><span class="koboSpan" id="kobo.1.1">File management</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The success and usability of the map editor tool is going to rely heavily on one specific interfacing element here, which is file access and management. </span><span class="koboSpan" id="kobo.2.2">In order to provide efficient means of file access, loading and saving, we are going to work on developing the means of visually guiding our user through the file system. </span><span class="koboSpan" id="kobo.2.3">The entire system consists of a few moving parts. </span><span class="koboSpan" id="kobo.2.4">For now, let us solely focus on the interface aspect of this idea.</span></p><div class="section" title="File manager interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/><span class="koboSpan" id="kobo.3.1">File manager interface</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Before we can successfully work with any kind of map data, it is important to have a comfortable means of loading and saving. </span><span class="koboSpan" id="kobo.4.2">This can be offloaded to a file manager interface, which is going to be responsible for displaying directory information. </span><span class="koboSpan" id="kobo.4.3">Let us take a look at what ours is going to look like:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.5.1"><img src="graphics/image_04_001.jpg" alt="File manager interface"/></span></div><p><span class="koboSpan" id="kobo.6.1">With this goal in mind, let us begin planning a class for it, starting with the header:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class GUI_FileManager { 
public: 
  GUI_FileManager(std::string l_name, GUI_Manager* l_guiMgr, 
    StateManager* l_stateMgr); 
  ~GUI_FileManager(); 
 
  void SetDirectory(std::string l_dir); 
  void ParentDirCallback(EventDetails* l_details); 
  void HandleEntries(EventDetails* l_details); 
  void ActionButton(EventDetails* l_details); 
  void CloseButton(EventDetails* l_details); 
  void Hide(); 
  void Show(); 
  void LoadMode(); 
  void SaveMode(); 
  bool IsInSaveMode() const; 
 
  template&lt;class T&gt; 
  void SetActionCallback( 
    void(T::*l_method)(const std::string&amp;), T* l_instance) 
  {...} 
private: 
  void ListFiles(); 
  GUI_Interface* m_interface; 
  std::string m_name; 
  std::string m_dir; 
 
  std::string m_folderEntry; 
  std::string m_fileEntry; 
 
  GUI_Manager* m_guiManager; 
  StateManager* m_stateMgr; 
  StateType m_currentState; 
  std::function&lt;void(std::string)&gt; m_actionCallback; 
  bool m_saveMode; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">Evidently, this class is a slightly more complex manifestation of a wrapper for a </span><code class="literal"><span class="koboSpan" id="kobo.9.1">GUI_Interface</span></code><span class="koboSpan" id="kobo.10.1"> instance. </span><span class="koboSpan" id="kobo.10.2">It is responsible for keeping track of the current directory we are in, as well as invoking a callback function/method when a file is selected to be loaded or saved. </span><span class="koboSpan" id="kobo.10.3">The callback function only takes a string argument, which carries the full path to the file that was selected to be loaded or saved, and can be registered like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">void SetActionCallback( 
  void(T::*l_method)(const std::string&amp;), T* l_instance) 
{ 
  m_actionCallback = 
    [l_instance, l_method](const std::string&amp; l_str) -&gt; void 
    { (l_instance-&gt;*l_method)(l_str); }; 
} 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Nothing too complicated yet. </span><span class="koboSpan" id="kobo.12.2">Let us move on to actually implementing the class!</span></p><div class="section" title="Implementing the file manager"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec4"/><span class="koboSpan" id="kobo.13.1">Implementing the file manager</span></h3></div></div></div><p><span class="koboSpan" id="kobo.14.1">With the class definition out of the way, it is time to take a look at the actual code that makes the file manager tick. </span><span class="koboSpan" id="kobo.14.2">Let's start by implementing the constructor of this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">GUI_FileManager::GUI_FileManager(std::string l_name, 
  GUI_Manager* l_guiMgr, StateManager* l_stateMgr): 
  m_guiManager(l_guiMgr), m_stateMgr(l_stateMgr), m_name(l_name), 
  m_saveMode(false) 
{ 
  m_guiManager-&gt;LoadInterface(""FileManager.interface"", l_name); 
  m_interface = m_guiManager-&gt;GetInterface(l_name); 
  m_currentState = m_stateMgr-&gt;GetCurrentStateType(); 
  m_folderEntry = m_interface-&gt;GetElement("FolderEntry")-&gt; 
    GetStyleName(); 
  m_fileEntry = m_interface-&gt;GetElement("FileEntry")-&gt; 
    GetStyleName(); 
  m_interface-&gt;RemoveElement("FolderEntry"); 
  m_interface-&gt;RemoveElement("FileEntry"); 
  m_interface-&gt;SetContentRectSize({ 300, 260 }); 
  m_interface-&gt;SetContentOffset({ 0.f, 16.f }); 
  m_interface-&gt;PositionCenterScreen(); 
 
  auto mgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Parent", 
    &amp;GUI_FileManager::ParentDirCallback, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Entries", 
    &amp;GUI_FileManager::HandleEntries, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_ActionButton", 
    &amp;GUI_FileManager::ActionButton, this); 
  mgr-&gt;AddCallback&lt;GUI_FileManager&gt;("FileManager_Close", 
    &amp;GUI_FileManager::CloseButton, this); 
 
  SetDirectory(Utils::GetWorkingDirectory()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.16.1">First, we load the interface and store its pointer in the designated data member. </span><span class="koboSpan" id="kobo.16.2">We also want to store the current state of the application, and obtain the style names of the elements, called </span><code class="literal"><span class="koboSpan" id="kobo.17.1">FolderEntry</span></code><span class="koboSpan" id="kobo.18.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.19.1">FileEntry</span></code><span class="koboSpan" id="kobo.20.1">, which are then removed. </span><span class="koboSpan" id="kobo.20.2">This makes the interface file a sort of template that gets filled in with all the right information later.</span></p><p><span class="koboSpan" id="kobo.21.1">Once the appropriate content size and offset are set, the interface is positioned in the centre of the screen. </span><span class="koboSpan" id="kobo.21.2">We then subscribe to relevant GUI interface events and set our file manager directory as the current directory the application is in.</span></p><p><span class="koboSpan" id="kobo.22.1">The callbacks and interfaces created in this class obviously need to be removed once they are no longer in use. </span><span class="koboSpan" id="kobo.22.2">This is where the destructor comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">GUI_FileManager::~GUI_FileManager() { 
  m_guiManager-&gt;RemoveInterface(m_currentState, m_name); 
  auto events = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Parent""); 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Entries""); 
  events-&gt;RemoveCallback(m_currentState, 
    ""FileManager_ActionButton""); 
  events-&gt;RemoveCallback(m_currentState, ""FileManager_Close""); 
} 
</span></pre><p><span class="koboSpan" id="kobo.24.1">Next, it is important for the file manager class to have a way to easily change its current directory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">void GUI_FileManager::SetDirectory(std::string l_dir) { 
  m_dir = l_dir; 
  std::replace(m_dir.begin(), m_dir.end(), '''', ''/''); 
  m_interface-&gt;RemoveElementsContaining(""Entry_""); 
  ListFiles(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">A couple of interesting things happened. </span><span class="koboSpan" id="kobo.26.2">Right after the argument is stored; all of the backward slashes in the directory string are replaced with forward slashes, in order to maintain compatibility with multiple other operating systems that do not play well with the former. </span><span class="koboSpan" id="kobo.26.3">The interface is then instructed to destroy all elements it has that begin with the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">""Entry_""</span></code><span class="koboSpan" id="kobo.28.1"> string. </span><span class="koboSpan" id="kobo.28.2">This is done in order to clear out all file and directory entries that may already exist. </span><span class="koboSpan" id="kobo.28.3">Finally, </span><code class="literal"><span class="koboSpan" id="kobo.29.1">ListFiles()</span></code><span class="koboSpan" id="kobo.30.1"> method is invoked, which populates the file manager with all of the files and folders inside the new directory. </span><span class="koboSpan" id="kobo.30.2">Let' us take a look at how that can be done:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">void GUI_FileManager::ListFiles() { 
  m_interface-&gt;GetElement(""Directory"")-&gt;SetText(m_dir); 
  auto list = Utils::GetFileList(m_dir, ""*.*"", true); 
  Utils::SortFileList(list); 
  auto ParentDir = m_interface-&gt;GetElement(""ParentDir""); 
  float x = ParentDir-&gt;GetPosition().x; 
  float y = ParentDir-&gt;GetPosition().y+ParentDir-&gt;GetSize().y+1.f; 
  size_t i = 0; 
  for (auto&amp; file : list) { 
    if (file.first == ""."" </span><span class="koboSpan" id="kobo.31.2">|| file.first == "".."") { continue; } 
    std::string entry = (file.second ? </span><span class="koboSpan" id="kobo.31.3">"FEntry_"" : ""Entry_"); 
    m_interface-&gt;AddElement(GUI_ElementType::Label, 
      entry + std::to_string(i)); 
    auto element = m_interface-&gt;GetElement( 
      entry + std::to_string(i)); 
    element-&gt;SetText(file.first); 
    element-&gt;SetPosition({ x, y }); 
    m_guiManager-&gt;LoadStyle((file.second ? 
      </span><span class="koboSpan" id="kobo.31.4">m_folderEntry : m_fileEntry), element); 
    y += ParentDir-&gt;GetSize().y + 4.f; 
    ++i; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.32.1">First, the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Directory</span></code><span class="koboSpan" id="kobo.34.1"> element is obtained in order to change its text. </span><span class="koboSpan" id="kobo.34.2">It represents the full path of the current working directory. </span><span class="koboSpan" id="kobo.34.3">The complete file list inside that directory is then obtained, including other folders. </span><span class="koboSpan" id="kobo.34.4">After it gets sorted alphabetically and by type, the parent directory element is obtained to calculate the starting coordinates of the first element on the list, which is, in turn, iterated over. </span><span class="koboSpan" id="kobo.34.5">Non-physical directories, such as </span><code class="literal"><span class="koboSpan" id="kobo.35.1">"."</span></code><span class="koboSpan" id="kobo.36.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.37.1">".."</span></code><span class="koboSpan" id="kobo.38.1">, are dismissed. </span><span class="koboSpan" id="kobo.38.2">A new element is then added to the interface, with an appropriate name that varies depending on whether we are working with a file or a folder. </span><span class="koboSpan" id="kobo.38.3">That same element is then updated to have the entry name, be in the right position and have a correct style attached to it. </span><span class="koboSpan" id="kobo.38.4">Finally, the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.39.1">y</span></em></span><span class="koboSpan" id="kobo.40.1"> coordinate is incremented for the next element on the list.</span></p><p><span class="koboSpan" id="kobo.41.1">With the directory structure being visually represented, let us take a look at what needs to happen when one of its entries is actually clicked:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void GUI_FileManager::HandleEntries(EventDetails* l_details) { 
  if(l_details-&gt;m_guiElement.find("FEntry_")!= std::string::npos){ 
    std::string path = m_dir + 
      m_interface-&gt;GetElement(l_details-&gt;m_guiElement)-&gt;GetText() 
      + ""; 
    SetDirectory(path); 
    m_interface-&gt;UpdateScrollVertical(0); 
  } else if (l_details-&gt;m_guiElement.find("Entry_") != 
    std::string::npos) 
  { 
    m_interface-&gt;GetElement("FileName")-&gt;SetText( 
     m_interface-&gt;GetElement(l_details-&gt;m_guiElement)-&gt;GetText()); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">The first check here lets us know whether the item clicked on was a directory or a file. </span><span class="koboSpan" id="kobo.43.2">In case of a folder click, we want to be able to traverse the filesystem by taking its name and adding it onto our existing directory path. </span><span class="koboSpan" id="kobo.43.3">The vertical scroll of the interface is then set back to zero, in order to move the content back up to the top if any scrolling has been done.</span></p><p><span class="koboSpan" id="kobo.44.1">A file click is a simpler matter. </span><span class="koboSpan" id="kobo.44.2">All we need to do in that case is obtain the text-field element that holds the filename, and change its contents to the name of the file that was just clicked on.</span></p><p><span class="koboSpan" id="kobo.45.1">All of this works perfectly for forward-traversal, but what if we want to go backwards? </span><span class="koboSpan" id="kobo.45.2">The parent directory element helps us out here:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">void GUI_FileManager::ParentDirCallback(EventDetails* l_details) { 
  auto i = m_dir.find_last_of("/", m_dir.length() - 2); 
  if (i != std::string::npos) { 
    std::string dir = m_dir.substr(0U, i + 1); 
    SetDirectory(dir); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.47.1">Here, it simply comes down to basic string manipulation. </span><span class="koboSpan" id="kobo.47.2">The very last instance of the forward slash character is first attempted to be located inside the directory string. </span><span class="koboSpan" id="kobo.47.3">If one is found, the string is simply </span><span class="emphasis"><em><span class="koboSpan" id="kobo.48.1">clipped</span></em></span><span class="koboSpan" id="kobo.49.1"> at that point, in order to drop everything that comes after it. </span><span class="koboSpan" id="kobo.49.2">The shortened path is then set as the current directory, where the rest of the magic that we've already covered happens.</span></p><p><span class="koboSpan" id="kobo.50.1">The last piece of the puzzle in making this work is handling the button press action:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">void GUI_FileManager::ActionButton(EventDetails* l_details) { 
  if (m_actionCallback == nullptr) { return; } 
  auto filename = m_interface-&gt;GetElement("FileName")-&gt;GetText(); 
  m_actionCallback(m_dir + filename); 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">First, we need to make sure the action callback is actually set. </span><span class="koboSpan" id="kobo.52.2">If it is, it gets invoked with the path to the currently selected file as its argument. </span><span class="koboSpan" id="kobo.52.3">The only other action button we have to worry about after this point is the close button:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.53.1">void GUI_FileManager::CloseButton(EventDetails* l_details){ 
  Hide(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.54.1">It simply invokes the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Hide()</span></code><span class="koboSpan" id="kobo.56.1"> method, which is covered here, along with its counterpart:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">void GUI_FileManager::Hide() { m_interface-&gt;SetActive(false); } 
 
void GUI_FileManager::Show() { 
  m_interface-&gt;SetActive(true); 
  m_interface-&gt;PositionCenterScreen(); 
  ListFiles(); 
  m_interface-&gt;Focus(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">When an interface is hidden, it's simply set to inactive. </span><span class="koboSpan" id="kobo.58.2">Showing it requires setting it back to being active, except we also want to position it in the absolute centre of the screen in this instance. </span><span class="koboSpan" id="kobo.58.3">In addition to that, it is a good idea to refresh its content, as the file structure may have changed while it was hidden. </span><span class="koboSpan" id="kobo.58.4">Lastly, the interface is focused, in order to bring it to the front of the drawing queue.</span></p><p><span class="koboSpan" id="kobo.59.1">The final bits of helpful code for this class consist of these methods:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">bool GUI_FileManager::IsInSaveMode() const { return m_saveMode; } 
void GUI_FileManager::LoadMode() { 
  m_interface-&gt;GetElement("ActionButton")-&gt;SetText("Load"); 
  m_saveMode = false; 
} 
void GUI_FileManager::SaveMode() { 
  m_interface-&gt;GetElement("ActionButton")-&gt;SetText("Save"); 
  m_saveMode = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.61.1">They help our other classes interface with this one more easily, by allowing them to determine if the file manager is in </span><code class="literal"><span class="koboSpan" id="kobo.62.1">Save</span></code><span class="koboSpan" id="kobo.63.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Load</span></code><span class="koboSpan" id="kobo.65.1"> mode, and to switch between the two.</span></p></div></div><div class="section" title="Loading files in a separate thread"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/><span class="koboSpan" id="kobo.66.1">Loading files in a separate thread</span></h2></div></div></div><p><span class="koboSpan" id="kobo.67.1">We have covered the threaded worker base class previously in </span><a class="link" href="ch01.html" title="Chapter 1. Under the Hood - Setting up the Backend"><span class="koboSpan" id="kobo.68.1">Chapter 1</span></a><span class="koboSpan" id="kobo.69.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">Under the Hood - Setting up the Backend</span></em></span><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">This is exactly where it will come in handy. </span><span class="koboSpan" id="kobo.71.3">In order to make the application seem more user-friendly, we want to render a nice loading bar that shows progress while the files are being loaded. </span><span class="koboSpan" id="kobo.71.4">Let us start by first defining a data type, used to store file paths that need to be loaded:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.72.1">using LoaderPaths = std::vector&lt;std::pair&lt;std::string, size_t&gt;&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.73.1">The </span><code class="literal"><span class="koboSpan" id="kobo.74.1">size_t</span></code><span class="koboSpan" id="kobo.75.1"> here represents the number of lines that are in the file, which makes it easy for us to determine the current loading progress. </span><span class="koboSpan" id="kobo.75.2">With that out of the way, let us work on the header file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.76.1">class FileLoader : public Worker { 
public: 
  FileLoader(); 
  void AddFile(const std::string&amp; l_file); 
  virtual void SaveToFile(const std::string&amp; l_file); 
 
  size_t GetTotalLines() const; 
  size_t GetCurrentLine() const; 
private: 
 </span><span class="strong"><strong><span class="koboSpan" id="kobo.77.1"> virtual bool ProcessLine(std::stringstream&amp; l_stream) = 0;</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.78.1">virtual void ResetForNextFile();</span></strong></span><span class="koboSpan" id="kobo.79.1"> 
  void Work(); 
  void CountFileLines(); 
 
  LoaderPaths m_files; 
  size_t m_totalLines; 
  size_t m_currentLine; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.80.1">Any </span><code class="literal"><span class="koboSpan" id="kobo.81.1">FileLoader</span></code><span class="koboSpan" id="kobo.82.1"> class in our code base needs to implement the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">ProcessLine</span></code><span class="koboSpan" id="kobo.84.1"> method, which simply defines what needs to happen as each individual line of the file is being parsed. </span><span class="koboSpan" id="kobo.84.2">If necessary, it can also take advantage of </span><code class="literal"><span class="koboSpan" id="kobo.85.1">SaveToFile</span></code><span class="koboSpan" id="kobo.86.1">, which, as the name states, defines the process of writing the class data out, and </span><code class="literal"><span class="koboSpan" id="kobo.87.1">ResetForNextFile</span></code><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">The latter method is invoked after every file that has finished loading, in order to give derivative classes a chance to clean up their internal state.</span></p><p><span class="koboSpan" id="kobo.89.1">As far as data members go, we have a list of loader paths that are to be loaded, the number of total lines of all files that are supposed to be parsed, and the number of the current line being read.</span></p><div class="section" title="Implementing the file loader"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec5"/><span class="koboSpan" id="kobo.90.1">Implementing the file loader</span></h3></div></div></div><p><span class="koboSpan" id="kobo.91.1">Let us start simply, and cover the one-liner methods first:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.92.1">FileLoader::FileLoader() : m_totalLines(0), m_currentLine(0) {} 
void FileLoader::AddFile(const std::string&amp; l_file) { 
  m_files.emplace_back(l_file, 0); 
} 
size_t FileLoader::GetTotalLines() const{ return m_totalLines; } 
size_t FileLoader::GetCurrentLine() const{ return m_currentLine; } 
void FileLoader::SaveToFile(const std::string&amp; l_file) {} 
void FileLoader::ResetForNextFile() {} 
</span></pre><p><span class="koboSpan" id="kobo.93.1">The constructor simply initializes a few of the class data members to their default values. </span><span class="koboSpan" id="kobo.93.2">The </span><code class="literal"><span class="koboSpan" id="kobo.94.1">AddFile()</span></code><span class="koboSpan" id="kobo.95.1"> method inserts the argument to the file container with the line count </span><span class="emphasis"><em><span class="koboSpan" id="kobo.96.1">zero</span></em></span><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">The next two methods are simple getters, while the last two are not even implemented, as they are optional.</span></p><p><span class="koboSpan" id="kobo.98.1">Next, let us work on the method that will actually be running in a thread and parse the file information:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.99.1">void FileLoader::Work() { 
  CountFileLines(); 
  if (!m_totalLines) { return; } 
  for (auto&amp; path : m_files) { 
    ResetForNextFile(); 
    std::ifstream file(path.first); 
    std::string line; 
    std::string name; 
    auto linesLeft = path.second; 
    while (std::getline(file, line)) { 
      { 
        sf::Lock lock(m_mutex); 
        ++m_currentLine; 
        --linesLeft; 
      } 
      if (line[0] == '|') { continue; } 
      std::stringstream keystream(line); 
      if (!ProcessLine(keystream)) { 
        { 
          sf::Lock lock(m_mutex); 
          m_currentLine += linesLeft; 
        } 
        break; 
      } 
    } 
    file.close(); 
  } 
  m_files.clear(); 
  Done(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.100.1">First, a private method for counting all file lines is invoked. </span><span class="koboSpan" id="kobo.100.2">This is necessary, as we want to be able to calculate our progress, and knowing how much work there is in total is needed for that. </span><span class="koboSpan" id="kobo.100.3">If after this method is called, the total number of lines is zero, we simply return as there is nothing to process.</span></p><p><span class="koboSpan" id="kobo.101.1">We then enter a loop that runs once for each file on the list. </span><span class="koboSpan" id="kobo.101.2">The class is reset for new file iteration, and a line from the input stream is created. </span><span class="koboSpan" id="kobo.101.3">The number of lines remaining to be processed is created, and another loop is entered that will execute once for each line in the file. </span><span class="koboSpan" id="kobo.101.4">Our </span><code class="literal"><span class="koboSpan" id="kobo.102.1">sf::Mutex</span></code><span class="koboSpan" id="kobo.103.1"> object is then locked in order to safely manipulate the two line data members that are used for progress tracking.</span></p><p><span class="koboSpan" id="kobo.104.1">If the first character of our line is a pipe, </span><code class="literal"><span class="koboSpan" id="kobo.105.1">|</span></code><span class="koboSpan" id="kobo.106.1">, it means we ran into a commented line and should just skip the current iteration. </span><span class="koboSpan" id="kobo.106.2">Otherwise, an </span><code class="literal"><span class="koboSpan" id="kobo.107.1">std::stringstream </span></code><span class="koboSpan" id="kobo.108.1">of the current line is created and passed into the pure virtual </span><code class="literal"><span class="koboSpan" id="kobo.109.1">ProcessLine()</span></code><span class="koboSpan" id="kobo.110.1"> method, which is encapsulated in an </span><code class="literal"><span class="koboSpan" id="kobo.111.1">if</span></code><span class="koboSpan" id="kobo.112.1"> statement to catch a possible failure, in which case the remainder of lines inside the current file are simply added to the current line counter and the loop is broken out of.</span></p><p><span class="koboSpan" id="kobo.113.1">Once the processing of all files is complete, the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">Done()</span></code><span class="koboSpan" id="kobo.115.1"> method is invoked in order to terminate the thread and let the outside code know we've finished.</span></p><p><span class="koboSpan" id="kobo.116.1">Another equally as important process is counting the lines of all file entries inside this class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.117.1">void FileLoader::CountFileLines() { 
  m_totalLines = 0; 
  m_currentLine = 0; 
  for (auto path = m_files.begin(); path != m_files.end();) { 
    if (path-&gt;first.empty()) { 
      path = m_files.erase(path); 
      continue; 
    } 
    std::ifstream file(path-&gt;first); 
    if (!file.is_open()) { 
      path = m_files.erase(path); 
      continue; 
    } 
    file.unsetf(std::ios_base::skipws); 
    { 
      sf::Lock lock(m_mutex); 
      path-&gt;second = static_cast&lt;size_t&gt;(std::count( 
        std::istreambuf_iterator&lt;char&gt;(file), 
        std::istreambuf_iterator&lt;char&gt;(), 
        '\n')); 
      m_totalLines += path-&gt;second; 
    } 
    ++path; 
    file.close(); 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.118.1">This one is fairly straightforward. </span><span class="koboSpan" id="kobo.118.2">After the two counters are zeroed out, we begin iterating over each path inside the file list. </span><span class="koboSpan" id="kobo.118.3">If the name of it is empty, the element is removed. </span><span class="koboSpan" id="kobo.118.4">Otherwise, we attempt to open the files. </span><span class="koboSpan" id="kobo.118.5">If that fails, the path is also erased. </span><span class="koboSpan" id="kobo.118.6">Otherwise, the file stream is requested to not skip whitespaces, and we enter a </span><code class="literal"><span class="koboSpan" id="kobo.119.1">sf::Mutex</span></code><span class="koboSpan" id="kobo.120.1"> lock, where the number of lines in the file stream is calculated using </span><code class="literal"><span class="koboSpan" id="kobo.121.1">std::count</span></code><span class="koboSpan" id="kobo.122.1">, and added to the total line counter. </span><span class="koboSpan" id="kobo.122.2">The path iterator is then moved forward, and the file is closed.</span></p></div></div><div class="section" title="The loading state"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/><span class="koboSpan" id="kobo.123.1">The loading state</span></h2></div></div></div><p><span class="koboSpan" id="kobo.124.1">The last piece of the threaded file loading puzzle is the loading state. </span><span class="koboSpan" id="kobo.124.2">In order to avoid other logic going on and simply focus on the graphical progress representation, it's a good idea to just switch to a dedicated state that will handle all loading logic inside it. </span><span class="koboSpan" id="kobo.124.3">Let us begin by defining a data type for holding pointers to </span><code class="literal"><span class="koboSpan" id="kobo.125.1">FileLoader*</span></code><span class="koboSpan" id="kobo.126.1"> instances:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.127.1">using LoaderContainer = std::vector&lt;FileLoader*&gt;; 
</span></pre><p><span class="koboSpan" id="kobo.128.1">The actual loading state header will end up looking something like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.129.1">class State_Loading : public BaseState { 
public: 
  ... </span><span class="koboSpan" id="kobo.129.2">// Other typical state methods. 
  </span><span class="koboSpan" id="kobo.129.3">void SetManualContinue(bool l_continue); 
  void Proceed(EventDetails* l_details); 
private: 
  void UpdateText(const std::string&amp; l_text, float l_percentage); 
  float CalculatePercentage(); 
  LoaderContainer m_loaders; 
  sf::Text m_text; 
  sf::RectangleShape m_rect; 
  unsigned short m_percentage; 
  size_t m_originalWork; 
  bool m_manualContinue; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.130.1">As you can see, we have one event callback method, a couple of helper methods, the container for loader pointers, an instance of </span><code class="literal"><span class="koboSpan" id="kobo.131.1">sf::Text</span></code><span class="koboSpan" id="kobo.132.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.133.1">sf::RectangleShape</span></code><span class="koboSpan" id="kobo.134.1"> to represent the loading bar, a number to represent the progress percentage, and the number of lines inside all files we originally started with.</span></p><div class="section" title="Implementing the loading state"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec6"/><span class="koboSpan" id="kobo.135.1">Implementing the loading state</span></h3></div></div></div><p><span class="koboSpan" id="kobo.136.1">All of this data needs to be initialized before it being used, so let us take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">OnCreate()</span></code><span class="koboSpan" id="kobo.138.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.139.1">void State_Loading::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  context-&gt;m_fontManager-&gt;RequireResource("Main"); 
  m_text.setFont(*context-&gt;m_fontManager-&gt;GetResource("Main")); 
  m_text.setCharacterSize(14); 
  m_text.setStyle(sf::Text::Bold); 
 
  sf::Vector2u windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
 
  m_rect.setFillColor(sf::Color(0, 150, 0, 255)); 
  m_rect.setSize(sf::Vector2f(0.f, 16.f)); 
  m_rect.setOrigin(0.f, 8.f); 
  m_rect.setPosition(0.f, windowSize.y / 2.f); 
 
  EventManager* evMgr = m_stateMgr-&gt;GetContext()-&gt;m_eventManager; 
  evMgr-&gt;AddCallback(StateType::Loading, 
    "Key_Space", &amp;State_Loading::Proceed, this); 
} 
</span></pre><p><span class="koboSpan" id="kobo.140.1">Because we are going to be using text, we need to have a font to work with. </span><span class="koboSpan" id="kobo.140.2">After one is acquired and all of the stylistic text settings are handled, we set up the rectangle to be exactly in the centre of the screen and register an event callback for proceeding out of the loading state, if the manual continue flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.141.1">true</span></code><span class="koboSpan" id="kobo.142.1">.</span></p><p><span class="koboSpan" id="kobo.143.1">Destroying this state also means the event callback and the font need to be released:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.144.1">void State_Loading::OnDestroy() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  EventManager* evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::Loading, "Key_Space"); 
  context-&gt;m_fontManager-&gt;ReleaseResource("Main"); 
} 
</span></pre><p><span class="koboSpan" id="kobo.145.1">Next, let us take a look at the updated logic:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.146.1">void State_Loading::Update(const sf::Time&amp; l_time) { 
  if (m_loaders.empty()) { 
    if (!m_manualContinue) { Proceed(nullptr); } 
    return; 
  } 
  auto windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
  if (m_loaders.back()-&gt;IsDone()) { 
    m_loaders.back()-&gt;OnRemove(); 
    m_loaders.pop_back(); 
    if (m_loaders.empty()) { 
      m_rect.setSize(sf::Vector2f( 
        static_cast&lt;float&gt;(windowSize.x), 16.f)); 
      UpdateText(".Press space to continue.", 100.f); 
      return; 
    } 
  } 
  if (!m_loaders.back()-&gt;HasStarted()){m_loaders.back()-&gt;Begin();} 
 
  auto percentage = CalculatePercentage(); 
  UpdateText("", percentage); 
  m_rect.setSize(sf::Vector2f( 
    (windowSize.x / 100) * percentage, 16.f)); 
} 
</span></pre><p><span class="koboSpan" id="kobo.147.1">First, a check is made to determine if we are ready to exit the state, given all of the work that has been done. </span><span class="koboSpan" id="kobo.147.2">If the manual continue flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.148.1">false</span></code><span class="koboSpan" id="kobo.149.1">, we simply invoke the Proceed callback directly by passing </span><code class="literal"><span class="koboSpan" id="kobo.150.1">nullptr</span></code><span class="koboSpan" id="kobo.151.1"> as the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">EventDetails</span></code><span class="koboSpan" id="kobo.153.1"> pointer, since it is not used there anyway. </span><span class="koboSpan" id="kobo.153.2">The update method is then returned from.</span></p><p><span class="koboSpan" id="kobo.154.1">If we still have some work to do, the first element on the loader list is checked to see if it's done. </span><span class="koboSpan" id="kobo.154.2">If it is, the loader is removed, and if it was the last one, the size of the rectangle is set to match the full size of the window on the x axis, which shows full completion. </span><span class="koboSpan" id="kobo.154.3">The text in the middle is also updated to let the user know they need to press the spacebar key to continue. </span><span class="koboSpan" id="kobo.154.4">Finally, the update method is returned from once again, to prevent further logic from executing.</span></p><p><span class="koboSpan" id="kobo.155.1">If none of those conditions were met, the first element on the loader list is checked to see if it has started its work. </span><span class="koboSpan" id="kobo.155.2">If it has not yet started, its </span><code class="literal"><span class="koboSpan" id="kobo.156.1">Begin</span></code><span class="koboSpan" id="kobo.157.1"> method is invoked. </span><span class="koboSpan" id="kobo.157.2">This is quickly followed by the percentage calculation, which is then used to update the text in the middle of the screen and adjust the size of the progress bar rectangle to match said percentage.</span></p><p><span class="koboSpan" id="kobo.158.1">Drawing in this state simply comes down to two calls:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">void State_Loading::Draw() { 
  sf::RenderWindow* wind = m_stateMgr-&gt; 
    GetContext()-&gt;m_wind-&gt;GetRenderWindow(); 
  wind-&gt;draw(m_rect); 
  wind-&gt;draw(m_text); 
} 
</span></pre><p><span class="koboSpan" id="kobo.160.1">All we need to do here is render the rectangle and the text instances.</span></p><p><span class="koboSpan" id="kobo.161.1">Next, let us take a look at the helper method that updates our text instance:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.162.1">void State_Loading::UpdateText(const std::string&amp; l_text, 
  float l_percentage) 
{ 
  m_text.setString(std::to_string( 
    static_cast&lt;int&gt;(l_percentage)) + "%" + l_text); 
  auto windowSize = m_stateMgr-&gt;GetContext()-&gt; 
    m_wind-&gt;GetRenderWindow()-&gt;getSize(); 
  m_text.setPosition(windowSize.x / 2.f, windowSize.y / 2.f); 
  Utils::CenterSFMLText(m_text); 
} 
</span></pre><p><span class="koboSpan" id="kobo.163.1">After the text string is updated, its position is updated to be directly in the middle of the screen. </span><span class="koboSpan" id="kobo.163.2">Since updating its contents may change the bounding box, and thus how it is centered, a helper function inside our </span><code class="literal"><span class="koboSpan" id="kobo.164.1">Utils</span></code><span class="koboSpan" id="kobo.165.1"> namespace is used to center it properly.</span></p><p><span class="koboSpan" id="kobo.166.1">Next, let us calculate the actual progress of the loading procedure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.167.1">float State_Loading::CalculatePercentage() { 
  float absolute = 100.f; 
  if (m_loaders.back()-&gt;GetTotalLines()) { 
    float d = (100.f * (m_originalWork - m_loaders.size())) / 
      static_cast&lt;float&gt;(m_originalWork); 
    float current = (100.f * m_loaders.back()-&gt;GetCurrentLine()) / 
      static_cast&lt;float&gt;(m_loaders.back()-&gt;GetTotalLines()); 
    float totalCurrent = current / 
      static_cast&lt;float&gt;(m_originalWork); 
    absolute = d + totalCurrent; 
  } 
  return absolute; 
} 
</span></pre><p><span class="koboSpan" id="kobo.168.1">After an absolute value of </span><code class="literal"><span class="koboSpan" id="kobo.169.1">100.f</span></code><span class="koboSpan" id="kobo.170.1"> is created, the current progress is calculated by first determining the progress of how many files have been already loaded out of the number we began with, followed by the progress of the current file being calculated and used to determine absolute progress, which is then returned.</span></p><p><span class="koboSpan" id="kobo.171.1">Once all of the work is done, the </span><code class="literal"><span class="koboSpan" id="kobo.172.1">Proceed()</span></code><span class="koboSpan" id="kobo.173.1"> method is invoked to return to the previous state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.174.1">void State_Loading::Proceed(EventDetails* l_details) { 
  if (!m_loaders.empty()) { return; } 
  m_stateMgr-&gt;SwitchTo(m_stateMgr-&gt;GetNextToLast()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.175.1">Obviously it needs to check if the list of file loaders is actually empty first. </span><span class="koboSpan" id="kobo.175.2">If it is, the state manager is instructed to switch to the state that comes just before this one, which means it is the one that initiated the loading procedure.</span></p><p><span class="koboSpan" id="kobo.176.1">Finally, what would a class be without some helper methods? </span><span class="koboSpan" id="kobo.176.2">Let us take a look at them now:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.177.1">void State_Loading::AddLoader(FileLoader* l_loader) { 
  m_loaders.emplace_back(l_loader); 
  l_loader-&gt;OnAdd(); 
} 
bool State_Loading::HasWork() const { return !m_loaders.empty(); } 
void State_Loading::Activate() { 
  m_originalWork = m_loaders.size(); 
} 
</span></pre></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Creating the map editor state"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/><span class="koboSpan" id="kobo.1.1">Creating the map editor state</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Now we're finally ready to actually tackle the state, in which all of the map editing is going to take place. </span><span class="koboSpan" id="kobo.2.2">Let us take a gander at its header file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">class State_MapEditor : public BaseState { 
public: 
  ... 
  </span><span class="koboSpan" id="kobo.3.2">void ResetSavePath(); 
  void SetMapRedraw(bool l_redraw); 
  void MainMenu(EventDetails* l_details); 
  void MapEditorNew(EventDetails* l_details); 
  void MapEditorLoad(EventDetails* l_details); 
  void MapEditorSave(EventDetails* l_details); 
  void MapEditorSaveAs(EventDetails* l_details); 
  void MapEditorExit(EventDetails* l_details); 
  void MapAction(const std::string&amp; l_name); 
private: 
  void SaveMap(const std::string&amp; l_path); 
  void LoadMap(const std::string&amp; l_path); 
  GUI_FileManager m_files; 
  MapControls m_mapControls; 
  std::string m_mapSavePath; 
  bool m_mapRedraw; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">This </span><code class="literal"><span class="koboSpan" id="kobo.5.1">State_MapEditor</span></code><span class="koboSpan" id="kobo.6.1"> class is going to be the frontier that deals with the most general editor events. </span><span class="koboSpan" id="kobo.6.2">Note the highlighted data member here. </span><span class="koboSpan" id="kobo.6.3">We have not yet covered this class, but it is responsible for handling the finer aspects of control for this application. </span><span class="koboSpan" id="kobo.6.4">It will be covered in the next chapter.</span></p><p><span class="koboSpan" id="kobo.7.1">Aside from the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">MapControls</span></code><span class="koboSpan" id="kobo.9.1"> class, we also have the file manager, a string for the path to a file that is currently being worked on, and a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">boolean</span></em></span><span class="koboSpan" id="kobo.11.1"> flag that keeps track of whether the game map should be redrawn or not.</span></p><div class="section" title="Implementing the state"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/><span class="koboSpan" id="kobo.12.1">Implementing the state</span></h2></div></div></div><p><span class="koboSpan" id="kobo.13.1">As always, let us begin by tackling the construction of all the important data inside this state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">void State_MapEditor::OnCreate() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;AddCallback("Key_Escape", 
    &amp;State_MapEditor::MainMenu, this); 
  evMgr-&gt;AddCallback("MapEditor_New", 
    &amp;State_MapEditor::MapEditorNew, this); 
  evMgr-&gt;AddCallback("MapEditor_Load", 
    &amp;State_MapEditor::MapEditorLoad, this); 
  evMgr-&gt;AddCallback("MapEditor_Save", 
    &amp;State_MapEditor::MapEditorSave, this); 
  evMgr-&gt;AddCallback("MapEditor_SaveAs", 
    &amp;State_MapEditor::MapEditorSaveAs, this); 
  evMgr-&gt;AddCallback("MapEditor_Exit", 
    &amp;State_MapEditor::MapEditorExit, this); 
 
  m_files.SetActionCallback(&amp;State_MapEditor::MapAction, this); 
  m_files.SetDirectory(Utils::GetWorkingDirectory() + 
    "media/maps/"); 
  m_files.Hide(); 
  context-&gt;m_guiManager-&gt;LoadInterface( 
    "MapEditorTop.interface", "MapEditorTop"); 
  context-&gt;m_guiManager-&gt;GetInterface("MapEditorTop")-&gt; 
    SetPosition({ 200, 0 }); 
 
  context-&gt;m_particles-&gt;CreateState(StateType::MapEditor); 
} 
</span></pre><p><span class="koboSpan" id="kobo.15.1">After all of the event callbacks are set up, the file manager class is provided with its own callback for either loading or saving a file, as well as the starting directory it needs to be in. </span><span class="koboSpan" id="kobo.15.2">In this case, appropriately enough, it is the maps folder. </span><span class="koboSpan" id="kobo.15.3">The manager is then hidden, and another interface is loaded and positioned on screen. </span><code class="literal"><span class="koboSpan" id="kobo.16.1">MapEditorTop</span></code><span class="koboSpan" id="kobo.17.1"> is the control strip on the very top of the screen that has buttons for creating a new map, loading, saving, and exiting the application:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.18.1"><img src="graphics/image_04_002.jpg" alt="Implementing the state"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.19.1">Once the state is finished and is about to be destroyed, it needs to remove all call-backs that it set up. </span><span class="koboSpan" id="kobo.19.2">This can be done in the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">OnDestroy()</span></code><span class="koboSpan" id="kobo.21.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">void State_MapEditor::OnDestroy() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto textureMgr = context-&gt;m_textureManager; 
  auto evMgr = context-&gt;m_eventManager; 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "Key_Escape"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_New"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Load"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Save"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_SaveAs"); 
  evMgr-&gt;RemoveCallback(StateType::MapEditor, "MapEditor_Exit"); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;GetTileMap()-&gt;SetMapSize({ 0,0 }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">In addition to callbacks, the map is also purged just before its size is set back to absolute zero. </span><span class="koboSpan" id="kobo.23.2">Since we are on the subject of callbacks, let us just cover most of them in a single go:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">void State_MapEditor::MapEditorNew(EventDetails* l_details) { 
  m_mapControls.NewMap(); 
} 
void State_MapEditor::MapEditorLoad(EventDetails* l_details) { 
  m_files.LoadMode(); 
  m_files.Show(); 
} 
 
void State_MapEditor::MapEditorSave(EventDetails* l_details) { 
  if (m_mapSavePath.empty()) { MapEditorSaveAs(nullptr); return; } 
  SaveMap(m_mapSavePath); 
} 
void State_MapEditor::MapEditorSaveAs(EventDetails* l_details) { 
  m_files.SaveMode(); 
  m_files.Show(); 
} 
 
void State_MapEditor::MapEditorExit(EventDetails* l_details) { 
  m_stateMgr-&gt;SwitchTo(StateType::MainMenu); 
  m_stateMgr-&gt;Remove(StateType::MapEditor); 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">When the </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">New</span></strong></span><span class="koboSpan" id="kobo.27.1"> map button is clicked, we want to invoke a special method of the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">MapControls</span></code><span class="koboSpan" id="kobo.29.1"> class that will handle it. </span><span class="koboSpan" id="kobo.29.2">If the </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">Load</span></strong></span><span class="koboSpan" id="kobo.31.1"> button is clicked, we simply switch the mode of the file manager to load, and show it on screen.</span></p><p><span class="koboSpan" id="kobo.32.1">Clicking the </span><span class="strong"><strong><span class="koboSpan" id="kobo.33.1">Save</span></strong></span><span class="koboSpan" id="kobo.34.1"> button can have two behaviors. </span><span class="koboSpan" id="kobo.34.2">First, if we are dealing with a fresh, new map that has not been saved yet, it is the same as clicking the </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">Save As...</span></strong></span><span class="koboSpan" id="kobo.36.1"> button, which switches the file manager to save mode and shows it on screen. </span><span class="koboSpan" id="kobo.36.2">However, if we have loaded a map or have previously saved a new one, the state remembers where it was saved, as well as its name. </span><span class="koboSpan" id="kobo.36.3">Prompting the user to enter a filename again would be pointless here, so the map is simply written to the exact same location, with the exact same name.</span></p><p><span class="koboSpan" id="kobo.37.1">Finally, if the </span><span class="strong"><strong><span class="koboSpan" id="kobo.38.1">Exit</span></strong></span><span class="koboSpan" id="kobo.39.1"> button is clicked, we simply switch back to the main menu state and remove this one.</span></p><p><span class="koboSpan" id="kobo.40.1">With the UI code out of the way, let us take a look at what needs to happen when a map is being loaded:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">void State_MapEditor::LoadMap(const std::string&amp; l_path) { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto loading = m_stateMgr-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  context-&gt;m_particles-&gt;PurgeCurrentState(); 
  context-&gt;m_gameMap-&gt;PurgeMap(); 
  context-&gt;m_gameMap-&gt;ResetWorker(); 
  context-&gt;m_gameMap-&gt;GetTileMap()-&gt;GetTileSet().ResetWorker(); 
  context-&gt;m_gameMap-&gt;AddFile(l_path); 
  loading-&gt;AddLoader(context-&gt;m_gameMap); 
  loading-&gt;SetManualContinue(false); 
  m_mapRedraw = true; 
  m_mapSavePath = l_path; 
  m_stateMgr-&gt;SwitchTo(StateType::Loading); 
} 
</span></pre><p><span class="koboSpan" id="kobo.42.1">Since we want a nice loading bar to appear as a map is being read in, we are going to be using the loading state. </span><span class="koboSpan" id="kobo.42.2">After it is obtained, both the particle system and the map are purged. </span><span class="koboSpan" id="kobo.42.3">The map, which inherits from the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">FileLoader</span></code><span class="koboSpan" id="kobo.44.1"> class, is then reset. </span><span class="koboSpan" id="kobo.44.2">The file path that was provided as an argument is then added to it to be loaded, and the loading state itself is set up to automatically dismiss itself once the loading is done. </span><span class="koboSpan" id="kobo.44.3">At the same time, we make sure that the map is going to be re-drawn as the map editor state resumes, and that it remembers the path of the map if it is to be saved later. </span><span class="koboSpan" id="kobo.44.4">Finally, we can switch to the loading state.</span></p><p><span class="koboSpan" id="kobo.45.1">Next, let us work on the code that is responsible for saving the map:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.46.1">void State_MapEditor::SaveMap(const std::string&amp; l_path) { 
  m_stateMgr-&gt;GetContext()-&gt;m_gameMap-&gt;SaveToFile(l_path); 
  m_mapSavePath = l_path; 
} 
</span></pre><p><span class="koboSpan" id="kobo.47.1">This is much simpler than the previous method. </span><span class="koboSpan" id="kobo.47.2">The path is simply passed to the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">SaveToFile</span></code><span class="koboSpan" id="kobo.49.1"> method of the game map class, and stored for later use.</span></p><p><span class="koboSpan" id="kobo.50.1">The actual callback of the file manager that mediates between the load and save methods can be implemented like :</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">void State_MapEditor::MapAction(const std::string&amp; l_path) { 
  if(m_files.IsInSaveMode()) { SaveMap(l_path); } 
  else { LoadMap(l_path); } 
  m_files.Hide(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">Depending on the mode the file manager is in, the appropriate method is called with the path being passed in as the argument. </span><span class="koboSpan" id="kobo.52.2">The actual interface is then hidden.</span></p><p><span class="koboSpan" id="kobo.53.1">Because we want to re-draw the map after it was loaded, the perfect place for that logic is inside the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">Activate()</span></code><span class="koboSpan" id="kobo.55.1"> method, as it gets called right when a state is switched to:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">void State_MapEditor::Activate() { 
  if (!m_mapRedraw) { return; } 
  auto map = m_stateMgr-&gt;GetContext()-&gt;m_gameMap; 
  map-&gt;Redraw(); 
  m_mapControls.SetTileSheetTexture( 
    map-&gt;GetTileSet()-&gt;GetTextureName()); 
  m_mapRedraw = false; 
} 
</span></pre><p><span class="koboSpan" id="kobo.57.1">If the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">m_mapRedraw</span></code><span class="koboSpan" id="kobo.59.1"> flag is not on, there is no need to do anything at this point. </span><span class="koboSpan" id="kobo.59.2">Otherwise, we want to redraw the map and provide the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">mapControls</span></code><span class="koboSpan" id="kobo.61.1"> class with the tile-sheet texture name, so that it can perform its own logic, such as, for example, tile selection.</span></p><p><span class="koboSpan" id="kobo.62.1">Next, let us take a look at what needs to be updated while the application is in this state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">void State_MapEditor::Update(const sf::Time&amp; l_time) { 
  auto context = m_stateMgr-&gt;GetContext(); 
  m_mapControls.Update(l_time.asSeconds()); 
  context-&gt;m_gameMap-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_systemManager-&gt;Update(l_time.asSeconds()); 
  context-&gt;m_particles-&gt;Update(l_time.asSeconds()); 
} 
</span></pre><p><span class="koboSpan" id="kobo.64.1">Alongside the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">mapControls</span></code><span class="koboSpan" id="kobo.66.1"> class, the game map, ECS system manager, and the particle system also need to be updated, because we are going to be using all of these classes while building maps. </span><span class="koboSpan" id="kobo.66.2">Predictably enough, these are the same objects that also need to be drawn:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.67.1">void State_MapEditor::Draw() { 
  auto context = m_stateMgr-&gt;GetContext(); 
  auto window = context-&gt;m_wind-&gt;GetRenderWindow(); 
  auto from = (m_mapControls.DrawSelectedLayers() ? 
    </span><span class="koboSpan" id="kobo.67.2">m_mapControls.GetSelectionOptions()-&gt;GetLowestLayer() : 0); 
  auto to = (m_mapControls.DrawSelectedLayers() ? 
    </span><span class="koboSpan" id="kobo.67.3">m_mapControls.GetSelectionOptions()-&gt;GetHighestLayer() 
    : Sheet::Num_Layers - 1); 
  for (auto i = from; i &lt;= to; ++i) { 
    context-&gt;m_gameMap-&gt;Draw(i); 
    context-&gt;m_systemManager-&gt;Draw(context-&gt;m_wind, i); 
    context-&gt;m_particles-&gt;Draw(*window, i); 
  } 
  if(!m_mapControls.DrawSelectedLayers()) { 
    context-&gt;m_particles-&gt;Draw(*window, -1); 
  } 
  m_mapControls.Draw(window); 
} 
</span></pre><p><span class="koboSpan" id="kobo.68.1">Note the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">from</span></code><span class="koboSpan" id="kobo.70.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.71.1">to</span></code><span class="koboSpan" id="kobo.72.1"> variables. </span><span class="koboSpan" id="kobo.72.2">The </span><code class="literal"><span class="koboSpan" id="kobo.73.1">mapControl</span></code><span class="koboSpan" id="kobo.74.1"> class is going to provide us with a way to switch between layers/elevations, so we need to obtain that information before anything is rendered, in order to make sure only the appropriate layers are drawn on screen. </span><code class="literal"><span class="koboSpan" id="kobo.75.1">DrawSelectedLayers</span></code><span class="koboSpan" id="kobo.76.1"> simply returns a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.77.1">boolean</span></em></span><span class="koboSpan" id="kobo.78.1"> value that determines whether or not all layers should be drawn, or just the selected ones. </span><span class="koboSpan" id="kobo.78.2">Once the loop has iterated over the appropriate elevations, we make sure to draw the remaining particles that are above the maximum elevation, provided, of course, everything needs to be rendered. </span><span class="koboSpan" id="kobo.78.3">This is topped off by the map controls being drawn over everything else.</span></p><p><span class="koboSpan" id="kobo.79.1">For other outside communications with this class, we provide two basic setter methods:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.80.1">void State_MapEditor::ResetSavePath() { m_mapSavePath = ""; } 
void State_MapEditor::SetMapRedraw(bool l_redraw) { 
  m_mapRedraw = l_redraw; 
} 
</span></pre><p><span class="koboSpan" id="kobo.81.1">These are going to be used inside the control classes to communicate events, such as a new map being created, or it needing to be re-drawn.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building the control mechanism"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/><span class="koboSpan" id="kobo.1.1">Building the control mechanism</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">While building maps, the user tends to run into situations where they need more than just a tile being placed where the mouse clicks. </span><span class="koboSpan" id="kobo.2.2">It would definitely be useful to have tools that would enable them to freely pan around, select chunks of the map for deletion or copying, erase them and so on. </span><span class="koboSpan" id="kobo.2.3">Our control class is going to serve this exact purpose. </span><span class="koboSpan" id="kobo.2.4">It will provide a set of tools that can be used for multiple different situations:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.3.1">enum class ControlMode{None, Pan, Brush, Bucket, Eraser, Select}; 
</span></pre><p><span class="koboSpan" id="kobo.4.1">The preceding control mode enumeration represents a couple of the most common tools that come in a variety of different pieces of software. </span><span class="koboSpan" id="kobo.4.2">We're going to implement some of them here, and leave the rest up to you! </span><span class="koboSpan" id="kobo.4.3">In the end, we should have a control interface that looks a little like this:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.5.1"><img src="graphics/image_04_003.jpg" alt="Building the control mechanism"/></span></div><p><span class="koboSpan" id="kobo.6.1">Let us get to actually writing out the header for the control class. </span><span class="koboSpan" id="kobo.6.2">For clarity, we are going to be discussing its methods and data members separately, starting with the member functions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.7.1">class MapControls { 
public: 
  MapControls(Window* l_window, EventManager* l_eventManager, 
    StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, 
    EntityManager* l_entityMgr, ParticleSystem* l_particles, 
    sf::View&amp; l_view); 
  ~MapControls(); 
 
  void Update(float l_dT); 
  void Draw(sf::RenderWindow* l_window); 
 
  void NewMap(); 
  void SetTileSheetTexture(const std::string&amp; l_sheet); 
  ControlMode GetMode() const; 
  bool IsInAction() const; 
  bool IsInSecondary() const; 
  GUI_SelectionOptions* GetSelectionOptions(); 
 
  sf::Vector2i GetMouseTileStart()const; 
  sf::Vector2i GetMouseTile()const; 
  sf::Vector2f GetMouseDifference()const; 
 
  bool DrawSelectedLayers()const; 
  void ToggleDrawingSelectedLayers(); 
 
  void MouseClick(EventDetails* l_details); 
  void MouseRelease(EventDetails* l_details); 
  void MouseWheel(EventDetails* l_details); 
  void ToolSelect(EventDetails* l_details); 
  void DeleteTiles(EventDetails* l_details); 
  void NewMapCreate(EventDetails* l_details); 
  void NewMapClose(EventDetails* l_details); 
 
  void SelectMode(ControlMode l_mode); 
  void RedrawBrush(); 
private: 
  void UpdateMouse(); 
  void PanUpdate(); 
  void BrushUpdate(); 
  void BucketUpdate(); 
  void EraserUpdate(); 
  void SelectionUpdate(); 
   
  void PlaceBrushTiles(); 
  void ResetZoom(); 
  void ResetTools(); 
  ... 
</span><span class="koboSpan" id="kobo.7.2">}; 
</span></pre><p><span class="koboSpan" id="kobo.8.1">In addition to all of the helper methods for setting and getting the class parameters, we have a whole bunch of event callbacks, as well as individual update methods for every kind of map tool we're going to be working with. </span><span class="koboSpan" id="kobo.8.2">Next, let us take a look at the data members we are going to be working with:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class MapControls { 
private: 
  ... 
  </span><span class="koboSpan" id="kobo.9.2">// Mode and mouse/layer flags. 
  </span><span class="koboSpan" id="kobo.9.3">ControlMode m_mode; 
  bool m_action; 
  bool m_secondaryAction; 
  bool m_rightClickPan; 
  bool m_drawSelectedLayers; 
  // Mouse information. 
  </span><span class="koboSpan" id="kobo.9.4">sf::Vector2i m_mousePosition; 
  sf::Vector2i m_mouseStartPosition; 
  sf::Vector2f m_mouseDifference; 
  sf::Vector2i m_mouseTilePosition; 
  sf::Vector2i m_mouseTileStartPosition; 
  float m_zoom; 
  // Brush information, and map bounds. 
  </span><span class="koboSpan" id="kobo.9.5">TileMap m_brush; 
  sf::RenderTexture m_brushTexture; 
  sf::RectangleShape m_brushDrawable; 
  sf::RectangleShape m_mapBoundaries; 
  // Other interfaces used here. 
  </span><span class="koboSpan" id="kobo.9.6">GUI_MapTileSelector m_tileSelector; 
  GUI_SelectionOptions m_selectionOptions; 
  GUI_Interface* m_mapSettings; 
  // Ties to other classes. 
  </span><span class="koboSpan" id="kobo.9.7">Window* m_window; 
  EventManager* m_eventManager; 
  StateManager* m_stateManager; 
  Map* m_map; 
  GUI_Manager* m_guiManager; 
  EntityManager* m_entityManager; 
  ParticleSystem* m_particleSystem; 
  sf::View&amp; m_view; 
}; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Alongside the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">ControlMode</span></code><span class="koboSpan" id="kobo.12.1"> that this class is currently in, we are also going to be storing a couple of flags. </span><span class="koboSpan" id="kobo.12.2">The </span><code class="literal"><span class="koboSpan" id="kobo.13.1">m_action</span></code><span class="koboSpan" id="kobo.14.1"> flag will be used with tools, as well as </span><code class="literal"><span class="koboSpan" id="kobo.15.1">m_secondaryAction</span></code><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">The former simply denotes whether the left mouse button is pressed or not, while the latter is used with an action that can only happen once the mouse position has changed. </span><span class="koboSpan" id="kobo.16.3">This will prove useful when we are trying to optimize certain things to not happen, unless they absolutely have to. </span><span class="koboSpan" id="kobo.16.4">The last two flags signify whether we are currently right-click panning, and whether only the selected layers should be drawn on screen.</span></p><p><span class="koboSpan" id="kobo.17.1">Below that, there are a couple of 2D vectors, used to store mouse information, such as its current position, where a left-click first happened, the difference between the current and last frame in the mouse position, its current position in tile coordinates, and its starting position in tile coordinates. </span><span class="koboSpan" id="kobo.17.2">Additionally, we also have a floating point value for the current zoom factor.</span></p><p><span class="koboSpan" id="kobo.18.1">For the brush that will be used to paint with, we simply use a </span><code class="literal"><span class="koboSpan" id="kobo.19.1">TileMap</span></code><span class="koboSpan" id="kobo.20.1"> structure, just like the game map class does. </span><span class="koboSpan" id="kobo.20.2">Since the brush is going to have to be drawn on screen, we need to store a texture for it, as well as another drawable object that will be used to show it. </span><span class="koboSpan" id="kobo.20.3">Finally, a </span><code class="literal"><span class="koboSpan" id="kobo.21.1">sf::RectangleShape</span></code><span class="koboSpan" id="kobo.22.1"> type is going to more than suffice for showing the boundaries of the map on screen.</span></p><p><span class="koboSpan" id="kobo.23.1">Additional code separation, especially when code is becoming quite lengthy, is always a good idea. </span><span class="koboSpan" id="kobo.23.2">For this purpose, other non-general-control logic is going to be spread out into two additional interface classes: a tile selector, and the selection options. </span><span class="koboSpan" id="kobo.23.3">A tile selector is a simple window that shows the entire tile-sheet and allows the user to select tiles they want to paint with, while selection options is a separate interface that provides us with a myriad of settings that can be tweaked when specific things on screen are selected. </span><span class="koboSpan" id="kobo.23.4">Both of these classes are going to be covered in the next chapter.</span></p><p><span class="koboSpan" id="kobo.24.1">Lastly, we have another interface, named </span><code class="literal"><span class="koboSpan" id="kobo.25.1">m_mapSettings</span></code><span class="koboSpan" id="kobo.26.1">, the logic of which is going to be handled within the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">MapControls</span></code><span class="koboSpan" id="kobo.28.1"> class. </span><span class="koboSpan" id="kobo.28.2">When creating new maps, we need a neat little window that is going to allow us to configure the size of the map, its default friction value, and the name of the tile-sheet it is going to be using. </span><span class="koboSpan" id="kobo.28.3">This is exactly the purpose the map settings interface is going to serve.</span></p><div class="section" title="Implementing controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/><span class="koboSpan" id="kobo.29.1">Implementing controls</span></h2></div></div></div><p><span class="koboSpan" id="kobo.30.1">There are quite a few data members to initialize, so let us take a look at how the constructor manages it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">MapControls::MapControls(Window* l_window, EventManager* l_eventManager, 
  StateManager* l_stateManager, Map* l_map, GUI_Manager* l_gui, 
  EntityManager* l_entityMgr, ParticleSystem* l_particles, 
  sf::View&amp; l_view): 
  /* Storing arguments first. </span><span class="koboSpan" id="kobo.31.2">*/ 
  m_window(l_window), m_eventManager(l_eventManager), 
  m_stateManager(l_stateManager), m_map(l_map), 
  m_guiManager(l_gui), m_entityManager(l_entityMgr), 
  m_particleSystem(l_particles), m_view(l_view), 
  /* Setting up initial data member values. </span><span class="koboSpan" id="kobo.31.3">*/ 
  m_mode(ControlMode::Pan), m_action(false), 
  m_secondaryAction(false), m_rightClickPan(false), 
  m_zoom(1.f), m_brush(sf::Vector2u(1, 1), *l_map-&gt;GetTileSet()), 
  m_drawSelectedLayers(false), 
  /* Initializing other interface classes. </span><span class="koboSpan" id="kobo.31.4">*/ 
  m_tileSelector(l_eventManager, l_gui, 
    l_gui-&gt;GetContext()-&gt;m_textureManager), 
  m_mapSettings(nullptr), 
  m_selectionOptions(l_eventManager, l_gui, this, 
    &amp;m_tileSelector, l_map, &amp;m_brush, l_entityMgr, l_particles) 
{ ... </span><span class="koboSpan" id="kobo.31.5">} 
</span></pre><p><span class="koboSpan" id="kobo.32.1">As you can see, there is quite a lot going on here. </span><span class="koboSpan" id="kobo.32.2">Let us zip through it section by section. </span><span class="koboSpan" id="kobo.32.3">Right after the arguments of the constructor are processed, we set up the data members of this class to hold their initial values. </span><span class="koboSpan" id="kobo.32.4">Shortly after that, the custom interface classes get set up, with all the necessary arguments being passed to their constructors. </span><span class="koboSpan" id="kobo.32.5">For now, we are not going to be worrying about them, as they will be covered in the next chapter.</span></p><p><span class="koboSpan" id="kobo.33.1">Let us take a look at the actual constructor body next:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">MapControls::MapControls(...) 
{ 
  ... </span><span class="koboSpan" id="kobo.34.2">// All of the callbacks gets set up. 
  </span><span class="koboSpan" id="kobo.34.3">m_guiManager-&gt;LoadInterface("MapEditorTools.interface", 
    "MapEditorTools"); 
  m_guiManager-&gt;GetInterface("MapEditorTools")-&gt; 
    SetPosition({ 0.f, 16.f }); 
  m_guiManager-&gt;LoadInterface("MapEditorNewMap.interface", 
    "MapEditorNewMap"); 
  m_mapSettings = m_guiManager-&gt;GetInterface("MapEditorNewMap"); 
  m_mapSettings-&gt;PositionCenterScreen(); 
  m_mapSettings-&gt;SetActive(false); 
 
  m_brush.SetTile(0, 0, 0, 0); 
  m_brushDrawable.setFillColor({ 255, 255, 255, 200 }); 
  m_brushDrawable.setOutlineColor({ 255, 0, 0, 255 }); 
  m_brushDrawable.setOutlineThickness(-1.f); 
  m_mapBoundaries.setPosition({ 0.f, 0.f }); 
  m_mapBoundaries.setFillColor({ 0,0,0,0 }); 
  m_mapBoundaries.setOutlineColor({255, 50, 50, 255}); 
  m_mapBoundaries.setOutlineThickness(-1.f); 
 
  auto dropdown = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_mapSettings-&gt;GetElement("SheetDropdown"))-&gt;GetMenu(); 
  dropdown-&gt;PurgeEntries(); 
  auto names = Utils::GetFileList(Utils::GetWorkingDirectory() + 
    "media/Tilesheets/", "*.tilesheet"); 
  for (auto&amp; entity : names) { 
    dropdown-&gt;AddEntry(entity.first.substr( 
      0, entity.first.find(".tilesheet"))); 
  } 
  dropdown-&gt;Redraw(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.35.1">Right after all event callbacks get set up, we begin working on the interfaces. </span><span class="koboSpan" id="kobo.35.2">The actual tools interface is loaded and positioned on screen, as well as the new map settings window, which we are going to keep track of by storing its pointer as one of our data members. </span><span class="koboSpan" id="kobo.35.3">It gets positioned in the centre of the screen and set as inactive for the time being.</span></p><p><span class="koboSpan" id="kobo.36.1">The next segment simply deals with the stylistic aspects of the brush drawable, as well as the map boundaries rectangle. </span><span class="koboSpan" id="kobo.36.2">These values can obviously be customized to look completely different.</span></p><p><span class="koboSpan" id="kobo.37.1">Lastly, we need to make sure to populate the drop-down element for sheet selection inside the new map settings interface. </span><span class="koboSpan" id="kobo.37.2">After the element is obtained and cleared of all other entries, the list of all filenames that are of type </span><code class="literal"><span class="koboSpan" id="kobo.38.1">.tilesheet</span></code><span class="koboSpan" id="kobo.39.1"> inside the appropriate location is obtained and iterated over, stripping away the file format from each one and adding it to the drop-down list, which is then re-drawn to reflect all changes.</span></p><p><span class="koboSpan" id="kobo.40.1">Keep in mind that all interfaces and callbacks that were created here need to be removed, which is all that happens in the destructor. </span><span class="koboSpan" id="kobo.40.2">For that specific reason, we are not going to be covering that here, as it is redundant.</span></p><p><span class="koboSpan" id="kobo.41.1">Let us take a look at what needs to happen when this class is being updated:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.42.1">void MapControls::Update(float l_dT) { 
  m_mapBoundaries.setSize(sf::Vector2f( 
    m_map-&gt;GetTileMap()-&gt;GetMapSize() * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size))); 
  UpdateMouse(); 
  if (m_mode == ControlMode::Pan || m_rightClickPan){PanUpdate();} 
  else if (m_mode == ControlMode::Brush) { BrushUpdate(); } 
  else if (m_mode == ControlMode::Bucket) { BucketUpdate(); } 
  else if (m_mode == ControlMode::Eraser) { EraserUpdate(); } 
  else if (m_mode == ControlMode::Select) { SelectionUpdate(); } 
} 
</span></pre><p><span class="koboSpan" id="kobo.43.1">First, we handle any possible changes in size of the map class. </span><span class="koboSpan" id="kobo.43.2">The map boundary rectangle is updated here to reflect them. </span><span class="koboSpan" id="kobo.43.3">Next, we must make sure the mouse is updated properly. </span><span class="koboSpan" id="kobo.43.4">All of that logic is contained within the </span><code class="literal"><span class="koboSpan" id="kobo.44.1">UpdateMouse</span></code><span class="koboSpan" id="kobo.45.1"> method, which is invoked here. </span><span class="koboSpan" id="kobo.45.2">Finally, depending on the current </span><code class="literal"><span class="koboSpan" id="kobo.46.1">ControlMode</span></code><span class="koboSpan" id="kobo.47.1">, we need to invoke the appropriate update method for the specific tool that is selected. </span><span class="koboSpan" id="kobo.47.2">The pan tool is special in a way, because it will be updated when it is selected as a tool, and when the right mouse button is being pressed as well.</span></p><p><span class="koboSpan" id="kobo.48.1">Drawing all of these objects may be simpler than you think:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">void MapControls::Draw(sf::RenderWindow* l_window) { 
  l_window-&gt;draw(m_mapBoundaries); 
  if (m_mode == ControlMode::Brush) { 
    l_window-&gt;draw(m_brushDrawable); 
  } 
  m_selectionOptions.Draw(l_window); 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">In this specific instance, all we need to render is the rectangle of the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">mapBoundaries</span></code><span class="koboSpan" id="kobo.52.1">, the brush, if the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">ControlMode</span></code><span class="koboSpan" id="kobo.54.1"> is set to </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Brush</span></code><span class="koboSpan" id="kobo.56.1">, and the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">SelectionOptions</span></code><span class="koboSpan" id="kobo.58.1"> class, which has its own </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Draw</span></code><span class="koboSpan" id="kobo.60.1"> method. </span><span class="koboSpan" id="kobo.60.2">More on that will be covered in the next chapter.</span></p><p><span class="koboSpan" id="kobo.61.1">Next, let us implement everything necessary to keep track of all the relevant mouse information:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">void MapControls::UpdateMouse() { 
  auto mousePos = m_eventManager-&gt;GetMousePos( 
    m_window-&gt;GetRenderWindow()); 
  m_mouseDifference = sf::Vector2f(mousePos - m_mousePosition); 
  m_mouseDifference *= m_zoom; 
  m_mousePosition = mousePos; 
  auto view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); 
  auto mouseGlobal=viewPos+(sf::Vector2f(m_mousePosition)*m_zoom); 
  auto newPosition = sf::Vector2i( 
    floor(mouseGlobal.x / Sheet::Tile_Size), 
    floor(mouseGlobal.y / Sheet::Tile_Size) 
  ); 
 
  if (m_mouseTilePosition != newPosition &amp;&amp; m_action) { 
    m_secondaryAction = true; 
  } 
  m_mouseTilePosition = newPosition; 
} 
</span></pre><p><span class="koboSpan" id="kobo.63.1">After the current mouse position is obtained, it is used to compute the coordinate difference between the current frame and the previous one.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/><span class="koboSpan" id="kobo.64.1">Note</span></h3><p><span class="koboSpan" id="kobo.65.1">Since the mouse difference is expressed in </span><span class="strong"><strong><span class="koboSpan" id="kobo.66.1">global coordinates</span></strong></span><span class="koboSpan" id="kobo.67.1">, we must remember to multiply them by the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.68.1">zoom factor</span></em></span><span class="koboSpan" id="kobo.69.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.70.1">The mouse position is then stored for the next frame, so this process can take place all over again. </span><span class="koboSpan" id="kobo.70.2">The current </span><code class="literal"><span class="koboSpan" id="kobo.71.1">sf::View</span></code><span class="koboSpan" id="kobo.72.1"> is then obtained for calculating the current </span><span class="strong"><strong><span class="koboSpan" id="kobo.73.1">global</span></strong></span><span class="koboSpan" id="kobo.74.1"> position of the camera. </span><span class="koboSpan" id="kobo.74.2">From this, we can calculate the global mouse position (adjusted for zoom, of course), and the mouse tile position, which is simply the tile that's being pointed at.</span></p><p><span class="koboSpan" id="kobo.75.1">The current mouse tile position is then checked against the calculated result for being different. </span><span class="koboSpan" id="kobo.75.2">If it is, and the left mouse button is currently being pressed (as shown by the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">m_action</span></code><span class="koboSpan" id="kobo.77.1"> data member), the secondary action flag is turned on. </span><span class="koboSpan" id="kobo.77.2">The mouse tile position is then stored for the next frame.</span></p><p><span class="koboSpan" id="kobo.78.1">The next method in the mouse variety deals with left and right clicks, and can be implemented like so:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.79.1">void MapControls::MouseClick(EventDetails* l_details) { 
  if (l_details-&gt;m_hasBeenProcessed) { return; } 
  if (l_details-&gt;m_keyCode != 
    static_cast&lt;int&gt;(MouseButtonType::Left)) 
  { 
    m_rightClickPan = true; 
    return; 
  } 
  m_mousePosition = m_eventManager-&gt;GetMousePos( 
    m_window-&gt;GetRenderWindow()); 
  m_mouseStartPosition = m_mousePosition; 
 
  auto view = m_window-&gt;GetRenderWindow()-&gt;getView(); 
  auto viewPos = view.getCenter() - (view.getSize() * 0.5f); 
  auto mouseGlobal = viewPos + (sf::Vector2f(m_mousePosition) 
    * m_zoom); 
  m_mouseTileStartPosition = sf::Vector2i( 
    floor(mouseGlobal.x / Sheet::Tile_Size), 
    floor(mouseGlobal.y / Sheet::Tile_Size) 
  ); 
 
  if (!m_selectionOptions.MouseClick(mouseGlobal)) { return; } 
 
  m_action = true; 
  m_secondaryAction = true; 
} 
</span></pre><p><span class="koboSpan" id="kobo.80.1">Because something else may have already processed a mouse event, we need to check for the event details that get submitted as an argument. </span><span class="koboSpan" id="kobo.80.2">We do not want to accidentally paint some tiles on the map if we are simply interacting with an interface, for example. </span><span class="koboSpan" id="kobo.80.3">Next, the key code of the event is checked to see whether it is the left mouse button. </span><span class="koboSpan" id="kobo.80.4">If it is not, all we need to worry about is setting the right-click pan flag to </span><code class="literal"><span class="koboSpan" id="kobo.81.1">true</span></code><span class="koboSpan" id="kobo.82.1"> and returning.</span></p><p><span class="koboSpan" id="kobo.83.1">If we indeed have a left-click, on the other hand, the current mouse position is stored as both the starting and the current positions. </span><span class="koboSpan" id="kobo.83.2">A very similar process to updating the mouse takes place here, leading to the calculation of the global mouse coordinates. </span><span class="koboSpan" id="kobo.83.3">They are then passed into the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">MouseClick()</span></code><span class="koboSpan" id="kobo.85.1"> method of the selection options class, which returns a </span><span class="emphasis"><em><span class="koboSpan" id="kobo.86.1">boolean</span></em></span><span class="koboSpan" id="kobo.87.1"> flag, signifying whether any entities or particle emitters have been selected. </span><span class="koboSpan" id="kobo.87.2">We will be dealing with that in the next chapter. </span><span class="koboSpan" id="kobo.87.3">If that is not the case, however, both the action and secondary action flags are set to </span><code class="literal"><span class="koboSpan" id="kobo.88.1">true</span></code><span class="koboSpan" id="kobo.89.1"> in order to use the currently selected tool.</span></p><p><span class="koboSpan" id="kobo.90.1">In the same way that for every action there is an equal and opposite reaction, for each click we need to have a release:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.91.1">void MapControls::MouseRelease(EventDetails* l_details) { 
  if (l_details-&gt;m_keyCode != 
    static_cast&lt;int&gt;(MouseButtonType::Left)) 
  { 
    m_rightClickPan = false; 
    return; 
  } 
  m_action = false; 
  m_secondaryAction = false; 
  m_selectionOptions.MouseRelease(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.92.1">All we need to worry about here is resetting all of the action flags that are used while the mouse is active. </span><span class="koboSpan" id="kobo.92.2">This includes the right-click panning, and both action flags. </span><span class="koboSpan" id="kobo.92.3">The selection options interface also needs to be notified of a release.</span></p><p><span class="koboSpan" id="kobo.93.1">A neat little feature that is going to help out a lot is being able to zoom in and out. </span><span class="koboSpan" id="kobo.93.2">It is handled here as an event:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.94.1">void MapControls::MouseWheel(EventDetails* l_details) { 
  if (l_details-&gt;m_hasBeenProcessed) { return; } 
  float factor = 0.05f; 
  factor *= l_details-&gt;m_mouseWheelDelta; 
  factor = 1.f - factor; 
  m_view.zoom(factor); 
  m_zoom *= factor; 
} 
</span></pre><p><span class="koboSpan" id="kobo.95.1">If this event has not already been processed by something else, we proceed to calculate the amount of zoom that needs to happen. </span><span class="koboSpan" id="kobo.95.2">A </span><code class="literal"><span class="koboSpan" id="kobo.96.1">float factor</span></code><span class="koboSpan" id="kobo.97.1"> value is defined here, and is multiplied by the change in the mouse wheel position. </span><span class="koboSpan" id="kobo.97.2">In order for it to be treated as a scale factor, it is subtracted from </span><code class="literal"><span class="koboSpan" id="kobo.98.1">1.f</span></code><span class="koboSpan" id="kobo.99.1">, and then used to zoom in the view. </span><span class="koboSpan" id="kobo.99.2">Finally, in order to keep track of the current zoom value, we must multiply it by the said scale factor.</span></p><p><span class="koboSpan" id="kobo.100.1">The next event we need to worry about is one of the tools being selected:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">void MapControls::ToolSelect(EventDetails* l_details) { 
  auto mode = ControlMode::None; 
  if (l_details-&gt;m_name == "MapEditor_PanTool") { 
    mode = ControlMode::Pan; 
  } else if (l_details-&gt;m_name == "MapEditor_BrushTool") { 
    mode = ControlMode::Brush; 
  } else if (l_details-&gt;m_name == "MapEditor_PaintTool") { 
    mode = ControlMode::Bucket; 
  } else if (l_details-&gt;m_name == "MapEditor_EraserTool") { 
    mode = ControlMode::Eraser; 
  } else if (l_details-&gt;m_name == "MapEditor_SelectTool") { 
    mode = ControlMode::Select; 
  } 
  SelectMode(mode); 
} 
</span></pre><p><span class="koboSpan" id="kobo.102.1">This is quite simple, as we basically map the names of elements to their </span><code class="literal"><span class="koboSpan" id="kobo.103.1">ControlMode</span></code><span class="koboSpan" id="kobo.104.1"> counter-parts. </span><span class="koboSpan" id="kobo.104.2">The appropriate mode is then selected on the bottom.</span></p><p><span class="koboSpan" id="kobo.105.1">Speaking of tools, each one of them has their own individual update method. </span><span class="koboSpan" id="kobo.105.2">Let us begin by taking a look at how the pan tool is updated:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">void MapControls::PanUpdate() { 
  if (!m_action &amp;&amp; !m_rightClickPan) { return; } 
  if (m_mouseDifference == sf::Vector2f(0.f, 0.f)) { return; } 
  m_view.setCenter(m_view.getCenter() + 
    (sf::Vector2f(0.f, 0.f) - sf::Vector2f(m_mouseDifference))); 
} 
</span></pre><p><span class="koboSpan" id="kobo.107.1">We obviously do not want the screen to move if the mouse is not being clicked, or if the mouse position delta between frames is absolute zero. </span><span class="koboSpan" id="kobo.107.2">Given that both those conditions are satisfied, however, all we need to do is move the centre of the view to a different location. </span><span class="koboSpan" id="kobo.107.3">This location is calculated by adding its current position with the mouse position difference, which has to have its sign flipped. </span><span class="koboSpan" id="kobo.107.4">We do this, because as the mouse is clicked and moved left, for example, the view needs to shift right in order to feel natural. </span><span class="koboSpan" id="kobo.107.5">The same is true for the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.108.1">x</span></em></span><span class="koboSpan" id="kobo.109.1"> axis.</span></p><p><span class="koboSpan" id="kobo.110.1">In the case of a brush tool, the logic goes like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.111.1">void MapControls::BrushUpdate() { 
  auto tilePos = sf::Vector2f( 
    static_cast&lt;float&gt;(m_mouseTilePosition.x * Sheet::Tile_Size), 
    static_cast&lt;float&gt;(m_mouseTilePosition.y * Sheet::Tile_Size) 
  ); 
  m_brushDrawable.setPosition(tilePos); 
  PlaceBrushTiles(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.112.1">First, the global position of the tile the mouse is over currently is calculated, which the brush drawable is set to match. </span><span class="koboSpan" id="kobo.112.2">Doing it like this creates a feel of the brush being locked to a grid. </span><span class="koboSpan" id="kobo.112.3">Another method is then invoked for placing the tiles:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.113.1">void MapControls::PlaceBrushTiles() { 
  if (!m_action || !m_secondaryAction) { return; } 
  m_map-&gt;GetTileMap()-&gt;PlotTileMap(m_brush, 
    m_mouseTilePosition, m_selectionOptions.GetLowestLayer()); 
  auto size = m_brush.GetMapSize(); 
  auto from = sf::Vector3i(m_mouseTilePosition.x, 
    m_mouseTilePosition.y, m_selectionOptions.GetLowestLayer()); 
  auto to = sf::Vector3i(m_mouseTilePosition.x + size.x - 1, 
    m_mouseTilePosition.y + size.y - 1, 
    m_selectionOptions.GetHighestLayer()); 
  m_map-&gt;Redraw(from, to); 
  m_secondaryAction = false; 
  // Set it to false in order to avoid multiple placements. 
</span><span class="koboSpan" id="kobo.113.2">} 
</span></pre><p><span class="koboSpan" id="kobo.114.1">The first and most obvious check here is to make sure that both the primary and secondary actions are on. </span><span class="koboSpan" id="kobo.114.2">We do not want to be placing tiles if the mouse is not being clicked, or if it already has been clicked, but is still at the same location. </span><span class="koboSpan" id="kobo.114.3">Otherwise, we are good to go on painting, which begins by the brush tile map being placed on the game maps tile map at the current mouse tile position, starting at the lowest layer currently selected by the selection options. </span><span class="koboSpan" id="kobo.114.4">Even though we may be able to shift through elevations at ease, we still need to tell this method about the lowest current elevation selected, because the brush tile map itself still begins at elevation </span><span class="emphasis"><em><span class="koboSpan" id="kobo.115.1">0</span></em></span><span class="koboSpan" id="kobo.116.1">.</span></p><p><span class="koboSpan" id="kobo.117.1">After the map has been updated, the tile coordinate range to be redrawn is calculated and passed to the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">MapControls</span></code><span class="koboSpan" id="kobo.119.1"> class to be rendered on screen. </span><span class="koboSpan" id="kobo.119.2">We do not want to re-draw the whole map, as that would take more time and introduce latency. </span><span class="koboSpan" id="kobo.119.3">Lastly, the secondary action flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.120.1">false</span></code><span class="koboSpan" id="kobo.121.1"> in order to indicate that a placement has been made at these coordinates already.</span></p><p><span class="koboSpan" id="kobo.122.1">The next tool we need to update is the selection box:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.123.1">void MapControls::SelectionUpdate() { 
  m_selectionOptions.SelectionUpdate(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.124.1">As you can see, all of that logic is handled by the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">SelectionOptions</span></code><span class="koboSpan" id="kobo.126.1"> class. </span><span class="koboSpan" id="kobo.126.2">For now, we simply need to worry about invoking this method</span></p><p><span class="koboSpan" id="kobo.127.1">The same </span><code class="literal"><span class="koboSpan" id="kobo.128.1">SelectionOptions</span></code><span class="koboSpan" id="kobo.129.1"> interface may be responsible for manipulating our brush, which means we need to have a method for redrawing it to reflect changes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.130.1">void MapControls::RedrawBrush() { 
  auto brushSize = m_brush.GetMapSize(); 
  auto brushRealSize = brushSize * 
    static_cast&lt;unsigned int&gt;(Sheet::Tile_Size); 
  auto textureSize = m_brushTexture.getSize(); 
  if (brushRealSize.x != textureSize.x || 
    brushRealSize.y != textureSize.y) 
  { 
    if (!m_brushTexture.create(brushRealSize.x, brushRealSize.y)) 
    { /* Error Message. </span><span class="koboSpan" id="kobo.130.2">*/ } 
  } 
 
  m_brushTexture.clear({ 0, 0, 0, 0 }); 
 
  for (auto x = 0; x &lt; brushSize.x; ++x) { 
    for (auto y = 0; y &lt; brushSize.y; ++y) { 
      for (auto layer = 0; layer &lt; Sheet::Num_Layers; ++layer) { 
        auto tile = m_brush.GetTile(x, y, layer); 
        if (!tile) { continue; } 
        auto info = tile-&gt;m_properties; 
        if (!info) { continue; } 
        info-&gt;m_sprite.setPosition(sf::Vector2f( 
          x * Sheet::Tile_Size, y * Sheet::Tile_Size)); 
        m_brushTexture.draw(info-&gt;m_sprite); 
      } 
    } 
  } 
 
  m_brushTexture.display(); 
  m_brushDrawable.setTexture(&amp;m_brushTexture.getTexture()); 
  m_brushDrawable.setSize(sf::Vector2f(brushRealSize)); 
  m_brushDrawable.setTextureRect( 
    sf::IntRect(sf::Vector2i(0, 0), sf::Vector2i(brushRealSize))); 
} 
</span></pre><p><span class="koboSpan" id="kobo.131.1">First, the real pixel brush size is calculated from the size of its tile map. </span><span class="koboSpan" id="kobo.131.2">If it does not match the current dimensions of the texture that represents it, the texture needs to be re-created. </span><span class="koboSpan" id="kobo.131.3">Once that is taken care of, the texture is cleared to all transparent pixels, and we begin iterating over each tile and layer inside said brush. </span><span class="koboSpan" id="kobo.131.4">Given it is a valid tile that has proper ties to an information structure that holds its sprite for rendering, the latter is set to the correct position on the texture and drawn to it.</span></p><p><span class="koboSpan" id="kobo.132.1">Once this is done, the texture's display method is invoked to show all the changes, and the drawable object of the brush is bound to the texture again. </span><span class="koboSpan" id="kobo.132.2">The drawables size and texture rectangle is also reset, because the dimensions of the texture could have changed.</span></p><p><span class="koboSpan" id="kobo.133.1">In this type of an application, it's important to have a quick and easy way of deleting something that's currently selected. </span><span class="koboSpan" id="kobo.133.2">For this, we're going to be processing the event that's bound to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.134.1">Delete</span></em></span><span class="koboSpan" id="kobo.135.1"> key on your keyboard:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.136.1">void MapControls::DeleteTiles(EventDetails* l_details) { 
  if (m_mode != ControlMode::Select) { return; } 
  m_selectionOptions.RemoveSelection(l_details); 
} 
</span></pre><p><span class="koboSpan" id="kobo.137.1">This is a very simple callback. </span><span class="koboSpan" id="kobo.137.2">It simply checks if the current </span><code class="literal"><span class="koboSpan" id="kobo.138.1">ControlMode</span></code><span class="koboSpan" id="kobo.139.1"> is selected, and passes its details to another callback that belongs to the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">selectionOptions</span></code><span class="koboSpan" id="kobo.141.1"> class. </span><span class="koboSpan" id="kobo.141.2">It will be dealing with all removals.</span></p><p><span class="koboSpan" id="kobo.142.1">When a new tool is being selected, we must reset all data members we work with to their initial values in order to avoid weird bugs. </span><span class="koboSpan" id="kobo.142.2">This is where the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">ResetTools()</span></code><span class="koboSpan" id="kobo.144.1"> method comes in:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.145.1">void MapControls::ResetTools() { 
  auto defaultVector = sf::Vector2i(-1, -1); 
  m_mouseTilePosition = defaultVector; 
  m_mouseTileStartPosition = defaultVector; 
  m_selectionOptions.Reset(); 
  m_tileSelector.Hide(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.146.1">It simply resets certain mouse data to a default uninitialized state. </span><span class="koboSpan" id="kobo.146.2">The </span><code class="literal"><span class="koboSpan" id="kobo.147.1">m_selectionOptions Reset()</span></code><span class="koboSpan" id="kobo.148.1"> method is also invoked, so that it can deal with its own resetting. </span><span class="koboSpan" id="kobo.148.2">Lastly, the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">tileSelector</span></code><span class="koboSpan" id="kobo.150.1"> interface is hidden here as well.</span></p><p><span class="koboSpan" id="kobo.151.1">Another useful little method is for resetting the zoom of the current view to a normal level:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.152.1">void MapControls::ResetZoom() { 
  m_view.zoom(1.f / m_zoom); 
  m_zoom = 1.f; 
} 
</span></pre><p><span class="koboSpan" id="kobo.153.1">By dividing </span><code class="literal"><span class="koboSpan" id="kobo.154.1">1.f</span></code><span class="koboSpan" id="kobo.155.1"> by the current zoom factor, we obtain a scale value, which, when scaled by, the view returns to its normal state.</span></p><p><span class="koboSpan" id="kobo.156.1">Next, let us see what needs to happen in order for this class to change its </span><code class="literal"><span class="koboSpan" id="kobo.157.1">ControlMode</span></code><span class="koboSpan" id="kobo.158.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">void MapControls::SelectMode(ControlMode l_mode) { 
  ResetTools(); 
  m_mode = l_mode; 
  if (m_mode == ControlMode::Brush) { RedrawBrush(); } 
  m_selectionOptions.SetControlMode(m_mode); 
} 
</span></pre><p><span class="koboSpan" id="kobo.160.1">After the tools are reset, the mode passed in as the argument is stored. </span><span class="koboSpan" id="kobo.160.2">If the mode being applied is a brush, it needs to be re-drawn. </span><span class="koboSpan" id="kobo.160.3">Lastly, the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">selectionOptions</span></code><span class="koboSpan" id="kobo.162.1"> class is notified of the mode change, so that it can perform its own logic.</span></p><p><span class="koboSpan" id="kobo.163.1">Finally, one of the last key pieces of code is the creation of a new map:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.164.1">void MapControls::NewMapCreate(EventDetails* l_details) { 
  auto s_x = m_mapSettings-&gt;GetElement("Size_X")-&gt;GetText(); 
  auto s_y = m_mapSettings-&gt;GetElement("Size_Y")-&gt;GetText(); 
  auto friction = m_mapSettings-&gt; 
    GetElement("Friction")-&gt;GetText(); 
  auto selection = static_cast&lt;GUI_DropDownMenu*&gt;( 
    m_mapSettings-&gt;GetElement("SheetDropdown"))-&gt; 
    GetMenu()-&gt;GetSelected(); 
  if (selection.empty()) { return; } 
 
  auto context = m_guiManager-&gt;GetContext(); 
  auto editorState = m_stateManager-&gt; 
    GetState&lt;State_MapEditor&gt;(StateType::MapEditor); 
  m_particleSystem-&gt;PurgeCurrentState(); 
  m_map-&gt;PurgeMap(); 
  editorState-&gt;ResetSavePath(); 
 
  m_map-&gt;GetTileMap()-&gt;SetMapSize 
    sf::Vector2u(std::stoi(s_x), std::stoi(s_y))); 
  m_map-&gt;GetDefaultTile()-&gt;m_friction = 
    sf::Vector2f(std::stof(friction), std::stof(friction)); 
  m_map-&gt;GetTileSet()-&gt;ResetWorker(); 
  m_map-&gt;GetTileSet()-&gt;AddFile(Utils::GetWorkingDirectory() + 
    "media/Tilesheets/" + selection + ".tilesheet"); 
  m_map-&gt;GetTileSet()-&gt;SetName(selection + ".tilesheet"); 
 
  auto loading = m_stateManager-&gt; 
    GetState&lt;State_Loading&gt;(StateType::Loading); 
  loading-&gt;AddLoader(context-&gt;m_gameMap-&gt;GetTileSet()); 
  loading-&gt;SetManualContinue(false); 
  editorState-&gt;SetMapRedraw(true); 
  m_mapSettings-&gt;SetActive(false); 
  m_stateManager-&gt;SwitchTo(StateType::Loading); 
} 
</span></pre><p><span class="koboSpan" id="kobo.165.1">First, we obtain the size values from the text-fields of the map settings interface. </span><span class="koboSpan" id="kobo.165.2">In addition to that, we also grab the friction value, as well as the current selection of the tile-sheet drop–down menu. </span><span class="koboSpan" id="kobo.165.3">If the latter is empty, we simply return, as no tile-sheet has been selected.</span></p><p><span class="koboSpan" id="kobo.166.1">If we do proceed, the particle system and the map both need to be purged. </span><span class="koboSpan" id="kobo.166.2">The </span><code class="literal"><span class="koboSpan" id="kobo.167.1">MapEditor</span></code><span class="koboSpan" id="kobo.168.1"> state is then notified to reset its save path, which forces the user to re-enter a filename when saving.</span></p><p><span class="koboSpan" id="kobo.169.1">The map's size is then set up, alongside the default friction value. </span><span class="koboSpan" id="kobo.169.2">The selected tile-sheet file is added for further loading in a separate thread, and its name is registered inside the game map's internal </span><code class="literal"><span class="koboSpan" id="kobo.170.1">TileSet</span></code><span class="koboSpan" id="kobo.171.1"> data member.</span></p><p><span class="koboSpan" id="kobo.172.1">Finally, the loading state is obtained, the tile-set is added to it, and the manual continue flag is set to </span><code class="literal"><span class="koboSpan" id="kobo.173.1">false</span></code><span class="koboSpan" id="kobo.174.1">, in order to make the loading screen simply go back to the current state after it is done. </span><span class="koboSpan" id="kobo.174.2">The new map settings interface is then hidden, and we can finally switch to the loading state.</span></p><p><span class="koboSpan" id="kobo.175.1">In case a mistake happens, the user must have a way to close the new </span><code class="literal"><span class="koboSpan" id="kobo.176.1">m_mapSettings</span></code><span class="koboSpan" id="kobo.177.1"> interface:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.178.1">void MapControls::NewMapClose(EventDetails* l_details) { 
  m_mapSettings-&gt;SetActive(false); 
} 
</span></pre><p><span class="koboSpan" id="kobo.179.1">This callback gets invoked when the </span><span class="strong"><strong><span class="koboSpan" id="kobo.180.1">close</span></strong></span><span class="koboSpan" id="kobo.181.1"> button of the interface is pressed. </span><span class="koboSpan" id="kobo.181.2">All it does is simply hiding it.</span></p><p><span class="koboSpan" id="kobo.182.1">Finally, we have a bunch of setters and getters that do not add up to much on their own, but are useful in the long run:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.183.1">void MapControls::NewMap() { m_mapSettings-&gt;SetActive(true); } 
void MapControls::SetTileSheetTexture(const std::string&amp; l_sheet) { 
  m_tileSelector.SetSheetTexture(l_sheet); 
} 
ControlMode MapControls::GetMode() const { return m_mode; } 
bool MapControls::IsInAction() const { return m_action; } 
bool MapControls::IsInSecondary() const{return m_secondaryAction;} 
GUI_SelectionOptions* MapControls::GetSelectionOptions() { 
  return &amp;m_selectionOptions; 
} 
sf::Vector2i MapControls::GetMouseTileStart() const { 
  return m_mouseTileStartPosition; 
} 
sf::Vector2i MapControls::GetMouseTile() const { 
  return m_mouseTilePosition; 
} 
sf::Vector2f MapControls::GetMouseDifference() const { 
  return m_mouseDifference; 
} 
bool MapControls::DrawSelectedLayers() const { 
  return m_drawSelectedLayers; 
} 
void MapControls::ToggleDrawingSelectedLayers() { 
  m_drawSelectedLayers = !m_drawSelectedLayers; 
} 
</span></pre><p><span class="koboSpan" id="kobo.184.1">You may have noticed that we have not yet covered the bucket and eraser tools. </span><span class="koboSpan" id="kobo.184.2">This is what is usually referred to as homework, which should serve as good practice:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.185.1">void MapControls::BucketUpdate() { /* IMPLEMENT */ } 
void MapControls::EraserUpdate() { /* IMPLEMENT */ } 
</span></pre><p><span class="koboSpan" id="kobo.186.1">Keep in mind that as we have not yet implemented everything that makes the map editor tick, this should probably wait until the next chapter is wrapped up.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we have introduced and implemented the concept of graphical file management, as well as laid the foundations for one of the most important tools a small RPG-style game uses. </span><span class="koboSpan" id="kobo.2.2">There is still a lot left to do before we can start reaping the benefits of having proper tools. </span><span class="koboSpan" id="kobo.2.3">In the next chapter, we will be covering the finishing touches of the map editor, as well as implementing a different tool for managing entities. </span><span class="koboSpan" id="kobo.2.4">See you there!</span></p></div></div></div></body></html>