<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building a Tetris Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a Tetris Application</h1></div></div></div><p>In this chapter, we develop a classic Tetris game. We look further into the <code class="literal">Window</code> class, including text writing and drawing figures that are more complex. We look also into timing, random numbers, and graphical updates such as falling figures and flash effects. An illustration of it is shown next:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="Building a Tetris Application"/></div><p>
</p><div class="section" title="The MainWindow function"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec13"/>The MainWindow function</h1></div></div></div><p>The <code class="literal">MainWindow</code> function is similar to the methods in <a class="link" href="ch02.html" title="Chapter 2. Hello, Small World!">Chapter 2</a>, <span class="emphasis"><em>Hello, Small World!</em></span>. It sets the application name and returns a pointer to the main window, which, in this case, is an instance of the <code class="literal">TetrisWindow</code> class. As stated in <a class="link" href="ch02.html" title="Chapter 2. Hello, Small World!">Chapter 2</a>, <span class="emphasis"><em>Hello, Small World!</em></span> the application name is used when accessing the registry, when opening or saving a file, and by the <span class="strong"><strong>About</strong></span> menu item. However, none of that functionality is used in this application:</p><p>
<span class="strong"><strong>MainWindow.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
#include "TetrisFigure.h" &#13;
#include "RedFigure.h" &#13;
#include "BrownFigure.h" &#13;
#include "TurquoiseFigure.h" &#13;
#include "GreenFigure.h" &#13;
#include "YellowFigure.h" &#13;
#include "BlueFigure.h" &#13;
#include "PurpleFigure.h" &#13;
#include "TetrisWindow.h" &#13;
 &#13;
void MainWindow(vector&lt;String&gt; /* argumentList */, &#13;
                WindowShow windowShow) { &#13;
  Application::ApplicationName() = TEXT("Tetris"); &#13;
  Application::MainWindowPtr() = new TetrisWindow(windowShow); &#13;
} &#13;
</pre></div></div>
<div class="section" title="The Tetris window"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec14"/>The Tetris window</h1></div></div></div><p>In this application, we do not use the <code class="literal">StandardDocument</code> framework from the <a class="link" href="ch02.html" title="Chapter 2. Hello, Small World!">Chapter 2</a>, <span class="emphasis"><em>Hello, Small World!</em></span>. Instead, the <code class="literal">TetrisWindow</code> class extends the Small Windows root class <code class="literal">Window</code> directly. The reason is simply that we do not need the functionality of the <code class="literal">StandardDocument</code> framework or its base class <code class="literal">Document</code>. We do not use menus or accelerators, and we do not save or load files:</p><p>
<span class="strong"><strong>TetrisWindow.h</strong></span>
</p><pre class="programlisting">class TetrisWindow : public Window { &#13;
  public: &#13;
    TetrisWindow(WindowShow windowShow); &#13;
    ~TetrisWindow(); &#13;
</pre><p>In this application, we ignore the mouse. Instead, we look into keyboard handling. The <code class="literal">OnKeyDown</code> method is called when the user presses or releases a key:</p><pre class="programlisting">    bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                   bool controlPressed); &#13;
</pre><p>Similar to the circle application, the <code class="literal">OnDraw</code> method is called every time the window's client area needs to be redrawn:</p><pre class="programlisting">    void OnDraw(Graphics&amp; graphics, DrawMode drawMode) const; &#13;
</pre><p>The <code class="literal">OnGainFocus</code> and <code class="literal">OnLoseFocus</code> methods are called when the window gains or loses input focus, respectively. When the window loses input focus, it will not receive any keyboard input and the timer is turned off, preventing the falling figure from moving:</p><pre class="programlisting">    void OnGainFocus(); &#13;
    void OnLoseFocus(); &#13;
</pre><p>The <code class="literal">OnTimer</code> method is called every second the window has focus. It tries to move the falling figure one step downward. It calls the <code class="literal">NewFigure</code> method if it fails to move the figure downward. The <code class="literal">NewFigure</code> method tries to introduce a new figure on the game board. If that fails, the <code class="literal">GameOver</code> method is called, which asks the user if they want a new game. The <code class="literal">NewGame</code> method is called if the user wants a new game. If the user does not want a new game, it exits the application:</p><pre class="programlisting">    void OnTimer(int timerId); &#13;
    void EndOfFigure(); &#13;
    void GameOver(); &#13;
    void NewGame(); &#13;
</pre><p>the <code class="literal">DeleteFullRows</code> examines each row by calling the <code class="literal">IsRowFull</code> method and calls the <code class="literal">FlashRow</code> and <code class="literal">DeleteRow</code> methods for each full row:</p><pre class="programlisting">    void DeleteFullRows(); &#13;
    bool IsRowFull(int row); &#13;
    void FlashRow(int row); &#13;
    void DeleteRow(int markedRow); &#13;
</pre><p>The <code class="literal">TryClose</code>  method is called if the user tries to close the window by clicking on the cross in the top-right corner of the window. It displays a message box that asks the user if they really want to quit:</p><pre class="programlisting">    bool TryClose(); &#13;
</pre><p>The <code class="literal">gameGrid</code> field holds the grid on which the figures are displayed (see the next section). The falling figure (<code class="literal">fallingFigure</code>) is falling down on the grid, and the next figure to fall down (<code class="literal">nextFigure</code>) is displayed in the top-right corner. Each time the player fills a row, the score (<code class="literal">currScore</code>) is increased. The timer identity (<code class="literal">TimerId</code>) is needed to keep track of the timer and is given the arbitrary value of <code class="literal">1000</code>. Finally, the figure list (<code class="literal">figureList</code>) will be filled with seven figures, one of each color. Each time a new figure is needed, a randomly chosen figure from the list will be chosen and copied:</p><pre class="programlisting">  private: &#13;
    GameGrid gameGrid; &#13;
    TetrisFigure fallingFigure, nextFigure; &#13;
 &#13;
    int currScore = 0; &#13;
    bool timerActive = true, inverse = false; &#13;
 &#13;
    static const int TimerId = 1000; &#13;
    vector&lt;TetrisFigure&gt; figureList; &#13;
}; &#13;
</pre><p>The <code class="literal">PreviewCoordinate</code> parameter in the <code class="literal">Window</code> constructor call indicates that the window's size is fixed, and the second parameter indicates that the size is 100 * 100 units. This means that unlike the circle application, the size of figures and game boards will change when the user changes the window's size:</p><p>
<span class="strong"><strong>TetrisWindow.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
#include "TetrisFigure.h" &#13;
#include "RedFigure.h" &#13;
#include "BrownFigure.h" &#13;
#include "TurquoiseFigure.h" &#13;
#include "GreenFigure.h" &#13;
#include "YellowFigure.h" &#13;
#include "BlueFigure.h" &#13;
#include "PurpleFigure.h" &#13;
#include "TetrisWindow.h" &#13;
 &#13;
TetrisWindow::TetrisWindow(WindowShow windowShow) &#13;
 :Window(PreviewCoordinate, Rect(0, 0, 100, 100), &#13;
         nullptr, OverlappedWindow, NoStyle, Normal), &#13;
</pre><p>The upper 20 percent of the client area is reserved for the score and the next figure. The game grid covers the lower 80 percent of the client area (from height unit 20 to 100):</p><pre class="programlisting">  gameGrid(Rect(0, 20, 100, 100)) { &#13;
</pre><p>Since we extend the <code class="literal">Window</code> class, we need to set the window header manually:</p><pre class="programlisting">  SetHeader(TEXT("Tetris")); &#13;
</pre><p>The timer interval is set to <code class="literal">1000</code> milliseconds, which means that <code class="literal">OnTimer</code> will be called every second. The random generator is initialized by calling the C standard functions <code class="literal">srand</code> and <code class="literal">time</code>:</p><pre class="programlisting">  SetTimer(TimerId, 1000); &#13;
  srand((unsigned int) time(nullptr)); &#13;
</pre><p>The figure list is initialized with one figure of each color; the falling and next figure are randomly chosen from that list. One of the figures in the list will be copied every time we need a new figure:</p><pre class="programlisting">  figureList.push_back(RedFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(BrownFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(TurquoiseFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(GreenFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(YellowFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(BlueFigure(this, &amp;gameGrid)); &#13;
  figureList.push_back(PurpleFigure(this, &amp;gameGrid)); &#13;
 &#13;
  fallingFigure = figureList[rand() % figureList.size()]; &#13;
  nextFigure = figureList[rand() % figureList.size()]; &#13;
} &#13;
</pre><p>Strictly speaking, it is not necessary to drop the timer when closing the Tetris window. The destructor is included only for the sake of completeness:</p><pre class="programlisting">TetrisWindow::~TetrisWindow() { &#13;
  DropTimer(TimerId); &#13;
} &#13;
</pre><div class="section" title="Keyboard input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Keyboard input</h2></div></div></div><p>The <code class="literal">OnKeyDown</code> method overrides the method in the <code class="literal">Window</code> class and is called each time the user presses a key. We try to move the falling figure in accordance with the key pressed. We do not care whether the user has pressed the <span class="emphasis"><em>Shift</em></span> or <span class="emphasis"><em>Ctrl</em></span> key:</p><pre class="programlisting">bool TetrisWindow::OnKeyDown(WORD key, bool /* shiftPressed */, &#13;
                             bool /* controlPressed */) { &#13;
  switch (key) { &#13;
    case KeyLeft: &#13;
      fallingFigure.TryMoveLeft(); &#13;
      break; &#13;
 &#13;
    case KeyRight: &#13;
      fallingFigure.TryMoveRight(); &#13;
      break; &#13;
 &#13;
    case KeyUp: &#13;
      fallingFigure.TryRotateAnticlockwise(); &#13;
      break; &#13;
 &#13;
    case KeyDown: &#13;
      fallingFigure.TryRotateAnticlockwise(); &#13;
      break; &#13;
</pre><p>When the user presses the Space key, the falling figure falls with visible speed to create the illusion of falling. We try to move the falling figure one step down every 10 milliseconds by calling the Win32 API function <code class="literal">Sleep</code>. The <code class="literal">TryMoveDown</code> method returns <code class="literal">false</code> when it is no longer possible to move the figure downward:</p><pre class="programlisting">    case KeySpace: &#13;
      while (fallingFigure.TryMoveDown()) { &#13;
        ::Sleep(10); &#13;
      } &#13;
      break; &#13;
  } &#13;
 &#13;
  return true; &#13;
} &#13;
</pre></div><div class="section" title="Drawing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Drawing</h2></div></div></div><p>The <code class="literal">OnDraw</code> method starts by drawing the game grid and two lines dividing the client area into three parts. The top-left corner displays the current score, the top-right corner displays the next figure, and the lower part displays the actual game grid:</p><pre class="programlisting">void TetrisWindow::OnDraw(Graphics&amp; graphics, &#13;
                          DrawMode /* drawMode */) const { &#13;
  gameGrid.DrawGameGrid(graphics, inverse); &#13;
  graphics.FillRectangle(Rect(Point(0, 0), Point(100,20)), &#13;
                         White, White); &#13;
  graphics.DrawLine(Point(40, 0), Point(40, 20), Black); &#13;
  graphics.DrawLine(Point(0, 20), Point(100, 20), Black); &#13;
</pre><p>Note that we add an offset when drawing the next figure in order to move from the game grid to the top-right corner. The value <code class="literal">25</code> moves the figure from the middle of the grid to the middle of its right half, and the value <code class="literal">-18</code> moves from the grid up to the area preceding the grid:</p><pre class="programlisting">  fallingFigure.DrawFigure(graphics); &#13;
  nextFigure.DrawFigure(graphics, Size(25, -18)); &#13;
</pre><p>The score font is set to <code class="literal">Times New Roman</code>, size <code class="literal">10</code>. Here, the size does not refer to typographical points, but to logical units. Since the call to the <code class="literal">Window</code> constructor states we gave the <code class="literal">PreviewCoordinate</code> coordinate system and the size 100 * 100, the height of the text will be 10 units, which is a tenth of the text client area's height. It is also half the height of the part of the client area where the score is written:</p><pre class="programlisting">  Font scoreFont(TEXT("Times New Roman"), 10); &#13;
</pre><p>The final <code class="literal">false</code> parameter in the call to the <code class="literal">DrawText</code> method indicates that the size of the text won't be recalculated. In the next chapters, we will display text that maintains the same size, regardless of the window size and the screen resolution. In this chapter, however, the size of the text will be changed when the user changes the size of window:</p><pre class="programlisting">  graphics.DrawText(Rect(0, 0, 40, 20), to_String(currScore), &#13;
                    scoreFont, Black, White, false); &#13;
} &#13;
</pre></div><div class="section" title="Input focus"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Input focus</h2></div></div></div><p>The <code class="literal">OnGainFocus</code> and <code class="literal">OnLoseFocus</code> methods start and stop the timer, respectively, so that the falling figure does not fall down when the window is out of focus:</p><pre class="programlisting">void TetrisWindow::OnGainFocus() { &#13;
  SetTimer(TimerId, 1000); &#13;
} &#13;
 &#13;
void TetrisWindow::OnLoseFocus() { &#13;
  DropTimer(TimerId); &#13;
} &#13;
</pre></div><div class="section" title="The timer"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>The timer</h2></div></div></div><p>The timer is active when it has the input focus. When active, the <code class="literal">TryMoveDown</code> method will be called every time the <code class="literal">OnTimer</code> method is called (once every second). When the figure cannot fall down any more (the <code class="literal">TryMoveDown</code> method returns <code class="literal">false</code>), the <code class="literal">EndOfFigure</code> method is called:</p><pre class="programlisting">void TetrisWindow::OnTimer(int /* timerId */) { &#13;
  if (timerActive) { &#13;
    if (!fallingFigure.TryMoveDown()) { &#13;
      EndOfFigure(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="New figures"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>New figures</h2></div></div></div><p>When it is not possible for the falling figure to move downward, the <code class="literal">OnTimer</code> method calls the <code class="literal">NewFigure</code> method. First, we need to store the falling figure to the game grid by calling the <code class="literal">AddToGrid</code> method. Then, we let the next figure become the new falling figure and we choose by random the new next figure from the figure list. We invalidate the area of the new falling figure and the area of the top-right corner where the next figure is drawn:</p><pre class="programlisting">void TetrisWindow::NewFigure() { &#13;
  fallingFigure.AddToGrid(); &#13;
  fallingFigure = nextFigure; &#13;
  fallingFigure.InvalidateFigure(); &#13;
&#13;
&#13;
 &#13;
  nextFigure = figureList[rand() % figureList.size()]; &#13;
  Rect nextArea(40, 0, 100, 20); &#13;
  Invalidate(nextArea); &#13;
  UpdateWindow(); &#13;
</pre><p>We delete the possible full rows and update the window:</p><pre class="programlisting">  DeleteFullRows(); &#13;
  UpdateWindow(); &#13;
</pre><p>If the new falling figure is not valid from the very beginning, the game is over and <code class="literal">GameOver</code> is called:</p><pre class="programlisting">  if (!fallingFigure.IsFigureValid()) { &#13;
    GameOver(); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Game over"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Game over</h2></div></div></div><p>The <code class="literal">GameOver</code> method presents the score and lets the user decide whether they want a new game. If they want a new game, it is initialized by the <code class="literal">NewGame</code> call. If the user does not want a new game, the call to the Win32 API function <code class="literal">PostQuitMessage</code> terminates the execution of the application.</p><p>Note that we call another version of the <code class="literal">Invalidate</code> method, without parameters. It invalidates the whole client area:</p><pre class="programlisting">void TetrisWindow::GameOver() { &#13;
  Invalidate(); &#13;
  UpdateWindow(); &#13;
</pre><p>The timer is inactive while the message is displayed:</p><pre class="programlisting">  timerActive = false; &#13;
  String message = TEXT("Game Over.\nYou scored ") + &#13;
                   to_String(currScore) + &#13;
                   TEXT(" points.\nAnother game?"); &#13;
 &#13;
  if (MessageBox(message, TEXT("Tetris"), YesNo, Question)==Yes) { &#13;
    NewGame(); &#13;
  } &#13;
  else { &#13;
    ::PostQuitMessage(0); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="New game"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>New game</h2></div></div></div><p>The <code class="literal">NewGame</code> method initializes the randomly chosen new falling and next figures, resets the score, and clears the game grid before activating the timer, as well as invalidates and updates the window, which makes the new falling figure starting to fall and the new game to begin:</p><pre class="programlisting">void TetrisWindow::NewGame() { &#13;
  fallingFigure = figureList[rand() % figureList.size()]; &#13;
  nextFigure = figureList[rand() % figureList.size()]; &#13;
 &#13;
  currScore = 0; &#13;
  gameGrid.ClearGameGrid(); &#13;
  timerActive = true; &#13;
  Invalidate(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div class="section" title="Deleting and flashing rows"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Deleting and flashing rows</h2></div></div></div><p>When deleting full rows, we loop through the rows, flashing and removing each full row. We increase the score and update the area of the row. Note that the rows start at the top of the grid. This means that we have to loop from the highest row to the lowest row in order to delete the row in the right order.</p><p>Note that if the row becomes flashed and deleted, we do not update the <code class="literal">row</code> variable since the deleted row will be replaced by the row above, which also needs to be examined:</p><pre class="programlisting">void TetrisWindow::DeleteFullRows() { &#13;
  int row = Rows - 1;  &#13;
  while (row &gt;= 0) { &#13;
    if (IsRowFull(row)) { &#13;
      FlashRow(row); &#13;
      DeleteRow(row); &#13;
 &#13;
      ++currScore; &#13;
      Rect scoreArea(0, 0, 40, 20); &#13;
      Invalidate(scoreArea); &#13;
      UpdateWindow(); &#13;
    } &#13;
    else { &#13;
      --row; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>A row is considered full if it does not contain a white square:</p><pre class="programlisting">bool TetrisWindow::IsRowFull(int row) { &#13;
  for (int col = 0; col &lt; Cols; ++col) { &#13;
    if (gameGrid[row][col] == White) { &#13;
      return false; &#13;
    } &#13;
  } &#13;
 &#13;
  return true; &#13;
}  &#13;
</pre><p>The flash effect is executed by redrawing the row in normal and inversed color (the <code class="literal">inverse</code> method is set) three times with an interval of 50 milliseconds. While doing this, it is especially important that we only invalidate the area of the chosen row. Otherwise, the whole window client area will be flashed:</p><pre class="programlisting">void TetrisWindow::FlashRow(int row) { &#13;
  Rect gridArea = gameGrid.GridArea(); &#13;
  int colWidth = gridArea.Width() / Cols, &#13;
      rowHeight = gridArea.Height() / Rows; &#13;
 &#13;
  Rect rowArea(0, row * rowHeight, Cols * colWidth, &#13;
               (row + 1) * rowHeight); &#13;
 &#13;
  for (int count = 0; count &lt; 3; ++count) { &#13;
    inverse = true; &#13;
    Invalidate(rowArea + gridArea.Top()Left()); &#13;
    UpdateWindow(); &#13;
    ::Sleep(50); &#13;
 &#13;
    inverse = false; &#13;
    Invalidate(rowArea + gridArea.Top()Left()); &#13;
    UpdateWindow(); &#13;
    ::Sleep(50); &#13;
  } &#13;
} &#13;
</pre><p>When deleting a row, we do not really delete it. Instead, we move each row above the deleted row one step downward and fill the top row with white squares. A complication is that we count rows from the top. This makes the lowest row on the screen the row with the highest index. This gives the appearance that we start from the bottom and remove every full row until we reach the top:</p><pre class="programlisting">void TetrisWindow::DeleteRow(int markedRow) { &#13;
  for (int row = markedRow; row &gt; 0; --row) { &#13;
    for (int col = 0; col &lt; Cols; ++col) { &#13;
      gameGrid[row][col] = gameGrid[row - 1][col]; &#13;
    } &#13;
  } &#13;
 &#13;
  for (int col = 0; col &lt; Cols; ++col) { &#13;
    gameGrid[0][col] = White; &#13;
  } &#13;
 &#13;
  Invalidate(gameGrid.GridArea()); &#13;
  Invalidate(g); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div class="section" title="Closing the window"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Closing the window</h2></div></div></div><p>Finally, when the user wants to close the window by clicking in the cross on the top-right corner, we need to confirm that they really want to quit. If the <code class="literal">TryClose</code> method returns <code class="literal">true</code>, the window is closed:</p><pre class="programlisting">bool TetrisWindow::TryClose() { &#13;
  timerActive = false; &#13;
 &#13;
  if (MessageBox(TEXT("Quit?"), TEXT("Tetris"), &#13;
                 YesNo, Question) == Yes) { &#13;
    return true; &#13;
  } &#13;
 &#13;
  timerActive = true; &#13;
  return false; &#13;
} &#13;
</pre></div></div>
<div class="section" title="The TetrisFigure class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>The TetrisFigure class</h1></div></div></div><p>In this application, there is the root <code class="literal">figure</code> class and one subclass for each type of falling figure. All figures can be moved sideways or rotated as a response to the user's requests. They are also moved downward by the timer.</p><p>There are seven figures, one for each color: red, brown, turquoise, green, yellow, blue, and purple. Each of them also has a unique shape. However, they all contain four squares. They can further be divided into three groups based on their ability to rotate. The red figure is the simplest one. It is a square and does not rotate at all. The brown, turquoise, and green figure can be rotated in vertical and horizontal directions, while the yellow, blue, and purple figures can be rotated in north, east, south, and west directions. For the red figure, it does not really matter since it does not rotate.</p><p>The <code class="literal">row</code> and <code class="literal">col</code> fields of the <code class="literal">TetrisFigure</code> class hold the center of the figure, which is marked by a cross in the illustrations of this section. The <code class="literal">color</code> field holds the color of the figure, and <code class="literal">direction</code> holds the current direction of the figure.</p><p>Finally, the <code class="literal">direction</code> array holds the relative positions of the three squares surrounding the marked square. There are four directions at most. Each direction holds three squares, which are the three remaining squares that are not the center of the figure. Each square holds two integers: the relative position of the center row and column.</p><p>The default constructor is needed to initialize the <code class="literal">fallingFigure</code> and <code class="literal">nextFigure</code> methods in the <code class="literal">TetrisWindow</code> class. The second constructor is protected since it is only called by its sub classes. Each figure has its own <code class="literal">TetrisFigure</code> subclass. Their constructors take a pointer to the color grid and define its color, start position, and figure patterns:</p><p>
<span class="strong"><strong>TetrisFigure.h</strong></span>
</p><pre class="programlisting">class TetrisFigure { &#13;
  public: &#13;
    TetrisFigure(); &#13;
 &#13;
  protected: &#13;
    TetrisFigure(Window* windowPtr, GameGrid* colorGridPtr, &#13;
           Color color, int row, int col, Direction direction, &#13;
           IntPair* northList, IntPair* eastList, &#13;
           IntPair* southList, IntPair* westList); &#13;
 &#13;
  public: &#13;
    TetrisFigure&amp; operator=(const TetrisFigure&amp; figure); &#13;
</pre><p>The <code class="literal">TryMoveLeft</code>, <code class="literal">TryMoveRight</code>, <code class="literal">TryRotateClockwise</code>, <code class="literal">TryRotateClockwise</code>, <code class="literal">TryRotateAnticlockwise</code>, and <code class="literal">TryMoveDown</code> methods all try to move the figure. They call the <code class="literal">IsFigureValid</code> method, which checks whether the new location is valid, that is, it is not located outside the game grid or at a location already occupied. The <code class="literal">IsFigureValid</code> method, in turn, calls the <code class="literal">IsSquareValid</code> method for each of its four squares:</p><pre class="programlisting">    void TryMoveLeft(); &#13;
    void TryMoveRight(); &#13;
    void TryRotateClockwise(); &#13;
    void TryRotateAnticlockwise(); &#13;
    bool TryMoveDown(); &#13;
</pre><p>There are two versions of the <code class="literal">IsFigureValid</code> method, where the first version is called by the <code class="literal">TetrisWindow</code> method and the other version is called by the preceding <code class="literal">try</code> methods in order to test whether a new location of the falling figure is valid:</p><pre class="programlisting">    bool IsFigureValid();&#13;
    static bool IsFigureValid(int direction, int row, int col,&#13;
                  GameGrid* gameGridPtr, IntPair* figureInfo[]);&#13;
    static bool IsSquareValid(int row, int col,&#13;
                              GameGrid* gameGridPtr);</pre><p>The <code class="literal">AddToGrid</code> method adds the four squares of the figure to the game grid:</p><pre class="programlisting">    void AddToGrid();&#13;
</pre><p>The <code class="literal">InvalidateFigure</code> method invalidates the area occupied by the figure, and the <code class="literal">DrawFigure</code> method draws the figure:</p><pre class="programlisting">    void InvalidateFigure(Size offsetSize = ZeroSize); &#13;
    void DrawFigure(Graphics&amp; graphics, &#13;
                    Size offsetSize = ZeroSize) const; &#13;
</pre><p>The <code class="literal">gameGridPtr</code> field is a pointer to the game grid, which we access when we try to move a figure in order to decide whether its new location is valid. The <code class="literal">color</code> field is the color of the figure (red, brown, turquoise, green, yellow, blue, or purple). The <code class="literal">row</code>, <code class="literal">col</code>, and <code class="literal">direction</code> fields hold the current location and direction of the figure.</p><p>The <code class="literal">figureInfo</code> field holds the shape of the figure. The figure can hold up to four directions: north, east, south, and west. Remember that <code class="literal">row</code> and <code class="literal">col</code> hold the location of the figures. More specifically, they hold the location of the center square of the four squares constituting the figure (marked by a cross in the following illustrations). The other three squares are defined by integer pairs holding their locations relative to the center square.</p><p>Technically, <code class="literal">figureInfo</code> is an array of four pointers (one each for the directions north, east, south, and west). Each pointer points at an array of three integer pairs, holding the locations of the three squares relative to the center square:</p><pre class="programlisting">  protected: &#13;
    Window* windowPtr; &#13;
    GameGrid* gameGridPtr; &#13;
    Color color; &#13;
    int row, col; &#13;
    Direction direction; &#13;
    IntPair* figureInfo[4]; &#13;
 }; &#13;
</pre><p>The default constructor is necessary because <code class="literal">fallingFigure</code> and <code class="literal">nextFigure</code> are member objects of the <code class="literal">TetrisWindow</code> class. However, they do not need to be initialized since their values are assigned one of the seven figures in the <code class="literal">figureList</code> array:</p><p>
<span class="strong"><strong>TetrisFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
#include "TetrisFigure.h" &#13;
#include "TetrisWindow.h" &#13;
 &#13;
TetrisFigure::TetrisFigure() { &#13;
  // Empty &#13;
} &#13;
</pre><p>The second constructor is called by the colored figure sub class constructor in order to initialize the figure. It takes a pointer to the main window and the game grid, the color of the figure, its start location and direction, and its location lists in the north, east, south, and west directions. Each of the lists holds three integer pairs representing the location of the squares relative to the center square:</p><pre class="programlisting">TetrisFigure::TetrisFigure(Window*windowPtr, GameGrid*gameGridPtr, &#13;
                           Color color, int row, int col, &#13;
                           Direction direction, &#13;
                           IntPair* northList, IntPair* eastList, &#13;
                           IntPair* southList, IntPair* westList) &#13;
 :windowPtr(windowPtr), &#13;
  gameGridPtr(gameGridPtr), &#13;
  color(color), &#13;
  row(row), &#13;
  col(col), &#13;
  direction(direction) { &#13;
  figureInfo[North] = northList; &#13;
  figureInfo[East] = eastList; &#13;
  figureInfo[South] = southList; &#13;
  figureInfo[West] = westList; &#13;
} &#13;
</pre><p>The assignment operator is necessary because the <code class="literal">fallingFigure</code> and <code class="literal">nextFigure</code> methods in the <code class="literal">TetrisWindow</code> class are copied from the figure list:</p><pre class="programlisting">TetrisFigure&amp; TetrisFigure::operator=(const TetrisFigure&amp; figure) { &#13;
  if (this != &amp;figure) { &#13;
    windowPtr = figure.windowPtr; &#13;
    gameGridPtr = figure.gameGridPtr; &#13;
    color = figure.color; &#13;
    row = figure.row; &#13;
    col = figure.col; &#13;
    direction = figure.direction; &#13;
    figureInfo[North] = figure.figureInfo[North]; &#13;
    figureInfo[East] = figure.figureInfo[East]; &#13;
    figureInfo[South] = figure.figureInfo[South]; &#13;
    figureInfo[West] = figure.figureInfo[West]; &#13;
  } &#13;
 &#13;
  return *this; &#13;
} &#13;
</pre><p>The <code class="literal">TryMoveLeft</code>, <code class="literal">TryMoveRight</code>, <code class="literal">TryRotateClockwise</code>, and <code class="literal">TryRotateAnticlockwise</code> methods are called when the user presses the arrow keys. They try to move the figure and invalidate its previous and current area if they succeed:</p><pre class="programlisting">void TetrisFigure::TryMoveLeft() { &#13;
  if (IsFigureValid(direction, row, col - 1&#13;
                    gameGridPtr, figureInfo)) { &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    --col; &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    windowPtr-&gt;UpdateWindow(); &#13;
  } &#13;
} &#13;
 &#13;
void TetrisFigure::TryMoveRight() { &#13;
  if (IsFigureValid(direction, row, col + 1&#13;
                     gameGridPtr, figureInfo)) { &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    ++col; &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    windowPtr-&gt;UpdateWindow(); &#13;
  } &#13;
} &#13;
 &#13;
&#13;
void TetrisFigure::TryRotateClockwise() { &#13;
  Direction newDirection = (direction == West) ? North : &#13;
                           ((Direction) (direction + 1)); &#13;
 &#13;
  if (IsFigureValid(newDirection, row, col, &#13;
                    gameGridPtr, figureInfo)) { &#13;
    InvalidateFigure(); &#13;
    direction = newDirection; &#13;
    InvalidateFigure(); &#13;
    windowPtr-&gt;UpdateWindow(); &#13;
  } &#13;
} &#13;
 &#13;
void TetrisFigure::TryRotateAnticlockwise() { &#13;
  Direction newDirection = (this-&gt;direction == North) ? West : &#13;
                           ((Direction) (direction - 1)); &#13;
 &#13;
  if (IsFigureValid(newDirection, row, col, &#13;
                    gameGridPtr, figureInfo)) { &#13;
    InvalidateFigure(); &#13;
    direction = newDirection; &#13;
    InvalidateFigure(); &#13;
    windowPtr-&gt;UpdateWindow(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">TryMoveDown</code> method is called by the timer when the player presses the Space key. It is also called by the <code class="literal">OnTimer</code> method in the <code class="literal">TetrisWindow</code> class; it returns a <code class="literal">Boolean</code> value indicating whether the movement succeeded:</p><pre class="programlisting">bool TetrisFigure::TryMoveDown() { &#13;
  if (IsFigureValid(direction, row + 1, col&#13;
                     gameGridPtr, figureInfo)) { &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    ++row; &#13;
    windowPtr-&gt;Invalidate(Area()); &#13;
    windowPtr-&gt;UpdateWindow(); &#13;
    return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>The first version of the <code class="literal">IsFigureValid</code> method is called by the <code class="literal">TetrisWindow</code> class and calls the second static version, with the current location and direction of the figure:</p><pre class="programlisting">bool TetrisFigure::IsFigureValid() { &#13;
  return IsFigureValid(direction, row, col&#13;
                     gameGridPtr, figureInfo); &#13;
} &#13;
</pre><p>The second version of the <code class="literal">IsFigureValid</code> method is called by the preceding <code class="literal">try</code> methods and checks if the figure is valid by calling the <code class="literal">IsSquareValid</code> method for each square in the figure. In order to do so, it needs to look up the relative positions of the included squares in the <code class="literal">figureInfo</code> method. The first value of the integer pairs is the row, and the second value is the column:</p><pre class="programlisting">bool TetrisFigure::IsFigureValid(int direction, int row, int col, &#13;
                                 GameGrid* gameGridPtr, &#13;
                                 IntPair* figureInfo[]) { &#13;
  int relRow0 = row + figureInfo[direction][0].first, &#13;
      relCol0 = col + figureInfo[direction][0].second, &#13;
      relRow1 = row + figureInfo[direction][1].first, &#13;
      relCol1 = col + figureInfo[direction][1].second, &#13;
      relRow2 = row + figureInfo[direction][2].first, &#13;
      relCol2 = col + figureInfo[direction][2].second; &#13;
 &#13;
  return IsSquareValid(row, col, gameGridPtr) &amp;&amp; &#13;
         IsSquareValid(relRow0, relCol0, gameGridPtr) &amp;&amp; &#13;
         IsSquareValid(relRow1, relCol1, gameGridPtr) &amp;&amp; &#13;
         IsSquareValid(relRow2, relCol2, gameGridPtr); &#13;
} &#13;
</pre><p>The <code class="literal">IsSquareValid</code> method returns <code class="literal">true</code> if the given square is located inside the game grid and not already occupied. A square on the game board is considered unoccupied if it is white:</p><pre class="programlisting">bool TetrisFigure::IsSquareValid(int row, int col,&#13;
                                 GameGrid* gameGridPtr) { &#13;
  return (row &gt;= 0) &amp;&amp; (row &lt; Rows) &amp;&amp; &#13;
         (col &gt;= 0) &amp;&amp; (col &lt; Cols) &amp;&amp; &#13;
         ((*gameGridPtr)[row][col] == White); &#13;
} &#13;
</pre><p>When the falling figure has reached its final position, it is added to the game grid. It is performed by setting the figure's color to the squares in the game grid at its current location. A falling figure has reached its final position when it cannot fall any longer without colliding with an earlier figure or has reached the game grid's lower bound:</p><pre class="programlisting">void TetrisFigure::AddToGrid() { &#13;
  (*gameGridPtr)[row][col] = color; &#13;
 &#13;
&#13;
  { int relRow = row + figureInfo[direction][0].first, &#13;
        relCol = col + figureInfo[direction][0].second; &#13;
    (*gameGridPtr)[relRow][relCol] = color; &#13;
  } &#13;
 &#13;
&#13;
  { int relRow = row + figureInfo[direction][1].first, &#13;
        relCol = col + figureInfo[direction][1].second; &#13;
    (*gameGridPtr)[relRow][relCol] = color; &#13;
  } &#13;
 &#13;
  { int relRow = row + figureInfo[direction][2].first, &#13;
        relCol = col + figureInfo[direction][2].second; &#13;
    (*gameGridPtr)[relRow][relCol] = color; &#13;
  } &#13;
} &#13;
</pre><p>When a figure has been moved, we need to redraw it. In order to avoid dazzle, we want to invalidate only its area, which is done by the <code class="literal">InvalidateFigure</code> method. We look up the rows and columns of the figure's four squares and call the <code class="literal">InvalidateSquare</code> method in the game grid for each of them:</p><pre class="programlisting">void TetrisFigure::InvalidateFigure(Size offsetSize/*=ZeroSize*/){ &#13;
  gameGridPtr-&gt;InvalidateSquare(windowPtr, row, col, offsetSize); &#13;
 &#13;
  { int relRow = row + figureInfo[direction][0].first, &#13;
        relCol = col + figureInfo[direction][0].second; &#13;
    gameGridPtr-&gt;InvalidateSquare(windowPtr, relRow, &#13;
                                  relCol, offsetSize); &#13;
  }  &#13;
  { int relRow = row + figureInfo[direction][1].first, &#13;
        relCol = col + figureInfo[direction][1].second; &#13;
    gameGridPtr-&gt;InvalidateSquare(windowPtr, relRow, &#13;
                                  relCol, offsetSize); &#13;
  } &#13;
  { int relRow = row + figureInfo[direction][2].first, &#13;
        relCol = col + figureInfo[direction][2].second; &#13;
    gameGridPtr-&gt;InvalidateSquare(windowPtr, relRow, &#13;
                                  relCol, offsetSize); &#13;
  } &#13;
} &#13;
</pre><p>When drawing the figure, we need to look up the locations of the squares of the figure before we draw them in a way similar to the <code class="literal">InvalidateFigure</code> method:</p><pre class="programlisting">void TetrisFigure::DrawFigure(Graphics&amp; graphics,Size offsetSize) &#13;
                              const { &#13;
  gameGridPtr-&gt;DrawSquare(graphics, row, col, &#13;
                          Black, color, offsetSize); &#13;
 &#13;
  { int relRow = row + figureInfo[direction][0].first, &#13;
        relCol = col + figureInfo[direction][0].second; &#13;
    gameGridPtr-&gt;DrawSquare(graphics, relRow, relCol, &#13;
                            Black, color, offsetSize); &#13;
  } &#13;
 &#13;
  { int relRow = row + figureInfo[direction][1].first, &#13;
        relCol = col + figureInfo[direction][1].second; &#13;
    gameGridPtr-&gt;DrawSquare(graphics, relRow, relCol, &#13;
                            Black, color, offsetSize); &#13;
  } &#13;
 &#13;
  { int relRow = row + figureInfo[direction][2].first, &#13;
        relCol = col + figureInfo[direction][2].second; &#13;
    gameGridPtr-&gt;DrawSquare(graphics, relRow, relCol, &#13;
                            Black, color, offsetSize); &#13;
  } &#13;
} &#13;
</pre><div class="section" title="The red figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>The red figure</h2></div></div></div><p>The red figure is one large square, built up by four smaller regular squares. It the simplest figure of the game since it does not change shape when rotating. This implies that we just need to look at one figure, shown as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_02.jpg" alt="The red figure"/></div><p>
</p><p>This also implies that it is enough to define the squares for one direction and this to define the shape of the figure in all four directions:</p><p>
<span class="strong"><strong>RedFigure.h</strong></span>
</p><pre class="programlisting">class RedFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair GenericList[]; &#13;
    RedFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>RedFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
#include "TetrisFigure.h" &#13;
#include "RedFigure.h" &#13;
&#13;
IntPair RedFigure::GenericList[] =&#13;
                 {IntPair(0,1), IntPair(1,0), IntPair(1,1)};&#13;
&#13;
RedFigure::RedFigure(Window* windowPtr, GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Red, 1, (Cols / 2) - 1,&#13;
                 North, GenericList, GenericList, GenericList, &#13;
                 GenericList) {&#13;
 // Empty.&#13;
}</pre><p>The first integer pair (<code class="literal">rel row 0</code>, <code class="literal">rel col 1</code>) of the generic list represents the square to the right of the marked square, the second integer pair (<code class="literal">rel row 1</code>, <code class="literal">rel col 0</code>) represents the square below the marked square, and the third integer pair (<code class="literal">rel row 1</code>, <code class="literal">rel col 1</code>) represents the square below and to the right of the marked square. Note that the rows increase downward and the columns increase to the right.</p></div><div class="section" title="The brown figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>The brown figure</h2></div></div></div><p>The brown figure can be oriented in a horizontal or vertical direction. It is initialized to vertical mode, as it can only be rotated into two directions. The north and south arrays are initialized with the vertical array and the east and west arrays are initialized with the horizontal array, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_03.jpg" alt="The brown figure"/></div><p>
</p><p>Since the row numbers increase downward and the column numbers increase to the right, the topmost square in the vertical direction (and the leftmost square in the horizontal direction) are represented by negative values:</p><p>
<span class="strong"><strong>BrownFigure.h</strong></span>
</p><pre class="programlisting">class BrownFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair HorizontalList[], VerticalList[]; &#13;
    BrownFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>BrownFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
#include "TetrisFigure.h" &#13;
#include "BrownFigure.h"&#13;
&#13;
IntPair BrownFigure::HorizontalList[] =&#13;
                     {IntPair(-1,0), IntPair(1,0), IntPair(2,0)},&#13;
        BrownFigure::VerticalList[] =&#13;
                     {IntPair(0,-1), IntPair(0,1), IntPair(0,2)};&#13;
&#13;
BrownFigure::BrownFigure(Window* windowPtr, GameGrid* gameGridPtr)&#13;
  :TetrisFigure(windowPtr, gameGridPtr, Brown, 1, (Cols / 2) - 1,&#13;
                North, HorizontalList, VerticalList,&#13;
                HorizontalList, VerticalList) {&#13;
 // Empty.&#13;
}</pre></div><div class="section" title="The turquoise figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>The turquoise figure</h2></div></div></div><p>Similar to the brown figure, the turquoise figure can be rotated in a vertical and horizontal direction, as shown in the following figure:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_04.jpg" alt="The turquoise figure"/></div><p>
</p><p>
<span class="strong"><strong>TurquoiseFigure.h</strong></span>
</p><pre class="programlisting">class TurquoiseFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair HorizontalList[], VerticalList[]; &#13;
    TurquoiseFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>TurquoiseFigure cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "GameGrid.h"&#13;
#include "TetrisFigure.h"&#13;
#include "TurquoiseFigure.h"&#13;
&#13;
IntPair TurquoiseFigure::HorizontalList[] =&#13;
                 {IntPair(-1,0), IntPair(0,1), IntPair(1,1)},&#13;
        TurquoiseFigure::VerticalList[] =&#13;
                 {IntPair(1,-1), IntPair(1,0), IntPair(0,1)};&#13;
&#13;
TurquoiseFigure::TurquoiseFigure(Window* windowPtr,&#13;
                                 GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Turquoise, 1, (Cols/2) - 1,&#13;
               North, HorizontalList, VerticalList,&#13;
               HorizontalList, VerticalList) {&#13;
  // Empty.&#13;
}</pre></div><div class="section" title="The green figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>The green figure</h2></div></div></div><p>The green figure is mirrored in relation to the turquoise figure, shown as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_05.jpg" alt="The green figure"/></div><p>
</p><p>
<span class="strong"><strong>GreenFigure.h</strong></span>
</p><pre class="programlisting">class GreenFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair HorizontalList[], VerticalList[]; &#13;
    GreenFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>GreenFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "GameGrid.h"&#13;
#include "TetrisFigure.h"&#13;
#include "GreenFigure.h"&#13;
&#13;
IntPair GreenFigure::HorizontalList[] =&#13;
                  {IntPair(1,-1), IntPair(0,-1), IntPair(-1,0)}, GreenFigure::VerticalList[] = &#13;
                  {IntPair(0,-1), IntPair(1,0), IntPair(1,1)}; &#13;
&#13;
GreenFigure::GreenFigure(Window* windowPtr, GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Green, 1, Cols / 2, &#13;
               North, HorizontalList, VerticalList,&#13;
               HorizontalList, VerticalList) {&#13;
 // Empty.&#13;
}</pre></div><div class="section" title="The yellow figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>The yellow figure</h2></div></div></div><p>The yellow figure can be rotated in a north, east, south, and west direction. It is initialized to the south, as shown in the following figure:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_06.jpg" alt="The yellow figure"/></div><p>
</p><p>
<span class="strong"><strong>YellowFigure.h</strong></span>
</p><pre class="programlisting">class YellowFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair NorthList[], EastList[], &#13;
                   SouthList[], WestList[]; &#13;
    YellowFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>YellowFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "GameGrid.h"&#13;
#include "TetrisFigure.h"&#13;
#include "YellowFigure.h"&#13;
IntPair YellowFigure::NorthList[] =&#13;
              {IntPair(0,-1), IntPair(-1,0), IntPair(0,1)},&#13;
        YellowFigure::EastList[] =&#13;
              {IntPair(-1,0),IntPair(0,1),IntPair(1,0)}, &#13;
        YellowFigure::SouthList[] = &#13;
              {IntPair(0,-1),IntPair(1,0),IntPair(0,1)},&#13;
        YellowFigure::WestList[] = &#13;
              {IntPair(-1,0),IntPair(0,-1),IntPair(1,0)};&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
YellowFigure::YellowFigure(Window* windowPtr,&#13;
                           GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Yellow, 1, (Cols / 2) - 1,&#13;
               South, NorthList, EastList, SouthList, WestList) {&#13;
  // Empty. &#13;
}</pre></div><div class="section" title="The blue figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>The blue figure</h2></div></div></div><p>The blue figure can also be directed in all four directions. It is initialized to the south, as shown in the following figure:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_07.jpg" alt="The blue figure"/></div><p>
</p><p>
<span class="strong"><strong>BlueFigure.h</strong></span>
</p><pre class="programlisting">class BlueFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair NorthList[], EastList[], &#13;
           SouthList[], WestList[]; &#13;
    BlueFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>BlueFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "GameGrid.h"&#13;
#include "TetrisFigure.h"&#13;
#include "BlueFigure.h"&#13;
&#13;
&#13;
&#13;
&#13;
IntPair BlueFigure::NorthList[] =&#13;
                    {IntPair(0,-2),IntPair(0,-1),IntPair(-1,0)},&#13;
        BlueFigure::EastList[] =&#13;
                    {IntPair(-2,0), IntPair(-1,0), IntPair(0,1)},&#13;
        BlueFigure::SouthList[] =&#13;
                    {IntPair(1,0), IntPair(0,1), IntPair(0,2)},&#13;
        BlueFigure::WestList[] =&#13;
                    {IntPair(0,-1), IntPair(1,0), IntPair(2,0)};&#13;
&#13;
BlueFigure::BlueFigure(Window* windowPtr, GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Blue, 1, (Cols / 2) - 1,&#13;
              South, NorthList, EastList, SouthList, WestList) {&#13;
  // Empty. &#13;
}</pre></div><div class="section" title="The purple figure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>The purple figure</h2></div></div></div><p>Finally, the purple figure is mirrored in relation to the blue figure and also initialized to the south, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_03_08.jpg" alt="The purple figure"/></div><p>
</p><p>
<span class="strong"><strong>PurpleFigure.h</strong></span>
</p><pre class="programlisting">class PurpleFigure : public TetrisFigure { &#13;
  public: &#13;
    static IntPair NorthList[], EastList[], &#13;
                   SouthList[], WestList[]; &#13;
    PurpleFigure(Window* windowPtr, GameGrid* gameGridPtr); &#13;
};</pre><p>
<span class="strong"><strong>PurpleFigure.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h"&#13;
#include "GameGrid.h"&#13;
#include "TetrisFigure.h"&#13;
#include "PurpleFigure.h"&#13;
&#13;
IntPair PurpleFigure::NorthList[] =&#13;
              {IntPair(-1,0),IntPair(0,1),IntPair(0,2)},&#13;
        PurpleFigure::EastList[] =&#13;
              {IntPair(1,0), IntPair(2,0), IntPair(0,1)},&#13;
        PurpleFigure::SouthList[] =&#13;
              {IntPair(0,-2),IntPair(0,-1),IntPair(1,0)},&#13;
        PurpleFigure::WestList[] =&#13;
              {IntPair(0,-1),IntPair(-2,0),IntPair(-1,0)}; &#13;
&#13;
&#13;
&#13;
PurpleFigure::PurpleFigure(Window* windowPtr,&#13;
                           GameGrid* gameGridPtr)&#13;
 :TetrisFigure(windowPtr, gameGridPtr, Purple, 1, Cols / 2, South,&#13;
               NorthList, EastList, SouthList, WestList) {&#13;
  // Empty. &#13;
}</pre></div></div>
<div class="section" title="The GameGrid class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>The GameGrid class</h1></div></div></div><p>Finally, the <code class="literal">GameGrid</code> class is quite simple. It keeps track of the squares on the game board. The <code class="literal">gridArea</code> field is the portion of the total client area that is occupied by the grid:</p><p>
<span class="strong"><strong>GameGrid.h</strong></span>
</p><pre class="programlisting">const int Rows = 20, Cols = 10;  &#13;
 &#13;
class GameGrid { &#13;
  public: &#13;
    GameGrid(Rect gridArea); &#13;
    void ClearGameGrid(); &#13;
 &#13;
    Color* operator[](int row) {return gameGrid[row];} &#13;
    void InvalidateSquare(Window* windowPtr, int row, &#13;
                          int col, Size offsetSize); &#13;
    void DrawGameGrid(Graphics&amp; graphics, bool inverse) const; &#13;
&#13;
&#13;
&#13;
    void DrawSquare(Graphics&amp; graphics, int row, int col, &#13;
                    Color penColor, Color brushColor, &#13;
                    Size offsetSize = ZeroSize) const; &#13;
 &#13;
    Rect GridArea() const {return gridArea;} &#13;
 &#13;
  private: &#13;
    Rect gridArea; &#13;
    Color gameGrid[Rows][Cols]; &#13;
}; &#13;
</pre><p>When called by the <code class="literal">TetrisWindow</code> constructor, the grid area will be set to (0, 20, 100, 100) units, placing it in the lower 80 percent of the client area of the window:</p><p>
<span class="strong"><strong>GameGrid.cpp</strong></span>
</p><pre class="programlisting">#include "..\\SmallWindows\\SmallWindows.h" &#13;
#include "GameGrid.h" &#13;
 &#13;
&#13;
&#13;
GameGrid::GameGrid(Rect gridArea) &#13;
 :gridArea(gridArea) { &#13;
  ClearGameGrid(); &#13;
} &#13;
</pre><p>When clearing the grid, we actually set every square to white:</p><pre class="programlisting">void GameGrid::ClearGameGrid () { &#13;
  for (int row = 0; row &lt; Rows; ++row) { &#13;
    for (int col = 0; col &lt; Cols; ++col) { &#13;
      gameGrid[row][col] = White; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><div class="section" title="Invalidating and drawing squares"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Invalidating and drawing squares</h2></div></div></div><p>The <code class="literal">DrawGameGrid</code> iterates through the squares of the grid. White squares are surrounded by white borders, while squares of every other color are surrounded by black borders. If the <code class="literal">inverseColor</code> parameter is true, the square color is inversed before drawn. This is useful when flashing rows:</p><pre class="programlisting">void GameGrid::DrawGameGrid(Graphics&amp; graphics, bool inverse) &#13;
                            const { &#13;
  for (int row = 0; row &lt; Rows; ++row) { &#13;
    for (int col = 0; col &lt; Cols; ++col) { &#13;
      Color squareColor = gameGrid[row][col]; &#13;
      Color penColor = (squareColor == White) ? White : Black; &#13;
      Color brushColor = inverse ? squareColor.Inverse() &#13;
                                 : squareColor; &#13;
      DrawSquare(graphics, row, col, penColor, brushColor); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Note that the <code class="literal">InvalidateSquare</code> and <code class="literal">DrawSquare</code> methods add an offset. It is zero in all cases except when invalidating or drawing the next figure in the <code class="literal">TetrisWindow</code> class. Both methods calculate the size of the rows and columns of the grid and define the area of the square invalidated or drawn:</p><pre class="programlisting">void GameGrid::InvalidateSquare(Window* windowPtr, int row, &#13;
                                int col, Size offsetSize) { &#13;
  int colWidth = gridArea.Width() / Cols, &#13;
      rowHeight = gridArea.Height() / Rows; &#13;
 &#13;
&#13;
  Rect squareArea(col * colWidth, row * rowHeight, &#13;
                  (col + 1) * colWidth, (row + 1) * rowHeight); &#13;
  windowPtr-&gt;Invalidate(gridArea.TopLeft() + squareArea + &#13;
                        offsetSize); &#13;
} &#13;
 &#13;
void GameGrid::DrawSquare(Graphics&amp; graphics, int row, int col, &#13;
                          Color penColor, Color brushColor, &#13;
                          Size offsetSize /* = ZeroSize */) const{ &#13;
  int colWidth = gridArea.Width() / Cols, &#13;
      rowHeight = gridArea.Height() / Rows; &#13;
 &#13;
  Rect squareArea (col * colWidth, row * rowHeight, &#13;
                  (col + 1) * colWidth, (row + 1) * rowHeight); &#13;
  graphics.FillRectangle(gridArea.TopLeft() + squareArea + &#13;
                         offsetSize, penColor, brushColor); &#13;
} &#13;
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we developed a Tetris game. You looked into timing and randomization, as well as a new coordinate system, more advanced drawing, how to catch keyboard events, and how to write text.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Working with Shapes and Figures">Chapter 4</a>, <span class="emphasis"><em>Working with Shapes and Figures</em></span>, we will develop a drawing program capable of drawing lines, arrows, rectangles, and ellipses.</p></div></body></html>