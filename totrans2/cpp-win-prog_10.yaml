- en: Chapter 10. The Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。框架
- en: 'The remaining chapters of this book explain the details of the Small Windows
    implementation. This chapter covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余章节解释了Small Windows实现的细节。本章涵盖以下主题：
- en: An overview of the classes of Small Windows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Small Windows类的概述
- en: An example of the Hello World application, which we covered at the beginning
    of this book, written in the Win32 API7
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本书开头介绍的Hello World应用程序的示例，使用Win32 API编写
- en: The `MainWindow` and `WinMain` functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow`和`WinMain`函数'
- en: 'The implementation of the main classes of Small Windows: `Application`, `Window`,
    and `Graphics`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Small Windows主要类的实现：`Application`、`Window`和`Graphics`
- en: An overview of Small Windows
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Small Windows的概述
- en: 'Here is a short description of the classes of Small Windows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Small Windows类的简要描述：
- en: '| **Chapter** | **Class** | **Description** |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **章节** | **类** | **描述** |'
- en: '| 10 | `Application` | This is the `main` class of Small Windows. It manages
    the message loop and registration of Windows classes. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `Application` | 这是Small Windows的`main`类。它管理消息循环和Windows类的注册。|'
- en: '| 10 | `Window` | This the root `Window` class. It creates individual windows
    and provides basic window functionality, such as mouse, touch, and keyboard input,
    drawing, zooming, timer, focus, size, and coordinate systems. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `Window` | 这是根`Window`类。它创建单个窗口并提供基本的窗口功能，如鼠标、触摸和键盘输入、绘图、缩放、计时器、焦点、大小和坐标系。|'
- en: '| 10 | `Graphics` | This is the class for drawing lines, rectangles, ellipses,
    and text in the client area of the window. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `Graphics` | 这是用于在窗口客户端区域绘制线条、矩形、椭圆和文本的类。|'
- en: '| 11 | `Document` extends `Window` | This extends the window with document
    functionality, such as scrolling, caret handling, and drop files. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `Document` 扩展 `Window` | 这扩展了窗口以包含文档功能，如滚动、光标处理和拖放文件。|'
- en: '| 11 | `Menu` | This handles menu bars, menus, menu items, and the menu separator.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `Menu` | 这处理菜单栏、菜单、菜单项和菜单分隔符。|'
- en: '| 11 | `Accelerator` | This extracts accelerator information from the menu
    item texts. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `Accelerator` | 这从菜单项文本中提取加速器信息。|'
- en: '| 11 | `StandardDocument` extends `Document` | This provides a document-based
    framework with the common **File**, **Edit**, and **Help** menu items. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `StandardDocument` 扩展 `Document` | 这提供了一个基于文档的框架，包含常见的**文件**、**编辑**和**帮助**菜单项。|'
- en: '| 12 | `Size``Point``Rect` | These are auxiliary classes that handle a two-dimensional
    point (x and y), size (width and height), or the four corners of a rectangle.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `Size` `Point` `Rect` | 这些是处理二维点（x和y）、大小（宽度和高度）或矩形四个角的辅助类。|'
- en: '| 12 | `Font` | This wraps the `LOGFONT` structure, which holds information
    about the font''s name, size, and whether it is bold or italic. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `Font` | 这封装了`LOGFONT`结构，该结构包含有关字体名称、大小以及是否为粗体或斜体的信息。|'
- en: '| 12 | `Cursor` | This sets the cursor and provides a set of standard cursors.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `Cursor` | 这设置光标并提供一组标准光标。|'
- en: '| 12 | `DynamicList` template | This is a list of dynamic size and a set of
    callback methods. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `DynamicList` 模板 | 这是一个动态大小的列表和一组回调方法。|'
- en: '| 12 | `Tree` template | This is a tree structure where each node has a (possibly
    empty) list of child nodes. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `Tree` 模板 | 这是一个树结构，其中每个节点都有一个（可能为空）子节点列表。|'
- en: '| 12 | `InfoList` | This is a list of generic information, which can be transformed
    to and from a memory buffer. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `InfoList` | 这是一个通用信息列表，可以转换成和从内存缓冲区。|'
- en: '| 13 | `Registry` | This provides an interface against the Windows registry.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `Registry` | 这提供了一个与Windows注册表的接口。|'
- en: '| 13 | `Clipboard` | This provides an interface against the Windows clipboard.
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `Clipboard` | 这提供了一个与Windows剪贴板的接口。|'
- en: '| 13 | `StandardDialog` | This displays the standard dialogs for saving and
    opening files, choosing a font or color, and printing. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `StandardDialog` | 这显示保存和打开文件、选择字体或颜色以及打印的标准对话框。|'
- en: '| 13 | `PreviewDocument` extends `Document` | This sets up a document whose
    logical size is fixed regardless of its physical size. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `PreviewDocument` 扩展 `Document` | 这设置了一个逻辑大小固定（无论其物理大小如何）的文档。|'
- en: '| 14 | `Dialog` extends `Window` | This provides a modal dialog. The controls
    below are added to the dialog. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `Dialog` 扩展 `Window` | 这提供了一个模态对话框。下面的控件被添加到对话框中。|'
- en: '| 14 | `Control` abstract | This is the base class for dialog controls. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `Control` 抽象 | 这是对话框控件的基础类。|'
- en: '| 14 | `ButtonControl` extends `Control` | This is the base class for button
    controls. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `ButtonControl` 扩展 `Control` | 这是按钮控件的基础类。|'
- en: '| 14 | `GroupBox`, `PushButton`, `CheckBox`, `RadioButton` extends `ButtonControl`
    | These are classes for group boxes, push buttons, checkboxes, and radio buttons.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `GroupBox`、`PushButton`、`CheckBox`、`RadioButton` 扩展 `ButtonControl`
    | 这些是用于分组框、按钮、复选框和单选按钮的类。|'
- en: '| 14 | `ListControl` extends `Control` | This is the base class for list controls.
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `ListControl` 扩展 `Control` | 这是列表控件的基础类。|'
- en: '| 14 | `ListBox`, `MultipleListBox` extends `ListControl` | These are classes
    for single and multiple list boxes. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `ListBox`、`MultipleListBox` 扩展 `ListControl` | 这些是用于单选和复选列表框的类。|'
- en: '| 14 | `ComboBox` extends `Control` | This is the class for a combo (drop-down)
    box. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `ComboBox` 扩展 `Control` | 这是一个组合（下拉）框的类。|'
- en: '| 14 | `Label` extends `Control` | This is the class for a simple label, often
    used as a prompt for `TextField`. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `Label` 扩展 `Control` | 这是一个简单的标签类，通常用作 `TextField` 的提示。|'
- en: '| 14 | `TextField` template extends `Control` | This is a class for an editable
    field, where a converter may convert between a string and any type. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `TextField` 模板扩展 `Control` | 这是一个可编辑字段的类，其中转换器可以在字符串和任何类型之间进行转换。|'
- en: '| 14 | `Converter` template | This is a converter class that can be specified
    by any type. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `Converter` 模板 | 这是一个可以指定为任何类型的转换器类。|'
- en: '| 14 | `PageSetupDialog` extends `Dialog` | This is a dialog for page setup
    settings, such as margins, headers, and footer text. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `PageSetupDialog` 扩展 `Dialog` | 这是一个用于页面设置设置的对话框，例如页边距、页眉和页脚文本。|'
- en: '| 14 | `PageSetupInfo` | This has page setup information, which we saw previously.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `PageSetupInfo` | 这包含页面设置信息，我们之前已经看到过。|'
- en: '"Hello" window for the Win32 API'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Hello" 窗口用于 Win32 API'
- en: First of all, let's take a look at the Hello application from the first chapter
    of this book. The following code snippet is the same application written directly
    with the Win32 API, without Small Windows. Note that the code is written in C
    rather than C++ as the Win32 API is a C function library rather than a C++ class
    library. As you can see, the code is a lot more complicated compared to the application
    in the first chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这本书第一章中的 Hello 应用程序。以下代码片段是使用 Win32 API 直接编写的相同应用程序，没有使用 Small Windows。请注意，代码是用
    C 编写的，而不是 C++，因为 Win32 API 是一个 C 函数库，而不是 C++ 类库。正如你所看到的，与第一章中的应用程序相比，代码要复杂得多。
- en: Do not worry if it looks complicated. Its purpose is actually to demonstrate
    the complexity of the Win32 API; we'll discuss the details in this and the following
    chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看起来很复杂，请不要担心。它的目的实际上是演示 Win32 API 的复杂性；我们将在本章和下一章中讨论细节。
- en: '**MainWindow.c**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.c**'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `WinMain` method is called when the application starts to execute. It corresponds
    to `main` in Standard C.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开始执行时，会调用 `WinMain` 方法。它对应于标准 C 中的 `main`。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we need to register the `Windows` class for our window. Note that `Windows`
    classes are not C++ classes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的窗口注册 `Windows` 类。请注意，`Windows` 类不是 C++ 类：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The style of the `Windows` class will be redrawn when the window size is changed
    in the horizontal and vertical direction:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口在水平和垂直方向上改变大小的时候，`Windows` 类的样式将被重新绘制：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The icon of the window is the standard application icon, the cursor is the standard
    arrow cursor, and the background of the client area is white.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的图标是标准应用程序图标，光标是标准箭头光标，客户端区域的背景是白色。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `WindowProc` function is a callback function called every time the window
    receives a message:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowProc` 函数是一个回调函数，每次窗口收到消息时都会被调用：'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The name of the `Windows` class is `window`, which is used in the `CreateWindowEx`
    call here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Windows` 类的名称是 `window`，在这里用于 `CreateWindowEx` 调用中：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `CreateWindowEx` method creates a window with the default position and
    size. Note that we can create many windows with the same `Windows` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateWindowEx` 方法创建一个具有默认位置和大小的窗口。请注意，我们可以使用相同的 `Windows` 类创建许多窗口：'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `GetMessage` method waits for the next message, which is translated and
    dispatched to the window with an input focus. The `GetMessage` method returns
    `true` for all messages except the quit message, which is eventually sent when
    the user closes the window:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMessage` 方法等待下一个消息，该消息被翻译并发送到具有输入焦点的窗口。`GetMessage` 方法对所有消息返回 `true`，除了退出消息，该消息在用户关闭窗口时最终发送：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When painting the client area, we need to create a paint structure and a device
    context, which is created by `BeginPaint`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制客户端区域时，我们需要创建一个绘图结构和设备上下文，这是通过 `BeginPaint` 创建的：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we want to use logical units (hundreds of a millimeters), we need to
    set the device context by calling `SetWindowExtEx` and `SetViewportExtEx`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想使用逻辑单位（毫米的百倍），我们需要通过调用 `SetWindowExtEx` 和 `SetViewportExtEx` 来设置设备上下文：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we also want to take scroll movements into consideration, we also call
    `SetWindowOrgEx`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们还想考虑滚动动作，所以我们也会调用 `SetWindowOrgEx`:'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, as we want to take scroll movements into consideration, we call `SetWindowOrgEx`
    to set to logical origin of the client area:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们想考虑滚动动作，我们调用 `SetWindowOrgEx` 来设置客户端区域的逻辑原点：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to set a `LOGFONT` structure to create the 12-point boldface `Times
    New Roman` font:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置一个 `LOGFONT` 结构来创建12磅粗体的 `Times New Roman` 字体：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we work with logical units that are hundreds of millimeters, one typographical
    point is 1 inch divided by 72 and 1 inch is 25.4 millimeters. We multiply the
    font size by 2,540 and divide it by 72:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是毫米级的逻辑单位，一个排版点等于1英寸除以72，1英寸等于25.4毫米。我们将字体大小乘以2540然后除以72：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we use the font to write text in the client area, we need to create the
    font indirectly and add it as a graphical object. We also need to save the previous
    object in order to restore it later:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在客户端区域使用字体写入文本时，我们需要间接创建字体并将其添加为图形对象。我们还需要保存先前的对象以便稍后恢复：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The text color is black and its background color is white. `RGB` is a macro
    that transforms the red, green, and blue parts of the color into a `COLORREF`
    value:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文本颜色为黑色，背景颜色为白色。`RGB` 是一个宏，它将颜色的红色、绿色和蓝色部分转换为一个 `COLORREF` 值：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, `DrawText` draws the text in the middle of the client area:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DrawText` 在客户端区域的中间绘制文本：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since fonts are system resources, we need to restore the previous font object
    and delete the new font object. We also need to restore the paint structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字体是系统资源，我们需要恢复先前的字体对象并删除新的字体对象。我们还需要恢复绘图结构：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we have handled the `WM_PAINT` message, we return zero.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经处理了 `WM_PAINT` 消息，我们返回零。
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For all messages other than `WM_PAINT`, we call `DefWindowProc` to handle the
    message:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除 `WM_PAINT` 以外的所有消息，我们调用 `DefWindowProc` 来处理消息：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The MainWindow function
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主窗口函数
- en: In regular C and C++, the execution of the application starts with the `main`
    function. In Small Windows, however, `main` has been replaced by `MainWindow`.
    `MainWindow` is implemented by the user of Small Windows for each project. Its
    task is to define the application name and create the main window object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规 C 和 C++ 中，应用程序的执行从 `main` 函数开始。然而，在小型 Windows 中，`main` 被替换为 `MainWindow`。`MainWindow`
    由小型 Windows 的用户为每个项目实现。其任务是定义应用程序名称并创建主窗口对象。
- en: '**MainWindow.h**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.h**'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The WinMain function
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinMain 函数
- en: 'In the Win32 API, `WinMain` is the function equivalent to `main`. Each application
    must include the definition of the `WinMain` function. In order for Small Windows
    to work, `WinMain` is implemented as a part of Small Windows, while `MainWindow`
    has to be implemented by the user of Small Windows for each project. To sum it
    up, here are the three kinds of main functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Win32 API 中，`WinMain` 是与 `main` 等效的函数。每个应用程序都必须包含 `WinMain` 函数的定义。为了使小型 Windows
    工作，`WinMain` 作为小型 Windows 的一部分实现，而 `MainWindow` 必须由小型 Windows 的用户为每个项目实现。总结一下，这里有三种主函数：
- en: '| **Regular C/C++** | **Win32 API** | **Small Windows** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **常规 C/C++** | **Win32 API** | **小型 Windows** |'
- en: '| main | WinMain | MainWindow |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| main | WinMain | MainWindow |'
- en: 'The `WinMain` function is called by the Windows system and takes the following
    parameters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinMain` 函数由 Windows 系统调用，并接受以下参数：'
- en: '`instanceHandle`: This holds the handle of the application'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceHandle`：这包含应用程序的句柄'
- en: '`prevInstanceHandle`: This is present due to backward compatibility but is
    always `null`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prevInstanceHandle`：由于向后兼容性，它存在，但始终为 `null`'
- en: '`commandLine`: This is a null-terminated character (`char`, not `TCHAR`) array
    holding the arguments for the application, separated by spaces'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commandLine`：这是一个以空字符终止的字符（`char`，不是 `TCHAR`）数组，包含应用程序的参数，由空格分隔'
- en: '`commandShow`: This holds the preferred appearance of the main window'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commandShow`：这包含主窗口的首选外观'
- en: '**WinMain.cpp**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**WinMain.cpp**'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `WinMain` function performs the following tasks:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinMain` 函数执行以下任务：'
- en: It divides the space-separated words of the command line into a `String` list
    by calling `GenerateArgumentList`. Refer to [Chapter 12](ch12.html "Chapter 12. The
    Auxiliary Classes"), *Auxiliary Classes*, for the definitions of `CharPtrToGenericString`
    and `Split`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过调用 `GenerateArgumentList` 将命令行中空格分隔的单词划分为一个 `String` 列表。请参阅[第12章](ch12.html
    "第12章。辅助类")，*辅助类*，以了解 `CharPtrToGenericString` 和 `Split` 的定义。
- en: It instantiates an `Application` object.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实例化一个 `Application` 对象。
- en: It calls the `MainWindow` function, which creates the main window of the application
    and sets its name.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `MainWindow` 函数，该函数创建应用程序的主窗口并设置其名称。
- en: It calls the `RunMessageLoop` method of `Application`, which continues to handle
    Windows messages until the quit message is sent.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `Application` 的 `RunMessageLoop` 方法，该方法继续处理 Windows 消息，直到收到退出消息。
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Application class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Application` 类'
- en: The `Application` class handles the message loop of the application. The message
    loop waits for the next message from the Windows system and sends it to the right
    window. The `Application` class also defines the `Windows` classes (which are
    not C++ classes) for the `Window`, `Document`, `StandardDocument`, and `Dialog`
    C++ classes. The fields of the classes are static since `Application` is not intended
    to be instantiated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 类处理应用程序的消息循环。消息循环等待从 Windows 系统接收下一个消息并将其发送到正确的窗口。`Application`
    类还定义了 `Window`、`Document`、`StandardDocument` 和 `Dialog` C++ 类的 `Windows` 类（它们不是
    C++ 类）。由于 `Application` 不打算实例化，因此类的字段是静态的。'
- en: From this point in Small Windows, every part of the Small Windows implementation
    is included in the `SmallWindows` namespace. A namespace is a C++ feature that
    encapsulates classes and functions. The declaration of `MainWindow`, we saw earlier,
    is not included in the `Smallwindows` namespace since the C++ language rules stipulate
    that it cannot be included in a namespace. The `WinMain` definition is also not
    included in the namespace, since it needs to be placed outside the namespace to
    be called by the Windows system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Small Windows 的这个点开始，Small Windows 实现的每一部分都包含在 `SmallWindows` 命名空间中。命名空间是
    C++ 的一个特性，用于封装类和函数。我们之前看到的 `MainWindow` 的声明不包括在 `Smallwindows` 命名空间中，因为 C++ 语言规则规定它不能包含在命名空间中。`WinMain`
    的定义也不包含在命名空间中，因为它需要放在命名空间外部才能被 Windows 系统调用。
- en: '**Application.h**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Application.h**'
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `RegisterWindowClasses` method defines the Windows classes for the `Window`,
    `Document`, `StandardDocument`, and `Dialog` C++ classes. The `RunMessageLoop`
    method runs the message loop of the Windows message system. It waits for the next
    message and sends it to the right window. When a special quit message is received
    it breaks the message loop, which leads to the termination of the `Application`
    class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterWindowClasses` 方法为 `Window`、`Document`、`StandardDocument` 和 `Dialog`
    C++ 类定义 Windows 类。`RunMessageLoop` 方法运行 Windows 消息系统的消息循环。它等待下一个消息并将其发送到正确的窗口。当接收到特殊的退出消息时，它会中断消息循环，从而导致
    `Application` 类的终止：'
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Windows, each application holds a **handle** to the application instance.
    Handles are common in the Win32 API, and are used to access objects of the Windows
    system. They are similar to pointers but provide identification without revealing
    any location information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，每个应用程序都持有应用程序实例的 **句柄**。句柄在 Win32 API 中很常见，用于访问 Windows 系统的对象。它们类似于指针，但提供标识而不透露任何位置信息。
- en: 'The instance handle (of the `HINSTANCE` type) is used when creating windows
    in the constructor of the following `Window` class and when displaying standard
    dialogs in the Standard Dialogs section in [Chapter 14](ch14.html "Chapter 14. Dialogs,
    Controls, and Page Setup"), *Dialogs, Controls, and Page Setup*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建以下 `Window` 类的构造函数中以及在第 14 章[对话框、控件和页面设置](ch14.html "第14章。对话框、控件和页面设置")的“标准对话框”部分显示标准对话框时，使用实例句柄（`HINSTANCE`
    类型）：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The application name is set by each application and is referred to by the standard
    **File**, **Help**, and **About** menus, the **Open** and **Save** dialogs, and
    the registry:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序名称由每个应用程序设置，并通过标准 **文件**、**帮助** 和 **关于** 菜单、**打开** 和 **保存** 对话框以及注册表进行引用：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The pointer to the main window of the application is referenced when the user
    closes a window. If it is the main window, the application exits. Moreover, when
    the user selects the **Exit** menu item, the main window is closed before the
    application exits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户关闭窗口时，会引用应用程序主窗口的指针。如果是主窗口，则应用程序退出。此外，当用户选择 **退出** 菜单项时，在应用程序退出之前会关闭主窗口：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Application.cpp**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Application.cpp**'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Win32 API Windows classes
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Win32 API的Windows类
- en: 'The `Windows` classes are registered in `Application`. A Windows class needs
    to be registered only once. After it has been registered, more than one window
    can be created for each `Windows` class. Again, note that windows classes are
    not C++ classes. Each `Windows` class is stored by its name: `lpszClassName`.
    The `lpfnWndProc` field defines the freestanding function that receives the window
    messages from the message loop. Each window allows double-clicks as well as horizontal
    and vertical redraw styles, which means that the `WM_PAINT` message is sent to
    the window and the `OnPaint` method is called each time the user changes the size
    of the window. Moreover, each window has the standard application icon in its
    top-right corner and the standard arrow cursor. The client area is white, except
    for the dialog, where the client area is light gray:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Windows`类在`Application`中注册。一个Windows类只需要注册一次。注册后，可以为每个`Windows`类创建多个窗口。再次注意，窗口类不是C++类。每个`Windows`类通过其名称：`lpszClassName`存储。`lpfnWndProc`字段定义了接收来自消息循环的窗口消息的独立函数。每个窗口都允许双击以及水平和垂直重绘样式，这意味着每次用户更改窗口大小时，都会向窗口发送`WM_PAINT`消息并调用`OnPaint`方法。此外，每个窗口在其右上角都有标准的应用程序图标和标准的箭头光标。客户端区域为白色，除了对话框，其客户端区域为浅灰色：'
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The message loop
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息循环
- en: 'The `RunMessageLoop` method holds the classic Windows message loop. There are
    two cases: if the main window pointer points at an object of the `Window` class,
    we just need to handle the message queue with the Win32 API functions `GetMessage`,
    `TranslateMessage`, and `DispatchMessage` without caring about accelerators. However,
    if it points at an object of `Document` or any of its subclasses, the message
    loop becomes more complicated because we need to take accelerators into consideration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunMessageLoop`方法保留了经典的Windows消息循环。有两种情况：如果主窗口指针指向`Window`类的对象，我们只需使用Win32
    API函数`GetMessage`、`TranslateMessage`和`DispatchMessage`处理消息队列，而不关心加速器。然而，如果它指向`Document`或其任何子类的对象，消息循环变得更加复杂，因为我们需要考虑加速器：'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the main window pointer points at an object of `Document` or any of its
    subclasses, we set up a buffer for the accelerator table defined in `Document`,
    which we use in the message loop. The Win32 API `TranslateAccelerator` function
    looks up the accelerator and decides whether a key stroke message should be treated
    as the menu item associated with the accelerator:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主窗口指针指向`Document`对象或其任何子类，我们将在`Document`中定义的加速器表中设置一个缓冲区，我们在消息循环中使用它。Win32
    API的`TranslateAccelerator`函数查找加速器并决定是否将按键消息视为与加速器关联的菜单项：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `TranslateAccelerator` method wants an array of ACCEL structures, so we
    convert the accelerator set to an array:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`TranslateAccelerator`方法需要一个ACCEL结构的数组，因此我们将加速器集转换为数组：'
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the accelerator array is used, it is deleted:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用加速器数组时，它将被删除：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the message loop is finished, we return the last massage:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息循环完成后，我们返回最后一条消息：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Window class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Window`类'
- en: The `Window` class is the root class of the document classes; it handles basic
    window functionality such as the timer, input focus, coordinate transformation,
    window size and position, text metrics, and the message box as well as mouse,
    keyboard, and touch screen input. Moreover, `Window` defines enumerations for
    window styles and appearances, buttons, icons, and coordinate systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`类是文档类的根类；它处理基本窗口功能，如计时器、输入焦点、坐标变换、窗口大小和位置、文本度量以及消息框以及鼠标、键盘和触摸屏输入。此外，`Window`定义了窗口样式和外观、按钮、图标和坐标系统的枚举：'
- en: '**Window.h**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Window.h**'
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is large set of window styles. The window may be equipped with a border,
    a thick frame, scroll bars, or minimize and maximize boxes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存在大量的窗口样式。窗口可能配备有边框、厚边框、滚动条或最小化和最大化框：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The window can be displayed in minimized, maximized, or normal mode:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口可以以最小化、最大化或正常模式显示：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A mouse may hold the left, middle, and right button. The mouse wheel can be
    rolled upwards or downwards:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标可以按下左键、中键和右键。鼠标滚轮可以向上或向下滚动：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are four kinds of coordinate system as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的坐标系如下：
- en: '`LogicalWithScroll`: In this, each unit is one hundredth of a millimeter, regardless
    of the physical screen resolution, with the current scroll bar settings taken
    into consideration'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogicalWithScroll`：在这种情况下，每个单位是毫米的一百分之一，无论物理屏幕分辨率如何，都考虑当前的滚动条设置'
- en: '`LogicalWithoutScroll`: This is the same as `LogicalWithScroll`, except that
    the scroll bars settings are ignored'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogicalWithoutScroll`：这与`LogicalWithScroll`相同，只是忽略了滚动条设置'
- en: '`PreviewCoordinate`: In this, the window client area always holds a specific
    logical size, which means that the size of the logical units is changed when the
    size of the window is changed'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreviewCoordinate`：在这种情况下，窗口客户端区域始终保持特定的逻辑大小，这意味着当窗口大小改变时，逻辑单位的大小也会改变'
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The message box comes equipped with a set of button combinations, icons, and
    answers. Note that the answer corresponding to the **OK** button is named `OkAnswer`
    in the `Answer` enumeration in order to avoid name clashes with the `OK` button
    in the `ButtonGroup` enumeration:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框配备了按钮组合、图标和答案。请注意，对应于**OK**按钮的答案在`Answer`枚举中命名为`OkAnswer`，以避免与`ButtonGroup`枚举中的`OK`按钮名称冲突：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The default definitions of `OnPaint` and `OnPrint` both call `OnDraw`. In order
    to distinguish the two cases, the `OnDraw` parameter has the value `Paint` or
    `Print`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPaint`和`OnPrint`的默认定义都调用`OnDraw`。为了区分这两种情况，`OnDraw`参数的值为`Paint`或`Print`：'
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first `Window` constructor is public and intended to be used when a window
    is created directly. The `pageSize` field refers to the size of the window client
    area. The constructor also takes a pointer to the window's parent window (which
    is `null` if there is no parent window), the window's basic style and extended
    style, and its initial appearance, position, and size. If the position or size
    is zero, the window is located or dimensioned in accordance with the system's
    default settings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Window`构造函数是公开的，用于直接创建窗口时使用。`pageSize`字段指的是窗口客户端区域的大小。构造函数还接受指向窗口父窗口的指针（如果没有父窗口则为`null`），窗口的基本样式和扩展样式，以及其初始外观、位置和大小。如果位置或大小为零，窗口将根据系统的默认设置定位或调整尺寸。
- en: 'Note the difference between the document and windows sizes in `PreviewCoordinate`:
    the document size is the size of the client area in units defined by the window''s
    coordinate system, while the size and position of the window are given in the
    coordinate system of the parent window or in device units if there is no parent
    window. Moreover, the document size refers to the size of the client area while
    the window size refers to the size of the whole window:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`PreviewCoordinate`中文档和窗口大小之间的区别：文档大小是窗口坐标系定义的单位中的客户端区域大小，而窗口的大小和位置是在父窗口的坐标系中给出，如果没有父窗口，则使用设备单位。此外，文档大小指的是客户端区域的大小，而窗口大小指的是整个窗口的大小：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second constructor is protected and intended to be called by subclasses''
    constructors. The difference when compared to the first constructor is that is
    takes the name of the `window` class as its first parameter. As defined by the
    `Application` class, the class name can be `Window`, `Document`, `StandardDocument`,
    or `Dialog`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数是受保护的，用于由子类的构造函数调用。与第一个构造函数相比，它的区别在于它将`window`类的名称作为其第一个参数。根据`Application`类的定义，类名可以是`Window`、`Document`、`StandardDocument`或`Dialog`：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A **device context** is used when painting the client area, when transforming
    between logical and device units, and when calculating the size of text. It is
    a connection to the client area of a window or to a printer. However, since it
    comes with a set of functions for drawing text of graphical objects, it can also
    be considered as a toolbox for drawing. However, before it is used, it needs to
    be prepared and adjusted in accordance with the current coordinate system:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制客户端区域、在逻辑单位和设备单位之间转换以及计算文本大小时使用**设备上下文**。它是连接到窗口的客户端区域或打印机的连接。然而，由于它附带了一套用于绘制图形对象文本的函数，它也可以被视为一个绘图工具箱。但是，在使用之前，它需要根据当前坐标系进行准备和调整：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The destructor destroys the window and exits the application if the window
    is the application''s main window:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数会销毁窗口并退出应用程序，如果窗口是应用程序的主窗口：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The window can be visible or invisible; it can also be enabled in such a way
    that it catches mouse, touch, and keyboard inputs:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口可以是可见的或不可见的；它也可以被启用，以便捕获鼠标、触摸和键盘输入：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `OnSize` and `OnMove` methods are called when the user changes the size
    of the window or moves it. The size and position are given in logical coordinates.
    The `OnHelp` method is called when the user presses the *F1* key of the *Help*
    button in a message box. The methods are intended to be overridden by subclasses,
    and their default behavior is to do nothing:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改窗口大小或移动窗口时，会调用`OnSize`和`OnMove`方法。大小和位置以逻辑坐标给出。当用户在消息框中按下*帮助*按钮的*F1*键时，会调用`OnHelp`方法。这些方法旨在被子类覆盖，并且它们的默认行为是不做任何事情：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `WindowHandle` method returns the Win32 API window handle, which is used
    by standard dialog functions. The `ParentWindowPtr` method returns the pointer
    to the parent window, which is `null`, meaning that there is no parent window.
    The `SetHeader` method sets the title of the window, which is visible in the upper
    border:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowHandle`方法返回Win32 API窗口句柄，它被标准对话框函数使用。`ParentWindowPtr`方法返回父窗口的指针，它是`null`，表示没有父窗口。`SetHeader`方法设置窗口的标题，该标题在窗口的上边框中可见：'
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The client area of the window is zoomed in accordance with the zoom factor;
    1.0 corresponds to the normal size:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的客户端区域根据缩放因子进行缩放；1.0对应于正常大小：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Several timers can be set or dropped as long as the values of the `timerId`
    parameter differ. The `OnTimer` method is called in accordance with the intervals
    in milliseconds; its default behavior is to do nothing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`timerId`参数的值不同，就可以设置或删除多个计时器。`OnTimer`方法根据毫秒间隔被调用；它的默认行为是不做任何事情。
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `SetFocus` method sets the input focus to this window. The input focus directs
    the keyboard input and clipboard to the window. However, the mouse pointer may
    be aiming at another window. The window previously holding the input focus loses
    the focus; only one window can hold the focus at a given time. The `HasFocus`
    method returns `true` if the window has input focus.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetFocus`方法将输入焦点设置到这个窗口。输入焦点将键盘输入和剪贴板指向窗口。然而，鼠标指针可能指向另一个窗口。之前拥有输入焦点的窗口会失去焦点；在给定时间内只能有一个窗口拥有焦点。`HasFocus`方法返回`true`，如果窗口有输入焦点。'
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `OnGainFocus` and `OnLoseFocus` methods are called when the window gains
    or loses input focus. They are intended to be overridden by subclasses, and their
    default behavior is to do nothing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口获得或失去输入焦点时，会调用`OnGainFocus`和`OnLoseFocus`方法。它们旨在被子类覆盖，并且它们的默认行为是不做任何事情。
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In Windows, a mouse is regarded as holding three buttons, even if it does not
    do so physically. The mouse buttons can be pressed or released and the mouse can
    be moved. The `OnMouseDown`, `OnMouseUp`, and `OnMouseMove` methods are called
    when the user presses or releases one of the mouse buttons or moves the mouse
    with at least one button pressed. The user may press the ***Shift*** or ***Ctrl***
    key at the same time, in which case `shiftPressed` or `controlPressed` is `true`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，鼠标被视为有三个按钮，即使它实际上没有这样做。可以按下或释放鼠标按钮，并且可以移动鼠标。当用户按下或释放鼠标按钮或至少按下一个按钮移动鼠标时，会调用`OnMouseDown`、`OnMouseUp`和`OnMouseMove`方法。用户可以同时按下***Shift***或***Ctrl***键，在这种情况下`shiftPressed`或`controlPressed`为`true`：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The user can also double-click a mouse button, in which case `OnDoubleClick`
    is called. What constitutes a double-click is decided by the Windows system and
    can be set in the Control Panel. When the user single-clicks a button, `OnMouseDown`
    is called, followed by `OnMouseMove` in the case of potential mouse movements,
    and finally `OnMouseUp`. However, in the case of a double-click, `OnMouseDown`
    is not called, its call is replaced by `OnDoubleClick`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以双击鼠标按钮，在这种情况下会调用`OnDoubleClick`。双击的定义由Windows系统决定，可以在控制面板中设置。当用户单击按钮时，会调用`OnMouseDown`，如果可能发生鼠标移动，则随后调用`OnMouseMove`，最后调用`OnMouseUp`。然而，在双击的情况下，不会调用`OnMouseDown`，其调用被`OnDoubleClick`所取代：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `OnMouseWheel` method is called when the user rolls the mouse wheel one
    step upwards or downwards:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向上或向下滚动鼠标滚轮一步时，会调用`OnMouseWheel`方法。
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `OnTouchDown`, `OnTouchMove`, and `OnTouchUp` methods are called when the
    user touches the screen. Unlike mouse clicks, the user can touch the screen at
    several locations at the same time. Therefore, the parameter is a list of points
    rather than a single point. The methods are intended to be overridden by subclasses.
    Their default behavior is to simulate a mouse click for each touch point with
    no button and with neither the ***Shift*** nor the ***Ctrl*** key pressed:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `OnKeyDown` and `OnKeyUp` methods are called when the user presses and
    releases a key. If the key is a graphical character (with ASCII number between
    32 and 127, inclusive), `OnChar` is called in between. The `OnKeyDown` and `OnKeyUp`
    methods return `bool`; the idea is that the methods return `true` if the key was
    used. If not, they return `false` and the caller method is free to use the key
    to, for instance, control scroll movements:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `OnPaint` method is called when the client area of the window needs to
    be redrawn, partly or completely, and `OnPrint` is called when the user selects
    the **Print** menu item. In both cases, the default definition calls `OnDraw`,
    which performs the actual drawing; `drawMode` is `Paint` when called by `OnPaint`
    and `Print` when called by `OnPrint`. The idea is that we let `OnPaint` and `OnPrint`
    perform actions specific to painting and printing and call `OnDraw` for the common
    drawing. The `Graphics` class is described in the next section:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `Invalidate` method invalidates the client area, partly or completely;
    that is, it prepares the area to be redrawn by `OnPaint` or `OnDraw`. If `clear`
    is `true`, the area is first cleared (painted by the window client color). The
    `UpdateWindow` method forces a repainting of the invalidated parts of the client
    area:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `OnClose` method is called when the user tries to close the window; its
    default behavior is to call `TryClose`. If `TryClose` returns `true` (which it
    does in its default definition), the window is closed. If that happens, `OnDestroy`
    is called, whose default behavior is to do nothing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following method transforms a `Point`, `Rectangle`, or `Size` object between
    device units and logical units. They are protected since they are intended to
    be called by subclasses only:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following method gets or sets the size and position of the window and the
    client area in device units:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following method gets or sets the logical size and position of the window
    and the client area, in logical units, in accordance with the coordinate system
    of the window:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `CreateTextMetric` method initializes and returns a Win32 API `TEXTMETRIC`
    structure, which is then used by the text metric methods in order to calculate
    the logical size of text. It is private since it in intended to be called only
    by the `Window` methods:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following method calculates and returns the width, height, ascent, or average
    width of a character or text with the given font, in logical units:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `MessageBox` method displays a message box with a message, caption, a set
    of buttons, an icon, and on optional **Help** button:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox` 方法显示一个包含消息、标题、一组按钮、图标以及可选的 **帮助** 按钮的消息框：'
- en: '[PRE67]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `pageSize` field holds the window client''s logical size in the `PreviewCoordinate`
    coordinate system, which is used when transforming coordinates between logical
    and device coordinates. In the `LogicalWithScroll` and `LogicalWithoutScroll`
    coordinate systems, `pageSize` holds the logical size of the document, which does
    not necessarily equal the logical size of the client area, and is not changed
    when the window is resized. It is protected since it is also used by the `Document`
    and `StandardDocument` subclasses in the next chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`pageSize` 字段存储窗口客户端在 `PreviewCoordinate` 坐标系中的逻辑大小，该坐标系用于在逻辑坐标和设备坐标之间转换坐标。在
    `LogicalWithScroll` 和 `LogicalWithoutScroll` 坐标系中，`pageSize` 存储文档的逻辑大小，这不一定等于客户端区域的大小，且在窗口大小调整时不会改变。它是受保护的，因为它在下一章的
    `Document` 和 `StandardDocument` 子类中也被使用：'
- en: '[PRE68]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the previous section, there was a handle to the application instance. `windowHandle`
    is a handle of type `HWND` to a Win32 API window; `parentPtr` is a pointer to
    the parent window, which is `null` if there is no parent window:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，有一个应用程序实例的句柄。`windowHandle` 是一个类型为 `HWND` 的 Win32 API 窗口句柄；`parentPtr`
    是父窗口的指针，如果没有父窗口，则为 `null`：
- en: '[PRE69]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The coordinate system chosen for the window is stored in `system`. The `zoom`
    field holds the zooming factor of the window, where 1.0 is the default:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口选择的坐标系存储在 `system` 中。`zoom` 字段存储窗口的缩放因子，其中 1.0 是默认值：
- en: '[PRE70]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `WindowProc` method is called each time the window receives a message.
    It is a friend of `Window`, since it needs access to its private members:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每次窗口接收消息时都会调用 `WindowProc` 方法。它是 `Window` 的朋友，因为它需要访问其私有成员：
- en: '[PRE71]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, `WindowMap` maps the `HWND` handles to the `Window` pointers, which
    are used in `WindowProc` as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WindowMap` 将 `HWND` 句柄映射到 `Window` 指针，这些指针在 `WindowProc` 中如下使用：
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Window.cpp**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Window.cpp**'
- en: '[PRE73]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Initialization
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The first constructor simply calls the second constructor with the class name
    `window`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数只是用类名 `window` 调用第二个构造函数：
- en: '[PRE74]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The second constructor initializes the `parentPtr`, `system`, and `pageSize`
    fields:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数初始化 `parentPtr`、`system` 和 `pageSize` 字段：
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If the window is a child window (the parent pointer is not `null`), its coordinates
    are converted to the coordinate system of its parent window:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口是子窗口（父指针不是 `null`），则将其坐标转换为父窗口的坐标系：
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The Win32 API window creation process is divided into two steps. First, a Windows
    class needs to be registered, which was done in the `Application` constructor
    earlier. Then, the `Windows` class name is used in the call to the Win32 API `CreateWindowEx`
    function, which returns a handle to the window. If the size or position is zero,
    default values are used:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 窗口创建过程分为两个步骤。首先，需要注册一个 Windows 类，这已经在之前的 `Application` 构造函数中完成。然后，使用
    `Windows` 类名调用 Win32 API 的 `CreateWindowEx` 函数，该函数返回窗口的句柄。如果大小或位置为零，则使用默认值：
- en: '[PRE77]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In order for `WindowProc` to be able to receive messages and identify the recipient
    window, the handle is stored in `WindowMap`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `WindowProc` 能够接收消息并识别接收窗口，句柄被存储在 `WindowMap` 中：
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The Win32 API functions `ShowWindow` and `RegisterTouchWindow` are called to
    make the window visible in accordance with the `windowShow` parameter and to make
    the window receptive to touch movements:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 Win32 API 函数 `ShowWindow` 和 `RegisterTouchWindow` 以根据 `windowShow` 参数使窗口可见，并使窗口能够响应触摸移动：
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The destructor calls `OnDestroy` and erases the window from `windowMap`. If
    the window has a parent window, it receives an input focus:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数调用 `OnDestroy` 并从 `windowMap` 中删除窗口。如果窗口有父窗口，它将接收输入焦点：
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the window is the application''s main window, the Win32 API `PostQuitMessage`
    function is called. It posts a quit message, which is eventually caught by `RunMessageLoop`
    in the `Application` class that terminates the execution. Finally, the window
    is destroyed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口是应用程序的主窗口，则调用 Win32 API 的 `PostQuitMessage` 函数。它发布一个退出消息，该消息最终由 `Application`
    类中的 `RunMessageLoop` 捕获，从而终止执行。最后，销毁窗口：
- en: '[PRE81]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Header and visibility
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题和可见性
- en: 'The `ShowWindow` and `EnableWindow` methods call the Win32 API functions `ShowWindow`
    and `EnableWindow` with the window handle as their first parameter:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowWindow` 和 `EnableWindow` 方法使用窗口句柄作为第一个参数调用 Win32 API 的 `ShowWindow` 和
    `EnableWindow` 函数：'
- en: '[PRE82]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Note that the second parameter of `EnableWindow` is a value of the Win32 API
    type `BOOL`, which is not necessarily the same type as the C++ type `bool`. Therefore,
    since `enable` holds the type `bool` we need to convert it to `BOOL`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`EnableWindow` 的第二个参数是 Win32 API 类型 `BOOL` 的值，这不一定与 C++ 类型 `bool` 相同。因此，由于
    `enable` 持有类型 `bool`，我们需要将其转换为 `BOOL`：
- en: '[PRE83]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `SetHeader` method sets the title of the window by calling the Win32 API
    function `SetWindowText`. As `headerText` is a `String` object and `SetWindowText`
    wants a C string (a zero-terminated char pointer) as parameter, we need to call
    the `c_str` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetHeader` 方法通过调用 Win32 API 函数 `SetWindowText` 来设置窗口的标题。由于 `headerText` 是一个
    `String` 对象，而 `SetWindowText` 需要一个 C 字符串（一个以零终止的字符指针）作为参数，因此我们需要调用 `c_str` 函数：'
- en: '[PRE84]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `SetTimer` and `DropTimer` methods turn the timer with the given identity
    on and off by calling the Win32 API functions `SetTimer` and `KillTimer`. The
    interval in the `SetTimer` call is given in milliseconds:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetTimer` 和 `DropTimer` 方法通过调用 Win32 API 函数 `SetTimer` 和 `KillTimer` 来开启和关闭具有给定标识符的计时器。`SetTimer`
    调用中的间隔以毫秒为单位给出：'
- en: '[PRE85]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `SetFocus` method sets the focus by calling the corresponding Win32 API
    function `SetFocus`. The `HasFocus` method returns `true` if the window has the
    input focus by calling the `GetFocus` Win32 API function, which returns the handle
    to the window, holding the input focus that is compared to the window''s handle:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetFocus` 方法通过调用相应的 Win32 API 函数 `SetFocus` 来设置焦点。`HasFocus` 方法通过调用 `GetFocus`
    Win32 API 函数返回 `true`，如果窗口通过该函数获得了输入焦点，该函数返回窗口句柄，与窗口句柄进行比较：'
- en: '[PRE86]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The touch screen
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸屏
- en: 'The default behavior of `OnTouchDown`, `OnTouchMove`, and `OnTouchUp` is to
    call the corresponding mouse input method for each touch point, with no button
    and neither the ***Shift*** nor the ***Ctrl*** key pressed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTouchDown`、`OnTouchMove` 和 `OnTouchUp` 的默认行为是调用每个触摸点的相应鼠标输入方法，没有按钮按下，也没有
    ***Shift*** 或 ***Ctrl*** 键被按下：'
- en: '[PRE87]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'With a modern screen, the user can touch the screen in ways similar to mouse
    clicks. However, the user can touch the screen at several locations at once, and
    its positions are stored in a point list. The `OnTouch` method is an auxiliary
    method calling `OnTouchDown`, `OnTouchMove`, and `OnTouchUp` when the user touches
    the screen. It creates a list of points in logical coordinates:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代屏幕上，用户可以以类似于鼠标点击的方式触摸屏幕。然而，用户可以同时触摸屏幕的几个位置，并且其位置存储在一个点列表中。`OnTouch` 方法是一个辅助方法，当用户触摸屏幕时调用
    `OnTouchDown`、`OnTouchMove` 和 `OnTouchUp`。它创建一个逻辑坐标中的点列表：
- en: '[PRE88]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the touch identity does not equal the first value in the input array, we
    have a touch down event; if it does, we have a touch move event:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触摸标识符不等于输入数组中的第一个值，我们有一个触摸下事件；如果它相等，我们有一个触摸移动事件：
- en: '[PRE89]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Invalidation and window updates
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无效化和窗口更新
- en: 'When the window''s client area needs to be (partly or completely) repainted,
    one of the `Invalidate` methods is called. The `Invalidate` methods call the Win32
    API function `InvalicateRect`, which posts a message that results in a call to
    `OnPaint` when `UpdateWindow` is called. The `clear` parameter indicates whether
    the invalidated area should be cleared (repainted with the window client area''s
    color) before it is redrawn, which normally is the case. Similar to the `EnableWindow`
    method we saw earlier, we need to convert `clear` from type `bool` to `BOOL`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口的客户区域需要（部分或全部）重绘时，会调用 `Invalidate` 方法之一。`Invalidate` 方法调用 Win32 API 函数 `InvalicateRect`，该函数在调用
    `UpdateWindow` 时发送一个消息，导致调用 `OnPaint`。`clear` 参数指示在重绘之前是否应该清除（用窗口客户区域的颜色重绘）无效区域，这通常是情况。类似于我们之前看到的
    `EnableWindow` 方法，我们需要将 `clear` 从类型 `bool` 转换为 `BOOL`：
- en: '[PRE90]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `Invalidate` method transforms the area from logical to device coordinates
    before the call to the Win32 API function `InvalidateRect` and stores the size
    in a `RECT` structure:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invalidate` 方法在调用 Win32 API 函数 `InvalidateRect` 之前将区域从逻辑坐标转换为设备坐标，并将大小存储在
    `RECT` 结构中：'
- en: '[PRE91]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `UpdateWindow` method calls the Win32 API function `UpdateWindow`, which
    eventually results in a call to `OnPaint`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateWindow` 方法调用 Win32 API 函数 `UpdateWindow`，这最终导致调用 `OnPaint`：'
- en: '[PRE92]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Preparing the device context
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备设备上下文
- en: When painting the windows's client area, we need a device context, which we
    need to prepare in accordance with the coordinate system in order to paint with
    logical coordinates. The Win32 API function `SetMapMode` sets the mapping mode
    of the logical coordinate system. `MISOTROPIC` forces that the *x* and *y* axis
    to have the same unit length (resulting in non-elliptic circles) that is suitable
    for the `LogicalWithScroll` and `LogicalWithoutScroll` systems, while `MANISOTROPIC`
    allows different unit lengths that are suitable for the `PreviewCoordinate` system.
    We establish a mapping between the logical and device systems by calling the Win32
    API functions `SetWindowExtEx`, which takes the logical size of the client area,
    and `SetViewportExtEx`, which takes its physical (device) size.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制窗口的客户端区域时，我们需要一个设备上下文，我们需要根据坐标系来准备它，以便使用逻辑坐标进行绘制。Win32 API 函数 `SetMapMode`
    设置逻辑坐标系统的映射模式。`MISOTROPIC` 强制 *x* 和 *y* 轴具有相同的单位长度（导致非椭圆形的圆），这对于 `LogicalWithScroll`
    和 `LogicalWithoutScroll` 系统是合适的，而 `MANISOTROPIC` 允许不同的单位长度，这对于 `PreviewCoordinate`
    系统是合适的。我们通过调用 `SetWindowExtEx` 函数建立逻辑和设备系统之间的映射，它接受客户端区域的逻辑大小，以及调用 `SetViewportExtEx`
    函数，它接受其物理（设备）大小。
- en: 'In the case of the `PreviewCoordinate` system, we simply match the logical
    size (`pageSize`) of the client area to its device size (`clientDeviceRect`),
    given by the Win32 API function `GetClientRect`, resulting in the client area
    always having the same logical size, regardless of its physical size:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PreviewCoordinate` 坐标系的情况下，我们只需将客户端区域（`pageSize`）的逻辑大小与由 Win32 API 函数 `GetClientRect`
    给出的设备大小（`clientDeviceRect`）相匹配，从而使得客户端区域始终具有相同的逻辑大小，无论其实际大小如何：
- en: '[PRE93]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the case of the logical coordinate system, we need to find the ratio between
    logical coordinates (hundreds of millimeters) and device coordinates (pixels).
    In other words, we need to establish the logical size of a pixel. We can find
    the number of pixels on the screen by calling the Win32 API function `GetDeviceCaps`
    with `HORZSIZE` and `VERTSIZE`, and the size of the screen in millimeters with
    `HORZRES` and `VERTRES`. We multiply the logical size by 100, since we have hundreds
    of millimeters as our logical unit. We also need to take into account the zooming
    factor of the window, which we do by multiplying the physical size by `zoom`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑坐标系的情况下，我们需要找到逻辑坐标（数百毫米）和设备坐标（像素）之间的比率。换句话说，我们需要确定像素的逻辑大小。我们可以通过调用带有 `HORZSIZE`
    和 `VERTSIZE` 的 Win32 API 函数 `GetDeviceCaps` 来找到屏幕上的像素数，以及使用 `HORZRES` 和 `VERTRES`
    的毫米级屏幕大小。由于我们的逻辑单位是数百毫米，我们需要将逻辑大小乘以 100。我们还需要考虑窗口的缩放因子，这通过将物理大小乘以 `zoom` 来实现。
- en: 'Note that it''s only in the `PreviewCoordinate` system that the client area
    always has the same logical size. In the other systems, the logical size changes
    when the size of the window is changed. The logical units are always the same
    in `LogicalWithScroll` and `LogicalWithoutScroll`: hundreds of millimeters:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有在 `PreviewCoordinate` 系统中，客户端区域始终具有相同的逻辑大小。在其他系统中，当窗口大小改变时，逻辑大小也会改变。在 `LogicalWithScroll`
    和 `LogicalWithoutScroll` 中，逻辑单位始终相同：数百毫米：
- en: '[PRE94]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the case of the `LogicalWithScroll` logical coordinate system, we also need
    to adjust the origin of the window in accordance with the current scroll settings
    by calling the Win32 API function `SetWindowOrg`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LogicalWithScroll` 逻辑坐标系的情况下，我们还需要通过调用 Win32 API 函数 `SetWindowOrg` 来根据当前的滚动设置调整窗口的原点：
- en: '[PRE95]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Unit transformation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位转换
- en: 'The `DeviceToLogical` method transforms the device coordinates of a point,
    rectangle, or size to logical coordinates by preparing the device context and
    then calling the Win32 API function `DPtoLP` (Device Point to Logical Point).
    Note that we establish the device context by calling the Win32 API function `GetDC`
    and we need to return it by calling `ReleaseDC`. Also, note that we need to convert
    the `Point` object to a `POINT` structure and back again, since `DPtoLP` takes
    a pointer to a `POINT`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeviceToLogical` 方法通过准备设备上下文并调用 Win32 API 函数 `DPtoLP`（设备点到逻辑点）将一个点、矩形或大小的设备坐标转换为逻辑坐标。请注意，我们通过调用
    Win32 API 函数 `GetDC` 来建立设备上下文，并且需要通过调用 `ReleaseDC` 来返回它。另外，请注意，我们需要将 `Point` 对象转换为
    `POINT` 结构，然后再转换回来，因为 `DPtoLP` 接受一个指向 `POINT` 的指针：'
- en: '[PRE96]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When transforming a rectangle, we use the point method to transform its top-left
    and bottom-right corners. When transforming a size, we create a rectangle, call
    the rectangle method, and convert the rectangle to a size:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换矩形时，我们使用点方法转换其左上角和右下角。在转换大小时，我们创建一个矩形，调用矩形方法，然后将矩形转换为大小：
- en: '[PRE97]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `LogicalToDevice` method transforms the point, rectangle, or size from
    logical to device coordinates calling the Win32 API function `LPtoDP` (Logical
    Point to Device Point) in the same manner as the earlier methods. The only difference
    is that they call `LPtoDP` instead of `DPtoLP`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogicalToDevice` 方法将点、矩形或大小从逻辑坐标转换为设备坐标，调用 Win32 API 函数 `LPtoDP`（逻辑点到设备点）的方式与早期方法相同。唯一的区别是它们调用
    `LPtoDP` 而不是 `DPtoLP`：'
- en: '[PRE98]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Window size and position
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口大小和位置
- en: 'The `GetWindowDevicePosition`, `SetWindowDevicePosition`, `GetWindowDeviceSize`,
    `SetWindowDeviceSize`, and `GetClientDeviceSize` methods call the corresponding
    Win32 API functions `GetWindowRect`, `GetClientRect`, and `SetWindowPos`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWindowDevicePosition`、`SetWindowDevicePosition`、`GetWindowDeviceSize`、`SetWindowDeviceSize`
    和 `GetClientDeviceSize` 方法调用相应的 Win32 API 函数 `GetWindowRect`、`GetClientRect` 和
    `SetWindowPos`：'
- en: '[PRE99]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `GetWindowPosition`, `SetWindowPosition`, `GetWindowSize`, `SetWindowSize`,
    and `GetClientSize` methods call the corresponding device methods together with
    `LogicalToDevice` or `DeviceToLogical`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWindowPosition`、`SetWindowPosition`、`GetWindowSize`、`SetWindowSize` 和 `GetClientSize`
    方法与 `LogicalToDevice` 或 `DeviceToLogical` 一起调用相应的设备方法：'
- en: '[PRE100]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Text metrics
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本度量
- en: 'Given a font, `CreateTextMetric` creates a metric structure holding the height,
    ascent line, and average width of a character of the font. The `CreateFontIndirect`
    and `SelectObject` methods prepare the font for `GetTextExtentPoint`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字体，`CreateTextMetric` 创建一个包含字体字符的高度、基线上升线和平均宽度的度量结构。`CreateFontIndirect`
    和 `SelectObject` 方法为 `GetTextExtentPoint` 准备字体：
- en: '[PRE101]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Note that `CreateFontIndirect` must be matched by `DeleteObject` and the first
    call to `SelectObject` must be matched by a second call to `SelectObject` to reinstall
    the original object:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CreateFontIndirect` 必须与 `DeleteObject` 匹配，并且第一个 `SelectObject` 调用必须与第二个
    `SelectObject` 调用匹配以重新安装原始对象：
- en: '[PRE102]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Also, note that the device context received from `GetDC` must be released with
    `ReleaseDC`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，从 `GetDC` 收到的设备上下文必须使用 `ReleaseDC` 释放：
- en: '[PRE103]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `GetCharacterHeight`, `GetCharacterAscent`, and `GetCharacterAverageWidth`
    methods call `CreateTextMetric` and return the relevant information:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCharacterHeight`、`GetCharacterAscent` 和 `GetCharacterAverageWidth` 方法调用
    `CreateTextMetric` 并返回相关信息：'
- en: '[PRE104]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `GetCharacterWidth` method calls `GetTextExtentPoint` to establish the
    width of a character of the given font. Since the font height is given in typographical
    points (1 point = 1/72 of an inch = 1/72 * 25.4 mm ≈≈ 0.35 mm) and needs to be
    given in millimeters, we call `PointsToLogical`. Similar to what we did earlier
    in `CreateTextMetric`, `CreateFontIndirect` and `SelectObject` prepare the font
    for `GetTextExtentPoint`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCharacterWidth` 方法调用 `GetTextExtentPoint` 以确定给定字体的字符宽度。由于字体高度是以排版点（1 点
    = 1/72 英寸 = 1/72 * 25.4 毫米 ≈≈ 0.35 毫米）给出的，并且需要以毫米为单位给出，我们调用 `PointsToLogical`。类似于我们在
    `CreateTextMetric`、`CreateFontIndirect` 和 `SelectObject` 中所做的，`CreateFontIndirect`
    和 `SelectObject` 方法为 `GetTextExtentPoint` 准备字体：'
- en: '[PRE105]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Closing the window
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭窗口
- en: 'When the user tries to close the window, the `Window` object (`this`) is deleted
    if `TryClose` returns `true`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试关闭窗口时，如果 `TryClose` 返回 `true`，则删除 `Window` 对象（`this`）：
- en: '[PRE106]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The MessageBox method
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MessageBox` 方法'
- en: 'The `MessageBox` method displays a message box holding a caption, a message,
    a combination of buttons (**OK**, **OK-Cancel**, **Retry-Cancel**, **Yes-No**,
    **Yes-No-Cancel**, **Cancel-Try-Continue**, or **Abort-Retry-Ignore**), an optional
    icon (**Information**, **Stop**, **Warning**, or **Question**), and an optional
    H**elp** button. It returns the answer **OK Answer** (since OK is already taken
    by the `ButtonGroup` enumeration), **Cancel**, **Yes**, **No**, **Retry**, **Continue**,
    **Abort**, or **Ignore**:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox` 方法显示一个包含标题、消息、按钮组合（**确定**、**确定-取消**、**重试-取消**、**是-否**、**是-否-取消**、**取消-重试-继续**或**中止-重试-忽略**）、可选图标（**信息**、**停止**、**警告**或**问题**）和可选的
    **帮助** 按钮的消息框。它返回 **确定答案**（因为 **确定** 已经被 `ButtonGroup` 枚举占用）、**取消**、**是**、**否**、**重试**、**继续**、**中止**
    或 **忽略**：'
- en: '[PRE107]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: When a window is created by calling `CreateWindowEx` in the `Window` class constructor,
    the name of a `Windows` class that has earlier been given by the `Application`
    class constructor is enclosed. When the class is registered, a freestanding function
    is also given. For the `Window` class, the function is `WindowProc`, which is
    thereby called every time the window receives a message.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 `Window` 类构造函数中的 `CreateWindowEx` 调用创建窗口时，由 `Application` 类构造函数先前给出的 `Windows`
    类的名称被包含在内。当类被注册时，还会提供一个独立的函数。对于 `Window` 类，该函数是 `WindowProc`，因此每当窗口收到消息时都会调用它：
- en: 'The `wordParam` and `longParam` parameters (`WPARAM` and `LPARAM` are both
    4 bytes) hold message-specific information, which may be divided into low and
    high words (2 bytes) with the `LOWORD` and `HIWORD` macros:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordParam` 和 `longParam` 参数（`WPARAM` 和 `LPARAM` 都是 4 字节）包含消息特定的信息，这些信息可能被分为低字和高字（2
    字节），使用 `LOWORD` 和 `HIWORD` 宏来区分：'
- en: '[PRE108]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'First we need to find the `Window` object associated with the window handle
    by looking up the handle in the static field `WindowMap`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过在静态字段 `WindowMap` 中查找句柄来找到与窗口句柄关联的 `Window` 对象：
- en: '[PRE109]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When receiving the `WSETFOCUS`, `WKILLFOCUS`, and `WTIMER` messages, the corresponding
    methods in `Window` are simply called. When the messages have been handled, they
    do not need to be further processed; therefore, zero is returned:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `WSETFOCUS`、`WKILLFOCUS` 和 `WTIMER` 消息时，`Window` 中的相应方法被简单地调用。当消息被处理完毕后，它们不需要进一步处理；因此，返回零：
- en: '[PRE110]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The identity of the timer (the `timerId` parameter in `SetTimer` and `DropTimer`)
    is stored in `wordParam`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的身份（`SetTimer` 和 `DropTimer` 中的 `timerId` 参数）存储在 `wordParam` 中：
- en: '[PRE111]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'When receiving the `WMOVE` and `WSIZE` messages, the `Point` value stored in
    `longParam` is given in device units that need to be transformed into logical
    units by calling `DeviceToLogical` in the calls to `OnMove` and `OnSize` in `Window`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `WMOVE` 和 `WSIZE` 消息时，存储在 `longParam` 中的 `Point` 值是以设备单位给出的，需要通过在 `Window`
    中的 `OnMove` 和 `OnSize` 调用中调用 `DeviceToLogical` 来转换为逻辑单位：
- en: '[PRE112]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If the user presses the ***F1*** key or the **Help** button in a message box,
    the `WM_HELP` message is sent. We call `OnHelp` in `Window`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在消息框中按下 ***F1*** 键或 **帮助** 按钮，则发送 `WM_HELP` 消息。我们在 `Window` 中调用 `OnHelp`：
- en: '[PRE113]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When handling mouse or keyboard input messages, it is useful to decide whether
    the user simultaneously presses the ***Shift*** or ***Ctrl*** key. This can be
    established by calling the Win32 API function, `GetKeyState`, which returns an
    integer value less than zero if the key is pressed when called with `VK_SHIFT`
    or `VK_CONTROL`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理鼠标或键盘输入消息时，决定用户是否同时按下 ***Shift*** 或 ***Ctrl*** 键是有用的。这可以通过调用 Win32 API 函数
    `GetKeyState` 来实现，如果使用 `VK_SHIFT` 或 `VK_CONTROL` 调用，则当键被按下时，它返回一个小于零的整数值：
- en: '[PRE114]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If `OnKeyDown` returns `true`, the key message has been processed and we return
    zero. If it returns `false`, the Win32 API function `DefWindowProc`, as shown
    here, will be called, which further processes the message:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `OnKeyDown` 返回 `true`，则表示键消息已被处理，我们返回零。如果它返回 `false`，则将调用如这里所示的 Win32 API
    函数 `DefWindowProc`，该函数将进一步处理消息：
- en: '[PRE115]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If the pressed key is a graphical character (ASCII numbers between 32 and 127,
    inclusive), `OnChar` is called:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是一个图形字符（ASCII 码在 32 到 127 之间，包括 127），则调用 `OnChar`：
- en: '[PRE116]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'All mouse input points stored in `longParam` are given in device coordinates,
    which need to be transformed into logical coordinates by `DeviceToLogical`. The
    mouse-down message is normally followed by the corresponding mouse-up message.
    Unfortunately, that is not the case if the user presses the mouse button in one
    window and releases it in another window, in which case the mouse-up message is
    sent to the other window. However, the problem can be solved by the Win32 API
    function, `SetCapture`, which makes sure that every mouse message is sent to the
    window until `ReleaseCapture` is called:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储在 `longParam` 中的鼠标输入点都是以设备坐标给出的，需要通过 `DeviceToLogical` 转换为逻辑坐标。鼠标按下消息通常随后是相应的鼠标抬起消息。不幸的是，如果用户在一个窗口中按下鼠标按钮并在另一个窗口中释放它，那么鼠标抬起消息将被发送到另一个窗口。然而，可以通过
    Win32 API 函数 `SetCapture` 解决这个问题，该函数确保在调用 `ReleaseCapture` 之前将每个鼠标消息发送到窗口：
- en: '[PRE117]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'When the user moves the mouse, they may at the same time press a combination
    of buttons, stored in `buttonMask`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动鼠标时，他们可能同时按下按钮组合，这些按钮存储在 `buttonMask` 中：
- en: '[PRE118]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Note that `ReleaseCapture` is called at the end of the mouse-up methods in
    order to release the mouse message from the window and make it possible for mouse
    messages to be sent to other windows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ReleaseCapture`是在鼠标抬起方法结束时被调用的，目的是释放窗口的鼠标消息，并使鼠标消息能够发送到其他窗口：
- en: '[PRE119]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'When a touch message is sent, `OnTouch` is called, which needs the position
    of the window in device units:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送触摸消息时，会调用`OnTouch`，这需要窗口在设备单位中的位置：
- en: '[PRE120]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'When creating a device context in response to a paint message, we use the Win32
    API functions `BeginPaint` and `EndPaint` instead of `GetDC` and `ReleaseDC` to
    handle the device context. However, the device context still needs to be prepared
    for the window''s coordinate system, which is accomplished by `PrepareDeviceContext`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应绘图消息创建设备上下文时，我们使用Win32 API 函数`BeginPaint`和`EndPaint`而不是`GetDC`和`ReleaseDC`来处理设备上下文。然而，设备上下文仍然需要为窗口的坐标系统做好准备，这是通过`PrepareDeviceContext`完成的：
- en: '[PRE121]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'When the user tries to close the window by clicking on the close box in the
    top-right corner, `OnClose` is called. It calls `TryClose` and closes the window
    if `TryClose` returns true:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试通过点击右上角的关闭框来关闭窗口时，会调用`OnClose`。它调用`TryClose`，如果`TryClose`返回true，则关闭窗口：
- en: '[PRE122]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If we reach this point, the Win32 API function `DefWindowProc` is called, which
    performs the default message handling:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们达到这一点，Win32 API 函数`DefWindowProc`会被调用，它执行默认的消息处理：
- en: '[PRE123]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The Graphics class
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Graphics`类'
- en: The `Graphics` class is a wrapper class for a device context. It also provides
    functionality for drawing lines, rectangles, and ellipses; writing text; saving
    and restoring graphic states; setting the origin of the device context; and clipping
    the painting area. The constructor is private since `Graphics` objects are intended
    to be created internally by Small Windows only.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphics`类是一个设备上下文的包装类。它还提供了绘制线条、矩形和椭圆；写入文本；保存和恢复图形状态；设置设备上下文的起点；以及裁剪绘图区域的功能。构造函数是私有的，因为`Graphics`对象旨在仅由小窗口内部创建。'
- en: '**Graphics.h**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**Graphics.h**'
- en: '[PRE124]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When drawing a line, it can be solid, dashed, dotted, dashed and dotted, as
    well as dashed and double-dotted:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制线条时，可以是实线、虚线、点线、点划线，以及点划双线：
- en: '[PRE125]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `Save` method saves the current state of the `Graphics` object and `Restore`
    restores it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Save`方法保存`Graphics`对象当前的状态，而`Restore`恢复它：'
- en: '[PRE126]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `SetOrigin` method sets the origin of the coordinate system and `IntersectClip`
    restricts the area to be painted:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetOrigin`方法设置坐标系统的原点，而`IntersectClip`限制要绘制的区域：'
- en: '[PRE127]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following methods draw lines, rectangles, and ellipses, and write text:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法绘制线条、矩形、椭圆，并写入文本：
- en: '[PRE128]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `GetDeviceContextHandle` method returns the device context wrapped by the
    `Graphics` object:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDeviceContextHandle`方法返回由`Graphics`对象包装的设备上下文：'
- en: '[PRE129]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The `windowPtr` field holds a pointer to the window about which client area
    is to be drawn, and `deviceContextHandle` holds the handle to the device context,
    of type `HDC`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`windowPtr`字段持有指向要绘制客户端区域的窗口的指针，而`deviceContextHandle`持有设备上下文的句柄，类型为`HDC`：'
- en: '[PRE130]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The `WindowProc` and `DialogProc` functions are friends of the `Graphics` class,
    since they need access to its private members. This is the same for the `PrintDialog`
    methods of the `StandardDialog` class:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowProc`和`DialogProc`函数是`Graphics`类的朋友，因为它们需要访问其私有成员。对于`StandardDialog`类的`PrintDialog`方法也是如此：'
- en: '[PRE131]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '**Graphics.cpp**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**Graphics.cpp**'
- en: '[PRE132]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The constructor initializes the window pointer and device context:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化窗口指针和设备上下文：
- en: '[PRE133]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Sometimes, it is desirable to save the current state of the `Graphics` object
    with `Save`, which returns an identity number that can be used to restore the
    `Graphics` object with `Restore`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能希望使用`Save`保存`Graphics`对象的当前状态，它返回一个可以用来使用`Restore`恢复`Graphics`对象的身份号码：
- en: '[PRE134]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The default origin (x = 0 and y = 0) of the coordinate system is the top-left
    corner of the window client area. This can be changed with `SetOrigin`, which
    takes the new origin in logical units. The win32 API function `SetWindowOrgEx`
    sets the new origin:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系的默认原点（x = 0 和 y = 0）是窗口客户端区域的左上角。这可以通过`SetOrigin`来改变，它接受新的原点在逻辑单位中。Win32
    API 函数`SetWindowOrgEx`设置新的原点：
- en: '[PRE135]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The part of the client area to be painted can be restricted with `IntersectClip`,
    resulting in the area outside the given rectangle not being affected. The Win32
    API function `IntersectClip` sets the restricted area:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`IntersectClip`限制要绘制的客户端区域的部分，结果是在给定矩形外的区域不受影响。Win32 API 函数`IntersectClip`设置限制区域：
- en: '[PRE136]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'It is possible to draw lines, rectangles, and ellipses using a pen, which is
    obtained by the Win32 API functions `CreatePen` and `SelectObject`. Note that
    we save the previous object in order to restore it later:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用笔绘制线条、矩形和椭圆，笔是通过 Win32 API 函数 `CreatePen` 和 `SelectObject` 获取的。请注意，我们保存了上一个对象以便稍后恢复：
- en: '[PRE137]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'By the way, the technique of moving the pen to the start point and then drawing
    the line to the end point with `MoveToEx` and `LineTo` is called **Turtle** **graphics**,
    referring to a turtle moving over the client area with the pen up or down:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，使用 `MoveToEx` 和 `LineTo` 将笔移动到起点并绘制到终点的技术被称为**海龟**图形，指的是笔在客户端区域内上提或放下移动的乌龟：
- en: '[PRE138]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Similar to `CreateTextMetrics` and `GetCharacterWidth` in `Window`, we need
    to select the previous object and restore the pen:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Window` 中的 `CreateTextMetrics` 和 `GetCharacterWidth` 类似，我们需要选择上一个对象并恢复笔：
- en: '[PRE139]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'When drawing a rectangle, we need a solid pen and a hollow brush, which we
    create with the Win32 API function `CreateBrushIndirect` with a `LOGBRUSH` structure
    parameter:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制矩形时，我们需要一个实心笔和一个空心画刷，我们使用带有 `LOGBRUSH` 结构参数的 Win32 API 函数 `CreateBrushIndirect`
    创建它们：
- en: '[PRE140]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'When filling a rectangle, we also need a solid brush, which we create with
    the Win32 API function `CreateSolidBrush`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充矩形时，我们还需要一个实心画刷，我们使用 Win32 API 函数 `CreateSolidBrush` 创建它：
- en: '[PRE141]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The `DrawEllipse` and `FillEllipse` methods are similar to `DrawRectangle`
    and `FillRectangle`. The only difference is that they call the Win32 API function
    `Ellipse` instead of `Rectangle`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawEllipse` 和 `FillEllipse` 方法与 `DrawRectangle` 和 `FillRectangle` 类似。唯一的区别是它们调用
    Win32 API 函数 `Ellipse` 而不是 `Rectangle`：'
- en: '[PRE142]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When drawing text, we first need to check whether the font is given in typographical
    points and needs to be transformed into logical units (if `pointToMeters` is true),
    which is the case in the `LogicalWithScroll` and `LogicalWithoutScroll` coordinates
    systems. However, in the `PreviewCoordinate` system, the size of the text is already
    given in logical units and should not be transformed. Moreover, before we write
    the text, we need to create and select a font object and set the text and background
    colors. The Win32 `DrawText` function centers the text within the given rectangle:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制文本时，我们首先需要检查字体是否以排版点给出并需要转换为逻辑单位（如果 `pointToMeters` 为真），这在 `LogicalWithScroll`
    和 `LogicalWithoutScroll` 坐标系中是这种情况。然而，在 `PreviewCoordinate` 系统中，文本的大小已经以逻辑单位给出，不应进行转换。此外，在我们写入文本之前，我们需要创建并选择一个字体对象，并设置文本和背景颜色。Win32
    的 `DrawText` 函数在给定的矩形内居中文本：
- en: '[PRE143]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked into the core of Small Windows: the `MainWindow`
    function and the `Application`, `Window`, and `Graphics` classes. In [Chapter
    11](ch11.html "Chapter 11. The Document"), *The Document*, we look into the document
    classes of Small Windows: `Document`, `Menu`, `Accelerator`, and `StandardDocument`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了小型窗口的核心：`MainWindow` 函数以及 `Application`、`Window` 和 `Graphics` 类。在[第11章](ch11.html
    "第11章。文档")《文档》中，我们探讨了小型窗口的文档类：`Document`、`Menu`、`Accelerator` 和 `StandardDocument`。
