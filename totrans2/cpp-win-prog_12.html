<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;The Auxiliary Classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. The Auxiliary Classes</h1></div></div></div><p>Small Windows includes a set of auxiliary classes, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Size</code>, <code class="literal">Point</code>, <code class="literal">Rect</code>, <code class="literal">Color</code>, and <code class="literal">Font</code>: These wrap the Win32 API structures which are <code class="literal">SIZE</code>, <code class="literal">POINT</code>, <code class="literal">RECT</code>, <code class="literal">COLORREF</code>, and <code class="literal">LOGFONT</code>. They are equipped with methods to communicate with files, the clipboard, and the registry. The Registry is a database in the Windows system that we can use to store values between the executions of our applications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cursor</code>: is a type representing the Windows cursor.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DynamicList</code>: holds a list of dynamic size with a set of callback functions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Tree</code>: holds a recursive tree structure.</li><li class="listitem" style="list-style-type: disc"><code class="literal">InfoList</code>: holds a list of generic information that can be transformed to and from a memory buffer.</li><li class="listitem" style="list-style-type: disc">There is also a small set of string manipulation functions.</li></ul></div><div class="section" title="The Size class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec58"/>The Size class</h1></div></div></div><p>The <code class="literal">Size</code> class is a small class holding the width and height:</p><p>
<span class="strong"><strong>Size.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
</pre><p>The <code class="literal">ZeroSize</code> object is an object with its width and height set to zero:</p><pre class="programlisting">  class Size; &#13;
  extern const Size ZeroSize;  &#13;
  class Size { &#13;
    public: &#13;
</pre><p>The default constructor initializes the width and height to zero. The size can be initialized by, and assigned to, another size. The <code class="literal">Size</code> class uses the assignment operator to assign a size to another size:</p><pre class="programlisting">      Size(); &#13;
      Size(int width, int height); &#13;
      Size(const Size&amp; size); &#13;
      Size&amp; operator=(const Size&amp; size); &#13;
</pre><p>A <code class="literal">Size</code> object can be initialized and assigned to a value of the Win32 API <code class="literal">SIZE</code> structure, and a <code class="literal">Size</code> object can be converted to a <code class="literal">SIZE</code>:</p><pre class="programlisting">      Size(const SIZE&amp; size); &#13;
      Size&amp; operator=(const SIZE&amp; size); &#13;
      operator SIZE() const; &#13;
</pre><p>When comparing two sizes, the widths are compared first. If they are equal, the heights are then compared:</p><pre class="programlisting">      bool operator==(const Size&amp; size) const; &#13;
      bool operator!=(const Size&amp; size) const; &#13;
      bool operator&lt;(const Size&amp; size) const; &#13;
      bool operator&lt;=(const Size&amp; size) const; &#13;
      bool operator&gt;(const Size&amp; size) const; &#13;
      bool operator&gt;=(const Size&amp; size) const;  &#13;
      friend Size Min(const Size&amp; left, const Size&amp; right); &#13;
      friend Size Max(const Size&amp; left, const Size&amp; right); &#13;
</pre><p>The multiplication operators multiply both the width and height with the factor. Note that even though the factor is a double, the resulting width and height are always rounded to integers:</p><pre class="programlisting">      Size operator*=(double factor); &#13;
      friend Size operator*(const Size&amp; size, double factor); &#13;
      friend Size operator*(double factor, const Size&amp; size); &#13;
</pre><p>It is also possible to multiply the size with a pair of values, where the first value is multiplied by the width and the second value is multiplied by the height. Also, in this case, the resulting width and height are integers:</p><pre class="programlisting">      Size operator*=(pair&lt;double,double&gt; factorPair); &#13;
      friend Size operator*(const Size&amp; size, &#13;
                            pair&lt;double,double&gt; factorPair); &#13;
      friend Size operator*(pair&lt;double,double&gt; factorPair, &#13;
                            const Size&amp; size); &#13;
</pre><p>The first set of addition operators adds and subtracts the distance to both the width and height:</p><pre class="programlisting">      Size operator+=(int distance); &#13;
      Size operator-=(int distance); &#13;
      friend Size operator+(const Size&amp; size, int distance); &#13;
      friend Size operator-(const Size&amp; size, int distance); &#13;
</pre><p>The second set of addition operators adds and subtracts the widths and heights separately:</p><pre class="programlisting">      Size operator+=(const Size&amp; size); &#13;
      Size operator-=(const Size&amp; size); &#13;
      friend Size operator+(const Size&amp; left, const Size&amp; right); &#13;
      friend Size operator-(const Size&amp; left, const Size&amp; right); &#13;
</pre><p>The size can be written to, and read from, a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WriteSizeToStream(ostream&amp; outStream) const;   &#13;
      bool ReadSizeFromStream(istream&amp; inStream); &#13;
      void WriteSizeToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadSizeFromClipboard(InfoList&amp; infoList); &#13;
      void WriteSizeToRegistry(String key) const; &#13;
      void ReadSizeFromRegistry(String key, &#13;
                                Size defaultSize = ZeroSize); &#13;
</pre><p>The width and height are inspected by the constant methods and modified by the non-constant methods:</p><pre class="programlisting">      int Width() const {return width;} &#13;
      int Height() const {return height;} &#13;
      int&amp; Width() {return width;} &#13;
      int&amp; Height() {return height;}  &#13;
&#13;
    private: &#13;
      int width, height; &#13;
  }; &#13;
}; &#13;
</pre><p>The implementation of the <code class="literal">Size</code> class is rather straightforward:</p><p>
<span class="strong"><strong>Size.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h"  &#13;
namespace SmallWindows { &#13;
  Size::Size() &#13;
   :width(0), &#13;
&#13;
&#13;
    height(0) { &#13;
    // Empty. &#13;
  }  &#13;
&#13;
  Size::Size(int width, int height) &#13;
   :width(width), &#13;
    height(height) { &#13;
    // Empty. &#13;
  } &#13;
&#13;
  Size::Size(const Size&amp; size) &#13;
   :width(size.width), &#13;
    height(size.height) { &#13;
    // Empty. &#13;
  } &#13;
&#13;
  Size&amp; Size::operator=(const Size&amp; size) { &#13;
    if (this != &amp;size) { &#13;
      width = size.width; &#13;
      height = size.height; &#13;
    } &#13;
    return *this; &#13;
  } &#13;
&#13;
  Size::Size(const SIZE&amp; size) &#13;
   :width(size.cx), &#13;
    height(size.cy) { &#13;
    // Empty. &#13;
  } &#13;
&#13;
  Size&amp; Size::operator=(const SIZE&amp; size) { &#13;
    width = size.cx; &#13;
    height = size.cy; &#13;
    return *this; &#13;
  } &#13;
&#13;
  Size::operator SIZE() const { &#13;
    SIZE size = {width, height}; &#13;
    return size; &#13;
  } &#13;
&#13;
  bool Size::operator==(const Size&amp; size) const { &#13;
    return (width == size.width) &amp;&amp; (height == size.height); &#13;
  } &#13;
&#13;
  bool Size::operator!=(const Size&amp; size) const { &#13;
    return !(*this == size); &#13;
  } &#13;
</pre><p>As mentioned earlier, when comparing two sizes, the widths are compared first. If they are equal the heights are then compared:</p><pre class="programlisting">  bool Size::operator&lt;(const Size&amp; size) const { &#13;
    return (width &lt; size.width) || &#13;
           ((width == size.width) &amp;&amp; (height &lt; size.height)); &#13;
  }&#13;
&#13;
  bool Size::operator&lt;=(const Size&amp; size) const { &#13;
    return ((*this &lt; size) || (*this == size)); &#13;
  }&#13;
&#13;
  bool Size::operator&gt;(const Size&amp; size) const { &#13;
    return !(*this &lt;= size); &#13;
  }&#13;
&#13;
  bool Size::operator&gt;=(const Size&amp; size) const { &#13;
    return !(*this &lt; size); &#13;
  } &#13;
</pre><p>Note that <code class="literal">Min</code> and <code class="literal">Max</code> return the right-hand side value if the values are equal. We could let it return the left-hand side value instead. However, since the <code class="literal">Size</code> objects in that case hold the same <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values and the methods return objects rather than references to an object, it does not matter. The same value is returned:</p><pre class="programlisting">  Size Min(const Size&amp; left, const Size&amp; right) { &#13;
    return (left &lt; right) ? left : right; &#13;
  }&#13;
&#13;
  Size Max(const Size&amp; left, const Size&amp; right) { &#13;
    return (left &gt; right) ? left : right; &#13;
  } &#13;
</pre><p>As mentioned earlier, the resulting width and height are always rounded to integers, even though the factor is a double:</p><pre class="programlisting">  Size Size::operator*=(double factor) { &#13;
    width = (int) (factor * width); &#13;
    height = (int) (factor * height); &#13;
    return *this; &#13;
  }  &#13;
&#13;
  Size operator*(const Size&amp; size, double factor) { &#13;
    return Size((int) (size.width * factor), &#13;
                (int) (size.height * factor)); &#13;
  } &#13;
&#13;
  Size operator*(double factor, const Size&amp; size) { &#13;
    return Size((int) (factor * size.width), &#13;
                (int) (factor * size.height)); &#13;
  } &#13;
&#13;
  Size Size::operator*=(pair&lt;double,double&gt; factorPair) { &#13;
    width = (int) (factorPair.first * width); &#13;
    height = (int) (factorPair.second * height); &#13;
    return *this; &#13;
  } &#13;
&#13;
  Size operator*(const Size&amp; size, &#13;
                 pair&lt;double,double&gt; factorPair) { &#13;
    return Size((int) (size.width * factorPair.first), &#13;
                (int) (size.height * factorPair.second)); &#13;
  } &#13;
&#13;
  Size operator*(pair&lt;double,double&gt; factorPair, &#13;
                 const Size&amp; size) { &#13;
    return Size((int) (factorPair.first * size.width), &#13;
                (int) (factorPair.second * size.height)); &#13;
  } &#13;
&#13;
  Size Size::operator+=(int distance) { &#13;
    width += distance; &#13;
    height += distance; &#13;
    return *this; &#13;
  } &#13;
  Size Size::operator-=(int distance) { &#13;
    width -= distance; &#13;
    height -= distance; &#13;
    return *this; &#13;
  }  &#13;
&#13;
  Size operator+(const Size&amp; size, int distance) { &#13;
    return Size(size.width + distance, size.height + distance); &#13;
  } &#13;
&#13;
  Size operator-(const Size&amp; size, int distance) { &#13;
    return Size(size.width - distance, size.height - distance); &#13;
  } &#13;
&#13;
  Size Size::operator+=(const Size&amp; size) { &#13;
    width += size.width; &#13;
    height += size.height; &#13;
    return *this; &#13;
  } &#13;
&#13;
  Size Size::operator-=(const Size&amp; size) { &#13;
    width -= size.width; &#13;
    height -= size.height; &#13;
    return *this; &#13;
  } &#13;
&#13;
  Size operator+(const Size&amp; left, const Size&amp; right) { &#13;
    return Size(left.width + right.width, &#13;
                right.height + right.height); &#13;
  } &#13;
&#13;
  Size operator-(const Size&amp; left, const Size&amp; right) { &#13;
    return Size(left.width - right.width, &#13;
                right.height - right.height); &#13;
  } &#13;
&#13;
  bool Size::WriteSizeToStream(ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;width, sizeof width); &#13;
    outStream.write((char*) &amp;height, sizeof height); &#13;
    return ((bool) outStream); &#13;
  } &#13;
&#13;
  bool Size::ReadSizeFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;width, sizeof width); &#13;
    inStream.read((char*) &amp;height, sizeof height); &#13;
    return ((bool) inStream); &#13;
  } &#13;
&#13;
  void Size::WriteSizeToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;int&gt;(width); &#13;
    infoList.AddValue&lt;int&gt;(height); &#13;
  } &#13;
&#13;
  void Size::ReadSizeFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;int&gt;(width); &#13;
    infoList.GetValue&lt;int&gt;(height); &#13;
  } &#13;
</pre><p>When writing the size to the registry, we convert the size to a <code class="literal">SIZE</code> structure that is sent to <code class="literal">WriteBuffer</code> in <code class="literal">Registry</code>:</p><pre class="programlisting">  void Size::WriteSizeToRegistry(String key) const { &#13;
    SIZE sizeStruct = (SIZE) *this; &#13;
    Registry::WriteBuffer(key, &amp;sizeStruct, sizeof sizeStruct); &#13;
  } &#13;
</pre><p>When reading the size from the registry, we convert the default size to a <code class="literal">SIZE</code> structure that is sent to <code class="literal">ReadBuffer</code> in <code class="literal">Registry</code>. The result is then converted back to a <code class="literal">Size</code> object:</p><pre class="programlisting">  void Size::ReadSizeFromRegistry(String key, &#13;
                                  Size defaultSize /*=ZeroSize*/){ &#13;
    SIZE sizeStruct, defaultSizeStruct = (SIZE) defaultSize; &#13;
    Registry::ReadBuffer(key, &amp;sizeStruct, sizeof sizeStruct, &#13;
                         &amp;defaultSizeStruct); &#13;
    *this = Size(sizeStruct); &#13;
  } &#13;
  const Size ZeroSize(0, 0); &#13;
}; &#13;
</pre></div></div>
<div class="section" title="The Point class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec59"/>The Point class</h1></div></div></div><p>The <code class="literal">Point</code> class is a small class holding the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position of a two-dimensional point:</p><p>
<span class="strong"><strong>Point.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Point { &#13;
    public: &#13;
</pre><p>The default constructor initializes the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> value to zero. The point can be initialized by, and assigned to, another point:</p><pre class="programlisting">      Point(); &#13;
      Point(int x, int y); &#13;
      Point(const Point&amp; point); &#13;
</pre><p>Similar to the <code class="literal">Size</code> class mentioned earlier, <code class="literal">Point</code> uses the assignment operator:</p><pre class="programlisting">      Point&amp; operator=(const Point&amp; point); &#13;
</pre><p>Similar to <code class="literal">SIZE</code> in the preceding section, there is a <code class="literal">POINT</code> Win32 API structure. A <code class="literal">Point</code> object can be initialized by, and assigned to, a <code class="literal">POINT</code> structure, and a <code class="literal">Point</code> object can be converted to <code class="literal">POINT</code>:</p><pre class="programlisting">      Point(const POINT&amp; point); &#13;
      Point&amp; operator=(const POINT&amp; point); &#13;
      operator POINT() const; &#13;
</pre><p>When comparing two points, the <span class="emphasis"><em>x</em></span> values are first compared. If they are equal, the <span class="emphasis"><em>y</em></span> values are then compared:</p><pre class="programlisting">      bool operator==(const Point&amp; point) const; &#13;
      bool operator!=(const Point&amp; point) const; &#13;
      bool operator&lt;(const Point&amp; point) const; &#13;
      bool operator&lt;=(const Point&amp; point) const; &#13;
      bool operator&gt;(const Point&amp; point) const; &#13;
      bool operator&gt;=(const Point&amp; point) const;  &#13;
      friend Point Min(const Point&amp; left, const Point&amp; right); &#13;
      friend Point Max(const Point&amp; left, const Point&amp; right); &#13;
</pre><p>Similar to the <code class="literal">Size</code> class mentioned earlier, the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values of the point can be multiplied by a factor. Note that even though the factor is a double, the resulting <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values are always rounded to integers:</p><pre class="programlisting">      Point&amp; operator*=(double factor); &#13;
      friend Point operator*(const Point&amp; point, double factor); &#13;
      friend Point operator*(double factor, const Point&amp; point); &#13;
</pre><p>It is also possible to multiply the point with a pair of values, where the first value is multiplied with the <span class="emphasis"><em>x</em></span> value and the second value is multiplied with the <span class="emphasis"><em>y</em></span> value. Also, in this case, the resulting <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values are integers:</p><pre class="programlisting">      Point&amp; operator*=(pair&lt;double,double&gt; factorPair); &#13;
      friend Point operator*(const Point&amp; point, &#13;
                             pair&lt;double,double&gt; factorPair); &#13;
      friend Point operator*(pair&lt;double,double&gt; factorPair, &#13;
                             const Point&amp; point); &#13;
</pre><p>The first set of addition operators adds and subtracts the integer distance to both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> value of the point:</p><pre class="programlisting">      Point&amp; operator+=(const int distance); &#13;
      Point&amp; operator-=(const int distance); &#13;
      friend Point operator+(const Point&amp; left, int distance); &#13;
      friend Point operator-(const Point&amp; left, int distance); &#13;
</pre><p>The second set of addition operators adds and subtracts the width and height of the size to the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values of the point:</p><pre class="programlisting">      Point&amp; operator+=(const Size&amp; size); &#13;
      Point&amp; operator-=(const Size&amp; size); &#13;
      friend Point operator+(const Point&amp; point,const Size&amp; size); &#13;
      friend Point operator-(const Point&amp; point,const Size&amp; size); &#13;
</pre><p>The third set of addition operators adds and subtracts the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values of the points:</p><pre class="programlisting">      Point&amp; operator+=(const Point&amp; point); &#13;
      Point&amp; operator-=(const Point&amp; point); &#13;
      friend Point operator+(const Point&amp;left, const Point&amp;right); &#13;
      friend Size operator-(const Point&amp; left, const Point&amp;right); &#13;
</pre><p>The point can be written to, and read from, a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WritePointToStream(ostream&amp; outStream) const; &#13;
      bool ReadPointFromStream(istream&amp; inStream); &#13;
      void WritePointToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadPointFromClipboard(InfoList&amp; infoList); &#13;
      void WritePointToRegistry(String key) const;  &#13;
      void ReadPointFromRegistry(String key, &#13;
                            Point defaultPoint /* = ZeroPoint */); &#13;
</pre><p>The <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> value of the point are inspected by the constant methods and modified by the non-constant methods:</p><pre class="programlisting">      int X() const {return x;} &#13;
      int Y() const {return y;} &#13;
      int&amp; X() {return x;} &#13;
      int&amp; Y() {return y;} &#13;
 &#13;
    private: &#13;
      int x, y; &#13;
  }; &#13;
 &#13;
  extern const Point ZeroPoint; &#13;
}; &#13;
</pre><p>The implementation of the <code class="literal">Point</code> class is also rather straightforward:</p><p>
<span class="strong"><strong>Point.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h"&#13;
 &#13;
namespace SmallWindows { &#13;
  Point::Point() &#13;
   :x(0), y(0) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Point::Point(int x, int y) &#13;
   :x(x), y(y) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Point::Point(const Point&amp; point) &#13;
   :x(point.x), &#13;
    y(point.y) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>In the assignment operator, it is a good custom to verify that we do not assign the same object. However, it is not completely necessary in this case since we just assign the integer values of <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>:</p><pre class="programlisting">  Point&amp; Point::operator=(const Point&amp; point) { &#13;
    if (this != &amp;point) { &#13;
      x = point.x; &#13;
      y = point.y; &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point::Point(const POINT&amp; point) &#13;
   :x(point.x), &#13;
    y(point.y) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator=(const POINT&amp; point) { &#13;
    x = point.x; &#13;
    y = point.y; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point::operator POINT() const { &#13;
    POINT point = {x, y}; &#13;
    return point; &#13;
  } &#13;
 &#13;
  bool Point::operator==(const Point&amp; point) const { &#13;
    return ((x == point.x) &amp;&amp; (y == point.y)); &#13;
  } &#13;
 &#13;
  bool Point::operator!=(const Point&amp; point) const { &#13;
    return !(*this == point); &#13;
  } &#13;
 &#13;
  bool Point::operator&lt;(const Point&amp; point) const { &#13;
    return (x &lt; point.x) || ((x == point.x) &amp;&amp; (y &lt; point.y)); &#13;
  } &#13;
 &#13;
  bool Point::operator&lt;=(const Point&amp; point) const { &#13;
    return ((*this &lt; point) || (*this == point)); &#13;
  } &#13;
 &#13;
  bool Point::operator&gt;(const Point&amp; point) const { &#13;
    return !(*this &lt;= point); &#13;
  } &#13;
 &#13;
  bool Point::operator&gt;=(const Point&amp; point) const { &#13;
    return !(*this &lt; point); &#13;
  } &#13;
 &#13;
  Point Min(const Point&amp; left, const Point&amp; right) { &#13;
    return (left &lt; right) ? left : right; &#13;
  } &#13;
 &#13;
  Point Max(const Point&amp; left, const Point&amp; right) { &#13;
    return (left &gt; right) ? left : right; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator*=(double factor) { &#13;
    x = (int) (factor * x); &#13;
    y = (int) (factor * y); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point operator*(const Point&amp; point, double factor) { &#13;
    return Point((int) (point.x * factor), &#13;
                 (int) (point.y * factor)); &#13;
  } &#13;
 &#13;
  Point operator*(double factor, const Point&amp; point) { &#13;
    return Point((int) (factor * point.x), &#13;
                 (int) (factor * point.y)); &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator*=(pair&lt;double,double&gt; factorPair) { &#13;
    x = (int) (factorPair.first * x); &#13;
    y = (int) (factorPair.second * y); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point operator*(const Point&amp; point, &#13;
                  pair&lt;double,double&gt; factorPair) { &#13;
    return Point((int) (point.x * factorPair.first), &#13;
                 (int) (point.y * factorPair.second)); &#13;
  } &#13;
 &#13;
  Point operator*(pair&lt;double,double&gt; factorPair, &#13;
                  const Point&amp; point) { &#13;
    return Point((int) (factorPair.first * point.x), &#13;
                 (int) (factorPair.second * point.y)); &#13;
  } &#13;
 &#13;
&#13;
&#13;
  Point&amp; Point::operator+=(const int distance) { &#13;
    x += distance; &#13;
    y += distance; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator-=(const int distance) { &#13;
    x -= distance; &#13;
    y -= distance; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator+=(const Size&amp; size) { &#13;
    x += size.Width(); &#13;
    y += size.Height(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator-=(const Size&amp; size) { &#13;
    x -= size.Width(); &#13;
    y -= size.Height(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator+=(const Point&amp; point) { &#13;
    x += point.x; &#13;
    y += point.y; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point&amp; Point::operator-=(const Point&amp; point) { &#13;
    x -= point.x; &#13;
    y -= point.y; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Point operator+(const Point&amp; left, int distance) { &#13;
    return Point(left.x + distance, left.y + distance); &#13;
  } &#13;
 &#13;
  Point operator-(const Point&amp; left, int distance) { &#13;
    return Point(left.x - distance, left.y - distance); &#13;
  } &#13;
 &#13;
  Point operator+(const Point&amp; point, const Size&amp; size) { &#13;
    return Point(point.x + size.Width(), point.y + size.Height()); &#13;
  } &#13;
 &#13;
  Point operator-(const Point&amp; point, const Size&amp; size) { &#13;
    return Point(point.x - size.Width(), point.y - size.Height()); &#13;
  } &#13;
 &#13;
  Point operator+(const Point&amp; left, const Point&amp; right) { &#13;
    return Point(left.x + right.x, left.y + right.y); &#13;
  } &#13;
 &#13;
  Size operator-(const Point&amp; left, const Point&amp; right) { &#13;
    return Size(left.x - right.x, left.y - right.y); &#13;
  } &#13;
 &#13;
  bool Point::WritePointToStream(ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;x, sizeof x); &#13;
    outStream.write((char*) &amp;y, sizeof y); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool Point::ReadPointFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;x, sizeof x); &#13;
    inStream.read((char*) &amp;y, sizeof y); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  void Point::WritePointToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;int&gt;(x); &#13;
    infoList.AddValue&lt;int&gt;(y); &#13;
  } &#13;
 &#13;
  void Point::ReadPointFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;int&gt;(x); &#13;
    infoList.GetValue&lt;int&gt;(y); &#13;
  } &#13;
 &#13;
  void Point::WritePointToRegistry(String key) const { &#13;
    POINT pointStruct = (POINT) *this; &#13;
    Registry::WriteBuffer(key, &amp;pointStruct, sizeof pointStruct); &#13;
  } &#13;
 &#13;
  void Point::ReadPointFromRegistry(String key, &#13;
                           Point defaultPoint /* = ZeroPoint */) { &#13;
    POINT pointStruct, defaultPointStruct = (POINT) defaultPoint; &#13;
    Registry::ReadBuffer(key, &amp;pointStruct, sizeof pointStruct, &#13;
                         &amp;defaultPointStruct); &#13;
    *this = Point(pointStruct); &#13;
  } &#13;
 &#13;
&#13;
  const Point ZeroPoint(0, 0); &#13;
}; &#13;
</pre></div>
<div class="section" title="The Rect class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec60"/>The Rect class</h1></div></div></div><p>The <code class="literal">Rect</code> class holds the four borders of a rectangle: left, top, right, and bottom.</p><p>
<span class="strong"><strong>Rect.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Rect; &#13;
  extern const Rect ZeroRect; &#13;
 &#13;
  class Rect { &#13;
    public: &#13;
</pre><p>The default constructor sets all the four borders to zero. The rectangle can be initialized by, or assigned to, another rectangle. It is also possible to initialize the rectangle with the top-left and bottom-right corners, as well as the top-left corner and a size holding the width and height of the rectangle:</p><pre class="programlisting">      Rect(); &#13;
      Rect(int left, int top, int right, int bottom); &#13;
      Rect(const Rect&amp; rect); &#13;
      Rect&amp; operator=(const Rect&amp; rect); &#13;
      Rect(Point topLeft, Point bottomRight); &#13;
      Rect(Point topLeft, Size size); &#13;
</pre><p>Similar to <code class="literal">SIZE</code> and <code class="literal">POINT</code> in the previous sections, a rectangle can be initialized and assigned to a value of the Win32 API <code class="literal">RECT</code> structure. A <code class="literal">Rect</code> object can also be converted to a <code class="literal">RECT</code>:</p><pre class="programlisting">      Rect(const RECT&amp; rect); &#13;
      Rect&amp; operator=(const RECT&amp; rect); &#13;
      operator RECT() const; &#13;
</pre><p>The compare operators first compare the top-left corners. If they are equal, the bottom-right corners are then compared:</p><pre class="programlisting">      bool operator==(const Rect&amp; rect) const; &#13;
      bool operator!=(const Rect&amp; rect) const; &#13;
      bool operator&lt;(const Rect&amp; rect) const; &#13;
      bool operator&lt;=(const Rect&amp; rect) const; &#13;
      bool operator&gt;(const Rect&amp; rect) const; &#13;
      bool operator&gt;=(const Rect&amp; rect) const; &#13;
</pre><p>The multiplication operators multiply all sides with the factor. Even though the factor is a double, the border values are always integers, similar to the <code class="literal">Size</code> and <code class="literal">Point</code> cases of the previous sections:</p><pre class="programlisting">      Rect&amp; operator*=(double factor); &#13;
      friend Rect operator*(const Rect&amp; rect, double factor); &#13;
      friend Rect operator*(double factor, const Rect&amp; rect); &#13;
</pre><p>It is also possible to multiply the rectangle with a pair of values, where the first value is multiplied with <code class="literal">left</code> and <code class="literal">right</code>, and the second value is multiplied with <code class="literal">top</code> and <code class="literal">bottom</code>. Also, in this case, the resulting values are integers:</p><pre class="programlisting">      Rect&amp; operator*=(pair&lt;double,double&gt; factorPair); &#13;
      friend Rect operator*(const Rect&amp; rect, &#13;
                            pair&lt;double,double&gt; factorPair); &#13;
      friend Rect operator*(pair&lt;double,double&gt; factorPair, &#13;
                            const Rect&amp; rect); &#13;
</pre><p>The following operators are a little bit special: the addition operator adds the size to the bottom-right corner and leaves the top-left corner unchanged while the subtraction operator subtracts the size from the top-left corner and leaves the bottom-right corner unchanged:</p><pre class="programlisting">      Rect&amp; operator+=(const Size&amp; size); &#13;
      Rect&amp; operator-=(const Size&amp; size); &#13;
</pre><p>However, the following operators add and subtract the size to and from both the top-left and bottom-right corners:</p><pre class="programlisting">      friend Rect operator+(const Rect&amp; rect, const Size&amp; size); &#13;
      friend Rect operator-(const Rect&amp; rect, const Size&amp; size); &#13;
</pre><p>The following operators take a point as a parameter and add the point to, and subtract it from, both the top-left and bottom-right corner:</p><pre class="programlisting">      Rect&amp; operator+=(const Point&amp; point); &#13;
      Rect&amp; operator-=(const Point&amp; point); &#13;
      friend Rect operator+(const Rect&amp; rect, const Point&amp; point); &#13;
      friend Rect operator+(const Point&amp; point, const Rect&amp; rect); &#13;
      friend Rect operator-(const Rect&amp; rect, const Point&amp; point); &#13;
</pre><p>The width of a rectangle is the absolute difference between the left and right border, and its height is the absolute difference between the top and bottom border:</p><pre class="programlisting">      int Width() const {return abs(right - left);} &#13;
      int Height() const {return abs(bottom - top);} &#13;
</pre><p>The <code class="literal">GetSize</code> method returns the width and height of the rectangle. It is not possible to name it <code class="literal">Size</code>, since there is a class with that name. However, it is still possible to define an operator returning a <code class="literal">Size</code> object. The <code class="literal">Size</code> and <code class="literal">Point</code> operators return the size and top-left corner of the rectangle:</p><pre class="programlisting">      Size GetSize() const {return Size(Width(), Height());} &#13;
      operator Size() const {return GetSize();} &#13;
      operator Point() const {return TopLeft();} &#13;
</pre><p>The top-left and bottom-right corner can both be inspected and modified. It is not appropriate to define methods returning a reference to a point since there are no corresponding fields for the corners:</p><pre class="programlisting">      Point TopLeft() const {return Point(left, top);} &#13;
      Point BottomRight() const {return Point(right, bottom);} &#13;
 &#13;
      void SetTopLeft(Point topLeft) {left = topLeft.X(); &#13;
                                      right = topLeft.Y();} &#13;
      void SetBottomRight(Point bottomRight) &#13;
                         {right = bottomRight.X(); &#13;
                          bottom = bottomRight.Y();} &#13;
</pre><p>The <code class="literal">Clear</code> method sets all four corners to zero, <code class="literal">Normalize</code> swaps the left and right borders and the top and bottom borders if they appear in the wrong order, and <code class="literal">PointInside</code> returns <code class="literal">true</code> if the point is located inside the rectangle, assuming that it has been normalized:</p><pre class="programlisting">      void Clear(); &#13;
      void Normalize(); &#13;
      bool PointInside(Point point) const; &#13;
</pre><p>The rectangle can be written to and read from a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WriteRectToStream(ostream&amp; outStream) const; &#13;
      bool ReadRectFromStream(istream&amp; inStream); &#13;
      void WriteRectToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadRectFromClipboard(InfoList&amp; infoList); &#13;
      void WriteRectToRegistry(String key) const; &#13;
      void ReadRectFromRegistry(String key, &#13;
                                Rect defaultRect = ZeroRect); &#13;
</pre><p>The four corners are inspected by the constant methods and modified by the non-constant methods:</p><pre class="programlisting">      int Left() const {return left;} &#13;
      int Right() const {return right;} &#13;
      int Top() const {return top;} &#13;
      int Bottom() const {return bottom;} &#13;
 &#13;
      int&amp; Left() {return left;} &#13;
      int&amp; Right() {return right;} &#13;
      int&amp; Top() {return top;} &#13;
      int&amp; Bottom() {return bottom;} &#13;
 &#13;
    private: &#13;
      int left, top, right, bottom; &#13;
  }; &#13;
}; &#13;
</pre><p>Similar to <code class="literal">Size</code> and <code class="literal">Point</code>, the implementation of <code class="literal">Rect</code> is rather straightforward.</p><p>
<span class="strong"><strong>Rect.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h"&#13;
 &#13;
namespace SmallWindows { &#13;
  Rect::Rect() &#13;
   :left(0), top(0), right(0), bottom(0) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect::Rect(int left, int top, int right, int bottom) &#13;
   :left(left), &#13;
    top(top), &#13;
    right(right), &#13;
    bottom(bottom) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect::Rect(const Rect&amp; rect) &#13;
   :left(rect.left), &#13;
    top(rect.top), &#13;
    right(rect.right), &#13;
    bottom(rect.bottom) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator=(const Rect&amp; rect) { &#13;
    if (this != &amp;rect) { &#13;
      left = rect.left; &#13;
      top = rect.top; &#13;
      right = rect.right; &#13;
      bottom = rect.bottom; &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect::Rect(Point topLeft, Point bottomRight) &#13;
   :left(topLeft.X()), &#13;
    top(topLeft.Y()), &#13;
    right(bottomRight.X()), &#13;
    bottom(bottomRight.Y()) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect::Rect(Point topLeft, Size size) &#13;
   :left(topLeft.X()), &#13;
    top(topLeft.Y()), &#13;
    right(topLeft.X() + size.Width()), &#13;
    bottom(topLeft.Y() + size.Height()) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect::Rect(const RECT&amp; rect) &#13;
   :left(rect.left), &#13;
    top(rect.top), &#13;
    right(rect.right), &#13;
    bottom(rect.bottom) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator=(const RECT&amp; rect) { &#13;
    left = rect.left; &#13;
    top = rect.top; &#13;
    right = rect.right; &#13;
    bottom = rect.bottom; &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect::operator RECT() const { &#13;
    RECT rect = {left, top, right, bottom}; &#13;
    return rect; &#13;
  } &#13;
 &#13;
  bool Rect::operator==(const Rect&amp; rect) const { &#13;
    return (left == rect.left) &amp;&amp; (top == rect.top) &amp;&amp; &#13;
           (right == rect.right) &amp;&amp; (bottom == rect.bottom); &#13;
  } &#13;
 &#13;
  bool Rect::operator!=(const Rect&amp; rect) const { &#13;
    return !(*this == rect); &#13;
  } &#13;
 &#13;
&#13;
&#13;
  bool Rect::operator&lt;(const Rect&amp; rect) const { &#13;
    return (TopLeft() &lt; rect.TopLeft()) || &#13;
           ((TopLeft() == rect.TopLeft()) &amp;&amp; &#13;
            (BottomRight() &lt; rect.BottomRight())); &#13;
  } &#13;
 &#13;
  bool Rect::operator&lt;=(const Rect&amp; rect) const { &#13;
    return ((*this &lt; rect) || (*this == rect)); &#13;
  } &#13;
 &#13;
  bool Rect::operator&gt;(const Rect&amp; rect) const { &#13;
    return !(*this &lt;= rect); &#13;
  } &#13;
 &#13;
  bool Rect::operator&gt;=(const Rect&amp; rect) const { &#13;
    return !(*this &lt; rect); &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator*=(double factor) { &#13;
    left = (int) (factor * left); &#13;
    top = (int) (factor * top); &#13;
    right = (int) (factor * right); &#13;
    bottom = (int) (factor * bottom); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect operator*(const Rect&amp; rect, double factor) { &#13;
    return Rect(rect.TopLeft() * factor, &#13;
                rect.BottomRight() * factor); &#13;
  } &#13;
 &#13;
  Rect operator*(double factor, const Rect&amp; rect) { &#13;
    return Rect(factor * rect.TopLeft(), &#13;
                factor * rect.BottomRight()); &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator*=(pair&lt;double,double&gt; factorPair) { &#13;
    left = (int) (factorPair.first * left); &#13;
    top = (int) (factorPair.second * top); &#13;
    right = (int) (factorPair.first * right); &#13;
    bottom = (int) (factorPair.second * bottom); &#13;
    return *this; &#13;
  } &#13;
 &#13;
&#13;
&#13;
&#13;
&#13;
  Rect operator*(const Rect&amp; rect, &#13;
                 pair&lt;double,double&gt; factorPair) { &#13;
    return Rect(rect.TopLeft() * factorPair, &#13;
                rect.BottomRight() * factorPair); &#13;
  } &#13;
 &#13;
  Rect operator*(pair&lt;double,double&gt; factorPair, &#13;
                 const Rect&amp; rect) { &#13;
    return Rect(factorPair * rect.TopLeft(), &#13;
                factorPair * rect.BottomRight()); &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator+=(const Size&amp; size) { &#13;
    right += size.Width(); &#13;
    bottom += size.Height(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator-=(const Size&amp; size) { &#13;
    left -= size.Width(); &#13;
    top -= size.Height(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect operator+(const Rect&amp; rect, const Size&amp; size) { &#13;
    return Rect(rect.left + size.Width(), &#13;
                rect.top + size.Height(), &#13;
                rect.right + size.Width(), &#13;
                rect.bottom + size.Height()); &#13;
  } &#13;
 &#13;
  Rect operator-(const Rect&amp; rect, const Size&amp; size) { &#13;
    return Rect(rect.left - size.Width(), &#13;
                rect.top - size.Height(), &#13;
                rect.right - size.Width(), &#13;
                rect.bottom - size.Height()); &#13;
  } &#13;
 &#13;
  Rect&amp; Rect::operator+=(const Point&amp; point) { &#13;
    left += point.X(); &#13;
    top += point.Y(); &#13;
    right += point.X(); &#13;
    bottom += point.Y(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
&#13;
&#13;
  Rect&amp; Rect::operator-=(const Point&amp; point) { &#13;
    left -= point.X(); &#13;
    top -= point.Y(); &#13;
    right -= point.X(); &#13;
    bottom -= point.Y(); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Rect operator+(const Rect&amp; rect, const Point&amp; point) { &#13;
    return Rect(rect.left + point.X(), rect.top + point.Y(), &#13;
                rect.right + point.X(), rect.bottom + point.Y()); &#13;
  } &#13;
 &#13;
  Rect operator+(const Point&amp; point, const Rect&amp; rect) { &#13;
    return Rect(point.X() + rect.left, point.Y() + rect.top, &#13;
                point.X() + rect.right, point.Y() + rect.bottom); &#13;
  } &#13;
 &#13;
  Rect operator-(const Rect&amp; rect, const Point&amp; point) { &#13;
    return Rect(rect.left - point.X(), rect.top - point.Y(), &#13;
                rect.right - point.X(), rect.bottom - point.Y()); &#13;
  }  &#13;
&#13;
  void Rect::Clear() { &#13;
    left = top = right = bottom = 0; &#13;
  }  &#13;
&#13;
  void Rect::Normalize() { &#13;
    int minX = min(left, right), minY = min(top, bottom), &#13;
        maxX = max(left, right), maxY = max(top, bottom);  &#13;
    left = minX; &#13;
    top = minY; &#13;
    right = maxX; &#13;
    bottom = maxY; &#13;
  } &#13;
 &#13;
  bool Rect::PointInside(Point point) const { &#13;
    return ((left &lt;= point.X()) &amp;&amp; (point.X() &lt;= right) &amp;&amp; &#13;
            (top &lt;= point.Y()) &amp;&amp; (point.Y() &lt;= bottom)); &#13;
  } &#13;
 &#13;
  bool Rect::WriteRectToStream(ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;left, sizeof left); &#13;
    outStream.write((char*) &amp;top, sizeof top); &#13;
    outStream.write((char*) &amp;right, sizeof right); &#13;
    outStream.write((char*) &amp;bottom, sizeof bottom); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool Rect::ReadRectFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;left, sizeof left); &#13;
    inStream.read((char*) &amp;top, sizeof top); &#13;
    inStream.read((char*) &amp;right, sizeof right); &#13;
    inStream.read((char*) &amp;bottom, sizeof bottom); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  void Rect::WriteRectToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;int&gt;(left); &#13;
    infoList.AddValue&lt;int&gt;(top); &#13;
    infoList.AddValue&lt;int&gt;(right); &#13;
    infoList.AddValue&lt;int&gt;(bottom); &#13;
  }  &#13;
&#13;
  void Rect::ReadRectFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;int&gt;(left); &#13;
    infoList.GetValue&lt;int&gt;(top); &#13;
    infoList.GetValue&lt;int&gt;(right); &#13;
    infoList.GetValue&lt;int&gt;(bottom); &#13;
  } &#13;
&#13;
  void Rect::WriteRectToRegistry(String key) const { &#13;
    RECT pointStruct = (RECT) *this; &#13;
    Registry::WriteBuffer(key, &amp;pointStruct, sizeof pointStruct); &#13;
  } &#13;
&#13;
  void Rect::ReadRectFromRegistry(String key, &#13;
                             Rect defaultRect /* = ZeroRect */) { &#13;
    RECT rectStruct, defaultRectStruct = (RECT) defaultRect; &#13;
    Registry::ReadBuffer(key, &amp;rectStruct, sizeof rectStruct, &#13;
                         &amp;defaultRectStruct); &#13;
    *this = Rect(rectStruct); &#13;
  } &#13;
 &#13;
  const Rect ZeroRect(0, 0, 0, 0); &#13;
}; &#13;
</pre></div>
<div class="section" title="The Color class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec61"/>The Color class</h1></div></div></div><p>The <code class="literal">Color</code> class is a wrapper class for the Win32 API <code class="literal">COLORREF</code> structure, which holds a color in accordance with the Red-Green-Blue (RGB) standard. Each component of the color is represented by a value between 0 and 255, inclusive, which gives a theoretical total number of 256<sup>3</sup> = 16,777,216 different colors, among which <code class="literal">Color</code> defines 142 standard colors.</p><p>
<span class="strong"><strong>Color.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Color; &#13;
  extern const Color SystemColor; &#13;
</pre><p>The default constructor initializes the color with zero for each of the red, green, and blue values, which corresponds to black. A color object can also be initialized by, and assigned to, another color:</p><pre class="programlisting">  class Color { &#13;
    public: &#13;
      Color(); &#13;
      Color(int red, int green, int blue); &#13;
      Color(const Color&amp; color); &#13;
      Color&amp; operator=(const Color&amp; color); &#13;
</pre><p>The equality operators compare the red, green, and blue values:</p><pre class="programlisting">      bool operator==(const Color&amp; color) const; &#13;
      bool operator!=(const Color&amp; color) const; &#13;
</pre><p>The <code class="literal">Inverse</code> function returns the inverted color and <code class="literal">GrayScale</code> returns the corresponding grayscale color:</p><pre class="programlisting">      Color Inverse(); &#13;
      void GrayScale(); &#13;
</pre><p>The color can be written to, and read from, a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WriteColorToStream(ostream&amp; outStream) const; &#13;
      bool ReadColorFromStream(istream&amp; inStream); &#13;
      void WriteColorToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadColorFromClipboard(InfoList&amp; infoList); &#13;
      void WriteColorToRegistry(String key) const; &#13;
      void ReadColorFromRegistry(String key, &#13;
                                 Color defaultColor =SystemColor); &#13;
</pre><p>The wrapped <code class="literal">COLORREF</code> structure value is inspected by the constant method and modified by the non-constant method:</p><pre class="programlisting">      COLORREF ColorRef() const {return colorRef;} &#13;
      COLORREF&amp; ColorRef() {return colorRef;} &#13;
 &#13;
    private: &#13;
      COLORREF colorRef; &#13;
  }; &#13;
</pre><p>The predefined colors are constant objects:</p><pre class="programlisting">  extern const Color &#13;
    AliceBlue, AntiqueWhite, Aqua, Aquamarine, &#13;
    Azure, Beige, Bisque, Black, BlanchedAlmond, &#13;
    Blue, BlueViolet, Brown, Burlywood, CadetBlue, &#13;
    Chartreuse, Chocolate, Coral, CornflowerBlue, &#13;
    Cornsilk, Crimson, Cyan, DarkBlue, DarkCyan, &#13;
    DarkGoldenRod, DarkGray, DarkGreen, DarkKhaki, &#13;
    DarkMagenta, DarkOliveGreen, DarkOrange, DarkOrchid, &#13;
    DarkRed, DarkSalmon, DarkSeaGreen, DarkSlateBlue, &#13;
    DarkSlateGray, DarkTurquoise, DarkViolet, DeepPink, &#13;
    DeepSkyBlue, DimGray, DodgerBlue, FireBrick, &#13;
    FloralWhite, ForestGreen, Fuchsia, Gainsboro, &#13;
    GhostWhite, Gold, GoldenRod, Gray, Green, GreenYellow, &#13;
    HoneyDew, HotPink, IndianRed, Indigo, Ivory, Khaki, &#13;
    Lavender, LavenderBlush, Lawngreen, LemonChiffon, &#13;
    LightBlue, LightCoral, LightCyan, LightGoldenRodYellow, &#13;
    LightGreen, LightGray, LightPink, LightSalmon, &#13;
    LightSeaGreen, LightSkyBlue, LightSlateGray, &#13;
    LightSteelBlue, LightYellow, Lime, LimeGreen, Linen, &#13;
    Magenta, Maroon, MediumAquamarine, MediumBlue, &#13;
    MediumOrchid, MediumPurple, MediumSeaGreen, &#13;
    MediumSlateBlue, MediumSpringGreen, MediumTurquoise, &#13;
    MediumVioletRed, MidnightBlue, MintCream, MistyRose, &#13;
    Moccasin, NavajoWhite, Navy, Navyblue, OldLace, Olive, &#13;
    OliveDrab, Orange, OrangeRed, Orchid, PaleGoldenRod, &#13;
    PaleGreen, PaleTurquoise, PaleVioletRed, PapayaWhip, &#13;
    PeachPuff, Peru, Pink, Plum, PowderBlue, Purple, &#13;
    Red, RosyBrown, RoyalBlue, SaddleBrown, Salmon, &#13;
    SandyBrown, SeaGreen, SeaShell, Sienna, Silver, SkyBlue, &#13;
    SlateBlue, SlateGray, Snow, SpringGreen, SteelBlue, &#13;
    SystemColor, Tan, Teal, Thistle, Tomato, Turquoise, &#13;
    Violet, Wheat, White, WhiteSmoke, Yellow, YellowGreen; &#13;
}; &#13;
</pre><p>The implementation of <code class="literal">Color</code> is rather straightforward. The Win32 <code class="literal">RGB</code> macro creates a <code class="literal">COLORREF</code> value based on the three color components.</p><p>
<span class="strong"><strong>Color.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  Color::Color() &#13;
   :colorRef(RGB(0, 0, 0)) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Color::Color(COLORREF colorRef) &#13;
   :colorRef(colorRef) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Color::Color(int red, int green, int blue) &#13;
   :colorRef(RGB(red, green, blue)) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Color::Color(const Color&amp; color) &#13;
   :colorRef(color.colorRef) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Color&amp; Color::operator=(const Color&amp; color) { &#13;
    if (this != &amp;color) { &#13;
      colorRef = color.colorRef; &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
</pre><p>Two colors are equal if their wrapped <code class="literal">COLORREF</code> structures are equal, and they are compared with the C standard function <code class="literal">memcpy</code>.</p><pre class="programlisting">  bool Color::operator==(const Color&amp; color) const { &#13;
    return (colorRef == color.colorRef); &#13;
  } &#13;
 &#13;
  bool Color::operator!=(const Color&amp; color) const { &#13;
    return !(*this == color); &#13;
  } &#13;
</pre><p>The <code class="literal">Inverse</code> function returns the inverted color with each component subtracted from 255, and <code class="literal">GrayScale</code> returns the corresponding grayscale color with each component holding the average value of the red, green, and blue components. <code class="literal">GetRValue</code>, <code class="literal">GetGValue</code>, and <code class="literal">GetBValue</code> are Win32 API macros that extract the red, green, and blue components:</p><pre class="programlisting">  Color Color::Inverse() { &#13;
    int inverseRed = 255 - GetRValue(colorRef); &#13;
    int inverseGreen = 255 - GetGValue(colorRef); &#13;
    int inverseBlue = 255 - GetBValue(colorRef); &#13;
    return Color(inverseRed, inverseGreen, inverseBlue); &#13;
  } &#13;
 &#13;
&#13;
  void Color::GrayScale() { &#13;
    int red = GetRValue(colorRef); &#13;
    int green = GetGValue(colorRef); &#13;
    int blue = GetBValue(colorRef); &#13;
 &#13;
    int average = (red + green + blue) / 3; &#13;
    colorRef = RGB(average, average, average); &#13;
  } &#13;
 &#13;
  bool Color::WriteColorToStream(ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;colorRef, sizeof colorRef); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool Color::ReadColorFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;colorRef, sizeof colorRef); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  void Color::WriteColorToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;COLORREF&gt;(colorRef); &#13;
  } &#13;
 &#13;
  void Color::ReadColorFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;COLORREF&gt;(colorRef); &#13;
  } &#13;
 &#13;
  void Color::WriteColorToRegistry(String key) const { &#13;
    Registry::WriteBuffer(key, &amp;colorRef, sizeof colorRef); &#13;
  } &#13;
 &#13;
  void Color::ReadColorFromRegistry(String key, &#13;
                           Color defaultColor /*=SystemColor */) { &#13;
    Registry::ReadBuffer(key, &amp;colorRef, sizeof colorRef, &#13;
                         &amp;defaultColor.colorRef); &#13;
  } &#13;
</pre><p>Each of the predefined colors calls the constructor that takes the red, green, and blue components:</p><pre class="programlisting">  const Color &#13;
    AliceBlue(240, 248, 255), AntiqueWhite(250, 235, 215), &#13;
    Aqua(0, 255, 255), Aquamarine(127, 255, 212), &#13;
    Azure(240, 255, 255), Beige(245, 245, 220), &#13;
    Bisque(255, 228, 196), Black(0, 0, 0), &#13;
    BlanchedAlmond(255, 255, 205), Blue(0, 0, 255), &#13;
    BlueViolet(138, 43, 226), Brown(165, 42, 42), &#13;
    Burlywood(222, 184, 135), CadetBlue(95, 158, 160), &#13;
    Chartreuse(127, 255, 0), Chocolate(210, 105, 30), &#13;
    Coral(255, 127, 80), CornflowerBlue(100, 149, 237), &#13;
    Cornsilk(255, 248, 220), Crimson(220, 20, 60), &#13;
    Cyan(0, 255, 255), DarkBlue(0, 0, 139), &#13;
    DarkCyan(0, 139, 139), DarkGoldenRod(184, 134, 11), &#13;
    DarkGray(169, 169, 169), DarkGreen(0, 100, 0), &#13;
    DarkKhaki(189, 183, 107), DarkMagenta(139, 0, 139), &#13;
    DarkOliveGreen(85, 107, 47), DarkOrange(255, 140, 0), &#13;
    DarkOrchid(153, 50, 204), DarkRed(139, 0, 0), &#13;
    DarkSalmon(233, 150, 122), DarkSeaGreen(143, 188, 143), &#13;
    DarkSlateBlue(72, 61, 139), DarkSlateGray(47, 79, 79), &#13;
    DarkTurquoise(0, 206, 209), DarkViolet(148, 0, 211), &#13;
    DeepPink(255, 20, 147), DeepSkyBlue(0, 191, 255), &#13;
    DimGray(105, 105, 105), DodgerBlue(30, 144, 255), &#13;
    FireBrick(178, 34, 34), FloralWhite(255, 250, 240), &#13;
    ForestGreen(34, 139, 34), Fuchsia(255, 0, 255), &#13;
    Gainsboro(220, 220, 220), GhostWhite(248, 248, 255), &#13;
    Gold(255, 215, 0),  GoldenRod(218, 165, 32), &#13;
    Gray(127, 127, 127), Green(0, 128, 0), &#13;
    GreenYellow(173, 255, 47), HoneyDew(240, 255, 240), &#13;
    HotPink(255, 105, 180), IndianRed(205, 92, 92), &#13;
    Indigo(75, 0, 130), Ivory(255, 255, 240), &#13;
    Khaki(240, 230, 140), Lavender(230, 230, 250), &#13;
    LavenderBlush(255, 240, 245), Lawngreen(124, 252, 0), &#13;
    LemonChiffon(255, 250, 205), LightBlue(173, 216, 230), &#13;
    LightCoral(240, 128, 128), LightCyan(224, 255, 255), &#13;
    LightGoldenRodYellow(250, 250, 210), &#13;
    LightGreen(144, 238, 144), LightGray(211, 211, 211), &#13;
    LightPink(255, 182, 193), LightSalmon(255, 160, 122), &#13;
    LightSeaGreen(32, 178, 170), LightSkyBlue(135, 206, 250), &#13;
    LightSlateGray(119, 136, 153), LightSteelBlue(176, 196, 222), &#13;
    LightYellow(255, 255, 224), Lime(0, 255, 0), &#13;
    LimeGreen(50, 205, 50), Linen(250, 240, 230), &#13;
    Magenta(255, 0, 255), Maroon(128, 0, 0), &#13;
    MediumAquamarine(102, 205, 170), MediumBlue(0, 0, 205), &#13;
    MediumOrchid(186, 85, 211), MediumPurple(147, 112, 219), &#13;
    MediumSeaGreen(60, 179, 113), MediumSlateBlue(123, 104, 238), &#13;
    MediumSpringGreen(0, 250, 154), MediumTurquoise(72, 209, 204), &#13;
    MediumVioletRed(199, 21, 133), MidnightBlue(25, 25, 112), &#13;
    MintCream(245, 255, 250), MistyRose(255, 228, 225), &#13;
    Moccasin(255, 228, 181), NavajoWhite(255, 222, 173), &#13;
    Navy(0, 0, 128), Navyblue(159, 175, 223), &#13;
    OldLace(253, 245, 230), Olive(128, 128, 0), &#13;
    OliveDrab(107, 142, 35), Orange(255, 165, 0), &#13;
    OrangeRed(255, 69, 0), Orchid(218, 112, 214), &#13;
    PaleGoldenRod(238, 232, 170), PaleGreen(152, 251, 152), &#13;
    PaleTurquoise(175, 238, 238), PaleVioletRed(219, 112, 147), &#13;
    PapayaWhip(255, 239, 213), PeachPuff(255, 218, 185), &#13;
    Peru(205, 133, 63), Pink(255, 192, 203), &#13;
    Plum(221, 160, 221), PowderBlue(176, 224, 230), &#13;
    Purple(128, 0, 128), Red(255, 0, 0), &#13;
    RosyBrown(188, 143, 143), RoyalBlue(65, 105, 225), &#13;
    SaddleBrown(139, 69, 19), Salmon(250, 128, 114), &#13;
    SandyBrown(244, 164, 96), SeaGreen(46, 139, 87), &#13;
    SeaShell(255, 245, 238), Sienna(160, 82, 45), &#13;
    Silver(192, 192, 192), SkyBlue(135, 206, 235), &#13;
    SlateBlue(106, 90, 205), SlateGray(112, 128, 144), &#13;
    Snow(255, 250, 250), SpringGreen(0, 255, 127), &#13;
    SteelBlue(70, 130, 180), SystemColor(0, 0, 0), &#13;
    Tan(210, 180, 140), Teal(0, 128, 128), &#13;
    Thistle(216, 191, 216), Tomato(255, 99, 71), &#13;
    Turquoise(64, 224, 208), Violet(238, 130, 238), &#13;
    Wheat(245, 222, 179), White(255, 255, 255), &#13;
    WhiteSmoke(245, 245, 245), Yellow(255, 255, 0), &#13;
    YellowGreen(139, 205, 50); &#13;
}; &#13;
</pre></div>
<div class="section" title="The Font class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec62"/>The Font class</h1></div></div></div><p>The <code class="literal">Font</code> class is a wrapper class for the Win32 API <code class="literal">LOGFONT</code> structure. The structure holds a large set of properties; however, we only take into consideration the fields for the font's name and size and whether the font is italic, bold, or underlined; the other fields are set to zero. The system font is the font where all fields in the <code class="literal">LOGFONT</code> structure are set to zero, which results in the standard font of the system. Finally, the <code class="literal">Font</code> class also includes a <code class="literal">Color</code> object.</p><p>
<span class="strong"><strong>Font.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class Font; &#13;
  extern const Font SystemFont; &#13;
 &#13;
  class Font { &#13;
    public: &#13;
</pre><p>The default constructor sets the name to the empty string and all other values to zero, resulting in the system font, usually 10 points Arial. The size of the font is given in typographic points (1 point = 1/72 of an inch = 1/72 * 25.4 mm ≈ 0.35 mm). A font can also be initialized by, or assigned to, another font:</p><pre class="programlisting">      Font(); &#13;
      Font(String name, int size, &#13;
           bool italic = false, bool bold = false); &#13;
      Font(const Font&amp; Font); &#13;
      Font&amp; operator=(const Font&amp; font); &#13;
</pre><p>Two fonts are equal if they hold the same name and size as well as the same italic, bold, and underline status (all other fields are assumed to be zero):</p><pre class="programlisting">      bool operator==(const Font&amp; font) const; &#13;
      bool operator!=(const Font&amp; font) const; &#13;
</pre><p>The font can be written to, and read from, a file stream, the clipboard, and the registry:</p><pre class="programlisting">      bool WriteFontToStream(ostream&amp; outStream) const; &#13;
      bool ReadFontFromStream(istream&amp; inStream); &#13;
      void WriteFontToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadFontFromClipboard(InfoList&amp; infoList); &#13;
      void WriteFontToRegistry(String key); &#13;
      void ReadFontFromRegistry(String key, &#13;
                                Font defaultFont = SystemFont); &#13;
</pre><p>The <code class="literal">PointToMeters</code> function converts a typographic point to logical units (hundredths of millimeters):</p><pre class="programlisting">      void PointsToLogical(double zoom = 1.0); &#13;
</pre><p>The wrapped <code class="literal">LOGFONT</code> structure is inspected by the constant method and modified by the non-constant method:</p><pre class="programlisting">      LOGFONT LogFont() const {return logFont;} &#13;
      LOGFONT&amp; LogFont() {return logFont;} &#13;
</pre><p>The <code class="literal">color</code> field can also be inspected by the constant method and modified by the non-constant method:</p><pre class="programlisting">      Color FontColor() const {return color;} &#13;
      Color&amp; FontColor() {return color;} &#13;
 &#13;
&#13;
    private: &#13;
      LOGFONT logFont; &#13;
      Color color; &#13;
  }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Font.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  Font::Font() { &#13;
    memset(&amp;logFont, 0, sizeof logFont); &#13;
  } &#13;
 &#13;
  Font::Font(String name, int size, bool italic, bool bold) { &#13;
    memset(&amp;logFont, 0, sizeof logFont); &#13;
    wcscpy_s(logFont.lfFaceName, LF_FACESIZE, name.c_str()); &#13;
    logFont.lfHeight = size; &#13;
    logFont.lfItalic = (italic ? TRUE : FALSE); &#13;
    logFont.lfWeight = (bold ? FW_BOLD : FW_NORMAL); &#13;
  } &#13;
 &#13;
  Font::Font(const Font&amp; font) { &#13;
    logFont = font.LogFont(); &#13;
    color = font.color; &#13;
  } &#13;
 &#13;
  Font&amp; Font::operator=(const Font&amp; font) { &#13;
    if (this != &amp;font) { &#13;
      logFont = font.LogFont(); &#13;
      color = font.color; &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
</pre><p>Two fonts are equal if their wrapped <code class="literal">LOGFONT</code> structures and their <code class="literal">Color</code> fields are equal:</p><pre class="programlisting">  bool Font::operator==(const Font&amp; font) const { &#13;
    return (::memcmp(&amp;logFont, &amp;font.logFont, &#13;
                     sizeof logFont) == 0) &amp;&amp; &#13;
           (color == font.color); &#13;
  } &#13;
 &#13;
  bool Font::operator!=(const Font&amp; font) const { &#13;
    return !(*this == font); &#13;
  } &#13;
</pre><p>The <code class="literal">write</code> and <code class="literal">read</code> methods write and read the wrapped <code class="literal">LOGFONT</code> structure and call the <code class="literal">Color</code> write and read methods:</p><pre class="programlisting">  bool Font::WriteFontToStream(ostream&amp; outStream) const { &#13;
    outStream.write((char*) &amp;logFont, sizeof logFont); &#13;
    color.WriteColorToStream(outStream); &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool Font::ReadFontFromStream(istream&amp; inStream) { &#13;
    inStream.read((char*) &amp;logFont, sizeof logFont); &#13;
    color.ReadColorFromStream(inStream); &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  void Font::WriteFontToClipboard(InfoList&amp; infoList) const { &#13;
    infoList.AddValue&lt;LOGFONT&gt;(logFont); &#13;
    color.WriteColorToClipboard(infoList); &#13;
  }  &#13;
&#13;
  void Font::ReadFontFromClipboard(InfoList&amp; infoList) { &#13;
    infoList.GetValue&lt;LOGFONT&gt;(logFont); &#13;
    color.ReadColorFromClipboard(infoList); &#13;
  }  &#13;
&#13;
  void Font::WriteFontToRegistry(String key) { &#13;
    Registry::WriteBuffer(key, &amp;logFont, sizeof logFont); &#13;
    color.WriteColorToRegistry(key); &#13;
  }  &#13;
&#13;
  void Font::ReadFontFromRegistry(String key, &#13;
                         Font defaultFont /* = SystemFont */) { &#13;
    Registry::ReadBuffer(key, &amp;logFont, sizeof logFont, &#13;
                         &amp;defaultFont.logFont); &#13;
    color.ReadColorFromRegistry(key); &#13;
  } &#13;
</pre><p>A typographic point is 1/72<sup>th</sup> of an inch, and an inch is 25.4 millimeters. To transform a font typographical unit to logical units (hundredths of millimeters), we divide the width and height by 72, multiply by 2,540 (2,540 logical units equals 25.4 millimeters) and the zoom factor:</p><pre class="programlisting">  void Font::PointsToLogical(double zoom /* = 1.0 */) { &#13;
    logFont.lfWidth = &#13;
      (int) (zoom * 2540.0 * logFont.lfWidth / 72.0); &#13;
    logFont.lfHeight = &#13;
      (int) (zoom * 2540.0 * logFont.lfHeight / 72.0); &#13;
  }  &#13;
&#13;
  const Font SystemFont; &#13;
}; &#13;
</pre></div>
<div class="section" title="The Cursor class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec63"/>The Cursor class</h1></div></div></div><p>There is a set of cursors available in the Win32 API, all with names starting with <code class="literal">IDC_</code>. In Small Windows, they have been given other names, which are hopefully easier to understand. Unlike other cases, we cannot use an enumeration for the cursors, since they are actually zero-terminated C++ strings (character pointers). Instead, every cursor is a pointer to a zero-terminated string. <code class="literal">LPCTSTR</code> stands for <span class="strong"><strong>Long Pointer to  Constant TChar String</strong></span>.</p><p>The reason the cursor has its own class, while the caret has a method in the <code class="literal">Document</code> class is that the caret does need a window handle to be set, while the cursor does not.</p><p>
<span class="strong"><strong>Cursor.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  typedef LPCTSTR CursorType; &#13;
 &#13;
  class Cursor { &#13;
    public: &#13;
      static const CursorType Normal; &#13;
      static const CursorType Arrow; &#13;
      static const CursorType ArrowHourGlass; &#13;
      static const CursorType Crosshair; &#13;
      static const CursorType Hand; &#13;
      static const CursorType ArrowQuestionMark; &#13;
      static const CursorType IBeam; &#13;
      static const CursorType SlashedCircle; &#13;
      static const CursorType SizeAll; &#13;
      static const CursorType SizeNorthEastSouthWest; &#13;
      static const CursorType SizeNorthSouth; &#13;
      static const CursorType SizeNorthWestSouthEast; &#13;
      static const CursorType SizeWestEast; &#13;
      static const CursorType VerticalArrow; &#13;
      static const CursorType HourGlass; &#13;
 &#13;
      static void Set(CursorType cursor); &#13;
   }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Cursor.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  const CursorType Cursor::Normal = IDC_ARROW; &#13;
  const CursorType Cursor::Arrow = IDC_ARROW; &#13;
  const CursorType Cursor::ArrowHourGlass = IDC_APPSTARTING; &#13;
  const CursorType Cursor::Crosshair = IDC_CROSS; &#13;
  const CursorType Cursor::Hand = IDC_HAND; &#13;
  const CursorType Cursor::ArrowQuestionMark = IDC_HELP; &#13;
  const CursorType Cursor::IBeam = IDC_IBEAM; &#13;
  const CursorType Cursor::SlashedCircle = IDC_NO; &#13;
  const CursorType Cursor::SizeAll = IDC_SIZEALL; &#13;
  const CursorType Cursor::SizeNorthEastSouthWest = IDC_SIZENESW; &#13;
  const CursorType Cursor::SizeNorthSouth = IDC_SIZENS; &#13;
  const CursorType Cursor::SizeNorthWestSouthEast = IDC_SIZENWSE; &#13;
  const CursorType Cursor::SizeWestEast = IDC_SIZEWE; &#13;
  const CursorType Cursor::VerticalArrow = IDC_UPARROW; &#13;
  const CursorType Cursor::HourGlass = IDC_WAIT; &#13;
</pre><p>The <code class="literal">Set</code> method sets the cursor by calling the Win32 API functions <code class="literal">LoadCursor</code> and <code class="literal">SetCursor</code>:</p><pre class="programlisting">  void Cursor::Set(CursorType cursor) { &#13;
    ::SetCursor(::LoadCursor(nullptr, cursor)); &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="The DynamicList class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec64"/>The DynamicList class</h1></div></div></div><p>The <code class="literal">DynamicList</code> class can be regarded as a more advanced version of the C++ standard classes <code class="literal">list</code> and <code class="literal">vector</code>. It varies its size dynamically:</p><p>
<span class="strong"><strong>DynamicList.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  template &lt;class Type&gt; &#13;
  class DynamicList { &#13;
    public: &#13;
</pre><p>The <code class="literal">IfFuncPtr</code> pointer is a function prototype that is used when testing (without changing) a value in the list. It takes a constant value and a <code class="literal">void</code> pointer and returns a <code class="literal">Boolean</code> value. <code class="literal">DoFuncPtr</code> is used when changing a value in the list and takes a (non-constant) value and a <code class="literal">void</code> pointer. The void pointers are sent by the calling methods; they hold additional information:</p><pre class="programlisting">      typedef bool (*IfFuncPtr)(const Type&amp; value, void* voidPtr); &#13;
      typedef void (*DoFuncPtr)(Type&amp; value, void* voidPtr); &#13;
</pre><p>The list can be initialized by, and assigned to, another list. The default constructor creates an empty list, and the destructor deallocates the memory from the list:</p><pre class="programlisting">      DynamicList(); &#13;
      DynamicList(const DynamicList&amp; list); &#13;
      DynamicList&amp; operator=(const DynamicList&amp; list); &#13;
      ~DynamicList(); &#13;
</pre><p>The <code class="literal">Empty</code> function returns <code class="literal">true</code> if the list is empty, <code class="literal">Size</code> returns the number of values in the list, <code class="literal">Clear</code> removes every value in the list, and <code class="literal">IndexOf</code> gives the zero-based index of the given value, or returns minus one if there is no such value in the list:</p><pre class="programlisting">      bool Empty() const; &#13;
      int Size() const; &#13;
      void Clear(); &#13;
      int IndexOf(Type&amp; value) const; &#13;
</pre><p>The <code class="literal">begin</code> and <code class="literal">end</code> methods return pointers to the beginning and end of the list. They are included in order for the list to be iterated by the <code class="literal">for</code> statement:</p><pre class="programlisting">      Type* begin(); &#13;
      const Type* begin() const; &#13;
      Type* end(); &#13;
      const Type* end() const; &#13;
</pre><p>The index method inspects or modifies the value with the given zero-based index in the list:</p><pre class="programlisting">      Type operator[](int index) const; &#13;
      Type&amp; operator[](int index); &#13;
</pre><p>The <code class="literal">Front</code> and <code class="literal">Back</code> methods inspect and modify the first and the last value of the list by calling the index methods mentioned previously:</p><pre class="programlisting">      Type Front() const {return (*this)[0];} &#13;
      Type&amp; Front() {return (*this)[0];} &#13;
      Type Back() const {return (*this)[size - 1];} &#13;
      Type&amp; Back() {return (*this)[size - 1];} &#13;
</pre><p>The <code class="literal">PushFront</code> and <code class="literal">PushBack</code> methods add a value or a list at the beginning or at the end of the list, and <code class="literal">Insert</code> inserts a value or a list at the given index:</p><pre class="programlisting">      void PushBack(const Type&amp; value); &#13;
      void PushBack(const DynamicList&amp; list); &#13;
      void PushFront(const Type&amp; value); &#13;
      void PushFront(const DynamicList&amp; list); &#13;
      void Insert(int index, const Type&amp; value); &#13;
      void Insert(int index, const DynamicList&amp; list); &#13;
</pre><p>The <code class="literal">Erase</code> function deletes the value at the given index, and <code class="literal">Remove</code> deletes the list from <code class="literal">firstIndex</code> to <code class="literal">lastIndex</code>, inclusive, or the end of the list if <code class="literal">lastIndex</code> is minus one. If <code class="literal">firstIndex</code> is zero and <code class="literal">lastIndex</code> is minus one, the whole list is deleted. The methods have been given different names since <code class="literal">lastIndex</code> in <code class="literal">Remove</code> is a default parameter. Giving the methods the same name would be a violation of the overload rules:</p><pre class="programlisting">      void Erase(int deleteIndex); &#13;
      void Remove(int firstIndex = 0, int lastIndex = -1); &#13;
</pre><p>The <code class="literal">Copy</code> function copies the list from <code class="literal">firstIndex</code> to <code class="literal">lastIndex</code>, inclusive, to <code class="literal">copyList</code> or the rest of the list if <code class="literal">lastIndex</code> is minus one, which implies that the whole list is copied if <code class="literal">firstIndex</code> is zero and <code class="literal">lastIndex</code> is minus one:</p><pre class="programlisting">      void Copy(DynamicList&amp; copyList, int firstIndex = 0, &#13;
                int lastIndex = -1) const; &#13;
</pre><p>The <code class="literal">AnyOf</code> function returns <code class="literal">true</code> if at least one value satisfies <code class="literal">ifFuncPtr</code>. That is, if <code class="literal">ifFuncPtr</code> returns <code class="literal">true</code> when called with the value as parameter. The <code class="literal">AllOf</code> function returns <code class="literal">true</code> if all values satisfy <code class="literal">ifFuncPtr</code>:</p><pre class="programlisting">      bool AnyOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) &#13;
                 const; &#13;
      bool AllOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) &#13;
                 const; &#13;
</pre><p>The <code class="literal">FirstOf</code> and <code class="literal">LastOf</code> methods set the <code class="literal">value</code> parameter to the first and last value satisfying <code class="literal">ifFuncPtr</code>; they return <code class="literal">false</code> is there are no such values:</p><pre class="programlisting">      bool FirstOf(IfFuncPtr ifFuncPtr, Type&amp; value, &#13;
                   void* ifVoidPtr = nullptr) const; &#13;
      bool LastOf(IfFuncPtr ifFuncPtr, Type&amp; value, &#13;
                  void* ifVoidPtr = nullptr) const; &#13;
</pre><p>The <code class="literal">Apply</code> method calls <code class="literal">doFuncPtr</code> for all values in the list, and <code class="literal">ApplyIf</code> calls <code class="literal">doFuncPtr</code> for each value in the list that satisfies <code class="literal">ifFuncPtr</code>:</p><pre class="programlisting">      void Apply(DoFuncPtr doFuncPtr, void* ifVoidPtr = nullptr); &#13;
      void ApplyIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, &#13;
                   void* ifVoidPtr = nullptr, &#13;
                   void* doVoidPtr = nullptr); &#13;
</pre><p>The <code class="literal">CopyIf</code> method copies each value in the list satisfying <code class="literal">ifFuncPtr</code> to <code class="literal">copyList</code>. <code class="literal">RemoveIf</code> removes the values satisfying <code class="literal">ifFuncPtr</code>:</p><pre class="programlisting">      void CopyIf(IfFuncPtr ifFuncPtr, DynamicList&amp; copyList, &#13;
                  void* ifVoidPtr = nullptr) const; &#13;
      void RemoveIf(IfFuncPtr ifFuncPtr, &#13;
                    void* ifVoidPtr = nullptr); &#13;
</pre><p>The <code class="literal">ApplyRemoveIf</code> method calls <code class="literal">doFuncPtr</code> to each value satisfying <code class="literal">ifFuncPtr</code> and then removes them. It may seem strange to apply a function to values that are to be removed. However, it is useful when removing dynamically allocated values, where <code class="literal">doFuncPtr</code> deallocates the memory of each value before it is removed from the list. It would not work to simply call <code class="literal">ApplyIf</code> and <code class="literal">RemoveIf</code>. When the values have been deleted by <code class="literal">ApplyIf</code>, they cannot be parameters to <code class="literal">ifFuncPtr</code> calls in <code class="literal">RemoveIf</code>:</p><pre class="programlisting">      void ApplyRemoveIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, &#13;
                         void* ifVoidPtr=nullptr, &#13;
                         void* doVoidPtr=nullptr); &#13;
</pre><p>The size is the number of values in the list and the buffer holds the values themselves. The size of the buffer is dynamic and changes when values are added to, or removed from, the list. When the list is empty, the buffer points are null:</p><pre class="programlisting">    private: &#13;
      int size; &#13;
      Type* buffer; &#13;
  }; &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  DynamicList&lt;Type&gt;::DynamicList() &#13;
   :size(0), &#13;
    buffer(nullptr) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The default constructor and assignment operator iterates through the given list and copies each value. For this to work, the type must support the assignment operator, which all types, except arrays, do:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  DynamicList&lt;Type&gt;::DynamicList(const DynamicList&amp; list) &#13;
   :size(list.size), &#13;
    buffer(new Type[list.size]) { &#13;
    assert(buffer != nullptr);  &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      buffer[index] = list.buffer[index]; &#13;
    } &#13;
  } &#13;
</pre><p>In the assignment operator, we first delete the buffer, as it may hold values. If the list is empty, the buffer points are null and the delete operator does nothing:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  DynamicList&lt;Type&gt;&amp; DynamicList&lt;Type&gt;::operator= &#13;
                                      (const DynamicList&amp; list) { &#13;
    if (this != &amp;list) { &#13;
      delete[] buffer; &#13;
      size = list.size; &#13;
      assert((buffer = new Type[size]) != nullptr); &#13;
 &#13;
      for (int index = 0; index &lt; size; ++index) { &#13;
        buffer[index] = list.buffer[index]; &#13;
      } &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
</pre><p>The destructor simply deletes the buffer. Again, if the list is empty, the buffer points are null and the delete operator does nothing:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  DynamicList&lt;Type&gt;::~DynamicList() { &#13;
    delete[] buffer; &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  bool DynamicList&lt;Type&gt;::Empty() const { &#13;
    return (size == 0); &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  int DynamicList&lt;Type&gt;::Size() const { &#13;
    return size; &#13;
  } &#13;
</pre><p>The <code class="literal">Clear</code> method sets the size to zero and the buffer to null:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Clear() { &#13;
    size = 0; &#13;
    delete[] buffer; &#13;
    buffer = nullptr; &#13;
  } &#13;
 &#13;
</pre><p>The <code class="literal">IndexOf</code> method iterates through the list and returns the index of the found value, or it returns minus one if there is no such value:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  int DynamicList&lt;Type&gt;::IndexOf(Type&amp; value) const { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
&#13;
      if (buffer[index] == value) { &#13;
        return index; &#13;
      } &#13;
    } &#13;
 &#13;
    return -1; &#13;
  } &#13;
</pre><p>The <code class="literal">begin</code> method returns the address of the first value in the list:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  Type* DynamicList&lt;Type&gt;::begin() { &#13;
    return &amp;buffer[0]; &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  const Type* DynamicList&lt;Type&gt;::begin() const { &#13;
    return &amp;buffer[0]; &#13;
  } &#13;
</pre><p>The <code class="literal">end</code> method returns the address one step beyond the last value in the list, which is the convention of list iterators in C++:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  Type* DynamicList&lt;Type&gt;::end() { &#13;
    return &amp;buffer[size]; &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  const Type* DynamicList&lt;Type&gt;::end() const { &#13;
    return &amp;buffer[size]; &#13;
  } &#13;
</pre><p>An assertion occurs if the index is beyond the list:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  Type DynamicList&lt;Type&gt;::operator[](int index) const { &#13;
    assert((index &gt;= 0) &amp;&amp; (index &lt; size)); &#13;
    return buffer[index]; &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  Type&amp; DynamicList&lt;Type&gt;::operator[](int index) { &#13;
    assert((index &gt;= 0) &amp;&amp; (index &lt; size)); &#13;
    return buffer[index]; &#13;
  } &#13;
</pre><p>When adding a value at the end of the original list, we need to allocate a new list with one extra value and add the new value at the end:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::PushBack(const Type&amp; value) { &#13;
    Type* newBuffer = new Type[size + 1]; &#13;
    assert(newBuffer != nullptr); &#13;
 &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    } &#13;
 &#13;
    newBuffer[size++] = value; &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
  } &#13;
</pre><p>When adding a new list at the end of the original list, we need to allocate a new list with the size of the original and new lists, and copy the values from the original list to the new list:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::PushBack(const DynamicList&amp; list) { &#13;
    Type* newBuffer = new Type[size + list.size]; &#13;
    assert(newBuffer != nullptr); &#13;
 &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    } &#13;
 &#13;
    for (int index = 0; index &lt; list.size; ++index) { &#13;
      newBuffer[size + index] = list.buffer[index]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    size += list.size; &#13;
  } &#13;
</pre><p>When inserting a new value at the beginning of the list, we need to copy all the values in the original list one step forward to make room for the new value:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::PushFront(const Type&amp; value) { &#13;
    Type* newBuffer = new Type[size + 1]; &#13;
    assert(newBuffer != nullptr); &#13;
    newBuffer[0] = value; &#13;
 &#13;
&#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      newBuffer[index + 1] = buffer[index]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    ++size; &#13;
  } &#13;
</pre><p>When inserting a new list, at the beginning of the list, we need to copy all its values and the number of steps corresponding to the size of the new list to make room for its values:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::PushFront(const DynamicList&amp; list) { &#13;
    Type* newBuffer = new Type[size + list.size]; &#13;
    assert(newBuffer != nullptr); &#13;
</pre><p>We move the values of the original list in order to make room for the new list:</p><pre class="programlisting">    for (int index = 0; index &lt; list.size; ++index) { &#13;
      newBuffer[index] = list.buffer[index]; &#13;
    } &#13;
</pre><p>When we have made room for the new list, we copy it to the original list at the beginning:</p><pre class="programlisting">    for (int index = 0; index &lt; size; ++index) { &#13;
      newBuffer[index + list.size] = buffer[index]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    size += list.size; &#13;
  } &#13;
</pre><p>The <code class="literal">Insert</code> method works in ways similar to <code class="literal">PushFront</code>. We need to allocate a new list and copy values in the original list to make room for the new values, and then copy the new values into the original list:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Insert(int insertIndex, &#13;
                                 const Type&amp; value) { &#13;
    assert((insertIndex &gt;= 0) &amp;&amp; (insertIndex &lt;= size)); &#13;
    Type* newBuffer = new Type[size + 1]; &#13;
    assert(newBuffer != nullptr); &#13;
 &#13;
    for (int index = 0; index &lt; insertIndex; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    } &#13;
 &#13;
    newBuffer[insertIndex] = value; &#13;
 &#13;
    for (int index = 0; index &lt; (size - insertIndex); ++index) { &#13;
      newBuffer[insertIndex + index + 1] = &#13;
        buffer[insertIndex + index]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    ++size; &#13;
  } &#13;
 &#13;
  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Insert(int insertIndex, &#13;
                                 const DynamicList&amp; list){ &#13;
    assert((insertIndex &gt;= 0) &amp;&amp; (insertIndex &lt;= size)); &#13;
    Type* newBuffer = new Type[size + list.size]; &#13;
    assert(newBuffer != nullptr); &#13;
 &#13;
    for (int index = 0; index &lt; insertIndex; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    } &#13;
 &#13;
    for (int index = 0; index &lt; list.size; ++index) { &#13;
      newBuffer[insertIndex + index] = list.buffer[index]; &#13;
    } &#13;
 &#13;
    for (int index = 0; index &lt; (size - insertIndex); ++index) { &#13;
      newBuffer[insertIndex + index + list.size] = &#13;
        buffer[insertIndex + index]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    size += list.size; &#13;
  } &#13;
</pre><p>When erasing a value in the list, we allocate a new smaller list and copy the remaining values to that list:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Erase(int eraseIndex) { &#13;
    assert((eraseIndex &gt;= 0) &amp;&amp; (eraseIndex &lt; size)); &#13;
    Type* newBuffer = new Type[size - 1]; &#13;
    assert(newBuffer != nullptr); &#13;
</pre><p>First, we copy the values before the delete index:</p><pre class="programlisting">    for (int index = 0; index &lt; eraseIndex; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    } &#13;
</pre><p>Then, we copy the values after the delete index:</p><pre class="programlisting">    for (int index = 0; index &lt; (size - (eraseIndex + 1)); &#13;
         ++index) { &#13;
      newBuffer[eraseIndex + index] = &#13;
        buffer[eraseIndex + index + 1]; &#13;
    } &#13;
 &#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    --size; &#13;
  } &#13;
</pre><p>The <code class="literal">Remove</code> method works in the same way as <code class="literal">Delete</code>; the difference is that more than one value can be removed from the list; <code class="literal">removeSize</code> holds the number of values to be removed:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Remove(int firstIndex /* = 0 */,  &#13;
                                 int lastIndex /* = -1 */) { &#13;
    if (lastIndex == -1) { &#13;
      lastIndex = size - 1; &#13;
    } &#13;
 &#13;
    assert((firstIndex &gt;= 0) &amp;&amp; (firstIndex &lt; size)); &#13;
    assert((lastIndex &gt;= 0) &amp;&amp; (lastIndex &lt; size)); &#13;
    assert(firstIndex &lt;= lastIndex); &#13;
 &#13;
    int removeSize = lastIndex - firstIndex + 1; &#13;
    Type* newBuffer = new Type[size - removeSize]; &#13;
    assert(newBuffer != nullptr);  &#13;
    for (int index = 0; index &lt; firstIndex; ++index) { &#13;
      newBuffer[index] = buffer[index]; &#13;
    }  &#13;
&#13;
    for (int index = 0; &#13;
         index &lt; (size - (firstIndex + removeSize)); ++index){ &#13;
      newBuffer[firstIndex + index] = &#13;
        buffer[firstIndex + index + removeSize]; &#13;
    }  &#13;
&#13;
    delete[] buffer; &#13;
    buffer = newBuffer; &#13;
    size -= removeSize; &#13;
  } &#13;
</pre><p>The <code class="literal">Copy</code> method simply calls <code class="literal">PushBack</code> for each value to be copied:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Copy(DynamicList&amp; copyList,&#13;
                               int firstIndex/* =0 */,&#13;
                               int lastIndex /* = -1 */) const {&#13;
    if (lastIndex == -1) { &#13;
      lastIndex = size - 1; &#13;
    } &#13;
 &#13;
    assert((firstIndex &gt;= 0) &amp;&amp; (firstIndex &lt; size)); &#13;
    assert((lastIndex &gt;= 0) &amp;&amp; (lastIndex &lt; size)); &#13;
    assert(firstIndex &lt;= lastIndex); &#13;
 &#13;
    for (int index = firstIndex; index &lt;= lastIndex; ++index) { &#13;
      copyList.PushBack(buffer[index]); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">AnyOf</code> method iterates through the list and returns <code class="literal">true</code> if at least one value satisfies the function:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  bool DynamicList&lt;Type&gt;::AnyOf(IfFuncPtr ifFuncPtr, &#13;
                          void* ifVoidPtr /* = nullptr */) const { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        return true; &#13;
      } &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">AllOf</code> method iterates through the list and returns <code class="literal">false</code> if at least one value does not satisfy the function:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  bool DynamicList&lt;Type&gt;::AllOf(IfFuncPtr ifFuncPtr, &#13;
                          void* ifVoidPtr /* = nullptr */) const { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (!ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        return false; &#13;
      } &#13;
    } &#13;
 &#13;
    return true; &#13;
  } &#13;
</pre><p>The <code class="literal">FirstOf</code> method finds the first value in the list that satisfies the function, copies it to the value parameter, and returns <code class="literal">true</code>. If it does not find any value satisfying the function, <code class="literal">false</code> is returned:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  bool DynamicList&lt;Type&gt;::FirstOf(IfFuncPtr ifFuncPtr, &#13;
              Type&amp; value, void* ifVoidPtr /* = nullptr */) const{ &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        value = buffer[index]; &#13;
        return true; &#13;
      } &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">LastOf</code> method finds the last value satisfying the function in the same way as <code class="literal">FirstOf</code>; the difference is that the search is performed backward:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  bool DynamicList&lt;Type&gt;::LastOf(IfFuncPtr ifFuncPtr, Type&amp; value, &#13;
                          void* ifVoidPtr /* = nullptr */) const { &#13;
    for (int index = (size - 1); index &gt;= 0; --index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        value = buffer[index]; &#13;
        return true; &#13;
      } &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">Apply</code> method iterates through the list and calls <code class="literal">doFuncPtr</code> for each value, the value may be modified (actually, the point of <code class="literal">Apply</code> is that the value is modified) since the parameter to <code class="literal">doFuncPtr</code> is not constant:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::Apply(DoFuncPtr doFuncPtr, &#13;
                                void* doVoidPtr /* = nullptr */) { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      doFuncPtr(buffer[index], doVoidPtr); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">ApplyIf</code> method iterates through the list and calls <code class="literal">doFuncPtr</code> for each value that satisfies <code class="literal">ifFuncPtr</code>:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::ApplyIf(IfFuncPtr ifFuncPtr, &#13;
         DoFuncPtr doFuncPtr, void* ifVoidPtr /* = nullptr */, &#13;
         void* doVoidPtr /* = nullptr */){ &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        doFuncPtr(buffer[index], doVoidPtr); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">CopyIf</code> method copies every value that satisfies <code class="literal">ifFuncPtr</code> to <code class="literal">copyList</code> by calling <code class="literal">PushBack</code>:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::CopyIf(IfFuncPtr ifFuncPtr, &#13;
                          DynamicList&amp; copyList, &#13;
                          void* ifVoidPtr /* = nullptr */) const { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        copyList.PushBack(buffer[index]); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">RemoveIf</code> method removes every value that satisfies <code class="literal">ifFuncPtr</code> by calling <code class="literal">Delete</code> for each value:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::RemoveIf(IfFuncPtr ifFuncPtr, &#13;
                                void* ifVoidPtr /* = nullptr */) { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        Erase(index--); &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">ApplyRemoveIf</code> method applies <code class="literal">doFuncPtr</code> to each value that satisfies <code class="literal">ifFuncPtr</code>. We cannot simply call <code class="literal">Apply</code> and <code class="literal">RemoveIf</code>, since <code class="literal">doFuncPtr</code> may deallocate the values in <code class="literal">Apply</code>, and <code class="literal">ifFuncPtr</code> in <code class="literal">RemoveIf</code> would not work when called on deleted values. Instead, we call <code class="literal">doFuncPtr</code> and call <code class="literal">Erase</code> immediately after. In this way, the values are not accessed after the call to <code class="literal">doFuncPtr</code>:</p><pre class="programlisting">  template &lt;class Type&gt; &#13;
  void DynamicList&lt;Type&gt;::ApplyRemoveIf(IfFuncPtr ifFuncPtr, &#13;
         DoFuncPtr doFuncPtr, void* ifVoidPtr /* = nullptr */, &#13;
         void* doVoidPtr /* = nullptr */) { &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (ifFuncPtr(buffer[index], ifVoidPtr)) { &#13;
        doFuncPtr(buffer[index], doVoidPtr); &#13;
        Erase(index--); &#13;
      } &#13;
    } &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="The Tree class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec65"/>The Tree class</h1></div></div></div><p>The C++ standard library hold a set of container classes for arrays, lists, vectors, sets, and maps. However, there is no class for a tree structure. Therefore, the <code class="literal">Tree</code> class has been added to Small Windows. A tree is made up of a set of nodes, among which, one is the root node. Each node holds a (possibly empty) list of child nodes:</p><p>
<span class="strong"><strong>Tree.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  template &lt;class NodeType&gt; &#13;
  class Tree { &#13;
    public: &#13;
      Tree(); &#13;
      Tree(NodeType nodeValue, &#13;
           initializer_list&lt;Tree&lt;NodeType&gt;*&gt; childList = {}); &#13;
      Tree(const Tree&amp; tree); &#13;
      Tree&amp; operator=(const Tree&amp; tree); &#13;
      void Init(const Tree&amp; tree); &#13;
      ~Tree(); &#13;
</pre><p>The tree can be written to, and read from, a file stream or the clipboard:</p><pre class="programlisting">      bool WriteTreeToStream(ostream&amp; outStream) const; &#13;
      bool ReadTreeFromStream(istream&amp; inStream); &#13;
      void WriteTreeToClipboard(InfoList&amp; infoList) const; &#13;
      void ReadTreeFromClipboard(InfoList&amp; infoList); &#13;
</pre><p>Each tree node holds a value that is inspected by the constant method and modified by the non-constant method:</p><pre class="programlisting">      NodeType NodeValue() const {return nodeValue;} &#13;
      NodeType&amp; NodeValue() {return nodeValue;} &#13;
</pre><p>The tree node also holds a list of child nodes, which is inspected by the constant method and modified by the non-constant method:</p><pre class="programlisting">      const DynamicList&lt;Tree*&gt;&amp; ChildList() const &#13;
                                            {return childList;} &#13;
      DynamicList&lt;Tree*&gt;&amp; ChildList() {return childList;} &#13;
&#13;
     private: &#13;
      NodeType nodeValue; &#13;
     DynamicList&lt;Tree*&gt; childList; &#13;
  }; &#13;
 &#13;
  template &lt;class NodeType&gt; &#13;
  Tree&lt;NodeType&gt;::Tree() { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The child list is an initializer list of tree nodes; it is empty by default:</p><pre class="programlisting">  template &lt;class NodeType&gt;   &#13;
  Tree&lt;NodeType&gt;::Tree(NodeType nodeValue, &#13;
           initializer_list&lt;Tree&lt;NodeType&gt;*&gt; childList /* = {} */) &#13;
   :nodeValue(nodeValue) { &#13;
    for (Tree&lt;NodeType&gt;* childNodePtr : childList) { &#13;
      this-&gt;childList.PushBack(childNodePtr); &#13;
    } &#13;
  } &#13;
</pre><p>The default constructor and the assignment operator call <code class="literal">Init</code> to do the actual initialization of the tree:</p><pre class="programlisting">  template &lt;class NodeType&gt; &#13;
  Tree&lt;NodeType&gt;::Tree(const Tree&amp; tree) { &#13;
    Init(tree); &#13;
  } &#13;
 &#13;
  template &lt;class NodeType&gt; &#13;
  Tree&lt;NodeType&gt;&amp; Tree&lt;NodeType&gt;::operator=(const Tree&amp; tree) { &#13;
    if (this != &amp;tree) { &#13;
      Init(tree); &#13;
    } &#13;
 &#13;
    return *this; &#13;
  } &#13;
 &#13;
&#13;
&#13;
&#13;
  template &lt;class NodeType&gt; &#13;
  void Tree&lt;NodeType&gt;::Init(const Tree&amp; tree) { &#13;
    nodeValue = tree.nodeValue; &#13;
 &#13;
    for (Tree* childPtr : tree.childList) { &#13;
      Tree* childClonePtr = new Tree(*childPtr); &#13;
      assert(childClonePtr != nullptr); &#13;
      childList.PushBack(childClonePtr); &#13;
    } &#13;
  } &#13;
</pre><p>The destructor deletes the children recursively:</p><pre class="programlisting">  template &lt;class NodeType&gt; &#13;
  Tree&lt;NodeType&gt;::~Tree() { &#13;
    for (Tree* childPtr : childList) { &#13;
      delete childPtr; &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">WriteTreeToStream</code> method writes the node value and the number of children to the stream, and then calls itself recursively for each child:</p><pre class="programlisting">  template &lt;class NodeType&gt; &#13;
  bool Tree&lt;NodeType&gt;::WriteTreeToStream(ostream&amp; outStream)const{ &#13;
    nodeValue.WriteTreeNodeToStream(outStream);  &#13;
&#13;
    int childListSize = childList.Size(); &#13;
    outStream.write((char*) &amp;childListSize, sizeof childListSize);  &#13;
&#13;
    for (Tree* childPtr : childList) { &#13;
      childPtr-&gt;WriteTreeToStream(outStream); &#13;
    } &#13;
 &#13;
    return ((bool) outStream); &#13;
  } &#13;
</pre><p>The <code class="literal">ReadTreeFromStream</code> method reads the node value and the number of children from the stream, creates the children, and calls itself recursively for each child:</p><pre class="programlisting">  template &lt;class NodeType&gt; &#13;
  bool Tree&lt;NodeType&gt;::ReadTreeFromStream(istream&amp; inStream) { &#13;
    nodeValue.ReadTreeNodeFromStream(inStream);  &#13;
&#13;
    int childListSize; &#13;
    inStream.read((char*) &amp;childListSize, sizeof childListSize); &#13;
&#13;
&#13;
    for (int count = 0; count &lt; childListSize; ++count) { &#13;
      Tree* childPtr = new Tree(); &#13;
      assert(childPtr != nullptr); &#13;
      childPtr-&gt;ReadTreeFromStream(inStream); &#13;
      childList.PushBack(childPtr); &#13;
    } &#13;
 &#13;
    return ((bool) inStream); &#13;
  } &#13;
</pre><p>The <code class="literal">WriteTreeToClipboard</code> and <code class="literal">ReadTreeFromClipboard</code> methods work in ways similar to <code class="literal">WriteTreeToStream</code> and <code class="literal">ReadTreeFromStream</code>:</p><pre class="programlisting">  template &lt;class NodeType&gt; &#13;
  void Tree&lt;NodeType&gt;::WriteTreeToClipboard(InfoList&amp; infoList) &#13;
                                            const { &#13;
    nodeValue.WriteTreeNodeToClipboard(infoList); &#13;
 &#13;
    infoList.AddValue&lt;int&gt;( childList.Size()); &#13;
 &#13;
    for (Tree* childPtr : childList) { &#13;
      childPtr-&gt;WriteTreeToClipboard(infoList); &#13;
    } &#13;
  } &#13;
 &#13;
  template &lt;class NodeType&gt; &#13;
  void Tree&lt;NodeType&gt;::ReadTreeFromClipboard(InfoList&amp; infoList) { &#13;
    nodeValue.ReadTreeNodeFromClipboard(infoList); &#13;
 &#13;
    int childListSize; &#13;
    infoList.GetValue&lt;int&gt;(childListSize); &#13;
 &#13;
    for (int count = 0; count &lt; childListSize; ++count) { &#13;
      Tree* childPtr = new Tree(); &#13;
      assert(childPtr != nullptr); &#13;
      childPtr-&gt;ReadTreeFromClipboard(infoList); &#13;
      childList.PushBack(childPtr); &#13;
    } &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="The InfoList class"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec66"/>The InfoList class</h1></div></div></div><p>The <code class="literal">InfoList</code> class is an auxiliary class with template methods that stores information in a character list; information can be added and extracted; or written to, or read from, a buffer.</p><p>
<span class="strong"><strong>InfoList</strong></span>
<span class="strong"><strong>.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class InfoList { &#13;
    public: &#13;
      template &lt;class AlignType&gt; void Align(); &#13;
      template &lt;class ListType&gt; &#13;
        void AddValue(const ListType value); &#13;
      template &lt;class ListType&gt; &#13;
        void PeekValue(ListType&amp; value, int index); &#13;
      template &lt;class ListType&gt; void GetValue(ListType&amp; value); &#13;
      template &lt;class CharType&gt; &#13;
        void AddString(basic_string&lt;CharType&gt; text); &#13;
      template &lt;class CharType&gt; &#13;
        basic_string&lt;CharType&gt; GetString(); &#13;
      void FromBuffer(const void* voidBuffer, int size); &#13;
      void ToBuffer(void* voidBuffer); &#13;
      int Size() const {return list.Size();} &#13;
 &#13;
    private: &#13;
      DynamicList&lt;char&gt; list; &#13;
  }; &#13;
</pre><p>The <code class="literal">Align</code> function increases the list one byte at a time until the size of the align type is a divisor of the list size:</p><pre class="programlisting">  template &lt;class AlignType&gt; &#13;
  void InfoList::Align() { &#13;
    int size = sizeof(AlignType); &#13;
 &#13;
    while ((list.Size() % size) &gt; 0) { &#13;
      list.PushBack(0); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">AddValue</code> function adds a value of the template type by adding its value byte by byte to the list, while <code class="literal">GetValue</code> gets the value at the beginning of the list by extracting it byte by byte from the list:</p><pre class="programlisting">  template &lt;class ListType&gt; &#13;
  void InfoList::AddValue(const ListType value) { &#13;
    int size = sizeof(ListType); &#13;
    const char* buffer = (char*) &amp;value; &#13;
 &#13;
    for (int count = 0; count &lt; size; ++count) { &#13;
      list.PushBack(*(buffer++)); &#13;
    } &#13;
  } &#13;
 &#13;
  template &lt;class ListType&gt; &#13;
  void InfoList::PeekValue(ListType&amp; value, int index) { &#13;
    int size = sizeof(ListType); &#13;
    char* buffer = (char*) &amp;value; &#13;
 &#13;
    for (int count = 0; count &lt; size; ++count) { &#13;
      *(buffer++) = list[index + count]; &#13;
    } &#13;
  } &#13;
 &#13;
  template &lt;class ListType&gt; &#13;
  void InfoList::GetValue(ListType&amp; value) { &#13;
    int size = sizeof(ListType); &#13;
    char* buffer = (char*) &amp;value; &#13;
 &#13;
    for (int count = 0; count &lt; size; ++count) { &#13;
      *(buffer++) = list.Front(); &#13;
      list.Erase(0); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">AddString</code> function adds the characters of the text to the list along with a terminating zero character, while <code class="literal">GetString</code> reads the text from the list until it encounters the terminating zero character:</p><pre class="programlisting">  template &lt;class CharType&gt; &#13;
  void InfoList::AddString(basic_string&lt;CharType&gt; text) { &#13;
    for (CharType c : text) { &#13;
      AddValue&lt;CharType&gt;(c); &#13;
    } &#13;
 &#13;
    AddValue&lt;CharType&gt;(0); &#13;
  } &#13;
 &#13;
  template &lt;class CharType&gt; &#13;
  basic_string&lt;CharType&gt; InfoList::GetString() { &#13;
    bacic_string&lt;CharType&gt; text; &#13;
 &#13;
    CharType c, zero = (CharType) 0; &#13;
    while ((c = GetValue&lt;CharType&gt;()) != zero) { &#13;
      text.append(c); &#13;
    } &#13;
 &#13;
    return text; &#13;
  } &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>InfoList.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>The <code class="literal">FromBuffer</code> function adds each byte of the buffer to the list, while <code class="literal">ToBuffer</code> extracts and copies each byte of the list to the buffer:</p><pre class="programlisting">void InfoList::FromBuffer(const void* voidBuffer, int size) { &#13;
  const char* charBuffer = (const char*) voidBuffer; &#13;
 &#13;
  for (int count = 0; count &lt; size; ++count) { &#13;
    list.PushBack(*(charBuffer++)); &#13;
  } &#13;
} &#13;
 &#13;
void InfoList::ToBuffer(void* voidBuffer) { &#13;
  char* charBuffer = (char*) voidBuffer; &#13;
 &#13;
  for (char c : list) { &#13;
    *(charBuffer++) = c; &#13;
  } &#13;
} &#13;
</pre></div>
<div class="section" title="Strings"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec67"/>Strings</h1></div></div></div><p>There are a small set of string functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CharPtrToGenericString</code>: This takes text as a <code class="literal">char</code> character pointer and returns the same text as a generic <code class="literal">String</code> object. Remember that the <code class="literal">String</code> class holds values of the <code class="literal">TCHAR</code> type, of which many are <code class="literal">char</code> or <code class="literal">wchar_t</code> depending on system settings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Split</code>: This takes a string and returns a list of strings holding the space-separated words of the text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IsNumeric</code>: This returns<code class="literal">true</code> if the text holds a numeric value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Trim</code>: This removes spaces at the beginning and at the end of the text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ReplaceAll</code>: This replaces one string with another string.</li><li class="listitem" style="list-style-type: disc"><code class="literal">WriteStringToStream</code> and <code class="literal">ReadStringFromStream</code>: These write and read a string to and from a stream.</li><li class="listitem" style="list-style-type: disc"><code class="literal">StartsWith</code> and <code class="literal">EndsWith</code>: These return<code class="literal">true</code> if the text starts or ends with the subtext.</li></ul></div><p>
<span class="strong"><strong>String.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  extern String CharPtrToGenericString(char* text); &#13;
  extern vector&lt;String&gt; Split(String text, TCHAR c = TEXT(' ')); &#13;
  extern bool IsNumeric(String text); &#13;
  extern String Trim(String text); &#13;
  void ReplaceAll(String&amp; text, String from, String to); &#13;
  extern bool WriteStringToStream(const String&amp; text, &#13;
                                  ostream&amp; outStream); &#13;
  extern bool ReadStringFromStream(String&amp; text, &#13;
                                   istream&amp; inStream); &#13;
  extern bool StartsWith(String text, String part); &#13;
  extern bool EndsWith(String text, String part); &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>String.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  String CharPtrToGenericString(char* text) { &#13;
    String result; &#13;
 &#13;
    for (int index = 0; text[index] != '\0'; ++index) { &#13;
      result += (TCHAR) text[index]; &#13;
    } &#13;
 &#13;
    return result; &#13;
  } &#13;
 &#13;
  vector&lt;String&gt; Split(String text, TCHAR c /* = TEXT(' ') */) { &#13;
    vector&lt;String&gt; list; &#13;
    int spaceIndex = -1, size = text.size(); &#13;
 &#13;
    for (int index = 0; index &lt; size; ++index) { &#13;
      if (text[index] == c) { &#13;
        String word = &#13;
          text.substr(spaceIndex + 1, index - spaceIndex - 1); &#13;
        list.push_back(word); &#13;
        spaceIndex = index; &#13;
      } &#13;
    } &#13;
 &#13;
    String lastWord = text.substr(spaceIndex + 1); &#13;
    list.push_back(lastWord); &#13;
    return list; &#13;
  } &#13;
</pre><p>The <code class="literal">IsNumeric</code> method uses the <code class="literal">IStringStream</code> method to read the value of the string and compare the number of characters read with the length of the text. If all the characters of the text are read, the text will hold a numeric value and <code class="literal">true</code> will be returned:</p><pre class="programlisting">      bool IsNumeric(String text) { &#13;
    IStringStream stringStream(Trim(text)); &#13;
    double value; &#13;
    stringStream &gt;&gt; value; &#13;
    return stringStream.eof(); &#13;
  } &#13;
 &#13;
  String Trim(String text) { &#13;
    while (!text.empty() &amp;&amp; isspace(text[0])) { &#13;
      text.erase(0, 1); &#13;
    } &#13;
 &#13;
    while (!text.empty() &amp;&amp; isspace(text[text.length() - 1])) { &#13;
      text.erase(text.length() - 1, 1); &#13;
    } &#13;
 &#13;
    return text; &#13;
  } &#13;
 &#13;
  void ReplaceAll(String&amp; text, String from, String to) { &#13;
    int index, fromSize = from.size(); &#13;
 &#13;
    while ((index = text.find(from)) != -1) { &#13;
      text.erase(index, fromSize); &#13;
      text.insert(index, to); &#13;
    } &#13;
  } &#13;
 &#13;
  bool WriteStringToStream(const String&amp; text,ostream&amp; outStream){ &#13;
    int size = text.size(); &#13;
    outStream.write((char*) &amp;size, sizeof size); &#13;
 &#13;
    for (TCHAR tChar : text) { &#13;
      outStream.write((char*) &amp;tChar, sizeof tChar); &#13;
    } &#13;
 &#13;
    return ((bool) outStream); &#13;
  } &#13;
 &#13;
  bool ReadStringFromStream(String&amp; text, istream&amp; inStream) { &#13;
    int size; &#13;
    inStream.read((char*) &amp;size, sizeof size); &#13;
 &#13;
&#13;
    for (int count = 0; count &lt; size; ++count) { &#13;
      TCHAR tChar; &#13;
      inStream.read((char*) &amp;tChar, sizeof tChar); &#13;
      text.push_back(tChar); &#13;
    } &#13;
 &#13;
    return ((bool) inStream); &#13;
  } &#13;
 &#13;
  bool StartsWith(String text, String part) { &#13;
    return (text.find(part) == 0); &#13;
  } &#13;
 &#13;
  bool EndsWith(String text, String part) { &#13;
    int index = text.rfind(part), &#13;
        difference = text.length() - part.length(); &#13;
    return ((index != -1) &amp;&amp; (index == difference)); &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec68"/>Summary</h1></div></div></div><p>In this chapter, we studied the auxiliary classes used by Small Windows. In <a class="link" href="ch13.html" title="Chapter 13. The Registry, Clipboard, Standard Dialogs, and Print Preview">Chapter 13</a>, <span class="emphasis"><em>The Clipboard, Standard Dialogs, and Print Preview</em></span>, we will look into the registry, the clipboard, standard dialogs, and print preview.</p></div></body></html>