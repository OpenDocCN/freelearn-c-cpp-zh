<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Networking</h1></div></div></div><div><blockquote class="blockquote"><p><em>In this chapter, you will be taught how to communicate with the Internet servers and with sockets in general. First, we will have a look at <code class="literal">QNetworkAccessManager</code>, which makes sending network requests and receiving replies really easy. Building on this basic knowledge, we are then going to use Google's Distance API to get information about the distance between two locations and how long it would take to get from one to the other. This technique and the respective knowledge can also be used to include Facebook or Twitter in your application via their respective APIs. Then, we will have a look at Qt's Bearer API, which provides information on a device's connectivity state. In the last section, you will learn how to use sockets to create your own server and clients using TCP or UDP as the network protocol.</em></p></blockquote></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec92"/>QNetworkAccessManager</h1></div></div></div><p>The easiest <a id="id464" class="indexterm"/>way to access files on the Internet is to use Qt's Network Access API. This API is centered on <code class="literal">QNetworkAccessManager</code>, which handles the complete communication between your game and the Internet.</p><p>When we now develop and test a network-enabled application, it is recommended that you use a private, local network if feasible. This way, it is possible to debug both ends of the connection and errors will not expose sensitive data. If you are not familiar with setting up a web server locally on your machine, there are luckily a number of all-in-one installers that are freely available. These will automatically configure Apache2, MySQL (or MariaDB), PHP, and many more <a id="id465" class="indexterm"/>on your system. On Windows, for example, you could use XAMPP (<a class="ulink" href="http://www.apachefriends.org">http://www.apachefriends.org</a>) or the Uniform Server (<a class="ulink" href="http://www.uniformserver.com">http://www.uniformserver.com</a>); on <a id="id466" class="indexterm"/>Apple computers, there is MAMP (<a class="ulink" href="http://www.mamp.info">http://www.mamp.info</a>); and on Linux you normally don't have to do anything since <a id="id467" class="indexterm"/>there is already a localhost. If not, open your preferred package manager, search for a package called <code class="literal">Apache2</code> or a similar one, and install it. Alternatively, have a look at your distribution's documentation.</p><p>Before you install Apache on your machine, think about using a virtual machine such as VirtualBox (<a class="ulink" href="http://www.virtualbox.org">http://www.virtualbox.org</a>) for this task. This way, you keep your machine clean <a id="id468" class="indexterm"/>and you can easily try different settings for your test server. With multiple virtual <a id="id469" class="indexterm"/>machines, you can even test the interaction between different instances of your game. If you are on <a id="id470" class="indexterm"/>Unix, Docker (<a class="ulink" href="http://www.docker.com">http://www.docker.com</a>) might be worth having a look at.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec129"/>Downloading files over HTTP</h2></div></div></div><p>For <a id="id471" class="indexterm"/>this, first try to set up a local <a id="id472" class="indexterm"/>server and create a file called <code class="literal">version.txt</code> in the root directory of the installed server. This file should contain a small piece of text such as "I am a file on localhost" or something similar. To test whether the server and the file are correctly setup, start a web browser and open <code class="literal">http://localhost/version.txt</code>. You should then see the file's content. Of course, if you have access to a domain, you can also use that. Just alter the URL used in the example correspondingly. If this fails, it may be the case that your server does not allow you to display text files. Instead of getting lost in the server's configuration, just rename the file to <code class="literal">version.html</code>. This should do the trick!</p><div><img src="img/8874OS_07_01.jpg" alt="Downloading files over HTTP"/><div><p>Result of requesting http://localhost/version.txt on a browser</p></div></div><p>As you might have guessed, because of the file name a real-life scenario could be to check whether there is an updated version of your game or application on the server. To get the content of a file, only five lines of code are needed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec93"/>Time for action – downloading a file</h1></div></div></div><p>First, create <a id="id473" class="indexterm"/>an instance of <code class="literal">QNetworkAccessManager</code>:</p><div><pre class="programlisting">QNetworkAccessManager *m_nam = new QNetworkAccessManager(this);</pre></div><p>Since <code class="literal">QNetworkAccessManager</code> inherits <code class="literal">QObject</code>, it takes a pointer to <code class="literal">QObject</code>, which is used as a parent. Thus, you do not have to take care of deleting the manager later on. Furthermore, one single instance of <code class="literal">QNetworkAccessManager</code> is enough for an entire application. So, either pass a pointer to the network access manager in your game or, for ease of use, create <a id="id474" class="indexterm"/>a singleton pattern and access the manager through that.</p><div><div><h3 class="title"><a id="tip56"/>Tip</h3><p>A singleton pattern ensures that a class is instantiated only once. The pattern is useful for accessing application-wide configurations or—as in our case—an instance of <code class="literal">QNetworkAccessManager</code>. On the wiki pages for <a class="ulink" href="http://www.qtcentre.org">http://www.qtcentre.org</a> and <a class="ulink" href="http://www.qt-project.org">http://www.qt-project.org</a>, you will find examples for different <a id="id475" class="indexterm"/>singleton patterns. A simple template-based approach would look like this (as a header file):</p><div><pre class="programlisting">template &lt;class T&gt;
class Singleton
{
public:
  static T&amp; Instance()
  {
    static T _instance;
    return _instance;
  }
private:
  Singleton();
  ~Singleton();
  Singleton(const Singleton &amp;);
  Singleton&amp; operator=(const Singleton &amp;);
};</pre></div><p>In the source code, you will include that header file and acquire a singleton of a class called <code class="literal">MyClass</code> with:</p><div><pre class="programlisting">MyClass *singleton = &amp;Singleton&lt;MyClass&gt;::Instance();</pre></div><p>If you are using Qt Quick—it will be explained in <a class="link" href="ch09.html" title="Chapter 9. Qt Quick Basics">Chapter 9</a>, <em>Qt Quick Basics</em>—with <code class="literal">QQuickView</code>, you can directly use the view's instance of <code class="literal">QNetworkAccessManager</code>:</p><div><pre class="programlisting">QQuickView *view = new QQuickView;
QNetworkAccessManager *m_nam 
  = view-&gt;engine()-&gt;networkAccessManager();</pre></div></div></div><p>Secondly, we connect the manager's <code class="literal">finished()</code> signal to a slot of our choice; for example, in our class, we have a slot called <code class="literal">downloadFinished()</code>:</p><div><pre class="programlisting">connect(m_nam, SIGNAL(finished(QNetworkReply*)), this, 
  SLOT(downloadFinished(QNetworkReply*)));</pre></div><p>Thirdly, we actually request the <code class="literal">version.txt</code> file from localhost:</p><div><pre class="programlisting">m_nam-&gt;get(QNetworkRequest(QUrl("http://localhost/version.txt")));</pre></div><p>With <code class="literal">get()</code>, a request to get the contents of the file, specified by the URL, is posted. The function expects <code class="literal">QNetworkRequest</code>, which defines all the information needed to send a request over the network. The main information for such a request is naturally the URL of the file. This is the reason why <code class="literal">QNetworkRequest</code> takes <code class="literal">QUrl</code> as an argument in its constructor. You <a id="id476" class="indexterm"/>can also set the URL with <code class="literal">setUrl()</code> to <a id="id477" class="indexterm"/>a request. If you wish to define some additional headers, you can either use <code class="literal">setHeader()</code> for the most common header or use <code class="literal">setRawHeader()</code> to be fully flexible. If you want to set, for example, a custom user agent to the request, the call will look like:</p><div><pre class="programlisting">QNetworkRequest request;
request.setUrl(QUrl("http://localhost/version.txt"));
request.setHeader(QNetworkRequest::UserAgentHeader, "MyGame");
m_nam-&gt;get(request);</pre></div><p>The <code class="literal">setHeader()</code> function takes two arguments, the first is a value of the <code class="literal">QNetworkRequest::KnownHeaders</code> enumeration, which holds the most common—self-explanatory—headers such as <code class="literal">LastModifiedHeader</code> or <code class="literal">ContentTypeHeader</code>, and the second is the actual value. You could also write the header using <code class="literal">setRawHeader()</code>:</p><div><pre class="programlisting">request.setRawHeader("User-Agent", "MyGame");</pre></div><p>When you use <code class="literal">setRawHeader()</code>, you have to write the header field names yourself. Besides this, it behaves like <code class="literal">setHeader()</code>. A list of all the available headers for the HTTP protocol Version 1.1 can be found in section 14 of RFC 2616 (<a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14</a>).</p><p>Back to our example: with the <code class="literal">get()</code> function, we requested the <code class="literal">version.txt</code> file from the localhost. All we have to do from now on is to wait for the server to reply. As soon as the server's reply is finished, the <code class="literal">downloadFinished()</code> slot will be called that was defined by the preceding connection statement. As an argument, a reply of the <code class="literal">QNetworkReply</code> type is transferred to the slot, and we can read the reply's data and set it to <code class="literal">m_edit</code>, an instance of <code class="literal">QPlainTextEdit</code>, with:</p><div><pre class="programlisting">void FileDownload::downloadFinished(QNetworkReply *reply) {
<strong>  const QByteArray content = reply-&gt;readAll();</strong>
  m_edit-&gt;setPlainText(content);
<strong>  reply-&gt;deleteLater();</strong>
}</pre></div><p>Since <code class="literal">QNetworkReply</code> inherits <code class="literal">QIODevice</code>, there are also other possibilities to read the contents of the reply including <code class="literal">QDataStream</code> or <code class="literal">QTextStream</code> to either read and interpret binary data or textual data. Here, as the fourth command, <code class="literal">QIODevice::readAll()</code> is used to get the full content of the requested file in <code class="literal">QByteArray</code>. The responsibility for the transferred pointer to the corresponding <code class="literal">QNetworkReply</code> lies with us, so we need to delete it at the end of the slot. This would be the fifth line of code that is needed to download a file with Qt. However, be careful and do not call delete on the reply directly. Always use <code class="literal">deleteLater()</code>, as the documentation suggests!</p><p>The full source <a id="id478" class="indexterm"/>code can be found in the <strong>FileDownload</strong> <a id="id479" class="indexterm"/>example bundled with this book. If you start the small demo application and click on the <strong>Load File</strong> button you should see:</p><div><img src="img/8874OS_07_02.jpg" alt="Time for action – downloading a file"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec130"/>Have a go hero – extending the basic file downloader</h2></div></div></div><p>If you haven't <a id="id480" class="indexterm"/>set up a localhost, just alter the URL in the source code to download another file. Of course, having to alter <a id="id481" class="indexterm"/>the source code in order to download another file is far from an ideal approach. So, try to extend the dialog by adding a line edit in which you can specify the URL you want to download. Also, you can offer a file dialog to choose the location to where the downloaded file will be saved.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec131"/>Error handling</h2></div></div></div><p>If you do not <a id="id482" class="indexterm"/>see the content of the file, something <a id="id483" class="indexterm"/>went wrong. Just as in real life, this can often happen. So, we need to make sure that there is a good error handling mechanism in such cases to inform the user about what is going on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec94"/>Time for action – displaying a proper error message</h1></div></div></div><p>Fortunately, <code class="literal">QNetworkReply</code> offers several possibilities to do this. In the slot called <code class="literal">downloadFinished()</code>, we first want to check whether an error occurred:</p><div><pre class="programlisting">if (reply-&gt;error() != QNetworkReply::NoError) {/* error occurred */}</pre></div><p>The <code class="literal">QNetworkReply::error()</code> function returns the error that occurred while handling the request. The <a id="id484" class="indexterm"/>error is encoded as a <a id="id485" class="indexterm"/>value of the <code class="literal">QNetworkReply::NetworkError</code> type. The two most common errors are probably these:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Error code</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ContentNotFoundError</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This error indicates that the URL of the request could not be found. It is similar to the HTTP error code 404.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ContentAccessDenied</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This error indicates that you do not have the permission to access the requested file. It is similar to the HTTP error code 401.</p>
</td></tr></tbody></table></div><p>You can look up the other 23 error codes in the documentation. But normally, you do not need to know exactly what went wrong. You only need to know whether everything worked out—<code class="literal">QNetworkReply::NoError</code> would be the return value in this case—or if something went wrong.</p><div><div><h3 class="title"><a id="tip59"/>Tip</h3><p>Since <code class="literal">QNetworkReply::NoError</code> has the value <code class="literal">0</code>, you can shorten the test phrase to check whether an error occurred to be:</p><div><pre class="programlisting">if (reply-&gt;error()) {
  // an error occurred
}</pre></div></div></div><p>To provide the user with a meaningful error description, you can use <code class="literal">QIODevice::errorString()</code>. The text is already set up with the corresponding error message and we only have to display it:</p><div><pre class="programlisting">if (reply-&gt;error()) {
  const QString error = reply-&gt;errorString();
  m_edit-&gt;setPlainText(error);
  return;
}</pre></div><p>In our example, assuming we made an error in the URL and wrote <code class="literal">versions.txt</code> by mistake, the application would look like this:</p><div><img src="img/8874OS_07_03.jpg" alt="Time for action – displaying a proper error message"/></div><p>If the request was an HTTP request and the status code is of interest, it could be retrieved by <code class="literal">QNetworkReply::attribute()</code>:</p><div><pre class="programlisting">reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute)</pre></div><p>Since it returns <code class="literal">QVariant</code>, you can either use <code class="literal">QVariant::toInt()</code> to get the code as an integer or <code class="literal">QVariant::toString()</code> to get the number as <code class="literal">QString</code>. Beside the HTTP status code, you can query a lot of other information through <code class="literal">attribute()</code>. Have a look at the description <a id="id486" class="indexterm"/>of the <code class="literal">QNetworkRequest::Attribute</code> enumeration in the documentation. There, you will also find <code class="literal">QNetworkRequest::HttpReasonPhraseAttribute</code>, which holds a human-readable reason phrase for the <a id="id487" class="indexterm"/>HTTP status code. For example, "Not Found" if an HTTP error 404 has occurred. The value of this attribute is used to set the error text for <code class="literal">QIODevice::errorString()</code>. So, you can either use the default error description provided by <code class="literal">errorString()</code> or compose your own by interpreting the reply's attributes.</p><div><div><h3 class="title"><a id="tip60"/>Tip</h3><p>If a download failed and you want to resume it or if you only want to download a specific part of a file, you can use the <code class="literal">Range</code> header:</p><div><pre class="programlisting">QNetworkRequest req(QUrl("..."));
req.setRawHeader("Range", "bytes=300-500");
QNetworkReply *reply = m_nam-&gt;get(req);</pre></div><p>In this example, only the bytes from <code class="literal">300</code> to <code class="literal">500</code> would be downloaded. However, the server must support this.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec132"/>Downloading files over FTP</h2></div></div></div><p>Downloading <a id="id488" class="indexterm"/>a file over FTP is as <a id="id489" class="indexterm"/>simple as downloading files over HTTP. If it is an anonymous FTP server for which you do not need an authentication, just use the URL like we did before. Assuming that there is again a file called <code class="literal">version.txt</code> on the FTP server on the localhost, type:</p><div><pre class="programlisting">m_nam-&gt;get(QNetworkRequest(QUrl("ftp://localhost/version.txt")));</pre></div><p>That is all, everything <a id="id490" class="indexterm"/>else stays the <a id="id491" class="indexterm"/>same. If the FTP server requires an authentication, you'll get an error, for example:</p><div><img src="img/8874OS_07_04.jpg" alt="Downloading files over FTP"/></div><p>Setting the username and password to access an FTP server is likewise easy: either write it in the URL, or use the <code class="literal">setUserName()</code> and <code class="literal">setPassword()</code> functions of <code class="literal">QUrl</code>. If the server does not use a standard port, you can set the port explicitly with <code class="literal">QUrl::setPort()</code>.</p><div><div><h3 class="title"><a id="tip62"/>Tip</h3><p>To upload a file to an FTP server, use <code class="literal">QNetworkAccessManager::put()</code>, which takes <code class="literal">QNetworkRequest</code> as its first argument, calling a URL that defines the name of the new file on the server, and the actual data as its second argument, which should be uploaded. For small uploads, you can pass the content as <code class="literal">QByteArray</code>. For larger content, it's better to use a pointer to <code class="literal">QIODevice</code>. Make sure that the device is open and stays available until the upload is done.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec133"/>Downloading files in parallel</h2></div></div></div><p>A very <a id="id492" class="indexterm"/>important note on <code class="literal">QNetworkAccessManager</code>: it works asynchronously. This means that you can post a network <a id="id493" class="indexterm"/>request without blocking the main event loop, and this is what keeps the GUI responsive. If you post more than one request, they are put on the manager's queue. Depending on the protocol used, they get processed in parallel. If you are sending HTTP requests, normally up to six requests will be handled at a time. This will not block the application. Therefore, there is really no need to encapsulate <code class="literal">QNetworkAccessManager</code> in a thread; however, unfortunately, this unnecessary approach is frequently recommended all over the Internet. <code class="literal">QNetworkAccessManager</code> already threads internally. Really, don't move <code class="literal">QNetworkAccessManager</code> to a thread unless you know exactly what you are doing.</p><p>If you send multiple requests, the slot connected to the manager's <code class="literal">finished()</code> signal is called in an arbitrary order depending on how quickly a request gets a reply from the server. This is why you need to know to which request a reply belongs. This is one reason why every <code class="literal">QNetworkReply</code> carries its related <code class="literal">QNetworkRequest</code>. It can be accessed through <code class="literal">QNetworkReply::request()</code>.</p><p>Even if the determination of the replies and their purpose may work for a small application in a single slot, it will quickly get large and confusing if you send a lot of requests. This problem is aggravated by the fact that all replies are delivered to only one slot. Since most probably there are different types of replies that need different treatments, it would be better to bundle them in specific slots that are specialized for a given task. Fortunately, this can be achieved very easily. <code class="literal">QNetworkAccessManager::get()</code> returns a pointer to <code class="literal">QNetworkReply</code>, which will get all information about the request that you post with <code class="literal">get()</code>. By using this pointer, you can then connect specific slots to the reply's signals.</p><p>For example, if <a id="id494" class="indexterm"/>you have several <a id="id495" class="indexterm"/>URLs and you want to save all linked images from these sites to your hard drive, then you request all web pages via <code class="literal">QNetworkAccessManager::get()</code> and connect their replies to a slot specialized for parsing the received HTML. If links to the images are found, this slot will request them again with <code class="literal">get()</code>. However, this time the replies to these requests will be connected to a second slot, which is designed for saving the images to the disk. Thus, you can separate the two tasks: parsing HTML and saving data to a local drive.</p><p>The most important signals of <code class="literal">QNetworkReply</code> are discussed next.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec43"/>The finished signal</h3></div></div></div><p>The <code class="literal">finished()</code> signal is an equivalent of the <code class="literal">QNetworkAccessManager::finished()</code> signal that we <a id="id496" class="indexterm"/>used earlier. It is triggered as soon as a reply is returned—successfully or not. After this signal is emitted, neither the reply's data nor its metadata will be altered anymore. With this signal, you are now able to connect a reply to a specific slot. This way, you can realize the scenario the scenario on saving images that was outlined in the previous section.</p><p>However, one problem remains: if you post simultaneous requests, you do not know which one has finished and thus called the connected slot. Unlike <code class="literal">QNetworkAccessManager::finished()</code>, <code class="literal">QNetworkReply::finished()</code> does not pass a pointer to <code class="literal">QNetworkReply</code>; this would actually be a pointer to itself in this case. A quick solution to solve this problem is to use <code class="literal">sender()</code>. It returns a pointer to the <code class="literal">QObject</code> instance that has called the slot. Since we know that it was <code class="literal">QNetworkReply</code>, we can write:</p><div><pre class="programlisting">QNetworkReply *reply = qobject_cast&lt;QNetworkReply*&gt;
(sender());
if (!reply)
  return;</pre></div><p>This was done by <a id="id497" class="indexterm"/>casting <code class="literal">sender()</code> to a pointer of the <code class="literal">QNetworkReply</code> type.</p><div><div><h3 class="title"><a id="tip63"/>Tip</h3><p>Whenever you're casting classes that inherit <code class="literal">QObject</code>, use <code class="literal">qobject_cast</code>. Unlike <code class="literal">dynamic_cast</code>, it does not use RTTI and works across the dynamic library boundaries.</p></div></div><p>Although we can be pretty confident that the cast will work, do not forget to check whether the pointer is valid. If it is a null pointer, exit the slot.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec95"/>Time for action – writing the OOP conform code using QSignalMapper</h1></div></div></div><p>A more <a id="id498" class="indexterm"/>elegant way that does not rely on <code class="literal">sender()</code> would be to use <code class="literal">QSignalMapper</code> and a local hash, in which all replies that are connected to that slot are stored. So, whenever you call <code class="literal">QNetworkAccessManager::get()</code>, store the returned pointer in a member variable of the <code class="literal">QHash&lt;int, QNetworkReply*&gt;</code> type and set up the mapper. Let's assume that we have the following member variables and that they are set up properly:</p><div><pre class="programlisting">QNetworkAccessManager *m_nam;
QSignalMapper *m_mapper;
QHash&lt;int, QNetworkReply*&gt; m_replies;</pre></div><p>Then, you connect the <code class="literal">finished()</code> signal of a reply this way:</p><div><pre class="programlisting">QNetworkReply *reply = m_nam-&gt;get(QNetworkRequest(QUrl(/*...*/)));
connect(reply, SIGNAL(finished()), m_mapper, SLOT(map()));
int id = /* unique id, not already used in m_replies*/;
m_replies.insert(id, reply);
m_mapper-&gt;setMapping(reply, id);</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec134"/>
<em>What just happened?</em>
</h2></div></div></div><p>First, we posted the request and fetched the pointer to <code class="literal">QNetworkReply</code> with reply. Then, we connected the reply's finished signal to the mapper's slot <code class="literal">map()</code>. Next, we found a unique ID, which must not already be in use in the <code class="literal">m_replies</code> variable. You can use random numbers generated with <code class="literal">qrand()</code> and fetch numbers as long as they are not unique. To determine whether a key is already in use, call <code class="literal">QHash::contains()</code>. It takes the key as an argument against which it should be checked. Or even simpler, count up another private member variable. Once we have a unique ID, we insert the pointer to <code class="literal">QNetworkReply</code> in the hash using the ID as a key. Last, with <code class="literal">setMapping()</code>, we set up the mapper's mapping: the ID's value corresponds to the actual reply.</p><p>In a prominent <a id="id499" class="indexterm"/>place, most likely the constructor of the class, we already have connected the mappers <code class="literal">map()</code> signal to a custom slot. For example:</p><div><pre class="programlisting">connect(m_mapper, SIGNAL(mapped(int)), this, SLOT(downloadFinished(int)));</pre></div><p>When the <code class="literal">downloadFinished()</code> slot is called, we can get the corresponding reply with:</p><div><pre class="programlisting">void SomeClass::downloadFinished(int id) {
  QNetworkReply *reply = m_replies.take(id);
  // do some stuff with reply here
  reply-&gt;deleteLater();
}</pre></div><div><div><h3 class="title"><a id="tip64"/>Tip</h3><p>
<code class="literal">QSignalMapper</code> also allows you to map with <code class="literal">QString</code> as an identifier instead of an integer as used in the preceding code. So, you could rewrite the example and use the URL to identify the corresponding <code class="literal">QNetworkReply</code>, at least as long as the URLs are unique.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl3sec44"/>The error signal</h2></div></div></div><p>If you <a id="id500" class="indexterm"/>download files sequentially, you can swap the error <a id="id501" class="indexterm"/>handling out. Instead of dealing with errors in the slot connected to the <code class="literal">finished()</code> signal, you can use the reply's <code class="literal">error()</code> signal, which passes the error of the <code class="literal">QNetworkReply::NetworkError</code> type to the slot. After the <code class="literal">error()</code> signal has been emitted, the <code class="literal">finished()</code> signal will most likely also be emitted shortly.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl3sec45"/>The readyRead signal</h2></div></div></div><p>Until <a id="id502" class="indexterm"/>now, we have used the slot connected to the <code class="literal">finished()</code> signal to get the reply's content. This works perfectly if you deal with small files. However, this approach is unsuitable when dealing with large files, as they would <a id="id503" class="indexterm"/>unnecessarily bind too many resources. For larger files, it is better to read and save the transferred data as soon as it is available. We are informed by <code class="literal">QIODevice::readyRead()</code> whenever new data is available to be read. So, for large files you should use the following code:</p><div><pre class="programlisting">connect(reply, SIGNAL(readyRead()), this, SLOT(readContent()));
file.open(QIODevice::WriteOnly);</pre></div><p>This will help you connect the reply's <code class="literal">readyRead()</code> signal to a slot, set up <code class="literal">QFile</code>, and open it. In the connected slot, type in the following snippet:</p><div><pre class="programlisting">const QByteArray ba = reply-&gt;readAll();
file.write(ba);
file.flush();</pre></div><p>Now, you can fetch the content, which has been transferred so far, and save it to the (already opened) file. This way, the resources needed are minimized. Don't forget to close the file after the <code class="literal">finished()</code> signal is emitted.</p><p>In this context, it would be helpful if you knew upfront the size of the file you want to download. Therefore, we can use <code class="literal">QNetworkAccessManager::head()</code>. It behaves like the <code class="literal">get()</code> function, but does not transfer the content of the file. Only the headers are transferred. And if we are lucky, the server sends the "Content-Length" header, which holds the file size in bytes. To get that information, we type:</p><div><pre class="programlisting">reply-&gt;head(QNetworkRequest::ContentLengthHeader).toInt();</pre></div><p>With this <a id="id504" class="indexterm"/>information, we can also check upfront <a id="id505" class="indexterm"/>whether there is enough space left on the disk.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl3sec46"/>The downloadProgress method</h2></div></div></div><p>Especially when <a id="id506" class="indexterm"/>a big file is downloaded, the <a id="id507" class="indexterm"/>user usually wants to know how much data has already been downloaded and approximately how long it will take for the download to finish.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec96"/>Time for action – showing the download progress</h1></div></div></div><p>In order to achieve this, we can use the reply's <code class="literal">downloadProgress()</code> signal. As the first argument, it passes the information on how many bytes have already been received and as the second <a id="id508" class="indexterm"/>argument, how many bytes there are in total. This gives us the possibility to indicate the progress of the download with <code class="literal">QProgressBar</code>. As the passed arguments are of the <code class="literal">qint64</code> type, we can't use them directly with <code class="literal">QProgressBar</code>, as it only accepts <code class="literal">int</code>. So, in the connected slot, we first calculate the percentage of the download progress:</p><div><pre class="programlisting">void SomeClass::downloadProgress(qint64 bytesReceived, qint64 bytesTotal) {
  qreal progress = (bytesTotal &lt; 1) ? 1.0 
                   : bytesReceived * 100.0 / bytesTotal;
  progressBar-&gt;setValue(progress * progressBar-&gt;maximum());
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec135"/>
<em>What just happened?</em>
</h2></div></div></div><p>With the percentage, we set the new value for the progress bar where <code class="literal">progressBar</code> is the pointer to this bar. However, what value will <code class="literal">progressBar-&gt;maximum()</code> have and where do we set the range for the progress bar? What is nice is that you do not have to set it for every new download. It is only done once, for example, in the constructor of the class containing the bar. As range values, I would recommend:</p><div><pre class="programlisting">progressBar-&gt;setRange(0, 2048);</pre></div><p>The reason is that if you take, for example, a range of 0 to 100 and the progress bar is 500 pixels wide, the bar would jump 5 pixels forward for every value change. This will look ugly. To get a smooth progression where the bar expands by 1 pixel at a time, a range of 0 to 99.999.999 would surely work, but would be highly inefficient. This is because the current value of the bar would change a lot without any graphical depiction. So, the best value for the range would be 0 to the actual bar's width in pixels. Unfortunately, the width of the bar can change depending on the actual widget width, and frequently querying the actual size of the bar every time the value changes is also not a good solution. Why <code class="literal">2048</code>, then? The idea behind this value is the resolution of the screen. Full HD monitors normally have a width of 1920 pixels, thus taking 2^11 (2048) ensures that the progress bar runs smoothly, even if it is fully expanded. So, 2048 isn't the perfect number but is a fairly good compromise. If you are targeting smaller devices, choose a smaller, more appropriate number.</p><p>To be able to calculate <a id="id509" class="indexterm"/>the remaining time for the download to finish, you have to start a timer. In this case, use <code class="literal">QElapsedTimer</code>. After posting the request with <code class="literal">QNetworkAccessManager::get()</code>, start the timer by calling <code class="literal">QElapsedTimer::start()</code>. Assuming that the timer is called <code class="literal">m_timer</code>, the calculation will be:</p><div><pre class="programlisting">qint64 total = m_timer.elapsed() / progress;
qint64 remaining = (total – m_timer.elapsed()) / 1000;</pre></div><p>
<code class="literal">QElapsedTimer::elapsed()</code> returns the milliseconds that are counted from the moment when the timer is started. This value divided by the progress equals the estimated total download time. If you subtract the elapsed time and divide the result by 1,000, you'll get the remaining time in seconds.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec136"/>Using a proxy</h2></div></div></div><p>If you like to use a <a id="id510" class="indexterm"/>proxy, you first have to set up <code class="literal">QNetworkProxy</code>. You have to define the type of the proxy with <code class="literal">setType()</code>. As arguments, you will most <a id="id511" class="indexterm"/>likely want to pass <code class="literal">QNetworkProxy::Socks5Proxy</code> or <code class="literal">QNetworkProxy::HttpProxy</code>. Then, set up the hostname with <code class="literal">setHostName()</code>, the username with <code class="literal">setUserName()</code>, and the password with <code class="literal">setPassword()</code>. The last two properties are, of course, only needed if the proxy requires an authentication. Once the proxy is set up, you can set it to the access manager via <code class="literal">QNetworkAccessManager::setProxy()</code>. Now, all new requests will use this proxy.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec97"/>Connecting to Google, Facebook, Twitter, and co.</h1></div></div></div><p>Since we <a id="id512" class="indexterm"/>discussed <code class="literal">QNetworkAccessManager</code>, you now have the <a id="id513" class="indexterm"/>knowledge you need to integrate Facebook, Twitter, or similar sites into your application. They all use the HTTP protocol and simple requests in order to retrieve data from them. For Facebook, you have to use the so-called Graph API. It describes which interfaces are available and what options they offer. If you want to search for users who are called "Helena", you have to request <a class="ulink" href="https://graph.facebook.com/search?q=helena&amp;type=user">https://graph.facebook.com/search?q=helena&amp;type=user</a>. Of course, you can do this with <code class="literal">QNetworkManager</code>. You will find more information about the possible requests to Facebook at <a class="ulink" href="http://developers.facebook.com/docs/graph-api">http://developers.facebook.com/docs/graph-api</a>.</p><p>If you wish to <a id="id514" class="indexterm"/>display tweets in your game, you have to use Twitter's REST or Search API. Assuming that you know the ID of a tweet you would like to display, then you can get it through <a class="ulink" href="https://api.twitter.com/1.1/statuses/show.json?id=12345">https://api.twitter.com/1.1/statuses/show.json?id=12345</a>, where <code class="literal">12345</code> is the actual ID for the tweet. If you would like to find tweets mentioning <code class="literal">#Helena</code>, you would write <a class="ulink" href="https://api.twitter.com/1.1/search/tweets.json?q=%23Helena">https://api.twitter.com/1.1/search/tweets.json?q=%23Helena</a>. You can find more information about the parameters and the other possibilities of Twitter's API at <a class="ulink" href="https://dev.twitter.com/docs/api">https://dev.twitter.com/docs/api</a>.</p><p>Since both Facebook and <a id="id515" class="indexterm"/>Twitter need an authentication to use their APIs, we will have a look at Google instead. Let's use Google's Distance Matrix API in order to get information about how long it would take for us to get from one city to another. The technical documentation for the API we are going to use can be found at <a class="ulink" href="https://developers.google.com/maps/documentation/distancematrix">https://developers.google.com/maps/documentation/distancematrix</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec98"/>Time for action – using Google's Distance Matrix API</h1></div></div></div><p>The <a id="id516" class="indexterm"/>GUI for this example is kept simple—the source code is attached with the book. It consists of two line edits (<code class="literal">ui-&gt;from</code> and <code class="literal">ui-&gt;to</code>) that allow you to enter the origin and destination of the journey. It also provides you with a combo box (<code class="literal">ui-&gt;vehicle</code>) that allows you to choose a mode of transportation—whether you want to drive a car, ride a bicycle, or walk—a push button (<code class="literal">ui-&gt;search</code>) to start the request, and a text edit or (<code class="literal">ui-&gt;result</code>) to show the results. The result will look like this:</p><div><img src="img/8874OS_07_05.jpg" alt="Time for action – using Google's Distance Matrix API"/></div><p>
<code class="literal">MainWindow</code>—a <a id="id517" class="indexterm"/>subclass of <code class="literal">QMainWindow</code>—is the application's main class that holds two private members: <code class="literal">m_nam</code>, which is a pointer to <code class="literal">QNetworkAccessManager</code>, and <code class="literal">m_reply</code>, which is a pointer to <code class="literal">QNetworkReply</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec99"/>Time for action – constructing the query</h1></div></div></div><p>Whenever <a id="id518" class="indexterm"/>the button is pressed, the <code class="literal">sendRequest()</code> slot is called:</p><div><pre class="programlisting">void MainWindow::sendRequest()
{
  if (m_reply != 0 &amp;&amp; m_reply-&gt;isRunning())
    m_reply-&gt;abort();
  ui-&gt;result-&gt;clear();</pre></div><p>In this slot, we first check whether there is an old request, which was stored in <code class="literal">m_reply</code>, and if it is still running. If that is <code class="literal">true</code>, we abort the old request as we are about to schedule a new one. Then, we also wipe out the result of the last request by calling <code class="literal">QPlainTextEdit::clear()</code> on the text edit.</p><p>Next, we will construct the URL for the request. We can do this by composing the string by hand where we add the query parameters to the base URL similar to:</p><div><pre class="programlisting">url = baseUrl + "?origin=" + ui-&gt;from-&gt;text() + "&amp;...";</pre></div><p>Besides the problem that this quickly becomes hard to read when we include multiple parameters, it is also rather error-prone. The values of the line edits have to be encoded to fit the criteria for a valid URL. For every user value, we therefore have to call <code class="literal">QUrl::toPercentEncoding()</code> explicitly. A much better approach, which is easier to read and less error-prone, is to use <code class="literal">QUrlQuery</code>. It circumvents the problem that may result from you forgetting to encode the data. So, we do this:</p><div><pre class="programlisting">QUrlQuery query;
query.addQueryItem("sensor", "false");
query.addQueryItem("language", "en");
query.addQueryItem("units", "metric");
query.addQueryItem("origins", ui-&gt;from-&gt;text());
query.addQueryItem("destinations", ui-&gt;to-&gt;text());
query.addQueryItem("mode", ui-&gt;vehicle-&gt;currentText());</pre></div><p>The usage is pretty clear: we create an instance and then add the query parameters with <code class="literal">addQueryItem()</code>. The first argument is taken as the key and the second as the value resulting in a string such as "key=value". The value will be automatically encoded when we use <code class="literal">QUrlQuery</code> in conjunction with <code class="literal">QUrl</code>. Other benefits of using <code class="literal">QUrlQuery</code> are that we can check whether we have already set a key with <code class="literal">hasQueryItem()</code>, taking the key as an argument, or removed a previous set key by calling <code class="literal">removeQueryItem()</code>.</p><p>In a real situation, we <a id="id519" class="indexterm"/>would, of course, wrap all the preceding literals in <code class="literal">QStringLiteral</code>, but this is omitted here in favor of a better reading. So, let's review which parameters we have set. The <code class="literal">sensor</code> key is set to <code class="literal">false</code> as we are not using a GPS device to locate our position. The <code class="literal">language</code> key is set to <code class="literal">English</code>, and for units, we favor metric over imperial. Then, the search-related parameters are set. The <code class="literal">origins</code> key holds the places we want to start from. As its value, the text of the <code class="literal">ui-&gt;from</code> line edit is chosen. If you want to query multiple starting positions, you just have to combine them using <code class="literal">|</code>. Equivalent to the origins, we set up the value for destinations. Last, we pass the value of the combo box to mode, which defines whether we want to go by a car, bicycle, or whether we want to walk, as shown in the following code:</p><div><pre class="programlisting">  QUrl url
    = ("http://maps.googleapis.com/maps/api/distancematrix/json");
  url.setQuery(query);
  m_reply = m_nam-&gt;get(QNetworkRequest(url));
}</pre></div><p>Next, we create <code class="literal">QUrl</code> that contains the address to which the query should be posted. By including "json" at the end, we define that the server should transfer its reply using the JSON format. Google also provides the option for us to get the result as XML. To achieve this, simply replace "json" with "xml". However, since the APIs of Facebook and Twitter return JSON, we will use this format.</p><p>Then, we set the previous constructed <code class="literal">query</code> to the URL by calling <code class="literal">QUrl::setQuery()</code>. This automatically encodes the values so we do not have to worry about that. Last, we post the request by calling the <code class="literal">get()</code> function and store the returned <code class="literal">QNetworkReply</code> in <code class="literal">m_reply</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec100"/>Time for action – parsing the server's reply</h1></div></div></div><p>In the <a id="id520" class="indexterm"/>constructor, we have connected the manager's <code class="literal">finish()</code> signal to the <code class="literal">finished()</code> slot of the <code class="literal">MainWindow</code> class. It will thus be called after the request has been posted:</p><div><pre class="programlisting">void MainWindow::finished(QNetworkReply *reply)
{
  if (m_reply != reply) {
    reply-&gt;deleteLater();
    return;
  }</pre></div><p>First, we check whether the reply that was passed is the one that we have requested through <code class="literal">m_nam</code>. If this is not the case, we delete <code class="literal">reply</code> and exit the function. This can happen if a reply was aborted by the <code class="literal">sendRequest()</code> slot:</p><div><pre class="programlisting">m_reply = 0;
if (reply-&gt;error()) {
  ui-&gt;result-&gt;setPlainText(reply-&gt;errorString());
  reply-&gt;deleteLater();
  return;
}</pre></div><p>Since we are now sure that it is our request, we set <code class="literal">m_reply</code> to null because we have handled it and do not need this information anymore. Next we check whether an error occurred, and if it did, we put the reply's error string in the text edit, delete reply, and exit the function:</p><div><pre class="programlisting">const QByteArray content = reply-&gt;readAll();
QJsonDocument doc = QJsonDocument::fromJson(content);
if (doc.isNull() || !doc.isObject()) {
  ui-&gt;result-&gt;setPlainText("Error while reading the JSON file.");
  reply-&gt;deleteLater();
  return;
}</pre></div><p>With <code class="literal">readAll()</code>, we get the content of the server's reply. Since the transferred data is not large, we do not need to use partial reading with <code class="literal">readyRead()</code>. The content is then converted to <code class="literal">QJsonDocument</code> using the <code class="literal">QJsonDocument::fromJson()</code> static function, which takes <code class="literal">QByteArray</code> as an argument and parses its data. If the document is null, the server's reply wasn't valid, and then, we show an error message on the text edit, delete the reply, and exit the function. We do the same if the document does not contain an object, as the API call should respond with a single object, as shown:</p><div><pre class="programlisting">QJsonObject obj = doc.object();
QVariantList origins = obj.value("origin_addresses")
                       .toArray().toVariantList();
QVariantList destinations = obj.value("destination_addresses")
                            .toArray().toVariantList();</pre></div><p>Since we now made sure that there is an object, we store it in <code class="literal">obj</code>. Furthermore, due to the API, we also know that the object holds the <code class="literal">origin_addresses</code> and <code class="literal">destination_addresses</code> keys. Both values are arrays that hold the requested origins and destinations. From this point on, we will skip any tests if the values exist and are valid since we trust the API. The object also holds a key called <code class="literal">status</code>, whose' value can be used to check whether the query may have failed and if yes, why? The last two lines of the source code store the origins and destinations in two variant lists. With <code class="literal">obj.value("origin_addresses")</code>, we get <code class="literal">QJsonValue</code> that holds the value of the pair specified by the <code class="literal">origin_addresses</code> key. <code class="literal">QJsonValue::toArray()</code> converts this value to <code class="literal">QJsonArray</code>, which then is converted to <code class="literal">QVariantList</code> using <code class="literal">QJsonArray::toVariantList()</code>. The returned JSON file for a search requesting the distance from Warsaw <a id="id521" class="indexterm"/>or Erlangen to Birmingham will look like:</p><div><pre class="programlisting">{
  "destination_addresses" : [ "Birmingham, West Midlands, UK" ],
  "origin_addresses" : [ "Warsaw, Poland", "Erlangen, Germany" ],
  "rows" : [ ... ],
  "status" : "OK"
}</pre></div><p>The <code class="literal">rows</code> key holds the actual results as an array. The first object in this array belongs to the first origin, the second object to the second origin, and so on. Each object holds a key named <code class="literal">elements</code>, whose' value is also an array of objects that belong to the corresponding destinations:</p><div><pre class="programlisting">"rows" : [
    {
      "elements" : [{...}, {...}]
    },
    {
      "elements" : [{...}, {...}]
    }
  ],</pre></div><p>Each JSON object for an origin-destination pair (<code class="literal">{...}</code> in the preceding example) consists of two pairs with the distance and duration keys. Both the values of these keys are arrays that hold the <code class="literal">text</code> and <code class="literal">value</code> keys, where <code class="literal">text</code> is a human-readable phrase for <code class="literal">value</code>. The object for the Warsaw-Birmingham search looks as shown in the following snippet:</p><div><pre class="programlisting">{
  "distance" : {
    "text" : "1,835 km",
    "value" : 1834751
  },
  "duration" : {
    "text" : "16 hours 37 mins",
    "value" : 59848
  },
  "status" : "OK"
}</pre></div><p>As you can see, the value of <code class="literal">value</code> for distance is the distance expressed in meters—since we have used <code class="literal">units=metric</code> in the request—and the value of <code class="literal">text</code> is value transformed into kilometers with the post fix "km". The same applies to duration. Here, value is expressed in seconds and text is value converted into hours and minutes.</p><p>Now that we know how the returned JSON is structured, we display the value of each origin-destination pair in the text edit. Therefore, we loop through each possible pairing using <code class="literal">QVariantLists</code>:</p><div><pre class="programlisting">for (int i = 0; i &lt; origins.count(); ++i) {
  for (int j = 0; j &lt; destinations.count(); ++j) {</pre></div><p>This scope will be <a id="id522" class="indexterm"/>reached for each combination. Think of the transferred result as a table where the origins are rows and the destinations are columns:</p><div><pre class="programlisting">QString output;
output += QString("From:").leftJustified(10, ' ') 
          + origins.at(i).toString() + "\n";
output += QString("To:").leftJustified(10, ' ') 
          + destinations.at(j).toString() + "\n";</pre></div><p>We cache the constructed text in a local variable called output. First, we add the string "From:" and the current origin to output. To make it look at least a little bit nicer, we call <code class="literal">leftJustified()</code>. It causes "From:" to be filled with spaces until the size of the entire string is <code class="literal">10</code>. The output will then be aligned. The value of the current origin is normally accessed through <code class="literal">QList::at()</code>, and since it is <code class="literal">QVariantList</code>, we need to convert the returned <code class="literal">QVariant</code> to <code class="literal">QString</code>. Thus, we call <code class="literal">toString()</code>. The same is done for the destination, which results in the following as the value for output:</p><div><pre class="programlisting">From:     Warsaw, Poland
To:       Birmingham, West Midlands, UK</pre></div><p>Next, we will read duration and distance from the corresponding <code class="literal">QJsonObject</code> from where we call <code class="literal">data</code>:</p><div><pre class="programlisting">QJsonObject data = obj.value("rows").toArray().at(i).toObject()
                  .value("elements").toArray().at(j).toObject();</pre></div><p>Starting at the reply's root object, we fetch the value of rows and convert it to an array (<code class="literal">obj.value("rows").toArray()</code>). Then, we fetch the value of the current row (<code class="literal">.at(i)</code>), convert it to a JSON object, and fetch its elements key (<code class="literal">.toObject().value("elements")</code>). Since this value is also an array—the columns of the row—we convert it to an array, fetch the current column (<code class="literal">.toArray().at(j)</code>), and convert it to an object. This is the object that contains the distance and duration for an origin-destination pair in the cell (<code class="literal">i;j</code>). Beside these two keys, the object also holds a key called <code class="literal">status</code>. Its value indicates whether the search was successful (<code class="literal">OK</code>), whether the origin or destination could not be found (<code class="literal">NOT_FOUND</code>), or whether the search could not find a route between the origin and destination (<code class="literal">ZERO_RESULTS</code>):</p><div><pre class="programlisting">QString status = data.value("status").toString();</pre></div><p>We store the value of status in a local variable that is also named status:</p><div><pre class="programlisting">if (status == "OK") {
  output += QString("Distance:").leftJustified(10, ' ') + 
    data.value("distance").toObject().value("text").toString() 
    + "\n";
  output += QString("Duration:").leftJustified(10, ' ') + 
    data.value("duration").toObject().value("text").toString() 
    + "\n";
}</pre></div><p>If all goes well, we <a id="id523" class="indexterm"/>then add <code class="literal">distance</code> and <code class="literal">duration</code> to the output and also align the labels as we did before using <code class="literal">leftJustified()</code>. For distance, we want to show the phrased result. Therefore, we first get the JSON value of the distance key (<code class="literal">data.value("distance")</code>), convert it to an object, and request the value for the text key (<code class="literal">.toObject().value("text")</code>). Lastly, we convert <code class="literal">QJsonValue</code> to <code class="literal">QString</code> using <code class="literal">toString()</code>. The same applies for duration:</p><div><pre class="programlisting">else if (status == "NOT_FOUND") {
  output += "Origin and/or destination of this pairing could not be geocoded.\n";
} else if (status == "ZERO_RESULTS") {
  output += "No route could be found.\n";
} else {
  output += "Unknown error.\n";
}</pre></div><p>If the API returns errors, we set an appropriate error text as output:</p><div><pre class="programlisting">      output += QString("\n").fill('=', 35) + "\n\n";
      ui-&gt;result-&gt;moveCursor(QTextCursor::End);
      ui-&gt;result-&gt;insertPlainText(output);
    }
  }
  reply-&gt;deleteLater();
}</pre></div><p>Finally, we add a line consisting of <code class="literal">35</code> equals signs (<code class="literal">fill('=', 35)</code>) to separate the result in one cell from the other cells. The output is then placed at the end of the text edit. This is done by moving the cursor to the end of the edit, by calling <code class="literal">moveCursor(QTextCursor::End)</code>, and inserting output into the edit with <code class="literal">insertPlainText(output)</code>.</p><p>When the loops <a id="id524" class="indexterm"/>finish, we must not forget to delete the reply. The actual result then looks as follows:</p><div><img src="img/8874OS_07_06.jpg" alt="Time for action – parsing the server's reply"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec137"/>Have a go hero – choosing XML as the reply's format</h2></div></div></div><p>To hone your <a id="id525" class="indexterm"/><a id="id526" class="indexterm"/>XML skills, you can use <a class="ulink" href="http://maps.googleapis.com/maps/api/distancematrix/xml">http://maps.googleapis.com/maps/api/distancematrix/xml</a> as a URL to which you send the requests. Then, you can parse the XML file as we did with JSON and display the retrieved data likewise.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec101"/>Controlling the connectivity state</h1></div></div></div><p>As a <a id="id527" class="indexterm"/>matter of fact, you can only use <code class="literal">QNetworkAccessManager</code> if you have an active connection to the Internet. Since you cannot theoretically know the connectivity state, you have to check this at the runtime of the application. With the help of the Bearer API, you can check whether the computer, mobile device, or tablet is online and you can even start a new connection—if the operating system supports it.</p><p>The Bearer API mainly consists of four classes. <code class="literal">QNetworkConfigurationManager</code> is the base and starting point. It holds all network configurations available on the system. Furthermore, it provides information about the network capabilities, for example, whether you can start and stop interfaces. The network configurations found by it are stored as <code class="literal">QNetworkConfiguration</code> classes. <code class="literal">QNetworkConfiguration</code> holds all information about an access point but not about a network interface, as an interface can provide multiple access points. This class also provides only the information about network configurations. You <a id="id528" class="indexterm"/>can't configure an access point or a network interface through <code class="literal">QNetworkConfiguration</code>. The network configuration is up to the operating system, and therefore, <code class="literal">QNetworkConfiguration</code> is a read-only class. With <code class="literal">QNetworkConfiguration</code>, however, you can determine whether the type of connection is an Ethernet, WLAN, or 2G connection. This may influence what kind of data and, more importantly, what size of data you are going to download. With <code class="literal">QNetworkSession</code>, you can then start or stop system network interfaces, which are defined by the configurations. This way, you gain control over an access point. <code class="literal">QNetworkSession</code> also provides session management that is useful when a system's access point is used by more than one application. The session ensures that the underlying interface only gets terminated after the last session has been closed. Lastly, <code class="literal">QNetworkInterface</code> provides classic information such as the hardware address or interface name.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec138"/>QNetworkConfigurationManager</h2></div></div></div><p>
<code class="literal">QNetworkConfigurationManager</code> manages all network configurations that are available on a system. You can access these configurations by calling <code class="literal">allConfigurations()</code>. Of course, you <a id="id529" class="indexterm"/>have to create an instance of the manager first:</p><div><pre class="programlisting">QNetworkConfigurationManager manager;
QList&lt;QNetworkConfiguration&gt; cfgs = manager.allConfigurations();</pre></div><p>The <a id="id530" class="indexterm"/>configurations are returned as a list. The default behavior of <code class="literal">allConfigurations()</code> is to return all possible configurations. However, you can also retrieve a filtered list. If you pass <code class="literal">QNetworkConfiguration::Active</code> as an argument, the list only contains configurations that have at least one active session. If you create a new session based on such a configuration, it will be active and connected. By passing <code class="literal">QNetworkConfiguration::Discovered</code> as an argument, you will get a list with configurations that can be used to immediately start a session. Note, however, that at this point, you cannot be sure whether the underlying interface can be started. The last important argument is <code class="literal">QNetworkConfiguration::Defined</code>. With this argument, <code class="literal">allConfigurations()</code> returns a list of configurations that are known to the system but are not usable right now. This may be a previously used WLAN hotspot, which is currently out of range.</p><p>You will be notified whenever the configurations change. If a new configuration becomes available, the manager emits the <code class="literal">configurationAdded()</code> signal. This may happen, for example, if mobile data transmission becomes available or if the user turns his/her device's WLAN adapter on. If a configuration is removed, for example, if the WLAN adapter is turned off, <code class="literal">configurationRemoved()</code> is emitted. Lastly, when a configuration <a id="id531" class="indexterm"/>gets changed, you will be notified by the <code class="literal">configurationChanged()</code> signal. All three signals pass a constant reference to the configuration about what was added, removed, or changed. The configuration <a id="id532" class="indexterm"/>passed by the <code class="literal">configurationRemoved()</code> signal is, of course, invalid. It still contains, the name and identifier of the removed configuration.</p><p>To find out whether any network interface of the system is active, call <code class="literal">isOnline()</code>. If you want to be notified about a mode change, track the <code class="literal">onlineStateChanged()</code> signal.</p><div><div><h3 class="title"><a id="tip65"/>Tip</h3><p>Since a WLAN scan takes a certain amount of time, <code class="literal">allConfigurations()</code> may not return all the available configurations. To ensure that configurations are completely populated, call <code class="literal">updateConfigurations()</code> first. Due to the long time it may take to gather all of the information about the system's network configurations, this call is asynchronous. Wait for the <code class="literal">updateCompleted()</code> signal and only then, call <code class="literal">allConfigurations()</code>.</p></div></div><p>
<code class="literal">QNetworkConfigurationManager</code> also informs you about the Bearer API's capabilities. The <code class="literal">capabilities()</code> function returns a flag of the <code class="literal">QNetworkConfigurationManager::Capabilities</code> type and describes the available possibilities that are platform-specific. The values you may be most interested in are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CanStartAndStopInterfaces</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This means that you can start and stop access points.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ApplicationLevelRoaming</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This indicates that the system will inform you if a more suitable access point is available, and that you can actively change the access point if you think there is a better one available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DataStatistics</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With this capability, <code class="literal">QNetworkSession</code> contains information about the transmitted and received data.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec139"/>QNetworkConfiguration</h2></div></div></div><p>
<code class="literal">QNetworkConfiguration</code> holds, as mentioned earlier, information about an access point. With <code class="literal">name()</code>, you get the user-visible name for a configuration, and with <code class="literal">identifier()</code>you get a unique, system-specific identifier. If you develop games for mobile devices, it may be of advantage to <a id="id533" class="indexterm"/>you to know which type of connection is being used. This might influence the data that you request; for example, the quality and thus, the size of a video. With <code class="literal">bearerType()</code>, the type of bearer used by a configuration is returned. The returned enumeration values are rather self-explanatory: <code class="literal">BearerEthernet</code>, <code class="literal">BearerWLAN</code>, <code class="literal">Bearer2G</code>, <code class="literal">BearerCDMA2000</code>, <code class="literal">BearerWCDMA</code>, <code class="literal">BearerHSPA</code>, <code class="literal">BearerBluetooth</code>, <code class="literal">BearerWiMAX</code>, and so on. You can look up the full-value list in the documentation for <code class="literal">QNetworkConfiguration::BearerType</code>.</p><p>With <code class="literal">purpose()</code>, you <a id="id534" class="indexterm"/>get the purpose of the configuration, for example, whether it is suitable to access a private network (<code class="literal">QNetworkConfiguration::PrivatePurpose</code>) or to access a public network (<code class="literal">QNetworkConfiguration::PublicPurpose</code>). The state of the configuration, if it is defined, discovered or active, as previously described, can be accessed through <code class="literal">state()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec140"/>QNetworkSession</h2></div></div></div><p>To start a <a id="id535" class="indexterm"/>network interface or to tell the system to keep an interface connected for as long as you need it, you have to start a session:</p><div><pre class="programlisting">QNetworkConfigurationManager manager;
QNetworkConfiguration cfg = manager.defaultConfiguration();
QNetworkSession *session = new QNetworkSession(cfg, this);
session-&gt;open();</pre></div><p>A session is based <a id="id536" class="indexterm"/>on a configuration. When there is more than one session and you are not sure which one to use, use <code class="literal">QNetworkConfigurationManager::defaultConfiguration()</code>. It returns the system's default configuration. Based on this, you can create an instance of <code class="literal">QNetworkSession</code>. The first argument, the configuration, is required. The second is optional but is recommended since it sets a parent and we do not have to take care of the deletion. You may want to check whether the configuration is valid (<code class="literal">QNetworkConfiguration::isValid()</code>) first. Calling <code class="literal">open()</code> will start the session and connect the interface if needed and supported. Since <code class="literal">open()</code> can take some time, the call is asynchronous. So, either listen to the <code class="literal">opened()</code> signal, which is emitted as soon as the session is open, or to the <code class="literal">error()</code> signal if an error happened. The error is of the <code class="literal">QNetworkSession::SessionError</code> type. Alternatively, instead of checking the <code class="literal">opened()</code> signal, you can also watch the <code class="literal">stateChanged()</code> signal. The possible states for a session can be: <code class="literal">Invalid</code>, <code class="literal">NotAvailable</code>, <code class="literal">Connecting</code>, <code class="literal">Connected</code>, <code class="literal">Closing</code>, <code class="literal">Disconnected</code>, and <code class="literal">Roaming</code>. If you want to make <code class="literal">open()</code> synchronous, call <code class="literal">waitForOpened()</code> right after calling <code class="literal">open()</code>. It will block the event loop till the session is open. This function will return <code class="literal">true</code> on success and <code class="literal">false</code> otherwise. To limit the waiting time, you can define a time-out. Just pass the milliseconds that you are willing to wait as an argument to <code class="literal">waitForOpened()</code>. To check whether a session is open, use <code class="literal">isOpen()</code>.</p><p>To close the session, call <code class="literal">close()</code>. If no session is left on the interface, it will be shot down. To force an interface to disconnect, call <code class="literal">stop()</code>. This call will invalidate all the sessions that are based on that interface.</p><p>You may receive the <code class="literal">preferredConfigurationChanged()</code> signal, which indicates that the preferred configuration, that is, for example, the preferred access point, has changed. This may be the case if a WLAN network is now in range and you do not have to use 2G anymore. The new configuration is passed as the first argument and the second one indicates whether changing the new access point will also alter the IP address. Besides checking for the signal, you can also inquire whether roaming is available for a configuration by calling <code class="literal">QNetworkConfiguration::isRoamingAvailable()</code>. If roaming is available, you have to decide to either reject the offer by calling <code class="literal">ignore()</code> or to accept it by calling <code class="literal">migrate()</code>. If you accept roaming, it will emit <code class="literal">newConfigurationActivated()</code> when the session is roamed. After you have checked the new connection, you can either accept the new access point or reject it. The latter means that you will return <a id="id537" class="indexterm"/>to the previous access point. If you accept <a id="id538" class="indexterm"/>the new access point, the previous one will be terminated.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec141"/>QNetworkInterface</h2></div></div></div><p>To get the <a id="id539" class="indexterm"/>interface that is used by a session, call <code class="literal">QNetworkSession::interface()</code>. It will return the <code class="literal">QNetworkInterface</code> object, which <a id="id540" class="indexterm"/>describes the interface. With <code class="literal">hardwareAddress()</code>, you get the low-level hardware address of the interface that is normally the MAC address. The name of the interface can be obtained by <code class="literal">name()</code>, which is a string such as "eth0" or "wlan0". A list of IP addresses as well as their netmasks and broadcast addresses registered with the interface is returned by <code class="literal">addressEntries()</code>. Furthermore, information about whether the interface is a loopback or whether it supports multicasting can be queried with <code class="literal">flags()</code>. The returned bitmask is a combination of these values: <code class="literal">IsUp</code>, <code class="literal">IsRunning</code>, <code class="literal">CanBroadcast</code>, <code class="literal">IsLoopBack</code>, <code class="literal">IsPointToPoint</code>, and <code class="literal">CanMulticast</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec102"/>Communicating between games</h1></div></div></div><p>After having <a id="id541" class="indexterm"/>discussed Qt's high-level network classes such as <code class="literal">QNetworkAccessManager</code> and <code class="literal">QNetworkConfigurationManager</code>, we will now have a look at a lower-level network classes and see how Qt supports you when it comes to implementing TCP or UDP servers and clients. This becomes relevant when you plan to extend your <a id="id542" class="indexterm"/>game by including a multiplayer mode. For such a task, Qt offers <code class="literal">QTcpSocket</code>, <code class="literal">QUdpSocket</code>, and <code class="literal">QTcpServer</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec103"/>Time for action – realizing a simple chat program</h1></div></div></div><p>To get <a id="id543" class="indexterm"/>familiar with <code class="literal">QTcpServer</code> and <code class="literal">QTcpSocket</code>, let's develop a simple chat program. This example will teach you the basic knowledge of network handling in Qt so that you can use this skill later to connect two or more copies of a game. At the end of this exercise, we want to see something like this:</p><div><img src="img/8874OS_07_07.jpg" alt="Time for action – realizing a simple chat program"/></div><p>On both the left-hand side and the right-hand side of the preceding figure, you can see a client, whereas the server is in the middle. We'll start by taking a closer look at the server.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec104"/>The server – QTcpServer</h1></div></div></div><p>As a protocol <a id="id544" class="indexterm"/>for communication, we will use <strong>Transmission Control Protocol</strong> (<strong>TCP</strong>). You may know this network protocol from the two most popular <a id="id545" class="indexterm"/>Internet protocols: HTTP and FTP. Both use TCP for their communication and so do the globally used protocols for e-mail traffic: SMTP, POP3, and IMAP. The main advantage of TCP, however, is its reliability and connection-based architecture. Data transferred by TCP is guaranteed to be complete, ordered, and without any duplicates. The protocol is furthermore stream orientated, which allows us to use <code class="literal">QDataStream</code> or <code class="literal">QTextStream</code>. A downside to TCP is its speed. This is because the missing data has to be retransmitted until the receiver fully receives it. By default, this causes a retransmission of all the data that was transmitted after the missing part. So, you should only choose TCP as a protocol if speed is not your top priority, but rather the completeness and correctness of the transmitted data. This applies if you send unique nonrepetitive data.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec105"/>Time for action – setting up the server</h1></div></div></div><p>A look at the <a id="id546" class="indexterm"/>server's GUI shows us that it principally consists of <code class="literal">QPlainTextEdit</code> (<code class="literal">ui-&gt;log</code>) that is used to display system messages and a button (<code class="literal">ui-&gt;disconnectClients</code>), which allows us to disconnect all the current connected clients. On top, next to the button, the server's address and port are displayed (<code class="literal">ui-&gt;address</code> and <code class="literal">ui-&gt;port</code>). After setting up the user interface in the constructor of the server's class <code class="literal">TcpServer</code>, we initiate the internally used <code class="literal">QTcpServer</code>, which is stored in the <code class="literal">m_server</code> private member variable:</p><div><pre class="programlisting">if (!m_server-&gt;listen(QHostAddress::LocalHost, 52693)) {
  ui-&gt;log-&gt;setPlainText("Failure while starting server: "
                        + m_server-&gt;errorString());
  return;
}
connect(m_server, SIGNAL(newConnection()),
        this, SLOT(newConnection()));</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec142"/>
<em>What just happened?</em>
</h2></div></div></div><p>With <code class="literal">QTcpServer::listen()</code>, we defined that the server should listen to the localhost and the <code class="literal">52693</code> port for new incoming connections. The value used here, <code class="literal">QHostAddress::LocalHost</code> of the <code class="literal">QHostAddress::SpecialAddress</code> enumeration, will resolve to <code class="literal">127.0.0.1</code>. If you instead pass <code class="literal">QHostAddress::Any</code>, the server will listen to all IPv4 interfaces as well as to IPv6 interfaces. If you only want to listen to a specific address, just pass this address as <code class="literal">QHostAddress</code>:</p><div><pre class="programlisting">m_server-&gt;listen(QHostAddress("127.0.0.1"), 0);</pre></div><p>This will behave like the one in the preceding code only in that the server will now listen to a port that will be chosen automatically. On success, <code class="literal">listen()</code> will return as <code class="literal">true</code>. So, if something goes wrong in the example it will show an error message on the text edit and exit the function. To compose the error message, we are using <code class="literal">QTcpServer::errorString()</code>, which holds a human-readable error phrase.</p><p>To handle the error in your game's code, the error string is not suitable. In any case where you need to know the exact error, use <code class="literal">QTcpServer::serverError()</code>, which returns the enumeration value of <code class="literal">QAbstractSocket::SocketError</code>. Based on this, you know exactly what went wrong, for example, <code class="literal">QAbstractSocket::HostNotFoundError</code>. If <code class="literal">listen()</code> was successful, we connect the server's <code class="literal">newConnection()</code> signal to the class's <code class="literal">newConnection()</code> slot. The signal will be emitted every time a new connection is available:</p><div><pre class="programlisting">ui-&gt;address-&gt;setText(m_server-&gt;serverAddress().toString());
ui-&gt;port-&gt;setText(QString::number(m_server-&gt;serverPort()));</pre></div><p>Lastly, we <a id="id547" class="indexterm"/>show the server's address a port number that can be accessed through <code class="literal">serverAddress()</code> and <code class="literal">serverPort()</code>. This information is needed by the clients so that they are able to connect to the server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec106"/>Time for action – reacting on a new pending connection</h1></div></div></div><p>As soon as a <a id="id548" class="indexterm"/>client tries to connect to the server, the <code class="literal">newConnection()</code> slot will be called:</p><div><pre class="programlisting">void TcpServer::newConnection() {
  while (m_server-&gt;hasPendingConnections()) {
    QTcpSocket *con = m_server-&gt;nextPendingConnection();
    m_clients &lt;&lt; con;
    ui-&gt;disconnectClients-&gt;setEnabled(true);
    connect(con, SIGNAL(disconnected()), this, SLOT(removeConnection()));
    connect(con, SIGNAL(readyRead()), this, SLOT(newMessage()));
    ui-&gt;log-&gt;insertPlainText(
      QString("* New connection: %1, port %2\n")
      .arg(con-&gt;peerAddress().toString())
      .arg(QString::number(con-&gt;peerPort())));
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec143"/>
<em>What just happened?</em>
</h2></div></div></div><p>Since more than one connection may be pending, we use <code class="literal">hasPendingConnections()</code> to determine whether there is at least one more pending connection. Each one is then handled inside the <code class="literal">while</code> loop. To get a pending connection of the <code class="literal">QTcpSocket</code> type, we call <code class="literal">nextPendingConnection()</code> and add this connection to a private list called <code class="literal">m_clients</code>, which holds all active connections. In the next line, as there is now at least one connection, we enable the button that allows all connections to be closed. Therefore, the slot connected to the button's <code class="literal">click()</code> signal will call <code class="literal">QTcpSocket::close()</code> on each single connection. When a connection is closed, its socket emits a <code class="literal">disconnected()</code> signal. We connect this signal to our <code class="literal">removeConnection()</code> slot. With the last connection, we react to the socket's <code class="literal">readyRead()</code> signal, which indicates that new data is available. In such a situation, our <code class="literal">newMessage()</code> slot is called. Lastly, we print a system message that a new connection has been established. The address and port of the connecting client and peer can be retrieved by the socket's <code class="literal">peerAddress()</code> and <code class="literal">peerPort()</code> functions.</p><div><div><h3 class="title"><a id="tip66"/>Tip</h3><p>If a new connection can't be accepted, the <code class="literal">acceptError()</code> signal is emitted instead of <code class="literal">newConnection()</code>. It passes the reason for the failure of the <code class="literal">QAbstractSocket::SocketError</code> type as an argument. If you want to temporarily decline new connections, call <code class="literal">pauseAccepting()</code> on <code class="literal">QTcpServer</code>. To <a id="id549" class="indexterm"/>resume accepting new connections, call <code class="literal">resumeAccepting()</code>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec107"/>Time for action – forwarding a new message</h1></div></div></div><p>When a <a id="id550" class="indexterm"/>connected client sends a new chat message, the underlying socket—since it inherits <code class="literal">QIODevice</code>—emits <code class="literal">readyRead()</code>, and thus, our <code class="literal">newMessage()</code> slot will be called.</p><p>Before we have a look at this slot, there is something important that you need to keep in mind. Even though TCP is ordered and without any duplicates, this does not mean that all the data is delivered in one big chunk. So, before processing the received data, we need to make sure that we get the entire message. Unfortunately, there is neither an easy way to detect whether all data was transmitted nor a globally usable method for such a task. Therefore, it is up to you to solve this problem, as it depends on the use case. Two common solutions, however, are to either send magic tokens to indicate the start and the end of a message, for example, single characters or XML tags, or you can send the size of the message upfront. The second solution is shown in the Qt documentation where the length is put in a <code class="literal">quint16</code> in front of the message. We, on the other hand, will look at an approach that uses a simple magic token to handle the messages correctly. As a delimiter, we use the "End of Transmission Block" character–ASCII code 23–to indicate the end of a message.</p><p>Since the processing of received data is quite complex, we will go through the code step by step this time:</p><div><pre class="programlisting">void TcpServer::newMessage()
{
  if (QTcpSocket *con = qobject_cast&lt;QTcpSocket*&gt;(sender())) {
    m_receivedData[con].append(con-&gt;readAll());</pre></div><p>To determine which socket called the slot, we use <code class="literal">sender()</code>. If the cast to <code class="literal">QTcpSocket</code> is successful, we enter the <code class="literal">if</code> scope and read the transferred—potentially fragmentary—message with <code class="literal">readAll()</code>.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Please note that <code class="literal">sender()</code> is used for simplicity. If you write real-life code, it is better to use <code class="literal">QSignalMapper</code>.</p></div></div><p>The <code class="literal">read</code> data is then concatenated with the previously received data that is stored in the <code class="literal">QHash</code> private member called <code class="literal">m_receivedData</code>, where the socket is used as a key:</p><div><pre class="programlisting">    if (!m_receivedData[con].contains(QChar(23)))
      return;</pre></div><p>Here we check whether the received data contains our special token, the "End of Transmission Block". Otherwise, we exit and wait for the further data to arrive, which then gets appended to the string. As soon as we have at least one special token, we proceed by splitting the data into single messages:</p><div><pre class="programlisting">    QStringList messages = m_receivedData[con].split(QChar(23));
    m_receivedData[con] = messages.takeLast();</pre></div><p>The received data contains exactly one single message for which the "End of Transmission Block" token is the last character, and thus, the messages list has two elements: the first one with the actual message and the last one without any content. This way, <code class="literal">m_receivedData[con]</code> is reset. What if <code class="literal">QChar(23)</code> is not the last character of the received text? Then, the last element is the beginning of the next, which is not yet complete, message. So, we store that message in <code class="literal">m_receivedData[con]</code>. This guarantees that no data will be lost:</p><div><pre class="programlisting">    foreach (QString message, messages) {
      ui-&gt;log-&gt;insertPlainText("Sending message: " + message + "\n");</pre></div><p>Since we do not <a id="id551" class="indexterm"/>know how many messages we will get with the last read from the socket, we need to go through the list of messages. For every message, we display a short notice on the server's log and then send it to the other clients:</p><div><pre class="programlisting">      message.append(QChar(23));
      foreach (QTcpSocket *socket, m_clients) {
        if (socket == con)
          continue;
        if (socket-&gt;state() == QAbstractSocket::ConnectedState)
          socket-&gt;write(message.toLocal8Bit());
      }
    }
  }
}</pre></div><p>Before sending the message, we append <code class="literal">QChar(23)</code> to indicate the end of the message, of course, and then send it to all the connected clients, except the one who sent it in the first place, by simply calling write on the socket. Since the socket inherits <code class="literal">QIODevice</code>, you can use most of the functions that you know from <code class="literal">QFile</code>.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec144"/>Have a go hero – using QSignalMapper</h2></div></div></div><p>As <a id="id552" class="indexterm"/>discussed earlier, using <code class="literal">sender()</code> is a convenient, but <a id="id553" class="indexterm"/>not an object-orientated, approach. Thus, try to use <code class="literal">QSignalMapper</code> instead to determine which socket called the slot. To achieve this, you have to connect the socket's <code class="literal">readyRead()</code> signal to a mapper and the slot directly. All the signal-mapper-related code will go into the <code class="literal">newConnection()</code> slot.</p><p>The same applies to the <a id="id554" class="indexterm"/>connection to the <code class="literal">removeConnection()</code> slot. Let's have a look at it next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec108"/>Time for action – detecting a disconnect</h1></div></div></div><p>When a <a id="id555" class="indexterm"/>client terminates the connection, we have to delete the socket from the local <code class="literal">m_clients</code> list. Therefore, we have to connected the socket's <code class="literal">disconnected()</code> signal to:</p><div><pre class="programlisting">void TcpServer::removeConnection()
{
  if (QTcpSocket *con = qobject_cast&lt;QTcpSocket*&gt;(sender())) {
    ui-&gt;log-&gt;insertPlainText(
      QString("* Connection removed: %1, port %2\n")
      .arg(con-&gt;peerAddress().toString())
      .arg(QString::number(con-&gt;peerPort())));
    m_clients.removeOne(con);
    con-&gt;deleteLater();
    ui-&gt;disconnectClients-&gt;setEnabled(!m_clients.isEmpty());
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec145"/>
<em>What just happened?</em>
</h2></div></div></div><p>After getting the socket that emitted the call through <code class="literal">sender()</code>, we post the information that a socket is being removed. Then, we remove the socket from <code class="literal">m_clients</code> and call <code class="literal">deleteLater()</code> on it. Do not use delete. Lastly, if no client is left, the disconnect button is disabled.</p><p>This is the first part. Now let's have a look at the client.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec109"/>The client</h1></div></div></div><p>The graphical user <a id="id556" class="indexterm"/>interface of the client (<code class="literal">TcpClient</code>) is pretty simple. It has three input fields to define the server's address (<code class="literal">ui-&gt;address</code>), the server's port (<code class="literal">ui-&gt;port</code>), and a username (<code class="literal">ui-&gt;user</code>). Of course, there is also a button to connect to (<code class="literal">ui-&gt;connect</code>) and disconnect from (<code class="literal">ui-&gt;disconnect</code>) the server. Finally, the GUI has a text edit that holds the received messages (<code class="literal">ui-&gt;chat</code>) and a line edit (<code class="literal">ui-&gt;text</code>) to send messages.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec110"/>Time for action – setting up the client</h1></div></div></div><p>When the <a id="id557" class="indexterm"/>user has provided the server's address and port and has chosen a username, he/she can connect to the server:</p><div><pre class="programlisting">void TcpClient::on_connect_clicked()
{
  //...
  if (m_socket-&gt;state() != QAbstractSocket::ConnectedState) {
    m_socket-&gt;connectToHost(ui-&gt;address-&gt;text(), ui-&gt;port-&gt;value());
    ui-&gt;chat-&gt;insertPlainText("== Connecting...\n");
  }
  //...
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec146"/>
<em>What just happened?</em>
</h2></div></div></div><p>The private member variable <code class="literal">m_socket</code> holds an instance of <code class="literal">QTcpSocket</code>. If this socket is already connected, nothing happens. Otherwise, the socket is connected to the given address and port by calling <code class="literal">connectToHost()</code>. Besides the obligatory server address and port number, you can pass a third argument to define the mode in which the socket will be opened. For possible values, you can use <code class="literal">OpenMode</code> just like we did for <code class="literal">QIODevice</code>. Since this call is asynchronous, we print a notification to the chat, so that the user is informed that the application is currently trying to connect to the server. When the connection is established, the socket sends the <code class="literal">connected()</code> signal that prints "Connected to server" on the chat to indicate that we have connected to a slot. Besides the messages in the chat, we also updated the GUI by, for example, disabling the connect button, but this is all basic stuff. You won't have any trouble understanding this if you have had a look at the sources. So, these details are left out here.</p><p>Of course, something <a id="id558" class="indexterm"/>could go wrong when trying to connect to a server, but luckily, we are informed about a failure as well through the <code class="literal">error()</code> signal passing a description of error in the form of <code class="literal">QAbstractSocket::SocketError</code>. The most frequent errors will probably be <code class="literal">QAbstractSocket::ConnectionRefusedError</code> if the peer refused the connection or <code class="literal">QAbstractSocket::HostNotFoundError</code> if the host address could not be found. If the connection, however, was successfully established, it should be closed later on. You can either call <code class="literal">abort()</code> to immediately close the socket, whereas <code class="literal">disconnectFromHost()</code> will wait until all pending data has been written.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec111"/>Time for action – receiving text messages</h1></div></div></div><p>In the <a id="id559" class="indexterm"/>constructor, we have connected the socket's <code class="literal">readyRead()</code> signal to a local slot. So, whenever the server sends a message through <code class="literal">QTcpSocket::write()</code>, we read the data and display it in the chat window:</p><div><pre class="programlisting">m_receivedData.append(m_socket-&gt;readAll());
if (!m_receivedData.contains(QChar(23)))
  return;

QStringList messages = m_receivedData.split(QChar(23));
m_receivedData = messages.takeLast();
foreach (const QString &amp;message, messages) {
  ui-&gt;chat-&gt;insertPlainText(message + "\n");
}</pre></div><p>As you already know, <code class="literal">QTcpSocket</code> inherits <code class="literal">QIODevice</code>, so we use <code class="literal">QIODevice::readAll()</code> to get the entire text that was sent. Next, we store the received data and determine whether the message was transmitted completely. This approach is the same as we <a id="id560" class="indexterm"/>used previously for the server. Lastly, in the <code class="literal">for</code> loop, we add the messages to the chat window.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec112"/>Time for action – sending text messages</h1></div></div></div><p>What is left is <a id="id561" class="indexterm"/>now is to describe how to send a chat massage. On hitting return inside the line edit, a local slot will be called that checks whether there is actual text to send and whether <code class="literal">m_socket</code> is still connected:</p><div><pre class="programlisting">QString message = m_user + ": " + ui-&gt;text-&gt;text();
m_socket-&gt;write(message.toLocal8Bit());
ui-&gt;text-&gt;clear();</pre></div><p>If so, a message is composed that contains the self-given username, a colon, and the text of the line edit. To send this string to the peer, the <code class="literal">QTcpSocket::write()</code> server is called. Since <code class="literal">write()</code> only accepts const <code class="literal">char*</code> or <code class="literal">QByteArray</code>, we use <code class="literal">QString::toLocal8Bit()</code> to get <code class="literal">QByteArray</code> that we can send over the socket.</p><p>That's all. It's like writing and reading from a file. For the complete example, have a look at the sources bundled with this book and run the server and several clients.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec147"/>Have a go hero – extending the chat with a user list</h2></div></div></div><p>This <a id="id562" class="indexterm"/>example has shown us how to send a simple text. If you now go on and define a schema for how the communication should work, you can use it as a base for more complex communication. For instance, if you want to enable the client to receive a list of all other clients (and their usernames), you need to define that the server will return such a list if it gets a message such as <code class="literal">rq:allClients</code> from a client. Therefore, you have to parse all messages received by the server before forwarding them to all the connected clients. Go ahead and try to implement such a requirement yourself. By now, it is possible that multiple users have chosen the same username. With the new functionality of getting a user list, you can prevent this from happening. Therefore, you have to send the username to the server that keeps track of them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec113"/>Improvements</h1></div></div></div><p>The example we explained uses a nonblocking, asynchronous approach. For example, after asynchronous <a id="id563" class="indexterm"/>calls such as <code class="literal">connectToHost()</code>, we do not block the thread until we get a result, but instead, we connect to the socket's signals to proceed. On the Internet as well as Qt's documentation, on the other hand, you will find dozens of examples explaining the blocking and the synchronous approaches. You will easily spot them by their use of <code class="literal">waitFor...()</code> functions. These functions block the current thread until a function such as <code class="literal">connectToHost()</code> has a result—the time <code class="literal">connected()</code> or <code class="literal">error()</code> will be emitted. The corresponding blocking function to <code class="literal">connectToHost()</code> is <code class="literal">waitForConnected()</code>. The other blocking functions that can be used are <code class="literal">waitForReadyRead()</code>, which waits until new data is available on a socket for reading; <code class="literal">waitForBytesWritten()</code>, which waits until the data has been written to the socket; and <code class="literal">waitForDisconnected()</code>, which waits until the connection has been closed.</p><p>Look out; even if Qt offers these <code class="literal">waitFor...()</code> functions, do not use them! The synchronous approach is not the smartest one since it will freeze your game's GUI. A frozen GUI is the worst <a id="id564" class="indexterm"/>thing that can happen in your game and it will annoy every user. So, when working inside the GUI thread, you are better to react to the <code class="literal">QIODevice::readyRead()</code>, <code class="literal">QIODevice::bytesWritten()</code>, <code class="literal">QAbstractSocket::connected()</code>, and <code class="literal">QAbstractSocket::disconnected()</code> corresponding signals.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>
<code class="literal">QAbstractSocket</code> is the base class of <code class="literal">QTcpSocket</code> as well as of <code class="literal">QUdpSocket</code>.</p></div></div><p>Following the asynchronous approach shown, the application will only become unresponsive while both reading and writing to the socket as well as during determining whether a message is complete. The optimum, however, would be to move the entire socket handling to an extra thread. Then, the GUI thread would only get signals, passing the new messages, and to send, it would simply pass <code class="literal">QString</code> to the worker thread. This way, you will get a super fluent velvet GUI.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec114"/>Using UDP</h1></div></div></div><p>In contrast to <a id="id565" class="indexterm"/>TCP, UDP is unreliable and connectionless. Neither the order of packets, nor their delivery is guaranteed. UDP, however, is very fast. So, if you have frequent data, which does not necessarily need to be received by the peer, use UDP. This data could, for example, be real-time positions of a player that get updated frequently or live video/audio streaming. Since <code class="literal">QUdpSocket</code> is mostly the same as <code class="literal">QTcpSocket</code>—both inherit <code class="literal">QAbstractSocket</code>—there is not much to explain. The main difference between them is that TCP is stream-orientated, whereas UDP is datagram-orientated. This means that the data is sent in small packages, containing among the actual content, the sender's as well as the receiver's IP address and port number. Due to the lack of <code class="literal">QUdpServer</code>, you have to use <code class="literal">QAbstractSocket::bind()</code> instead of <code class="literal">QTcpServer::listen()</code>. Like <code class="literal">listen()</code>, <code class="literal">bind()</code> takes the addresses and ports that are allowed to send datagrams as arguments. Whenever a new package arrives, the <code class="literal">QIODevice::readyRead()</code> signal is emitted. To read the data, use the <code class="literal">readDatagram()</code> function, which takes four parameters. The first one of the <code class="literal">char*</code> type is used to write the data in, the second specifies the amount of bytes to be written, and the last two parameters of the <code class="literal">QHostAddress*</code> and <code class="literal">quint16*</code> types are used to store the sender's IP address and port number. Sending data works likewise: <code class="literal">writeDatagram()</code> sends the first argument's data of the <code class="literal">char*</code> type to the <a id="id566" class="indexterm"/>host, which is defined by the third (address) and fourth (port number) argument. With the second parameter, you can limit the amount of data to be sent.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec115"/>Time for action – sending a text via UDP</h1></div></div></div><p>As an <a id="id567" class="indexterm"/>example, let's assume that we have two sockets of the <code class="literal">QUpSocket</code> type. We will call the first one <code class="literal">socketA</code> and the other <code class="literal">socketB</code>. Both are bound to the localhost, <code class="literal">socketA</code> to the <code class="literal">52000</code> port and <code class="literal">socketB</code> to the <code class="literal">52001</code> port. So, if we want to send the string "Hello!" from <code class="literal">socketA</code> to <code class="literal">socketB</code>, we have to write in the application that is holding <code class="literal">socketA</code>:</p><div><pre class="programlisting">socketA-&gt;writeDatagram(QByteArray("Hello!"), QHostAddress("127.0.0.1"), 52001);</pre></div><p>Here, we have used the convenient function of <code class="literal">writeDatagram()</code>, which takes <code class="literal">QByteArray</code> instead of const <code class="literal">char*</code> and <code class="literal">qint64</code>. The class that holds <code class="literal">socketB</code> must have the socket's <code class="literal">readyRead()</code> signal connected to a slot. This slot will then be called because of our <code class="literal">writeDatagram()</code> call, assuming that the datagram is not lost! In the slots, we read the datagram and the sender's address and port number with:</p><div><pre class="programlisting">while (socketB-&gt;hasPendingDatagrams()) {
  QByteArray datagram;
  datagram.resize(socketB-&gt;pendingDatagramSize())
  QHostAddress sender;
  quint16 senderPort;
  socketB-&gt;readDatagram(datagram.data(), datagram.size(),
                       &amp;sender, &amp;senderPort);
  // do something with datagram, sender and port.
}</pre></div><p>As long as there are pending datagrams—this is checked by <code class="literal">hasPendingDatagrams()</code>, which returns <code class="literal">true</code> as long as there are pending datagrams—we read them. This is done by creating <code class="literal">QByteArray</code>, which is used to store the transferred datagram. To be able to hold the entire transmitted data, it is resized to the length of the pending datagram. This information is retrieved by <code class="literal">pendingDatagramSize()</code>. Next we create <code class="literal">QHostAddress</code> and <code class="literal">quint16</code> so that <code class="literal">readDatagram()</code> can store the sender's address and port number in these variables. Now, all is set up to call <code class="literal">readDatagram()</code> so that we get the datagram.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec148"/>Have a go hero – connecting players of the Benjamin game</h2></div></div></div><p>With this <a id="id568" class="indexterm"/>introductory knowledge, you can go ahead and try some stuff by yourself. For example, you can take the game Benjamin the elephant and send Benjamin's current position from one client to another. This way, you can either clone the screen from one client to the other or both clients can play the game and <a id="id569" class="indexterm"/>additionally can see where the elephant of the other player currently is. For such a task, you would use UDP, as it is important that the position is updated very fast while it isn't a disaster when one position gets lost.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec149"/>Pop quiz – test your knowledge</h2></div></div></div><p>Q1. Which three (main) classes do you need to download a file?</p><p>Q2. How can you download only the first 100 bytes of a file?</p><p>Q3. If you need to extend a URL by parameters with special characters, you need to escape them with <code class="literal">QUrl::toPercentEncoding()</code>. Which other, more convenient, option does Qt offer?</p><p>Q4. How do you delete <code class="literal">QNetworkReply</code> received from <code class="literal">QNetworkAccessManager</code>?</p><p>Q5. What is the type hierarchy of <code class="literal">QTcpSocket</code> and <code class="literal">QUdpSocket</code> and what's the big advantage of this hierarchy?</p><p>Q6. The <code class="literal">readDatagram()</code> function belongs to <code class="literal">QTcpSocket</code> or <code class="literal">QUdpSocket</code>?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec116"/>Summary</h1></div></div></div><p>In the first part of this chapter, you familiarized yourself with <code class="literal">QNetworkAccessManager</code>. This class is at the heart of your code whenever you want to download or upload files to the Internet. After having gone through the different signals that you can use to fetch errors, to get notified about new data or to show the progress, you should now know everything you need on that topic.</p><p>The example about the Distance Matrix API depended your knowledge of <code class="literal">QNetworkAccessManager</code>, and it shows you a real-life application case for it. Dealing with JSON as the server's reply format was a recapitulation of <a class="link" href="ch04.html" title="Chapter 4. Qt Core Essentials">Chapter 4</a>, <em>Qt Core Essentials</em>, but was highly needed since Facebook or Twitter only use JSON to format their network replies.</p><p>In the last section, you learned how to set up your own TCP server and clients. This enables you to connect different instances of a game to provide the multiplayer functionality. Alternatively, you were taught how to use UDP.</p><p>Please keep in mind that we only scratched the surface of this topic due to its complexity. Covering it fully would have exceeded this beginner's guide. For a real game, which uses a network, you should learn more about Qt's possibilities for establishing a secure connection via SSL or some other mechanism.</p><p>In the next chapter, you'll learn how to extend your game with a scripting engine. This allows you to, for example, easily change various aspects of your game without the need for recompiling it.</p></div></body></html>