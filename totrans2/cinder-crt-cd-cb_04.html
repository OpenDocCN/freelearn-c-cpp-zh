<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Multimedia Content</h1></div></div></div><p>In this chapter we will learn about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading and displaying video</li><li class="listitem" style="list-style-type: disc">Creating a simple video controller</li><li class="listitem" style="list-style-type: disc">Saving window content as an image</li><li class="listitem" style="list-style-type: disc">Saving window animation as video</li><li class="listitem" style="list-style-type: disc">Saving window content as a vector graphics image</li><li class="listitem" style="list-style-type: disc">Saving high resolution images with tile renderer</li><li class="listitem" style="list-style-type: disc">Sharing graphics between applications</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Introduction</h1></div></div></div><p>Most interesting applications use multimedia content in some form or another. In this chapter we will start by learning how to load, manipulate, and display video. We will then move on to saving our graphics into images, image sequences, or video, and then we will move to recording sound visualization.</p><p>Lastly, we will learn how to share graphics between applications and how to save mesh data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Loading and displaying video</h1></div></div></div><p>In this recipe, we will learn how <a id="id247" class="indexterm"/>to load a video from a file and display it on screen using Quicktime and OpenGL. <a id="id248" class="indexterm"/>We'll learn how to load a file as a resource or from a file selected by the user using a file open dialog.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec103"/>Getting ready</h2></div></div></div><p>You need to have QuickTime installed and also a video file in a format compatible with QuickTime.</p><p>To load the video as a resource it is necessary<a id="id249" class="indexterm"/> to copy it to the <code class="literal">resources</code> folder in your project. To learn more on resources, please read the recipes <em>Using resources on Windows</em> and <em>Using resources on OSX and iOS</em> from <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How to do it…</h2></div></div></div><p>We will use Cinder's QuickTime wrappers to load and display vido.<a id="id250" class="indexterm"/></p><div><ol class="orderedlist arabic"><li class="listitem">Include the headers containing the Quicktime and OpenGL functionality by adding the following at the beginning of the source file:<div><pre class="programlisting">#include "cinder/qtime/QuickTime.h"
#include "cinder/gl/gl.h"
#include "cinder/gl/Texture.h"</pre></div></li><li class="listitem">Declare a <code class="literal">ci::qtime::MovieGl</code> member in you application's class declaration. This example will only need the <code class="literal">setup</code>, <code class="literal">update</code>, and <code class="literal">draw</code> methods, so make sure at least these are declared:<div><pre class="programlisting">using namespace ci;
using namespace ci::app;

class MyApp : public AppBasic {
public:
  void setup();
  void update();
  void draw();

qtime::MovieGl mMovie;
gl::Texture mMovieTexture;
};</pre></div></li><li class="listitem">To load the video as a resource use the <code class="literal">ci::app::loadResource</code> method with the file name as <code class="literal">parameter</code> and pass the resulting <code class="literal">ci::app::DataSourceRef</code> when constructing the movie object. It is also good practice to place the loading resource inside a <code class="literal">trycatch</code> segment in order to catch any resource loading errors. Place the following code inside your <code class="literal">setup</code> method:<div><pre class="programlisting">try{
mMovie = qtime::MovieGl( loadResource( "movie.mov" ) );
    } catch( Exception e){
console() &lt;&lt;e.what()&lt;&lt;std::endl;
    }</pre></div></li><li class="listitem">You can also load the video by using a file open dialog and passing the file path as an argument <a id="id251" class="indexterm"/>when constructing the <code class="literal">mMovie</code> object. Your <code class="literal">setup</code> <a id="id252" class="indexterm"/>would instead have the following code:<div><pre class="programlisting">try{
fs::path path = getOpenFilePath();
mMovie = qtime::MovieGl( path );
    } catch( Exception e){
console() &lt;&lt;e.what()&lt;&lt;std::endl;
    }</pre></div></li><li class="listitem">To play the video, call the <code class="literal">play</code> method on the movie object. You can test the successful instantiation of <code class="literal">mMovie</code> by placing it inside an <code class="literal">if</code> statement just like an ordinary pointer:<div><pre class="programlisting">If( mMovie ){
mMovie.play();
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method we copy the texture of the current movie frame into our <code class="literal">mMovieTexture</code> to draw it later:<div><pre class="programlisting">void MyApp::update(){
if( mMovie ){
mMovieTexture = mMovie.getTexture();
}</pre></div></li><li class="listitem">To draw the movie we simply need to draw our texture on screen using the method <code class="literal">gl::draw</code>. We need to check if the texture is valid because <code class="literal">mMovie</code> may take a while to load. We'll also create <code class="literal">ci::Rectf</code> with the texture size and center it on screen to keep the drawn video centered without stretching:<div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
if( mMovieTexture ){
Rect frect = Rectf( mMovieTexture.getBounds() ).getCenteredFit( getWindowBounds(), true );
gl::draw( mMovieTexture, rect );
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How it works…</h2></div></div></div><p>The <code class="literal">ci::qtime::MovieGl</code> class <a id="id253" class="indexterm"/>allows playback and control of movies by wrapping around the QuickTime framework. Movie<a id="id254" class="indexterm"/> frames are copied into OpenGl textures for easy drawing. To access the texture of the current frame of the movie use the method <code class="literal">ci::qtime::MovieGl::getTexture()</code> which returns a <code class="literal">ci::gl::Texture</code> object. Textures used by <code class="literal">ci::qtime::MovieGl</code> are always bound to the <code class="literal">GL_TEXTURE_RECTANGLE_ARB</code> target.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec106"/>There's more</h2></div></div></div><p>If you wish to do iterations over<a id="id255" class="indexterm"/> the pixels of a movie consider using the class <code class="literal">ci::qtime::MovieSurface</code>. This class allows playback of movies by wrapping around the QuickTime framework, but converts movie frames into <code class="literal">ci::Surface</code> objects. To access the current frame's surface, use<a id="id256" class="indexterm"/> the method <code class="literal">ci::qtime::MovieSurface::getSurface()</code> which returns a <code class="literal">ci::Surface</code> object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Creating a simple video controller</h1></div></div></div><p>In this recipe we'll learn how<a id="id257" class="indexterm"/> to create a simple video controller using the built-in GUI functionalities of Cinder.</p><p>We'll control movie playback, if the movie loops or not, the speed rate, volume, and the position.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec107"/>Getting ready</h2></div></div></div><p>You must have Apple's QuickTime installed and a movie file in a format compatible with QuickTime.</p><p>To learn how to load and display<a id="id258" class="indexterm"/> a movie please refer to the previous recipe <em>Loading and displaying Video</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec108"/>How to do it…</h2></div></div></div><p>We will create a simple interface using Cinder <code class="literal">params</code> classes to control a video.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary files to work with Cinder <code class="literal">params</code> (QuickTime and OpenGl) by adding the following at the top of the source file:<div><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/gl/Texture.h"
#include "cinder/qtime/QuickTime.h"
#include "cinder/params/Params.h"
#include "cinder/Utilities.h"</pre></div></li><li class="listitem">Add the <code class="literal">using</code> statements before the application's class declaration to simplify calling Cinder commands as shown in the following code lines:<div><pre class="programlisting">using namespace ci;
using namespace ci::app;
using namespace ci::gl;</pre></div></li><li class="listitem">Declare a <code class="literal">ci::qtime::MovieGl</code>, <code class="literal">ci::gl::Texture</code>, and a <code class="literal">ci::params::InterfaceGl</code> object to play, render, and control the video respectively. Add the following to your class declaration:<div><pre class="programlisting">Texture mMovieTexture;
qtime::MovieGl mMovie;
params::InterfaceGl mParams;</pre></div></li><li class="listitem">Select a video file <a id="id259" class="indexterm"/>by opening an open file dialog and use that path to initialize our <code class="literal">mMovie</code>. The following code should go in the <code class="literal">setup</code> method:<div><pre class="programlisting">try{
fs::path path = getOpenFilePath();
mMovie = qtime::MovieGl( path );
}catch( … ){
  console() &lt;&lt; "could not open video file" &lt;&lt;std::endl;
}</pre></div></li><li class="listitem">We'll also need some variables to store the values which we'll manipulate. Each controllable parameter of the video will have two variables to represent the current and the previous value of that parameter. Now declare the following variables:<div><pre class="programlisting">float mMoviePosition, mPrevMoviePosition;
float mMovieRate, mPrevMovieRate;
float mMovieVolume, mPrevMovieVolume;
bool mMoviePlay, mPrevMoviePlay;
bool mMovieLoop, mPrevMovieLoop;</pre></div></li><li class="listitem">Set the default values in the <code class="literal">setup</code> method:<div><pre class="programlisting">mMoviePosition = 0.0f;
mPrevMoviePosition = mMoviePosition;
mMovieRate = 1.0f;
mPrevMovieRate = mMovieRate;
mMoviePlay = false;
mPrevMoviePlay = mMoviePlay;
mMovieLoop = false;
mPrevMovieLoop = mMovieLoop;
mMovieVolume = 1.0f;
mPrevMovieVolume = mMovieVolume;</pre></div></li><li class="listitem">Now let's initialize <code class="literal">mParams</code> and add a control for each of the previously defined variables and set the <code class="literal">max</code>, <code class="literal">min</code>, and <code class="literal">step</code> values when necessary. The following code must go in the <code class="literal">setup</code> method:<div><pre class="programlisting">mParams = params::InterfaceGl( "Movie Controller", Vec2i( 200, 300 ) ); 
if( mMovie ){
string max = ci::toString( mMovie.getDuration() );
mParams.addParam( "Position", &amp;mMoviePosition, "min=0.0 max=" + max + " step=0.5" );

mParams.addParam( "Rate", &amp;mMovieRate, "step=0.01" );

mParams.addParam( "Play/Pause", &amp;mMoviePlay );

mParams.addParam( "Loop", &amp;mMovieLoop );

mParams.addParam( "Volume", &amp;mMovieVolume, "min=0.0 max=1.0 step=0.01" );
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method<a id="id260" class="indexterm"/> we'll check if the movie was valid and compare each of the parameters to their previous state to see if they changed. If it did, we'll update <code class="literal">mMovie</code> and set the parameter to the new value. The following code lines go in the <code class="literal">update</code> method:<div><pre class="programlisting">if( mMovie ){

if( mMoviePosition != mPrevMoviePosition ){
mPrevMoviePosition = mMoviePosition;
mMovie.seekToTime( mMoviePosition );
        } else {
mMoviePosition = mMovie.getCurrentTime();
mPrevMoviePosition = mMoviePosition;
        }
if( mMovieRate != mPrevMovieRate ){
mPrevMovieRate = mMovieRate;
mMovie.setRate( mMovieRate );
        }
if( mMoviePlay != mPrevMoviePlay ){
mPrevMoviePlay = mMoviePlay;
if( mMoviePlay ){
mMovie.play();
            } else {
mMovie.stop();
            }
        }
if( mMovieLoop != mPrevMovieLoop ){
mPrevMovieLoop = mMovieLoop;
mMovie.setLoop( mMovieLoop );
        }
if( mMovieVolume != mPrevMovieVolume ){
mPrevMovieVolume = mMovieVolume;
mMovie.setVolume( mMovieVolume );
        }
    }</pre></div></li><li class="listitem">In the <code class="literal">update</code> method<a id="id261" class="indexterm"/> it is also necessary to get a handle to the movie texture and copy it to our previously declared <code class="literal">mMovieTexture</code>. In the <code class="literal">update</code> method we write:<div><pre class="programlisting">if( mMovie ){
mMovieTexture = mMovie.getTexture();
}</pre></div></li><li class="listitem">All that is left is to draw our content. In the <code class="literal">draw</code> method we'll clear the background with black. We'll check the validity of <code class="literal">mMovieTexture</code> and draw it in a rectangle that fits on the window. We also call the <code class="literal">draw</code> command of <code class="literal">mParams</code> to draw the controls on top of the video:<div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 

if( mMovieTexture ){
Rectf rect = Rectf( mMovieTexture.getBounds() ).getCenteredFit( getWindowBounds(), true );
gl::draw( mMovieTexture, rect );
    }

mParams.draw();</pre></div></li><li class="listitem">Draw it and you'll see the application's window with a black background along with the controls. Change the various parameters in the parameters menu and you'll see it affecting the video:<div><img src="img/8703OS_4_1.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How it works…</h2></div></div></div><p>We created a <code class="literal">ci::params::InterfaceGl</code> object and added a control for each of the parameters we wanted to manipulate.</p><p>We created a variable for<a id="id262" class="indexterm"/> each of the parameters we want to manipulate and a variable to store their previous value. In the update we checked to see if these values differ, which will only happen when the user has changed their value using the <code class="literal">mParams</code> menu.</p><p>When the parameter changes we change the <code class="literal">mMovie</code> parameter with the value the user has set.</p><p>Some parameters must be kept in a specific range. The movie position is set in seconds from <code class="literal">0</code> to the maximum duration of the video in seconds. The volume must be a value between <code class="literal">0</code> and <code class="literal">1</code>, <code class="literal">0</code> meaning no audio and <code class="literal">1</code> <a id="id263" class="indexterm"/>being the maximum volume.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Saving window content as an image</h1></div></div></div><p>In this example we will show you how to save window content to the graphic file and how to implement this<a id="id264" class="indexterm"/> functionality in your Cinder application. This could be useful to save output of a graphics algorithm.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec110"/>How to do it…</h2></div></div></div><p>We will add a window content saving function to your application:</p><div><ol class="orderedlist arabic"><li class="listitem">Add necessary headers:<div><pre class="programlisting">#include "cinder/ImageIo.h"
#include "cinder/Utilities.h"</pre></div></li><li class="listitem">Add property to your application's main class:<div><pre class="programlisting">bool mMakeScreenshot;</pre></div></li><li class="listitem">Set a default value inside the <code class="literal">setup</code> method:<div><pre class="programlisting">mMakeScreenshot = false;</pre></div></li><li class="listitem">Implement the <code class="literal">keyDown</code> method as follows:<div><pre class="programlisting">void MainApp::keyDown(KeyEvent event)
  {
  if(event.getChar() == 's') {
  mMakeScreenshot = true;
    }
  }</pre></div></li><li class="listitem">Add the following code at the end of the <code class="literal">draw</code> method:<div><pre class="programlisting">if(mMakeScreenshot) {
mMakeScreenshot = false;
writeImage( getDocumentsDirectory() / fs::path("MainApp_screenshot.png"), copyWindowSurface() );
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec111"/>How it works…</h2></div></div></div><p>Every time you set <code class="literal">mMakeScreenshot</code> to <code class="literal">true</code> the screenshot of your application will be selected and saved. In this case the application waits for the <em>S</em> key to be pressed and then sets the flag <code class="literal">mMakeScreenshot</code> to <code class="literal">true</code>. The current application window screenshot will be saved inside your documents directory under the name <code class="literal">MainApp_screenshot.png</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec112"/>There's more...</h2></div></div></div><p>This is just the basic example of common usage of the <code class="literal">writeImage</code> function. There are many other practical applications.<a id="id265" class="indexterm"/></p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Saving window animation as image sequences</h3></div></div></div><p>Let's say you want to record a equence of images Perform the following steps to do so:<a id="id266" class="indexterm"/></p><div><ol class="orderedlist arabic"><li class="listitem">Modify the previous code snippet shown in step 5 for saving the window content as follows:<div><pre class="programlisting">if(mMakeScreenshot || mRecordFrames) {
mMakeScreenshot = false;
writeImage( getDocumentsDirectory() / fs::path("MainApp_screenshot_" + toString(mFramesCounter) + ".png"), copyWindowSurface() );
mFramesCounter++;
}</pre></div></li><li class="listitem">You have to define <code class="literal">mRecordFrames</code> and <code class="literal">mFrameCounter</code> as properties of your main application class:<div><pre class="programlisting">bool mRecordFrames;
int mFramesCounter;</pre></div></li><li class="listitem">Set initial values inside the <code class="literal">setup</code> method:<div><pre class="programlisting">mRecordFrames = false;
mFramesCounter = 1;</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Recording sound visualization</h3></div></div></div><p>We assume that you are<a id="id267" class="indexterm"/> using <code class="literal">TrackRef</code> from the <code class="literal">audio</code> namespace to play your sound Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Implement the previous steps for saving window animations as image sequences.</li><li class="listitem">Type the following lines of code at the beginning of the <code class="literal">update</code> method:<div><pre class="programlisting">if(mRecordFrames) {
mTrack-&gt;setTime(mFramesCounter / 30.f);
}</pre></div></li></ol></div><p>We are calculating the desired audio track position based on the number of frames that passed. We are doing that to synchronize animation with the music track. In this case we want to produce <code class="literal">30</code> fps animation so we are dividing <code class="literal">mFramesCounter</code> by <code class="literal">30</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Saving window animations as video</h1></div></div></div><p>In this recipe,we'll start by drawing a simple animation and learning how to export it to video. We will <a id="id268" class="indexterm"/>create a video where pressing any key will start or stop the recording.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec113"/>Getting ready</h2></div></div></div><p>You must have Apple's QuickTime installed. Make sure you know where you want your video to be saved, as you'll have to specify its location at the beginning.</p><p>It could be anything that is drawn using OpenGl but for this example, we'll create a yellow circle at the center of the window with a changing radius. The radius is calculated by the absolute value of the sine of the elapsed seconds since the application launched. We multiply this value by <code class="literal">200</code> to scale it up. Now add the following to the <code class="literal">draw</code> method:</p><div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) );     
float radius = fabsf( sinf( getElapsedSeconds() ) ) * 200.0f;
Vec2f center = getWindowCenter();
gl::color( Color( 1.0f, 1.0f, 0.0f ) );
gl::drawSolidCircle( center, radius );</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec114"/>How to do it…</h2></div></div></div><p>We will use the <code class="literal">ci::qtime::MovieWriter</code> class to create a video of our rendering.</p><div><ol class="orderedlist arabic"><li class="listitem">Include the OpenGl and QuickTime files at the beginning of the source file by adding the following:<div><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/qtime/MovieWriter.h"</pre></div></li><li class="listitem">Now let's declare a <code class="literal">ci::qtime::MovieWriter</code> object and a method to initialize it.  Add the following to your class declaration:<div><pre class="programlisting">qtime::MovieWriter mMovieWriter;
void initMovieWriter();</pre></div></li><li class="listitem">In the implementation of <code class="literal">initMovieWriter</code> we start by asking the user to specify a path using a save file dialog and use it to initialize the movie writer. The movie writer also needs to know the window's width and height. Here's the implementation of <code class="literal">initMovieWriter</code>.<div><pre class="programlisting">void MyApp::initMovieWriter(){
fs::path path = getSaveFilePath();
if( path.empty() == false ){
mMovieWriter = qtime::MovieWriter( path, getWindowWidth(), getWindowHeight() );
    }
}</pre></div></li><li class="listitem">Lets declare a key event handler by declaring the <code class="literal">keyUp</code> method.<div><pre class="programlisting">void keyUp( KeyEvent event );</pre></div></li><li class="listitem">In its implementation we will see if there is already a movie being recorded by checking the validity of <code class="literal">mMovieWriter</code>. If it is a valid object then we must save the current movie <a id="id269" class="indexterm"/>by destroying the object. We can do so by calling the <code class="literal">ci::qtime::MovieWriter</code> default constructor; this will create a null instance. If <code class="literal">mMovieWriter</code> is not a valid object then we initialize a new movie writer by calling the method <code class="literal">initMovieWriter()</code>.<div><pre class="programlisting">void MovieWriterApp::keyUp( KeyEvent event ){
if( mMovieWriter ){
mMovieWriter = qtime::MovieWriter();
    } else {
initMovieWriter();
    }
}</pre></div></li><li class="listitem">The last two steps are to check if <code class="literal">mMovieWriter</code> is valid and to add a frame by calling the method <code class="literal">addFrame</code> with the window's surface. This method has to be called in the <code class="literal">draw</code> method, after our drawing routines have been made. Here's the final <code class="literal">draw</code> method, including the circle drawing code.<div><pre class="programlisting">void MyApp::draw()
{
  gl::clear( Color( 0, 0, 0 ) ); 

float radius = fabsf( sinf( getElapsedSeconds() ) ) * 200.0f;
    Vec2f center = getWindowCenter();
gl::color( Color( 1.0f, 1.0f, 0.0f ) );
gl::drawSolidCircle( center, radius );

if( mMovieWriter ){
mMovieWriter.addFrame( copyWindowSurface() );
    }
}</pre></div></li><li class="listitem">Build and run the application. Pressing any key will start or end a video recording. Each time a new recording begins, the user will be presented with a save file dialog to set where the movie will be saved.<div><img src="img/8703OS_4_2.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec115"/>How it works…</h2></div></div></div><p>The <code class="literal">ci::qtime::MovieWriter</code> object allows for easy movie writing using Apple's QuickTime. Recordings begin<a id="id270" class="indexterm"/> by initializing a <code class="literal">ci::qtime::MovieWriter</code> object and are saved when the object is destroyed. By calling the <code class="literal">addFrame</code> method, new frames are added.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec116"/>There's more...</h2></div></div></div><p>You can also define the format of the video by creating a <code class="literal">ci::qtime::MovieWriter::Format</code> object and passing it as an optional parameter in the movie writer's constructor. If no format is specified, the movie writer will use the default PNG codec and 30 frames per second.</p><p>For example, to create a movie writer with the H264 codec with 50 percent quality and 24 frames per second, you could<a id="id271" class="indexterm"/> write the following code:</p><div><pre class="programlisting">qtime::MovieWriter::Format format;
format.setCodec( qtime::MovieWriter::CODEC_H264 );
format.setQuality( 0.5f );
format.setDefaultDuration( 1.0f / 24.0f );
qtime::MovieWriter mMovieWriter = ci::Qtime::MovieWriter( "mymovie.mov", getWindowWidth(), getWindowHeight(), format );</pre></div><p>You can optionally open a <strong>Settings</strong> window and allow the user to define the video settings by calling the static method <code class="literal">qtime::MovieWriter::getUserCompressionSettings</code>. This method will populate a <code class="literal">qtime::MovieWriter::Format</code> object and return <code class="literal">true</code> if successful or <code class="literal">false</code> if the user canceled the change in the setting.</p><p>To use this method for defining the settings and creating a movie writer, you can write the following code:</p><div><pre class="programlisting">qtime::MovieWriter::Format format;
qtime::MovieWriter mMovieWriter;
boolformatDefined = qtime::MovieWriter::getUserCompressionSettings( &amp;format );
if( formatDefined ){
mMovieWriter = qtime::MovieWriter( "mymovie.mov", getWindowWidth(), getWindowHeight(), format );
}</pre></div><p>It is also possible to enable <strong>multipass</strong> encoding. For the current version of Cinder it is only available using the H264 codec. Multipass encoding will increase the movie's quality but at the cost of a greater performance decrease. For this reason it is disabled by default.</p><p>To write a movie with multipass encoding enabled we can write the following:</p><div><pre class="programlisting">qtime::MovieWriter::Format format;
format.setCodec( qtime::MovieWriter::CODEC_H264 );
format.enableMultiPass( true );
qtime::MovieWritermMovieWriter = ci::Qtime::MovieWriter( "mymovie.mov", getWindowWidth(), getWindowHeight(), format );</pre></div><p>There are plenty of settings and formats that can be set using the <code class="literal">ci::qtime::MovieWriter::Format</code> class and the best way to know the full list of options is to check the documentation for the class at <a class="ulink" href="http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html">http://libcinder.org/docs/v0.8.4/guide__qtime___movie_writer.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Saving window content as a vector graphics image</h1></div></div></div><p>In this recipe we'll learn how to draw 2D graphics on screen and save it to an image in a vector graphics format using the cairo renderer.</p><p>Vector graphics can be extremely <a id="id272" class="indexterm"/>useful when creating visuals for printing as they can be scaled without losing quality.</p><p>Cinder has an integration for the cairo graphics library; a powerful and full-featured 2D renderer, capable of outputting to a variety of formats including popular vector graphics formats.</p><p>To learn more about the cairo library, please go to its official web page: <a class="ulink" href="http://www.cairographics.org">http://www.cairographics.org</a></p><p>In this example we'll create an application that draws a new circle whenever the user presses the mouse. When any key is pressed, the application will open a save file dialog and save the content in a format defined by the file's extension.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec117"/>Getting ready</h2></div></div></div><p>To draw graphics created with the cairo renderer we must define our renderer to be  <code class="literal">Renderer2d</code>.</p><p>At the end of the source file of our application class there's a <em>macro</em> to initialize the application where the second parameter defines the renderer. If your application is called <code class="literal">MyApp</code>, you must change the macro to be the following:</p><div><pre class="programlisting">CINDER_APP_BASIC( MyApp, Renderer2d )</pre></div><p>The cairo renderer allows exporting of PDF, SVG, EPS, and PostScript formats. When specifying the file to save, make sure you write one of the supported extensions: <code class="literal">pdf</code>, <code class="literal">svg</code>, <code class="literal">eps</code>, or <code class="literal">ps</code>.</p><p>Include the following files at the top of your source file:</p><div><pre class="programlisting">#include "cinder/Rand.h"
#include "cinder/cairo/Cairo.h"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How to do it…</h2></div></div></div><p>We will use Cinder's cairo wrappers to create images in vector formats from our rendering.</p><div><ol class="orderedlist arabic"><li class="listitem">To create a new circle every time the user presses the mouse we must first create a <code class="literal">Circle</code> class. This class will contain position, radius, and color parameters. Its constructor will take <code class="literal">ci::Vec2f</code> to define its position and will generate a random radius and color.<p>Write the following code before the application's class declaration:</p><div><pre class="programlisting">class Circle{
public:
    Circle( const Vec2f&amp;pos ){
this-&gt;pos = pos;
radius = randFloat( 20.0f, 50.0f );
color = ColorA( randFloat( 1.0f ), randFloat( 1.0f ), randFloat( 1.0f ), 0.5f );
    }

    Vec2f pos;
float radius;
ColorA color;
};</pre></div></li><li class="listitem">We should now declare <code class="literal">std::vector</code> of circles where we'll store the created circles. Add the following code to your class declaration:<div><pre class="programlisting">std::vector&lt; Circle &gt;mCircles;</pre></div></li><li class="listitem">Let's create a<a id="id273" class="indexterm"/> method which will draw the circles that will take <code class="literal">cairo::Context</code> as their parameter:<div><pre class="programlisting">void renderScene( cairo::Context &amp;context );</pre></div></li><li class="listitem">In the method definition, iterate over <code class="literal">mCircles</code> and draw each one in the context:<div><pre class="programlisting">void MyApp::renderScene( cairo::Context &amp;context ){
for( std::vector&lt; Circle &gt;::iterator it = mCircles.begin(); it != mCircles.end(); ++it ){
context.circle( it-&gt;pos, it-&gt;radius );
context.setSource( it-&gt;color );
context.fill();
    }
}</pre></div></li><li class="listitem">At this point we only need to add a circle whenever the user presses the mouse. To do this, we must implement the <code class="literal">mouseDown</code> event handler by declaring it in the class declaration.<div><pre class="programlisting">void mouseDown( MouseEvent event );</pre></div></li><li class="listitem">In its implementation we add a <code class="literal">Circle</code> class to <code class="literal">mCircles</code> using the mouse position.<div><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  Circle circle( event.getPos() );
mCircles.push_back( circle );
}</pre></div></li><li class="listitem">We can now draw the circles on the window by creating <code class="literal">cairo::Context</code> bound to the window's surface. This will let us visualize what we're drawing. Here's the <code class="literal">draw</code> method implementation:<div><pre class="programlisting">void CairoSaveApp::draw()
{
cairo::Context context( cairo::createWindowSurface() );
renderScene( context );
}</pre></div></li><li class="listitem">To save the scene to an image file we must create a context bound to a surface that represents a file in a vector graphics format. Let's do this whenever the user releases a key by declaring the <code class="literal">keyUp</code> event handler.<div><pre class="programlisting">void keyUp( KeyEvent event );</pre></div></li><li class="listitem">In the <code class="literal">keyUp</code> <a id="id274" class="indexterm"/>implementation we create <code class="literal">ci::fs::path</code> and populate it by calling a save file dialog. We'll also create an empty <code class="literal">ci::cairo::SurfaceBase</code> which is the base for all the surfaces that the cairo renderer can draw to.<div><pre class="programlisting">fs::path filePath = getSaveFilePath();
cairo::SurfaceBase surface;</pre></div></li><li class="listitem">We'll now compare the extension of the path with the supported formats and initialize the surface accordingly. It can be initialized as <code class="literal">ci::cairo::SurfacePdf</code>, <code class="literal">ci::cairo::SurfaceSvg</code>, <code class="literal">ci::cairo::SurfaceEps</code>, or as <code class="literal">ci::cairo::SurfacePs</code>.<div><pre class="programlisting">if( filePath.extension() == ".pdf" ){
surface = cairo::SurfacePdf( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".svg" ){
surface = cairo::SurfaceSvg( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".eps" ){
surface = cairo::SurfaceEps( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".ps" ){
surface = cairo::SurfacePs( filePath, getWindowWidth(), getWindowHeight() );
    }</pre></div></li><li class="listitem">Now we can create <code class="literal">ci::cairo::Context</code> and render our scene to it by calling the <code class="literal">renderScene</code> method and passing the context as a parameter. The circles will be rendered to the context and a file will be created in the specified format. Here's the final <code class="literal">keyUp</code> method implementation:<div><pre class="programlisting">void CairoSaveApp::keyUp( KeyEvent event ){
fs::path filePath = getSaveFilePath();
cairo::SurfaceBase surface;
if( filePath.extension() == ".pdf" ){
surface = cairo::SurfacePdf( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".svg" ){
surface = cairo::SurfaceSvg( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".eps" ){
surface = cairo::SurfaceEps( filePath, getWindowWidth(), getWindowHeight() );
    } else if( filePath.extension() == ".ps" ){
surface = cairo::SurfacePs( filePath, getWindowWidth(), getWindowHeight() );
    }
cairo::Context context( surface );
renderScene( context );
}</pre></div><div><img src="img/8703OS_4_3.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec119"/>How it works…</h2></div></div></div><p>Cinder wraps and integrates<a id="id275" class="indexterm"/> the cairo 2D vector renderer. It allows use of Cinder's types to draw and interact with cairo.</p><p>The complete drawing is made by calling the drawing methods of a <code class="literal">ci::cairo::Context</code> object. The context in turn, must be created by passing a surface object extending <code class="literal">ci::cairo::SurfaceBase</code>. All drawings will be made in the surface and rasterized according to the type of the surface.</p><p>The following surfaces allow saving images in a vector graphics format:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Surface type</p>
</th><th style="text-align: left" valign="bottom">
<p>Format</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfacePdf</code></p>
</td><td style="text-align: left" valign="top">
<p>PDF</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceSvg</code></p>
</td><td style="text-align: left" valign="top">
<p>SVG</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceEps</code></p>
</td><td style="text-align: left" valign="top">
<p>EPS</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfacePs</code></p>
</td><td style="text-align: left" valign="top">
<p>PostsSript</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec120"/>There's more...</h2></div></div></div><p>It is also possible to draw using<a id="id276" class="indexterm"/> other renderers. Though the renderers aren't able to create vector images, they can be useful in other situations.</p><p>Here are the other available surfaces:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Surface Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Format</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceImage</code></p>
</td><td style="text-align: left" valign="top">
<p>Anti-aliased pixel-based rasterizer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceQuartz</code></p>
</td><td style="text-align: left" valign="top">
<p>Apple's Quartz</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceCgBitmapContext</code></p>
</td><td style="text-align: left" valign="top">
<p>Apple's CoreGraphics</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ci::cairo::SurfaceGdi</code></p>
</td><td style="text-align: left" valign="top">
<p>Windows GDI</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Saving high resolution images with the tile renderer</h1></div></div></div><p>In this recipe we'll learn how to export a high-resolution image of the content being drawn on screen using the <code class="literal">ci::gl::TileRender</code> class. This can be very useful when creating graphics for print.</p><p>We'll start by creating a simple <a id="id277" class="indexterm"/>scene and drawing it on screen. Next, we'll code our example so that whenever the user presses any key, a save file dialog will appear and a high-resolution image will be saved to the specified path.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec121"/>Getting ready</h2></div></div></div><p>The <code class="literal">TileRender</code> class can create high resolution images from anything being drawn on screen using OpenGl calls.</p><p>To save an image with <code class="literal">TileRender</code> we must first draw some content on screen. It can be anything but for this example let's create a nice simple pattern with circles to fill the screen.</p><p>In the implementation of your <code class="literal">draw</code> method write the following code:</p><div><pre class="programlisting">void MyApp::draw()
{
  gl::clear( Color( 0, 0, 0 ) ); 
gl::color( Color::white() );
for( float i=0; i&lt;getWindowWidth(); i+=10.0f ){
for( float j=0; j&lt;getWindowHeight(); j += 10.0f ){
float radius = j * 0.01f;
gl::drawSolidCircle( Vec2f( i, j ), radius );
        }
    }
}</pre></div><p>Remember that this could be anything that is drawn on screen using OpenGl.</p><div><img src="img/8703OS_4_4.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec122"/>How to do it...</h2></div></div></div><p>We will use the <code class="literal">ci::gl::TileRender</code> class to generate high-resolution images of our OpenGL rendering.<a id="id278" class="indexterm"/></p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary headers by adding the following at the top of the source file:<div><pre class="programlisting">#include "cinder/gl/TileRender.h"
#include "cinder/ImageIo.h"</pre></div></li><li class="listitem">Since we'll save a high-resolution image whenever the user presses any key, let's implement the <code class="literal">keyUp</code> event handler by declaring it in the class declaration.<div><pre class="programlisting">void keyUp( KeyEvent event );</pre></div></li><li class="listitem">In the <code class="literal">keyUp</code> implementation we start by creating a <code class="literal">ci::gl::TileRender</code> object and then set the width and height of the image we are going to create. We are going to set it to be four times the size of the application window. It can be of any size you want, just take in to account that if you don't respect the window's aspect ratio, the image will become stretched.<div><pre class="programlisting">gl::TileRender tileRender( getWindowWidth() * 4, getWindowHeight() * 4 );</pre></div></li><li class="listitem">We must define our scene's <code class="literal">Modelview</code> and <code class="literal">Projection</code> matrices to match our window. If we are using only 2D graphics we can call the method <code class="literal">setMatricesWindow</code>, as follows:<div><pre class="programlisting">tileRender.setMatricesWindow( getWindowWidth(), getWindowHeight() );</pre></div><p>To define the scene's <code class="literal">Modelview</code> and <code class="literal">Projection</code> matrices to match the window while drawing 3D content, it is necessary to call the method <code class="literal">setMatricesWindowPersp</code>:</p><div><pre class="programlisting">tileRender.setMatricesWindowPersp( getWindowWidth(), getWindowHeight() );</pre></div></li><li class="listitem">Next we'll draw our scene each time a new tile is created by using the method <code class="literal">nextTile</code>. When all the tiles have been created the method will return <code class="literal">false</code>. We can create all the tiles by redrawing our scene in a <code class="literal">while</code> loop while asking if there is a next tile, as follows:<div><pre class="programlisting">while( tileRender.nextTile() ){
draw();
    }</pre></div></li><li class="listitem">Now that the scene is fully rendered in <code class="literal">TileRender</code>, we must save it. Let's ask the user to indicate where to save by opening a save file dialog. It is mandatory to specify an extension for the image file as it will be used internally to define the image format.<div><pre class="programlisting">fs::path filePath = getSaveFilePath();</pre></div></li><li class="listitem">We check if <code class="literal">filePath</code> is not empty and write the tile render surface as an image using the <code class="literal">writeImage</code> method.<div><pre class="programlisting">if( filePath.empty() == false ){
writeImage( filePath, tileRender.getSurface() );
}</pre></div></li><li class="listitem">After saving the<a id="id279" class="indexterm"/> image it is necessary to redefine the window's <code class="literal">Modelview</code> and <code class="literal">Projection</code> matrices. If drawing in 2D you can set the matrices to their default values by using the method <code class="literal">setMatricesWindow</code> with the window's dimensions, as follows:<div><pre class="programlisting">gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec123"/>How it works…</h2></div></div></div><p>The <code class="literal">ci::gl::TileRender</code> class<a id="id280" class="indexterm"/> makes it possible to generate high-resolution versions of our rendering by scaling individual portions of our drawing to the entire size of the window and storing them as <code class="literal">ci::Surface</code>. After the entire scene has been stored in individual portions it is stitched together as tiles to form a single high-resolution <code class="literal">ci::Surface</code>, which can then be saved as an image.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Sharing graphics between applications</h1></div></div></div><p>In this recipe we will show you the way of sharing graphic in real time between applications under Mac OS X. To do that, we will use <strong>Syphon</strong> and its implementation for Cinder. Syphon is an open source tool that allows an application to share graphics as still frames or real-time updated frame sequence. You can read more about Syphon here: <a class="ulink" href="http://syphon.v002.info/">http://syphon.v002.info/</a></p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec124"/>Getting ready</h2></div></div></div><p>To test if the graphic shared by our application is available, we are going to use <strong>Syphon Recorder</strong>, which you can find here: <a class="ulink" href="http://syphon.v002.info/recorder/">http://syphon.v002.info/recorder/</a></p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec125"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Checkout Syphon CinderBlock from the <em>syphon-implementations</em> repository <a class="ulink" href="http://code.google.com/p/syphon-implementations/">http://code.google.com/p/syphon-implementations/</a>.</li><li class="listitem">Create a new group inside your project tree and name it <code class="literal">Blocks</code>.</li><li class="listitem">Drag-and-drop Syphon CinderBlock into your newly created <code class="literal">Blocks</code> group.<div><img src="img/8703OS_4_5.jpg" alt="How to do it…"/></div></li><li class="listitem">Make sure <strong>Syphon.framework</strong> is added to the <strong>Copy Files</strong> section of <strong>Build Phases</strong> in the <strong>target</strong> settings.</li><li class="listitem">Add necessary header files:<div><pre class="programlisting">#include "cinderSyphon.h"</pre></div></li><li class="listitem">Add property to your main application class:<div><pre class="programlisting">syphonServer mScreenSyphon;</pre></div></li><li class="listitem">At the end of <code class="literal">setup</code> method, add the following code:<div><pre class="programlisting">mScreenSyphon.setName("Cinder Screen");
gl::clear(Color::white());</pre></div></li><li class="listitem">Inside the <code class="literal">draw</code> method add the following code:<div><pre class="programlisting">gl::enableAlphaBlending();

gl::color( ColorA(1.f, 1.f, 1.f, 0.05f) );
gl::drawSolidRect( getWindowBounds() );

gl::color( ColorA::black() );
Vec2f pos = Vec2f( cos(getElapsedSeconds()), sin(getElapsedSeconds())) * 100.f;
gl::drawSolidCircle(getWindowCenter() + pos, 10.f);

mScreenSyphon.publishScreen();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec126"/>How it works…</h2></div></div></div><p>Application draws a simple rotating animation and shares the whole window area via Syphon library. Our application window looks like the following screenshot:</p><div><img src="img/8703OS_4_6.jpg" alt="How it works…"/></div><p>To test if the graphic can be received by other applications, we will use Syphon Recorder. Run Syphon Recorder and find our Cinder application in the drop-down menu under the name: <strong>Cinder Screen – MainApp</strong>. We set up the first part of this name at the step 6 of this recipe in the <em>How to do it...</em>  section while the second part is an executable file name. Now, the preview from our Cinder application should be available and it would looks like the following screenshot:</p><div><img src="img/8703OS_4_7.jpg" alt="How it works…"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec127"/>There's more...</h2></div></div></div><p>The Syphon library is very useful, simple to use, and is available for other applications and libraries.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Receiving graphics from other applications</h3></div></div></div><p>You can receive textures from other applications as well. To do this, you have to use the <code class="literal">syphonClient</code> class as shown in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a property to your application main class:<div><pre class="programlisting">syphonClient mClientSyphon;</pre></div></li><li class="listitem">Initialize <code class="literal">mClientSyphon</code> inside the CIT method:<div><pre class="programlisting">mClientSyphon.setApplicationName("MainApp Server");
mClientSyphon.setServerName("");
mClientSyphon.bind();</pre></div></li><li class="listitem">At the end of the <code class="literal">draw</code> method add the following line which draws graphics that the other application is sharing:<div><pre class="programlisting">mClientSyphon.draw(Vec2f::zero());</pre></div></li></ol></div></div></div></div></body></html>