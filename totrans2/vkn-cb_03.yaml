- en: Command Buffers and Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令缓冲区和同步
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating a command pool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令池
- en: Allocating command buffers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配命令缓冲区
- en: Beginning a command buffer recording operation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始命令缓冲区记录操作
- en: Ending a command buffer recording operation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束命令缓冲区记录操作
- en: Resetting a command buffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置命令缓冲区
- en: Resetting a command pool
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置命令池
- en: Creating a semaphore
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建信号量
- en: Creating a fence
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建栅栏
- en: Waiting for fences
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待栅栏
- en: Resetting fences
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置栅栏
- en: Submitting command buffers to a queue
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令缓冲区提交到队列
- en: Synchronizing two command buffers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步两个命令缓冲区
- en: Checking if processing of a submitted command buffer has finished
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查提交的命令缓冲区的处理是否完成
- en: Waiting until all commands submitted to a queue are finished
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待直到队列中提交的所有命令完成
- en: Waiting for all submitted commands to be finished
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待所有提交的命令完成
- en: Destroying a fence
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁栅栏
- en: Destroying a semaphore
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁信号量
- en: Freeing command buffers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放命令缓冲区
- en: Destroying a command pool
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁命令池
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Low level APIs like Vulkan give us much more control over the hardware than
    higher level APIs similar to OpenGL. This control is achieved not only through
    resources we can create, manage, and operate on, but especially through communication
    and interaction with the hardware. The control Vulkan gives us is fine grained,
    because we explicitly specify which commands are sent to hardware, how and when.
    For this purpose **command buffers** have been introduced; these are one of the
    most important objects Vulkan API exposes to developers. They allow us to record
    operations and submit them to hardware, where they are processed or executed.
    And what's more important, we can record them in multiple threads, unlike in high
    level APIs like OpenGL, where not only are commands recorded in a single thread,
    but they are recorded implicitly by the driver and sent to hardware without any
    control from the developers. Vulkan also allows us to reuse existing command buffers,
    saving additional processing time. This all gives us much more flexibility, but
    also many more responsibilities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenGL等高级API相比，Vulkan等低级API给我们提供了对硬件的更多控制。这种控制不仅通过我们可以创建、管理和操作的资源来实现，而且特别通过与硬件的通信和交互来实现。Vulkan给我们的控制是细粒度的，因为我们明确指定了哪些命令被发送到硬件，如何以及何时发送。为此，引入了**命令缓冲区**；这些是Vulkan
    API向开发者公开的最重要对象之一。它们允许我们记录操作并将它们提交给硬件，在那里它们被处理或执行。更重要的是，我们可以多线程记录它们，而在OpenGL等高级API中，不仅命令在单个线程中记录，而且它们由驱动程序隐式记录并发送到硬件，开发者没有任何控制。Vulkan还允许我们重用现有的命令缓冲区，节省额外的处理时间。所有这些都给我们提供了更多的灵活性，但也带来了更多的责任。
- en: Because of this, we need to control not only what operations we submit, but
    also when. Especially when some operations depend on the results of other operations,
    we need to take extra care and properly synchronize submitted commands. For this
    purpose, semaphores and fences have been introduced.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们需要控制的不只是我们提交的操作，还有它们的时间。特别是当某些操作依赖于其他操作的结果时，我们需要格外小心，并适当地同步提交的命令。为此，引入了信号量和栅栏。
- en: In this chapter we will learn how to allocate, record and submit command buffers,
    how to create synchronization primitives and use them to control the execution
    of submitted operations, how to synchronize command buffers internally, directly
    on the GPU, and  also how to synchronize applications with the work processed
    by the hardware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何分配、记录和提交命令缓冲区，如何创建同步原语并使用它们来控制提交操作的执行，如何内部同步命令缓冲区，直接在GPU上，以及如何同步应用程序与硬件处理的工作。
- en: Creating a command pool
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令池
- en: Command pools are objects from which command buffers acquire their memory. Memory
    itself is allocated implicitly and dynamically, but without it command buffers
    wouldn't have any storage space to hold the recorded commands. That's why, before
    we can allocate command buffers, we first need to create a memory pool for them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池是从中获取命令缓冲区内存的对象。内存本身是隐式和动态分配的，但没有它，命令缓冲区就没有存储空间来保存记录的命令。这就是为什么，在我们能够分配命令缓冲区之前，我们首先需要为它们创建一个内存池。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a variable of type `VkDevice` named `logical_device` and initialize it
    with a handle of a created logical device.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `logical_device` 的 `VkDevice` 类型的变量，并用已创建的逻辑设备的句柄初始化它。
- en: Take the index of one of the queue families requested for the logical device.
    Store this index in a variable of type `uint32_t` named `queue_family`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取逻辑设备请求的队列家族之一的索引。将此索引存储在名为 `queue_family` 的 `uint32_t` 类型的变量中。
- en: 'Create a variable of type `VkCommandPoolCreateInfo` named `command_pool_create_info`.
    Use the following values for the members of this variable:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `command_pool_create_info` 的 `VkCommandPoolCreateInfo` 类型的变量。为此变量的成员使用以下值：
- en: '`VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO` value for `sType`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: Bit field indicating selected parameters of type `VkCommandPoolCreateFlags`
    for `flags`
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示 `VkCommandPoolCreateFlags` 类型选择参数的位字段，用于 `flags`
- en: '`queue_family` variable for `queueFamilyIndex`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_family` 变量用于 `queueFamilyIndex`'
- en: Create a variable of type `VkCommandPool` named `command_pool` in which command
    pool's handle will be stored.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `command_pool` 的 `VkCommandPool` 类型的变量，其中将存储命令池的句柄。
- en: Call `vkCreateCommandPool( logical_device, &command_pool_create_info, nullptr,
    &command_pool )` using the `logical_device` variable, a pointer to the `command_pool_create_info`
    variable, a `nullptr` value and a pointer to the `command_pool` variable.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device` 变量、指向 `command_pool_create_info` 变量的指针、`nullptr` 值和指向 `command_pool`
    变量的指针调用 `vkCreateCommandPool(logical_device, &command_pool_create_info, nullptr,
    &command_pool)`。
- en: Make sure the call returned a `VK_SUCCESS` value.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用返回了 `VK_SUCCESS` 值。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Command pools are used mainly as a source of memory for the command buffers,
    but this is not the only reason for which they are created. They inform the driver
    about the intended usage of command buffers allocated from them, and whether we
    must reset or free them in bulk, or if we can do it separately per each command
    buffer. These parameters are specified through a `flags` member (represented as
    follows by a `parameters` variable) of the variables of type `VkCommandPoolCreateInfo`,
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池主要用于作为命令缓冲区的内存来源，但这并不是它们被创建的唯一原因。它们通知驱动程序从它们分配的命令缓冲区的预期用途，以及我们是否必须批量重置或释放它们，或者是否可以单独对每个命令缓冲区进行操作。这些参数通过
    `VkCommandPoolCreateInfo` 类型变量的 `flags` 成员（如下通过 `parameters` 变量表示）指定，如下所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we specify `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` bit, it means that the
    command buffers allocated from a given pool will live for a very short amount
    of time, they will be submitted very few times, and will be immediately reset
    or freed. When we use `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`, we can
    reset command buffers individually. Without this flag, we can do this only in
    groups - on all command buffers allocated from a given pool. Recording a command
    buffer implicitly resets it so, without this flag, we can record a command buffer
    only once. If we want to record it again, we need to reset the whole pool from
    which it was allocated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定 `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` 位时，这意味着从给定池分配的命令缓冲区将存活很短的时间，它们将被提交很少的次数，并将立即重置或释放。当我们使用
    `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` 时，我们可以单独重置命令缓冲区。如果没有此标志，我们只能在组中这样做
    - 在所有从给定池分配的命令缓冲区上。隐式记录命令缓冲区会重置它，因此如果没有此标志，我们只能记录命令缓冲区一次。如果我们想再次记录它，我们需要重置从它分配的整个池。
- en: Command pools also control the queues to which command buffers can be submitted.
    This is achieved through a queue family index, which we must provide during pool
    creation (only families requested during logical device creation can be provided).
    Command buffers that are allocated from a given pool can be submitted *only* to
    queues from the specified family.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池还控制可以提交到哪些队列。这是通过队列家族索引实现的，我们必须在创建池时提供该索引（只有逻辑设备创建期间请求的家族才能提供）。从给定池分配的命令缓冲区只能提交到指定的家族的队列。
- en: 'To create a pool, we need to prepare the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个池，我们需要准备以下代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Command pools cannot be accessed at the same time from multiple threads (command
    buffers from the same pool cannot be recorded on multiple threads at the same
    time). That's why each application thread on which a command buffer will be recorded
    should use separate command pools.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池不能从多个线程同时访问（同一池的命令缓冲区不能同时在多个线程上记录）。这就是为什么每个将记录命令缓冲区的应用程序线程都应该使用单独的命令池。
- en: Now, we are ready to allocate command buffers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好分配命令缓冲区。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Allocating command buffers*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配命令缓冲区*'
- en: '*Resetting a command buffer*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令缓冲区*'
- en: '*Resetting a command pool*'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令池*'
- en: '*Destroying a command pool*'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating command buffers
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command buffers are used to store (record) commands that are later submitted
    to queues, where they are executed and processed by the hardware to give us results.
    When we have created a command pool, we can use it to allocate command buffers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the handle of a command pool and use it to initialize a variable of type
    `VkCommandPool` named `command_pool`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkCommandBufferAllocateInfo` named `command_buffer_allocate_info`
    and use the following values for its members:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO` value for `sType`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command_pool` variable for `commandPool`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_COMMAND_BUFFER_LEVEL_PRIMARY` value or a `VK_COMMAND_BUFFER_LEVEL_SECONDARY`
    value for `level`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of command buffers we want to allocate for `commandBufferCount`
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a vector of type `std::vector<VkCommandBuffer>` named `command_buffers`.
    Resize the vector to be able to hold the number of command buffers we want to
    create.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkAllocateCommandBuffers( logical_device, &command_buffer_allocate_info,
    &command_buffers[0] )` for which provide a handle of the logical device, a pointer
    to the `command_buffer_allocate_info` variable and a pointer to the first element
    of the `command_buffers` vector.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon success, indicated by the `VK_SUCCESS` value returned by the call, handles
    of all created command buffers will be stored in the `command_buffers` vector.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command buffers are allocated from command pools. This allows us to control
    some of their properties in whole groups. First, we can submit command buffers
    only to queues from a family selected during command pool creation. Second, as
    command pools cannot be used concurrently, we should create separate command pools
    for each thread of our application in which we want to record commands, to minimize
    synchronization and improve performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'But, command buffers also have their individual properties. Some of them are
    specified when we start recording operations, but we need to choose a very important
    parameter during command buffer allocation - whether we want to allocate **primary**
    or **secondary** command buffers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Primary command buffers can be directly submitted to queues. They can also execute
    (call) secondary command buffers.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary command buffers can only be executed from primary command buffers,
    and we are not allowed to submit them.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These parameters are specified through variables of type `VkCommandBufferAllocateInfo`,
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, to allocate command buffers, we need the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have allocated command buffers, we can use them in our application.
    To do this, we need to record operations in one or multiple command buffers and
    then submit them to a queue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a command pool*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning a command buffer recording operation*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: '*Freeing command buffers*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放命令缓冲区*'
- en: Beginning a command buffer recording operation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始命令缓冲区记录操作
- en: When we want to perform operations using hardware, we need to record them and
    submit them to a queue. Commands are recorded into command buffers. So when we
    want to record them, we need to begin a recording operation of a selected command
    buffer, effectively setting it in the recording state.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用硬件执行操作时，我们需要记录它们并将它们提交到队列。命令被记录在命令缓冲区中。因此，当我们想要记录它们时，我们需要开始一个选定命令缓冲区的记录操作，实际上将其设置为记录状态。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer, in which commands should be recorded, and
    store it in a variable of type `VkCommandBuffer` named `command_buffer`. Make
    sure the command buffer is allocated from a pool with a `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flag set, or that it is in the initial state (it was reset).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应记录命令的命令缓冲区的句柄，并将其存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。确保命令缓冲区是从设置了`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`标志的池中分配的，或者它处于初始状态（它已被重置）。
- en: 'Create a variable of a bit field type `VkCommandBufferUsageFlags` named `usage`
    and set the following bits depending on which conditions are met:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`usage`的`VkCommandBufferUsageFlags`类型的位字段变量，并根据满足的条件设置以下位：
- en: If the command buffer will be submitted only once and then reset or re-recorded,
    set the `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` bit.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果命令缓冲区只提交一次然后重置或重新记录，设置`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`位。
- en: If it is the secondary command buffer and is considered to be entirely inside
    a render pass, set the `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` bit.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是辅助命令缓冲区并且被认为是完全在渲染通道内，设置`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`位。
- en: If the command buffer needs to be resubmitted to a queue while it is still being
    executed on a device (before the previous submission of this command buffer has
    ended), set the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` bit.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果命令缓冲区需要在设备上执行时重新提交到队列（在之前提交的此命令缓冲区结束之前），设置`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`位。
- en: 'Create a variable of type `VkCommandBufferInheritanceInfo *` named `secondary_command_buffer_info`.
    If it is a primary command buffer, initialize the variable with a `nullptr` value.
    If it is a secondary command buffer, initialize the variable with an address of
    a variable of type `VkCommandBufferInheritanceInfo` whose members are initialized
    with the following values:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`secondary_command_buffer_info`的`VkCommandBufferInheritanceInfo *`类型变量。如果它是主命令缓冲区，则使用`nullptr`值初始化变量。如果是辅助命令缓冲区，则使用`VkCommandBufferInheritanceInfo`类型变量的地址初始化变量，其成员使用以下值初始化：
- en: '`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO` value for `sType`.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO`的`sType`值。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值。'
- en: For `renderPass` use a handle of a compatible render pass, in which the command
    buffer will be executed; if the command buffer won't be executed inside a render
    pass, this value is ignored (refer to *Creating a render pass* recipe from [Chapter
    6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`renderPass`，使用兼容的渲染通道的句柄，其中命令缓冲区将被执行；如果命令缓冲区不会在渲染通道内执行，则此值被忽略（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)中的*创建渲染通道*配方，*渲染通道和帧缓冲区*）。
- en: An index of a subpass within a render pass, in which the command buffer will
    be executed, for `subpass` (if the command buffer won't be executed inside a render
    pass, this value is ignored).
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染通道中，命令缓冲区将要执行的子通道的索引，对于`subpass`（如果命令缓冲区不会在渲染通道内执行，则此值被忽略）。
- en: For `framebuffer,` use an optional handle of a framebuffer into which the command
    buffer will render, or a `VK_NULL_HANDLE` value if a framebuffer is not known
    or the command buffer won't be executed from within a render pass.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`framebuffer`，使用一个可选的帧缓冲区句柄，该句柄将用于命令缓冲区渲染，或者如果不知道帧缓冲区或者命令缓冲区不会在渲染通道内执行，则使用`VK_NULL_HANDLE`值。
- en: For `occlusionQueryEnable` member use a `VK_TRUE` value, if the command buffer
    can be executed while an occlusion query is active in the primary command buffer
    that executes this secondary command buffer. Otherwise, use a `VK_FALSE` value
    to indicate that the command buffer cannot be executed along with an enabled occlusion
    query.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `occlusionQueryEnable` 成员，如果命令缓冲区可以在执行此二级命令缓冲区的主命令缓冲区中活动遮挡查询时执行，则使用 `VK_TRUE`
    值。否则，使用 `VK_FALSE` 值来表示命令缓冲区不能与启用的遮挡查询一起执行。
- en: A set of flags that can be used by an active occlusion query for `queryFlags`.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组可以由活动遮挡查询用于 `queryFlags` 的标志。
- en: A set of statistics that can be counted by an active query for `pipelineStatistics`.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组可以通过活动查询 `pipelineStatistics` 计数的统计信息。
- en: 'Create a variable of type `VkCommandBufferBeginInfo` named `command_buffer_begin_info`.
    Use the following values to initialize its members:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `command_buffer_begin_info` 的 `VkCommandBufferBeginInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO` value for `sType`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO` 的 `sType` 值。'
- en: '`nullptr` value for `pNext`'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`。'
- en: '`usage` variable for `flags`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage` 变量用于 `flags`。'
- en: '`secondary_command_buffer_info` variable for `pInheritanceInfo`'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secondary_command_buffer_info` 变量用于 `pInheritanceInfo`。'
- en: Call `vkBeginCommandBuffer( command_buffer, &command_buffer_begin_info )` and
    provide the handle of the command buffer in the first parameter, and a pointer
    to the `command_buffer_begin_info` variable in the second parameter.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkBeginCommandBuffer(command_buffer, &command_buffer_begin_info)` 并在第一个参数中提供命令缓冲区的句柄，在第二个参数中提供一个指向
    `command_buffer_begin_info` 变量的指针。
- en: Make sure the call was successful by checking if the value returned by the call
    was equal to `VK_SUCCESS`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查调用返回的值是否等于 `VK_SUCCESS` 来确保调用成功。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Recording command buffers is the most important operation we can do in Vulkan.
    This is the only way to tell the hardware what it should do and how. When we start
    recording command buffers, their state is undefined. In general, command buffers
    don't inherit any state (as opposed to an OpenGL, in which the current state is
    maintained). So when we record operations, we also need to remember to set the
    state that is relevant to these operations. An example of such a state is a drawing
    command, which uses vertex attributes and indices. Before we record a drawing
    operation, we need to bind appropriate buffers with vertex data and a buffer with
    vertex indices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记录命令缓冲区是我们可以在 Vulkan 中执行的最重要操作。这是唯一告诉硬件它应该做什么以及如何做的途径。当我们开始记录命令缓冲区时，它们的状态是未定义的。一般来说，命令缓冲区不会继承任何状态（与
    OpenGL 相反，OpenGL 会保持当前状态）。因此，当我们记录操作时，我们还需要记得设置与这些操作相关的状态。这样一个状态的例子是一个绘图命令，它使用顶点属性和索引。在我们记录绘图操作之前，我们需要绑定带有顶点数据和顶点索引的适当缓冲区。
- en: Primary command buffers can call (execute) commands recorded in the secondary
    command buffers. Executed secondary command buffers don't inherit the state from
    the primary command buffers that executed them. What's more, the state of the
    primary command buffer is also undefined after the execution of the secondary
    command buffer is recorded (when we record a primary command buffer, and execute
    a secondary command buffer in it, and we want to continue recording the primary
    command buffer, we need to set its state once again). There is only one exception
    to the state inheritance rule - when the primary command buffer is inside a render
    pass and we execute a secondary command buffer from it, the primary command buffer's
    render pass and subpass states are preserved.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 主命令缓冲区可以调用（执行）在二级命令缓冲区中记录的命令。已执行的二级命令缓冲区不会从执行它们的 主命令缓冲区继承状态。更重要的是，二级命令缓冲区记录后，主命令缓冲区的状态也是未定义的（当我们记录主命令缓冲区，并在其中执行二级命令缓冲区，我们想要继续记录主命令缓冲区，我们需要再次设置其状态）。状态继承规则只有一个例外
    - 当主命令缓冲区在渲染通道内，并且我们从其中执行二级命令缓冲区时，主命令缓冲区的渲染通道和子通道状态被保留。
- en: 'Before we can begin a recording operation, we need to prepare a variable of
    type `VkCommandBufferBeginInfo`, through which we provide recording parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始记录操作之前，我们需要准备一个 `VkCommandBufferBeginInfo` 类型的变量，通过它我们提供记录参数：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For performance reasons, we should avoid recording command buffers with a `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    flag.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，我们应该避免记录带有 `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` 标志的命令缓冲区。
- en: 'Next, we can begin a recording operation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始记录操作：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From now on, we can record selected operations into the command buffer. But
    how do we know which commands can be recorded into command buffers? The names
    of all such functions begin with a `vkCmd` prefix and their first parameter is
    always a command buffer (a variable of type `VkCommandBuffer`). But, we need to
    remember that not all commands can be recorded into both primary and secondary
    command buffers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以将选定的操作记录到命令缓冲区中。但我们如何知道哪些命令可以记录到命令缓冲区中？所有这些函数的名称都以`vkCmd`前缀开头，并且它们的第一参数始终是命令缓冲区（`VkCommandBuffer`类型的变量）。但是，我们需要记住，并非所有命令都可以记录到主命令缓冲区和次级命令缓冲区中。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The following recipes in this chapter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Allocating command buffers*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配命令缓冲区*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: '*Resetting a command buffer*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令缓冲区*'
- en: '*Resetting a command pool*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令池*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: Ending a command buffer recording operation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束命令缓冲区记录操作
- en: When we don't want to record any more commands in a command buffer, we need
    to stop recording it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想在命令缓冲区中记录更多命令时，我们需要停止记录。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer that is in a recording state (for which
    a recording operation was started). Store the handle in a variable of type `VkCommandBuffer`
    named `command_buffer`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取处于记录状态（记录操作已开始）的命令缓冲区的句柄。将句柄存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。
- en: Call `vkEndCommandBuffer( command_buffer )` and provide the `command_buffer`
    variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkEndCommandBuffer(command_buffer)`并提供`command_buffer`变量。
- en: Make sure the recording operation was successful by checking whether the call
    returned a `VK_SUCCESS` value.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查调用是否返回`VK_SUCCESS`值来确保记录操作成功。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Commands are recorded into the command buffer between the `vkBeginCommandBuffer()`
    and `vkEndCommandBuffer()` function calls. We can't submit a command buffer until
    we stop recording it. In other words, when we finish recording a command buffer,
    it is said to be in the executable state and can be submitted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在`vkBeginCommandBuffer()`和`vkEndCommandBuffer()`函数调用之间记录到命令缓冲区中。在停止记录之前，我们不能提交命令缓冲区。换句话说，当我们完成命令缓冲区的记录后，它处于可执行状态，可以被提交。
- en: For the recording operation to be as fast as possible and to have as small impact
    on the performance as possible, recorded commands don't report any errors. If
    any problems occur, they are reported by the `vkEndCommandBuffer()` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使记录操作尽可能快，并尽可能减少对性能的影响，记录的命令不报告任何错误。如果发生任何问题，它们将由`vkEndCommandBuffer()`函数报告。
- en: 'So when we stop recording a command buffer, we should make sure that the recording
    was successful. We can do that like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们停止记录命令缓冲区时，我们应该确保记录操作成功。我们可以这样做：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If there were errors during the recording operation (the value returned by the
    `vkEndCommandBuffer()` function is not equal to `VK_SUCCESS`), we can't submit
    such a command buffer and we need to reset it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在记录操作过程中出现错误（`vkEndCommandBuffer()`函数返回的值不等于`VK_SUCCESS`），我们无法提交这样的命令缓冲区，我们需要重置它。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The following recipes in this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: '*Resetting a command buffer*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令缓冲区*'
- en: Resetting a command buffer
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置命令缓冲区
- en: When a command buffer was previously recorded, or if there were errors during
    the recording operation, the command buffer must be reset before it can be rerecorded
    once again. We can do this implicitly, by beginning another record operation.
    But, we can also do it explicitly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令缓冲区之前已被记录，或者记录操作过程中出现错误时，在可以再次重录之前，必须重置命令缓冲区。我们可以通过开始另一个记录操作隐式地做到这一点。但，我们也可以显式地做到这一点。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer allocated from a pool that was created with
    a `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag. Store the handle in
    a variable of type `VkCommandBuffer` named `command_buffer`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从使用带有`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`标志创建的池中分配命令缓冲区的句柄。将句柄存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。
- en: Create a variable of type `VkCommandBufferResetFlags` named `release_resources`.
    In the variable, store a value of `VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT`
    if you want to release memory allocated by the buffer and give it back to the
    pool. Otherwise, store a `0` value in the variable.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `release_resources` 的 `VkCommandBufferResetFlags` 类型的变量。如果想要释放缓冲区分配的内存并将其返回到池中，则在变量中存储
    `VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT` 的值。否则，在变量中存储 `0` 值。
- en: Call `vkResetCommandBuffer( command_buffer, release_resources )` and provide
    the handle of the command buffer in the first parameter, and the `release_resources`
    variable in the second parameter.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkResetCommandBuffer( command_buffer, release_resources )` 并在第一个参数中提供命令缓冲区的句柄，在第二个参数中提供
    `release_resources` 变量。
- en: Make sure the call was successful by checking if the returned value is equal
    to `VK_SUCCESS`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查返回值是否等于 `VK_SUCCESS` 来确保调用成功。
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Command buffers can be reset in bulk, by resetting a whole command pool, or
    individually. Separate resets can be performed only if a pool, from which the
    command buffers were allocated, was created with a `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    flag.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区可以通过重置整个命令池或单独重置来批量重置。只有当创建命令池时带有 `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    标志时，才能执行单独的重置。
- en: Resetting a command buffer is performed implicitly, when we start recording
    it, or explicitly by calling a `vkResetCommandBuffer()` function. Explicit reset
    gives us control over the memory allocated by the command buffer from its pool.
    During explicit reset, we can decide whether we want to return the memory to a
    pool, or if the command buffer should keep it and reuse it during the next command
    recording.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重置命令缓冲区是在开始记录时隐式执行的，或者通过调用 `vkResetCommandBuffer()` 函数显式执行。显式重置使我们能够控制命令缓冲区从其池中分配的内存。在显式重置期间，我们可以决定是否要将内存返回到池中，或者命令缓冲区是否应该保留它并在下一次命令记录期间重用它。
- en: 'Individual command buffers are reset explicitly like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 单个命令缓冲区的重置是显式执行的，如下所示：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a command pool*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建命令池*'
- en: '*Beginning a command buffer recording operation*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Resetting a command pool*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令池*'
- en: Resetting a command pool
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置命令池
- en: When we don't want to reset command buffers individually, or if we created a
    pool without a `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag, we can
    reset all command buffers allocated from a given pool at once.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不希望单独重置命令缓冲区，或者如果我们没有带有 `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    标志创建池时，我们可以一次性重置从给定池分配的所有命令缓冲区。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Take the handle of a created command pool. Use it to initialize a variable of
    type `VkCommandPool` named `command_pool`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取已创建的命令池的句柄。使用它来初始化一个名为 `command_pool` 的 `VkCommandPool` 类型的变量。
- en: Create a variable of type `VkCommandPoolResetFlags` named `release_resources`
    and initialize it with a value of `VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT`,
    if memory reserved by all command buffers allocated from the command pool should
    be released and returned to the pool, or with a `0` value otherwise.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `release_resources` 的 `VkCommandPoolResetFlags` 类型的变量，并将其初始化为 `VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT`，如果应该释放由命令池分配的所有命令缓冲区保留的内存并将其返回到池中，否则初始化为
    `0` 值。
- en: Call `vkResetCommandPool( logical_device, command_pool, release_resources )`
    and provide the `logical_device`, `command_pool` and `release_resources` variables.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkResetCommandPool( logical_device, command_pool, release_resources )` 并提供
    `logical_device`、`command_pool` 和 `release_resources` 变量。
- en: Make sure the call returned a `VK_SUCCESS` value, which indicates it was successful.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用返回了 `VK_SUCCESS` 值，这表示操作成功。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Resetting a command pool causes all command buffers allocated from it to return
    to their initial state, as if they were never recorded. This is similar to resetting
    all command buffers separately, but is faster and we don't have to create a command
    pool with a `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag specified.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重置命令池会导致从它分配的所有命令缓冲区返回到其初始状态，就像它们从未被记录过一样。这与分别重置所有命令缓冲区类似，但更快，我们不需要创建一个带有 `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
    标志的命令池。
- en: When command buffers are recorded, they take their memory from the pool. This
    is done automatically, without our control. When we reset the command pool, we
    can choose if command buffers should keep their memory for later use, or if it
    should be returned to the pool.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录命令缓冲区时，它们从池中获取它们的内存。这是自动完成的，不受我们的控制。当我们重置命令池时，我们可以选择命令缓冲区是否应该保留它们的内存以供以后使用，或者是否应该将其返回到池中。
- en: 'To reset all command buffers allocated from the specified pool at once, we
    need the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性重置从指定池分配的所有命令缓冲区，我们需要以下代码：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a command pool*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建命令池*'
- en: '*Allocating command buffers*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配命令缓冲区*'
- en: '*Resetting a command buffer*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置命令缓冲区*'
- en: Creating a semaphore
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信号量
- en: Before we can submit commands and utilize the device's processing power, we
    need to know how to synchronize operations. Semaphores are one of the primitives
    used for synchronization. They allow us to coordinate operations submitted to
    queues, not only within one queue, but also between different queues in one logical
    device.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够提交命令并利用设备的处理能力之前，我们需要知道如何同步操作。信号量是用于同步的原始数据之一。它们允许我们协调提交到队列的操作，不仅限于一个队列内部，还可以在不同的逻辑设备队列之间。
- en: Semaphores are used when we submit commands to queues. So before we can use
    them during the submission of command buffers, we need to create them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向队列提交命令时使用信号量。因此，在我们能够在提交命令缓冲区时使用它们之前，我们需要创建它们。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a created logical device. Store the handle in a variable
    of type `VkDevice` named `logical_device`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个已创建的逻辑设备的句柄。将句柄存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: 'Create a variable of type `VkSemaphoreCreateInfo` named `semaphore_create_info`.
    Use the following values to initialize its members:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `semaphore_create_info` 的 `VkSemaphoreCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO` value for `sType`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO` 的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: '`0` value for `flags`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: Create a variable of type `VkSemaphore` named `semaphore`. In this variable,
    a handle of a created semaphore will be stored.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `semaphore` 的 `VkSemaphore` 类型的变量。在这个变量中，将存储创建的信号量的句柄。
- en: 'Make the following function call: `vkCreateSemaphore( logical_device, &semaphore_create_info,
    nullptr, &semaphore )`. For this call use the `logical_device` variable, a pointer
    to the `semaphore_create_info` variable, a `nullptr` value and a pointer to the
    `semaphore` variable.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用以下函数：`vkCreateSemaphore( logical_device, &semaphore_create_info, nullptr,
    &semaphore )`。为此调用使用 `logical_device` 变量，`semaphore_create_info` 变量的指针，一个 `nullptr`
    值和一个 `semaphore` 变量的指针。
- en: Make sure the semaphore creation was successful by checking if the returned
    value was equal to `VK_SUCCESS`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查返回值是否等于 `VK_SUCCESS` 来确保信号量创建成功。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Semaphores, as synchronization primitives, have only two different states:
    signaled or un-signaled. Semaphores are used during command buffer submissions.
    When we provide them to a list of semaphores to be signaled, they change their
    state to signaled as soon as all work submitted within a given batch is finished.
    In a similar way, when we submit commands to queues, we can specify that submitted
    commands should wait until all semaphores from a specified list become signaled.
    This way, we can coordinate work submitted to queues and postpone processing of
    commands that depend on the results of other commands.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为同步原语，信号量只有两种不同的状态：已信号量或未信号量。信号量在命令缓冲区提交期间使用。当我们将它们提供给要信号量的信号量列表时，一旦给定批次中提交的所有工作完成，它们的状态就会变为已信号量。以类似的方式，当我们向队列提交命令时，我们可以指定提交的命令应等待直到指定列表中的所有信号量都变为已信号量。这样，我们可以协调提交到队列的工作，并推迟依赖于其他命令结果的命令的处理。
- en: When semaphores are signaled and all commands waiting for them are resumed,
    semaphores are automatically reset (they change their state to un-signaled) and
    can be reused.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号量被信号量并所有等待它们的命令恢复时，信号量会自动重置（它们的状态变为未信号量）并可以再次使用。
- en: 'Semaphores are also used when we acquire images from a swapchain. In this case,
    such semaphores must be used when we submit commands that reference acquired images.
    These commands should wait until swapchain images are no longer used by the presentation
    engine, which is indicated by the semaphore signal operation. This is shown in
    the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_001.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Semaphores are created with a `vkCreateSemaphore()` function call. Parameters
    needed during the creation process are provided through a variable of type `VkSemaphoreCreateInfo`,
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To create a semaphore, we need to prepare a code similar to this one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Semaphores can be used only to synchronize work submitted to queues, as they
    coordinate graphics hardware internally. The application doesn't have access to
    the state of the semaphores. If the application should be synchronized with the
    submitted commands, fences need to be used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*Acquiring a swapchain image*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Presenting an image*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to a queue*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Synchronizing two command buffers*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destroying a semaphore*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a fence
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fences, opposite to semaphores, are used to synchronize an application with
    commands submitted to the graphics hardware. They inform the application when
    the processing of a submitted work has been finished. But before we can use fences,
    we need to create them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the created logical device and use its handle to initialize a variable
    of type `VkDevice` named `logical_device`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a variable of type `VkFenceCreateInfo` named `fence_create_info`. Use
    the following values to initialize its members:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VK_STRUCTURE_TYPE_FENCE_CREATE_INFO` value for `sType`'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullptr` value for `pNext`'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `flags` use a `0` value if a created fence should be un-signaled, or a `VK_FENCE_CREATE_SIGNALED_BIT`
    value if a created fence should be signaled
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a variable of type `VkFence` named `fence` that will hold the handle
    of a created fence.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkCreateFence( logical_device, &fence_create_info, nullptr, &fence )`
    and provide the `logical_device` variable, a pointer to the `fence_create_info`
    variable, a `nullptr` value and a pointer to the `fence` variable.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the call was successful by comparing the returned value with a `VK_SUCCESS`
    enum.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fences, similarly to other synchronization primitives, have only two states:
    signaled and un-signaled. They can be created in either of these two states, but
    they are reset by the application--this changes their state from signaled to un-signaled.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: To signal a fence, we need to provide it during command buffer submission. Such
    a fence, similarly to semaphores, will become signaled as soon as all work submitted
    along with the fence is finished. But, fences can't be used to synchronize command
    buffers. Their state can be queried by the application and the application can
    wait on fences until they become signaled.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标记一个栅栏，我们需在命令缓冲区提交时提供它。这样的栅栏，类似于信号量，一旦与栅栏一起提交的所有工作完成，就会立即被标记。但是，栅栏不能用来同步命令缓冲区。应用程序可以查询栅栏的状态，并且可以在栅栏被标记之前等待。
- en: Semaphores are used to synchronize submitted command buffers with each other.
    Fences are used to synchronize an application with submitted commands.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量用于同步提交的命令缓冲区之间。栅栏用于同步应用程序与提交的命令。
- en: 'To create a fence, we need to prepare a variable of type `VkFenceCreateInfo`,
    in which we must choose whether we want the created fence to be already in a signaled
    state or if it should be un-signaled:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个栅栏，我们需要准备一个名为`VkFenceCreateInfo`的变量，在其中我们必须选择是否希望创建的栅栏已经处于标记状态，或者它应该是未标记的：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, this structure is provided to the `vkCreateFence()` function, which creates
    a fence using specified parameters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，此结构被提供给`vkCreateFence()`函数，该函数使用指定的参数创建一个栅栏：
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a semaphore*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Waiting on fences*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Resetting fences*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置栅栏*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: '*Checking if processing of a submitted command buffer has finished*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查提交的命令缓冲区的处理是否完成*'
- en: '*Destroying a fence*'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁一个栅栏*'
- en: Waiting for fences
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待栅栏
- en: When we want to know when the processing of submitted commands is finished,
    we need to use a fence and provide it during command buffer submission. Then,
    the application can check the fence's state and wait until it becomes signaled.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想知道提交的命令处理何时完成时，我们需要使用一个栅栏，并在命令缓冲区提交时提供它。然后，应用程序可以检查栅栏的状态，并等待它被标记。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the created logical device and use its handle to initialize a variable
    of type `VkDevice` named `logical_device`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取已创建的逻辑设备，并使用其句柄初始化一个名为`logical_device`的`VkDevice`类型的变量。
- en: Create a list of fences on which the application should wait. Store the handles
    of all fences in a variable of type `std::vector<VkFence>` named `fences`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个应用程序应该等待的栅栏列表。将所有栅栏的句柄存储在一个名为`std::vector<VkFence>`的变量`fences`中。
- en: Create a variable of type `VkBool32` named `wait_for_all`. Initialize it with
    a value of `VK_TRUE`, if the application should wait until all specified fences
    become signaled. If the application should wait until any of the fences becomes
    signaled (at least one of them), then initialize the variable with a `VK_FALSE`
    value.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`wait_for_all`的`VkBool32`类型的变量。如果应用程序应该等待直到所有指定的栅栏都被标记，则用`VK_TRUE`的值初始化它。如果应用程序应该等待直到任何栅栏被标记（至少有一个），则用`VK_FALSE`的值初始化该变量。
- en: Create a variable of type `uint64_t` named `timeout`. Initialize the variable
    with a value indicating how much time (in nanoseconds) the application should
    spend waiting.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`timeout`的`uint64_t`类型的变量。用表示应用程序应该等待多长时间（以纳秒为单位）的值初始化该变量。
- en: Call `vkWaitForFences( logical_device, static_cast<uint32_t>(fences.size()),
    &fences[0], wait_for_all, timeout )`. Provide a handle of the logical device,
    a number of elements in the `fences` vector, a pointer to the first element of
    the `fences` variable, the `wait_for_all` and the `timeout` variables.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkWaitForFences(logical_device, static_cast<uint32_t>(fences.size()), &fences[0],
    wait_for_all, timeout)`。提供逻辑设备的句柄、`fences`向量的元素数量、`fences`变量的第一个元素的指针、`wait_for_all`和`timeout`变量。
- en: Check the value returned by the call. If it was equal to `VK_SUCCESS` it means
    that the condition was satisfied--one or all fences (depending on the value of
    the `wait_for_all` variable) became signaled within the specified time. If the
    condition is not met, `VK_TIMEOUT` will be returned.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查调用返回的值。如果它等于`VK_SUCCESS`，则表示条件得到满足——一个或所有栅栏（取决于`wait_for_all`变量的值）在指定时间内被标记。如果条件未满足，则返回`VK_TIMEOUT`。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `vkWaitForFences()` function blocks the application for a specified period
    of time or until the provided fences becomes signaled. This way, we can synchronize
    our application with work submitted to the device's queues. This is also the way
    for us to know when the processing of submitted commands is finished.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: During the call we can provide multiple fences, not just one. We can also wait
    until all fences become signaled, or just any one of them. If the condition is
    not met within the specified period of time, the function returns a `VK_TIMEOUT`
    value. Otherwise, it returns `VK_SUCCESS`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We can also check a fence's state by simply providing its handle to the function
    and specifying a timeout value of `0`. This way, the `vkWaitForFences()` function
    won't block and will immediately return the value indicating the current state
    of the provided fence - a `VK_TIMEOUT` value if the fence was un-signaled (though
    no real wait was performed) or a `VK_SUCCESS` value if the fence was already signaled.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that causes the application to wait may look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resetting fences*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to a queue*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checking if processing of a submitted command buffer has finished*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting fences
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semaphores are automatically reset. But when a fence becomes signaled, it is
    the application's responsibility to reset the fence back to the un-signaled state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store the handle of a created logical device in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a vector variable named `fences`. It should contain elements of type
    `VkFence`. In the variable, store the handles of all fences that should be reset.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `vkResetFences( logical_device, static_cast<uint32_t>(fences.size()), &fences[0]
    )` and provide the `logical_device` variable, the number of elements in the `fences`
    vector and a pointer to the first element of the `fences` vector.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the function succeeded by checking if the value returned by the call
    was equal to `VK_SUCCESS`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to know when submitted commands are finished, we use a fence.
    But we can''t provide a fence that was already signaled. We must first reset it,
    which means that we change its state from signaled to un-signaled. Fences are
    reset explicitly by the application, not automatically like semaphores. Resetting
    fences is done like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes in this chapter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a fence*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Waiting on fences*'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Submitting command buffers to a queue*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checking if processing of a submitted command buffer has finished*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting command buffers to a queue
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have recorded command buffers and we want to harness the graphics hardware's
    power to process the prepared operations. What to do next? We need to submit prepared
    work to a selected queue.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we will use variables of a custom `WaitSemaphoreInfo` type.
    It is defined as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Through it, we provide a handle of a semaphore on which hardware should wait
    before processing the given `command buffer`, and we also specify in which pipeline
    stages the wait should occur.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它，我们提供一个句柄，硬件在处理给定的 `command buffer` 之前应等待该句柄，并且我们还指定了等待应发生的管道阶段。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a queue to which work should be submitted. Use the handle
    to initialize a variable of type `VkQueue` named `queue`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应提交工作的工作队列的句柄。使用该句柄初始化一个名为 `queue` 的 `VkQueue` 类型的变量。
- en: Create a variable of type `std::vector<VkSemaphore>` named `wait_semaphore_handles`.
    If submitted commands should wait for other commands to end, in the variable store
    the handles of all semaphores for which a given queue should wait before processing
    the submitted command buffers.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `wait_semaphore_handles` 的 `std::vector<VkSemaphore>` 类型的变量。如果提交的命令应该等待其他命令结束，则在变量中存储所有给定队列在处理提交的命令缓冲区之前应等待的句柄。
- en: Create a variable of type `std::vector<VkPipelineStageFlags>` named `wait_semaphore_stages`.
    If submitted commands should wait for other commands to end, initialize the vector
    with pipeline stages at which the queue should wait for a corresponding semaphore from
    the `wait_semaphore_handles` variable to become signaled.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `wait_semaphore_stages` 的 `std::vector<VkPipelineStageFlags>` 类型的变量。如果提交的命令应该等待其他命令结束，则使用
    `wait_semaphore_handles` 变量中的管道阶段初始化该向量，以便队列在等待相应的信号时等待。
- en: Prepare a variable of type `std::vector<VkCommandBuffer>` named `command_buffers`.
    Store the handles of all recorded command buffers that should be submitted to
    the selected queue. Make sure that none of these command buffers is currently
    processed by the device, or were recorded with a `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    flag.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `command_buffers` 的 `std::vector<VkCommandBuffer>` 类型的变量。存储所有应提交到所选队列的已记录命令缓冲区的句柄。确保这些命令缓冲区中没有任何一个正在由设备处理，或者使用
    `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` 标志记录。
- en: Create a variable of type `std::vector<VkSemaphore>` named `signal_semaphores`.
    In this vector, store the handles of all semaphores that should be signaled when
    the processing of all command buffers, submitted in the `command_buffers` variable,
    is finished.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `signal_semaphores` 的 `std::vector<VkSemaphore>` 类型的变量。在此向量中，存储所有在 `command_buffers`
    变量中提交的所有命令缓冲区的处理完成后应发出信号的句柄。
- en: Create a variable of type `VkFence` named `fence`. If a fence should be signaled
    when the processing of all command buffers submitted in the `command_buffers`
    variable is finished, store the handle of this fence in the `fence` variable.
    Otherwise, initialize this variable with a `VK_NULL_HANDLE` value.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fence` 的 `VkFence` 类型的变量。如果应在 `command_buffers` 变量中提交的所有命令缓冲区的处理完成后发出信号，则在该变量中存储此围栏的句柄。否则，使用
    `VK_NULL_HANDLE` 值初始化此变量。
- en: 'Create a variable of type `VkSubmitInfo` named `submit_info`. Use the following
    values to initialize its members:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `submit_info` 的 `VkSubmitInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_SUBMIT_INFO` value for `sType`'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_SUBMIT_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: Number of elements in the `wait_semaphore_handles` vector for `waitSemaphoreCount`
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_semaphore_handles` 向量中 `waitSemaphoreCount` 的元素数量'
- en: Pointer to the first element of the `wait_semaphore_handles` vector or a `nullptr`
    value, if the vector is empty, for `pWaitSemaphores`
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `wait_semaphore_handles` 向量第一个元素的指针或一个 `nullptr` 值，如果该向量为空，用于 `pWaitSemaphores`
- en: Pointer to the first element of the `wait_semaphore_stages` vector or a `nullptr`
    value, if the vector is empty, for `pWaitDstStageMask`
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `wait_semaphore_stages` 向量第一个元素的指针或一个 `nullptr` 值，如果该向量为空，用于 `pWaitDstStageMask`
- en: Number of submitted command buffers (number of elements in the `command_buffers`
    vector) for `commandBufferCount`
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交的命令缓冲区数量（`command_buffers` 向量中的元素数量）用于 `commandBufferCount`
- en: Pointer to the first element of the `command_buffers` vector or a `nullptr`
    value, if the vector is empty, for `pCommandBuffers`
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `command_buffers` 向量第一个元素的指针或一个 `nullptr` 值，如果该向量为空，用于 `pCommandBuffers`
- en: Number of elements in the `signal_semaphores` vector for `signalSemaphoreCount`
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal_semaphores` 向量中 `signalSemaphoreCount` 的元素数量'
- en: Pointer to the first element of the `signal_semaphores` vector or a `nullptr`
    value, if the vector is empty, for `pSignalSemaphores`
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `signal_semaphores` 向量第一个元素的指针或一个 `nullptr` 值，如果该向量为空，用于 `pSignalSemaphores`
- en: Call `vkQueueSubmit( queue, 1, &submit_info, fence )` and provide the handle
    of the queue to which work should be submitted, a `1` value, a pointer to the
    `submit_info` variable, and the `fence` variable.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkQueueSubmit(queue, 1, &submit_info, fence)` 并提供应该提交工作的队列句柄，一个 `1` 值，`submit_info`
    变量的指针，以及 `fence` 变量。
- en: Make sure the call was successful by checking whether it returned a `VK_SUCCESS`
    value.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查它是否返回了 `VK_SUCCESS` 值来确保调用成功。
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we submit command buffers to the device's queue, they will be executed
    as soon as the processing of earlier commands submitted to the same queue is finished.
    From the application's perspective, we don't know when the commands are going
    to be executed. It may start immediately or after a while.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将命令缓冲区提交到设备的队列时，它们将在之前提交到同一队列的命令处理完成后立即执行。从应用程序的角度来看，我们不知道命令将在何时执行。它可能立即开始，也可能在一段时间后。
- en: When we want to postpone the processing of submitted commands, we need to synchronize
    them by providing a list of semaphores on which a given queue should wait before
    the submitted command buffers are executed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要推迟提交命令的处理时，我们需要通过提供一个信号量列表来同步它们，在提交的命令缓冲区执行之前，给定的队列应该在列表上的信号量上等待。
- en: When we submit command buffers and provide a list of semaphores, each semaphore
    is associated with a pipeline stage. Commands are executed until they reach a
    specified pipeline stage, where they are paused and wait for the semaphore to
    become signaled.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交命令缓冲区并提供一个信号量列表时，每个信号量都与一个管线阶段相关联。命令将执行，直到它们达到指定的管线阶段，在那里它们将被暂停并等待信号量被触发。
- en: 'During the submission, semaphores and pipeline stages are in separate arrays.
    So, we need to split the vector with elements of a custom type `WaitSemaphoreInfo`
    into two separate vectors:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交过程中，信号量和管线阶段位于不同的数组中。因此，我们需要将包含自定义类型 `WaitSemaphoreInfo` 元素的向量拆分为两个单独的向量：
- en: '[PRE16]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we are ready for the usual submission. For the submission, semaphores
    on which command buffers should wait, pipeline stages at which the wait should
    be performed, command buffers and another list of semaphores that should be signaled,
    are all specified through a variable of type `VkSubmitInfo`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行常规提交。对于提交，指定命令缓冲区应该等待的信号量、执行等待的管线阶段、命令缓冲区以及应该被触发的另一个信号量列表，都是通过类型为
    `VkSubmitInfo` 的变量来指定的：
- en: '[PRE17]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This batch of data is then submitted like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这批数据随后以这种方式提交：
- en: '[PRE18]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we submit command buffers, the device will execute the recorded commands
    and produce the desired results, as an example it will draw a 3D scene on screen.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交命令缓冲区时，设备将执行记录的命令并产生预期的结果，例如，它将在屏幕上绘制一个3D场景。
- en: Here we submit just one batch of command buffers, but it is possible to submit
    multiple batches.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只提交了一批命令缓冲区，但可能提交多个批次。
- en: For performance reasons, we should submit as many batches as possible in as
    few function calls as possible.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，我们应该尽可能少地使用函数调用提交尽可能多的批次。
- en: We shouldn't submit command buffers if they were already submitted and their
    execution hasn't ended yet. We can do this only when command buffers were recorded
    with a `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flag, but we should avoid
    using this flag for performance reasons.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令缓冲区已经被提交且其执行尚未结束，我们不应该提交命令缓冲区。我们只能在命令缓冲区使用 `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`
    标志记录时这样做，但出于性能原因，我们应该避免使用此标志。
- en: See also
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中接下来的菜谱：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: '*Ending a command buffer recording operation*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束命令缓冲区记录操作*'
- en: '*Creating a semaphore*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Creating a fence*'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个栅栏*'
- en: Synchronizing two command buffers
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步两个命令缓冲区
- en: We know how to prepare work and submit it to queues. We also know how to create
    semaphores. In this sample recipe, we will see how to use semaphores to synchronize
    two command buffers. More specifically, we will learn how to postpone the processing
    of a command buffer until the processing of another command buffer is finished.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何准备工作和将其提交到队列中。我们也知道如何创建信号量。在这个示例菜谱中，我们将看到如何使用信号量来同步两个命令缓冲区。更具体地说，我们将学习如何推迟处理一个命令缓冲区，直到另一个命令缓冲区的处理完成。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe we will use the `WaitSemaphoreInfo` structure introduced in
    the *Submitting command buffers to a queue* recipe. For reference, here is its
    definition:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在 *将命令缓冲区提交到队列* 菜谱中引入的 `WaitSemaphoreInfo` 结构。为了参考，以下是它的定义：
- en: '[PRE19]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a queue to which the first batch of command buffers will
    be submitted. Store this handle in a variable of type `VkQueue` named `first_queue`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取将第一批次命令缓冲区提交到的队列的句柄。将此句柄存储在名为`first_queue`的`VkQueue`类型的变量中。
- en: Create semaphores that should be signaled when the processing of the first batch
    of command buffers is finished (refer to *Creating a semaphore* recipe). Store
    the semaphores in a variable of type `std::vector<WaitSemaphoreInfo>` named `synchronizing_semaphores`.
    Prepare a list of stages at which command buffers from the second batch should
    wait for each semaphore. Include these stages in the `synchronizing_semaphores`
    vector.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建在第一批次命令缓冲区的处理完成后应该被触发的信号量（参考*创建信号量*配方）。将这些信号量存储在名为`synchronizing_semaphores`的`std::vector<WaitSemaphoreInfo>`类型的变量中。准备一个列表，指定第二批次命令缓冲区在每个信号量处应该等待的阶段。将这些阶段包含在`synchronizing_semaphores`向量中。
- en: Prepare the first batch of command buffers and submit them to the queue represented
    by the `first_queue` variable. Include semaphores from the `synchronizing_semaphores`
    vector on a list of semaphores to signal (see *Submitting command buffers to a queue*
    recipe).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备第一批次命令缓冲区并将它们提交到由`first_queue`变量表示的队列中。在要触发的信号量列表中包含来自`synchronizing_semaphores`向量的信号量（参见*将命令缓冲区提交到队列*配方）。
- en: Take the handle of a queue, to which the second batch of command buffers will
    be submitted. Store this handle in a variable of type `VkQueue` named `second_queue`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取将第二批次命令缓冲区提交到的队列的句柄。将此句柄存储在名为`second_queue`的`VkQueue`类型的变量中。
- en: Prepare the second batch of command buffers and submit them to the queue, represented
    by the `second_queue` variable. Include semaphores and stages from the `synchronizing_semaphores`
    vector on a list of semaphores and stages to wait for (see *Submitting command
    buffers to a queue* recipe).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备第二批次命令缓冲区并将它们提交到由`second_queue`变量表示的队列中。在等待的信号量和阶段列表中包含来自`synchronizing_semaphores`向量的信号量和阶段（参见*将命令缓冲区提交到队列*配方）。
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe we submit two batches of command buffers. When the first batch
    is processed by the hardware and finished, it signals all the semaphores included
    in the list of semaphores to be signaled. We take only the handles of semaphores,
    because pipeline stages are not required during the process of signaling the semaphores:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们提交了两批命令缓冲区。当第一批次由硬件处理并完成时，它将向要触发的信号量列表中的所有信号量发出信号。我们只取信号量的句柄，因为在信号量的信号过程中不需要管道阶段：
- en: '[PRE20]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we take these same semaphores and use them when we submit the second
    batch of command buffers. This time, we use both handles and pipeline stages.
    The second batch will wait for all the provided semaphores at the specified pipeline
    stages. This means that some parts of the submitted command buffers may start
    being processed, but when they reach the provided stages processing is paused,
    as seen in the following diagram:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这些相同的信号量，在提交第二批次命令缓冲区时使用它们。这次，我们使用两个句柄和管道阶段。第二批次将等待在指定的管道阶段提供的所有信号量。这意味着提交的命令缓冲区的某些部分可能开始被处理，但当它们达到提供的阶段时，处理将暂停，如下面的图所示：
- en: '![](img/image_03_002.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: '[PRE21]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows how to synchronize the work of multiple command buffers submitted
    to different queues from the same logical device. The processing of the command
    buffers from the second submission will be postponed until all commands from the
    first batch are finished.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何同步来自同一逻辑设备的不同队列提交的多个命令缓冲区的工作。第二次提交的命令缓冲区的处理将被推迟，直到第一批次的所有命令都完成。
- en: See also
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a semaphore*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建信号量*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: Checking if processing of a submitted command buffer has finished
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查提交的命令缓冲区的处理是否完成
- en: When we use semaphores, the application is not involved in the process of synchronizing
    the command buffers. It doesn't know when the processing of submitted commands
    has finished and when other commands start being processed. It all takes place
    "behind the stage", and is transparent to the application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用信号量时，应用程序不参与同步命令缓冲区的过程。它不知道提交的命令的处理何时完成以及何时开始处理其他命令。所有这些都发生在“阶段之后”，对应用程序来说是透明的。
- en: But, when we want to know when the processing of a given command buffer has
    ended, we need to use fences. This way, we can check when a submitted command
    buffer is fully processed by the device.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们想知道给定命令缓冲区的处理何时结束时，我们需要使用栅栏。这样，我们可以检查提交的命令缓冲区何时被设备完全处理。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create an un-signaled fence and store it in a variable of type `VkFence` named
    `fence`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个未触发的栅栏并将其存储在名为`fence`的`VkFence`类型变量中。
- en: Prepare a batch of command buffers, semaphores to wait on submission and semaphores
    to signal after the submission is fully processed. Use the prepared data when
    submitting command buffers to the selected queue. Use the `fence` variable during
    the submission (refer to *Submitting command buffers to a queue* recipe).
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一批命令缓冲区、等待提交的信号量以及提交完成后发出信号的信号量。在将命令缓冲区提交到所选队列时使用准备好的数据。在提交期间使用`fence`变量（参考*将命令缓冲区提交到队列*配方）。
- en: Wait on the created fence object by providing a handle of a logical device,
    from which all the utilized resources were created, the `fence` variable, `VK_FALSE`
    value for the parameter defining whether to wait on all provided fences, and a
    selected value for timeout (refer to the *Waiting for fences* recipe).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供逻辑设备的句柄（所有利用的资源都由此设备创建）、`fence`变量、定义是否等待所有提供的栅栏的`VK_FALSE`值以及选定的超时值来等待创建的栅栏对象（参考*等待栅栏*配方）。
- en: When the wait is finished and the `VK_SUCCESS` value was returned, it means
    that the processing of all command buffers submitted to the queue within the batch
    in which the `fence` variable was used, has been successfully finished.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当等待完成并且返回`VK_SUCCESS`值时，这意味着在`fence`变量所在的批次中提交到队列的所有命令缓冲区的处理已成功完成。
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Synchronizing the application with submitted command buffers is done in two
    steps. First we create a fence, prepare the command buffers and submit them to
    a queue. We need to remember to provide the created fence within the same submission:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序与提交的命令缓冲区同步分为两步进行。首先我们创建一个栅栏，准备命令缓冲区并将它们提交到队列。我们需要记住在同一个提交中提供创建的栅栏：
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we just need to wait in our application, until the fence becomes signaled.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要在我们的应用程序中等待，直到栅栏被触发。
- en: '[PRE23]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This way, we are sure that the submitted command buffer has been successfully
    processed by the device.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以确保提交的命令缓冲区已被设备成功处理。
- en: But typical rendering scenarios should not cause our application to be fully
    paused, as this is just a waste of time. We should check if a fence becomes signaled.
    If it does not, we should spend the remaining time on other tasks, for example
    on improving the artificial intelligence or calculating physics more accurately,
    and check periodically the state of the fence. When the fence becomes signaled,
    we then perform the tasks that depended on the submitted commands.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，典型的渲染场景不应该导致我们的应用程序完全暂停，因为这只是浪费时间。我们应该检查栅栏是否被触发。如果没有，我们应该把剩余的时间花在其他任务上，例如提高人工智能或更精确地计算物理，并定期检查栅栏的状态。当栅栏被触发时，我们然后执行依赖于已提交命令的任务。
- en: Fences can also be used when we want to reuse command buffers. Before we can
    re-record them, we must be sure they are no longer executed by the device. We
    should have a number of command buffers recorded and submitted one after another.
    Only then, when we use all of them, do we start waiting on fences (each submitted
    batch should have an associated fence). The more separate batches of command buffers
    we have, the less time we spend on waiting for fences (refer to *Increasing the
    performance through increasing the number of separately rendered frames* recipe
    from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要重用命令缓冲区时，也可以使用栅栏。在我们能够重新记录它们之前，我们必须确保它们不再被设备执行。我们应该记录并提交一系列命令缓冲区。只有当我们使用完所有这些缓冲区后，我们才开始等待栅栏（每个提交的批次都应该有一个相关的栅栏）。我们拥有的独立的命令缓冲区批次越多，我们在等待栅栏上花费的时间就越少（参考[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*通过增加单独渲染帧的数量来提高性能*配方）。
- en: See also
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a fence*'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建栅栏*'
- en: '*Waiting for fences*'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Resetting fences*'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重置栅栏*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: Waiting until all commands submitted to a queue are finished
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待直到队列中提交的所有命令完成
- en: When we want to synchronize the application with work submitted to a selected
    queue, we don't always have to use fences. It is possible for the application
    to wait until all tasks submitted to a selected queue are finished.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将应用程序与应用程序提交给选定队列的工作同步时，我们并不总是必须使用栅栏。应用程序等待直到选定队列提交的所有任务完成是可能的。
- en: How to do it...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of the queue into which tasks were submitted. Store it in a
    variable of type `VkQueue` named `queue`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到提交任务的队列句柄。将其存储在一个名为 `queue` 的 `VkQueue` 类型的变量中。
- en: Call `vkQueueWaitIdle( queue )` and provide the `queue` variable.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkQueueWaitIdle( queue )` 并提供 `queue` 变量。
- en: We can make sure that no errors occurred by checking if the value returned by
    the call is equal to a `VK_SUCCESS`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过检查调用返回的值是否等于 `VK_SUCCESS` 来确保没有发生错误。
- en: How it works...
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `vkQueueWaitIdle()` function pauses the application until all work (processing
    of all command buffers) submitted to the given queue is finished. This way, we
    don't need to create fences.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkQueueWaitIdle()` 函数使应用程序暂停，直到提交给指定队列的所有工作（所有命令缓冲区的处理）完成。这样，我们就不需要创建栅栏。'
- en: But such synchronization should be performed only on very rare occasions. Graphics
    hardware (GPU) is usually much faster than the general processor (CPU), and may
    require work to be constantly submitted for the application to fully utilize its
    performance.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种同步操作只应在非常罕见的情况下进行。图形硬件（GPU）通常比通用处理器（CPU）快得多，可能需要不断提交工作以使应用程序充分利用其性能。
- en: Performing a wait on the application side may introduce stalls in the graphics
    hardware's pipeline, which causes the device to be inefficiently utilized.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序端执行等待可能会在图形硬件的管道中引入停滞，这会导致设备效率低下地被利用。
- en: 'To wait for the queue until it finishes all submitted work, we need to prepare
    the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待队列直到它完成所有提交的工作，我们需要准备以下代码：
- en: '[PRE24]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Waiting on fences*'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Submitting command buffers to a queue*'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将命令缓冲区提交到队列*'
- en: '*Waiting for all commands to be finished*'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有命令完成*'
- en: Waiting for all submitted commands to be finished
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待所有提交的命令完成
- en: Sometimes we would like to wait until all the work submitted to all the logical
    devices' queues is finished. This type of wait is typically done before we close
    our application and we want to destroy all created or allocated resources.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望等待直到提交给所有逻辑设备队列的所有工作完成。这种等待通常在我们关闭应用程序并希望销毁所有创建或分配的资源之前进行。
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个创建的逻辑设备的句柄，并将其存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: 'Make the following call: `vkDeviceWaitIdle( logical_device )`, for which provide
    the handle of the logical device.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下调用：`vkDeviceWaitIdle( logical_device )`，为它提供逻辑设备的句柄。
- en: You can check if there were no errors by comparing the returned value with a
    `VK_SUCCESS`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过将返回值与 `VK_SUCCESS` 进行比较来检查是否没有错误。
- en: How it works...
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `vkDeviceWaitIdle()` function causes our application to wait until a logical
    device is no longer busy. This is similar to waiting on all queues requested for
    a given device--until commands, which were submitted to all queues, are finished.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkDeviceWaitIdle()` 函数使我们的应用程序等待，直到逻辑设备不再忙碌。这类似于等待请求给定设备的所有队列--直到提交给所有队列的命令完成。'
- en: The above function is usually called just before the exit from our application.
    When we want to destroy resources, we must make sure they are no longer used by
    the logical device. This function guarantees we can safely perform such destruction.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在退出我们的应用程序之前调用上述函数。当我们想要销毁资源时，我们必须确保它们不再被逻辑设备使用。此函数保证我们可以安全地进行此类销毁。
- en: 'Waiting for all commands submitted to the device is performed like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 等待提交给设备的所有命令是这样进行的：
- en: '[PRE25]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Waiting on fences*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Waiting until all commands submitted to a queue are finished*'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待直到提交给队列的所有命令完成*'
- en: Destroying a fence
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁一个栅栏
- en: Fences can be reused multiple times. But when we don't need them anymore, typically
    just before we close our application, we should destroy them.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏可以被多次重用。但当我们不再需要它们时，通常是在我们关闭应用程序之前，我们应该销毁它们。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起逻辑设备的把手并将其存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Take the handle of a fence that should be destroyed. Use the handle to initialize
    a variable of type `VkFence` named `fence`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起应该被摧毁的栅栏把手。使用把手初始化一个名为 `fence` 的 `VkFence` 类型的变量。
- en: Call `vkDestroyFence( logical_device, fence, nullptr )` and provide the logical
    device's handle, the `fence` variable and a `nullptr` value.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyFence( logical_device, fence, nullptr )` 并提供逻辑设备的把手、`fence` 变量和一个
    `nullptr` 值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `fence` variable.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于安全原因，将 `VK_NULL_HANDLE` 值分配给 `fence` 变量。
- en: How it works...
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Fences are destroyed using the `vkDestroyFence()` function, like this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vkDestroyFence()` 函数摧毁栅栏，如下所示：
- en: '[PRE26]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We don't need to check if a value of the `fence` variable is not equal to the
    `VK_NULL_HANDLE` value because destruction of a null handle will be ignored by
    the driver. But, we do this to skip an unnecessary function call.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要检查 `fence` 变量的值是否不等于 `VK_NULL_HANDLE` 值，因为驱动程序会忽略空把手的摧毁。但是，我们这样做是为了跳过一个不必要的函数调用。
- en: But, we can't destroy an invalid object - an object that wasn't created on a
    given logical device or that has already been destroyed. That's why we assign
    a `VK_NULL_HANDLE` value to the variable with the fence's handle.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不能摧毁一个无效的对象——一个没有在给定的逻辑设备上创建或已经被摧毁的对象。这就是为什么我们将 `VK_NULL_HANDLE` 值分配给带有栅栏把手的变量。
- en: See also
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In this chapter, the recipe: *Creating a fence*.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，菜谱：*创建一个栅栏*。
- en: Destroying a semaphore
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摧毁一个信号量
- en: Semaphores can be reused multiple times, so usually we don't need to delete
    them when the application is executing. But when we don't need a semaphore any
    more, and if we are sure it is not being used by the device (there are both no
    pending waits, and no pending signal operations), we can destroy it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量可以被多次重用，所以通常在应用程序执行时我们不需要删除它们。但是，当我们不再需要信号量，并且我们确信它没有被设备使用（既没有挂起的等待，也没有挂起的信号操作），我们可以摧毁它。
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a logical device. Store this handle in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起逻辑设备的把手。将这个把手存储在一个名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Initialize a variable of type `VkSemaphore` named `semaphore` with a handle
    of the semaphore that should be destroyed. Make sure it is not referenced by any
    submissions.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用要被摧毁的信号量的把手初始化一个名为 `semaphore` 的 `VkSemaphore` 类型的变量。确保它没有被任何提交引用。
- en: 'Make the following call: `vkDestroySemaphore( logical_device, semaphore, nullptr
    )`, for which provide the logical device''s handle, the handle of the semaphore
    and a `nullptr` value.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下调用：`vkDestroySemaphore( logical_device, semaphore, nullptr )`，为它提供逻辑设备的把手、信号量的把手和一个
    `nullptr` 值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `semaphore` variable.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于安全原因，将 `VK_NULL_HANDLE` 值分配给 `semaphore` 变量。
- en: How it works...
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Deleting a semaphore is quite easy:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个信号量相当简单：
- en: '[PRE27]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we can destroy a semaphore, we must make sure it is not referenced any
    more by any of the performed queue submissions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够摧毁一个信号量之前，我们必须确保它不再被任何执行的队列提交所引用。
- en: If we performed a submission and provided a semaphore in the list of semaphores
    to be signaled, or in the list of the semaphores for which a given submission
    should wait, we must make sure the submitted commands have finished. For this
    purpose we need to use a fence on which the application should wait, or one of
    the functions waiting for all the operations to be submitted to a given queue
    or the whole device to be finished (refer to the *Waiting for fences*, *Waiting
    until all commands submitted to a queue are finished* and *Waiting for all submitted
    commands to be finished* recipes).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行了一个提交，并在要触发的信号量列表中提供了信号量，或者在给定提交应等待的信号量列表中提供了信号量，我们必须确保提交的命令已经完成。为此，我们需要使用应用程序应该等待的栅栏，或者使用等待将所有操作提交到给定队列或整个设备完成的函数之一（参考
    *等待栅栏*、*等待直到队列中所有命令完成* 和 *等待所有提交的命令完成* 菜谱）。
- en: See also
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下菜谱：
- en: '*Creating a semaphore*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Waiting for fences*'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏完成*'
- en: '*Waiting until all commands submitted to a queue are finished*'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待直到队列中所有命令完成*'
- en: '*Waiting for all submitted commands to be finished*'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有提交的命令完成*'
- en: Freeing command buffers
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放命令缓冲区
- en: When command buffers are no longer necessary and when they are not pending for
    execution on a device, they can be freed.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令缓冲区不再需要，并且它们在设备上没有挂起执行时，它们可以被释放。
- en: How to do it...
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并使用它来初始化一个名为 `logical_device` 的 `VkDevice` 类型变量。
- en: Take the handle of a command pool created from the logical device. Store this
    handle in a variable of type `VkCommandPool` named `command_pool`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取从逻辑设备创建的命令池的句柄，并将其存储在名为 `command_pool` 的 `VkCommandPool` 类型变量中。
- en: Create a vector variable with elements of type `VkCommandBuffer`, name the variable
    `command_buffers`. Resize the vector to be able to hold all command buffers that
    should be freed. Initialize the vector's elements with the handles of all the
    command buffers that should be freed.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `VkCommandBuffer` 的向量变量，命名为 `command_buffers`。将向量的大小调整为能够容纳所有应该被释放的命令缓冲区。使用应该被释放的所有命令缓冲区的句柄初始化向量元素。
- en: Call `vkFreeCommandBuffers( logical_device, command_pool, static_cast<uint32_t>(command_buffers.size()),
    &command_buffers[0] )`. During the call, provide the handles of the logical device
    and the command pool, provide the number of elements in the `command_buffers`
    vector (the number of command buffers to be freed) and a pointer to the first
    element of the `command_buffers` vector.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkFreeCommandBuffers( logical_device, command_pool, static_cast<uint32_t>(command_buffers.size()),
    &command_buffers[0] )`。在调用过程中，提供逻辑设备的句柄和命令池，提供 `command_buffers` 向量中的元素数量（要释放的命令缓冲区数量）以及
    `command_buffers` 向量第一个元素的指针。
- en: For safety reasons, clear the `command_buffers` vector.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，清除 `command_buffers` 向量。
- en: How it works...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Command buffers can be freed in groups, but during a single `vkFreeCommandBuffers()`
    function call we can only free command buffers from the same command pool. We
    can free any number of command buffers at once:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 命令缓冲区可以成组释放，但在单个 `vkFreeCommandBuffers()` 函数调用中，我们只能释放来自同一命令池的命令缓冲区。我们可以一次性释放任意数量的命令缓冲区：
- en: '[PRE28]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we can free command buffers, we must make sure they are not referenced
    by the logical device, and that all submissions in which command buffers were
    provided have already finished.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够释放命令缓冲区之前，我们必须确保它们没有被逻辑设备引用，并且所有提供命令缓冲区的提交都已经完成。
- en: Command buffers allocated from a given pool are implicitly freed when we destroy
    a command pool. So when we want to destroy a pool, we don't need to separately
    free all command buffers allocated from it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们销毁命令池时，从该池分配的命令缓冲区会隐式释放。因此，当我们想要销毁一个池时，我们不需要单独释放从它分配的所有命令缓冲区。
- en: See also
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a command pool*'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建命令池*'
- en: '*Allocating command buffers*'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配命令缓冲区*'
- en: '*Waiting for fences*'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Waiting for all commands to be finished*'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有命令完成*'
- en: '*Destroying a command pool*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁命令池*'
- en: Destroying a command pool
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁命令池
- en: When all command buffers allocated from a given pool are not used any more,
    and we also don't need the pool, we can safely destroy it.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当从给定池分配的所有命令缓冲区不再使用，并且我们也不再需要该池时，我们可以安全地销毁它。
- en: How to do it...
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Use a handle of the pool that should be destroyed to initialize a variable of
    type `VkCommandPool` named `command_pool`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用应该被销毁的池的句柄来初始化一个名为 `command_pool` 的 `VkCommandPool` 类型变量。
- en: Call `vkDestroyCommandPool( logical_device, command_pool, nullptr )`, for which
    provide the handles of the logical device and the command pool, and a `nullptr`
    value.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyCommandPool( logical_device, command_pool, nullptr )`，为它提供逻辑设备的句柄和命令池，以及一个
    `nullptr` 值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `command_pool`
    variable.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值分配给 `command_pool` 变量。
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The command pool is destroyed with the following code:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 命令池的销毁使用以下代码：
- en: '[PRE29]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But, we can't destroy the pool until all command buffers allocated from it are
    not pending for execution on a device. To do that, we can wait on fences or use
    one of the functions that causes the application to wait until the selected queue
    stops processing commands, or while the whole device is busy (the work submitted
    to all queues from a given device is still being processed). Only then can we
    safely destroy the command pool.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不能销毁该池，直到从它分配的所有命令缓冲区不再在设备上挂起等待执行。为了做到这一点，我们可以等待栅栏（fences）或使用那些会导致应用程序等待直到所选队列停止处理命令，或者整个设备忙碌（从给定设备提交到所有队列的工作仍在处理）的函数。只有在这种情况下，我们才能安全地销毁命令池。
- en: See also
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a command pool*'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建命令池*'
- en: '*Waiting for all submitted commands to be finished*'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有提交的命令完成*'
