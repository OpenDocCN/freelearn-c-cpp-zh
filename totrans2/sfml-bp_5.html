<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Playing with User Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Playing with User Interfaces</h1></div></div></div><p>In the previous chapters, we have learned how to build some simple games. This chapter will show you how to improve those games by adding a user interface to them. This chapter will cover two different possibilities of user interface:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating your own objects</li><li class="listitem" style="list-style-type: disc">Using a library that already exists–<span class="strong"><strong>Simple and Fast Graphical User Interface</strong></span> (<span class="strong"><strong>SFGUI</strong></span>)</li></ul></div><p>By the end of this chapter, you should be able to create simple to complex interfaces to communicate with the player.</p><div class="section" title="What is a GUI?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>What is a GUI?</h1></div></div></div><p>A <span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) is a mechanism that allows the user to<a id="id268" class="indexterm"/> visually interact with a software through graphical objects such as icons, text, buttons, and so on. Internally, a GUI handles some events and binds them to functions, mostly called callbacks. These functions define the reaction of the program.</p><p>There are a lot of different common objects that are always present in a GUI, such as buttons, windows, labels, and layouts. I don't think I need to explain to you what a button, window, or label is, but I will explain to you in short what a layout is.</p><p>A layout is an invisible object that manages the arrangements of the graphical objects on the screen. Simply put, its goal is to take care of the size and the position of the objects by managing a part of them. It's like a table that makes sure none of these objects are on top of the others, and which adapts their size to fill the screen as proportionately as possible.</p><div class="section" title="Creating a GUI from scratch"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Creating a GUI from scratch</h2></div></div></div><p>Now that the <a id="id269" class="indexterm"/>GUI terms have been introduced, we will think about how to build it one by one using SFML. This GUI will be added to the Gravitris project, and the result will be similar to the following two screenshots:</p><div class="mediaobject"><img src="graphics/8477OS_05_01.jpg" alt="Creating a GUI from scratch"/></div><p>These show you the starting menu of the game and the pause menu during the game.</p><p>To build this GUI, only four different objects have been used: <code class="literal">TextButton</code>, <code class="literal">Label</code>, <code class="literal">Frame</code>, and <code class="literal">VLayout</code>. We will now see how to structure our code to be as flexible as possible to be able to extend<a id="id270" class="indexterm"/> this GUI in future if needed.</p></div><div class="section" title="Class hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Class hierarchy</h2></div></div></div><p>As already said, we<a id="id271" class="indexterm"/> will need to build different components for the GUI. Each<a id="id272" class="indexterm"/> one has its own characteristics and features that can be slightly different from the others. Following are some characteristics of these components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TextButton</code>: This class will represent <a id="id273" class="indexterm"/>a button that can trigger an "on click" event when clicked on. Graphically, it's a box with text inside it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Label</code>: This accepts simple<a id="id274" class="indexterm"/> text that can be displayed on the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Frame</code>: This class is an invisible container <a id="id275" class="indexterm"/>that will contain some object through a layout. This object will also be attached to an SFML window and will fill the<a id="id276" class="indexterm"/> entire window. This class can also process events (like catching the resize of the window, the click of the <span class="emphasis"><em>Esc</em></span> key, and so on).</li><li class="listitem" style="list-style-type: disc"><code class="literal">Vlayout</code>: This class's<a id="id277" class="indexterm"/> functionality has already been explained–it displays objects vertically. This class has to be able to adjust the positions of all the objects attached to it.</li></ul></div><p>Because we want to build<a id="id278" class="indexterm"/> a GUI reusable and it needs to be as flexible as possible, we need to think bigger than our 4 classes to build it. For example, we should be able to easily add a container, switch to a horizontal layout or grid layout, make use of sprite buttons and so on. Basically, we need a hierarchy that allows the addition of new components easily. Here is a possible solution:</p><div class="mediaobject"><img src="graphics/8477OS_05_02.jpg" alt="Class hierarchy"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>In this hierarchy, each green box represents an external class of the GUI.</p></div></div><p>In the GUI system, each <a id="id279" class="indexterm"/>component is a <code class="literal">Widget</code>. This class is the base of all the other components and defines the common methods to interact with them. We also define some virtual classes, such as <code class="literal">Button</code>, <code class="literal">Container</code>, and <code class="literal">Layout</code>. Each of these classes <a id="id280" class="indexterm"/>adapts the <code class="literal">Widget</code> class and adds the possibility of growing our system without too much effort. For example, adding an <code class="literal">HLayout</code> class will be made possible by extending it from <code class="literal">Layout</code>. Other examples include some specific buttons such as <code class="literal">RadioButton</code> and <code class="literal">CheckBox</code>, which use the <code class="literal">Button</code> class.</p><p>In this hierarchy, the <code class="literal">Frame</code> class extends the <code class="literal">ActionTarget</code> class. The idea is to be able to use the bind methods of <code class="literal">ActionTarget</code> to catch some events such as when working in some window and the <span class="emphasis"><em>Esc</em></span> key is pressed.</p><p>Now that the<a id="id281" class="indexterm"/> hierarchy has been shown to you, we will continue with the<a id="id282" class="indexterm"/> implementation of the different classes. Let's start from the base: the <code class="literal">Widget</code> class.</p><div class="section" title="The Widget class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>The Widget class</h3></div></div></div><p>As already explained, this<a id="id283" class="indexterm"/> class is the common trunk of all the other <a id="id284" class="indexterm"/>GUI components. It provides some common methods with default behaviors that can be customized or improved on. A <code class="literal">Widget</code> class not only has a position and can be moved, but also has the ability to be displayed on screen. Take a look at its header source:</p><div class="informalexample"><pre class="programlisting">class Widget : public sf::Drawable
{
  public:
  Widget(Widget* parent=nullptr);
  virtual ~Widget();

  void setPosition(const sf::Vector2f&amp; pos);
  void setPosition(float x,float y);
  const sf::Vector2f&amp; getPosition()const;
  virtual sf::Vector2f getSize()const = 0;

  protected:
  virtual bool processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos);
  virtual void processEvents(const sf::Vector2f&amp; parent_pos);
  virtual void updateShape();

  Widget* _parent;
  sf::Vector2f _position;
};</pre></div><p>This first class is simple. We define a construct and a virtual destructor. The virtual destructor is very important because of the polymorphism usage inside the GUI logic. Then we define some getters and setters on the internal variables. A widget can also be attached to another one that is contained in it so we keep a reference to it for updating purposes. Now take a look at the implementation for a better understanding:</p><div class="informalexample"><pre class="programlisting">Widget::Widget(Widget* parent) : _parent(parent){}
Widget::~Widget(){}
void Widget::setPosition(const sf::Vector2f&amp; pos) {_position = pos;}
void Widget::setPosition(float x,float y)
{
  _position.x = x;
  _position.y = y;
}
const sf::Vector2f&amp; Widget::getPosition()const {return _position;}
bool Widget::processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos) {return false;}
void Widget::processEvents(const sf::Vector2f&amp; parent_pos) {}</pre></div><p>Up to this point, nothing should surprise you. We only defined some getters/setters and coded the default behavior for event handling.</p><p>Now have a look at the following function:</p><div class="informalexample"><pre class="programlisting">void Widget::updateShape()
{
  if(_parent)
  _parent-&gt;updateShape();
}</pre></div><p>This function, unlike<a id="id285" class="indexterm"/> the others we saw, is important. Its goal is to propagate the<a id="id286" class="indexterm"/> update request through the GUI tree. For example, from a button with a change in its size due to a text change, to its layout, to the container. By doing this, we are sure that each component will be updated without further efforts.</p></div><div class="section" title="The Label class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>The Label class</h3></div></div></div><p>Now that the <code class="literal">Widget</code> class<a id="id287" class="indexterm"/> has been introduced, let's build our first<a id="id288" class="indexterm"/> widget, a label. This is the simplest widget that we can build. So we will learn the logic of GUI through it. The result will be as follows:</p><div class="mediaobject"><img src="graphics/8477OS_05_03.jpg" alt="The Label class"/></div><p>For doing this we will run the following code:</p><div class="informalexample"><pre class="programlisting">class Label : public Widget
{
  public:
  Label(const std::string&amp; text, Widget* parent=nullptr);
  virtual ~Label();

  void setText(const std::string&amp; text);
  void setCharacterSize(unsigned int size);
  unsigned int getCharacterSize()const;
  void setTextColor(const sf::Color&amp; color);
  virtual sf::Vector2f getSize()const override;

  private:
  sf::Text _text;
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
};</pre></div><p>As you can see this class is nothing other than a box around <code class="literal">sf::Text</code>. It defines some methods taken<a id="id289" class="indexterm"/> from the <code class="literal">sf::Text</code> API with the exact same behavior. It also<a id="id290" class="indexterm"/> implements the requirements of <code class="literal">Widget</code> class such as the <code class="literal">getSize()</code> and <code class="literal">draw()</code> methods. Now let's have a look at the implementation:</p><div class="informalexample"><pre class="programlisting">Label::Label(const std::string&amp; text, Widget* parent) : Widget(parent)
{
  _text.setFont(Configuration::fonts.get(Configuration::Fonts::Gui));
  setText(text);
  setTextColor(sf::Color(180,93,23));
}</pre></div><p>The constructor initializes the text from a parameter, sets the default font taken from the <code class="literal">Configuration</code> class, and sets a color.</p><div class="informalexample"><pre class="programlisting">Label::~Label() {}
void Label::setText(const std::string&amp; text)
{   _text.setString(text);
  updateShape();
}
void Label::setCharacterSize(unsigned int size)
{
  _text.setCharacterSize(size);
  updateShape();
}</pre></div><p>These two functions forward their jobs to <code class="literal">sf::Text</code> and request for an update because of the possible change of size.</p><div class="informalexample"><pre class="programlisting">unsigned int Label::getCharacterSize()const {return _text.getCharacterSize();}

void Label::setTextColor(const sf::Color&amp; color) {_text.setColor(color);}

sf::Vector2f Label::getSize()const
{
  sf::FloatRect rect = _text.getGlobalBounds();
  return sf::Vector2f(rect.width,rect.height);
}</pre></div><p>SFML already provides a function to get the size of a <code class="literal">sf::Text</code> parameter, so we use it and convert the result into the excepted one as shown by the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Label::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  states.transform.translate(_position);
  target.draw(_text,states);
}</pre></div><p>This function is<a id="id291" class="indexterm"/> simple, but we need to understand it. Each widget has its own position, but is relative to the parent. So when we display the object, we <a id="id292" class="indexterm"/>need to update the <code class="literal">sf::RenderStates</code> parameter by translating the transform matrix by the relative position, and then draw all the stuff needed. It's simple, but important.</p></div><div class="section" title="The Button class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>The Button class</h3></div></div></div><p>Now, we will build another <code class="literal">Widget</code> class that is very useful: the <code class="literal">Button</code> class. This class will be a virtual one because <a id="id293" class="indexterm"/>we want to be able to build several button classes. But there are common functions <a id="id294" class="indexterm"/>shared by all the button classes, such as the "on click" event. So, the goal of this class is to group them. Take a look to the header of this class:</p><div class="informalexample"><pre class="programlisting">class Button : public Widget
{
  public:
  using FuncType = std::function&lt;void(const sf::Event&amp; event,Button&amp; self)&gt;;
  static FuncType defaultFunc;
  Button(Widget* parent=nullptr);

  virtual ~Button();
  FuncType onClick;

  protected:
  virtual bool processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)override;
  virtual void onMouseEntered();
  virtual void onMouseLeft();

  private:
  enum Status {None =0,Hover = 1};
  int _status;
};</pre></div><p>As usual, we declare the constructor and the destructor. We also declare an <code class="literal">onClick</code> attribute, which is an <code class="literal">std::function</code> that will be triggered when the button is pushed. This is our callback. The callback type is kept as <code class="literal">typedef</code> and we also declare a default empty function<a id="id295" class="indexterm"/> for convenience. Now, take a look at the implementation:</p><div class="informalexample"><pre class="programlisting">Button::FuncType Button::defaultFunc = [](const sf::Event&amp;,Button&amp;)-&gt;void{};</pre></div><p>With the help of the following code snippet, we declare an empty function that will be used as the default <a id="id296" class="indexterm"/>for the <code class="literal">onClick</code> attribute. This function does nothing:</p><div class="informalexample"><pre class="programlisting">Button::Button(Widget* parent) : Widget(parent), onClick(defaultFunc), _status(Status::None) {}</pre></div><p>We build the constructor that forwards its parameter to its parent class and also sets the <code class="literal">onClick</code> value to the default empty function previously defined to avoid undefined performance when the callback is not initialized by the user, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">Button::~Button() {}
bool Button::processEvent(const sf::Event&amp; event,const 
sf::Vector2f&amp; parent_pos)
{
  bool res = false;
  if(event.type == sf::Event::MouseButtonReleased)
  {
    const sf::Vector2f pos = _position + parent_pos;
    const sf::Vector2f size = getSize();
    sf::FloatRect rect;
    rect.left = pos.x;
    rect.top = pos.y;
    rect.width = size.x;
    rect.height = size.y;
    if(rect.contains(event.mouseButton.x,event.mouseButton.y)) 
{
      onClick(event,*this);
        res = true;
    }
  } else if (event.type == sf::Event::MouseMoved) {
    const sf::Vector2f pos = _position + parent_pos;
    const sf::Vector2f size = getSize();
    sf::FloatRect rect;
    rect.left = pos.x;
    rect.top = pos.y;
    rect.width = size.x;
    rect.height = size.y;
    int old_status = _status;
    _status = Status::None;
    const sf::Vector2f 
    mouse_pos(event.mouseMove.x,event.mouseMove.y);
    if(rect.contains(mouse_pos))
      _status=Status::Hover;
    if((old_status &amp; Status::Hover) and not (_status &amp; 
      Status::Hover))
        onMouseLeft();
    else if(not (old_status &amp; Status::Hover) and (_status &amp; 
      Status::Hover))
        onMouseEntered();
  }
  return res;
}</pre></div><p>This function is<a id="id297" class="indexterm"/> the heart of our class. It manages the events by triggering some callbacks when some criteria are satisfied. Let's take a look at it step<a id="id298" class="indexterm"/> by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the event received as the parameter is a click, we have to check whether it happens in the button area. If so, we trigger our <code class="literal">onClick</code> function.</li><li class="listitem">On the other hand, if the event is caused by moving the pointer, we verify if the mouse pointer is hovering over the button. If so, we set the status value to <code class="literal">Hover</code>, and here is the trick:</li><li class="listitem">If this flag was newly defined to <code class="literal">Hover</code>, then we call the <code class="literal">onMouseEntered()</code> method, which can be customized.</li><li class="listitem">If the flag was previously defined to <code class="literal">Hover</code> but is not set to it anymore, it's because the mouse left the area of the button, so we call another method: <code class="literal">onMouseLeft()</code>.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The value returned by the <code class="literal">processEvent()</code> method <a id="id299" class="indexterm"/>will stop the propagation of the event on the GUI if it's set to <code class="literal">true</code>. Returning false will continue the propagation of the event, so it's also possible to use an event without stopping its propagation; on the mouse moving away, for example. But in this case, we simply can't click on multiple widget objects at the same time, so we stop if needed.</p></div></div><p>I hope the logic of the <code class="literal">processEvent()</code> function is clear, because our GUI logic is based on it.</p><p>Following two functions are the default empty behavior of the button with a mouse move event. Of course, we will customize them in the specialized <code class="literal">Button</code> classes:</p><div class="informalexample"><pre class="programlisting">void Button::onMouseEntered() {}
void Button::onMouseLeft() {}</pre></div></div><div class="section" title="The TextButton class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>The TextButton class</h3></div></div></div><p>This class will <a id="id300" class="indexterm"/>extend our previously defined <code class="literal">Button</code> class. The result will be a rectangle on the screen with text inside it, just as shown in the following <a id="id301" class="indexterm"/>screenshot:</p><div class="mediaobject"><img src="graphics/8477OS_05_04.jpg" alt="The TextButton class"/></div><p>Now take a look at the implementation. Remember that our <code class="literal">Button</code> class extends from <code class="literal">sf::Drawable</code>:</p><div class="informalexample"><pre class="programlisting">class TextButton : public
{
  public:
  TextButton(const std::string&amp; text, Widget* parent=nullptr);
  virtual ~TextButton();

  void setText(const std::string&amp; text);
  void setCharacterSize(unsigned int size);

  void setTextColor(const sf::Color&amp; color);
  void setFillColor(const sf::Color&amp; color);
  void setOutlineColor(const sf::Color&amp; color);
  void setOutlineThickness(float thickness);
  virtual sf::Vector2f getSize()const override;

  private:
  sf::RectangleShape _shape;
  Label _label;
  void updateShape()override;
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
  sf::Color _fillColor;
  sf::Color _outlineColor;
  virtual void onMouseEntered()override;
  virtual void onMouseLeft()override;
};</pre></div><p>This class extends the <code class="literal">Button</code> class and adds a rectangle shape and a label to it. It also implements the <code class="literal">onMouseEntered()</code> and <code class="literal">onMouseLeft()</code> functions. These two functions will change the color of the button, making them a bit lighter:</p><div class="informalexample"><pre class="programlisting">TextButton::TextButton(const std::string&amp; text,Widget* parent) : Button(parent), _label(text,this)
{
  setFillColor(sf::Color(86,20,19));
  setOutlineThickness(5);
  setOutlineColor(sf::Color(146,20,19));
}</pre></div><p>The constructor initializes<a id="id302" class="indexterm"/> the different colors and the initial text:</p><div class="informalexample"><pre class="programlisting">TextButton::~TextButton() {}
void TextButton::setText(const std::string&amp; text) {_label.setText(text);}
void TextButton::setCharacterSize(unsigned int size) {_label.setCharacterSize(size);}
void TextButton::setTextColor(const sf::Color&amp; color) {_label.setTextColor(color);}

void TextButton::setFillColor(const sf::Color&amp; color)
{
  _fillColor = color;
  _shape.setFillColor(_fillColor);
}

void TextButton::setOutlineColor(const sf::Color&amp; color)
{
  _outlineColor = color;
  _shape.setOutlineColor(_outlineColor);
}

void TextButton::setOutlineThickness(float thickness) {_shape.setOutlineThickness(thickness);}

sf::Vector2f TextButton::getSize()const
{
  sf::FloatRect rect = _shape.getGlobalBounds();
  return sf::Vector2f(rect.width,rect.height);
}</pre></div><p>All these functions<a id="id303" class="indexterm"/> set the different attributes by forwarding the job. It also calls the <code class="literal">updateShape()</code> method to update the container:</p><div class="informalexample"><pre class="programlisting">void TextButton::updateShape()
{
  sf::Vector2f label_size = _label.getSize();
  unsigned int char_size = _label.getCharacterSize();
  _shape.setSize(sf::Vector2f(char_size*2 + label_size.x ,char_size*2 + label_size.y));
  _label.setPosition(char_size,char_size);
  Widget::updateShape();
}</pre></div><p>The following function updates the shape by resizing it using the size from the internal label and adding some padding to it:</p><div class="informalexample"><pre class="programlisting">void TextButton::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  states.transform.translate(_position);
  target.draw(_shape,states);
  target.draw(_label,states);
}</pre></div><p>This method has<a id="id304" class="indexterm"/> the same logic as Label. It moves <code class="literal">sf::RenderStates</code> to the position of the button and draws all the different <code class="literal">sf::Drawable</code><a id="id305" class="indexterm"/> parameters:</p><div class="informalexample"><pre class="programlisting">void TextButton::onMouseEntered()
{
  const float light = 1.4f;
  _shape.setOutlineColor(sf::Color(_outlineColor.r*light,
  _outlineColor.g*light,
  _outlineColor.b*light));
  _shape.setFillColor(sf::Color(_fillColor.r*light,
  _fillColor.b*light,
  _fillColor.b*light));
}

void TextButton::onMouseLeft()
{
  _shape.setOutlineColor(_outlineColor);
  _shape.setFillColor(_fillColor);
}</pre></div><p>These two functions change the color of the button when the cursor is hovering over it and reset the initial color when the cursor leaves it. This is useful for the user, because he knows which button will be clicked easily.</p><p>As you can see, implementation of a <code class="literal">TextButton</code> is pretty short, all thanks to the changes made in the parent classes, <code class="literal">Button</code> and <code class="literal">Widget</code>.</p></div><div class="section" title="The Container class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>The Container class</h3></div></div></div><p>This class is another type <a id="id306" class="indexterm"/>of <code class="literal">Widget</code> and will be abstract. A <code class="literal">Container</code> class is a <code class="literal">Widget</code> class that will store <a id="id307" class="indexterm"/>other widgets through a <code class="literal">Layout</code> class. The purpose of this class is to group all the common operations between the different possible <code class="literal">Container</code> classes, even as in our case, we only implement a <code class="literal">Frame</code> container.</p><div class="informalexample"><pre class="programlisting">class Container  : public Widget
{
  public:
  Container(Widget* parent=nullptr);
  virtual ~Container();

  void setLayout(Layout* layout);
  Layout* getLayout()const;

  virtual sf::Vector2f getSize()const override;

  protected:
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
  virtual bool processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)override;
  virtual void processEvents(const sf::Vector2f&amp; parent_pos)override;

  private:
  Layout* _layout;
};</pre></div><p>As usual, we define<a id="id308" class="indexterm"/> the constructor and destructor. We also add accessors to the internal <code class="literal">Layout</code> class. We will also implement the <code class="literal">draw()</code> method and the event processing. Now take a look at the implementation in the following code <a id="id309" class="indexterm"/>snippet:</p><div class="informalexample"><pre class="programlisting">Container::Container(Widget* parent) : Widget(parent), _layout(nullptr) {}
Container::~Container()
{
  if(_layout != nullptr and _layout-&gt;_parent == this) {
    _layout-&gt;_parent = nullptr;
    delete _layout;
  }
}</pre></div><p>The destructor deletes the internal <code class="literal">Layout</code> class, but only if the parent of the <code class="literal">Layout</code> class is the current container. This avoids double free corruption and respects the RAII idiom:</p><div class="informalexample"><pre class="programlisting">void Container::setLayout(Layout* layout)
{
  if(_layout != nullptr and _layout-&gt;_parent == this) {
    _layout-&gt;_parent = nullptr;
  }
  if((_layout = layout) != nullptr) {
    _layout-&gt;_parent = this;
    _layout-&gt;updateShape();
  }
}</pre></div><p>The previous function sets the layout of the container and deletes it from the memory if needed. Then it takes<a id="id310" class="indexterm"/> ownership of the new layout and updates the internal pointer to it.</p><div class="informalexample"><pre class="programlisting">Layout* Container::getLayout()const {return _layout;}
sf::Vector2f Container::getSize()const
{
  sf::Vector2f res(0,0);
  if(_layout)
  res = _layout-&gt;getSize();
  return res;
}
void Container::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  if(_layout)
  target.draw(*_layout,states);
}</pre></div><p>The three previous functions <a id="id311" class="indexterm"/>do the usual job, just as with the other <code class="literal">Widgets</code>:</p><div class="informalexample"><pre class="programlisting">bool Container::processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)
{
    bool res = false;
    if(and _layout)
        res = _layout-&gt;processEvent(event,parent_pos);
    return res;
}
void Container::processEvents(const sf::Vector2f&amp; parent_pos)
{
    if(_layout)
        _layout-&gt;processEvents(parent_pos);
}</pre></div><p>These two previous functions process for the events. Because a <code class="literal">Layout</code> class doesn't have any event to deal with, it forwards the job to all the internal <code class="literal">Widget</code> classes. If an event is processed by a <code class="literal">Widget</code> class, we stop the propagation, because logically no other widget should be able to deal with it.</p></div><div class="section" title="The Frame class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec20"/>The Frame class</h3></div></div></div><p>Now that the basic <a id="id312" class="indexterm"/>container has been constructed, let's extend it with a special one. The following <code class="literal">Widget</code> class will be attached to <code class="literal">sf::RenderWindow</code> and will be the main widget. It will manage the render target and the events by<a id="id313" class="indexterm"/> itself. Take a look at its header:</p><div class="informalexample"><pre class="programlisting">class Frame : public Container, protected ActionTarget&lt;int&gt;
{
  public:
  using ActionTarget&lt;int&gt;::FuncType;
  Frame(sf::RenderWindow&amp; window);
  virtual ~Frame();

  void processEvents();
  bool processEvent(const sf::Event&amp; event);

  void bind(int key,const FuncType&amp; callback);
  void unbind(int key);

  void draw();
  virtual sf::Vector2f getSize()const override;

  private:
  sf::RenderWindow&amp; _window;

  virtual bool processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)override;
  virtual void processEvents(const sf::Vector2f&amp; parent_pos)override;
};</pre></div><p>As you can see, this class is a bit more complex than the previous <code class="literal">Widget</code>. It extends the <code class="literal">Container</code> class to be<a id="id314" class="indexterm"/> able to attach a <code class="literal">Layout</code> class to it. Moreover, it also extends the <code class="literal">ActionTarget</code> class, but as protected. This is an important point. In fact, we want to allow the user to bind/unbind events, but we don't want to allow them to cast the <code class="literal">Frame</code> to an <code class="literal">ActionTarget</code>, so we hide it to the user and rewrite all the methods of the <code class="literal">ActionTarget</code> class. This is why there is a protected keyword.</p><p>The class will also be able to extract events from its parent windows; this explains why we need to keep a reference to it, as seen here:</p><div class="informalexample"><pre class="programlisting">Frame::Frame(sf::RenderWindow&amp; window) : Container(nullptr), ActionTarget(Configuration::gui_inputs), _window(window) {}
Frame::~Frame(){}

void Frame::draw() {_window.draw(*this);}

void Frame::bind(int key,const FuncType&amp; callback) {ActionTarget::bind(key,callback);}

void Frame::unbind(int key) {ActionTarget::unbind(key);}

sf::Vector2f Frame::getSize()const
{
  sf::Vector2u size = _window.getSize();
  return sf::Vector2f(size.x,size.y);
}</pre></div><p>All these methods are simple and don't require a lot of explanation. You simply initialize all the attributes with<a id="id315" class="indexterm"/> the constructor and forward the job to the attributes stored inside the class for the others, as done here:</p><div class="informalexample"><pre class="programlisting">void Frame::processEvents()
{
    sf::Vector2f parent_pos(0,0);
    processEvents(parent_pos);
}
bool Frame::processEvent(const sf::Event&amp; event)
{
    sf::Vector2f parent_pos(0,0);
    return processEvent(event,parent_pos);
}</pre></div><p>These two overload <a id="id316" class="indexterm"/>functions are exposed to the user. It forwards the job to the override functions inherited from <code class="literal">Widget</code> by constructing the missing ones or the already known arguments.</p><div class="informalexample"><pre class="programlisting">bool Frame::processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)
{
  bool res = ActionTarget::processEvent(event);
  if(not res)
  res = Container::processEvent(event,parent_pos);
  return res;
}

void Frame::processEvents(const sf::Vector2f&amp; parent_pos)
{
  ActionTarget::processEvents();
  Container::processEvents(parent_pos);
  sf::Event event;
  while(_window.pollEvent(event))
  Container::processEvent(event,parent_pos);
}</pre></div><p>On the other hand, these two functions process to the event management of the <code class="literal">ActionTarget</code> and <code class="literal">Container</code> bases of the class, but also take in charge the polling event from its parent window. In this case, all event management will be automatic.</p><p>The <code class="literal">Frame</code> class is now over. As you can see, it's not a complex task, thanks to our hierarchical tree and because we reused code here.</p></div><div class="section" title="The Layout class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>The Layout class</h3></div></div></div><p>Now that all the <a id="id317" class="indexterm"/>widgets that will be rendered on the screen are building, let's<a id="id318" class="indexterm"/> build the class that will be in charge of their arrangement:</p><div class="informalexample"><pre class="programlisting">class Layout : protected Widget
{
  public:
  Layout(Widget* parent=nullptr);
  virtual ~Layout();

  void setSpace(float pixels);

  protected:
  friend class Container;   float _space;
};</pre></div><p>As you can see, the abstract class is very simple. The only new feature is the ability to set spacing. We don't have any <code class="literal">add(Widget*)</code> method, for example. The reason is that the argument will be slightly different depending on the kind of <code class="literal">Layout</code> used. For example, we just need a<a id="id319" class="indexterm"/> <code class="literal">Widget</code> class as argument for the layout with a single column or line, but the situation is completely different for a grid. We need two other integers that represent the cell in which the widget can be placed. So, no common API is designed here. As you will see, the implementation of this class is also very simple and doesn't require any explanation. It follows the logic of the <code class="literal">Widget</code> class we previously created.</p><div class="informalexample"><pre class="programlisting">Layout::Layout(Widget* parent): Widget(parent), _space(5) {}

Layout::~Layout() {}
void Layout::setSpace(float pixels)
{
    if(pixels &gt;= 0) {
        _space = pixels;
        updateShape();
    }
    else
        throw std::invalid_argument("pixel value must be &gt;= 0");
}</pre></div></div><div class="section" title="The VLayout class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>The VLayout class</h3></div></div></div><p>This <code class="literal">Layout</code> class <a id="id320" class="indexterm"/>will be more complex than the previous ones. This one contains<a id="id321" class="indexterm"/> the full implementation of a vertical layout, which automatically adjusts its size and the alignment of all its internal objects:</p><div class="informalexample"><pre class="programlisting">class VLayout : public Layout
{
  public:
  VLayout(const VLayout&amp;) = delete;
  VLayout&amp; operator=(const VLayout&amp;) = delete;
  VLayout(Widget* parent = nullptr);
  ~Vlayout();

  void add(Widget* widget);
  Widget* at(unsigned int index)const;
  virtual sf::Vector2f getSize()const override;

  protected:
  virtual bool processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos) override;
  virtual void processEvents(const sf::Vector2f&amp; parent_pos) override;

  private:
  std::vector&lt;Widget*&gt; _widgets;
  virtual void updateShape() override;
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const override;
};</pre></div><p>The class will implement all the requirements from the widget and will also add the features to add widgets in it. So there are some functions to implement. To keep a trace of the widgets attached<a id="id322" class="indexterm"/> to the <code class="literal">Layout</code> class, we will internally store them in a container. The choice of the <code class="literal">std::vector</code> class makes sense here because of the random access of the elements for the <code class="literal">at()</code> method and the great number access<a id="id323" class="indexterm"/> through the container. So the only reason for the choice is performance, since an <code class="literal">std::list</code> will also be able to do the same job. Now, let's have a look at the implementation:</p><div class="informalexample"><pre class="programlisting">VLayout::VLayout(Widget* parent) : Layout(parent) {}
VLayout::~VLayout()
{
    for(Widget* widget : _widgets) {
        if(widget-&gt;_parent == this)
            delete widget;
    }
}</pre></div><p>The destructor will free the memory from the objects attached to the <code class="literal">Layout</code> class, with the same criteria as the ones explained in the <code class="literal">Container</code> class:</p><div class="informalexample"><pre class="programlisting">void VLayout::add(Widget* widget)
{
  widget-&gt;_parent = this;
  _widgets.emplace_back(widget);
  updateShape();
}
Widget* VLayout::at(unsigned int index)const {return _widgets.at(index);}</pre></div><p>These two previous functions add the possibility to add and get access to the widget stored by the class instance. The <code class="literal">add()</code> method additionally<a id="id324" class="indexterm"/> takes ownership of the added object:</p><div class="informalexample"><pre class="programlisting">sf::Vector2f VLayout::getSize()const
{
  float max_x = 0;
  float y = 0;
  for(Widget* widget : _widgets)
  {
    sf::Vector2f size = widget-&gt;getSize();
    if(size.x &gt; max_x)
    max_x = size.x;
    y+= _space + size.y;
  }
  return sf::Vector2f(max_x+_space*2,y+_space);
}</pre></div><p>This method <a id="id325" class="indexterm"/>calculates the total size of the layout, taking into account the spacing. Because our class will display all the objects in a single column, the height will be their total size and the width the maximal of all the objects. The spacing has to be taken into account each time.</p><div class="informalexample"><pre class="programlisting">bool VLayout::processEvent(const sf::Event&amp; event,const sf::Vector2f&amp; parent_pos)
{
  for(Widget* widget : _widgets) 
{
    if(widget-&gt;processEvent(event,parent_pos))
    return true;
  }
    return false ;
}

void VLayout::processEvents(const sf::Vector2f&amp; parent_pos)
{
  for(Widget* widget : _widgets)
  widget-&gt;processEvents(parent_pos);
}</pre></div><p>These two previous methods forward the job to all the stored widget , but we stop the propagation when it's needed.</p><div class="informalexample"><pre class="programlisting">void VLayout::updateShape()
{
  float max_x = (_parentparent-&gt;getSize().x:0);
  for(Widget* widget : _widgets) {
  sf::Vector2f size = widget-&gt;getSize();
  float widget_x = size.x;
  if(widget_x &gt; max_x)
  max_x = widget_x;
}
  float pos_y = _space;
  if(_parent)
  pos_y = (_parent-&gt;getSize().y - getSize().y)/2.f;
  for(Widget* widget : _widgets) 
{
    sf::Vector2f size = widget-&gt;getSize();
    widget-&gt;setPosition((max_x-size.x)/2.0,pos_y);
    pos_y += size.y + _space;
  }
  Widget::updateShape();
}</pre></div><p>This method is the most important for this class. It resets the different positions of all the objects by calculating it based on all the other widgets. The final result will be a column of widgets<a id="id326" class="indexterm"/> centered vertically and horizontally.</p><div class="informalexample"><pre class="programlisting">void VLayout::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  for(Widget* widget : _widgets)
  target.draw(*widget,states);
}</pre></div><p>This last function<a id="id327" class="indexterm"/> asks each <code class="literal">Widget</code> to render itself by forwarding the parameter. This time, we don't need to translate states because the position of the layout is the same as its parent.</p><p>The entire class has now been built and explained. It's now time for the user to use them and add a menu to our game.</p></div></div></div></div>
<div class="section" title="Adding a menu to the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Adding a menu to the game</h1></div></div></div><p>Now that we have <a id="id328" class="indexterm"/>all the pieces in place to build a basic menu, let's do it with our fresh GUI. We will build two of them. The main, game-opening one and the pause menu. This will show you the different usage possibilities of our actual GUI.</p><p>If you have understood what we have done until now well, you would have noticed that the base component of our GUI is <code class="literal">Frame</code>. All the other widgets will be displayed on the top of it. Here is a schema that summarizes the GUI tree hierarchy:</p><div class="mediaobject"><img src="graphics/8477OS_05_05.jpg" alt="Adding a menu to the game"/></div><p>Each color<a id="id329" class="indexterm"/> represents a different type of component. The trunk is <span class="strong"><strong>sf::RenderWindow</strong></span> and then we have a <span class="strong"><strong>Frame</strong></span> attached to it with its <span class="strong"><strong>Layout</strong></span>. And finally we have some different <span class="strong"><strong>Widget</strong></span>. Now that the usage has been explained, let's create our main menu.</p><div class="section" title="Building the main menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Building the main menu</h2></div></div></div><p>To build the main menu, we <a id="id330" class="indexterm"/>will need to add an attribute to the <code class="literal">Game</code> class. Let's <a id="id331" class="indexterm"/>call it <code class="literal">_mainMenu</code>.</p><div class="informalexample"><pre class="programlisting">gui::Frame _mainMenu;</pre></div><p>We then create an <code class="literal">enum</code> function with different possibilities of values in order to know the currently displayed status:</p><div class="informalexample"><pre class="programlisting">enum Status {StatusMainMenu,StatusGame,StatusConfiguration,StatusPaused,StatusExit} _status</pre></div><p>Now let's create a function to initialize the menu:</p><div class="informalexample"><pre class="programlisting">void initGui();</pre></div><p>This function will store the entire GUI construction, except from the constructor that is calling. Now that we have all that we need in the header file, let's move on to the implementation of<a id="id332" class="indexterm"/> all this stuff.</p><p>First of all, we need to <a id="id333" class="indexterm"/>update the constructor by adding in the initialization of <code class="literal">_mainMenu</code> and <code class="literal">_status</code>. It should look like this:</p><div class="informalexample"><pre class="programlisting">Game::Game(int X, int Y,int word_x,int word_y) : ActionTarget(Configuration::player_inputs), 
_window(sf::VideoMode(X,Y),"05_Gui"), _current_piece(nullptr), 
_world(word_x,word_y), _mainMenu(_window), 
_status(Status::StatusMainMenu)
{
  //...
  initGui();
}</pre></div><p>Now we need to implement the <code class="literal">initGui()</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void Game::initGui()
{
  book::gui::VLayout* layout = new book::gui::VLayout;
  layout-&gt;setSpace(25);
  book::gui::TextButton* newGame = new book::gui::TextButton("New Game");
  newGame-&gt;onClick = [this](const sf::Event&amp;, book::gui::Button&amp; button){
  initGame();
  _status = Status::StatusGame;
};

layout-&gt;add(newGame);
book::gui::TextButton* configuration = new book::gui::TextButton("Configuration");
configuration-&gt;onClick = [this](const sf::Event&amp;, book::gui::Button&amp; button){
  _status = Status::StatusConfiguration;
};

layout-&gt;add(configuration);
book::gui::TextButton* exit = new book::gui::TextButton("Exit");
exit-&gt;onClick = [this](const sf::Event&amp;, book::gui::Button&amp; button){
  _window.close();
};
layout-&gt;add(exit);
_mainMenu.setLayout(layout);
_mainMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event&amp; event){
    this-&gt;_window.close();
  });
}</pre></div><p>Let's discuss this function step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a <code class="literal">Vlayout</code> class and set its spacing.</li><li class="listitem">We create a button with <code class="literal">New Game</code> as its label.</li><li class="listitem">We set the <code class="literal">onClick</code> callback function that initializes the game.</li><li class="listitem">We add the button to the layout.</li><li class="listitem">With the same logic, we create two other buttons with different callbacks.</li><li class="listitem">Then we set the layout to the <code class="literal">_mainMenu</code> parameter.</li><li class="listitem">And we finally add an event directly to the frame that will handle the <span class="emphasis"><em>Esc</em></span> key. This key is<a id="id334" class="indexterm"/> defined in the <code class="literal">GuiInputs enum</code> contained in the <code class="literal">Configuration</code> class, which was constructed as <code class="literal">PlayerInputs</code>.</li></ol></div><p>Now that our<a id="id335" class="indexterm"/> menu is created, we need to make some little changes in the existing <code class="literal">run()</code>, <code class="literal">processEvents()</code>, and <code class="literal">render()</code> methods. Let's start with <code class="literal">run()</code>. The modification is negligible. In fact, we just have to add a condition for the call of the update methods, adding verification on the <code class="literal">_status</code> variable. The new line is now as follows:</p><div class="informalexample"><pre class="programlisting">if(_status == StatusGame and not _stats.isGameOver())</pre></div><p>The next function is <code class="literal">processEvents()</code>, which will require a little more modification, but not too much. In fact, we need to call <code class="literal">_mainMenu::processEvent(const f::Event&amp;)</code> and <code class="literal">_mainMenu::processEvents()</code>, but only when the game is in <code class="literal">StatusMainMenu</code> mode. The new method is now as follows:</p><div class="informalexample"><pre class="programlisting">void Game::processEvents()
{
  sf::Event event;
  while(_window.pollEvent(event))
  {
    if (event.type == sf::Event::Closed)
    _window.close();
    else if (event.type == sf::Event::KeyPressed and event.key.code == sf::Keyboard::Escape and _status == Status::StatusGame)
    _status = StatusPaused;
    else
    {
      switch(_status)
      {
        case StatusMainMenu: _mainMenu.processEvent(event);break;
        case StatusGame : ActionTarget::processEvent(event);break;
        default : break;
      }
    }
  }
  switch(_status)
  {
    case StatusMainMenu: _mainMenu.processEvents();break;
    case StatusGame :  ActionTarget::processEvents();break;
    default : break;
  }
}</pre></div><p>As you can see, the modification is not too complicated, and easily understandable.</p><p>And now, the last <a id="id336" class="indexterm"/>change in the <code class="literal">render()</code> method. The logic is the same, a switch<a id="id337" class="indexterm"/> on the <code class="literal">_status</code> value.</p><div class="informalexample"><pre class="programlisting">void Game::render()
{
  _window.clear();
  switch(_status)
  {
    case StatusMainMenu: _window.draw(_mainMenu);break;
    case StatusGame :
    {
if(not _stats.isGameOver())
  _window.draw(_world);
  _window.draw(_stats);
    }break;
    default : break;
  }
_window.display();
}</pre></div><p>As you can see, we have been able to add a menu to our game without too much effort. The result should be like the figure shown here:</p><div class="mediaobject"><img src="graphics/8477OS_05_06.jpg" alt="Building the main menu"/></div><p>Now, let's <a id="id338" class="indexterm"/>build the <a id="id339" class="indexterm"/>second menu.</p></div><div class="section" title="Building the pause menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Building the pause menu</h2></div></div></div><p>The pause menu<a id="id340" class="indexterm"/> will be constructed just like the previous one, so I will skip<a id="id341" class="indexterm"/> the constructor part and directly move on to the <code class="literal">initGui()</code> function:</p><div class="informalexample"><pre class="programlisting">void Game::initGui()
{
  //...
  book::gui::VLayout* layout = new book::gui::VLayout;
  layout-&gt;setSpace(50);
  book::gui::Label* pause = new book::gui::Label("Pause");
  pause-&gt;setCharacterSize(70);
  layout-&gt;add(pause);
  book::gui::TextButton* exit = new book::gui::TextButton("Exit");
  exit-&gt;onClick = [this](const sf::Event&amp;, book::gui::Button&amp; button)
  {
    _status = StatusMainMenu;
  };

  layout-&gt;add(exit);
  _pauseMenu.setLayout(layout);
  _pauseMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event&amp; event){
  _status = StatusGame;
  });
}</pre></div><p>The logic is exactly the same<a id="id342" class="indexterm"/> as the one used for the previous menu, but here we use a <code class="literal">Label</code> and a <code class="literal">TextButton</code> class. The callback of the button will also change<a id="id343" class="indexterm"/> the <code class="literal">_status</code> value. Here, again, we catch the <span class="emphasis"><em>Esc</em></span> key. The result is to leave this menu. In the <code class="literal">processEvents()</code>, we only need to add one line to the first switch:</p><div class="informalexample"><pre class="programlisting">case StatusPaused :_pauseMenu.processEvent(event);break;</pre></div><p>And add another line to the second switch:</p><div class="informalexample"><pre class="programlisting">case StatusPaused : _pauseMenu.processEvents();break;</pre></div><p>And that's it. We are done with this function.</p><p>The next step is the <code class="literal">render()</code> function. Here again it will be very quick. We add a case in the switch statement as follows:</p><div class="informalexample"><pre class="programlisting">case StatusPaused :
{
    if(not _stats.isGameOver())
        _window.draw(_world);
    _window.draw(_pauseMenu);
}break;</pre></div><p>The request to draw <code class="literal">_world</code> means to set the current game state in the background on the menu. This is useless, but pretty cool, so why not?</p><p>The final result is the second screenshot shown at the beginning of this chapter. Have a look at what appears on my screen:</p><div class="mediaobject"><img src="graphics/8477OS_05_07.jpg" alt="Building the pause menu"/></div></div><div class="section" title="Building the configuration menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Building the configuration menu</h2></div></div></div><p>This menu will in<a id="id344" class="indexterm"/> fact be implemented in the second part (by using SFGUI), but we<a id="id345" class="indexterm"/> need a way to exit the configuration menu. So we simply have to create a <code class="literal">_configurationMenu</code> as the two others and bind the <code class="literal">Escape</code> event to set the status to the main menu. The code in the <code class="literal">initGui()</code> to add is shown as follows:</p><div class="informalexample"><pre class="programlisting">_configurationMenu.bind(Configuration::GuiInputs::Escape,[this](const sf::Event&amp; event){
    _status = StatusMainMenu;
});</pre></div><p>I'm sure you are now able to update the <code class="literal">processEvents()</code> and <code class="literal">render()</code> functions by yourself using your new skills.</p><p>That's all concerning our home-made GUI. Of course, you can improve it as you wish. That's one of its advantages.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>If you are interested in making improvements, take a look to the external library made regrouping all our custom <a id="id346" class="indexterm"/>game framework at <a class="ulink" href="http://github.com/Krozark/SFML-utils/">http://github.com/Krozark/SFML-utils/</a>.</p></div></div><p>The next step is to<a id="id347" class="indexterm"/> use an already made GUI with more complex widgets. But keep in mind that if you only need to show menus like those presented here, this GUI<a id="id348" class="indexterm"/> is enough.</p></div></div>
<div class="section" title="Using SFGUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Using SFGUI</h1></div></div></div><p>SFGUI is an open<a id="id349" class="indexterm"/> source library that implements a complete GUI system based on the top<a id="id350" class="indexterm"/> of SFML. Its goal is to provide a rich set of widgets and to be easily customizable and extensible. It also uses modern C++, so it's easy to use in any SFML project without too much effort.</p><p>The following screenshot shows the SFGUI in action with the test example provided with the source:</p><div class="mediaobject"><img src="graphics/8477OS_05_08.jpg" alt="Using SFGUI"/></div><div class="section" title="Installing SFGUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Installing SFGUI</h2></div></div></div><p>The first step is to download<a id="id351" class="indexterm"/> the source code. You will find it on the official website<a id="id352" class="indexterm"/> of the library: <a class="ulink" href="http://sfgui.sfml-dev.de/">http://sfgui.sfml-dev.de/</a>. The current version is 0.2.3 (Feb 20, 2014). You will need to build SFGUI by yourself, but as usual, it comes with the <code class="literal">cmake</code> file to help with the build. That is perfect, because we already know how to use it.</p><p>Sometimes, you could have a problem like the one shown in the following screenshot during the build step:</p><div class="mediaobject"><img src="graphics/8477OS_05_09.jpg" alt="Installing SFGUI"/></div><p>In this case, you have<a id="id353" class="indexterm"/> to set the <code class="literal">CMAKE_MODULE_PATH</code> variable to <code class="literal">/path/to/SFML/cmake/Modules</code> using the <code class="literal">add entry</code> parameter. This should fix the problem.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>For other similar problems, take a look at this page: <a class="ulink" href="http://sfgui.sfml-dev.de/p/faq#findsfml">http://sfgui.sfml-dev.de/p/faq#findsfml</a>. It should be helpful.</p></div></div><p>Now that SFGUI is configured, you need to build it and finally install it exactly as SFML and Box2D. You should now be pretty familiar with this.</p></div><div class="section" title="Using the features of SFGUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Using the features of SFGUI</h2></div></div></div><p>I will not go too<a id="id354" class="indexterm"/> deep into the usage of SFGUI in this book. The goal is to show you that you don't always need to reinvent the wheel when a good one already exists.</p><p>SFGUI use a lot of C++11 features, such as <code class="literal">shared_pointers</code>, <code class="literal">std::functions</code>, and some others that have already been covered in this book, and uses the RAII idiom as well. As you already know how to work with these features, you will not be lost when it comes to using SFGUI optimally.</p><p>First of all, to use SFGUI objects, you must instantiate one object before all the others: <code class="literal">sfg::SFGUI</code>. This class holds all the information needed for the rendering. Except from this point, the library can be used pretty much like ours. So let's try it.</p></div><div class="section" title="Building the starting level"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Building the starting level</h2></div></div></div><p>We will add a menu to<a id="id355" class="indexterm"/> our game that will allow us to choose the starting level. The goal of this section is to add a simple form that takes a number as parameter and sets it as the starting level of the game. The final result will look like this:</p><div class="mediaobject"><img src="graphics/8477OS_05_10.jpg" alt="Building the starting level"/></div><p>Before starting with SFGUI, we need to make an update to our <code class="literal">Stats</code> class. In fact, this class doesn't allow us to start at a specific level, so we need to add that functionality. This will be done by adding a new attribute to it as follows:</p><div class="informalexample"><pre class="programlisting">unsigned int _initialLvl;</pre></div><p>We will also need a new method:</p><div class="informalexample"><pre class="programlisting">void setLevel(int lvl);</pre></div><p>That's it for the header. Now we need to initialize <code class="literal">_initialLvl</code> to <code class="literal">0</code> by default. And then change the calculation of the current level in the <code class="literal">addLines()</code> function. To do this, go to the following line:</p><div class="informalexample"><pre class="programlisting">_nbLvl = _nbRows / 10;</pre></div><p>Change the preceding line to the following:</p><div class="informalexample"><pre class="programlisting">_nbLvl = _initialLvl + (_nbRows / 10);</pre></div><p>And finally, we will need to update or implement the assessors on the current level as follows:</p><div class="informalexample"><pre class="programlisting">void Stats::setLevel(int lvl)
{
  _initialLvl = lvl;
  _textLvl.setString("lvl : "+std::to_string(lvl));
}

int Stats::getLevel()const
{
  return _initialLvl + _nbLvl;
}</pre></div><p>And that's it for the update on this class. Now let's go back to SFGUI.</p><p>We will use only three <a id="id356" class="indexterm"/>different visual objects to build the needed form: label, text input, and button. But we will also use a layout and a desktop, which is the equivalent of our <code class="literal">Frame</code> class. All the initialization will be done in the <code class="literal">initGui()</code> function, just as before.</p><p>We also need to add two new attributes to our game:</p><div class="informalexample"><pre class="programlisting">sfg::SFGUI _sfgui;
sfg::Desktop _sfgDesktop;</pre></div><p>The reason for adding <code class="literal">_sfgui</code> was previously explained. We add <code class="literal">_sfDesktop</code> for the exact same reason we add <code class="literal">Frame</code> to contain the objects.</p><p>Now take a look at the code needed to create the form:</p><div class="informalexample"><pre class="programlisting">void Game::initGui()
{
  //...
  auto title = sfg::Label::Create("Enter your starting level");
  auto level = sfg::Entry::Create();
  auto error = sfg::Label::Create();
  auto button = sfg::Button::Create( "Ok" );
  button-&gt;GetSignal( sfg::Button::OnLeftClick ).Connect(
    [level,error,this](){
      int lvl = 0;
      std::stringstream sstr(static_cast&lt;std::string&gt;(level-&gt;GetText()));
      sstr &gt;&gt; lvl;
      if(lvl &lt; 1 or lvl &gt; 100)
      error-&gt;SetText("Enter a number from 1 to 100.");
      else
      {
        error-&gt;SetText("");
        initGame();
        _stats.setLevel(lvl);
        _status = Status::StatusGame;
      }
    }
  );

  auto table = sfg::Table::Create();
  table-&gt;SetRowSpacings(10);
  table-&gt;Attach(title,sf::Rect&lt;sf::Uint32&gt;(0,0,1,1));
  table-&gt;Attach(level,sf::Rect&lt;sf::Uint32&gt;(0,1,1,1));
  table-&gt;Attach(button,sf::Rect&lt;sf::Uint32&gt;(0,2,1,1));
  table-&gt;Attach(error,sf::Rect&lt;sf::Uint32&gt;(0,3,1,1));
  table-&gt;SetAllocation(sf::FloatRect((_window.getSize().x-300)/2,
  (_window.getSize().y-200)/2,
  300,200));
  _sfgDesktop.Add(table);
}</pre></div><p>Okay, a lot of new features here, so I will explain them step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we <a id="id357" class="indexterm"/>create the different components needed for this form.</li><li class="listitem">Then we set the callback of the button on a press event. This callback does a lot of things:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We get back the text entered by the user</li><li class="listitem" style="list-style-type: disc">We convert this text to an integer using <code class="literal">std::stringstream</code></li><li class="listitem" style="list-style-type: disc">We check the validity of the input</li><li class="listitem" style="list-style-type: disc">If the input is not valid, we display an error message</li><li class="listitem" style="list-style-type: disc">On the other hand, if it is valid, we reset the game, set the starting level, and start the game</li></ul></div></li><li class="listitem">Until all the objects are created, we add them into a layout one by one.</li><li class="listitem">We change the size of the layout and center it on the window.</li><li class="listitem">Finally, we attach the layout to the desktop.</li></ol></div><p>As all the object are created and stored into <code class="literal">std::shared_</code> we don't need to keep a trace of them. SFGUI does it for us.</p><p>Now that the form is created, we have the same challenges as with our GUI: events and rendering. Good news, the logic is the same! However, we do have to code the <code class="literal">processEvents()</code> and <code class="literal">render()</code> functions again.</p><p>In the <code class="literal">processEvents()</code> method, we only need to complete the first switch as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">case StatusConfiguration :
{
  _configurationMenu.processEvent(event);
  _sfgDesktop.HandleEvent(event);
}break;</pre></div><p>As you can see, the logic is the same as our GUI, so the reasoning is clear.</p><p>And finally, the rendering. Here, again, the switch has to be completed by using the following code snippet:</p><div class="informalexample"><pre class="programlisting">case StatusConfiguration:
{
  _sfgDesktop.Update(0.0);
  _sfgui.Display(_window);
  _window.draw(_configurationMenu);
}break;</pre></div><p>The new thing is the <code class="literal">Update()</code> call. This is for animations. Since in our case, we don't have any animation, we can put <code class="literal">0</code> as the parameter. It would be good practice to add this in the <code class="literal">Game::update()</code> function, but it's okay for our needs–and it also avoids changes.</p><p>You should now <a id="id358" class="indexterm"/>be able to use this new form in the configuration menu.</p><p>Of course, in this example, I have just shown you a little piece of SFGUI. It packs in many more features, and if you are interested, I would suggest you to take a look at the documentation and the examples given with the library. It's very interesting.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Summary</h1></div></div></div><p>Congratulations, you have now finished this chapter and have gained the ability to communicate with your player in a good way. You are now able to create some buttons, use labels, and add callbacks to some event triggers set off by the user. You also know the basics to create your own GUI and how to use SFGUI.</p><p>In the next chapter, we will learn how to use the full power of the CPU by using more than one thread, and see its implications in game programming.</p></div></body></html>