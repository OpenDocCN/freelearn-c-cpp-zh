- en: Chapter 9. Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 容器
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Comparing strings in an ultra-fast manner
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以超快的方式比较字符串
- en: Using an unordered set and map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无序集合和映射
- en: Making a map, where value is also a key
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个映射，其中值也是键
- en: Using multi-index containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多索引容器
- en: Getting the benefits of single-linked list and memory pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得单链表和内存池的好处
- en: Using flat associative containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扁平关联容器
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is devoted to the Boost containers and the things directly connected
    with them. This chapter provides information about the Boost classes that can
    be used in every day programming, and that will make your code much faster, and
    the development of new applications easier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍Boost容器及其直接相关的内容。本章提供了有关可以在日常编程中使用、可以使代码运行得更快、使新应用程序的开发更简单的Boost类的信息。
- en: Containers differ not only by functionality, but also by the efficiency (complexity)
    of some of their members. The knowledge about complexities is essential for writing
    fast applications. This chapter doesn't just introduce some new containers to
    you; it gives you tips on when and when not to use a specific type of container
    or its methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不仅通过功能不同，而且通过其成员的一些效率（复杂度）也不同。了解复杂度对于编写快速应用程序至关重要。本章不仅向您介绍了一些新的容器，还提供了何时以及何时不要使用特定类型的容器或其方法的建议。
- en: So, let's begin!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Comparing strings in an ultra-fast manner
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以超快的方式比较字符串
- en: It is a common task to manipulate strings. Here we'll see how the operation
    of string comparison can be done quickly using some simple tricks. This recipe
    is a trampoline for the next one, where the techniques described here will be
    used to achieve constant time-complexity searches.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 操作字符串是一个常见任务。在这里，我们将看到如何使用一些简单的技巧快速执行字符串比较操作。这个配方是下一个配方的跳板，其中这里描述的技术将被用来实现常数时间复杂度的搜索。
- en: 'So, we need to make a class that is capable of quickly comparing strings for
    equality. We''ll make a template function to measure the speed of comparison:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要创建一个能够快速比较字符串相等的类。我们将创建一个模板函数来测量比较的速度：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires only the basic knowledge of STL and C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方只需要基本的STL和C++知识。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll make `std::string` a public field in our own class, and add all the
    comparison code to our class, without writing helper methods to work with stored
    `std::string`, as shown in the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使`std::string`成为我们自己的类的公共字段，并将所有比较代码添加到我们的类中，而不需要编写与存储的`std::string`一起工作的辅助方法，如下面的步骤所示：
- en: 'To do so, we''ll need the following header:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要以下头文件：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can create our fast comparison class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的快速比较类：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Do not forget to define the equality comparison operators:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记定义相等比较运算符：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, that''s it! Now we can run our tests and see the result using the following
    code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这就完成了！现在我们可以运行我们的测试，并使用以下代码查看结果：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The comparison of strings is slow because we are required to compare all the
    characters of the string one-by-one, if the strings are of equal length. Instead
    of doing that, we replace the comparison of strings with the comparison of integers.
    This is done via the hash function—the function that makes some short-fixed length
    representation of the string. Let us talk about the hash values on apples. Imagine
    that you have two apples with labels, as shown in the following diagram, and you
    wish to check that the apples are of the same cultivar. The simplest way to compare
    those apples is to compare them by labels. Otherwise you'll lose a lot of time
    comparing the apples based on the color, size, form, and other parameters. A hash
    is something like a label that reflects the value of the object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串比较之所以慢，是因为如果我们要求比较字符串的所有字符，如果字符串长度相等，我们就必须逐个比较这些字符。而不是这样做，我们用整数比较来替换字符串比较。这是通过哈希函数完成的——该函数使字符串具有某种短固定长度的表示。让我们谈谈苹果上的哈希值。想象一下，你有两个带有标签的苹果，如图所示，你希望检查这些苹果是否属于同一品种。比较这些苹果的最简单方法是通过标签来比较它们。否则，你将花费大量时间根据颜色、大小、形状和其他参数来比较苹果。哈希就像一个标签，反映了对象的价值。
- en: '![How it works...](img/4880OS_09_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_09_01.jpg)'
- en: So, let's move step-by-step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们一步一步来。
- en: 'In step 1, we include the header file that contains the definitions of the
    hash functions. In step 2, we declare our new string class that contains `str_`,
    which is the original value of the string and `comparison_`, which is the computed
    hash value. Note the construction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们包含了包含哈希函数定义的头文件。在步骤 2 中，我们声明了我们的新字符串类，它包含 `str_`，这是字符串的原始值，以及 `comparison_`，这是计算出的哈希值。注意构造：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `boost::hash<std::string>` is a structure, a functional object just like
    `std::negate<>`. That is why we need the first parenthesis—we construct that functional
    object. The second parenthesis with `s` inside is a call to `std::size_t operator()(const
    std::string& s)`, which will compute the hash value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::hash<std::string>` 是一个结构，一个功能对象，就像 `std::negate<>`。这就是为什么我们需要第一个括号——我们构建这个功能对象。第二个括号内包含
    `s` 的括号是对 `std::size_t operator()(const std::string& s)` 的调用，它将计算哈希值。
- en: 'Now take a look at step 3 where we define `operator==`. Look at the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看步骤 3，我们定义了 `operator==`。看看以下代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And, take additional care about the second part of the expression. The hashing
    operation loses information, which means that there is a possibility that more
    than one string produces exactly the same hash value. It means that if the hashes
    mismatch, there is a 100 percent guarantee that the strings will not match, otherwise
    we are required to compare the strings using the traditional methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还要注意表达式的第二部分。哈希操作会丢失信息，这意味着可能存在多个字符串产生完全相同的哈希值。这意味着如果哈希值不匹配，则可以保证字符串不会匹配，否则我们要求使用传统方法比较字符串。
- en: Well, it's time to compare numbers. If we measure the execution time using the
    default comparison method, it will give us 819 milliseconds; however, our hashing
    comparison works almost two times faster and finishes in 475 milliseconds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在是时候比较数字了。如果我们使用默认的比较方法来测量执行时间，它将给出 819 毫秒；然而，我们的哈希比较几乎快两倍，只需 475 毫秒就能完成。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has the hash functional object, you may find it in the `<functional>`
    header in the `std::` namespace. You will know that the default Boost implementation
    of hash does not allocate additional memory and also does not have virtual functions.
    Hashing in Boost and STL is fast and reliable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 提供了哈希功能对象，你可以在 `std::` 命名空间中的 `<functional>` 头文件中找到它。你会知道默认的 Boost 哈希实现不会分配额外的内存，也没有虚拟函数。Boost
    和 STL 中的哈希既快又可靠。
- en: 'You can also specialize hashing for your own types. In Boost, it is done via
    specializing the `hash_value` function in the namespace of a custom type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为你的自定义类型特化哈希。在 Boost 中，这是通过在自定义类型的命名空间中特化 `hash_value` 函数来完成的：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is different from STL specialization of `std::hash`, where you are required
    to make a template specialization of the `hash<>` structure in the `std::` namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 STL 的 `std::hash` 特化不同，在 `std::` 命名空间中，你需要对 `hash<>` 结构进行模板特化。
- en: Hashing in Boost is defined for all the basic type arrays (such as `int`, `float`,
    `double`, and `char`), and for all the STL containers including `std::array`,
    `std::tuple`, and `std::type_index`. Some libraries also provide hash specializations,
    for example, `Boost.Variant` can hash any `boost::variant` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost 中，哈希被定义为所有基本类型数组（例如 `int`、`float`、`double` 和 `char`），以及所有 STL 容器，包括
    `std::array`、`std::tuple` 和 `std::type_index`。一些库也提供了哈希特化，例如，`Boost.Variant` 可以对任何
    `boost::variant` 类进行哈希。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read the *Using an unordered set and map* recipe for more information about
    the hash functions' usage.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读有关使用无序集和映射的菜谱，以了解更多关于哈希函数使用的信息。
- en: The official documentation of `Boost.Functional/Hash` will tell you how to combine
    multiple hashes and provides more examples. Read about it at [http://www.boost.org/doc/libs/1_53_0/doc/html/hash.html](http://www.boost.org/doc/libs/1_53_0/doc/html/ha).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Functional/Hash` 的官方文档会告诉你如何组合多个哈希并提供更多示例。请阅读[http://www.boost.org/doc/libs/1_53_0/doc/html/hash.html](http://www.boost.org/doc/libs/1_53_0/doc/html/ha)。'
- en: Using an unordered set and map
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无序集和映射
- en: In the previous recipe, we saw how string comparison can be optimized using
    hashing. After reading it, the following question may arise, "Can we make a container
    that will cache hashed values to use faster comparison?".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何通过哈希来优化字符串比较。阅读之后，可能会产生以下疑问：“我们能否创建一个容器来缓存哈希值，以便更快地进行比较？”
- en: The answer is yes, and we can do much more. We can achieve almost constant time
    complexities for search, insertion, and removal of elements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，我们可以做更多。我们可以实现几乎恒定的时间复杂度，用于搜索、插入和删除元素。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and STL containers is required. Reading the previous
    recipe will also help.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要具备 C++ 和 STL 容器的基本知识。阅读之前的食谱也会有所帮助。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This will be the simplest of all recipes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是所有食谱中最简单的一个：
- en: All you need to do is just include the `<boost/unordered_map.hpp>` header, if
    we wish to use maps or the `<boost/unordered_set.hpp>` header, if we wish to use
    sets.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只需要包含 `<boost/unordered_map.hpp>` 头文件，如果我们想使用映射，或者包含 `<boost/unordered_set.hpp>`
    头文件，如果我们想使用集合。
- en: 'Now you are free to use `boost::unordered_map`, instead of `std::map` and `boost::unordered_set`
    instead of `std::set`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以自由地使用 `boost::unordered_map` 而不是 `std::map`，以及使用 `boost::unordered_set`
    而不是 `std::set`：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unordered containers store values and remember the hash of each value. Now if
    you wish to find a value in them, they will compute the hash of that value and
    search for that hash in the container. After the hash is found, the containers
    check for equality between the found value and the searched value. Then, the iterator
    to the value, or to the end of the container is returned.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无序容器存储值并记住每个值的哈希。现在，如果您想在这些容器中查找一个值，它们将计算该值的哈希并搜索容器中的该哈希。找到哈希后，容器将检查找到的值与搜索值之间的相等性。然后，返回值的迭代器或容器的末尾迭代器。
- en: Because the container can search for a constant width integral hash value, it
    may use some optimizations and algorithms suitable only for integers. Those algorithms
    guarantee constant search complexity O(1), when traditional `std::set` and `std::map`
    provide worse complexity O(log(N)), where N is the number of elements in the container.
    This leads us to a situation where the more elements in traditional `std::set`
    or `std::map` , the slower it works. However, the performance of unordered containers
    does not depend on the element count.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器可以搜索一个常宽整数的哈希值，它可能使用一些仅适用于整数的优化和算法。这些算法保证了常数搜索复杂度 O(1)，而传统的 `std::set` 和
    `std::map` 提供的复杂度更差，为 O(log(N))，其中 N 是容器中元素的数量。这导致了一个情况，即传统 `std::set` 或 `std::map`
    中的元素越多，其工作速度越慢。然而，无序容器的性能并不依赖于元素数量。
- en: 'Such good performance never comes free of cost. In unordered containers, values
    are unordered (you are not surprised, are you?). It means that if we''ll be outputting
    elements of containers from `begin()` to `end()`, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的高性能并不是免费的。在无序容器中，值是无序的（您不会感到惊讶，对吧？）。这意味着如果我们将从 `begin()` 到 `end()` 输出容器的元素，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll get the following output for `std::set` and `boost::unordered_set`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `std::set` 和 `boost::unordered_set`，我们将得到以下输出：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, how much does the performance differ? Have a look at the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，性能差异有多大？看看以下输出：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The performance was measured using the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是通过以下代码测量的：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the code contains a lot of string constructions, so it is not 100
    percent correct to measure the speedup using this test. It is here to show that
    unordered containers are usually faster than ordered ones.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码中包含大量的字符串构造，因此使用此测试来衡量加速并不完全正确。它在这里是为了表明无序容器通常比有序容器更快。
- en: 'Sometimes a task might arise where we need to use a user-defined type in unordered
    containers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能会出现需要在使用无序容器中定义用户自定义类型的情况：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To do that, we need to write a comparison operator for that type:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要为该类型编写一个比较运算符：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, specialize the hashing function for that type. If the type consists of
    multiple fields, we usually just need to combine the hashes of all the fields
    that participate in equal comparison:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为该类型特别指定哈希函数。如果类型由多个字段组成，我们通常只需要组合所有参与相等比较的字段的哈希值：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is highly recommended to combine hashes using the `boost::hash_combine` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈推荐使用 `boost::hash_combine` 函数组合哈希值。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Multiversions of containers are also available: `boost::unordered_multiset`
    is defined in the `<boost/unordered_set.hpp>` header, and `boost::unordered_multimap`
    is defined in the `<boost/unordered_map.hpp>` header. Just like in the case of
    STL, multiversions of containers are capable of storing multiple equal key values.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的多版本也是可用的：`boost::unordered_multiset` 在 `<boost/unordered_set.hpp>` 头文件中定义，而
    `boost::unordered_multimap` 在 `<boost/unordered_map.hpp>` 头文件中定义。就像在 STL 的情况下，容器多版本能够存储多个相等的键值。
- en: All the unordered containers allow you to specify your own hashing functor,
    instead of the default `boost::hash`. They also allow you to specialize your own
    equal comparison functor, instead of the default `std::equal_to`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的无序容器都允许你指定自己的哈希函数，而不是默认的 `boost::hash`。它们还允许你特化自己的相等比较函数，而不是默认的 `std::equal_to`。
- en: 'C++11 has all the unordered containers from Boost. You may find them in the
    headers: `<unordered_set>` and `<unordered_map>`, in the `std::` namespace, instead
    of `boost::`. The Boost and the STL versions have the same performance, and must
    work in the same way. However, Boost''s unordered containers are available even
    on C++03 compilers, and make use of the rvalue reference emulation of `Boost.Move`,
    so you can use those containers for the move-only classes in C++03.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 包含了所有来自 Boost 的无序容器。你可以在头文件中找到它们：`<unordered_set>` 和 `<unordered_map>`，在
    `std::` 命名空间中，而不是 `boost::`。Boost 和 STL 版本具有相同的性能，并且必须以相同的方式工作。然而，Boost 的无序容器甚至在
    C++03 编译器上也是可用的，并利用了 `Boost.Move` 的右值引用仿真，因此你可以使用这些容器来处理 C++03 中的移动只类。
- en: 'C++11 has no `hash_combine` function, so you will need to write your own:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 没有提供 `hash_combine` 函数，因此你需要自己编写：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Or just use `boost::hash_combine`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者直接使用 `boost::hash_combine`。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: The recipe *Using the C++11 move emulation* in [Chapter 1](ch01.html "Chapter 1. Starting
    to Write Your Application"), *Starting to Write Your Application*, for more details
    on rvalue reference emulation of `Boost.Move`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `Boost.Move` 的右值引用仿真的详细信息，请参考[第1章](ch01.html "第1章. 开始编写你的应用程序")中的*使用C++11移动仿真*配方。
- en: More information about the unordered containers is available on the official
    site at [http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html](http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于无序容器的更多信息可以在官方网站上找到[http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html](http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html)
- en: More information about combining hashes and computing hashes for ranges is available
    at [http://www.boost.org/doc/libs/1_53_0/do](http://www.boost.org/doc/libs/1_53_0/do)[c/html/hash.html](http://c/html/hash.html)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于组合哈希和计算范围哈希的更多信息，请访问[http://www.boost.org/doc/libs/1_53_0/do](http://www.boost.org/doc/libs/1_53_0/do)[c/html/hash.html](http://c/html/hash.html)
- en: Making a map, where value is also a key
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个值也是键的映射
- en: Several times in a year, we need something that can store and index a pair of
    values. Moreover, we need to get the first part of the pair using the second,
    and get the second part using the first. Confused? Let me show you an example.
    We are creating a vocabulary class, wherein when the users put values into it,
    the class must return identifiers and when the users put identifiers into it,
    the class must return values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每年有几次，我们需要一种可以存储和索引一对值的东西。此外，我们需要使用第二个值来获取对的第一个部分，使用第一个值来获取第二个部分。困惑吗？让我给你举一个例子。我们正在创建一个词汇类，当用户将其值放入其中时，该类必须返回标识符；当用户将其标识符放入其中时，该类必须返回值。
- en: To be more practical, users will be entering login names into our vocabulary,
    and wish to get the unique identifier of a person. They will also wish to get
    all the persons' names using identifiers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更实用，用户将输入登录名到我们的词汇中，并希望获取一个人的唯一标识符。他们还希望使用标识符获取所有人员的姓名。
- en: Let's see how it can be implemented using Boost.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Boost 来实现它。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of STL and templates are required for this recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，需要基本的 STL 和模板知识。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This recipe is about the abilities of the `Boost.Bimap` library. Let''s see
    how it can be used to implement this task:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是关于 `Boost.Bimap` 库的能力。让我们看看如何使用它来实现这个任务：
- en: 'We''ll need the following includes:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下包含：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we are ready to make our vocabulary structure:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的词汇结构：
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It can be filled using the following syntax:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下语法来填充：
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can work with the left part of bimap just like with a map:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像处理映射的左侧一样处理双向映射的左侧：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The right part of bimap is almost the same as the left:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向映射的右侧几乎与左侧相同：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to ensure that there is such a person in the vocabulary:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要确保这个人在词汇中存在：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s it. Now, if we put all the code (except includes) inside `int main()`,
    we''ll get the following output:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就是全部了。现在，如果我们把所有的代码（除了包含）放在 `int main()` 中，我们会得到以下输出：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In step 2, we define the `bimap` type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们定义了 `bimap` 类型：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first template parameter tells that the first key must have type `std::string`,
    and should work as `std::set`. The second template parameter tells that the second
    key must have type `std::size_t`. Multiple first keys can have a single second
    key value, just like in `std::multimap`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板参数表示第一个键必须是 `std::string` 类型，并且应该像 `std::set` 一样工作。第二个模板参数表示第二个键必须是 `std::size_t`
    类型。多个第一个键可以有一个单一的第二个键值，就像在 `std::multimap` 中一样。
- en: 'We can specify the underlying behavior of `bimap` using classes from the `boost::bimaps::`
    namespace. We can use hash map as an underlying type for the first key:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `boost::bimaps::` 命名空间中的类来指定 `bimap` 的底层行为。我们可以将哈希映射作为第一个键的底层类型：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we do not specify the behavior of the key, and just specify its type,
    `Boost.Bimap` uses `boost::bimaps::set_of` as a default behavior. Just like in
    our example, we can try to express the following code using STL:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有指定键的行为，只是指定其类型时，`Boost.Bimap` 使用 `boost::bimaps::set_of` 作为默认行为。就像在我们的例子中，我们可以尝试使用
    STL 表达以下代码：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using STL it would look like a combination of the following two variables:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 STL，它看起来像以下两个变量的组合：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see from the preceding comments, a call to `name_id.left` (in step
    4) will return a reference to something with an interface close to `std::map<std::string,
    std::size_t>`. A call to `name_id.right` from step 5 will return something with
    an interface close to `std::multimap<std::size_t, std::string>`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述注释所示，在步骤 4 中调用 `name_id.left` 将返回一个类似于 `std::map<std::string, std::size_t>`
    接口的引用。在步骤 5 中从 `name_id.right` 调用将返回一个类似于 `std::multimap<std::size_t, std::string>`
    接口的对象。
- en: In step 6, we work with a whole `bimap`, searching for a pair of keys, and making
    sure that they are in the container.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 6 中，我们处理整个 `bimap`，搜索键对，并确保它们在容器中。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Unfortunately, C++11 has nothing close to `Boost.Bimap`. Here we have some
    other bad news: `Boost.Bimap` does not support rvalue references, and on some
    compilers, insane numbers of warnings will be shown. Refer to your compiler''s
    documentation to get the information about suppressing specific warnings.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++11 没有与 `Boost.Bimap` 类似的东西。这里还有一些坏消息：`Boost.Bimap` 不支持右值引用，并且在某些编译器上，将显示大量警告。请参考您的编译器文档以获取有关抑制特定警告的信息。
- en: The good news is that `Boost.Bimap` usually uses less memory than two STL containers,
    and makes searches as fast as STL containers. It has no virtual function calls
    inside, but does use dynamic allocations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，`Boost.Bimap` 通常比两个 STL 容器使用更少的内存，并且搜索速度与 STL 容器一样快。它内部没有虚函数调用，但确实使用了动态分配。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Using multi-index containers*, will give you more information
    about multi-indexing, and about the Boost library that can be used instead of
    `Boost.Bimap`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱，*使用多索引容器*，将为您提供更多关于多索引以及可以替代 `Boost.Bimap` 的 Boost 库的信息。
- en: Read the official documentation for more examples and information about `bimap`
    at [http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `bimap` 的更多示例和信息，请阅读官方文档，[http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/index.html)
- en: Using multi-index containers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多索引容器
- en: 'In the previous recipe, we made some kind of vocabulary, which is good when
    we need to work with pairs. But, what if we need much more advanced indexing?
    Let''s make a program that indexes persons:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们创建了一些词汇，当我们需要处理成对的内容时很有用。但是，如果我们需要更高级的索引呢？让我们编写一个索引人员的程序：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will need a lot of indexes; for example, by name, ID, height, and weight.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要很多索引；例如，按名称、ID、身高和体重。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of STL containers and unordered maps is required.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解 STL 容器和无序映射。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: All the indexes can be constructed and managed by a single `Boost.Multiindex`
    container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有索引都可以由单个 `Boost.Multiindex` 容器构建和管理。
- en: 'To do so, we will need a lot of includes:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要很多包含：
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The hardest part is to construct the multi-index type:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最困难的部分是构建多索引类型：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we may insert values into our multi-index:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将值插入到我们的多索引中：
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s construct a function for printing the index content:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建一个用于打印索引内容的函数：
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Print all the indexes as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打印所有索引：
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Some code from the previous recipe can also be used:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前菜谱中的某些代码也可以使用：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now if we run our example, it will output the content of the indexes:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果我们运行我们的示例，它将输出索引的内容：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The hardest part here is the construction of a multi-index type using `boost::multi_index::multi_index_container`.
    The first template parameter is a class that we are going to index. In our case,
    it is `person`. The second parameter is a type `boost::multi_index::indexed_by`,
    all the indexes must be described as a template parameter of that class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最困难的部分是使用 `boost::multi_index::multi_index_container` 构造一个多索引类型。第一个模板参数是我们将要索引的类。在我们的例子中，它是
    `person`。第二个参数是类型 `boost::multi_index::indexed_by`，所有索引都必须描述为该类的模板参数。
- en: 'Now, let''s take a look at the first index description:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第一个索引描述：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The usage of the `boost::multi_index::ordered_unique` class means that the index
    must work like `std::set`, and have all of its members. The `boost::multi_index::identity<person>`
    class means that the index will use the `operator <` of a `person` class for orderings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::multi_index::ordered_unique` 类的使用意味着索引必须像 `std::set` 一样工作，并且具有所有其成员。`boost::multi_index::identity<person>`
    类意味着索引将使用 `person` 类的 `operator <` 进行排序。'
- en: 'The next table shows the relation between the `Boost.MultiIndex` types and
    the STL containers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表格显示了 `Boost.MultiIndex` 类型与 STL 容器之间的关系：
- en: '| The Boost.MultiIndex types | STL containers |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| The Boost.MultiIndex types | STL containers |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boost::multi_index::ordered_unique` | `std::set` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::ordered_unique` | `std::set` |'
- en: '| `boost::multi_index::ordered_non_unique` | `std::multiset` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::ordered_non_unique` | `std::multiset` |'
- en: '| `boost::multi_index::hashed_unique` | `std::unordered_set` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::hashed_unique` | `std::unordered_set` |'
- en: '| `boost::multi_index::hashed_non_unique` | `std::unordered_mutiset` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::hashed_non_unique` | `std::unordered_multiset` |'
- en: '| `boost::multi_index::sequenced` | `std::list` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::sequenced` | `std::list` |'
- en: 'Let''s take a look at the second index:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个索引：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `boost::multi_index::hashed_non_unique` type means that the index will work
    like `std::set`, and `boost::multi_index::member<person, std::size_t, &person::id_>`
    means that the index will apply the hash function only to a single member field
    of the person structure, to `person::id_`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::multi_index::hashed_non_unique` 类型意味着索引将像 `std::set` 一样工作，而 `boost::multi_index::member<person,
    std::size_t, &person::id_>` 意味着索引将仅对人的结构体中的单个成员字段应用哈希函数，即 `person::id_`。'
- en: 'The remaining indexes won''t be a trouble now, so let''s take a look at the
    usage of indexes in the print function instead. Getting the type of iterator for
    a specific index is done using the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩余的索引不会造成麻烦，因此让我们看看在打印函数中使用索引的方式。获取特定索引的迭代器类型是通过以下代码完成的：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This looks slightly overcomplicated because `Indexes` is a template parameter.
    The example would be simpler, if we could write this code in the scope of `indexes_t`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来稍微有些复杂，因为 `Indexes` 是一个模板参数。如果我们可以在这个 `indexes_t` 的作用域中编写此代码，示例将更简单：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `nth_index` member metafunction takes a zero-based number of index to use.
    In our example, index 1 is the index of IDs, index 2 is the index of heights and
    so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth_index` 成员元函数接受一个基于零的索引号来使用。在我们的例子中，索引 1 是 ID 的索引，索引 2 是高度的索引，以此类推。'
- en: 'Now, let''s take a look at how to use `const_iterator_t`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `const_iterator_t`：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This can also be simplified for `indexes_t` being in scope:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在作用域中简化 `indexes_t`：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The function `get<indexNo>()` returns index. We can use that index almost like
    an STL container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `get<indexNo>()` 返回索引。我们可以几乎像使用 STL 容器一样使用那个索引。
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has no multi-index library. The `Boost.MultiIndex` library is a fast library
    that uses no virtual functions. The official documentation of `Boost.MultiIndex`
    contains performance and memory usage measures, showing that this library in most
    cases uses less memory than STL-based handwritten code. Unfortunately, `boost::multi_index::multi_index_container`
    does not support C++11 features, and also has no rvalue references emulation using
    `Boost.Move`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 没有多个索引库。`Boost.MultiIndex` 库是一个快速库，不使用虚拟函数。`Boost.MultiIndex` 的官方文档包含了性能和内存使用度量，显示在大多数情况下，这个库使用的内存比基于
    STL 的手写代码少。不幸的是，`boost::multi_index::multi_index_container` 不支持 C++11 特性，也没有使用
    `Boost.Move` 的右值引用模拟。
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: The official documentation of `Boost.MultiIndex` contains tutorials, performance
    measures, examples, and other `Boost.Multiindex` libraries' description of useful
    features. Read about it at [http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.MultiIndex` 的官方文档包含教程、性能度量、示例以及其他 `Boost.Multiindex` 库的有用功能描述。请参阅[http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html)。'
- en: Getting the benefits of single-linked list and memory pool
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取单链表和内存池的好处
- en: Nowadays, we usually use `std::vector` when we need nonassociative and nonordered
    containers. This is recommended by *Andrei Alexandrescu* and *Herb Sutter* in
    the book *C++ Coding Standards*, and even those users who did not read the book
    usually use `std::vector`. Why? Well, `std::list` is slower, and uses much more
    resources than `std::vector`. The `std::deque` container is very close to `std::vector`
    , but stores values noncontinuously.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们需要非关联和非有序容器时，我们通常使用 `std::vector`。这在 *C++ Coding Standards* 一书中由 *Andrei
    Alexandrescu* 和 *Herb Sutter* 推荐，甚至那些没有读过这本书的用户通常也会使用 `std::vector`。为什么？因为 `std::list`
    比较慢，并且使用的资源比 `std::vector` 多得多。`std::deque` 容器非常接近 `std::vector`，但它存储的值不是连续的。
- en: Everything is good until we do not need a container; however, if we need a container,
    erasing and inserting elements does not invalidate iterators. Then we are forced
    to choose the slower `std::list`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好，直到我们不需要容器；然而，如果我们需要容器，删除和插入元素不会使迭代器失效。然后我们被迫选择较慢的 `std::list`。
- en: But wait, there is a good solution in Boost for such cases!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，Boost 对于这种情况有一个很好的解决方案！
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Good knowledge of STL containers is required to understand the introductory
    part. After that, only basic knowledge of C++ and STL containers is required.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解介绍部分，需要具备对 STL 容器的良好了解。之后，只需要对 C++ 和 STL 容器有基本了解即可。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we''ll be using two Boost libraries at the same time: `Boost.Pool`
    and single-linked list from `Boost.Container`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将同时使用两个 Boost 库：`Boost.Pool` 和来自 `Boost.Container` 的单链表。
- en: 'We''ll need the following headers:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE42]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we need to describe the type of our list. This can be done as shown in
    the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要描述我们的列表类型。这可以通过以下代码实现：
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can work with our single-linked list like with `std::list`. Take a look
    at the function that is used to measure the speed of both the list types:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像使用 `std::list` 一样使用我们的单链表。看看用于测量两种列表类型速度的函数：
- en: '[PRE44]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Features specific for each type of list are moved to `list_specific` functions:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每种列表类型特有的功能被移动到 `list_specific` 函数中：
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we are using `std::list`, we may notice a slowdown because each node of
    the list needs a separate allocation. It means that usually when we insert 10
    elements into `std::list`, the container calls new 10 times.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `std::list` 时，我们可能会注意到速度变慢，因为列表的每个节点都需要单独的分配。这意味着通常当我们向 `std::list` 插入
    10 个元素时，容器会调用 new 10 次。
- en: That is why we used boost`::fast_pool_allocator<int>` from `Boost.Pool`. This
    allocator tries to allocate bigger blocks of memory, so that at a later stage,
    multiple nodes can be constructed without any calls to allocate new ones.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们使用了来自 `Boost.Pool` 的 `boost::fast_pool_allocator<int>`。这个分配器试图分配更大的内存块，这样在稍后的阶段，多个节点可以构建而无需调用分配新的内存。
- en: The `Boost.Pool` library has a drawback—it uses memory for internal needs. Usually,
    an additional `sizeof` pointer is used per element. To workaround that issue,
    we are using a single linked list from `Boost.Containers`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Pool` 库有一个缺点——它使用内存来满足内部需求。通常，每个元素都会使用额外的 `sizeof` 指针。为了解决这个问题，我们使用了来自
    `Boost.Containers` 的单链表。'
- en: The `boost::container::slist` class is more compact, but its iterators can iterate
    only forward. Step 3 will be trivial for those readers who are aware of STL containers,
    so we move to step 4 to see some `boost::container::slist` specific features.
    Since the single-linked list iterator could iterate only forward, traditional
    algorithms of insertion and deletion will take linear time O(N). That's because
    when we are erasing or inserting, the previous element must be modified to point
    at new elements of the list. To workaround that issue, the single-linked list
    has the methods `erase_after` and `insert_after` that work for constant time O(1).
    These methods insert or erase elements right after the current position of the
    iterator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::slist` 类更紧凑，但它的迭代器只能向前迭代。对于熟悉 STL 容器的读者来说，步骤 3 将是微不足道的，所以我们转到步骤
    4 来查看一些 `boost::container::slist` 特定的功能。由于单链表迭代器只能向前迭代，传统的插入和删除算法将需要线性时间 O(N)。那是因为当我们删除或插入时，前一个元素必须被修改以指向列表的新元素。为了解决这个问题，单链表有
    `erase_after` 和 `insert_after` 方法，它们可以在常数时间 O(1) 内工作。这些方法在迭代器的当前位置之后插入或删除元素。'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, erasing and inserting values at the beginning of single-linked lists
    makes no big difference.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在单链表的开始处删除和插入值并没有太大的区别。
- en: 'Take a careful look at the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看以下代码：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It is required because `boost::fast_pool_allocator` does not free memory, so
    we must do it by hand. The *Doing something at scope exit* recipe from [Chapter
    3](ch03.html "Chapter 3. Managing Resources"), *Managing Resources*, will be a
    help in freeing `Boost.Pool`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `boost::fast_pool_allocator` 不会释放内存，所以我们必须手动完成。来自 [第 3 章](ch03.html "第
    3 章。管理资源") 的 *在作用域退出时做某事* 配方将有助于释放 `Boost.Pool`。
- en: 'Let''s take a look at the execution results to see the difference:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行结果以查看差异：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we can see, `slist_t` uses half the memory, and is twice as fast compared
    to the `std::list` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`slist_t` 使用了内存的一半，并且比 `std::list` 类快两倍。
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has `std::forward_list`, which is very close to `boost::containers::slist`.
    It also has the `*_after` methods, but has no `size()` method. They have the same
    performance and neither of them have virtual functions, so these containers are
    fast and reliable. However, the Boost version is also usable on C++03 compilers,
    and even has support for rvalue references emulation via `Boost.Move`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 有 `std::forward_list`，它与 `boost::containers::slist` 非常相似。它也有 `*_after`
    方法，但没有 `size()` 方法。它们的性能相同，并且它们都没有虚拟函数，所以这些容器既快又可靠。然而，Boost 版本也可以在 C++03 编译器上使用，并且甚至通过
    `Boost.Move` 提供对右值引用仿真的支持。
- en: Pools are not part of C++11\. Use the version from Boost; it is fast and does
    not use virtual functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 池不是 C++11 的一部分。请使用 Boost 的版本；它既快又不使用虚拟函数。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Guessing why `boost::fast_pool_allocator` does not free the memory by itself?
    That's because C++03 has no stateful allocators, so the containers are not copying
    and storing allocators. That makes it impossible to implement a `boost::fast_pool_allocator`
    function that deallocates memory by itself.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `boost::fast_pool_allocator` 不能自己释放内存？那是因为 C++03 没有状态分配器，所以容器不会复制和存储分配器。这使得无法实现一个可以自己释放内存的
    `boost::fast_pool_allocator` 函数。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of `Boost.Pool` contains more examples and classes
    to work with memory pools. Read about it at [http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Pool` 的官方文档包含了更多关于内存池的示例和类。请在此处阅读：[http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/index.html)。'
- en: The *Using flat associative containers* recipe will introduce you to some more
    classes from `Boost.Container`. You can also read the official documentation of
    `Boost.Container` to study that library by yourself, or get full reference documentation
    of its classes at [http://www.boost.org/doc/libs/1_53_0/doc/html/container.html](http://www.boost.org/doc/libs/1_53_0/doc/html/container.html).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用平面关联容器* 的配方将向您介绍 `Boost.Container` 中的一些更多类。您也可以阅读 `Boost.Container` 的官方文档，自己学习该库，或在其类中获取完整的参考文档：[http://www.boost.org/doc/libs/1_53_0/doc/html/container.html](http://www.boost.org/doc/libs/1_53_0/doc/html/container.html)。'
- en: Read about why stateful allocators may be required at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关为什么可能需要状态分配器的信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/allocators_containers.html#interprocess.allocators_containers.allocator_introduction)。
- en: '*Vector vs List*, and other interesting topics from *Bjarne Stroustrup*, the
    inventor of the C++ programming language, can be found at [http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup)[-Cpp11-Style](http://-Cpp11-Style).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量与列表*，以及其他来自 C++ 编程语言发明者 *Bjarne Stroustrup* 的有趣话题，可以在 [http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup)[-Cpp11-Style](http://-Cpp11-Style)
    找到。'
- en: Using flat associative containers
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平面关联容器
- en: 'After reading the previous recipe, some of the readers may start using fast
    pool allocators everywhere; especially, for `std::set` and `std::map`. Well, I''m
    not going to stop you from doing that, but let''s at least take a look at an alternative:
    flat associative containers. These containers are implemented on top of the traditional
    vector container and store the values ordered.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了之前的菜谱后，一些读者可能会开始到处使用快速池分配器；特别是，对于 `std::set` 和 `std::map`。好吧，我不会阻止你这样做，但至少让我们看看一个替代方案：平面关联容器。这些容器是在传统的向量容器之上实现的，并按顺序存储值。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Basic knowledge of STL associative containers is required.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 需要掌握 STL 关联容器的基本知识。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The flat containers are part of the `Boost.Container` library. We already saw
    how to use some of its containers in the previous recipes. In this recipe we''ll
    be using a `flat_set` associative container:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 平面容器是 `Boost.Container` 库的一部分。我们已经在之前的菜谱中看到了如何使用其中的一些容器。在这个菜谱中，我们将使用一个 `flat_set`
    关联容器：
- en: 'We''ll need to include only a single header file:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要包含一个头文件：
- en: '[PRE48]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After that, we are free to construct the flat container:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以自由地构建平面容器：
- en: '[PRE49]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Reserving space for elements:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为元素预留空间：
- en: '[PRE50]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Filling the container:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充容器：
- en: '[PRE51]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can work with it just like with `std::set`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像使用 `std::set` 一样使用它：
- en: '[PRE52]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Steps 1 and 2 are trivial, but step 3 requires attention. It is one of the most
    important steps while working with flat associative containers and `std::vector`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1 和 2 很简单，但步骤 3 需要特别注意。这是在使用平面关联容器和 `std::vector` 时最重要的步骤之一。
- en: The `boost::container::flat_set` class stores its values ordered in vector,
    which means that any insertion or deletion of elements takes linear time O(N),
    just like in case of `std::vector`. This is a necessary evil. But for that, we
    gain almost three times less memory usage per element, more processor cache friendly
    storage, and random access iterators. Take a look at step 5, `5.1`, where we were
    getting the distance between two iterators returned by calls to the `lower_bound`
    member functions. Getting distance with a flat set takes constant time O(1), while
    the same operation on iterators of `std::set` takes linear time O(N). In the case
    of `5.1`, getting the distance using `std::set` would be 400 times slower than
    getting the distance for flat set containers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::flat_set` 类将它的值有序地存储在向量中，这意味着任何元素的插入或删除都花费线性时间 O(N)，就像在
    `std::vector` 的情况下。这是一个必要的恶。但为此，我们几乎每个元素节省了三倍多的内存使用，更友好的处理器缓存存储，以及随机访问迭代器。看看第
    5 步，`5.1`，在那里我们获取由 `lower_bound` 成员函数调用返回的两个迭代器之间的距离。使用平面集合获取距离需要常数时间 O(1)，而同样操作
    `std::set` 的迭代器需要线性时间 O(N)。在 `5.1` 的情况下，使用 `std::set` 获取距离会比获取平面集合容器的距离慢 400 倍。'
- en: Back to step 3\. Without reserving memory, insertion of elements can become
    at times slower and less memory efficient. The `std::vector` class allocates the
    required chunk of memory and the in-place construct elements on that chunk. When
    we insert some element without reserving the memory, there is a chance that there
    is no free space remaining on the preallocated chunk of memory, so `std::vector`
    will allocate twice the chunk of memory that was allocated previously. After that,
    `std::vector` will copy or move elements from the first chunk to the second, delete
    elements of the first chunk, and deallocate the first chunk. Only after that,
    insertion will occur. Such copying and deallocation may occur multiple times during
    insertions, dramatically reducing the speed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第3步。如果不预留内存，插入元素有时会变慢且内存效率较低。`std::vector`类分配所需的内存块，并在该块上就地构造元素。当我们不预留内存而插入一些元素时，可能会出现预分配的内存块上没有剩余空间的情况，因此`std::vector`将分配两倍于之前分配的内存块。之后，`std::vector`将复制或移动第一个块中的元素到第二个块，删除第一个块中的元素，并释放第一个块的内存。只有在那时，插入才会发生。这种复制和释放内存可能会在插入过程中多次发生，从而大大降低速度。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If you know the count of elements that `std::vector` or any flat container must
    store, reserve the space for those elements before insertion. There are no exceptions
    from that rule!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道`std::vector`或任何扁平容器必须存储的元素数量，在插入之前为这些元素预留空间。这个规则没有例外！
- en: Step 4 is trivial, we are inserting elements here. Note that we are inserting
    ordered elements. This is not required, but recommended to speedup insertion.
    Inserting elements at the end of `std::vector` is much more cheaper than in the
    middle or at the beginning.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步很简单，我们在这里插入元素。请注意，我们正在插入有序元素。这不是必需的，但推荐这样做以加快插入速度。在`std::vector`的末尾插入元素比在中间或开头插入要便宜得多。
- en: In step 5, `5.2` and `5.3` do not differ much, except of their execution speed.
    Rules for erasing elements are pretty much the same as for inserting them, so
    see the preceding paragraph for explanations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，`5.2`和`5.3`没有太大区别，除了它们的执行速度。删除元素的规定与插入元素的规定几乎相同，所以请参阅前面的段落以获取解释。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Maybe I'm telling you trivial things about containers, but I have seen some
    very popular products that use features of C++11, have an insane amount of optimizations
    and lame usage of STL containers, especially `std::vector`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我在告诉你关于容器的一些简单事情，但我看到一些非常流行的产品使用了C++11的特性，有大量的优化，以及STL容器的糟糕使用，特别是`std::vector`。
- en: In step 5, `5.4` shows you that the `std::lower_bound` function will work faster
    with `boost::container::flat_set` than with `std::set`, because of random access
    iterators.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，`5.4`展示了`std::lower_bound`函数使用`boost::container::flat_set`比使用`std::set`要快，因为具有随机访问迭代器。
- en: In step 5, `5.5` also shows you the benefit of random access iterators. Note
    that we did not use the `std::find` function here. This is because that function
    takes linear time O(N), while the member `find` functions take logarithmic time
    O(log(N)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，`5.5`也展示了随机访问迭代器的优势。请注意，我们在这里没有使用`std::find`函数。这是因为该函数需要线性时间O(N)，而成员`find`函数需要对数时间O(log(N))。
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When should we use flat containers, and when should we use usual ones? Well,
    it''s up to you, but here is a list of differences from the official documentation
    of `Boost.Container` that will help you to decide:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在什么时候使用扁平容器，什么时候使用常规容器？嗯，这取决于你，但这里有一个从`Boost.Container`官方文档中摘录的差异列表，这将帮助你做出决定：
- en: Faster lookup than standard associative containers
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器查找更快
- en: Much faster iteration than standard associative containers
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器迭代得更快
- en: Less memory consumption for small objects (and for large objects if `shrink_to_fit`
    is used)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小对象（如果使用`shrink_to_fit`则对于大对象）内存消耗更少
- en: Improved cache performance (data is stored in contiguous memory)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善缓存性能（数据存储在连续内存中）
- en: Nonstable iterators (iterators are invalidated when inserting and erasing elements)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非稳定迭代器（在插入和删除元素时迭代器会被无效化）
- en: Non-copyable and non-movable value types can't be stored
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法存储不可复制和不可移动的值类型
- en: Weaker exception safety than standard associative containers (copy/move constructors
    can throw an exception when shifting values in erasures and insertions)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器具有较弱的异常安全性（复制/移动构造函数在删除和插入时移动值可能会抛出异常）
- en: Slower insertion and erasure than standard associative containers (specially
    for non-movable types)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器插入和删除更慢（特别是对于不可移动的类型）
- en: C++11 unfortunately has no flat containers. Flat containers from Boost are fast,
    have a lot of optimizations, and do not use virtual functions. Classes from `Boost.Containers`
    have support of rvalue reference emulation via `Boost.Move` so you are free to
    use them even on C++03 compilers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++11没有扁平容器。Boost中的扁平容器速度快，有很多优化，并且不使用虚函数。`Boost.Containers`中的类通过`Boost.Move`支持rvalue引用的模拟，因此您可以在C++03编译器上自由使用它们。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Getting the benefits of single-linked list and memory pool* recipe
    for more information about `Boost.Container`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Container`的更多信息，请参考*获取单链表和内存池的好处*配方。
- en: The recipe *Using the C++11 move emulation* in [Chapter 1](ch01.html "Chapter 1. Starting
    to Write Your Application"), *Starting to Write Your Application*, will give you
    the basics of emulation rvalue references on C++03 compatible compilers.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始编写您的应用程序")中，*使用C++11移动模拟*的配方，将向您介绍如何在C++03兼容的编译器上实现仿值引用的基础知识。
- en: The official documentation of `Boost.Container` contains a lot of useful information
    about `Boost.Container` and full reference of each class. Read about it at [http://www.boost.org/doc/libs/1_53_0/doc/html/container.html](http://www.boost.org/doc/libs/1_53_0/doc/html/container.html).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Container`的官方文档包含了关于`Boost.Container`的大量有用信息以及每个类的完整参考。请访问[http://www.boost.org/doc/libs/1_53_0/doc/html/container.html](http://www.boost.org/doc/libs/1_53_0/doc/html/container.html)了解更多信息。'
