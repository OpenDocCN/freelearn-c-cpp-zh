<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Interactive 3D Data Visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Interactive 3D Data Visualization</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a virtual camera for 3D rendering</li><li class="listitem" style="list-style-type: disc">Creating a 3D plot with perspective rendering</li><li class="listitem" style="list-style-type: disc">Creating an interactive environment with GLFW</li><li class="listitem" style="list-style-type: disc">Rendering a volumetric dataset – MCML simulation</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Introduction</h1></div></div></div><p>OpenGL is <a id="id52" class="indexterm"/>a very attractive platform for creating dynamic, highly interactive tools for visualizing data in 3D. In this chapter, we will build upon the fundamental concepts discussed in the previous chapter and extend our demos to incorporate more sophisticated OpenGL features for 3D rendering. To enable 3D visualization, we will first introduce the basic steps of setting up a virtual camera in OpenGL. In addition, to create more interactive demos, we will introduce the use of GLFW callback functions for handling user inputs. Using these concepts, we will illustrate how to create an interactive 3D plot with perspective rendering using OpenGL. Finally, we will demonstrate how to render a 3D volumetric dataset generated from a Monte Carlo simulation of light transport in biological tissue. By the end of this chapter, readers will be able to visualize data in 3D with perspective rendering and interact with the environment dynamically through user inputs for a wide range of applications.</p></div></div>
<div class="section" title="Setting up a virtual camera for 3D rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Setting up a virtual camera for 3D rendering</h1></div></div></div><p>Rendering a 3D<a id="id53" class="indexterm"/> scene is similar to taking a photograph with a digital camera in the real world. The steps that are taken to create a photograph can also be applied in OpenGL.</p><p>For example, you can move the camera from one position to another and adjust the viewpoint freely in space, which is known as <a id="id54" class="indexterm"/>
<span class="strong"><strong>viewing transformation</strong></span>. You can also adjust the position and orientation of the the object of interest in the scene. However, unlike in the real world, in the virtual world you can position the object at any orientation freely without any physical constraints,<a id="id55" class="indexterm"/> termed as <span class="strong"><strong>modeling transformation</strong></span>. Finally, we can exchange camera lenses to adjust the zoom and create different perspectives the process is called <a id="id56" class="indexterm"/>
<span class="strong"><strong>projection transformation</strong></span>.</p><p>When you take a photo applying the viewing and modeling transformation, the digital camera takes the information and creates an image on your screen. This process<a id="id57" class="indexterm"/> is called <span class="strong"><strong>rasterization</strong></span>.</p><p>These sets of <a id="id58" class="indexterm"/>matrices—encompassing the viewing transformation, modeling transformation, and projection transformation—are the fundamental elements we can adjust at run-time, which allows us to create an interactive and dynamic rendering of the scene. To get started, we will first look into the setup of the camera matrix, and how we can create a scene with different perspectives.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>Getting ready</h2></div></div></div><p>The source code in this chapter is based on the final demo from the previous chapter. Basically, we will be modifying the previous implementation by setting up a camera model using a perspective matrix. In the upcoming chapters, we will explore the use of the <a id="id59" class="indexterm"/>
<span class="strong"><strong>OpenGL Shading Language</strong></span> (<span class="strong"><strong>GLSL</strong></span>) to enable even more complex rendering techniques and higher performance.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>How to do it...</h2></div></div></div><p>Let's get started on the first new requirement for handling perspective transformation in OpenGL. Since the camera parameters depend on the window size, we need to first implement a callback function that handles a window resize event and updates the matrices accordingly:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the function prototype for the callback function:<div class="informalexample"><pre class="programlisting">void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{</pre></div></li><li class="listitem">Preset the camera parameters: the vertical <a id="id60" class="indexterm"/><span class="strong"><strong>field of view angle</strong></span> (<span class="strong"><strong>fovY</strong></span>), the distance to the <span class="strong"><strong>Near clipping plane</strong></span> (front), the distance to <span class="strong"><strong>Far clipping plane</strong></span> (back), and the screen aspect ratio (<span class="strong"><strong>width</strong></span>/<span class="strong"><strong>height</strong></span>):<div class="mediaobject"><img src="graphics/9727OS_03_01.jpg" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting">  const float fovY = 45.0f;
  const float front = 0.1f;
  const float back = 128.0f;
  float ratio = 1.0f;
  if (height &gt; 0)
    ratio = (float) width / (float) height;</pre></div></li><li class="listitem">Set up <a id="id61" class="indexterm"/>the viewport of the virtual camera (using the window size):<div class="informalexample"><pre class="programlisting">  glViewport(0, 0, width, height);</pre></div></li><li class="listitem">Specify the matrix mode as <code class="literal">GL_PROJECTION</code> and allow subsequent matrix operations to be applied to the projection matrix stack:<div class="informalexample"><pre class="programlisting">  glMatrixMode(GL_PROJECTION);</pre></div></li><li class="listitem">Load the identity matrix to the current matrix (that is, reset the matrix to its default state):<div class="informalexample"><pre class="programlisting">  glLoadIdentity();</pre></div></li><li class="listitem">Set up the perspective projection matrix for the virtual camera:<div class="informalexample"><pre class="programlisting">  gluPerspective(fovY, ratio, front, back);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>How it works...</h2></div></div></div><p>The purpose of the <code class="literal">framebuffer_size_callback</code> function is to handle callback events from the GLFW library. Upon resizing the window, an event will be captured and the callback function provides a mechanism to update the virtual camera parameters accordingly. One important problem is that changing the aspect ratio of the screen can introduce distortion if we do not adjust our virtual camera rendering parameters appropriately. Therefore, the <code class="literal">update</code> function also calls the <code class="literal">glViewport</code> function to ensure that the graphic is rendered onto the new viewable area.</p><p>Furthermore, imagine<a id="id62" class="indexterm"/> we are taking a photo of a scene with a camera physically in the real world. The <code class="literal">gluPerspective</code> function basically controls the camera lens' zoom (that is, the field of view angle) as well as the camera sensor (that is, the image plane) aspect ratio. One major difference between the virtual and real camera is the concept of a near clipping and far clipping plane (front and back variables) that limits the viewable area of the rendered image. These constraints are related to more advanced topics (the depth buffer and depth testing) and how the graphical engine works with a virtual 3D scene. One rule of thumb is, we should never set an unnecessarily large value as it will affect the precision of the depth testing result, which can lead to z-fighting issue. <span class="strong"><strong>Z-fighting</strong></span> <a id="id63" class="indexterm"/>is a phenomenon that occurs when objects share very similar depth values and the precision of the depth value is not sufficient to resolve the ambiguity (due to precision loss in the floating-point representation during the 3D rendering process). Setting a higher resolution depth buffer, or reducing the distance between the clipping planes, is often the simplest way to mitigate such problems.</p><p>The sample code provides perspective rendering of a scene that resembles how the human eye sees the world. For example, an object will appear larger if it is closer to the camera and smaller if it is farther away. This allows for a more realistic view of a scene. On the other hand, by controlling the field of view angle, we can exaggerate perspective distortion, similar to capturing a scene with an ultra-wide angle lens.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/>There's more...</h2></div></div></div><p>Alternatively, we can set up the camera with the <code class="literal">glFrustum()</code> function by replacing the <code class="literal">gluPerspective()</code> function with the following code:</p><div class="informalexample"><pre class="programlisting">  const double DEG2RAD = 3.14159265 / 180;
  // tangent of half fovY
  double tangent = tan(fovY/2 * DEG2RAD);  
  // half height of near plane
  double height_f = front * tangent;     
  // half width of near plane
  double width_f = height_f * ratio;   

  //Create the projection matrix based on the near clipping 
  //plane and the location of the corners
  glFrustum(-width_f, width_f, -height_f, height_f, front, back);
}</pre></div><p>The <code class="literal">glFrustum</code> function takes the corners of the near clipping and far clipping planes to construct the projective matrix. Fundamentally, there is no difference between the <code class="literal">gluPerspective</code> and <code class="literal">glFrustum</code> functions, so they are interchangeable.</p><p>As we can see, the virtual <a id="id64" class="indexterm"/>camera in OpenGL can be updated upon changes to the screen frame buffer (window size) and these event updates are captured with the callback mechanism of the GLFW library. Of course, we can also handle other events such as keyboard and mouse inputs. Further details on how to handle additional events will be discussed later. In the next section, let's implement the rest of the demo to create our first 3D plot with perspective rendering.</p></div></div>
<div class="section" title="Creating a 3D plot with perspective rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Creating a 3D plot with perspective rendering</h1></div></div></div><p>In the<a id="id65" class="indexterm"/> previous chapter, we showed a heat map of a 2D Gaussian distribution with varying standard deviation over time. Now, we will <a id="id66" class="indexterm"/>continue with more advanced rendering of the same dataset in 3D and demonstrate the effectiveness of visualizing multi-dimensional data with OpenGL. The code base from the previous chapter will be modified to enable 3D rendering.</p><p>Instead of rendering the 2D Gaussian distribution function on a plane, we take the output of the Gaussian function <span class="inlinemediaobject"><img src="graphics/9727OS_03_13.jpg" alt="Creating a 3D plot with perspective rendering"/></span> as the z (height) value as follows:</p><div class="mediaobject"><img src="graphics/9727OS_03_20.jpg" alt="Creating a 3D plot with perspective rendering"/></div><p>Here <span class="strong"><strong>A</strong></span> is the amplitude of the distribution centered at <span class="inlinemediaobject"><img src="graphics/9727OS_03_21.jpg" alt="Creating a 3D plot with perspective rendering"/></span>, and <span class="inlinemediaobject"><img src="graphics/9727OS_03_12.jpg" alt="Creating a 3D plot with perspective rendering"/></span> are the standard deviations (spread) of the distribution in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions. In our example, we will vary the spread of the distribution over time to change its shape in 3D. Additionally, we will apply a heat map to each vertex based on the height for better visualization effect.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec69"/>Getting ready</h2></div></div></div><p>With the camera <a id="id67" class="indexterm"/>set up using the projection model, we can render our graph in 3D with the desired effects by changing some of the virtual camera parameters such as the field of view angle for perspective distortion as well as the rotation angles for different viewing angles. To reduce<a id="id68" class="indexterm"/> coding complexity, we will re-use the <code class="literal">draw2DHeatMap</code> and <code class="literal">gaussianDemo</code> functions implemented in <a class="link" href="ch02.html" title="Chapter 2. OpenGL Primitives and 2D Data Visualization">Chapter 2</a>, <span class="emphasis"><em>OpenGL Primitives and 2D Data Visualization</em></span> with minor modifications. The rendering techniques will be based on the OpenGL primitives described in the previous chapter.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How to do it...</h2></div></div></div><p>Let's modify the final demo in <a class="link" href="ch02.html" title="Chapter 2. OpenGL Primitives and 2D Data Visualization">Chapter 2</a>, <span class="emphasis"><em>OpenGL Primitives and 2D Data Visualization</em></span> (<code class="literal">main_gaussian_demo.cpp</code> in the code package) to enable perspective rendering in 3D. The overall code structure is provided here to orient readers first and major changes will be discussed in smaller blocks sequentially:</p><div class="informalexample"><pre class="programlisting">#include &lt;GLFW/glfw3.h&gt;
...

// Window size
const int WINDOWS_WIDTH = 1280;
const int WINDOWS_HEIGHT = 720;

// NEW: Callback functions and helper functions for 3D plot
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void draw2DHeatMap(const Data *data, int num_points);
void gaussianDemo(float sigma);
...

int main(void)
{
  GLFWwindow* window;
  int width, height;
  if (!glfwInit()){
    exit(EXIT_FAILURE);
  }
  window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, "Chapter 3: 3D Data Plotting", NULL, NULL);
  if (!window){
    glfwTerminate();
    exit(EXIT_FAILURE);
  }
  glfwMakeContextCurrent(window);
  glfwSwapInterval(1);
  // NEW: Callback functions
  ...

  //enable anti-aliasing
  glEnable(GL_BLEND);
  //smooth the points
  glEnable(GL_LINE_SMOOTH);
  //smooth the lines
  glEnable(GL_POINT_SMOOTH);
  glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
  glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
  //needed for alpha blending
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_ALPHA_TEST) ;
  // NEW: Initialize parameters for perspective rendering
  ...
  while (!glfwWindowShouldClose(window))
  {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    // NEW: Perspective rendering
    ...
  }
  glfwDestroyWindow(window);
  glfwTerminate();
  exit(EXIT_SUCCESS);
}</pre></div><p>With the<a id="id69" class="indexterm"/> preceding framework in mind, inside the <code class="literal">main</code> function<a id="id70" class="indexterm"/> let's add the new <code class="literal">callback</code> function for handling window resizing implemented in the previous section:</p><div class="informalexample"><pre class="programlisting">glfwGetFramebufferSize(window, &amp;width, &amp;height);
framebuffer_size_callback(window, width, height);</pre></div><p>Let's define several global variables and initialize them for perspective rendering, including the zoom level (<code class="literal">zoom</code>) and rotation angles around the <span class="emphasis"><em>x</em></span> (<code class="literal">beta</code>) and <span class="emphasis"><em>z</em></span> (<code class="literal">alpha</code>) axes, respectively:</p><div class="informalexample"><pre class="programlisting">GLfloat alpha=210.0f, beta=-70.0f, zoom=2.0f;</pre></div><p>In addition, outside<a id="id71" class="indexterm"/> the <code class="literal">main</code> loop, let's initialize some parameters for rendering the Gaussian distribution, including the standard deviation (sigma), sign, and step size for dynamically changing the function over time:</p><div class="informalexample"><pre class="programlisting">float sigma = 0.1f;
float sign = 1.0f;
float step_size = 0.01f;</pre></div><p>In the <code class="literal">while</code> loop, we <a id="id72" class="indexterm"/>perform the following transformations to render the Gaussian function in 3D:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Specify the matrix mode as <code class="literal">GL_MODELVIEW</code> to allow subsequent matrix operations to be applied to the <code class="literal">MODELVIEW</code> matrix stack:<div class="informalexample"><pre class="programlisting">glMatrixMode(GL_MODELVIEW);</pre></div></li><li class="listitem">Perform the translation and rotation of the object:<div class="informalexample"><pre class="programlisting">glLoadIdentity();
glTranslatef(0.0, 0.0, -2.0);
// rotate by beta degrees around the x-axis
glRotatef(beta, 1.0, 0.0, 0.0);
// rotate by alpha degrees around the z-axis
glRotatef(alpha, 0.0, 0.0, 1.0);</pre></div></li><li class="listitem">Draw the origin (with the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes) and the Gaussian function in 3D. Dynamically plot a series of Gaussian functions with varying sigma values over time and reverse the sign once a certain threshold is reached:<div class="informalexample"><pre class="programlisting">drawOrigin();
sigma=sigma+sign*step_size;
if(sigma&gt;1.0f){
  sign = -1.0f;
}
if(sigma&lt;0.1){
  sign = 1.0f;
}
gaussianDemo(sigma);</pre></div><p>For handling each of the preceding drawing tasks, we implement the origin visualizer, Guassian function generator, and 3D point visualizer in separate functions.</p></li></ol></div><p>To visualize the origin, implement the following drawing function:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the function prototype:<div class="informalexample"><pre class="programlisting">void drawOrigin(){</pre></div></li><li class="listitem">Draw the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes<a id="id73" class="indexterm"/> in red, green, and blue, respectively:<div class="informalexample"><pre class="programlisting">  glLineWidth(4.0f);
  glBegin(GL_LINES);
  float transparency = 0.5f;

  //draw a red line for the x-axis
  glColor4f(1.0f, 0.0f, 0.0f, transparency);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glColor4f(1.0f, 0.0f, 0.0f, transparency);
  glVertex3f(0.3f, 0.0f, 0.0f);

  //draw a green line for the y-axis
  glColor4f(0.0f, 1.0f, 0.0f, transparency);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glColor4f(0.0f, 1.0f, 0.0f, transparency);
  glVertex3f(0.0f, 0.0f, 0.3f);

  //draw a blue line for the z-axis
  glColor4f(0.0f, 0.0f, 1.0f, transparency);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glColor4f(0.0f, 0.0f, 1.0f, transparency);
  glVertex3f(0.0f, 0.3f, 0.0f);
  glEnd();
}</pre></div></li></ol></div><p>For the<a id="id74" class="indexterm"/> implementation of the Gaussian function demo, we have broken down the problem into two parts: a Gaussian data generator and a heat map visualizer function with point drawing. Together with 3D rendering and the heat map, we can now clearly see the shape of the Gaussian distribution and how the samples animate and move in space over time:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate the Gaussian distribution:<div class="informalexample"><pre class="programlisting">void gaussianDemo(float sigma){
  const int grid_x = 400;
  const int grid_y = 400;
  const int num_points = grid_x*grid_y;
  Data *data=(Data*)malloc(sizeof(Data)*num_points);
  int data_counter=0;
  
  //standard deviation
  const float sigma2=sigma*sigma;
  //amplitude
  const float sigma_const = 10.0f*(sigma2*2.0f*(float)M_PI);

  for(float x = -grid_x/2.0f; x&lt;grid_x/2.0f; x+=1.0f){
   for(float y = -grid_y/2.0f; y&lt;grid_y/2.0f; y+=1.0f){
      float x_data = 2.0f*x/grid_x;
      float y_data = 2.0f*y/grid_y;
      //Set the mean to 0
      float z_data = exp(-0.5f*(x_data*x_data)/(sigma2) -0.5f*(y_data*y_data)/(sigma2)) /sigma_const;
      data[data_counter].x = x_data;
      data[data_counter].y = y_data;
      data[data_counter].z = z_data;
      data_counter++;
    }
  }
  draw2DHeatMap(data, num_points);
  free(data);
}</pre></div></li><li class="listitem">Next, implement <a id="id75" class="indexterm"/>the <code class="literal">draw2DHeatMap</code> function<a id="id76" class="indexterm"/> to visualize the result. Note that, unlike in <a class="link" href="ch02.html" title="Chapter 2. OpenGL Primitives and 2D Data Visualization">Chapter 2</a>, <span class="emphasis"><em>OpenGL Primitives and 2D Data Visualization</em></span>, we use the z value inside the <code class="literal">glVertex3f</code> function:<div class="informalexample"><pre class="programlisting">void draw2DHeatMap(const Data *data, int num_points){
  glPointSize(3.0f);
  glBegin(GL_POINTS);
  float transparency = 0.25f;
  //locate the maximum and minimum values in the dataset
  float max_value=-999.9f;
  float min_value=999.9f;
  for(int i=0; i&lt;num_points; i++){
    Data d = data[i];
    if(d.z &gt; max_value)
      max_value = d.z;
    if(d.z &lt; min_value)
      min_value = d.z;
  }
  float halfmax = (max_value + min_value) / 2;
  //display the result
  for(int i = 0; i&lt;num_points; i++){
    Data d = data[i];
    float value = d.z;
    float b = 1.0f - value/halfmax;
    float r = value/halfmax - 1.0f;
    if(b &lt; 0)
      b=0;
    if(r &lt; 0)
      r=0;
    float g = 1.0f - b - r;
    glColor4f(r, g, b, transparency);
    glVertex3f(d.x, d.y, d.z);
  }
  glEnd();
}</pre></div></li></ol></div><p>The rendered result<a id="id77" class="indexterm"/> is shown in the following <a id="id78" class="indexterm"/>screenshot. We can see that the transparency (alpha blending) allows us to see through the data points and provides a visually appealing result:</p><div class="mediaobject"><img src="graphics/9727OS_03_02.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How it works...</h2></div></div></div><p>This simple example demonstrates the use of perspective rendering as well as OpenGL transformation functions to rotate and translate the rendered objects in virtual space. As you can see, the overall code structure remains the same as in <a class="link" href="ch02.html" title="Chapter 2. OpenGL Primitives and 2D Data Visualization">Chapter 2</a>, <span class="emphasis"><em>OpenGL Primitives and 2D Data Visualization</em></span> and the major changes primarily include setting up the camera<a id="id79" class="indexterm"/> parameters for perspective rendering (inside the <code class="literal">framebuffer_size_callback</code> function) and performing the required transformations to render the Gaussian function in 3D (after setting the matrix mode to <code class="literal">GL_MODELVIEW</code>). Two very commonly used transformation functions to manipulate virtual objects include <code class="literal">glRotatef</code> and <code class="literal">glTranslatef</code>, which allow us to position objects at any orientation and position. These functions can significantly improve the dynamics of your own application, with very minimal cost in development and computation time since they are heavily optimized.</p><p>The <code class="literal">glRotatef</code> function <a id="id80" class="indexterm"/>takes four parameters: the rotation angle and three components of the direction vector <span class="emphasis"><em>(x, y, z)</em></span>, which define the axis of rotation. The function also replaces the current matrix with the product of the rotation matrix and the current matrix:</p><div class="mediaobject"><img src="graphics/9727OS_03_14.jpg" alt="How it works..."/></div><p>Here <span class="inlinemediaobject"><img src="graphics/9727OS_03_15.jpg" alt="How it works..."/></span> and <span class="inlinemediaobject"><img src="graphics/9727OS_03_16.jpg" alt="How it works..."/></span>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>There's more...</h2></div></div></div><p>One may ask, what if we would like to position two objects at different orientations and positions? What if we would like to position many parts in space relative to one another? The answer to these is to use the <code class="literal">glPushMatrix</code> and <code class="literal">glPopMatrix</code> functions to control the stack of transformation matrices. The concept behind this can get relatively complex for a model with a large number of parts and keeping a history of the state machine with many components can be tedious. To address this issue, we will look into newer versions of GLSL support (OpenGL 3.x and higher).</p></div></div>
<div class="section" title="Creating an interactive environment with GLFW"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Creating an interactive environment with GLFW</h1></div></div></div><p>In the <a id="id81" class="indexterm"/>previous two sections, we focused on <a id="id82" class="indexterm"/>the creation of 3D objects and on utilizing basic OpenGL rendering techniques with a virtual camera. Now, we are ready to incorporate user inputs, such as mouse and keyboard inputs, to enable more dynamic interactions using camera control features such as zoom and rotate. These features will be the fundamental building blocks for the upcoming applications and the code will be reused in later chapters.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>Getting ready</h2></div></div></div><p>The GLFW <a id="id83" class="indexterm"/>library provides a mechanism to handle user inputs from different environments. The event handlers are implemented as callback functions in C/C++, and, in the previous tutorials, we bypassed these options for the sake of simplicity. To get started, we first need to enable these callback functions and implement basic features to control the rendering parameters.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>How to do it...</h2></div></div></div><p>To handle keyboard inputs, we attach our own implementation of the <code class="literal">callback</code> functions back to the event handler of GLFW. We will perform the following operations in the <code class="literal">callback</code> function:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the following global variables (including a new variable called <code class="literal">locked</code> to track whether the mouse button is pressed down, as well as the angles of rotation and zoom level) that will be updated by the <code class="literal">callback</code> functions:<div class="informalexample"><pre class="programlisting">GLboolean locked = GL_FALSE;
GLfloat alpha=210.0f, beta=-70.0f, zoom=2.0f;</pre></div></li><li class="listitem">Define the keyboard <code class="literal">callback</code> function prototype:<div class="informalexample"><pre class="programlisting">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{</pre></div></li><li class="listitem">If we receive any event other than the key press event, ignore it:<div class="informalexample"><pre class="programlisting">  if (action != GLFW_PRESS)
    return;</pre></div></li><li class="listitem">Create a <code class="literal">switch</code> statement to handle each key press case:<div class="informalexample"><pre class="programlisting">  switch (key)
  {</pre></div></li><li class="listitem">If the <span class="emphasis"><em>Esc</em></span> key is pressed, exit the program:<div class="informalexample"><pre class="programlisting">    case GLFW_KEY_ESCAPE:
      glfwSetWindowShouldClose(window, GL_TRUE);
      break;</pre></div></li><li class="listitem">If the space bar is pressed, start or stop the animation by toggling the variable:<div class="informalexample"><pre class="programlisting">    case GLFW_KEY_SPACE:
      freeze=!freeze;
      break;</pre></div></li><li class="listitem">If the <a id="id84" class="indexterm"/>direction keys (up, down, left, and right) are pressed, update the variables that control the angles of rotation for the rendered object:<div class="informalexample"><pre class="programlisting">    case GLFW_KEY_LEFT:
      alpha += 5.0f;
      break;
    case GLFW_KEY_RIGHT:
      alpha -= 5.0f;
      break;
    case GLFW_KEY_UP:
      beta -= 5.0f;
      break;
    case GLFW_KEY_DOWN:
      beta += 5.0f;
      break;</pre></div></li><li class="listitem">Lastly, if <a id="id85" class="indexterm"/>the <span class="emphasis"><em>Page Up</em></span> or <span class="emphasis"><em>Page Down</em></span> keys are pressed, zoom in and out from the object by updating the <code class="literal">zoom</code> variable:<div class="informalexample"><pre class="programlisting">    case GLFW_KEY_PAGE_UP:
      zoom -= 0.25f;
      if (zoom &lt; 0.0f)
        zoom = 0.0f;
        break;
    case GLFW_KEY_PAGE_DOWN:
      zoom += 0.25f;
      break;
      default:
      break;
  }
}</pre></div></li></ol></div><p>To handle mouse click events, we implement another <code class="literal">callback</code> function similar to the one for the keyboard. The mouse click event is rather simple as there is only a limited set of buttons available:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the mouse press <code class="literal">callback</code> function prototype:<div class="informalexample"><pre class="programlisting">void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{</pre></div></li><li class="listitem">Ignore <a id="id86" class="indexterm"/>all inputs except for the left click event for simplicity:<div class="informalexample"><pre class="programlisting">  if (button != GLFW_MOUSE_BUTTON_LEFT)
    return;</pre></div></li><li class="listitem">Toggle the <code class="literal">lock</code> variable to store the mouse hold event. The <code class="literal">lock</code> variable will be used to determine whether the mouse movement is used for rotating the object:<div class="informalexample"><pre class="programlisting">  if (action == GLFW_PRESS)
  {
    glfwSetInputMode(window, GLFW_CURSOR,   GLFW_CURSOR_DISABLED);
    locked = GL_TRUE;
  }
  else
  {
    locked = GL_FALSE;
    glfwSetInputMode(window, GLFW_CURSOR,GLFW_CURSOR_NORMAL);
  }
}</pre></div></li></ol></div><p>For handling <a id="id87" class="indexterm"/>mouse movement events, we need to create another <code class="literal">callback</code> function. The <code class="literal">callback</code> function for mouse movement takes the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates from the window instead of unique key inputs:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">callback</code> function prototype that takes in the mouse coordinates:<div class="informalexample"><pre class="programlisting">void cursor_position_callback(GLFWwindow* window, double x, double y)
{</pre></div></li><li class="listitem">Upon mouse press and mouse movement, we update the rotation angles of the object with the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of the mouse:<div class="informalexample"><pre class="programlisting">  //if the mouse button is pressed
  if (locked)
  {
    alpha += (GLfloat) (x - cursorX) / 10.0f;
    beta += (GLfloat) (y - cursorY) / 10.0f;
  }
  //update the cursor position
  cursorX = (int) x;
  cursorY = (int) y;
}</pre></div></li></ol></div><p>Finally, we will<a id="id88" class="indexterm"/> implement the mouse scroll callback function, which allows users to scroll up and down to zoom in and zoom out of the object.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">callback</code> function prototype that captures the <code class="literal">x</code> and <code class="literal">y</code> scroll variables:<div class="informalexample"><pre class="programlisting">void scroll_callback(GLFWwindow* window, double x, double y)
{</pre></div></li><li class="listitem">Take the y parameter (up and down scroll) and update the zoom variable:<div class="informalexample"><pre class="programlisting">  zoom += (float) y / 4.0f;
  if (zoom &lt; 0.0f)
    zoom = 0.0f;
}</pre></div></li></ol></div><p>With all of<a id="id89" class="indexterm"/> the <code class="literal">callback</code> functions implemented, we are now ready to link these functions to the GLFW library event handlers. The GLFW library provides a platform-independent API for handling each of these events, so the same code will run in Windows, Linux, and Mac OS X seamlessly.</p><p>To integrate the callbacks with the GLFW library, call the following functions in the <code class="literal">main</code> function:</p><div class="informalexample"><pre class="programlisting">//keyboard input callback
glfwSetKeyCallback(window, key_callback);

//framebuffer size callback  
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

//mouse button callback
glfwSetMouseButtonCallback(window, mouse_button_callback);

//mouse movement callback
glfwSetCursorPosCallback(window, cursor_position_callback);

//mouse scroll callback
glfwSetScrollCallback(window, scroll_callback);</pre></div><p>The end result is an interactive interface that allows the user to control the rendering object freely in space. First, when the user scrolls the mouse (see the following screenshots), we translate the object forward or backward. This creates the visual perception that <a id="id90" class="indexterm"/>the object is zoomed in or zoomed out of the camera:</p><div class="mediaobject"><img src="graphics/9727OS_03_03.jpg" alt="How to do it..."/></div><p>Here is <a id="id91" class="indexterm"/>another screenshot at a different zoom level:</p><div class="mediaobject"><img src="graphics/9727OS_03_04.jpg" alt="How to do it..."/></div><p>These simple yet powerful techniques allow users to manipulate virtual objects in real-time and can be<a id="id92" class="indexterm"/> extremely useful when visualizing complex datasets. Additionally, we can rotate the object at different angles by holding the mouse button and dragging the object in various directions. The screenshots below show how we can render the graph at any arbitrary <a id="id93" class="indexterm"/>angle to better understand the data distribution.</p><p>Here is a screenshot showing the side view of the Gaussian function:</p><div class="mediaobject"><img src="graphics/9727OS_03_05.jpg" alt="How to do it..."/></div><p>Here is a screenshot showing the Gaussian function from the top:</p><div class="mediaobject"><img src="graphics/9727OS_03_06.jpg" alt="How to do it..."/></div><p>Finally, here is a<a id="id94" class="indexterm"/> screenshot showing<a id="id95" class="indexterm"/> the Gaussian function from the bottom:</p><div class="mediaobject"><img src="graphics/9727OS_03_07.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>How it works...</h2></div></div></div><p>This sample code illustrates the basic interface needed to build interactive applications that are highly portable<a id="id96" class="indexterm"/> across multiple platforms<a id="id97" class="indexterm"/> using OpenGL and the GLFW library. The use of <code class="literal">callback</code> functions in the GLFW library allows non-blocking calls that run in parallel with the rendering engine. This concept is particularly useful since input devices such as the mouse, keyboard, and joysticks all have different input rates and latency. These <code class="literal">callback</code> functions allow for asynchronous execution without blocking the main rendering loop.</p><p>The <code class="literal">glfwSetKeyCallback</code>, <code class="literal">glfwSetFramebufferSizeCallback</code>, <code class="literal">glfwSetScrollCallback</code>, <code class="literal">glfwSetMouseBcuttonCallback</code>, and <code class="literal">glfwSetCursorPosCallback</code> functions provide controls over the mouse buttons and scrolling wheel, keyboard inputs, and window resizing events. These are only some of the many handlers we can implement with the GLFW library support. For example, we can further extend the error handling capabilities by adding additional <code class="literal">callback</code> functions. Also, we can handle window closing and opening events, thereby enabling even more sophisticated interfaces with multiple windows. With the examples provided thus far, we have introduced the basics of how to create interactive interfaces with relatively simple API calls.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec76"/>See also</h2></div></div></div><p>For complete coverage of GLFW library function calls, this website provides a comprehensive set of examples and documentation for all callback functions as well as the handling of inputs and other events: <a class="ulink" href="http://www.glfw.org/docs/latest/">http://www.glfw.org/docs/latest/</a>.</p></div></div>
<div class="section" title="Rendering a volumetric dataset &#x2013; MCML simulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Rendering a volumetric dataset – MCML simulation</h1></div></div></div><p>In this section, we<a id="id98" class="indexterm"/> will demonstrate the rendering of a 3D volumetric dataset generated from a Monte Carlo simulation of light transport in biological tissue, called <a id="id99" class="indexterm"/>
<span class="strong"><strong>Monte Carlo for multi-layered media</strong></span> (<span class="strong"><strong>MCML</strong></span>). For simplicity, the simulation output file is included with the code bundle for this chapter so that readers can directly run the demo without setting up <a id="id100" class="indexterm"/>the simulation code. The source code for the Monte Carlo simulation is described in detail in a series of publications listed in the <span class="emphasis"><em>See also</em></span> section and the GPU implementation is available online for interested readers (<a class="ulink" href="https://code.google.com/p/gpumcml/">https://code.google.com/p/gpumcml/</a>).</p><p>Light transport in biological tissue can be modeled with the <a id="id101" class="indexterm"/>
<span class="strong"><strong>radiative transport equation</strong></span> (<span class="strong"><strong>RTE</strong></span>), which has proven difficult to solve analytically for complex geometry. The time-dependent RTE can be expressed as:</p><div class="mediaobject"><img src="graphics/9727OS_03_17.jpg" alt="Rendering a volumetric dataset – MCML simulation"/></div><p>Here <span class="inlinemediaobject"><img src="graphics/9727OS_03_18.jpg" alt="Rendering a volumetric dataset – MCML simulation"/></span> is the<a id="id102" class="indexterm"/> radiance [<span class="emphasis"><em>W m<sup>−2</sup>sr<sup>−1</sup></em></span>] defined as the radiant power [<span class="emphasis"><em>W</em></span>] crossing an infinitesimal area at location <span class="emphasis"><em>r</em></span> perpendicular to the direction <span class="emphasis"><em>Ω</em></span> per unit solid angle, <span class="emphasis"><em>μ<sub>s</sub></em></span> is the scattering coefficient, <span class="emphasis"><em>μ<sub>a</sub></em></span> is the absorption coefficient, <span class="emphasis"><em>ν</em></span> is the speed of light, and <span class="inlinemediaobject"><img src="graphics/9727OS_03_19.jpg" alt="Rendering a volumetric dataset – MCML simulation"/></span> is the source term. To solve the RTE numerically, Wilson and Adam introduced the <a id="id103" class="indexterm"/>
<span class="strong"><strong>Monte Carlo</strong></span> (<span class="strong"><strong>MC</strong></span>) method, which is widely accepted as a gold-standard approach for photon migration modeling due to its accuracy and versatility (especially for complex tissue geometry).</p><p>The MC method <a id="id104" class="indexterm"/>is a statistical sampling technique that has been applied to a number of important problems in many different fields, ranging from radiation therapy planning in medicine to option pricing in finance. The name Monte Carlo is derived from the resort city in Monaco that is known for its casinos, among other attractions. As its name implies, the key feature of the MC method involves the exploitation of random chance (through the generation of random numbers with a particular probability distribution) to model the physical process in question.</p><p>In our case, we are interested in modeling photon propagation in biological tissue. The MCML algorithm provides an MC model of steady-state light transport in multi-layered media. In particular, we will simulate photon propagation in a homogeneous medium with a circular light source incident on the tissue surface in order to compute the light dose (absorbed energy) distribution. Such computations have a wide range of applications, including treatment planning for light therapies such as photodynamic therapy (this can be considered a light-activated chemotherapy for cancer).</p><p>Here, we demonstrate how to integrate our code base for displaying volumetric data with OpenGL rendering functions. We will take advantage of techniques such as alpha blending, perspective rendering, and heat map rendering. Together with the GLFW interface for capturing user inputs, we can create an interactive visualizer that can display a large volumetric dataset in real-time and control a slicer that magnifies a plane of data points within the volumetric dataset using a few simple key inputs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec77"/>Getting ready</h2></div></div></div><p>The simulation result is stored in an ASCII text file that contains a 3D matrix. Each value in the matrix<a id="id105" class="indexterm"/> represents the absorbed photon energy density at some fixed position within the voxelized geometry. Here, we will provide a simple parser that extracts the simulation output matrix from the file and stores it in the local memory.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec78"/>How to do it...</h2></div></div></div><p>Let's get started by implementing the MCML data parser, the jet color scheme heat map generator, as well as the slicer in OpenGL:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Take the data from the simulation output text file and store it in floating-point arrays:<div class="informalexample"><pre class="programlisting">#define MCML_SIZE_X 50
#define MCML_SIZE_Y 50
#define MCML_SIZE_Z 200
float mcml_data[MCML_SIZE_X][MCML_SIZE_Y][MCML_SIZE_Z];
Vertex mcml_vertices[MCML_SIZE_X][MCML_SIZE_Y][MCML_SIZE_Z];
float max_data, min_data;
int slice_x = 0, slice_z = 0, slice_y = 0;
float point_size=5.0f;

//load the data from a text file
void loadMCML(){
  FILE *ifp;
  //open the file for reading
  ifp = fopen("MCML_output.txt", "r");
  if (ifp == NULL) {
    fprintf(stderr, "ERROR: Can't open MCML Data file!\n");
    exit(1);
  }
  float data;
  float max=0, min=9999999;
  for(int x=0; x&lt;MCML_SIZE_X; x++){
    for(int z=0; z&lt;MCML_SIZE_Z; z++){
      for(int y=0; y&lt;MCML_SIZE_Y; y++){
        if (fscanf(ifp, "%f\n", &amp;data) == EOF){
          fprintf(stderr, "ERROR: Missing MCML Data file!\n");
          exit(1);
        }
        //store the log compressed data point
        data = log(data+1);
        mcml_data[x][y][z]=data;
        //find the max and min from the data set for heatmap
        if(data&gt;max){
          max=data;
        }
        if(data&lt;min){
          min=data;
        }
        //normalize the coordinates
        mcml_vertices[x][y][z].x=(float)(x-MCML_SIZE_X/2.0f)/MCML_SIZE_X;
        mcml_vertices[x][y][z].y=(float)(y-MCML_SIZE_Y/2.0f)/MCML_SIZE_Y;
        mcml_vertices[x][y][z].z=(float)(z-MCML_SIZE_Z/2.0f)/MCML_SIZE_Z*2.0f;
      }
    }
  }
  fclose(ifp);
  max_data = max;
  min_data = min;
  halfmax= (max+min)/2.0f;</pre></div></li><li class="listitem">Encode<a id="id106" class="indexterm"/> the simulation output values using a custom color map for display:<div class="informalexample"><pre class="programlisting">  //store the heat map representation of the data
  for(int z=0; z&lt;MCML_SIZE_Z; z++){
    for(int x=0; x&lt;MCML_SIZE_X; x++){
      for(int y=0; y&lt;MCML_SIZE_Y; y++){
        float value = mcml_data[x][y][z];
        COLOUR c = GetColour(value, min_data,max_data);
        mcml_vertices[x][y][z].r=c.r;
        mcml_vertices[x][y][z].g=c.g;
        mcml_vertices[x][y][z].b=c.b;
      }
    }
  }
}</pre></div></li><li class="listitem">Implement the heat map generator with the jet color scheme:<div class="informalexample"><pre class="programlisting">Color getHeatMapColor(float value, float min, float max)
{
  //remapping the value to the JET color scheme
  Color c = {1.0f, 1.0f, 1.0f}; // default value
  float dv;
  //clamp the data 
  if (value &lt; min)
    value = min;
  if (value &gt; max)
    value = max;
  range = max - min;
  //the first region (0%-25%)
  if (value &lt; (min + 0.25f * range)) {
    c.r = 0.0f;
    c.g = 4.0f * (value - min) / range;
  }
  //the second region of value (25%-50%)
  else if (value &lt; (min + 0.5f * range)) {
    c.r = 0.0f;
    c.b = 1.0f + 4.0f * (min + 0.25f * range - value) / range;
  }
  //the third region of value (50%-75%)
  else if (value &lt; (min + 0.75f * range)) {
    c.r = 4.0f * (value - min - 0.5f * range) / range;
    c.b = 0.0f;
  }
  //the fourth region (75%-100%)
  else {
    c.g = 1.0f + 4.0f * (min + 0.75f * range - value) / range;
    c.b = 0.0f;
  }
  return(c);
}</pre></div></li><li class="listitem">Draw all <a id="id107" class="indexterm"/>data points on screen with transparency enabled:<div class="informalexample"><pre class="programlisting">void drawMCMLPoints(){
  glPointSize(point_size);
  glBegin(GL_POINTS);
  for(int z=0; z&lt;MCML_SIZE_Z; z++){
    for(int x=0; x&lt;MCML_SIZE_X; x++){
      for(int y=0; y&lt;MCML_SIZE_Y; y++){
        glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.15f);
        glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);
      }
    }
  }
  glEnd();
}</pre></div></li><li class="listitem">Draw three <a id="id108" class="indexterm"/>slices of data points for cross-sectional visualization:<div class="informalexample"><pre class="programlisting">void drawMCMLSlices(){
  glPointSize(10.0f);
  glBegin(GL_POINTS);

  //display data on xy plane
  for(int x=0; x&lt;MCML_SIZE_X; x++){
    for(int y=0; y&lt;MCML_SIZE_Y; y++){
      int z = slice_z;
      glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);
      glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);
    }
  }

  //display data on yz plane
  for(int z=0; z&lt;MCML_SIZE_Z; z++){
    for(int y=0; y&lt;MCML_SIZE_Y; y++){
      int x = slice_x;
      glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);
      glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);
    }
  }

  //display data on xz plane
  for(int z=0; z&lt;MCML_SIZE_Z; z++){
    for(int x=0; x&lt;MCML_SIZE_X; x++){
      int y = slice_y;
      glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);
      glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);
    }
  }
  glEnd();
}</pre></div></li><li class="listitem">In addition, we <a id="id109" class="indexterm"/>need to update the <code class="literal">key_callback</code> function for moving the slices:<div class="informalexample"><pre class="programlisting">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
  if (action != GLFW_PRESS)
    return;
  switch (key)
  {
    case GLFW_KEY_ESCAPE:
      glfwSetWindowShouldClose(window, GL_TRUE);
      break;
    case GLFW_KEY_P:
      point_size+=0.5;
      break;
    case GLFW_KEY_O:
      point_size-=0.5;
      break;
    case GLFW_KEY_A:
      slice_y -=1;
      if(slice_y &lt; 0)
        slice_y = 0;
      break;
    case GLFW_KEY_D:
      slice_y +=1;
      if(slice_y &gt;= MCML_SIZE_Y-1)
        slice_y = MCML_SIZE_Y-1;
      break;
    case GLFW_KEY_W:
      slice_z +=1;
      if(slice_z &gt;= MCML_SIZE_Z-1)
        slice_z = MCML_SIZE_Z-1;
      break;
    case GLFW_KEY_S:
      slice_z -= 1;
      if (slice_z &lt; 0)
        slice_z = 0;
      break;
    case GLFW_KEY_E:
      slice_x -=1;
      if(slice_x &lt; 0)
        slice_x = 0;
      break;
    case GLFW_KEY_Q:
      slice_x +=1;
      if(slice_x &gt;= MCML_SIZE_X-1)
        slice_x = MCML_SIZE_X-1;
      break;
    case GLFW_KEY_PAGE_UP:
      zoom -= 0.25f;
      if (zoom &lt; 0.f)
        zoom = 0.f;
      break;
    case GLFW_KEY_PAGE_DOWN:
      zoom += 0.25f;
      break;
    default:
      break;
  }
}</pre></div></li><li class="listitem">Finally, to<a id="id110" class="indexterm"/> complete the demo, simply call the <code class="literal">drawMCMLPoints</code> and <code class="literal">drawMCMLSlices</code> functions inside the <code class="literal">main</code> loop using the same code structure for perspective rendering introduced in the previous demo for plotting a Gaussian function:<div class="informalexample"><pre class="programlisting">while (!glfwWindowShouldClose(window))
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef(0.0, 0.0, -zoom);
  glRotatef(beta, 1.0, 0.0, 0.0);
  glRotatef(alpha, 0.0, 0.0, 1.0);
  //disable depth test so we can render the points with blending
  glDisable(GL_DEPTH_TEST);
  drawMCMLPoints();
  //must enable this to ensure the slides are rendered in the right order 
  glEnable(GL_DEPTH_TEST);
  drawMCMLSlices();

  //draw the origin with the x,y,z axes for visualization
  drawOrigin();
  glfwSwapBuffers(window);
  glfwPollEvents();
}</pre></div></li></ol></div><p>The simulation results, representing<a id="id111" class="indexterm"/> the photon absorption distribution in a voxelized geometry, are displayed in 3D in the following screenshot. The light source illuminates the tissue surface (<span class="emphasis"><em>z=0</em></span> at the bottom) and propagates through the tissue (positive <span class="emphasis"><em>z</em></span> direction) that is modeled as an infinitely wide homogeneous medium. The photon absorption distribution follows the expected shape for a finite-sized, flat, and circular beam:</p><div class="mediaobject"><img src="graphics/9727OS_03_08.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec79"/>How it works...</h2></div></div></div><p>This demo illustrates how we can take a volumetric dataset generated from a Monte Carlo simulation (and, more generally, a volumetric dataset from any application) and render it with a highly interactive<a id="id112" class="indexterm"/> interface using OpenGL. The data parser takes an ASCII text file as input. Then, we turn the floating-point data into individual vertices that can fit into our rendering pipeline. Upon initialization, the variables <code class="literal">mcml_vertices</code> and <code class="literal">mcml_data</code> store the pre-computed heat map data as well as the position of each data point. The <code class="literal">parser</code> function also computes the maximum and minimum value in the dataset for heat map visualization. The <code class="literal">getHeatMapColor</code> function takes the simulation output value and maps it to a color in the jet color scheme. The algorithm basically defines a color spectrum and we remap the value based on its range.</p><p>In the following screenshot, we show a top view of the simulation result, which allows us to visualize the symmetry of the light distribution:</p><div class="mediaobject"><img src="graphics/9727OS_03_09.jpg" alt="How it works..."/></div><p>The <code class="literal">drawMCMLSlices</code> function takes a slice (that is, a plane) of data and renders the data points at the full opacity and a larger point size. This provides a useful and very common visualization method (especially in medical imaging) that allows users to examine the volumetric data in detail by moving the cross-sectional slices. As we can see in the following screenshot, we can shift the slicer in the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> directions to visualize the desired regions of interest:</p><div class="mediaobject"><img src="graphics/9727OS_03_10.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec80"/>There's more...</h2></div></div></div><p>This demo <a id="id113" class="indexterm"/>provides an example of real-time volumetric data visualization for rendering simulation data in an interactive 3D environment. The current implementation can be easily modified for a wide range of applications that require volumetric dataset visualization. Our approach provides an intuitive way to render complex 3D datasets with a heat map generator and a slicer as well as 3D perspective rendering techniques using OpenGL.</p><p>One important observation is that this demo required a significant number of <code class="literal">glVertex3f</code> calls, which can become a major performance bottleneck. To address this, in the upcoming chapters, we will explore more sophisticated ways to handle memory transfer and draw even more complex models with <a id="id114" class="indexterm"/>
<span class="strong"><strong>Vertex Buffer Objects</strong></span> (<span class="strong"><strong>VBOs</strong></span>), a memory buffer in your graphics card designed to store information about vertices. This will lead us towards fragment programs and custom vertex shader programs (that is, moving from OpenGL 2.0 to OpenGL 3.2 or higher). However, the simplicity of using classical OpenGL 2.0 calls is an important consideration if we are aiming for a short <a id="id115" class="indexterm"/>development cycle, minimal overhead, and backward compatibility with older hardware.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec81"/>See also</h2></div></div></div><p>For further information, please consult the following references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">E. Alerstam &amp; W. C. Y. Lo, T. Han, J. Rose, S. Andersson-Engels, and L. Lilge, "Next-generation acceleration and code optimization for light transport in turbid media using GPUs," <span class="emphasis"><em>Biomed. Opt. Express 1</em></span>, 658-675 (2010).</li><li class="listitem" style="list-style-type: disc">W. C. Y. Lo, K. Redmond, J. Luu, P. Chow, J. Rose, and L. Lilge, "Hardware acceleration of a Monte Carlo simulation for photodynamic therapy treatment planning," <span class="emphasis"><em>J. Biomed. Opt. 14</em></span>, 014019 (2009).</li><li class="listitem" style="list-style-type: disc">L. Wang, S. Jacques, and L. Zheng, "MCML - Monte Carlo modeling of light transport in multi-layered tissues," <span class="emphasis"><em>Comput. Meth. Prog. Biol. 47</em></span>, 131–146 (1995).</li><li class="listitem" style="list-style-type: disc">B. Wilson and G. Adam, "A Monte Carlo model for the absorption and flux distributions of light in tissue,"<span class="emphasis"><em> Med. Phys. 10</em></span>, 824 (1983).</li></ul></div></div></div></body></html>