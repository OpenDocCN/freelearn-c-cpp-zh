<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Introduction to Unreal C++"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Introduction to Unreal C++</h1></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Blueprints">Chapter 6</a>, <span class="emphasis"><em>Blueprints</em></span>, you learned about Blueprints, the visual scripting language of Unreal Engine 4. Now you will learn about C++, which can be used to create base classes for Blueprints. In this chapter, you will learn how to create a C++ project (we will use the <span class="strong"><strong>Third Person Template</strong></span>) and modify it to add support for health and health regeneration for<a id="id425" class="indexterm"/> our character. You will also learn how to expose variables and functions to Blueprint.</p><p>This chapter will be focused on writing C++ code using Visual Studio 2015 in Microsoft Windows.</p><div class="section" title="Setting up Visual Studio 2015"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec47"/>Setting up Visual Studio 2015</h1></div></div></div><p>With <a id="id426" class="indexterm"/>Unreal Engine 4.10, you will need Visual Studio 2015 to compile C++ for your projects. There are three editions of Visual Studio available. They are: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Community edition</strong></span>: This is free for any individual and nonenterprise organizations<a id="id427" class="indexterm"/> for up to five users. For this book, I will be using this edition.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Professional edition</strong></span>: This <a id="id428" class="indexterm"/>is a paid version and is useful for small teams.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Enterprise edition</strong></span>: This is for large teams working on projects of any size and <a id="id429" class="indexterm"/>complexity.</li></ul></div><p>You<a id="id430" class="indexterm"/> can download the Visual Studio 2015 community edition from <a class="ulink" href="https://www.visualstudio.com/downloads/download-visual-studio-vs">https://www.visualstudio.com/downloads/download-visual-studio-vs</a>
</p><p>After visiting the above link, select <span class="strong"><strong>Community 2015</strong></span> and choose your format to download. You can either download the web installer or the offline installer. To download the offline installer, select the <span class="strong"><strong>ISO</strong></span> format:</p><div class="mediaobject"><img src="graphics/B03950_10_01.jpg" alt="Setting up Visual Studio 2015"/></div><p>After <a id="id431" class="indexterm"/>downloading the setup, double-click on <span class="strong"><strong>vs_community.exe</strong></span> to run the setup and install Visual Studio 2015.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Before installing Visual Studio 2015, make sure you select <span class="strong"><strong>Visual C++</strong></span> under the <span class="strong"><strong>Programming Languages</strong></span> section. This is required to work with Unreal Engine 4.</p></div></div><div class="mediaobject"><img src="graphics/B03950_10_02.jpg" alt="Setting up Visual Studio 2015"/></div><p>When the installation is complete, the setup will prompt you to restart your computer. Do this, and <a id="id432" class="indexterm"/>you are good to go with Unreal Engine 4 C++.</p><div class="section" title="Workflow improvements"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec81"/>Workflow improvements</h2></div></div></div><p>There <a id="id433" class="indexterm"/>are some recommended settings for Visual Studio 2015 to work with Unreal Engine 4 that improves the overall user experience for developers. Some of them are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Turn off <span class="strong"><strong>Show Inactive Blocks</strong></span>. If you do not, many chunks of code may appear grayed out in the text editor. (<span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options</strong></span> | <span class="strong"><strong>Text Editor</strong></span> | <span class="strong"><strong>C/C++</strong></span> | <span class="strong"><strong>View</strong></span>).</li><li class="listitem" style="list-style-type: disc">Set <span class="strong"><strong>Disable External Dependencies Folders</strong></span> to <span class="strong"><strong>True</strong></span> to hide unneeded folders in the <span class="strong"><strong>Solution Explorer</strong></span>. (<span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options</strong></span> | <span class="strong"><strong>Text Editor</strong></span> | <span class="strong"><strong>C/C++</strong></span> | <span class="strong"><strong>Advanced</strong></span>).</li><li class="listitem" style="list-style-type: disc">Turn off <span class="strong"><strong>Edit &amp; Continue</strong></span> features. (<span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options</strong></span> | <span class="strong"><strong>Debugging</strong></span> | <span class="strong"><strong>Edit</strong></span> and click on <span class="strong"><strong>Continue</strong></span>).</li><li class="listitem" style="list-style-type: disc">Turn on <span class="strong"><strong>IntelliSense</strong></span>.</li></ul></div></div></div></div>
<div class="section" title="Creating a C++ project"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec48"/>Creating a C++ project</h1></div></div></div><p>Now that<a id="id434" class="indexterm"/> we have Visual Studio installed, let's create a project that includes C++ code. In this project, we will extend the Third Person Template that comes with Unreal Engine 4 and add support for health (including health regeneration):</p><div class="mediaobject"><img src="graphics/B03950_10_03.jpg" alt="Creating a C++ project"/></div><p>Start<a id="id435" class="indexterm"/> Unreal Engine 4 and when the project browser dialog appears:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Select the <span class="strong"><strong>New Project</strong></span> tab</li><li class="listitem" style="list-style-type: disc">Select the <span class="strong"><strong>C++</strong></span> sub tab</li><li class="listitem" style="list-style-type: disc">Select <span class="strong"><strong>Third Person</strong></span></li><li class="listitem" style="list-style-type: disc">Name your project</li><li class="listitem" style="list-style-type: disc">Click on <span class="strong"><strong>Create Project</strong></span></li></ul></div><p>When you click on <span class="strong"><strong>Create Project</strong></span>, Unreal Engine 4 will create all the base classes required and will compile the project for you. This might take a minute or so. Once this is completed, the solution file (Visual Studio file) for your project will be automatically opened along with the project.</p><p>Once the project is opened, one main change you might notice is the new <span class="strong"><strong>Compile</strong></span> button that appears on the <span class="strong"><strong>Toolbar</strong></span>. This will only appear if your project is a code project:</p><div class="mediaobject"><img src="graphics/B03950_10_04.jpg" alt="Creating a C++ project"/></div><p>This is<a id="id436" class="indexterm"/> used to recompile the code changes and reload them on the fly, even when you are playing the game! This system is called <span class="strong"><strong>Hot Reloading</strong></span>. As a<a id="id437" class="indexterm"/> programmer, you will make use of this feature extensively.</p><div class="section" title="The character class"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec82"/>The character class</h2></div></div></div><p>In<a id="id438" class="indexterm"/> this project, we have a character class and a game mode class already available. Let's take a quick look at how the character class is made.</p><p>Basically, what we have is a source file (with the extension <code class="literal">.cpp</code>) and a header file (<code class="literal">.h</code>). In a nutshell, a header file contains all the declarations, and the source file contains the definitions of those declarations. To access a specific method (or a function) in another file, we use <code class="literal"># include</code> <code class="literal">ExampleHeader.h</code>. This way, we will have access to all functions declared in that header file.</p><p>Accessing declarations on another header file are based on access specifiers. We will learn more about them later in this chapter.</p><p>To open the source file (<code class="literal">.cpp</code>) and header file (<code class="literal">.h</code>) from Unreal Engine 4:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Open <span class="strong"><strong>Content Browser</strong></span></li><li class="listitem" style="list-style-type: disc">Go to <span class="strong"><strong>C++ Classes</strong></span></li><li class="listitem" style="list-style-type: disc">Select your project name folder</li><li class="listitem" style="list-style-type: disc">Double-click on your character class</li></ul></div><p>This will open both source file (<code class="literal">.cpp</code>) and header file (<code class="literal">.h</code>) in Visual Studio:</p><div class="mediaobject"><img src="graphics/B03950_10_05.jpg" alt="The character class"/></div><p>The<a id="id439" class="indexterm"/> preceding screenshot shows the header file of our character class. Let's analyze it line by line.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#pragma once</code>: Any line that is preceded by a hash (<code class="literal">#</code>) sign is called a preprocessor directive. Think of it as instruction to the compiler to run before any actual code is compiled. They start with the hash (<code class="literal">#</code>) sign and usually ends with a new line. You can have multi-line by using the backslash (<code class="literal">\</code>) sign. In this case, <code class="literal">#pragma once</code> is a preprocessor and its job is to protect against multiple includes. <code class="literal">#pragma once</code> is known as header guard.</li><li class="listitem" style="list-style-type: disc"><code class="literal">#include</code>: In this file, we see two include files. One is <code class="literal">Character.h</code> from the <code class="literal">GameFramework</code> folder (which is in the <code class="literal">UE4</code> directory) and the other is a <code class="literal">generated.h</code> file:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Character.h</code>: This file is included because our character class is inherited from the <code class="literal">ACharacter</code> class that comes with Unreal Engine 4. This include is required to access all the declarations in the <code class="literal">Character</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">generated.h</code>: This is automatically generated for you by <span class="strong"><strong>Unreal Header Tool</strong></span> (<span class="strong"><strong>UHT</strong></span>). These are generated whenever you have<a id="id440" class="indexterm"/> a <code class="literal">USTRUCT()</code>or <code class="literal">UCLASS()</code> macro declared. They contain the details of type declarations in your header file. This should be the last include file in your header.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Macros</code>: <code class="literal">Macros</code> are also preprocessor-directive, which starts with <code class="literal">#define</code>. Right before<a id="id441" class="indexterm"/> the compile time, the compiler copies and pastes the actual values anywhere this macro is used. For example, if you create a macro like this: <code class="literal">#define MyMacro 3.14</code>, then <code class="literal">3.14</code> will be copied and pasted everywhere that <code class="literal">MyMacro</code> is used.</li><li class="listitem" style="list-style-type: disc"><code class="literal">UCLASS(config=game)</code>: This is an Unreal macro that makes the editor aware of the new class. Inside the parentheses, you specify the class specifiers and metadata. In this example, we specify the config specifier. This indicates that this class is allowed to store data in the given configuration file. In this case, the name of your config file will be <code class="literal">YourGameNameGame.ini</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class APACKT_CPPCharacter</code>: <code class="literal">public ACharacter</code>: This indicates the class name and shows you which class we inherited this from. For this class, we inherited it from the <code class="literal">Character</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GENERATED_BODY()</code>: This is a macro that must be placed at the very beginning of the class body. When compiling, Unreal will replace it with all the boilerplate code that is necessary. This means that, right before compile time, <code class="literal">GENERATED_BODY()</code> is replaced by the actual code. Since this chunk of code is required to compile the class, Epic has made it easier for us by creating this macro.</li><li class="listitem" style="list-style-type: disc"><code class="literal">private</code>, <code class="literal">public</code>, and <code class="literal">protected</code>: These are called access specifiers. Access specifiers let you decide whether a method can be accessed by other files or not. There are three types of access specifiers. They are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">private</code>: This means you can access the members only in this class. In this example, <code class="literal">CameraBoom</code> and <code class="literal">FollowCamera</code> are set as private properties. That means, you can access them <code class="literal">only</code> inside this class. If you create a new class deriving from this class, you cannot access them.</li><li class="listitem" style="list-style-type: disc"><code class="literal">public</code>: This means all the members can be accessed from any other class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">protected</code>: This means all the members can be accessed from this class and any class that is derived from this class.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">UPROPERTY()</code>: This defines the property metadata and specifiers. These are used on properties to serialize, replicate, and expose them to Blueprints. There are a number of <code class="literal">UPROPERTY ()</code> specifiers that you can use. To see the full<a id="id442" class="indexterm"/> list, visit this link: <a class="ulink" href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html">https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html</a>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">void</code>: This means it's a function that does not return any data type. A function <a id="id443" class="indexterm"/>can return any type of data such as <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">bool</code>, or even objects, but doesn't require a data type all the time. In such cases, you would use the void return type to indicate that this method does not return any type of data. This will also prevent overriding the function in any child classes. If you want to override a function in child classes, then you need to make it a virtual void. When you create a virtual void, it means child classes can override this function, implement their own logic, and optionally call the parent class function using the keyword <code class="literal">Super</code>.</li></ul></div><p>Understanding the preceding things (preprocessors, macros, access specifiers, and so on) will help a lot as you work in Unreal C++.</p><p>Another thing that is worth mentioning is the use of double colons (<code class="literal">::</code>), hyphen arrows (<code class="literal">-&gt;</code>), and periods (<code class="literal">.</code>). Understanding what they are and how to use them is crucial. Out of these, mostly we use the hyphen arrow (<code class="literal">-&gt;</code>) symbol. Let's see what they are.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Double colons</strong></span> (<code class="literal">::</code>): When using this symbol, it means you are accessing a method from a specific namespace or scope. For example, you will use this symbol when you want to call static methods from other classes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hyphen arrow</strong></span> (<code class="literal">-&gt;</code>): This is used when you are pointing to some data that might or might not exist somewhere in the memory. Using this symbol means you are trying to access a pointer. A pointer points to a location somewhere in the memory where the actual data of that pointer is stored. Before accessing a pointer, it is always a good idea to check them and make sure they are valid. Pointers are one of the most important part in Unreal C++ so I'd highly recommend to read this article provided by Nathan Iyer (Rama): <a class="ulink" href="https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers">https://wiki.unrealengine.com/Entry_Level_Guide_to_UE4_C%2B%2B#Pointers</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Period</strong></span> (.): This is used to access the data itself. For example, you will use this to access the data inside a struct.</li></ul></div><div class="section" title="Adding the health system"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec30"/>Adding the health system</h3></div></div></div><p>Now<a id="id444" class="indexterm"/> that we know about the <code class="literal">Character</code> class, let's begin by modifying our character to add support for the health and health regeneration system. Before we begin, let's see a quick breakdown of what we will be doing. In this system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">float</code> variable that holds the current health of the player when the game begins. We will make sure that the player has maximum health when the player is initialized.</li><li class="listitem" style="list-style-type: disc">Override the default function <code class="literal">TakeDamage ()</code> of the <code class="literal">Actor</code> class.</li><li class="listitem" style="list-style-type: disc">When the player is taking damage, we will check how much damage was taken and subtract that amount from the health. We will then start a timer that will execute an event that regenerates health.</li></ul></div><div class="section" title="Creating a health variable"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec02"/>Creating a health variable</h4></div></div></div><p>So let's<a id="id445" class="indexterm"/> get started. Open up your character source file and add the following code under private access specifier:</p><div class="informalexample"><pre class="programlisting">UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = "My Character", meta = (AllowPrivateAccess = "true") )
float Health;</pre></div><p>Here, we declare a <code class="literal">Health</code> variable with the data type <code class="literal">float</code>. We also added <code class="literal">UPROPERTY</code> to our <code class="literal">float</code> variable and added the specifiers <code class="literal">EditAnywhere</code>, <code class="literal">BlueprintReadWrite</code>, and <code class="literal">Category</code>. The <code class="literal">EditAnywhere</code> specifier lets you edit this property in the <span class="strong"><strong>Details</strong></span> panel. <code class="literal">BlueprintReadWrite</code> allows you to get or set this value in Blueprint. Whatever name you write as the category will appear in the <span class="strong"><strong>Details</strong></span> panel. If you compile and start your game and look at the <span class="strong"><strong>Details</strong></span> panel of the <span class="strong"><strong>ThirdPersonCharacter</strong></span> Blueprint (in <span class="strong"><strong>ThirdPersonCPP/Blueprints</strong></span>) you will see our new property exposed:</p><div class="mediaobject"><img src="graphics/B03950_10_06.jpg" alt="Creating a health variable"/></div><p>As you can see, a value of <code class="literal">0.0</code> doesn't make sense to <code class="literal">Health</code>. So what we will do is open the source<a id="id446" class="indexterm"/> file of our character class and type the following line under the class <code class="literal">constructor</code>:</p><div class="informalexample"><pre class="programlisting">Health = 100.f; // .f is optional. If it's confusing you can replace it with 100.0</pre></div><p>The <code class="literal">constructor</code> class is usually the first definition in a source file. It looks like <code class="literal">YourClassName::YourClassName()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Any line preceded by <code class="literal">//</code> (double slash) is a comment and is ignored by the compiler.</p></div></div><p>The <code class="literal">constructor</code> class is basically where we set the default values of our class. In this case, we want the default value of our player health to be <code class="literal">100</code>.</p><p>Now, if you press the <span class="strong"><strong>Compile</strong></span> button in Unreal Engine editor, the editor will compile the new changes and hot reload it when it's finished. When the compilation is finished, you should see the new value (which is <span class="strong"><strong>100</strong></span>) as the default value for <code class="literal">health</code>.</p></div><div class="section" title="Taking damage"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec03"/>Taking damage</h4></div></div></div><p>Now <a id="id447" class="indexterm"/>that our health is set, we can access it and change it in our <code class="literal">character</code> class. We now need to update this value whenever our player is taking damage. Since our character is an <code class="literal">Actor</code> class, we can use the <code class="literal">TakeDamage()</code> function to update the health. To do so, add the following code to your character header file:</p><div class="informalexample"><pre class="programlisting">virtual float TakeDamage( float Damage, struct FDamageEvent const&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser ) override;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>
<code class="literal">TakeDamage</code> is a virtual function that already exists in the <code class="literal">Actor</code> class. So when <a id="id448" class="indexterm"/>you want to have custom logic inside virtual functions, make sure you include an override keyword for them. This way you are telling the compiler to look in the parent class for a definition of this function. In case if the base class definition could not be found or has been changed then the compiler will throw an error. Keep in mind that if the override keyword is not there then the compiler will treat this as a new definition.</p></div></div><p>The <code class="literal">TakeDamage</code> function takes some parameters and returns a <code class="literal">float</code> value, which is the actual damage applied. In this function, we will first check whether our health value is larger than <code class="literal">0</code>. If it is, we decrease the <code class="literal">Health</code> value by the <code class="literal">Damage</code> value. If not, then we simply return <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">float APACKT_CPPCharacter::TakeDamage(float Damage, struct FDamageEvent const&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser)
{
 // Super key word is used here to call the actual TakeDamage function from the parent class which returns a float value.We then assign this value to ActualDamage which is a float type.
 const float ActualDamage = Super::TakeDamage(Damage, DamageEvent, EventInstigator, DamageCauser);
 // Check if we have health
 if (Health &gt; 0.0)
 {
  // Reduce health by the damage received
  Health = Health - ActualDamage;
  // return the actual damage received
  return ActualDamage;
 }
 // Player has no health. So return 0.0
 return 0.0;
}</pre></div><p>In the <a id="id449" class="indexterm"/>preceding example, you can see the use of comments and how it can help when reading the code later. <code class="literal">TakeDamage</code> function first calls the parent class function which returns the actual damage to apply. We will save this value to a local variable called <code class="literal">ActualDamage</code>. We then check whether the <code class="literal">health</code> value is greater than <code class="literal">0.0</code> and if it is then <code class="literal">health</code> value is reduced by the <code class="literal">ActualDamage</code> float variable and return that value. Whenever you override a virtual function and implement your custom logic, you use <code class="literal">Super::FunctionName()</code> to inherit the basic functionality of the parent class. Since the <code class="literal">TakeDamage()</code> function is virtual, and we override that function, we use <code class="literal">Super::TakeDamage()</code> to call the actual function defined in the parent class, which does the logic of applying damage to the actor. </p></div><div class="section" title="Health regeneration"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec04"/>Health regeneration</h4></div></div></div><p>Now <a id="id450" class="indexterm"/>that our character can take damage, we will modify this system further and add health regeneration. Our health regeneration system will regenerate health based on a <code class="literal">float</code> variable that is by default set to <code class="literal">1.0</code> every 1 second, which is also set to a <code class="literal">float</code> variable. These settings will be exposed to the Blueprint editor, so we can change them later without compiling the game again.</p><p>Let's take a quick look at the health regeneration system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We use a timer to regenerate health.</li><li class="listitem" style="list-style-type: disc">When the player takes damage, we clear this timer.</li><li class="listitem" style="list-style-type: disc">After taking damage, we set the timer to restart after 2 seconds. The timer will call a custom function that will regenerate health.</li><li class="listitem" style="list-style-type: disc">When<a id="id451" class="indexterm"/> the timer finishes, it will call the custom event which will add 1 health. This timer will continue to run until the player reaches maximum health.</li></ul></div><p>So the first thing we need is a <code class="literal">TimerHandle</code>. This helps in identifying <code class="literal">Timers</code> that have identical methods bound to them. To declare a <code class="literal">TimerHandle</code>, open up the character header file and add the following line under <code class="literal">GENERATED_BODY ()</code>:</p><div class="informalexample"><pre class="programlisting">FTimerHandle TimerHandle_HealthRegen;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>You can use any name for <code class="literal">TimerHandle</code>. Here, the use of <code class="literal">TimerHandle</code>_ before <code class="literal">HealthRegen</code> is optional.</p></div></div><p>Since we now know that we will be using timers, let's add two new <code class="literal">float</code> variables that will act as the time to activate the <code class="literal">RegenerateHealth</code> function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will call the first <code class="literal">float</code> variable <code class="literal">InitialDelay</code>. This is used to call <code class="literal">RegenerateHealth</code> after taking damage. We will set the default value to <code class="literal">2</code>.</li><li class="listitem" style="list-style-type: disc">We will call the second <code class="literal">float</code> variable <code class="literal">RegenDelay</code>. When regenerating starts from the <code class="literal">TakeDamage</code> function, we use this <code class="literal">RegenDelay</code> time to call the <code class="literal">RegenerateHealth</code> function again. We will set the default value to <code class="literal">0.5</code>.</li></ul></div><p>The following are the variables:</p><div class="informalexample"><pre class="programlisting">/* After taking damage, Regenerate Health will be called after this much seconds. */
UPROPERTY( EditAnywhere, Category = "My Character" )
float InitialDelay;
 
/* Time to regenerate health. */
UPROPERTY( EditAnywhere, Category = "My Character" )
float RegenDelay;</pre></div><p>We will also add a new property called <code class="literal">RegenerateAmount</code> and expose it to the Blueprint editor:</p><div class="informalexample"><pre class="programlisting">UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = "My Character", meta = (AllowPrivateAccess = "true") )
float RegenerateAmount;</pre></div><p>In the <code class="literal">RegenerateAmount</code> variable you can see a new meta specifier called <code class="literal">AllowPrivateAccess</code>. This is used when you want a variable in private access specifier but you need it in Blueprint as well (<code class="literal">BlueprintReadOnly</code> or <code class="literal">BlueprintReadWrite</code>). Without <code class="literal">AllowPrivateAccess</code> compiler will throw an error when you use <code class="literal">BlueprintReadWrite</code> or <code class="literal">BlueprintReadOnly</code> on a variable under private access specifier. Finally, we will add a new function called <code class="literal">RegenerateHealth</code> like this:</p><div class="informalexample"><pre class="programlisting">void RegenerateHealth();</pre></div><p>For <a id="id452" class="indexterm"/>now, we are done with the header file. Let's open the character source file and inside the class constructor (remember the class constructor is <code class="literal">YourClassName::YourClassName()</code>), add the default value for <code class="literal">RegenerateAmount</code> as <code class="literal">1.0</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>The <code class="literal">constructor</code> class is not construction script in Blueprints. If you want construction script behavior in C++, then you need to override the <code class="literal">OnConstruction</code> method.</p></div></div><p>We will also add the <code class="literal">RegenerateHealth</code> function into our source file like this:</p><div class="informalexample"><pre class="programlisting">void APACKT_CPPCharacter::RegenerateHealth()
{
}</pre></div><p>Inside this function, we will write our code that will add the <code class="literal">RegenerateAmount</code> value to our existing health. So let's modify it like this:</p><div class="informalexample"><pre class="programlisting">void APACKT_CPPCharacter::RegenerateHealth()
{
    if (Health &gt;= GetClass()-&gt;GetDefaultObject&lt;ABaseCharacter&gt;()-&gt;Health)
    {
        Health = GetClass()-&gt;GetDefaultObject&lt;ABaseCharacter&gt;()-&gt;Health;
    }
    else
    {
        Health += RegenerateAmount;
        FTimerHandle TimerHandle_ReRunRegenerateHealth;
        GetWorldTimerManager().SetTimer( TimerHandle_ ReRunRegenerateHealth, this, &amp;APACKT_CPPCharacter::RegenerateHealth, RegenDelay );
    }
}</pre></div><p>Now, let's analyze that code. The first thing we do inside this function is to check whether our <code class="literal">Health</code> is greater than or equal to our default <code class="literal">Health</code>. If it is, we simply set the health value to the default value (which is what we set in the constructor). If it's not, we add <code class="literal">RegenerateAmount</code> to our existing health and rerun this function using a timer.</p><p>Finally, we modify the <code class="literal">TakeDamage</code> function to add <code class="literal">HealthRegeneration</code>:</p><div class="informalexample"><pre class="programlisting">float APACKT_CPPCharacter::TakeDamage( float Damage, struct FDamageEvent const&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser )
{
// Get the actual damage applied
 const float ActualDamage = Super::TakeDamage(Damage, DamageEvent, EventInstigator, DamageCauser);

 if (Health &lt;= 0.0)
 {
  // Player has no health. So return 0.0
  return 0.0;
 }

 // Reduce health by the damage received
 Health = Health - ActualDamage;

 //Is the health reduced to 0 for the first time?
 if (Health &lt;= 0.0)
 {
  // Clear existing timer
  GetWorldTimerManager().ClearTimer(TimerHandle_HealthRegen);
  return 0.0;
 }


 // Set a timer to call Regenerate Health function, if it is not running already
 if (!GetWorldTimerManager().IsTimerActive(TimerHandle_HealthRegen))
 {
  GetWorldTimerManager().SetTimer(TimerHandle_HealthRegen, this, &amp;APACKT_CPPCharacter::RegenerateHealth, InitialDelay);
 }

 // return the actual damage received
 return ActualDamage;
}</pre></div><p>In the code above, <a id="id453" class="indexterm"/>we first check if our health is less than or equal to <code class="literal">0.0</code>. If it is then we know the player has no health so we simply return <code class="literal">0.0</code>. Otherwise we reduce our <code class="literal">health</code> value and check if health is less than or equal to <code class="literal">0</code>. We clear the timer if health is <code class="literal">0</code> otherwise we check if health regeneration is currently active. If it is not active then we create a new timer to run the <code class="literal">RegenerateHealth</code> function and lastly we return the <code class="literal">ActualDamage</code> applied.</p></div></div></div></div>
<div class="section" title="C++ to Blueprint"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec49"/>C++ to Blueprint</h1></div></div></div><p>We now <a id="id454" class="indexterm"/>have a health and health regeneration system in our character class. One problem with our current system is that we have not yet defined what happens to our character after the health reaches 0. In this section, we will create an event that we will implement in Blueprint. This event will be called when the player's health reaches 0.0. To create this Blueprint event, open our character header file and add the following code:</p><div class="informalexample"><pre class="programlisting">UFUNCTION(BlueprintImplementableEvent, Category = "My Character")
void PlayerHealthIsZero();</pre></div><p>As you can see, we added a normal function called <code class="literal">PlayerHealthIsZero()</code>. To make this available in Blueprint, we added a <code class="literal">UFUNCTION</code> specifier and inside that we added <code class="literal">BlueprintImplementableEvent</code>. This means C++ can call this function and it will execute inside Blueprint but we cannot add a definition for this in our character source file. Instead, we will just call it inside the source file whenever we want. In this example, we will call it inside our <code class="literal">TakeDamage</code> event if the player's health is <code class="literal">0</code>. So let's modify our <code class="literal">TakeDamage</code> like this:</p><div class="informalexample"><pre class="programlisting">float APACKT_CPPCharacter::TakeDamage( float Damage, struct FDamageEvent const&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser )
{
// Get the actual damage applied
 const float ActualDamage = Super::TakeDamage(Damage, DamageEvent, EventInstigator, DamageCauser);

 if (Health &lt;= 0.0)
 {
  // Player has no health. So return 0.0
  return 0.0;
 }

 // Reduce health by the damage received
 Health = Health - ActualDamage;

 //Is the health reduced to 0 for the first time?
 if (Health &lt;= 0.0)
 {
  // Clear existing timer
  GetWorldTimerManager().ClearTimer(TimerHandle_HealthRegen);

  // Call the BLueprint event
  PlayerHealthIsZero();

  return 0.0;
 }


 // Set a timer to call Regenerate Health function, if it is not running already
 if (!GetWorldTimerManager().IsTimerActive(TimerHandle_HealthRegen))
 {
  GetWorldTimerManager().SetTimer(TimerHandle_HealthRegen, this, &amp;APACKT_CPPCharacter::RegenerateHealth, InitialDelay);
 }

 // return the actual damage received
 return ActualDamage; }</pre></div><p>In the preceding code, we call PlayerHealthIsZero right after clearing the regen timer.</p><p>Now it's time <a id="id455" class="indexterm"/>to compile and run the project. In Visual Studio, press <span class="emphasis"><em>F5</em></span> to compile and launch the project. Once the project is loaded, open our character Blueprint and you will see our new variables exposed in the <span class="strong"><strong>Details</strong></span> panel:</p><div class="mediaobject"><img src="graphics/B03950_10_07.jpg" alt="C++ to Blueprint"/></div><p>From here, you can open the Blueprint graph and add our <span class="strong"><strong>Player Health Is Zero</strong></span> event:</p><div class="mediaobject"><img src="graphics/B03950_10_08.jpg" alt="C++ to Blueprint"/></div><p>In <a id="id456" class="indexterm"/>this event, you can program your logic to play a death animation, show some UI screen, and so on.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec50"/>Summary</h1></div></div></div><p>Unreal C++ is easy to learn compared to actual C++. This is because the programming wizards at Epic Games implemented so many features that makes writing Unreal C++ fun! You can extend what you learned from this chapter by including Armor system, Stamina system, and so on for your character. By incorporating UMG and Blueprints, you can show a HUD that shows player health and maybe a small warning system that pops up when the player's health goes below 50. In the next chapter, you will learn how to package a project for shipping.</p></div></body></html>