<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Conquer the Universe</h1></div></div></div><p>Congratulations! You have come this far. If you are reading this chapter, then you have already created two games—a 2D game and a 3D game. Sure, they aren't going to sell and make you a million dollars, but you already completed more games than 90 percent of all people who try.</p><p>There is a lot more to learn, and there is no way that we can cover everything in a single book. This chapter will briefly cover a few more topics and hopefully give you at least enough information to experiment further after you are done with the book. In fact, we are going to set up a framework that will allow you to play, so we will call it the playground.</p><p>The topics that we will cover include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The playground</strong>: We will begin by setting up a template that you can use over and over again as you experiment with different features. This template will also be a good starting ground for any future games that you may want to create.</li><li class="listitem" style="list-style-type: disc"><strong>Texture mapping</strong>: So far, we worked with color, not textures. It would be pretty difficult to make realistic games with only color. It turns out that we can put textures onto our models to make them more realistic. We will learn the basics of texture mapping on a simple 3D shape.</li><li class="listitem" style="list-style-type: disc"><strong>Lighting</strong>: So far, we used the default lighting that was provided by OpenGL. Most of the time, we want more control over the lighting. We will discuss the various types of lighting and how they are used.</li><li class="listitem" style="list-style-type: disc"><strong>Skyboxes</strong>: The game universe can't go on forever. We often use a device known as a skybox to surround our game world and make it look like it is larger than it really is. We will learn how to add a skybox to our space game.</li><li class="listitem" style="list-style-type: disc"><strong>Physics</strong>: In the real world, objects bounce, fall, and do other things based on the laws of physics. We will discuss how objects interact with each other and the rest of the universe.</li><li class="listitem" style="list-style-type: disc"><strong>AI</strong>: Many games have enemies or weapons seeking to destroy the player. These enemies are usually controlled by some form of <strong>Artificial Intelligence</strong> (<strong>AI</strong>). We will discuss some simple forms of AI and learn how the game can control objects in the game.</li><li class="listitem" style="list-style-type: disc"><strong>Where to go from here</strong>: Finally, I'll give you a few tips on how you can continue to improve your skills once you have completed this book. We'll talk about game engines and topics for additional study.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec66"/>A fun framework</h1></div></div></div><p>Now, it's time to create our playground. Before we start coding, let's decide on the basic features that we <a id="id687" class="indexterm"/>want to set up:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Visual Studio project</li><li class="listitem" style="list-style-type: disc">Windows environment</li><li class="listitem" style="list-style-type: disc">OpenGL environment</li><li class="listitem" style="list-style-type: disc">Game loop</li></ul></div><p>That's all we are going to do for now. The idea is to set up a basic template that you can use to start any game or experimental project. We don't want to include too much in this basic framework, so we will leave out sound, input, sprite, and model loading for now. These can be added in as they are needed.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec166"/>Setting up the Visual Studio project</h2></div></div></div><p>Start <a id="id688" class="indexterm"/>a new blank project and name it <code class="literal">FunWith3D</code>. Make <a id="id689" class="indexterm"/>sure to add the correct libraries as we have done before in the project <strong>Properties</strong>, <strong>Configuration Properties</strong>, <strong>Linker</strong>, <strong>Input</strong>, <strong>Additional Dependencies</strong> property:</p><div><pre class="programlisting">glu32.lib;opengl32.lib;SOIL.lib;</pre></div><p>We are going to include the SOIL library because it is so useful to load images. You will want to copy the following files over from our <code class="literal">SpaceRacer3D.cpp</code> project folder:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glut.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glut32.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glut32.dll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SOIL.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SOIL.lib</code></li></ul></div><p>Add the<a id="id690" class="indexterm"/> following <a id="id691" class="indexterm"/> libraries to Properties, Configuration Properties, Input, and Additional Dependencies:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glut32.lib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SOIL.lib</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec167"/>Setting up the Windows environment</h2></div></div></div><p>Create a <a id="id692" class="indexterm"/>new C++ file and name it <code class="literal">FunWith3D.cpp</code>. Then<a id="id693" class="indexterm"/> add the following code:</p><div><pre class="programlisting">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include "glut.h"
#include "SOIL.h"

const int screenWidth = 1024;
const int screenHeight = 768;

// Global Variables:
HINSTANCE hInstance = NULL;
HDC hDC = NULL;
HGLRC hRC = NULL;
HWND hWnd = NULL;

bool fullscreen = false;


// Forward declarations of functions included in this code module:
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);</pre></div><p>Now, open <code class="literal">SpaceRacer3D.cpp</code> from the previous project and copy the following functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WinMain</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WndProc</code></li></ul></div><p>These are the header files and two functions that are required for Windows to do its stuff. All of this code has been explained in previous chapters, so I'm not going to re-explain it here. In <a id="id694" class="indexterm"/>fact, you could save yourself some<a id="id695" class="indexterm"/> typing and copy this code directly from our previous project.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec168"/>Setting up the OpenGL environment</h2></div></div></div><p>Now, it is <a id="id696" class="indexterm"/>time to set up OpenGL. Copy the <a id="id697" class="indexterm"/>following function from SpaceRacer3D and add them after the <code class="literal">WndProc</code> declaration:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ReSizeGLScene</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">InitGL</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">KillGLWindow</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CreateGLWindow</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec169"/>Setting up the game loop</h2></div></div></div><p>Now, we <a id="id698" class="indexterm"/>add the function that defines our game loop. Add <a id="id699" class="indexterm"/>these functions after the OpenGL code that you just added:</p><div><pre class="programlisting">void StartGame()
{
}
void Update(const float p_deltaTime)
{
}

void Enable2D()
{
  glColor3f(1.0f, 1.0f, 1.0f);
  glEnable(GL_TEXTURE_2D);
  
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0, screenWidth, screenHeight, 0, 0, 1);
  
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  
  glPushAttrib(GL_DEPTH_BUFFER_BIT);
  glDisable(GL_DEPTH_TEST);
}

void Disable2D()
{
  glPopAttrib();
  
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  
  glDisable(GL_TEXTURE_2D);
}

void Render2D()
{
  Enable2D();
  //Add your 2D rendering here
  Disable2D();
}

void Render3D()
{
  //Add your 3D rendering here
}

void Render()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  Render3D();
  Render2D();
  SwapBuffers(hDC);
}
void EndGame()
{
}

void GameLoop(const float p_deltatTime)
{
  Update(p_deltatTime);
  Render();
}</pre></div><p>In order to be consistent with some other code that we have written, you need to add the following precompile directives in the project <strong>Properties</strong>, <strong>Configuration Properties</strong>, <strong>C/C++</strong>, <strong>Preprocessor</strong>, and <strong>Preprocessor Definitions</strong> property: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">_USE_MATH_DEFINES</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">_CRT_SECURE_NO_WARNINGS</code></li></ul></div><p>Congratulations! You now have a framework that you can use for any future projects and experiments. You have also just successfully reviewed the OpenGL and game code that we have been working with throughout the entire book.</p><p>You will <a id="id700" class="indexterm"/>notice that I also left the code in so that you will be<a id="id701" class="indexterm"/> able render in either 3D or 2D! All together, you now have a small yet effective start for your own game engine. I suggest that you save a copy of the folder containing this solution and project. Then, when you are ready to start a new project, you can simply copy the solution folder, give it another name, and you are ready to go. We are going to use this as the basis for any code that we write in this chapter.</p><div><div><h3 class="title"><a id="tip67"/>Tip</h3><p>To save space and keep our little playground simple, I did not include some key features, such as input, sprites, models, and sound. If you feel that any of these are essential to your playground, then this will be your first exercise. In general, you will have to simply copy the relevant files and/or code into your project folder from the last version of SpaceRacer3D.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec67"/>Texture mapping</h1></div></div></div><p>Until now, all of our shapes and models used color, but a whole new world awaits us when we<a id="id702" class="indexterm"/> start applying textures to our models. Adding a 2D texture to a 3D model is known as <strong>texture mapping</strong>, or in some cases <strong>texture wrapping</strong>. Let's see what it takes to add a little texture to our 3D models. We are going to start with a simple cube.</p><p>First, use your favorite image editing software to create a 256 x 256 pixel square and give it some kind of texture. I will be using the following one:</p><div><img src="img/8199OS_12_01.jpg" alt="Texture mapping"/></div><p>Save this texture as a bitmap (BMP). We are going to use bitmaps, as opposed to PNGs, for texture mapping because the internal data structure of a bitmap happens to coincide with the data<a id="id703" class="indexterm"/> structure that is expected by OpenGL. In other words, it is easier!</p><p>I always create a folder called resources for my images. It is also a good idea to include these as resources in the Visual Studio project (right-click on the <strong>Resources</strong> folder in the <strong>Solution Explorer</strong> panel and choose <strong>Add Existing…</strong>, then navigate to the image).</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec170"/>Loading the texture</h2></div></div></div><p>If you recall, we <a id="id704" class="indexterm"/>created a sprite class for our previous projects. We use the <code class="literal">AddTexture</code> method of the <code class="literal">Sprite</code> class to make a call to the SOIL library to load the image. We won't be using the <code class="literal">Sprite</code> class for these textures. The <code class="literal">Sprite</code> class has a lot of methods and properties that don't apply to texturing 3D models, so we are going to write our own texture loader for this use. Add the following code somewhere above render functions:</p><div><pre class="programlisting">void LoadTexture(const char* filepath, GLsizei height, GLsizei width, unsigned int colordepth, GLuint &amp;texture)
{
  unsigned char* data;
  FILE* file;
  
  file = fopen(filepath, "r");
  data = (unsigned char*)malloc(width * height * colordepth);
  fread(data, width * height * colordepth, 1, file);
  fclose(file);
  
  texture = SOIL_load_OGL_texture(filepath, SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, 0);
  glBindTexture(GL_TEXTURE_2D, texture);
  glTexImage2D(GL_TEXTURE_2D, 0, colordepth == 3 ? GL_RGB:GL_RGBA, width, height, 0, colordepth == 3 ? GL_RGB:GL_RGBA, GL_UNSIGNED_BYTE, data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  free(data);
}</pre></div><p>The purpose<a id="id705" class="indexterm"/> of <code class="literal">LoadTexture</code> is to load a texture into memory, and then set it up to be a texture map for a 3D object. In order to accomplish this, we actually need to load the texture twice. First, we directly open the file and read it as a binary file into a buffer called <code class="literal">data</code>. We use the <code class="literal">char</code> datatype because we want to store the binary data as unsigned integers and <code class="literal">char</code> does a really great job of this. So, our first few lines of code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define the data array</li><li class="listitem" style="list-style-type: disc">Create a file handle</li><li class="listitem" style="list-style-type: disc">Allocate memory for the data</li><li class="listitem" style="list-style-type: disc">Read the file into the data buffer</li><li class="listitem" style="list-style-type: disc">Close the file (but not the buffer)</li></ul></div><p>Now, read the image a second time, though this time we use the SOIL library to read it as an OpenGL texture and use SOIL to load the texture and assign it to the OpenGL referenced by <code class="literal">texture</code>.</p><p>Then, we perform some fancy OpenGL operations on it to set it up as a model texture:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GL_BindTexture</code> simply tells OpenGL that we want this texture to be the current texture, to which we will apply the settings that follow.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glTexImage2D</code> tells OpenGL how to interpret the data that we have read in. We are telling OpenGL to treat the data as a 2D texture of the type RGB or RGBA (controlled by the <code class="literal">colordepth</code> parameter), and that the data is stored as unsigned integers (thus, the <code class="literal">char</code> data type).</li><li class="listitem" style="list-style-type: disc">The next two functions, both calls to <code class="literal">glTexParameteri</code>, tell OpenGL how to handle the texture as it gets nearer to or farther away from the camera. They are both set up to use linear filtering to handle this level of detail.</li><li class="listitem" style="list-style-type: disc">Finally, we close the data buffer as it is no longer needed.</li></ul></div><p>We have set the <code class="literal">LoadTexture</code> function up so that you can call it for different textures based on your needs. In our case, we are first going to set up a handle to this texture. At the top of the code, add this line to the global variables section:</p><div><pre class="programlisting">GLuint texMarble;</pre></div><p>Next, we <a id="id706" class="indexterm"/>will place the call to load the texture in the <code class="literal">StartGame</code> function:</p><div><pre class="programlisting">LoadTexture("resources/marble.bmp", 256, 256, 4, texMarble);</pre></div><p>This call tells the program:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The location of the file</li><li class="listitem" style="list-style-type: disc">The width and height of the image</li><li class="listitem" style="list-style-type: disc">The color depth of the image (in this case <code class="literal">4</code> = RGBA)</li><li class="listitem" style="list-style-type: disc">The OpenGL texture handle</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec171"/>Rendering the cube</h2></div></div></div><p>We are all <a id="id707" class="indexterm"/>set up now with a texture, but we need a model to texture. To keep things simple, we are going to use quads to create a cube and apply the marble texture to each face of the cube.</p><p>Just before we get started, we need to add three variables to track rotation. Add these lines to the global variables section:</p><div><pre class="programlisting">float xrot = 1.0f;
float yrot = 1.0f;
float zrot = 1.0f;</pre></div><p>Now, create the following function just below the <code class="literal">LoadTexture</code> function:</p><div><pre class="programlisting">int DrawTexturedCube(GLvoid)
{
  glEnable(GL_TEXTURE_2D);
  
  glLoadIdentity();
  glTranslatef(0.0f, 0.0f, -5.0f);
  
  glRotatef(xrot, 1.0f, 0.0f, 0.0f);
  glRotatef(yrot, 0.0f, 1.0f, 0.0f);
  glRotatef(zrot, 0.0f, 0.0f, 1.0f);
  
  glBindTexture(GL_TEXTURE_2D, texMarble);
  
  glBegin(GL_QUADS);
  // Font Face
  glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
  glTexCoord2f(1.0f, 0.0f); glVertex3f(1.0f, -1.0f, 1.0f);
  glTexCoord2f(1.0f, 1.0f); glVertex3f(1.0f, 1.0f, 1.0f);
  glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
  // Back Face
  glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);
  glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f);
  glTexCoord2f(0.0f, 1.0f); glVertex3f(1.0f, 1.0f, -1.0f);
  glTexCoord2f(0.0f, 0.0f); glVertex3f(1.0f, -1.0f, -1.0f);
  // Top Face
  glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f);
  glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
  glTexCoord2f(1.0f, 0.0f); glVertex3f(1.0f, 1.0f, 1.0f);
  glTexCoord2f(1.0f, 1.0f); glVertex3f(1.0f, 1.0f, -1.0f);
  // Bottom Face
  glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f);
  glTexCoord2f(0.0f, 1.0f); glVertex3f(1.0f, -1.0f, -1.0f);
  glTexCoord2f(0.0f, 0.0f); glVertex3f(1.0f, -1.0f, 1.0f);
  glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
  // Right face
  glTexCoord2f(1.0f, 0.0f); glVertex3f(1.0f, -1.0f, -1.0f);
  glTexCoord2f(1.0f, 1.0f); glVertex3f(1.0f, 1.0f, -1.0f);
  glTexCoord2f(0.0f, 1.0f); glVertex3f(1.0f, 1.0f, 1.0f);
  glTexCoord2f(0.0f, 0.0f); glVertex3f(1.0f, -1.0f, 1.0f);
  // Left Face
  glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);
  glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
  glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
  glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f);
  glEnd();
  
  xrot += 0.01f;
  yrot += 0.02f;
  zrot += 0.03f;
  return TRUE;
}</pre></div><p>This code is very similar to the code that we used to draw a cube in a previous chapter. However, when we drew that cube, we applied color to each vertex. Now, we will apply our texture to <a id="id708" class="indexterm"/>each face. First, we set things up:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing that we do is use <code class="literal">glEnable(GL_TEXTURE_2D)</code> to enable 2D textures. In our initial setup, we disabled 2D textures. If we did not enable them here, then our texture would not show up!</li><li class="listitem">Next, we use <code class="literal">glLoadIdentity()</code> to initialize the current matrix.</li><li class="listitem">We call <code class="literal">glTranslatef(0.0f, 0.0f, -5.0f)</code> to move the camera back (so that we will be outside the cube).</li><li class="listitem">Three calls to <code class="literal">glRotate3f</code> will rotate the cube for us.</li><li class="listitem">Then, we use <code class="literal">glBindTexture(GL_TEXTURE_2D, texMarble)</code> to inform OpenGL that for the next draw operations we will be using the texture referenced by <code class="literal">texMarble</code>.</li></ol></div><p>With this setup completed, we are ready to get drawing:</p><div><ol class="orderedlist arabic"><li class="listitem">We start with <code class="literal">glBegin(GL_QUADS)</code> to tell OpenGL that we will be drawing quads.</li><li class="listitem">Now, each call comes in a pair. First a call to <code class="literal">glTexCoord2f</code> is followed by a call to <code class="literal">glVertex3f</code>. The call to <code class="literal">glTexCoord2f</code> tells OpenGL which part of the texture to put at the location specified by <code class="literal">glVertex3f</code>. In this way, we can map any point in the texture to any point in the quad. OpenGL takes care of figuring out which parts of the texture go between vertices.</li><li class="listitem">When we are done drawing the cube, we issue the <code class="literal">glEnd()</code> command.</li><li class="listitem">The last three lines update the rotation variables.</li><li class="listitem">Finally, we have to make a call to <code class="literal">DrawTexturedCube</code> in the <code class="literal">Render3D </code>function:<div><pre class="programlisting">DrawTexturedCube();</pre></div></li><li class="listitem">Run the program and see the cube in its textured glory!<div><img src="img/8199OS_12_02.jpg" alt="Rendering the cube"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec172"/>Mapping operations</h2></div></div></div><p>I owe you <a id="id709" class="indexterm"/>a little more explanation as to how texture mapping works. Take a look at these four lines of code from <code class="literal">DrawTexturedCube</code>:</p><div><pre class="programlisting">glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f);
glTexCoord2f(1.0f, 0.0f); glVertex3f(1.0f, -1.0f, 1.0f);
glTexCoord2f(1.0f, 1.0f); glVertex3f(1.0f, 1.0f, 1.0f);
glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);</pre></div><p>These four lines define one quad. Each vertex consists of a texture coordinate (<code class="literal">glTexCoord2f</code>) and a vertex coordinate (<code class="literal">glVertex3f</code>). When OpenGL looks at a texture, here is what it sees:</p><div><img src="img/8199OS_12_03.jpg" alt="Mapping operations"/></div><p>No matter how<a id="id710" class="indexterm"/> big a texture is in pixels, in texture coordinates, the texture is exactly one unit wide and one unit tall. So, the first line of the preceding code tells OpenGL to take the point (<strong>0,0</strong>) of the texture (the upper-left corner) and map it to the next vertex that is defined (which is the upper-left hand corner of the quad, in this example). You will notice that the third line maps the coordinate (<strong>1,1</strong>) of the texture to the lower-right corner of the quad. In effect, we are stretching the texture across the face of the quad! However, OpenGL also adapts the mapping so that the texture doesn't look smeared, so this isn't exactly what happens. Instead, you will see some tiling in our case.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec68"/>Let there be light!</h1></div></div></div><p>Until this point, we<a id="id711" class="indexterm"/> haven't worried about lighting. In fact, we just assumed that light would be there so that we could see our images. OpenGL has a light setting that lights everything equally. This setting is turned on, by default, until we tell OpenGL that we would like to handle the lighting.</p><p>Imagine what our scene would look like if there was no lighting. In fact, this is going to happen to you <a id="id712" class="indexterm"/>some day. You will have everything set up and ready to roll, you'll run the program, and you'll get a big, black, nothing! What's wrong? You forgot to turn on the lights! Just as shown in the following image:</p><div><img src="img/8199OS_12_04.jpg" alt="Let there be light!"/></div><p>Just like real life, if you don't have a source of light, you aren't going to see anything. OpenGL has many types of lights. One common light is <strong>ambient</strong> light. Ambient light appears to come<a id="id713" class="indexterm"/> from all directions at the same time, similarly to how sunlight fills up a room.</p><div><img src="img/8199OS_12_05.jpg" alt="Let there be light!"/></div><p>Lighting is <a id="id714" class="indexterm"/>very important in 3D games, and most games have multiple light sources to add realism to the game.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec173"/>Defining a light source</h2></div></div></div><p>Let's take <a id="id715" class="indexterm"/>over and define our own light source. Add the following lines of code to the top of the <code class="literal">DrawTexturedCube</code> function:</p><div><pre class="programlisting">glEnable(GL_LIGHTING);
GLfloat ambientLight[] = { 0.0f, 0.0f, 1.0f, 1.0f };
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);
glEnable(GL_COLOR_MATERIAL);
glColorMaterial(GL_FRONT, GL_AMBIENT);</pre></div><p>Run the program, then come back to see what is happening:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glEnable(GL_LIGHTING)</code> tells OpenGL that we want to take control of the lighting now. Remember: once you enable lighting, it's up to you. In fact, if you enable lighting and don't define any lights, then you will get a completely black scene.</li><li class="listitem" style="list-style-type: disc">Next, we define a color for our light. In this case, we are creating a blue light.</li><li class="listitem" style="list-style-type: disc">Now we tell OpenGL what type of lighting we would like to use with <code class="literal">glLightModelfv</code>. In this case, we are turning on a blue, ambient light.</li><li class="listitem" style="list-style-type: disc">Light has to have a material to reflect from. So, we use <code class="literal">glEnable(GL_COLOR_MATERIAL)</code> to tell OpenGL to use a material that will reflect color.</li><li class="listitem" style="list-style-type: disc">The call to <code class="literal">glColorMaterial(GL_FRONT, GL_AMBIENT)</code> tells OpenGL that the front of this material should reflect light as if it was ambient light. Remember, ambient light comes from all directions.</li></ul></div><p>Of course, you have already seen the result. Our cube is blue! Play around with different colors. We only have time to barely scratch the surface on lighting. You will also want to learn about diffuse lighting. Diffuse lights fade with distance. With a diffuse light, you not only set up the color, but you also place the light at a certain location.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec69"/>The skybox</h1></div></div></div><p>While space <a id="id716" class="indexterm"/>may be infinite, your computer isn't so there has to be a boundary somewhere. This boundary is called the skybox.</p><p>Imagine that our spaceship is flying through space! Space is big. While we may put some planets and asteroids in our universe to give the space ship something to interact with, we certainly won't model every star. Here is what our universe looks like:</p><div><img src="img/8199OS_12_06.jpg" alt="The skybox"/></div><p>This is pretty<a id="id717" class="indexterm"/> empty, right? You probably already noticed this in our game, SpaceRacer3D. Of course, we could add some more objects of our own—more asteroids, add a bunch of stars—and in a real game, we would. But, there is always a limit to how many objects you can add to the game before you start having performance issues.</p><p>For the really distant objects, such as distant stars, we fake it by using 2D textures. For example, our game could use a texture of stars to imitate the stars and nebula in space, as shown in the following image:</p><div><img src="img/8199OS_12_07.jpg" alt="The skybox"/></div><p>Now, as a cube has six sides, what we really want is six textures. A typical skybox looks similar to the following image:</p><div><img src="img/8199OS_12_08.jpg" alt="The skybox"/></div><p>It doesn't<a id="id718" class="indexterm"/> take too much imagination to see how this texture can be wrapped around the cube and cover all size sides. This creates an image that covers all of the space encapsulated by the skybox and gives the illusion of being surrounded by stars and nebula, as shown in the following image:</p><div><img src="img/8199OS_12_09.jpg" alt="The skybox"/></div><p>The<a id="id719" class="indexterm"/> following illustration shows the skybox in relation to the texture that will be applied to it from another perspective:</p><div><img src="img/8199OS_12_10.jpg" alt="The skybox"/></div><p>The cube containing the ship and asteroid represents the game world. The ship and asteroid are real objects in that world. The image on the left is a texture that contains the stars.</p><p>Now, imagine the star texture being wrapped around the cube, and there is your whole universe <a id="id720" class="indexterm"/>composed of the stars, the ship, and the asteroid. The star texture wrapped around the cube is the skybox.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec70"/>Advanced topics</h1></div></div></div><p>Unfortunately, for the last two topics, we only have time to give them an honorable mention. I included them because you are going to hear about these topics, and you need to know what these terms mean.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec174"/>Game physics</h2></div></div></div><p>
<strong>Game physics</strong> are <a id="id721" class="indexterm"/>the rules that define how objects interact with other objects inside the game universe. For example, in SpaceRacer3D, the ship simply passes through the asteroids. However, there could be many other outcomes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ship and asteroid could bounce off of each other (rebound)</li><li class="listitem" style="list-style-type: disc">The ship could be sucked into the asteroid with the force increasing as the ship got closer (gravity)</li><li class="listitem" style="list-style-type: disc">The asteroid could push against the ship the closer the ship got to it (reverse gravity)</li></ul></div><p>Each of these effects would be programmed into the game. Each of these effects would also create a different kind of gameplay. An entire genre of games known as physics-based games simply define the laws of physics for a game universe and then let things interact to see what will happen.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec175"/>AI</h2></div></div></div><p>
<strong>AI</strong>, or <strong>artificial intelligence</strong>, is another set of rules that defines how characters or objects that are<a id="id722" class="indexterm"/> controlled by the compute behave. AI is typically applied to enemies and other <strong>Non-player Characters</strong> (<strong>NPCs</strong>) to give them a life-like appearance<a id="id723" class="indexterm"/> in the game. Some examples of AI include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A mine that automatically detects that the enemy is close and blows up</li><li class="listitem" style="list-style-type: disc">A homing missile that locks onto a space ship and draws closer no matter how the ship navigates</li><li class="listitem" style="list-style-type: disc">An enemy character who detects that the player coming and hides behind a rock</li></ul></div><p>AI is typically considered one of the most difficult areas of game programming. Some algorithms<a id="id724" class="indexterm"/> are quite easy (for example, the homing missile only needs the ships position to know how to track it), while others are very complex (for example, hiding behind a rock). Some games even provide an AI opponent for you to play against.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec71"/>The future</h1></div></div></div><p>You have, indeed, come a long way. If you are reading these words, and especially if you wrote all of the code along the way, then you have achieved a great accomplishment, but there is still so much to learn. I encourage you to find other books and never stop learning. The only thing that will stop you from becoming a great game programmer is you!</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec72"/>Summary</h1></div></div></div><p>As always, we covered a lot of topics in this chapter. You learned how to map a texture onto an object, then you learned how to turn the lights on. You learned how a skybox can be used to make your world seem larger than it is. And you got just a taste of physics and AI, topics which could easily fill entire books on their own. Don't stop until you have got every piece of code in this book to work for you, and then start changing the code to different and amazing things.</p><p>Good luck!</p></div></body></html>