- en: Chapter 7. Gold, Items, and a Shop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 金币、物品和商店
- en: 'Now that you have created an NPC that talks to the player, it is time to allow
    the NPC to help the player. In this chapter, we will use the NPC as a shop owner,
    displaying items for the user to buy. Before we do this, the user is going to
    need some sort of currency to buy the items. We will cover the following topics
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个与玩家交谈的NPC，是时候允许NPC帮助玩家了。在本章中，我们将使用NPC作为店主，向用户展示可以购买的物品。在我们这样做之前，用户将需要某种货币来购买物品。本章我们将涵盖以下主题：
- en: Setting and getting gold instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和获取金币实例
- en: Item data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品数据
- en: The shop screen framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店屏幕框架
- en: The item button framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品按钮框架
- en: Linking the item data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接物品数据
- en: Setting and getting gold instances
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和获取金币实例
- en: While we move on to making a shopping interface, via the **Shop** button, we
    must first be able to pull the currency in order to pay for items in the shop.
    In a previous chapter, we discussed and made placeholders for gold, but we did
    not actually create gold values. In this game, we would like gold to be dropped
    by enemies at the end of battle. In this case, enemies will need some sort of
    gold data that we can add to the player's gold data (eventually, items will need
    this gold data that is tied to them as well). In [Chapter 4](ch04.html "Chapter 4. Pause
    Menu Framework"), *Pause Menu Framework*, we created a pause menu that has a gold
    placeholder, and we will now add gold to this pause menu.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续制作购物界面，通过**Shop**按钮时，我们首先必须能够提取货币，以便在商店中购买物品。在之前的一章中，我们讨论并创建了金币的占位符，但实际上我们没有创建金币值。在这个游戏中，我们希望金币在战斗结束后由敌人掉落。在这种情况下，敌人需要某种金币数据，我们可以将其添加到玩家的金币数据中（最终，物品也需要这种与它们关联的金币数据）。在[第4章](ch04.html
    "Chapter 4. Pause Menu Framework")，*暂停菜单框架*中，我们创建了一个具有金币占位符的暂停菜单，现在我们将向这个暂停菜单添加金币。
- en: 'First, let''s add a `Gold` property to `FEnemyInfo.h`. Navigate to **Source**
    | **RPG** | **Data**, open `FEnemyInfo.h`, and add a `Gold` property of an integer
    data type to your `EnemyInfo` table, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`FEnemyInfo.h`中添加一个`Gold`属性。导航到**Source** | **RPG** | **Data**，打开`FEnemyInfo.h`，并在你的`EnemyInfo`表中添加一个整型数据类型的`Gold`属性，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We now need to tie the `Gold` property with our standard `GameCharacter` properties
    so that we can update any instance of an enemy with the proper gold value. Next,
    you will open `GameCharacter.h`, which is located in **RPG** under **Source**,
    and add a public `UProperty` to the `UCharacter` class for gold similar to that
    in `FEnemyInfo.h`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将`Gold`属性与我们的标准`GameCharacter`属性关联起来，以便我们可以更新任何敌人的实例，使其具有正确的金币值。接下来，你将打开位于**Source**下的**RPG**文件夹中的`GameCharacter.h`文件，并在`UCharacter`类中添加一个与`FEnemyInfo.h`中类似的公共`UProperty`用于金币：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, head into `GameCharacter.cpp` to set the return value of the gold that
    is equal to the value set in `EnemyInfo`, so that each instance of this particular
    enemy will return the amount of gold set in the enemy''s data table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入`GameCharacter.cpp`来设置金币的返回值，使其等于在`EnemyInfo`中设置的值，这样这个特定敌人的每个实例都将返回敌人数据表中设置的金币数量：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you are finished, the enemy''s character information in `GameCharacter.cpp`
    will look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，`GameCharacter.cpp`中的敌人角色信息将看起来像这样：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now need to choose when to accumulate the gold, and in this case, we will
    accumulate the gold from combat. So, navigate to **Source** | **RPG** | **Combat**,
    open `CombatEngine.h`, and create a public gold variable that we will use to store
    all the gold won in the battle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要选择何时累积金币，在这种情况下，我们将从战斗中累积金币。因此，导航到**Source** | **RPG** | **Combat**，打开`CombatEngine.h`，创建一个公共的金币变量，我们将用它来存储在战斗中赢得的所有金币：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you have finished declaring the `GoldTotal` variable, the `CombatEngine.h`
    file will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成声明`GoldTotal`变量后，`CombatEngine.h`文件将看起来像这样：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step that we need to perform is telling the engine when to give the
    gold to the player. As mentioned earlier, we want players to win gold from enemies
    that can easily be integrated into our combat engine. Navigate to **Source** |
    **RPG** | **Combat**, and open `CombatEngine.cpp`. Let''s first scroll down to
    the `for` loop that we created in [Chapter 3](ch03.html "Chapter 3. Exploration
    and Combat"), *Exploration and Combat*, to check for a victory. Just above this
    `for` loop, declare a new `Gold` integer, and set it to `0`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will assure that, if we don''t have a victory and need to cycle through
    the `for` loop again, the gold gained in battle will reset to 0\. Next, we need
    to accumulate the gold from every enemy killed; thus, within the `for` loop, we
    have `Gold` increment by each enemy''s gold:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your `for` loop will now look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the `for` loop, you will still have an `if` condition that checks whether
    the enemy party is dead; if the enemy party is dead, the combat phase will change
    to the victory phase. If the condition is `true`, it means that we won the battle;
    therefore, we should be rewarded with the gold from the `for` loop. Since the
    `Gold` variable that we want to add is in the `GoldTotal` variable, we simply
    set the local `Gold` variable to the new value of `GoldTotal`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you are finished, your `if` condition will now look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have set enemies to drop gold after the player is victorious in
    battle, the next thing that we need to do is add gold to our game data; more specifically,
    it would be best to add it in `RPGGameInstance.h`, since an instance of the game
    will always be active. It would be unwise to add the gold data to a party member
    unless there is a specific party member who will always be in the game. So, let's
    open `RPGGameInstance.h` located in **RPG** under **Source**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'As a public property, add another integer to `Game Data` that we will call
    `GameGold`. Also, ensure that `GameGold` is read- and write-enabled because we
    want to be able to add and subtract gold; therefore editing of `GameGold` must
    be enabled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we can create instances of `GameGold`, go to your `RPGGameMode.cpp`
    file where you originally set up the logic for the game over and victory conditions;
    in the victory condition, create a pointer to `URPGGameInstance` that we will
    call `gameInstance`, and set it equal to a cast to `GetGameInstance`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now use `gameInstance` to add the total gold that we got from the battle
    to `GameGold`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, the value of `GameGold` that we are using as the player''s gold
    will now be incremented by the gold won in the battle. The `tick` function in
    `RPGGameMode.cpp` will now look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you need to make sure that all your changes are saved and recompile your
    entire project (you may need to restart UE4).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now adjust the gold value of each enemy character that we have from
    the enemy''s Data Table. In **Content Browser**, navigate to the **Enemies** Data
    Table located at **Data** under **Content**. In the Data Table, you will now see
    a **Gold** row. Add any value that you want to the **Gold** row, and save the
    Data Table:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and getting gold instances](img/B04548_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Now that an enemy has a gold value, there is a real value that is bound to
    the `Gold` variable in `EnemyInfo` that gets added to `GameGold` if the player
    is victorious in battle. However, we need to display that gold; luckily, we still
    have a placeholder for the gold in our pause menu. Open the **Pause_Main** Widget
    Blueprint, and click on the **Editable_Gold** Text Block that we created in [Chapter
    4](ch04.html "Chapter 4. Pause Menu Framework"), *Pause Menu Framework*. In the
    **Details** panel, go to **Content** and create a binding for the Text Block,
    which will open the graph for **Get Editable Gold Text**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and getting gold instances](img/B04548_07_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that we need to do is get the game instance of **RPGGameInstance**
    by creating a **Get Game Instance** function located under **Game** and setting
    it as an object of **Cast To RPGGameInstance**:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and getting gold instances](img/B04548_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'We can then get the `GameGold` variable from **RPGGameInstance**, which is
    the variable that stores the current gold total for the game. It is located in
    **Game Data** under **Variables**. Link it to the **As RPGGameInstance** pin in
    **Cast To RPGGameInstance**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and getting gold instances](img/B04548_07_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, link **Game Gold** to **Return Value** in **ReturnNode** and allow
    **Get Editable Gold Text** to trigger **Cast To RPGGameInstance**, which will
    trigger **ReturnNode**. Your **Get Editable Gold Text** binding will now look
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and getting gold instances](img/B04548_07_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: If you test this now, you will be able to get into battle, win gold from your
    enemies on victory, and now you will be able to see your gold accumulate in your
    pause menu. We can use these same variables to add to any menu system, including
    a shop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Item data
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are finished with the gold creation, we need to create one more
    thing before we make a shop, that is, items. There are many ways to make items,
    but it is best to keep an inventory and stats of items through the use of Data
    Tables. So, let''s first create a new C++ `FTableRowBase` struct similar to the
    `CharacterInfo` structs that you previously created. Our files will be called
    `ItemsData.h` and `ItemsData.cpp`, and we will put these files where our other
    data is; that is, by navigating to **Source** | **RPG** | **Data**. The `ItemsData.cpp`
    source file will include the following two header files:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ItemsData.h` header file will contain definitions of all the item data
    that we will need. In this case, the item data will be stats that the player has,
    since items will most likely affect stats. The stats only need to be of the integer
    type and read-enabled since we won''t be changing the value of any of the items
    directly. Your `ItemsData.h` file will look something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, you can recompile, and you are now ready to create your own Data
    Table. Since we are creating a shop, let's create a Data Table for the shop in
    **Content Browser** and in the `Data` folder by navigating to **Miscellaneous**
    | **Data Table**, and then using **Items Data** as the structure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Item data](img/B04548_07_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Name your new Data Table **Items_Shop**, and then open the Data Table. Here,
    you can add as many items as you want with whatever kinds of stat you would like
    using the **Row Editor** tab. To make an item, first click on the **Add** button
    in **Row Editor** to add a new row. Then, click on the textbox next to **Rename**
    and type in **Potion**. You will see that you have a potion item with all the
    other stats zeroed out:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Item data](img/B04548_07_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Next, give it some values. I will make this a healing potion; therefore, I will
    give it an **HP** value of **50** and a **Gold** value of **10**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Item data](img/B04548_07_08.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'The purpose of this Data Table is also to store every item that our shop owner
    will carry. So, feel free to add more items to this Data Table:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Item data](img/B04548_07_09.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: The shop screen framework
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are done with creating items, we can move on to creating the shop.
    In the previous chapter, we created dialog boxes for our shop owner, and in one
    of the dialog boxes, we created a **Shop** button that, when clicked, will open
    up a shop menu. Let''s create this shop menu by first creating a new Widget Blueprint
    by navigating to **Content** | **Blueprints** | **UI** | **NPC**. We will call
    this Widget Blueprint **Shop** and open it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_10.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: We will make the shop in a similar format to that of our pause menu, but we
    will keep it simple because all we need for now is a Scroll Box that will hold
    the shop's items, as well as an area for gold, and an **Exit** button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To expedite this process, you can simply copy and paste the elements from your
    existing menu systems that you wish to reuse into the **Shop** Widget Blueprint.
    We can do this by navigating to **Content** | **Blueprints** | **UI** and opening
    the **Pause_Main** and **Pause_Inventory** Widget Blueprints, which we created
    in the previous chapters. From **Pause_Main**, we can copy the **Menu_Gold**,
    **Editable_Gold**, **Button_Exit**, **Menu_Exit**, and **BG_Color**, and paste
    them into the **Shop** Widget Blueprint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also copy the **ScrollBox_Inventory** and **Title_Inventory** from the
    **Pause_Inventory** Widget Blueprint and paste them into the **Shop** Widget Blueprint.
    When you are done, your **Shop** Widget Blueprint will look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_11.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Here, edit the **Shop** Widget Blueprint so that the title reads as **Shop**
    instead of **Inventory**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_12.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'You will now need to link the **Shop** Widget Blueprint to the Shop button
    in the **Shop_Welcome** Widget Blueprint. To do this, open the **Shop_Welcome**
    Widget Blueprint by navigating to **Content** | **Blueprints** | **UI** | **NPC**,
    select **Button_Shop**, and then click on the **+** button to the right of the
    **OnClicked** event by navigating to **Details** | **Events**:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_13.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'This will automatically open the graph with a newly created **OnClicked** event
    for **Button_Shop**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can simply mimic the same actions you used to open the dialog boxes
    when the player clicks on the **Talk** button. The only difference is that, instead
    of creating a new **Shop_Talk** widget, the **Shop** widget will create the **Create
    Shop Widget** for you. The graph for **Button_Shop** will look like the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_15.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'You will now be able to test the shop by talking to the NPC and clicking on
    the **Shop** button, which will now open the shop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_16.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that nothing is yet visible in the shop, not even the gold.
    To display the gold on the screen, you need to repeat the steps you performed
    earlier in this chapter when you displayed the gold in the **Pause_Main** Widget
    Blueprint. But this time, open the graph in the **Shop** Widget Blueprint, and
    then create a binding for the **Editable_Gold** Text Block by navigating to **Details**
    | **Context**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_17.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Your graph will automatically open, and you will notice a **Get Editable Gold
    Text** function with a **ReturnNode**. Since you will be getting the gold from
    the same game instance that you did when getting the gold from the **Pause_Main**
    Widget Blueprint, you can simply copy and paste all the nodes from the **Get Editable
    Gold Text** function into **Pause_Main**, and link them to the **Get Editable
    Text** function in the **Shop** Widget Blueprint. When you are done, the **Get
    Editable Gold Text** function in the **Shop** Widget Blueprint will look like
    this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_18.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create the **Button_Exit** functionality in the **Shop** Widget
    Blueprint by creating an **OnClicked** event (by navigating to **Details** | **Events**)
    for **Button_Exit**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_19.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'When the graph opens, link the **OnClicked** event to the **Remove from Parent**
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![The shop screen framework](img/B04548_07_20.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: At this point, when you test the shop, you will see the gold and be able to
    exit the shop screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The item button framework
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we link our items to the shop, we will first need to create a framework
    in which the items are placed in the shop. What we would like to do is create
    a button for each item that the shop owner sells but, in order to make the interface
    scalable in such a way that NPCs can hold different selectable items, it would
    be wise to create a Scroll Box framework that holds a single button with a default
    value for the item's text/description. We can then dynamically draw the button
    for as many items as the shop owner carries, as well as dynamically draw the text
    on each button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must first create a Widget Blueprint by navigating to **Content**
    | **Blueprints** | **UI** and call it **Item**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_21.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Open **Item**. Since we are going to make the items clickable, we will program
    a button. To make the button, all that we will need is the button itself and text
    for the button; we will not need a Canvas Panel because we will eventually be
    adding this button to the Scroll Box of our shop. So, from the **Hierarchy** tab,
    delete the Canvas Panel, and drag a button from **Palette**. We will name this
    button, **Button_Item**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_24.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will place a Text Block in the button that we just created and
    name it **TextBlock_Item**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_25.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Once done, navigate to **Details** | **Content**, and create a binding for
    the text in the Text Block. This will automatically open the graph with a **Get
    Text** function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_26.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Create a new **Item** variable of the **Text** type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_27.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'Drag the **Item** variable into the graph, select **Get** to drop in a getter
    for the **Item** variable, and then link it to the **Return Value** pin of **ReturnNode**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![The item button framework](img/B04548_07_28.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Linking the item data
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is now time to link the item data that we created at the beginning of this
    chapter to the shop using the **Item** button framework we just created. To do
    this, we will add a functionality to display every item in our **Items_Shop**
    Data Table using the **Item** button framework that we created in the previous
    section. First, open **Event Graph** in the **Shop** Widget Blueprint. Link the
    **Get Data Table Row Names** function located in Data Tables to **Event Construct**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_29.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'Then, from the **Select Asset** drop-down menu, select **Items_Shop**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_30.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'This will get the names of every item in the **Items_Shop** Data table that
    we created earlier in this chapter. Here, we need to create an instance of the
    **Item** Widget Blueprint for every item row. This will create a button for every
    item with the correct corresponding item name. To do this, create a **ForEachLoop**
    located at **Array** under **Utilities** and allow the **Get Data Table Row Names**
    function to execute it. Link the **Out Row Names** pin to the **Array** pin of
    the **ForEachLoop** so that every row in the Data Table becomes an element of
    the array in the **ForEachLoop**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_31.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to loop through each element of the array of row names and, for
    each row, we need to create a new instance of the **Item** Widget Blueprint. To
    do this, link the **Create Item Widget** action located under **User Interface**
    to the **Loop Body** pin in the **ForEachLoop**. Let the class instance be **Item**
    that can be selected from the **Class** drop-down menu in the **Create Item Widget**
    action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_41.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Then, for every item created, set the **Item** variable that is created for
    every **Item** widget instance to the value of each element in the array. You
    can create the **Set Item** action, by right-clicking anywhere in **Event Graph**,
    unchecking **Context Sensitive**, and locating **Set Item** by navigating to **Class**
    | **Item**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_33.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: '**Create Item Widget** can now launch **Set Item**, and set the **Return Value**
    pin value of **Create Item Widget** to the **Target** pin value of **Item**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_32.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we have not yet set the element of the array to the item that
    we set in the **Item** widget; so, to do this, we can simply link the **Array
    Element** pin from the **ForEachLoop** to the **Item** pin in the **Set Item**
    action:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_36.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we are going to have our Scroll Box that we created in the **Shop**
    Widget Blueprint hold all of our item instances. To do this, after we set each
    item to the correct name, we will add the item instance as a child to the **ScrollBox_Inventory**
    Scroll Box that we created earlier in this chapter. This is done by simply calling
    the **Add Child** function located in **Panel** under **Widget** after we set
    the item:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_37.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Then, we set the **Content** value of the child to the **Return Value** pin
    of the item:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_38.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, the **Target** pin of the child needs to be linked to **ScrollBox_Inventory**,
    which can be dragged into your **Event Graph** from **Variables**. If you do not
    see the **ScrollBox_Inventory** variable in your variables, go back to the **Designer
    View**, select the **ScrollBox_Inventory**, and make sure **is variable** is checked:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking the item data](img/B04548_07_39.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'At this point, if you test your shop, you will see the shop populated with
    every item listed in your Data Table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你测试你的商店，你将看到商店中填充了你数据表中列出的每一个物品：
- en: '![Linking the item data](img/B04548_07_40.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![链接物品数据](img/B04548_07_40.jpg)'
- en: You will be able to add even more items to your Data Table and these items will
    automatically appear in your shop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够向你的数据表中添加更多物品，这些物品将自动出现在你的商店中。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a currency system for our game along with the ability
    for our enemies to drop gold. We also created a new set of data that contains
    items and their stats, and we have now populated the shop owner's store to display
    the items currently for sale in the shop.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为游戏创建了一个货币系统，并使我们的敌人能够掉落金币。我们还创建了一套新的数据集，包含物品及其属性，并且现在我们已经填充了店主商店，以显示商店中目前出售的物品。
- en: In the next chapter, we will add the buying functionality to the shop along
    with the usage of an item and consumption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为商店添加购买功能，以及物品的使用和消耗。
