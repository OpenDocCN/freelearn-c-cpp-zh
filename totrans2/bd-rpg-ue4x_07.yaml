- en: Chapter 7. Gold, Items, and a Shop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 金币、物品和商店
- en: 'Now that you have created an NPC that talks to the player, it is time to allow
    the NPC to help the player. In this chapter, we will use the NPC as a shop owner,
    displaying items for the user to buy. Before we do this, the user is going to
    need some sort of currency to buy the items. We will cover the following topics
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个与玩家交谈的NPC，是时候允许NPC帮助玩家了。在本章中，我们将使用NPC作为店主，向用户展示可以购买的物品。在我们这样做之前，用户将需要某种货币来购买物品。本章我们将涵盖以下主题：
- en: Setting and getting gold instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和获取金币实例
- en: Item data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品数据
- en: The shop screen framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店屏幕框架
- en: The item button framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品按钮框架
- en: Linking the item data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接物品数据
- en: Setting and getting gold instances
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和获取金币实例
- en: While we move on to making a shopping interface, via the **Shop** button, we
    must first be able to pull the currency in order to pay for items in the shop.
    In a previous chapter, we discussed and made placeholders for gold, but we did
    not actually create gold values. In this game, we would like gold to be dropped
    by enemies at the end of battle. In this case, enemies will need some sort of
    gold data that we can add to the player's gold data (eventually, items will need
    this gold data that is tied to them as well). In [Chapter 4](ch04.html "Chapter 4. Pause
    Menu Framework"), *Pause Menu Framework*, we created a pause menu that has a gold
    placeholder, and we will now add gold to this pause menu.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续制作购物界面，通过**Shop**按钮时，我们首先必须能够提取货币，以便在商店中购买物品。在之前的一章中，我们讨论并创建了金币的占位符，但实际上我们没有创建金币值。在这个游戏中，我们希望金币在战斗结束后由敌人掉落。在这种情况下，敌人需要某种金币数据，我们可以将其添加到玩家的金币数据中（最终，物品也需要这种与它们关联的金币数据）。在[第4章](ch04.html
    "Chapter 4. Pause Menu Framework")，*暂停菜单框架*中，我们创建了一个具有金币占位符的暂停菜单，现在我们将向这个暂停菜单添加金币。
- en: 'First, let''s add a `Gold` property to `FEnemyInfo.h`. Navigate to **Source**
    | **RPG** | **Data**, open `FEnemyInfo.h`, and add a `Gold` property of an integer
    data type to your `EnemyInfo` table, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`FEnemyInfo.h`中添加一个`Gold`属性。导航到**Source** | **RPG** | **Data**，打开`FEnemyInfo.h`，并在你的`EnemyInfo`表中添加一个整型数据类型的`Gold`属性，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We now need to tie the `Gold` property with our standard `GameCharacter` properties
    so that we can update any instance of an enemy with the proper gold value. Next,
    you will open `GameCharacter.h`, which is located in **RPG** under **Source**,
    and add a public `UProperty` to the `UCharacter` class for gold similar to that
    in `FEnemyInfo.h`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将`Gold`属性与我们的标准`GameCharacter`属性关联起来，以便我们可以更新任何敌人的实例，使其具有正确的金币值。接下来，你将打开位于**Source**下的**RPG**文件夹中的`GameCharacter.h`文件，并在`UCharacter`类中添加一个与`FEnemyInfo.h`中类似的公共`UProperty`用于金币：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, head into `GameCharacter.cpp` to set the return value of the gold that
    is equal to the value set in `EnemyInfo`, so that each instance of this particular
    enemy will return the amount of gold set in the enemy''s data table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入`GameCharacter.cpp`来设置金币的返回值，使其等于在`EnemyInfo`中设置的值，这样这个特定敌人的每个实例都将返回敌人数据表中设置的金币数量：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you are finished, the enemy''s character information in `GameCharacter.cpp`
    will look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，`GameCharacter.cpp`中的敌人角色信息将看起来像这样：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now need to choose when to accumulate the gold, and in this case, we will
    accumulate the gold from combat. So, navigate to **Source** | **RPG** | **Combat**,
    open `CombatEngine.h`, and create a public gold variable that we will use to store
    all the gold won in the battle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要选择何时累积金币，在这种情况下，我们将从战斗中累积金币。因此，导航到**Source** | **RPG** | **Combat**，打开`CombatEngine.h`，创建一个公共的金币变量，我们将用它来存储在战斗中赢得的所有金币：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you have finished declaring the `GoldTotal` variable, the `CombatEngine.h`
    file will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成声明`GoldTotal`变量后，`CombatEngine.h`文件将看起来像这样：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step that we need to perform is telling the engine when to give the
    gold to the player. As mentioned earlier, we want players to win gold from enemies
    that can easily be integrated into our combat engine. Navigate to **Source** |
    **RPG** | **Combat**, and open `CombatEngine.cpp`. Let''s first scroll down to
    the `for` loop that we created in [Chapter 3](ch03.html "Chapter 3. Exploration
    and Combat"), *Exploration and Combat*, to check for a victory. Just above this
    `for` loop, declare a new `Gold` integer, and set it to `0`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要执行的操作是告诉引擎何时给玩家金币。如前所述，我们希望玩家能够从可以轻松集成到我们的战斗引擎中的敌人那里赢得金币。导航到**源** | **RPG**
    | **战斗**，打开`CombatEngine.cpp`文件。让我们首先滚动到我们在[第3章](ch03.html "第3章。探索和战斗")中创建的`for`循环，检查胜利。在这个`for`循环上方，声明一个新的`Gold`整数，并将其设置为`0`：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will assure that, if we don''t have a victory and need to cycle through
    the `for` loop again, the gold gained in battle will reset to 0\. Next, we need
    to accumulate the gold from every enemy killed; thus, within the `for` loop, we
    have `Gold` increment by each enemy''s gold:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保，如果我们没有胜利并需要再次循环`for`循环，战斗中获得的金币将重置为0。接下来，我们需要累积每个被击败的敌人的金币；因此，在`for`循环中，我们将`Gold`增加每个敌人的金币：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your `for` loop will now look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`for`循环现在将看起来像这样：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the `for` loop, you will still have an `if` condition that checks whether
    the enemy party is dead; if the enemy party is dead, the combat phase will change
    to the victory phase. If the condition is `true`, it means that we won the battle;
    therefore, we should be rewarded with the gold from the `for` loop. Since the
    `Gold` variable that we want to add is in the `GoldTotal` variable, we simply
    set the local `Gold` variable to the new value of `GoldTotal`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环之后，你仍然会有一个`if`条件来检查敌人党派是否已死亡；如果敌人党派已死亡，战斗阶段将变为胜利阶段。如果条件为`true`，这意味着我们赢得了战斗；因此，我们应该从`for`循环中获得金币奖励。由于我们想要添加的`Gold`变量在`GoldTotal`变量中，我们只需将局部`Gold`变量设置为`GoldTotal`的新值：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you are finished, your `if` condition will now look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的`if`条件现在将看起来像这样：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have set enemies to drop gold after the player is victorious in
    battle, the next thing that we need to do is add gold to our game data; more specifically,
    it would be best to add it in `RPGGameInstance.h`, since an instance of the game
    will always be active. It would be unwise to add the gold data to a party member
    unless there is a specific party member who will always be in the game. So, let's
    open `RPGGameInstance.h` located in **RPG** under **Source**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置敌人在玩家在战斗中获胜后掉落金币，接下来我们需要做的是将金币添加到我们的游戏数据中；更具体地说，最好在`RPGGameInstance.h`中添加它，因为游戏实例始终处于活动状态。将金币数据添加到党派成员中是不明智的，除非有一个特定的党派成员将始终在游戏中。因此，让我们打开位于**源**下的**RPG**目录中的`RPGGameInstance.h`文件。
- en: 'As a public property, add another integer to `Game Data` that we will call
    `GameGold`. Also, ensure that `GameGold` is read- and write-enabled because we
    want to be able to add and subtract gold; therefore editing of `GameGold` must
    be enabled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为公共属性，向`游戏数据`中添加另一个整数，我们将其称为`游戏金币`。同时，确保`游戏金币`是可读和可写的，因为我们希望能够添加和减去金币；因此，必须启用`游戏金币`的编辑：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we can create instances of `GameGold`, go to your `RPGGameMode.cpp`
    file where you originally set up the logic for the game over and victory conditions;
    in the victory condition, create a pointer to `URPGGameInstance` that we will
    call `gameInstance`, and set it equal to a cast to `GetGameInstance`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`GameGold`的实例，前往你原来设置游戏结束和胜利条件的`RPGGameMode.cpp`文件；在胜利条件中，创建一个指向`URPGGameInstance`的指针，我们将其称为`gameInstance`，并将其设置为`GetGameInstance`的转换：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now use `gameInstance` to add the total gold that we got from the battle
    to `GameGold`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`gameInstance`将我们从战斗中获得的总金币添加到`GameGold`：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, the value of `GameGold` that we are using as the player''s gold
    will now be incremented by the gold won in the battle. The `tick` function in
    `RPGGameMode.cpp` will now look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们用作玩家金币的`GameGold`值现在将增加战斗中赢得的金币。`RPGGameMode.cpp`中的`tick`函数现在将看起来像这样：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you need to make sure that all your changes are saved and recompile your
    entire project (you may need to restart UE4).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要确保所有更改都已保存，并重新编译整个项目（你可能需要重新启动UE4）。
- en: 'We can now adjust the gold value of each enemy character that we have from
    the enemy''s Data Table. In **Content Browser**, navigate to the **Enemies** Data
    Table located at **Data** under **Content**. In the Data Table, you will now see
    a **Gold** row. Add any value that you want to the **Gold** row, and save the
    Data Table:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调整每个敌人角色的金币值，这些值来自敌人的数据表。在**内容浏览器**中，导航到位于**内容**下的**敌人**数据表，在**数据**下。在数据表中，你现在将看到一个**金币**行。将任何你想要的值添加到**金币**行，并保存数据表：
- en: '![Setting and getting gold instances](img/B04548_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![设置和获取金币实例](img/B04548_07_01.jpg)'
- en: 'Now that an enemy has a gold value, there is a real value that is bound to
    the `Gold` variable in `EnemyInfo` that gets added to `GameGold` if the player
    is victorious in battle. However, we need to display that gold; luckily, we still
    have a placeholder for the gold in our pause menu. Open the **Pause_Main** Widget
    Blueprint, and click on the **Editable_Gold** Text Block that we created in [Chapter
    4](ch04.html "Chapter 4. Pause Menu Framework"), *Pause Menu Framework*. In the
    **Details** panel, go to **Content** and create a binding for the Text Block,
    which will open the graph for **Get Editable Gold Text**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然敌人有了金币值，就有了一个与`EnemyInfo`中的`Gold`变量绑定的实际值，如果玩家在战斗中获胜，这个值就会被添加到`GameGold`中。然而，我们需要显示这些金币；幸运的是，我们暂停菜单中仍然有一个金币占位符。打开**Pause_Main**
    Widget Blueprint，点击我们在[第4章](ch04.html "第4章。暂停菜单框架")中创建的**Editable_Gold**文本块，*暂停菜单框架*。在**详细信息**面板中，转到**内容**并创建一个文本块的绑定，这将打开**获取可编辑金币文本**的图表：
- en: '![Setting and getting gold instances](img/B04548_07_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![设置和获取金币实例](img/B04548_07_02.jpg)'
- en: 'The first thing that we need to do is get the game instance of **RPGGameInstance**
    by creating a **Get Game Instance** function located under **Game** and setting
    it as an object of **Cast To RPGGameInstance**:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是通过在**游戏**下创建一个**获取游戏实例**函数来获取**RPGGameInstance**的游戏实例，并将其设置为**Cast
    To RPGGameInstance**的对象：
- en: '![Setting and getting gold instances](img/B04548_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![设置和获取金币实例](img/B04548_07_03.jpg)'
- en: 'We can then get the `GameGold` variable from **RPGGameInstance**, which is
    the variable that stores the current gold total for the game. It is located in
    **Game Data** under **Variables**. Link it to the **As RPGGameInstance** pin in
    **Cast To RPGGameInstance**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从**RPGGameInstance**获取`GameGold`变量，这是存储游戏当前金币总数的变量。它位于**游戏数据**下的**变量**中。将其链接到**Cast
    To RPGGameInstance**中的**As RPGGameInstance**引脚：
- en: '![Setting and getting gold instances](img/B04548_07_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![设置和获取金币实例](img/B04548_07_04.jpg)'
- en: 'Lastly, link **Game Gold** to **Return Value** in **ReturnNode** and allow
    **Get Editable Gold Text** to trigger **Cast To RPGGameInstance**, which will
    trigger **ReturnNode**. Your **Get Editable Gold Text** binding will now look
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将**游戏金币**链接到**ReturnNode**中的**返回值**，并允许**获取可编辑金币文本**触发**Cast To RPGGameInstance**，这将触发**ReturnNode**。你的**获取可编辑金币文本**绑定现在将看起来像这样：
- en: '![Setting and getting gold instances](img/B04548_07_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![设置和获取金币实例](img/B04548_07_05.jpg)'
- en: If you test this now, you will be able to get into battle, win gold from your
    enemies on victory, and now you will be able to see your gold accumulate in your
    pause menu. We can use these same variables to add to any menu system, including
    a shop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试，你将能够进入战斗，在胜利后从敌人那里赢得金币，现在你将能够在暂停菜单中看到你的金币积累。我们可以使用这些相同的变量来添加到任何菜单系统，包括商店。
- en: Item data
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物品数据
- en: 'Now that we are finished with the gold creation, we need to create one more
    thing before we make a shop, that is, items. There are many ways to make items,
    but it is best to keep an inventory and stats of items through the use of Data
    Tables. So, let''s first create a new C++ `FTableRowBase` struct similar to the
    `CharacterInfo` structs that you previously created. Our files will be called
    `ItemsData.h` and `ItemsData.cpp`, and we will put these files where our other
    data is; that is, by navigating to **Source** | **RPG** | **Data**. The `ItemsData.cpp`
    source file will include the following two header files:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了金币的创建，在创建商店之前，我们还需要创建另一件事，那就是物品。制作物品有很多方法，但最好通过使用数据表来保持物品的库存和统计数据。因此，让我们首先创建一个新的C++
    `FTableRowBase`结构体，类似于你之前创建的`CharacterInfo`结构体。我们的文件将命名为`ItemsData.h`和`ItemsData.cpp`，我们将把这些文件放在我们的其他数据旁边；即通过导航到**源**
    | **RPG** | **数据**。`ItemsData.cpp`源文件将包含以下两个头文件：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ItemsData.h` header file will contain definitions of all the item data
    that we will need. In this case, the item data will be stats that the player has,
    since items will most likely affect stats. The stats only need to be of the integer
    type and read-enabled since we won''t be changing the value of any of the items
    directly. Your `ItemsData.h` file will look something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsData.h`头文件将包含所有所需物品数据的定义。在这种情况下，物品数据将是玩家拥有的统计数据，因为物品很可能会影响统计数据。统计数据只需要是整数类型并且可读，因为我们不会直接更改任何物品的值。你的`ItemsData.h`文件看起来可能像这样：'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, you can recompile, and you are now ready to create your own Data
    Table. Since we are creating a shop, let's create a Data Table for the shop in
    **Content Browser** and in the `Data` folder by navigating to **Miscellaneous**
    | **Data Table**, and then using **Items Data** as the structure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以重新编译，现在你就可以创建你自己的数据表了。由于我们正在创建商店，让我们在**内容浏览器**和`数据`文件夹中创建一个商店的数据表，方法是导航到**杂项**
    | **数据表**，然后使用**物品数据**作为结构。
- en: '![Item data](img/B04548_07_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![物品数据](img/B04548_07_06.jpg)'
- en: 'Name your new Data Table **Items_Shop**, and then open the Data Table. Here,
    you can add as many items as you want with whatever kinds of stat you would like
    using the **Row Editor** tab. To make an item, first click on the **Add** button
    in **Row Editor** to add a new row. Then, click on the textbox next to **Rename**
    and type in **Potion**. You will see that you have a potion item with all the
    other stats zeroed out:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的新数据表命名为**Items_Shop**，然后打开数据表。在这里，你可以使用**行编辑器**选项卡添加尽可能多的物品，并使用你想要的任何类型的统计数据。要创建一个物品，首先点击**行编辑器**中的**添加**按钮以添加一个新行。然后，点击**重命名**旁边的文本框并输入**药水**。你会看到你有一个药水物品，其他统计数据都为零：
- en: '![Item data](img/B04548_07_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![物品数据](img/B04548_07_07.jpg)'
- en: Next, give it some values. I will make this a healing potion; therefore, I will
    give it an **HP** value of **50** and a **Gold** value of **10**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给它一些值。我将把它变成一个治疗药水；因此，我将给它一个**HP**值为**50**和一个**Gold**值为**10**。
- en: '![Item data](img/B04548_07_08.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![物品数据](img/B04548_07_08.jpg)'
- en: 'The purpose of this Data Table is also to store every item that our shop owner
    will carry. So, feel free to add more items to this Data Table:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据表的目的也是为了存储我们的店主将携带的每一件物品。所以，请随意向此数据表添加更多物品：
- en: '![Item data](img/B04548_07_09.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![物品数据](img/B04548_07_09.jpg)'
- en: The shop screen framework
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店屏幕框架
- en: 'Now that we are done with creating items, we can move on to creating the shop.
    In the previous chapter, we created dialog boxes for our shop owner, and in one
    of the dialog boxes, we created a **Shop** button that, when clicked, will open
    up a shop menu. Let''s create this shop menu by first creating a new Widget Blueprint
    by navigating to **Content** | **Blueprints** | **UI** | **NPC**. We will call
    this Widget Blueprint **Shop** and open it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了物品的创建，我们可以继续创建商店。在上一章中，我们为我们的店主创建了对话框，并在其中一个对话框中创建了一个**商店**按钮，点击该按钮将打开商店菜单。让我们通过首先创建一个新的Widget
    Blueprint来创建这个商店菜单，方法是导航到**内容** | **蓝图** | **UI** | **NPC**。我们将把这个Widget Blueprint命名为**商店**并打开它：
- en: '![The shop screen framework](img/B04548_07_10.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_10.jpg)'
- en: We will make the shop in a similar format to that of our pause menu, but we
    will keep it simple because all we need for now is a Scroll Box that will hold
    the shop's items, as well as an area for gold, and an **Exit** button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使商店的格式与我们的暂停菜单类似，但我们会保持简单，因为我们现在只需要一个滚动框来存放商店的物品，以及一个存放金币的区域和一个**退出**按钮。
- en: To expedite this process, you can simply copy and paste the elements from your
    existing menu systems that you wish to reuse into the **Shop** Widget Blueprint.
    We can do this by navigating to **Content** | **Blueprints** | **UI** and opening
    the **Pause_Main** and **Pause_Inventory** Widget Blueprints, which we created
    in the previous chapters. From **Pause_Main**, we can copy the **Menu_Gold**,
    **Editable_Gold**, **Button_Exit**, **Menu_Exit**, and **BG_Color**, and paste
    them into the **Shop** Widget Blueprint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快这个进程，你可以简单地复制并粘贴你希望重新使用的现有菜单系统中的元素到**商店**Widget Blueprint中。我们可以通过导航到**内容**
    | **蓝图** | **UI**并打开我们在上一章中创建的**Pause_Main**和**Pause_Inventory**Widget Blueprints来实现这一点。从**Pause_Main**，我们可以复制**Menu_Gold**、**Editable_Gold**、**Button_Exit**、**Menu_Exit**和**BG_Color**，并将它们粘贴到**商店**Widget
    Blueprint中。
- en: 'We can also copy the **ScrollBox_Inventory** and **Title_Inventory** from the
    **Pause_Inventory** Widget Blueprint and paste them into the **Shop** Widget Blueprint.
    When you are done, your **Shop** Widget Blueprint will look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从**Pause_Inventory**小部件蓝图复制**ScrollBox_Inventory**和**Title_Inventory**并将其粘贴到**商店**小部件蓝图中。完成时，你的**商店**小部件蓝图将如下所示：
- en: '![The shop screen framework](img/B04548_07_11.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_11.jpg)'
- en: 'Here, edit the **Shop** Widget Blueprint so that the title reads as **Shop**
    instead of **Inventory**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编辑**商店**小部件蓝图，使其标题显示为**商店**而不是**库存**：
- en: '![The shop screen framework](img/B04548_07_12.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_12.jpg)'
- en: 'You will now need to link the **Shop** Widget Blueprint to the Shop button
    in the **Shop_Welcome** Widget Blueprint. To do this, open the **Shop_Welcome**
    Widget Blueprint by navigating to **Content** | **Blueprints** | **UI** | **NPC**,
    select **Button_Shop**, and then click on the **+** button to the right of the
    **OnClicked** event by navigating to **Details** | **Events**:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将**商店**小部件蓝图链接到**Shop_Welcome**小部件蓝图中的商店按钮。为此，通过导航到**内容** | **蓝图** | **UI**
    | **NPC**打开**Shop_Welcome**小部件蓝图，选择**Button_Shop**，然后通过导航到**细节** | **事件**点击**OnClicked**事件右侧的**+**按钮：
- en: '![The shop screen framework](img/B04548_07_13.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_13.jpg)'
- en: 'This will automatically open the graph with a newly created **OnClicked** event
    for **Button_Shop**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动打开一个带有为**Button_Shop**创建的新**OnClicked**事件的图表：
- en: '![The shop screen framework](img/B04548_07_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_14.jpg)'
- en: 'Here, you can simply mimic the same actions you used to open the dialog boxes
    when the player clicks on the **Talk** button. The only difference is that, instead
    of creating a new **Shop_Talk** widget, the **Shop** widget will create the **Create
    Shop Widget** for you. The graph for **Button_Shop** will look like the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以简单地模仿你在玩家点击**交谈**按钮时使用的相同操作。唯一的区别是，你不需要创建一个新的**Shop_Talk**小部件，而是**商店**小部件会为你创建**创建商店小部件**。**Button_Shop**的图表将如下截图所示：
- en: '![The shop screen framework](img/B04548_07_15.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_15.jpg)'
- en: 'You will now be able to test the shop by talking to the NPC and clicking on
    the **Shop** button, which will now open the shop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过与NPC交谈并点击**商店**按钮来测试商店，这将打开商店：
- en: '![The shop screen framework](img/B04548_07_16.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_16.jpg)'
- en: 'You will notice that nothing is yet visible in the shop, not even the gold.
    To display the gold on the screen, you need to repeat the steps you performed
    earlier in this chapter when you displayed the gold in the **Pause_Main** Widget
    Blueprint. But this time, open the graph in the **Shop** Widget Blueprint, and
    then create a binding for the **Editable_Gold** Text Block by navigating to **Details**
    | **Context**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到商店中还没有任何东西可见，甚至没有金币。要在屏幕上显示金币，你需要重复本章前面在**Pause_Main**小部件蓝图显示金币时执行的步骤。但这次，打开**商店**小部件蓝图中的图表，然后通过导航到**细节**
    | **上下文**为**Editable_Gold**文本块创建一个绑定：
- en: '![The shop screen framework](img/B04548_07_17.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_17.jpg)'
- en: 'Your graph will automatically open, and you will notice a **Get Editable Gold
    Text** function with a **ReturnNode**. Since you will be getting the gold from
    the same game instance that you did when getting the gold from the **Pause_Main**
    Widget Blueprint, you can simply copy and paste all the nodes from the **Get Editable
    Gold Text** function into **Pause_Main**, and link them to the **Get Editable
    Text** function in the **Shop** Widget Blueprint. When you are done, the **Get
    Editable Gold Text** function in the **Shop** Widget Blueprint will look like
    this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你的图表将自动打开，你会注意到一个带有**ReturnNode**的**获取可编辑金币文本**函数。由于你将从与从**Pause_Main**小部件蓝图获取金币相同的游戏实例中获取金币，你可以简单地从**获取可编辑金币文本**函数中复制并粘贴所有节点到**Pause_Main**，并将它们链接到**商店**小部件蓝图中的**获取可编辑文本**函数。完成时，**商店**小部件蓝图中的**获取可编辑金币文本**函数将如下所示：
- en: '![The shop screen framework](img/B04548_07_18.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_18.jpg)'
- en: 'Next, we will create the **Button_Exit** functionality in the **Shop** Widget
    Blueprint by creating an **OnClicked** event (by navigating to **Details** | **Events**)
    for **Button_Exit**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在**商店**小部件蓝图中创建**Button_Exit**功能，通过为**Button_Exit**创建一个**OnClicked**事件（通过导航到**细节**
    | **事件**）：
- en: '![The shop screen framework](img/B04548_07_19.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_19.jpg)'
- en: 'When the graph opens, link the **OnClicked** event to the **Remove from Parent**
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当图打开时，将**OnClicked**事件链接到**从父级移除**函数：
- en: '![The shop screen framework](img/B04548_07_20.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![商店屏幕框架](img/B04548_07_20.jpg)'
- en: At this point, when you test the shop, you will see the gold and be able to
    exit the shop screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当你测试商店时，你会看到金币并能够退出商店屏幕。
- en: The item button framework
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目按钮框架
- en: Before we link our items to the shop, we will first need to create a framework
    in which the items are placed in the shop. What we would like to do is create
    a button for each item that the shop owner sells but, in order to make the interface
    scalable in such a way that NPCs can hold different selectable items, it would
    be wise to create a Scroll Box framework that holds a single button with a default
    value for the item's text/description. We can then dynamically draw the button
    for as many items as the shop owner carries, as well as dynamically draw the text
    on each button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将项目链接到商店之前，我们首先需要创建一个框架，其中项目被放置在商店中。我们希望为商店老板出售的每个项目创建一个按钮，但为了使界面可扩展，以便NPC可以持有不同的可选择物品，创建一个包含单个按钮的滚动框框架，该按钮具有项目文本/描述的默认值，将是明智的。然后我们可以动态地绘制按钮，以及商店老板携带的物品数量，以及每个按钮上的文本。
- en: 'To do this, we must first create a Widget Blueprint by navigating to **Content**
    | **Blueprints** | **UI** and call it **Item**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要通过导航到**内容** | **蓝图** | **UI**来创建一个Widget蓝图，并将其命名为**Item**：
- en: '![The item button framework](img/B04548_07_21.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_21.jpg)'
- en: 'Open **Item**. Since we are going to make the items clickable, we will program
    a button. To make the button, all that we will need is the button itself and text
    for the button; we will not need a Canvas Panel because we will eventually be
    adding this button to the Scroll Box of our shop. So, from the **Hierarchy** tab,
    delete the Canvas Panel, and drag a button from **Palette**. We will name this
    button, **Button_Item**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Item**。由于我们将使项目可点击，我们将编写一个按钮。为了创建按钮，我们只需要按钮本身和按钮上的文本；我们不需要Canvas面板，因为我们最终会将此按钮添加到商店的滚动框中。因此，从**层次结构**选项卡中删除Canvas面板，并从**调色板**中拖动一个按钮。我们将把这个按钮命名为**Button_Item**：
- en: '![The item button framework](img/B04548_07_24.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_24.jpg)'
- en: 'Finally, we will place a Text Block in the button that we just created and
    name it **TextBlock_Item**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在刚刚创建的按钮中放置一个文本块，并将其命名为**TextBlock_Item**：
- en: '![The item button framework](img/B04548_07_25.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_25.jpg)'
- en: 'Once done, navigate to **Details** | **Content**, and create a binding for
    the text in the Text Block. This will automatically open the graph with a **Get
    Text** function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，导航到**详细信息** | **内容**，并为文本块中的文本创建一个绑定。这将自动打开带有**获取文本**函数的图：
- en: '![The item button framework](img/B04548_07_26.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_26.jpg)'
- en: 'Create a new **Item** variable of the **Text** type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的**Item**变量，类型为**文本**：
- en: '![The item button framework](img/B04548_07_27.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_27.jpg)'
- en: 'Drag the **Item** variable into the graph, select **Get** to drop in a getter
    for the **Item** variable, and then link it to the **Return Value** pin of **ReturnNode**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Item**变量拖入图中，选择**获取**以在**Item**变量中放置一个获取器，并将其链接到**ReturnNode**的**返回值**引脚：
- en: '![The item button framework](img/B04548_07_28.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![项目按钮框架](img/B04548_07_28.jpg)'
- en: Linking the item data
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接项目数据
- en: 'It is now time to link the item data that we created at the beginning of this
    chapter to the shop using the **Item** button framework we just created. To do
    this, we will add a functionality to display every item in our **Items_Shop**
    Data Table using the **Item** button framework that we created in the previous
    section. First, open **Event Graph** in the **Shop** Widget Blueprint. Link the
    **Get Data Table Row Names** function located in Data Tables to **Event Construct**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们在本章开头创建的项目数据通过我们刚刚创建的**Item**按钮框架链接到商店了。为此，我们将添加一个功能，使用我们在上一节中创建的**Item**按钮框架显示我们**Items_Shop**数据表中的每个项目。首先，在**Shop**
    Widget蓝图中打开**事件图**。将位于数据表中的**获取数据表行名称**函数链接到**事件构造**：
- en: '![Linking the item data](img/B04548_07_29.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_29.jpg)'
- en: 'Then, from the **Select Asset** drop-down menu, select **Items_Shop**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从**选择资产**下拉菜单中选择**Items_Shop**：
- en: '![Linking the item data](img/B04548_07_30.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_30.jpg)'
- en: 'This will get the names of every item in the **Items_Shop** Data table that
    we created earlier in this chapter. Here, we need to create an instance of the
    **Item** Widget Blueprint for every item row. This will create a button for every
    item with the correct corresponding item name. To do this, create a **ForEachLoop**
    located at **Array** under **Utilities** and allow the **Get Data Table Row Names**
    function to execute it. Link the **Out Row Names** pin to the **Array** pin of
    the **ForEachLoop** so that every row in the Data Table becomes an element of
    the array in the **ForEachLoop**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取我们在本章早期创建的**Items_Shop**数据表中每个项目的名称。在这里，我们需要为每个项目行创建一个**Item**小部件蓝图实例。这将为每个项目创建一个带有正确对应项目名称的按钮。为此，创建位于**Utilities**下的**Array**中的**ForEachLoop**，并允许**获取数据表行名称**函数执行它。将**Out
    Row Names**引脚链接到**ForEachLoop**的**Array**引脚，以便数据表中的每一行都成为**ForEachLoop**中数组的元素：
- en: '![Linking the item data](img/B04548_07_31.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_31.jpg)'
- en: 'Next, we need to loop through each element of the array of row names and, for
    each row, we need to create a new instance of the **Item** Widget Blueprint. To
    do this, link the **Create Item Widget** action located under **User Interface**
    to the **Loop Body** pin in the **ForEachLoop**. Let the class instance be **Item**
    that can be selected from the **Class** drop-down menu in the **Create Item Widget**
    action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要遍历行名称数组中的每个元素，并为每个行创建一个新的**Item**小部件蓝图实例。为此，将位于**用户界面**下的**Create Item
    Widget**操作链接到**ForEachLoop**的**Loop Body**引脚。让类实例为**Item**，可以在**Create Item Widget**操作的**类**下拉菜单中选择：
- en: '![Linking the item data](img/B04548_07_41.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_41.jpg)'
- en: 'Then, for every item created, set the **Item** variable that is created for
    every **Item** widget instance to the value of each element in the array. You
    can create the **Set Item** action, by right-clicking anywhere in **Event Graph**,
    unchecking **Context Sensitive**, and locating **Set Item** by navigating to **Class**
    | **Item**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于创建的每个项目，将每个**Item**小部件实例创建的**Item**变量设置为数组中每个元素的价值。您可以通过在**事件图**的任何位置右键单击，取消选中**上下文相关**，并通过导航到**类**|**Item**来创建**设置项目**操作：
- en: '![Linking the item data](img/B04548_07_33.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_33.jpg)'
- en: '**Create Item Widget** can now launch **Set Item**, and set the **Return Value**
    pin value of **Create Item Widget** to the **Target** pin value of **Item**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建项目小部件**现在可以启动**设置项目**，并将**创建项目小部件**的**返回值**引脚值设置为**项目**的**目标**引脚值：'
- en: '![Linking the item data](img/B04548_07_32.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_32.jpg)'
- en: 'At this point, we have not yet set the element of the array to the item that
    we set in the **Item** widget; so, to do this, we can simply link the **Array
    Element** pin from the **ForEachLoop** to the **Item** pin in the **Set Item**
    action:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们还没有将数组中的元素设置为在**Item**小部件中设置的项目；因此，为了做到这一点，我们可以简单地从**ForEachLoop**的**Array
    Element**引脚链接到**Set Item**操作中的**Item**引脚：
- en: '![Linking the item data](img/B04548_07_36.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_36.jpg)'
- en: 'Lastly, we are going to have our Scroll Box that we created in the **Shop**
    Widget Blueprint hold all of our item instances. To do this, after we set each
    item to the correct name, we will add the item instance as a child to the **ScrollBox_Inventory**
    Scroll Box that we created earlier in this chapter. This is done by simply calling
    the **Add Child** function located in **Panel** under **Widget** after we set
    the item:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将把我们在**商店**小部件蓝图创建的滚动框用于存放所有的项目实例。为此，在将每个项目设置为正确的名称后，我们将把项目实例作为子项添加到我们在本章早期创建的**ScrollBox_Inventory**滚动框中。这可以通过在设置项目后，在**Widget**下的**Panel**中调用**Add
    Child**函数来完成：
- en: '![Linking the item data](img/B04548_07_37.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_37.jpg)'
- en: 'Then, we set the **Content** value of the child to the **Return Value** pin
    of the item:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子项的**内容**值设置为项目的**返回值**引脚：
- en: '![Linking the item data](img/B04548_07_38.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_38.jpg)'
- en: 'Lastly, the **Target** pin of the child needs to be linked to **ScrollBox_Inventory**,
    which can be dragged into your **Event Graph** from **Variables**. If you do not
    see the **ScrollBox_Inventory** variable in your variables, go back to the **Designer
    View**, select the **ScrollBox_Inventory**, and make sure **is variable** is checked:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，子项的**目标**引脚需要链接到**ScrollBox_Inventory**，这可以从**变量**拖入您的**事件图**。如果您在变量中看不到**ScrollBox_Inventory**变量，请返回到**设计视图**，选择**ScrollBox_Inventory**，并确保**是变量**被选中：
- en: '![Linking the item data](img/B04548_07_39.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![链接项目数据](img/B04548_07_39.jpg)'
- en: 'At this point, if you test your shop, you will see the shop populated with
    every item listed in your Data Table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你测试你的商店，你将看到商店中填充了你数据表中列出的每一个物品：
- en: '![Linking the item data](img/B04548_07_40.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![链接物品数据](img/B04548_07_40.jpg)'
- en: You will be able to add even more items to your Data Table and these items will
    automatically appear in your shop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够向你的数据表中添加更多物品，这些物品将自动出现在你的商店中。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a currency system for our game along with the ability
    for our enemies to drop gold. We also created a new set of data that contains
    items and their stats, and we have now populated the shop owner's store to display
    the items currently for sale in the shop.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为游戏创建了一个货币系统，并使我们的敌人能够掉落金币。我们还创建了一套新的数据集，包含物品及其属性，并且现在我们已经填充了店主商店，以显示商店中目前出售的物品。
- en: In the next chapter, we will add the buying functionality to the shop along
    with the usage of an item and consumption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为商店添加购买功能，以及物品的使用和消耗。
