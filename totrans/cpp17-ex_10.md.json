["```cpp\nfunction main() { \n  left = 50; \n  length = 50; \n  index = 0; \n```", "```cpp\n  while (index < 4) { \n    if ((index % 2) == 0) { \n      SetPenStyle(SolidLine); \n    } \n    else { \n      SetPenStyle(DashLine); \n    } \n```", "```cpp\n            topLeft = point(left, 25); \n            call drawTriangle(topLeft, length); \n```", "```cpp\n    length = length + 25; \n    left = left + length; \n    index = index + 1; \n  } \n} \n```", "```cpp\nfunction drawTriangle(topLeft, length) { \n  topRight = call getTopRight(topLeft, length); \n  bottomMiddle = call getBottomMiddle(topLeft, length); \n  drawLine(topLeft, topRight); \n  drawLine(topRight, bottomMiddle); \n  drawLine(bottomMiddle, topLeft); \n} \n```", "```cpp\nfunction getTopRight(topLeft, length) { \n  return point(xCoordinate(topLeft) + length, \n               yCoordinate(topLeft)); \n} \n```", "```cpp\nfunction getBottomMiddle(topLeft, length) { \n  left = xCoordinate(topLeft); \n  top = yCoordinate(topLeft); \n  middle = left + length / 2; \n  bottom = top + length; \n  return point(middle, bottom); \n} \n```", "```cpp\nprogram -> functionDefinitionList \nfunctionDefinitionList -> functionDefinition*\n```", "```cpp\nfunctionDefinition -> function name(nameList) { instructionList } \n```", "```cpp\ninstruction -> callExpression ; \n             | while (expression) instruction \n             | if (expression) instruction \n             | if (expression) instruction else instruction \n             | { instructionList } \n             | ... \n\ncallInstruction -> callExpression ; \n```", "```cpp\nprimaryExpression -> call name(expressionList) \n                   |\n```", "```cpp\nclass Token { \n  // ... \n  enum TokenId {BlockId, CallId, ElseId, FunctionId, GotoId, \n                IfId, IfNotGotoId, ReturnId, WhileId, // ... \n               }; \n  // ... \n}; \n```", "```cpp\nvoid Scanner::init() { \n  ADD_TO_KEYWORD_MAP(CallId) \n  ADD_TO_KEYWORD_MAP(ElseId) \n  ADD_TO_KEYWORD_MAP(FunctionId) \n  ADD_TO_KEYWORD_MAP(IfId) \n  ADD_TO_KEYWORD_MAP(ReturnId) \n  ADD_TO_KEYWORD_MAP(WhileId) \n// ... \n} \n```", "```cpp\n#ifndef FUNCTION_H \n#define FUNCTION_H \n\n#include <QtWidgets> \n\n#include \"Value.h\" \n#include \"Action.h\" \n\nclass Function { \n  public: \n    Function() {} \n    Function(const QList<QString>& nameList, int address); \n    const QList<QString>& nameList() const {return m_nameList;} \n    int address() {return m_address;} \n\n    Function(const Function& function); \n    Function operator=(const Function& function); \n\n  private: \n    QList<QString> m_nameList; \n    int m_address; \n}; \n\n#endif // FUNCTION_H \n```", "```cpp\n#include \"Function.h\" \n\nFunction::Function(const QList<QString>& nameList, int address) \n :m_nameList(nameList), \n  m_address(address) { \n  // Empty. \n} \n\nFunction::Function(const Function& function) \n :m_nameList(function.m_nameList), \n  m_address(function.m_address) { \n  // Empty. \n} \n\nFunction Function::operator=(const Function& function) { \n  m_nameList = function.m_nameList; \n  m_address = function.m_address; \n  return *this; \n} \n```", "```cpp\n#ifndef DIRECTIVE_H \n#define DIRECTIVE_H \n\n#include <QtWidgets> \n\n#include \"Token.h\" \n#include \"Value.h\" \n#include \"Function.h\" \n\nclass Directive { \n  public: \n    Directive(TokenId tokenId); \n    Directive(TokenId tokenId, int address); \n    Directive(TokenId tokenId, const QString& name); \n    Directive(TokenId tokenId, const QString& name, \n              int parameters); \n    Directive(TokenId tokenId, const Value& value); \n    Directive(TokenId tokenId, const Function& function); \n\n    Directive(const Directive& directive); \n    Directive operator=(const Directive& directive); \n\n    TokenId directiveId() {return m_directiveId;} \n    const QString& name() {return m_name;} \n    const Value& value() {return m_value;} \n    const Function& function() {return m_function;} \n\n    int parameters() const {return m_parameters;} \n    int address() const {return m_address;} \n    void setAddress(int address) {m_address = address;} \n\n  private:          \n    TokenId m_directiveId; \n    QString m_name; \n    int m_parameters, m_address; \n    Value m_value; \n    Function m_function; \n}; \n\n#endif // DIRECTIVE_H \n```", "```cpp\n#include \"Directive.h\"\n```", "```cpp\nDirective::Directive(TokenId directiveId) \n :m_directiveId(directiveId) { \n  // Empty. \n} \n```", "```cpp\nDirective::Directive(TokenId directiveId, int address) \n :m_directiveId(directiveId), \n  m_address(address) { \n  // Empty. \n} \n```", "```cpp\nDirective::Directive(TokenId directiveId, const QString& name) \n :m_directiveId(directiveId), \n  m_name(name) { \n  // Empty. \n} \n```", "```cpp\nDirective::Directive(TokenId directiveId, const QString& name, \n                     int parameters) \n :m_directiveId(directiveId), \n  m_name(name), \n  m_parameters(parameters) { \n  // Empty. \n} \n```", "```cpp\nDirective::Directive(TokenId directiveId, const Value& value) \n :m_directiveId(directiveId), \n  m_value(value) { \n  // Empty. \n} \n```", "```cpp\nDirective::Directive(TokenId directiveId, \n                     const Function& function) \n :m_directiveId(directiveId), \n  m_function(function) { \n  // Empty. \n} \n```", "```cpp\n// ... \n\nclass Parser { \n  private: \n    void functionDefinitionList(); \n    void functionDefinition(); \n\n```", "```cpp\n            QList<QString> nameList(); \n            int expressionList(); \n```", "```cpp\n    void callExpression(); \n    // ... \n}; \n```", "```cpp\nvoid Parser::functionDefinitionList() { \n  while (m_lookAHead.id() != EndOfFileId) { \n    functionDefinition(); \n  } \n} \n```", "```cpp\nvoid Parser::functionDefinition() { \n  match(FunctionId); \n  QString name = m_lookAHead.name(); \n  match(NameId); \n```", "```cpp\n  match(LeftParenthesisId); \n  QList<QString> nList = nameList(); \n  match(RightParenthesisId); \n```", "```cpp\n   int startAddress = (int) m_directiveList.size(); \n   Function function(nList, startAddress); \n   m_directiveList.push_back(Directive(FunctionId, function)); \n```", "```cpp\n  match(LeftBracketId); \n  instructionList(); \n  match(RightBracketId); \n```", "```cpp\n  m_directiveList.push_back(Directive(ReturnId)); \n```", "```cpp\n  check(!m_functionMap.contains(name), \n        \"function \"\" + name + \"\" already defined\"); \n```", "```cpp\n  check(!((name == \"main\") && (nList.size() > 0)), \n        \"function \"main\" cannot have parameters\"); \n```", "```cpp\n  m_functionMap[name] = function; \n}\n```", "```cpp\nQList<QString> Parser::nameList() { \n  QList <QString> nameList; \n```", "```cpp\n  while (m_lookAHead.id() != RightParenthesisId) { \n    QString name = m_lookAHead.name(); \n    nameList.push_back(name); \n    match(NameId); \n```", "```cpp\n    if (m_lookAHead.id() == RightParenthesisId) { \n      break; \n    } \n```", "```cpp\n    match(CommaId); \n  } \n```", "```cpp\n  QSet<QString> nameSet; \n  for (const QString& name : nameList) { \n    if (nameSet.contains(name)) { \n      semanticError(\"parameter \"\" + name + \"\" defined twice\"); \n    } \n\n    nameSet.insert(name); \n  } \n\n  return nameList; \n} \n\n```", "```cpp\nvoid Parser::instructionList() { \n  while (m_lookAHead.id() != RightBracketId) { \n    instruction(); \n  } \n}\n```", "```cpp\nvoid Parser::instruction() { \n  switch (m_lookAHead.id()) { \n    case CallId: \n      callExpression(); \n      match(SemicolonId); \n      break; \n```", "```cpp\n    case ReturnId: \n      match(ReturnId); \n\n      if (m_lookAHead.id() != SemicolonId) { \n        expression(); \n      } \n\n      m_directiveList.push_back(Directive(ReturnId)); \n      match(SemicolonId); \n      break; \n```", "```cpp\n    case IfId: { \n        match(IfId); \n        match(LeftParenthesisId); \n        expression(); \n        match(RightParenthesisId); \n```", "```cpp\n        int ifNotIndex = (int) m_directiveList.size(); \n        m_directiveList.push_back(Directive(IfNotGotoId, 0)); \n        instruction();\n```", "```cpp\n        if (m_lookAHead.id() == ElseId) { \n          match(ElseId); \n          int elseIndex = (int) m_directiveList.size(); \n          m_directiveList.push_back(Directive(GotoId, 0)); \n```", "```cpp\n          m_directiveList[ifNotIndex]. \n            setAddress((int) m_directiveList.size()); \n          instruction(); \n```", "```cpp\n          m_directiveList[elseIndex]. \n            setAddress((int) m_directiveList.size()); \n        } \n```", "```cpp\n        else { \n          m_directiveList[ifNotIndex]. \n            setAddress((int) m_directiveList.size()); \n        } \n      } \n      break; \n```", "```cpp\n    case WhileId: { \n        match(WhileId); \n        int whileIndex = (int) m_directiveList.size(); \n```", "```cpp\n        match(LeftParenthesisId); \n        expression(); \n        match(RightParenthesisId);\n```", "```cpp\n        int ifNotIndex = (int) m_directiveList.size(); \n        m_directiveList.push_back(Directive(IfNotGotoId, 0)); \n        instruction(); \n```", "```cpp\n        m_directiveList.push_back(Directive(GotoId, whileIndex)); \n```", "```cpp\n        m_directiveList[ifNotIndex]. \n          setAddress((int) m_directiveList.size()); \n      } \n      break; \n```", "```cpp\n    case LeftBracketId: \n      match(LeftBracketId); \n      instructionList(); \n      match(RightBracketId); \n      break; \n```", "```cpp\n    case NameId: { \n        QString name = m_lookAHead.name(); \n        match(NameId); \n        match(AssignId); \n        expression(); \n        match(SemicolonId); \n        m_directiveList.push_back(Directive(AssignId, name)); \n      } \n      break; \n\n      // ... \n  } \n} \n```", "```cpp\nvoid Parser::callExpression() { \n  match(CallId); \n  QString name = m_lookAHead.name(); \n  match(NameId); \n  match(LeftParenthesisId); \n  int size = expressionList(); \n  match(RightParenthesisId); \n  m_directiveList.push_back(Directive(CallId, name, size)); \n} \n```", "```cpp\nint Parser::expressionList() { \n  int size = 0; \n```", "```cpp\n  while (m_lookAHead.id() != RightParenthesisId) { \n    expression(); \n    ++size; \n```", "```cpp\n    if (m_lookAHead.id() == RightParenthesisId) { \n      break; \n    } \n```", "```cpp\n    match(CommaId); \n  }\n```", "```cpp\n  return size; \n} \n```", "```cpp\n#ifndef EVALUATOR_H \n#define EVALUATOR_H \n\n#include <QtWidgets> \n\n#include \"Error.h\" \n#include \"Directive.h\" \n#include \"Action.h\" \n#include \"Function.h\" \n```", "```cpp\nclass Evaluator { \n  public: \n    Evaluator(const QList<Directive>& directiveList, \n              QList<Action>& actionList, \n              QMap<QString,Function> functionMap);\n```", "```cpp\n  private: \n    void checkType(TokenId tokenId, const Value& value); \n    void checkType(TokenId tokenId, const Value& leftValue, \n                   const Value& rightValue); \n\n    Value evaluate(TokenId tokenId, const Value& value); \n    Value evaluate(TokenId tokenId, const Value& leftValue, \n                   const Value& rightValue); \n```", "```cpp\n    QStack<Value> m_valueStack; \n    QMap<QString,Value> m_valueMap; \n    QStack<QMap<QString,Value>> m_valueMapStack; \n    QStack<int> m_returnAddressStack; \n}; \n\n#endif // EVALUATOR_H \n```", "```cpp\n#include <CAssert> \nusing namespace std; \n\n#include \"Error.h\" \n#include \"Evaluator.h\" \n```", "```cpp\nEvaluator::Evaluator(const QList<Directive>& directiveList, \n                     QList<Action>& actionList, \n                     QMap<QString,Function> functionMap) { \n  int directiveIndex = 0; \n\n  while (true) { \n    Directive directive = directiveList[directiveIndex]; \n    TokenId directiveId = directive.directiveId(); \n```", "```cpp\n    switch (directiveId) { \n      case CallId: { \n          QString name = directive.name(); \n          check(functionMap.contains(name), \n                \"missing function: \"\" + name + \"\"\"); \n          Function function = functionMap[name]; \n          check(directive.parameters() == \n                function.nameList().size(), \n                \"invalid number of parameters\"); \n```", "```cpp\n          m_returnAddressStack.push(directiveIndex + 1); \n          m_valueMapStack.push(m_valueMap); \n          m_valueMap.clear(); \n          directiveIndex = function.address(); \n        } \n        break;\n```", "```cpp\n      case FunctionId: { \n          const Function& function = directive.function(); \n          const QList<QString>& nameList = function.nameList(); \n\n          for (int listIndex = ((int) nameList.size() - 1); \n               listIndex >= 0; --listIndex) { \n            const QString& name = nameList[listIndex]; \n            m_valueMap[name] = m_valueStack.pop(); \n          } \n        } \n        ++directiveIndex; \n        break; \n```", "```cpp\n      case ReturnId: \n        if (!m_returnAddressStack.empty()) { \n          m_valueMap = m_valueMapStack.pop(); \n          directiveIndex = m_returnAddressStack.pop(); \n        } \n```", "```cpp\n        else { \n          return; \n        } \n        break;\n```", "```cpp\n      case IfNotGotoId: { \n          Value value = m_valueStack.pop(); \n\n          if (!value.booleanValue()) { \n            directiveIndex = directive.address(); \n          } \n```", "```cpp\n          else { \n            ++directiveIndex; \n          } \n        } \n        break; \n```", "```cpp\n      case GotoId: \n        directiveIndex = directive.address(); \n        break; \n```", "```cpp\n      case SetPenColorId: \n      case SetPenStyleId: \n      case SetBrushColorId: \n      case SetBrushStyleId: \n      case SetFontId: \n      case SetHorizontalAlignmentId: \n      case SetVerticalAlignmentId: { \n          Value value = m_valueStack.pop(); \n          checkType(directiveId, value); \n          actionList.push_back(Action(directiveId, value)); \n          ++directiveIndex; \n        } \n        break;\n```", "```cpp\n      case DrawLineId: \n      case DrawRectangleId: \n      case DrawEllipseId: \n      case DrawTextId: { \n          Value secondValue = m_valueStack.pop(); \n          Value firstValue = m_valueStack.pop(); \n          checkType(directiveId, firstValue, secondValue); \n          actionList.push_back(Action(directiveId, firstValue, \n                                      secondValue)); \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case AssignId: { \n          Value value = m_valueStack.pop(); \n          m_valueMap[directive.name()] = value; \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case XCoordinateId: \n      case YCoordinateId: { \n          Value value = m_valueStack.pop(); \n          checkType(directiveId, value); \n          Value resultValue = evaluate(directiveId, value); \n          m_valueStack.push(resultValue); \n          ++directiveIndex; \n        } \n        break;\n```", "```cpp\n      case AddId: \n      case SubtractId: \n      case MultiplyId: \n      case DivideId: \n      case PointId: { \n          Value rightValue = m_valueStack.pop(); \n          Value leftValue = m_valueStack.pop(); \n          checkType(directiveId, leftValue, rightValue); \n          Value resultValue = \n            evaluate(directiveId, leftValue, rightValue); \n          m_valueStack.push(resultValue); \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case ColorId: { \n          Value blueValue = m_valueStack.pop(); \n          Value greenValue = m_valueStack.pop(); \n          Value redValue = m_valueStack.pop(); \n          checkColorType(redValue, greenValue, blueValue); \n          QColor color(redValue.numericalValue(), \n                       greenValue.numericalValue(), \n                       blueValue.numericalValue()); \n          m_valueStack.push(Value(color)); \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case FontId: { \n          Value sizeValue = m_valueStack.pop(); \n          Value nameValue = m_valueStack.pop(); \n          checkFontType(nameValue, sizeValue, \n                        boldValue, italicValue); \n          QFont font(nameValue.stringValue(), \n                     sizeValue.numericalValue()); \n          m_valueStack.push(Value(font)); \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case NameId: { \n          QString name = directive.name(); \n          check(m_valueMap.contains(name), \n                \"unknown name: \"\" + name +\"\"\"); \n          m_valueStack.push(m_valueMap[name]); \n          ++directiveIndex; \n        } \n        break; \n```", "```cpp\n      case ValueId: \n        m_valueStack.push(directive.value()); \n        ++directiveIndex; \n        break; \n    } \n  } \n} \n```", "```cpp\n#include <QApplication> \n#include <QMessageBox> \n#include <IOStream> \nusing namespace std; \n\n#include \"Action.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"Parser.h\" \n#include \"Evaluator.h\" \n#include \"ViewerWidget.h\" \n\nint main(int argc, char *argv[]) { \n  Scanner::init(); \n  QApplication application(argc, argv); \n\n  try { \n    QString path = \"C:\\Input.dsl\"; \n\n    QFile file(path); \n    if (!file.open(QIODevice::ReadOnly)) { \n      error(\"Cannot open file \"\" + path + \"\" for reading.\"); \n    } \n\n    QString buffer(file.readAll()); \n    Scanner scanner(buffer); \n```", "```cpp\n    QList<Directive> directiveList; \n    QMap<QString,Function> functionMap; \n    Parser(scanner, directiveList, functionMap); \n\n    QList<Action> actionList; \n    Evaluator evaluator(directiveList, actionList, functionMap); \n\n    ViewerWidget mainWidget(actionList); \n    mainWidget.show(); \n    return application.exec(); \n  } \n  catch (exception e) { \n    QMessageBox messageBox(QMessageBox::Information, \n                           QString(\"Error\"), QString(e.what())); \n    messageBox.exec(); \n  } \n}\n```"]