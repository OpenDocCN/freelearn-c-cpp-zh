["```cpp\nclass X {\n   // ...\n};\nX *f();\nvoid g(X *p);\nvoid h() {\n   X *p = f();\n   g(p);\n   delete p;\n}\n```", "```cpp\nX *f() { // here’s one possibility\n   return new X;\n}\nX *f() { // here’s another\n   static X x;\n   return &x;\n}\n```", "```cpp\n// ...\nvoid f() {\n   X *p = new X;\n   thread th0{ [p] { /* use *p */ };\n   thread th1{ [p] { /* use *p */ };\n   th0.detach();\n   th1.detach();\n}\n```", "```cpp\n#include <memory>\n#include <iostream>\n// print_pointee() shares a pointer with the caller\n// but does not take ownership\ntemplate <class T> void print_pointee(T *p) {\n   if (p) std::cout << *p << ‘\\n’;\n}\nstd::unique_ptr<T> make_one(const T &arg) {\n   return std::make_unique<T>(arg);\n}\nint main() {\n   auto p = make_one(3); // p is a std::unique_ptr<int>\n   print_pointee(p.get()); // caller and callee share the\n                           // pointer during this call\n}\n```", "```cpp\nclass entity {\n   bool taken{ false };\npublic:\n   void take() { taken = true; }\n   void release() { taken = false; }\n   bool taken() const { return taken; }\n   // ...\n};\nconstexpr int N = ...;\n// entities is where the entity objects live. We did\n// not allocate them dynamically, but if we had we would\n// have used unique_ptr<entity> as this will be the\n// single last point of use for these objects\narray<entity,N> entities;\nclass nothing_left{};\n// this function returns a non-owning pointer (Chapter 6\n// will cover more ergonomic options than a raw pointer)\nentity * borrow_one() {\n   if(auto p = find_if(begin(entities), end(entities),\n               [](auto && e) { return !e.taken(); };\n      p != end(entities)) {\n      p->take();\n      return &(*p); // non-owning pointer\n   }\n   throw nothing_left{};\n}\n```", "```cpp\n#include <memory>\nclass X {\n   // ...\n};\nstd::unique_ptr<X> f();\nvoid g(std::unique_ptr<X>&);\nvoid h() {\n   // we could write std::unique_ptr<X> instead of auto\n   auto p = f();\n   g(p);\n} f() is responsible for the lifetime of the X object it points to, and it’s also clear that g() uses the enclosed X* without becoming responsible for the pointed-to X object. Add to this the fact that p is an object and, as such, will be destroyed if g() throws or if f() is called in such a way that the calling code forgets to use the return value, and you get an exception-safe program – one that’s shorter and simpler than the original one!\nMurphy and Machiavelli\nYou might be thinking, “*But I’m sure I could steal the pointer managed by the* `std::unique_ptr` *in* `g()`,” and you would be correct. Not only is it possible but also easy, as `unique_ptr` gives you direct access to the underlying pointer in more than one way. However, the type system is designed to protect us from accidents and make reasonable well-written code work well. It will protect you from Murphy, the accidents that happen, not from Machiavelli, the deliberately hostile code.\nIf you write deliberately broken code, you will end up with a deliberately broken program. It’s pretty much what you would expect.\nIn terms of semantics, you could tell a story just with function signatures, using `std::unique_ptr` objects. Note that in the following example, the functions have been left deliberately incomplete to make it clear that we are concerned with their signatures only:\n\n```", "```cpp\n\n As we can see, function signatures talk to us. It’s better if we pay attention.\nHandling objects\nThe `unique_ptr` type is a remarkable tool, one you should strive to get acquainted with if you have not done so already. Here are some interesting facts about that type and how it can be used to manage pointers to objects.\nA `unique_ptr<T>` object is non-copyable, as its copy constructor and copy assignment member functions are marked as deleted. That’s why `g()` in the first example of the *Type unique_ptr* section takes its argument by reference – `g()` shares the pointee with the caller but does not take ownership of it. We could also have expressed `g()` as taking `X*` as an argument, with the contemporary acceptance that function arguments that are raw pointers are meant to model using a pointer but without owning it:\n\n```", "```cpp\n\n `unique_ptr<T>` is also movable – a moved-from `unique_ptr<T>` behaves like a null pointer, as the movement for this type semantically implements a transfer of ownership. This makes it simpler to implement various types that need to manage resources indirectly.\nConsider, for example, the following `solar_system` class, which supposes a hypothetical `Planet` type as well as a hypothetical implementation for `create_planet()`:\n\n```", "```cpp\n\n If we had decided to implement `solar_system` with `vector<Planet*>` or as `Planet*` instead, then the memory management of our type would have to be performed by `solar_system` itself, adding to the complexity of that type. Since we used a `vector<unique_ptr<Planet>>`, everything is implicitly correct by default. Of course, depending on what we are doing, `vector<Planet>` might be even better, but let’s suppose we need pointers for the sake of the example.\nA `unique_ptr<T>` offers most of the same operations as `T*`, including `operator*()` and `operator->()`, as well as the ability to compare them with `==` or `!=` to see whether two `unique_ptr<T>` objects point to the same `T` object. The latter two might seem strange, as the type represents sole ownership of the *pointee*, but you could use references to `unique_ptr<T>`, in which case these functions make sense:\n\n```", "```cpp\n\n For good reasons, you cannot do pointer arithmetic on `unique_ptr<T>`. If you need to do pointer arithmetic (and we sometimes will – for example, when we write our own containers in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)), it’s always possible to get to the raw pointer owned by a `unique_pointer<T>` through its `get()` member function. This is often useful when interfacing with C libraries, making system calls, or calling functions that use a raw pointer without taking ownership of it.\nOh, and here’s a fun fact – `sizeof(unique_ptr<T>)==sizeof(T*)` with a few exceptions that will be discussed later in this chapter. This means that there’s generally no cost in terms of memory space to using a smart pointer instead of a raw pointer. In other words, by default, the only state found in a `unique_ptr<T>` object is `T*`.\nHandling arrays\nA nice aspect of `unique_ptr` is that it offers a specialization to handle arrays. Consider the following:\n\n```", "```cpp\n\n What, you might think, is the use case for this? Well, it all depends on your needs. For example, if you require a variable-sized array of `T` that grows as needed, use `vector<T>`. It’s a wonderful tool and extremely efficient if used well.\nIf you want a fixed-sized array that’s small enough to fit on your execution stack where the number of elements, `N`, is known at compile time, use a raw array of `T` or an object of type `std::array<T,N>`.\nIf you want a fixed-sized array that’s either not small enough to fit on your execution stack or where the number of elements, `n`, is known at runtime, you can use `vector<T>`, but you’ll pay for facilities you might not require (`vector<T>` remains an awesome choice, that being said), or you could use `unique_ptr<T[]>`. Note that if you go for this latter option, you will end up having to track the size yourself, separately from the actual array, since `unique_ptr` does no such tracking. Alternatively, of course, you can wrap it in your own abstraction, such as `fixed_size_array<T>`, as follows:\n\n```", "```cpp\n\n This is a naïve implementation that brings together knowledge of the number of elements with implicit ownership of the resource. Note that we don’t have to write the copy operations (unless we want to implement them!), the move operations, or the destructor, as they all implicitly do something reasonable. Also, this type will be relatively efficient if type `T` is trivially constructible but will (really) not be as efficient as `vector<T>` for numerous use cases. Why is that? Well, it so happens that `vector` does significantly better memory management than we do… but we’ll get there.\nNote that, as with scalar types, the fact that `sizeof(unique_ptr<T[]>)` is equal to `sizeof(T*)` is also true, which I’m sure we can all appreciate.\nCustom deleters\nYou might think, “*Well, in my code base, we don’t use* `delete` *to deallocate objects because [insert your favorite reason here], so I cannot use* `unique_ptr`.” There are indeed many situations where applying `operator delete` on a pointer to destroy the pointed-to object is not an option:\n\n*   Sometimes, `T::~T()` is `private` or `protected`, making it inaccessible to other classes such as `unique_ptr<T>`.\n*   Sometimes, the finalization semantics require doing something else than calling `delete` – for example, calling a `destroy()` or `release()` member function\n*   Sometimes, the expectation is to call a free function that will perform auxiliary work in addition to freeing a resource.\n\nNo matter what the reasons are for freeing a resource in an unconventional manner, `unique_ptr<T>` can take a `T*` stored within `unique_ptr<T>` when the destructor of that smart pointer is called. Indeed, the actual signature of the `unique_ptr` template is as follows:\n\n```", "```cpp\n\n Here, `default_delete<T>` itself is essentially the following:\n\n```", "```cpp\n\n The presence of a default type for `D` is what usually allows us to write code that ignores that parameter. The `D` parameter in the `unique_ptr<T,D>` signature is expected to be stateless, as it’s not stored within the `unique_ptr` object but instantiated as needed, and then it’s used as a function that takes the pointer and does whatever is required to finalize the *pointee*.\nAs such, imagine the following class with a `private` destructor, a common technique if you seek to prevent instantiation through other means than dynamic allocation (you cannot use an automatic or a static object of that type, since it cannot be implicitly destroyed):\n\n```", "```cpp\n\n Note that by making the `cleaner` functor its friend, the `requires_dynamic_alloc` class lets `cleaner` specifically access both its `protected` and `private` members, which includes access to its `private` destructor.\nImagine now that we are using an object through an interface that hides from client code information on whether we are the sole owner of the pointed-to resource, or whether we share that resource with others. Also, imagine that the potential sharing of that resource is done through intrusive means, as is done on many platforms, such that the way to signal that we are disconnecting from that resource is to call its `release()` member function, which will, in turn, either take into account that we have disconnected or free the resource if we were its last users. To simplify client code, our code base has a `release()` free function that calls the `release()` member function on such a pointer if it is non-null.\nWe can still use `unique_ptr` for this, but note the syntax, which is slightly different, as we will need to pass the function pointer as an argument to the constructor, since that pointer will be stored within. Thus, this specialization of `unique_ptr` with a function pointer as a *deleter* leads to a slight size increase:\n\n```", "```cpp\n\n If the extra cost of a function pointer’s size (plus alignment) in the size of `unique_ptr` is unacceptable (for example, because you are on a resource-constrained platform or because you have a container with many `unique_ptr` objects, which makes the costs increase significantly faster), there’s a neat trick you can play by pushing the runtime use of the `deleter` function into the wonderful world of the type system:\n\n```", "```cpp\n\n As you can see, in the case of `p`, we used a function pointer as a deleter, which requires storing the address of the function, whereas with `q`, we replaced the function pointer with the *type of a hypothetical lambda*, which will, when instantiated, call that function, passing the pointer as an argument. It’s simple and can save space if used judiciously!\nmake_unique\nSince C++14, `unique_ptr<T>` has been accompanied by a factory function that perfectly forwards its arguments to a constructor of `T`, allocates and constructs the `T` as well as `unique_ptr<T>` to hold it, and returns the resulting object. That function is `std::make_unique<T>(args...)`, and a naïve implementation would be as follows:\n\n```", "```cpp\n\n There are also variants to create a `T[]`, of course. You might wonder what the point of such a function is, and indeed, that function was not shipped along with `unique_ptr` initially (`unique_ptr` is a C++11 type), but consider the following (contrived) example:\n\n```", "```cpp\n\n We can suppose from this example that this class is used when, for some reason, client code prefers to dynamically allocate the `T` objects (in practice, using objects rather than pointers to objects makes your life simpler). Knowing that subobjects in a C++ object are constructed in order of declaration, we know that `p0` will be constructed before `p1`:\n\n```", "```cpp\n\n However, suppose that the order of operations is `new T(val0)`, the construction of `p0`, `new T(val1)`, and the construction of `p1`. What happens then if `new T(val1)` throws an exception, either because `new` fails to allocate sufficient memory or because the constructor of `T` fails? You might be tempted to think that the destructor of `pair_with_alloc` will clean up, but that will not be the case – for a destructor to be called, the corresponding constructor must have completed first; otherwise, there is no object to destroy!\nThere are ways around this ,of course. One of them might be to use `unique_ptr<T>` instead of `T*`, which would be wonderful, given that this is what we’re currently discussing! Let’s rewrite `pair_with_alloc` that way:\n\n```", "```cpp\n\n With this version, if the order of operations is `new T(val0)`, the construction of `p0`, `new T(val1)`, the construction of `p1`, then if `new T(val1)` throws an exception, the `pair_with_alloc` object will still not be destroyed (it has not been constructed). However, `p0` itself *has* been constructed by that point, and as such, it will be destroyed. Our code has suddenly become simpler and safer!\nWhat then has that to do with `make_unique<T>()`? Well, there’s a hidden trap here. Let’s look closer at the order of operations in our constructor:\n\n```", "```cpp\n\n If you look at the rules laid out in the comments, you will see that we could have the operations in the following order, A→B→C→D, but we could also have them ordered as A→C→B→D or C→A→B→D, in which case the two calls to `new T(...)` would occur, followed by the two `unique_ptr<T>` constructors. If this happens, then an exception thrown by the second call to `new` or the associated constructor of `T` would still lead to a resource leak.\nNow, that’s a shame. But that’s also the point of `make_unique<T>()` – with a factory function, client code never finds itself with “floating results from calls to `new`”; it either has a complete `unique_ptr<T>` object or not:\n\n```", "```cpp\n\n As you can see, `make_unique<T>()` is a security feature, mostly useful to avoid exposing ownerless resources in client code. As a bonus, `make_unique<T>()` allows us to limit how we repeat ourselves in source code. Check the following:\n\n```", "```cpp\n\n As you can see, `p0` and `p1` require you to spell the name of the pointed-to type twice whereas `p2` only requires you to write it once. That’s always nice.\nTypes shared_ptr and weak_ptr\nIn most cases, `unique_ptr<T>` will be your smart pointer of choice. It’s small, fast, and does what most code requires. There are some specialized but important use cases where `unique_ptr<T>` is not what you need, and these have in common the following:\n\n*   The semantics being conveyed is the *shared ownership* of the resource\n*   The last owner of the resource is not known a priori (which mostly happens in concurrent code)\n\nNote that if the execution is not concurrent, you will, in general, know who the last owner of the resource is – it’s the last object to observe the resource that will be destroyed in the program. This is an important point – you can have concurrent code that shares resources and still uses `unique_ptr` to manage the resource. Non-owning users of the resource, such as raw pointers, can access it without taking ownership (more on that later in this chapter), and this approach is sufficient.\nYou can, of course, have non-concurrent code where the last owner of a resource is not known a priori. An example might involve a protocol where the provider of the resource still holds on to it after returning it to the client, but they might be asked to release it at a later point while client code retains it, making the client the last owner from that point on, or they might never be asked to release it, in which case the provider might be the last owner of the resource. Such situations are highly specific, obviously, but they show that there might be reasons to use shared ownership semantics as expressed through `std::shared_ptr`, even in non-concurrent code.\nSince concurrent code remains the posterchild for situations where the last owner of a shared resource is not known a priori, we will use this as a basis for our investigation. Remember this example from the beginning of this chapter:\n\n```", "```cpp\n\n Here, `p` in `f()` does not own the `X` it points to, being a raw pointer, and both `th0` and `th1` copy that raw pointer, so neither is responsible for the pointee (at least on the basis of the rules enforced by the type system; you could envision acrobatics to make this work, but it’s involved, tricky, and bug-prone).\nThis example can be amended to have clear ownership semantics by shifting `p` from `X*` to `shared_ptr<X>`. Indeed, let’s consider the following:\n\n```", "```cpp\n\n In `f()`, the `p` object is initially the sole owner of the `X` it points to. When `p` is copied, as it is in the capture blocks of the lambdas executed by `th0` and `th1`, the mechanics of `shared_ptr` ensure that `p` and its two copies share both `X*` and an integral counter, used to determine how many shared owners there are for the resource.\nThe key functions of `shared_ptr` are its copy constructor (shares the resource and increments the counter), copy assignment (disconnects from the original resource, decrementing its counter, and then connects to the new resource, incrementing its counter), and the destructor (decrements the counter and destroys the resource if there’s no owner left). Each of these functions is subtle to implement; to help understand what the stakes are, we will provide simplified implementation examples in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096). Move semantics, unsurprisingly, implement transfer of ownership semantics for `shared_ptr`.\nNote that `shared_ptr<T>` implements extrusive (non-intrusive) shared ownership semantics. Type `T` could be a fundamental type and does not need to implement a particular interface for this type to work. This differs from the intrusive shared semantics that were mentioned earlier in this chapter, with the `releasable` type an example.\nUsefulness and costs\nThere are intrinsic costs to the `shared_ptr<T>` model. The most obvious one is that `sizeof(shared_ptr<T>)>sizeof(unique_ptr<T>)` for any type `T`, since `shared_ptr<T>` needs to handle both a pointer to the shared resource and a pointer to the shared counter.\nAnother cost is that copying a `shared_ptr<T>` is not a cheap operation. Remember that `shared_ptr<T>` makes sense mostly in concurrent code, where you do not know a priori the last owner of a resource. For that reason, the increments and decrements of the shared counter require synchronization, meaning that the counter is typically an `atomic` integer, and mutating an `atomic<int>` object (for example) costs more than mutating an `int`.\nAnother non-negligible cost is the following:\n\n```", "```cpp\n\n An instruction such as this one will lead to *two* allocations, not one – there will be one for the `X` object and another one (performed internally by the `shared_ptr`) for the counter. Since these two allocations will be done separately, one by the client code and one by the constructor itself, the two allocated objects might find themselves in distinct cache lines, potentially leading to a loss of efficiency when accessing the `shared_ptr` object.\nmake_shared()\nThere is a way to alleviate the latter cost, and that is to make the same entity perform both allocations, instead of letting the client code do one and the constructor do the other. The standard tool to achieve this is the `std::make_shared<T>()` factory function.\nCompare the following two instructions:\n\n```", "```cpp\n\n When constructing `p`, `shared_ptr<X>` is provided an existing `X*` to manage, so it has no choice but to perform a second, separate allocation for the shared counter. Conversely, the call expressed as `make_shared<X>(args)` specifies the type `X` to construct along with the arguments `args` to forward directly to the constructor. It falls upon that function to create `shared_ptr<X>`, `X`, and the shared counter, which lets us put both `X` and the counter in the same contiguous space (the **control block**), using mechanisms such as a *union* or the *placement new* mechanism, which will be explored in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116).\nClearly, given the same arguments used for construction, the preceding `p` and `q` will be equivalent `shared_ptr<X>` objects, but in general, `q` will perform better than `p`, as its two key components will be organized in a more cache-friendly manner.\nWhat about weak_ptr?\nIf `shared_ptr<T>` is a type with a narrower (yet essential) niche than `unique_ptr<T>`, `weak_ptr<T>` occupies an even narrower (but still essential) niche. The role of `weak_ptr<T>` is to model the *temporary* ownership of `T`. Type `weak_ptr<T>` is meant to interact with `shared_ptr<T>` in a way that makes the continued existence of the *pointee* testable from client code.\nA good example of `weak_ptr` usage, inspired by the excellent `cppreference` website ([https://en.cppreference.com/w/cpp/memory/weak_ptr](https://en.cppreference.com/w/cpp/memory/weak_ptr)), is as follows:\n\n```", "```cpp\n\n As this example shows, you can make `weak_ptr<T>` from `shared_ptr<T>`, but `weak_ptr` does not own the resource until you call `lock()` on it, yielding `shared_ptr<T>`, from which you can safely use the resource after having verified that it does not model an empty pointer.\nAnother use case for `std::weak_ptr` and `std::shared_ptr` would be a cache of resources such that the following occurs:\n\n*   The data in a `Resource` object is sufficiently big or costly to duplicate that it’s preferable to share it than to copy it\n*   A `Cache` object shares the objects it stores, but it needs to invalidate them before replacing them when its capacity is reached\n\nIn such a situation, a `Cache` object could hold `std::shared_ptr<Resource>` objects but provide its client code, `std::weak_ptr<Resource>`, on demand, such that the `Resource` objects can be disposed of when the `Cache` needs to do so, but the client code needs to be able to verify that the objects it points to have not yet been invalidated.\nA full (simplified) example would be the following (see the GitHub repository for this book to get the full example):\n\n```", "```cpp\n\n After a sufficient number of additions to the cache, the object pointed to by `p` in `main()` becomes invalidated and erased from the set of resources, one of our requirements for this example (without that requirement, we could have simply used `std::shared_ptr` objects in this case). Yet, `main()` can test for the validity of the object pointed to by `p` through the construction of `std::shared_ptr` from the `std::weak_ptr` it holds.\nIn practice, `weak_ptr` is sometimes used to break cycles when `shared_ptr` objects refer to each other in some way. If you have two types whose objects mutually refer to one another (say, `X` and `Y`) and do not know which one will be destroyed first, then consider making one of them the owner (`shared_ptr`) and the other one the non-owner in a verifiable manner (`weak_ptr`), which will ensure that they will not keep each other alive forever. For example, this will conclude, but the `X` and `Y` destructors will never be called:\n\n```", "```cpp\n\n If you change either `X::p` or `Y::p` to `weak_ptr`, you will see both the `X` and `Y` destructors being called:\n\n```", "```cpp\n\n Of course, the easiest way not to get to the point where you face a cycle of `shared_ptr<T>` objects is to not build such a cycle, but when faced with external libraries and third-party tools, that’s sometimes easier said than done.\nWhen to use raw pointers\nWe have seen that smart pointer types such as `unique_ptr<T>` and `shared_ptr<T>` shine when there is a need to describe ownership of a type `T` resource through the type system. Does that mean that `T*` has become useless?\nNo, of course not. The trick is to use it in controlled situations. The first is that for a function, being passed a `T*` as an argument should mean the function is *an observer, not an owner*, of that `T`. If your code base used raw pointers in that sense, you will most probably not run into trouble.\nSecondly, you can use a raw pointer inside a class that implements your preferred ownership semantics. It’s fine to implement a container that manipulates objects through raw pointers (for example, a tree-like structure meant for various traversal orders), as long as that container implements clear copy and move semantics. What you don’t want to do is expose pointers to the internal nodes of your container to external code. Pay attention to the container’s interface.\nIndeed, consider this single-linked list of (excerpt):\n\n```", "```cpp\n\n We will explore this example in greater detail in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187). The destructor works fine and (supposing the rest of the class is reasonably well-written) the class is usable and useful. Now, suppose we decide to use `unique_ptr<node>` instead of `node*` as the `head` data member for `single_linked_list`, and as a replacement for the `next` member of the node. This seems like a good idea, except when you consider the consequences:\n\n```", "```cpp\n\n This seems like a good idea on the surface, but it does not convey the proper semantics – it’s *not* true that a node *owns* and *is responsible for* the next node. We don’t want to make the removal of a node destroy the node that follows (and so on, recursively) and if that looks like a simplification in the destructor of `single_linked_list`, think about the consequences – this strategy leads to as many destructors recursively called as there are nodes in the list, which is a very good way to achieve a stack overflow!\nUse a smart pointer when the use case matches the semantics it models. Of course, when the relationship modeled by your pointers is neither unique ownership nor shared ownership, you probably do not want smart pointer types that provide these semantics, resorting instead to either nonstandard and non-owning smart pointers or, simply, raw pointers.\nFinally, you often need raw pointers to use lower-level interfaces – for example, when performing system calls. That does not disqualify higher-level abstractions, such as `vector<T>` or `unique_ptr<T>`, when writing system-level code – you can get access to the underlying array of `vector<T>` through its `data()` member function, just as you can get access to the underlying raw pointer of `unique_ptr<T>` through its `get()` member function. As long as it makes sense, see the called code as borrowing the pointer from the caller code for the duration of the call.\nAnd if you have no other choice, use raw pointers. They exist, after all, and they work. Simply remember to use higher-level abstractions wherever possible – it will make your code simpler, safer, and (more often than you would think) faster. If you cannot define the higher-level semantics, maybe it’s still a bit early to write that part of the code, and you’ll get better results if you spend more time thinking about these semantics.\nSummary\nIn this chapter, we saw how to use standard smart pointers. We discussed the ownership semantics they implement (sole ownership, shared co-ownership, and temporary co-ownership), saw examples of how they can be used, and discussed some ways in which they can be used while acknowledging that other, more appropriate options exist.\nIn the next chapter, we’ll take this a step further and write our own (usable, if naïve) versions of `unique_ptr<T>` and `shared_ptr<T>`, in order to get an intuitive grasp of what this entails, and we will write some nonstandard but useful smart pointers too. This will help us build a nicer, more interesting resource management toolset.\n\n```"]