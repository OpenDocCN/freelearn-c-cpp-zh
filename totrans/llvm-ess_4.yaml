- en: Chapter 4. Basic IR Transformations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 基本IR转换
- en: Until now, we have seen how the IR is independent of its target and how it can
    be used to generate code for a specific backend. To generate efficient code for
    the backend, we optimize the IR generated by the frontend by running a series
    of analysis and transformation passes using the LLVM pass manager. We must note
    that most of the optimizations that happen in a compiler take place on the IR,
    one of the reasons being that the IR is retargetable and the same set of optimizations
    would be valid for a number of targets. It reduces the effort of writing the same
    optimization for every target. There are some target-specific optimizations too;
    they happen at the selection DAG level, which we will see later. Another reason
    for IR being the target of optimization is that LLVM IR is in SSA form, which
    means every variable is assigned only once and every new assignment to a variable
    is a new variable itself. One very visible benefit of this representation is that
    we don't have to do reaching definition analysis where some variable is assigned
    a value of another variable. SSA representation also helps in a number of optimizations
    such as constant propagation, dead code elimination, and so on. Going ahead, we
    will see some of the important optimizations in LLVM, what is the role of LLVM
    Pass Infrastructure, and how we can use the opt tool to perform different optimizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 IR 如何独立于其目标，以及它如何被用来为特定的后端生成代码。为了为后端生成高效的代码，我们通过运行一系列分析和转换 Pass
    来优化前端生成的 IR，使用 LLVM Pass 管理器。我们必须注意，编译器中发生的许多优化都发生在 IR 上，其中一个原因是 IR 是可重定位的，同一组优化对于多个目标都是有效的。这减少了为每个目标编写相同优化的工作量。也有一些特定于目标的优化；它们在选择
    DAG 层级发生，我们将在后面看到。IR 成为优化目标的另一个原因是 LLVM IR 是 SSA 形式，这意味着每个变量只被分配一次，每个变量的新赋值本身就是一个新变量。这种表示的一个非常明显的优点是我们不必进行到达定义分析，其中某个变量被赋予另一个变量的值。SSA
    表示法也有助于许多优化，如常量传播、死代码消除等。接下来，我们将看到一些重要的 LLVM 优化，LLVM Pass 基础设施的作用，以及我们如何使用 opt
    工具执行不同的优化。
- en: 'In this chapter, we will cover following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The opt tool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opt 工具
- en: Pass and Pass Manager
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pass 和 Pass 管理器
- en: Using other Pass info in own pass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自己的 Pass 中使用其他 Pass 信息
- en: IR simplification examples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IR 简化示例
- en: IR combination examples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IR 组合示例
- en: Opt Tool
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Opt 工具
- en: '**Opt** is the LLVM Optimizer and analyzer tool that is run on LLVM IR to optimize
    the IR or produce an analysis about it. We saw in the first chapter a very basic
    introduction to the opt tool, and how to use it to run analysis and transformation
    passes. In this section, we will see what else the opt tool does. We must note
    that opt is a developer tool and all the optimizations that it provides can be
    invoked from the frontend as well.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Opt** 是在 LLVM IR 上运行的 LLVM 优化器和分析工具，用于优化 IR 或生成关于它的分析。我们在第一章中看到了对 opt 工具的非常基本的介绍，以及如何使用它来运行分析和转换
    Pass。在本节中，我们将了解 opt 工具还能做什么。我们必须注意，opt 是一个开发者工具，它提供的所有优化都可以从前端调用。'
- en: 'With the opt tool, we can specify the level of optimization that we need, which
    means we can specify the optimization levels from `O0`, `O1`, `O2`, to `O3`(`O0`
    being the least optimized code and `O3` being the most optimized code). Apart
    from these, there is also an optimization level `Os` or `Oz`, which deals with
    space optimization. The syntax to invoke one of these optimizations is:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 opt 工具，我们可以指定所需的优化级别，这意味着我们可以指定从 `O0`、`O1`、`O2` 到 `O3`（`O0` 是最不优化的代码，`O3`
    是最优化代码）的优化级别。除了这些，还有一个优化级别 `Os` 或 `Oz`，它处理空间优化。调用这些优化之一的语法是：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, x represents the optimization level, which can have a value from 0 to
    3 or s or z. These optimization levels are similar to what Clang frontend specifies.
    `-O0` represents no optimization whereas `–O1` means only few optimizations are
    enabled. `–O2` is a moderate level of optimization and `–O3` is the highest level
    of optimization, which is similar to `–O2` but it allows optimization that takes
    longer to perform or may generate larger code (the O3 level does not guarantee
    that the code will be the most optimized and efficient, it just says that the
    compiler will try more to optimize the code and in the process may break things
    also). `–Os` means optimization for size, basically not running optimizations
    which increase code size (for example, it removes `slp-vectorizer` optimization)
    and perform optimizations that reduce code size (for example, instruction combining
    optimization).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，x 代表优化级别，其值可以是 0 到 3 或 s 或 z。这些优化级别与 Clang 前端指定的类似。`-O0` 表示没有优化，而 `–O1`
    表示只启用少量优化。`–O2` 是一个适度的优化级别，而 `–O3` 是最高级别的优化，它与 `–O2` 类似，但它允许执行耗时更长或可能生成更大代码的优化（O3
    级别并不保证代码是最优化和高效的，它只是说明编译器会尝试更多优化代码，在这个过程中可能会破坏某些东西）。`–Os` 表示针对大小的优化，基本上不运行会增加代码大小的优化（例如，它会移除
    `slp-vectorizer` 优化）并执行减少代码大小的优化（例如，指令组合优化）。
- en: We can direct the opt tool to run a specific pass that we require. These passes
    can be one of the already defined passes listed at [http://llvm.org/docs/Passes.html](http://llvm.org/docs/Passes.html)
    or one of the passes we have written ourselves. The passes listed in the above
    link are also run in the optimization levels of `-O1`, `-O2`, and `-O3`. To view
    which pass is being run at a certain optimization level, use the `-debug-pass=Structure`
    command-line option along with the opt tool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将 opt 工具指向运行所需的具体 pass。这些 pass 可以是已经定义并列举在 [http://llvm.org/docs/Passes.html](http://llvm.org/docs/Passes.html)
    中的 pass，或者是我们自己编写的 pass。上述链接中列出的 pass 也在 `-O1`、`-O2` 和 `-O3` 的优化级别中运行。要查看在某个优化级别正在运行哪个
    pass，请使用 `-debug-pass=Structure` 命令行选项与 opt 工具一起使用。
- en: 'Let''s take an example to demonstrate the difference between the `O1` and `O2`
    level of optimization. The `O3` level generally has one or two more passes from
    `O2`. So, let''s take an example and see how much the `O2` level of optimization
    optimizes the code. Write the test code in the `test.ll` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来演示 `O1` 和 `O2` 优化级别的差异。`O3` 级别通常比 `O2` 级别多一个或两个遍历。所以，让我们举一个例子，看看 `O2`
    优化级别如何优化代码。将测试代码写入 `test.ll` 文件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this test code, the `callercaller` function calls the `caller` function,
    which in turn calls the `test` function, which performs an addition of two numbers
    and returns the value to its caller, which in turn returns the value to the `callercaller`
    function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试代码中，`callercaller` 函数调用 `caller` 函数，而 `caller` 函数又调用 `test` 函数，该函数执行两个数字的加法并返回值给其调用者，然后调用者将值返回给
    `callercaller` 函数。
- en: 'Now, run the `O1` and `O2` levels of optimization, as shown:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `O1` 和 `O2` 优化级别，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the difference in the optimized code for the
    `O1` and `O2` levels:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `O1` 和 `O2` 优化级别优化代码的差异：
- en: '![Opt Tool](img/00003.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Opt Tool](img/00003.jpeg)'
- en: As we can see, the code in `O2` has optimized the calls to the function and
    the `Add` operations as well and returns the result directly from the `callercaller`
    function. This is obtained due to the fact that `O2` optimization runs the passes
    **always-inline** which inlines all the function calls and treats the code as
    one big function. Then, in also runs the `globaldce` pass, which eliminates unreachable
    internals from the code. After this, it runs `constmerge` which merges duplicate
    global constants into a single constant. It also performs a global value numbering
    pass that eliminates partially or fully redundant instructions and eliminates
    redundant load instructions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`O2` 优化了函数调用和 `Add` 操作，并直接从 `callercaller` 函数返回结果。这是由于 `O2` 优化运行了 `always-inline`
    pass，它内联了所有函数调用并将代码视为一个大的函数。然后，它还运行了 `globaldce` pass，该 pass 从代码中消除了不可达的内部部分。之后，它运行
    `constmerge`，将重复的全局常量合并为单个常量。它还执行了一个全局值编号 pass，该 pass 消除了部分或完全冗余的指令，并消除了冗余的加载指令。
- en: Pass and Pass Manager
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pass 和 Pass Manager
- en: LLVM's `Pass` infrastructure is one of the many important features of the LLVM
    system. There are a number of analysis and optimization passes that can be run
    using this infrastructure. The starting point for LLVM passes is the `Pass` class,
    which is a superclass of all the passes. We need to inherit from some predefined
    subclasses taking into account what our pass is going to implement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的 `Pass` 基础设施是 LLVM 系统的许多重要特性之一。有多个分析和优化遍历可以使用这个基础设施运行。LLVM 遍历的起点是 `Pass`
    类，它是所有遍历的超类。我们需要从一些预定义的子类中继承，考虑到我们的遍历将要实现的功能。
- en: '**ModulePass**: This is the most general superclass. By inheriting this class
    we allow the entire module to be analyzed at once. The functions within the module
    may not be referred to in a particular order. To use it, write a subclass that
    inherits from the `ModulePass` subclass and overloads the `runOnModule` function.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ModulePass**: 这是最高级的超类。通过继承这个类，我们可以一次性分析整个模块。模块内的函数可以不按特定顺序引用。要使用它，编写一个继承自
    `ModulePass` 子类的子类，并重载 `runOnModule` 函数。'
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before going ahead with the discussion of other `Pass` classes, let''s look
    into the three virtual methods that the `Pass` classes override:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在讨论其他 `Pass` 类之前，让我们看看 `Pass` 类覆盖的三个虚拟方法：
- en: '**doInitialization**: This is meant to do initialization stuff that does not
    depend on the current function being processed.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**doInitialization**: 这意味着执行不依赖于当前正在处理的函数的初始化操作。'
- en: '**runOn{Passtype}**: This is the method where we should implement our subclass
    for the functionality of the pass. This will be `runOnFunction` for `FunctionPass`,
    `runOnLoop` for `LoopPass`, and so on.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runOn{Passtype}**: 这是实现我们子类以实现遍历功能的方法。对于 `FunctionPass`，这将对应于 `runOnFunction`，对于
    `LoopPass`，将对应于 `runOnLoop` 等。'
- en: '**doFinalization**: This is called when `runOn{Passtype}` has finished doing
    the job for every function in the program.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**doFinalization**: 当 `runOn{Passtype}` 为程序中的每个函数完成工作后，将调用此方法。'
- en: '**FunctionPass**: These passes execute on each function present in the module,
    independent from other functions in the module. There is no defined order in which
    the functions will be processed. They are not allowed to modify functions other
    than the one being processed, and any addition or deletion of functions from the
    current module is also not allowed. To implement `FunctionPass` we might need
    to overload the three virtual functions mentioned earlier by implementing in the
    `runOnFunction` method.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FunctionPass**: 这些遍历操作在模块中的每个函数上执行，独立于模块中的其他函数。没有定义函数处理的顺序。它们不允许修改正在处理的函数以外的函数，也不允许从当前模块中添加或删除函数。要实现
    `FunctionPass`，我们可能需要通过在 `runOnFunction` 方法中实现来重载前面提到的三个虚拟函数。'
- en: '**BasicBlockPass**: These passes work on basic blocks one at a time, independently
    of other basic blocks present in the program. They are not allowed to add or delete
    any new basic block or change the CFG. They are also not allowed to do things
    that `FunctionPass` is not allowed to. To implement, they can override the `doInitialization`
    and `doFinalization` methods of `FunctionPass`, or overload their own virtual
    methods for the two methods mentioned earlier and the `runOnBasicBlock` method.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BasicBlockPass**: 这些遍历操作一次处理一个基本块，独立于程序中存在的其他基本块。它们不允许添加或删除任何新的基本块或更改控制流图（CFG）。它们也不允许执行
    `FunctionPass` 不允许执行的操作。为了实现，它们可以重载 `FunctionPass` 的 `doInitialization` 和 `doFinalization`
    方法，或者重载它们自己的虚拟方法，用于前面提到的两个方法和 `runOnBasicBlock` 方法。'
- en: '**LoopPass**: These passes work on each loop in the function, independent of
    all other loops within the function. Loops are processed in such a way that the
    outermost loop is executed the last. To implement `LoopPass` we need to overload
    the `doInitialization`, `doFinalization`, and `runOnLoop` methods.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoopPass**: 这些遍历操作针对函数中的每个循环进行处理，独立于函数内的其他所有循环。循环的处理方式是，最外层的循环最后执行。要实现 `LoopPass`，我们需要重载
    `doInitialization`、`doFinalization` 和 `runOnLoop` 方法。'
- en: Now, let's see how to get started with writing a custom pass. Let's write a
    pass that will print the names of all the functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何开始编写自定义遍历。让我们编写一个遍历，该遍历将打印所有函数的名称。
- en: Before getting started with writing the implementation of the pass, we need
    to make changes in a few places in the code so that the pass is recognized and
    can be run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写遍历的实现之前，我们需要在代码的几个地方进行更改，以便遍历被识别并可以运行。
- en: 'We need to create a directory under the LLVM tree. Let''s make a directory,
    `lib/Transforms/FnNamePrint`. In this directory, we need to create a `Makefile`
    with the following contents, which will allow our pass to be compiled:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 LLVM 树下创建一个目录。让我们创建一个目录，`lib/Transforms/FnNamePrint`。在这个目录中，我们需要创建一个 `Makefile`，内容如下，这将允许我们的
    `pass` 被编译：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This specifies that all `.cpp` files should be compiled and linked into a shared
    object that will be available in the `lib` folder of the `build-folder` (`build-folder/lib/FnNamePrint.so`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了所有 `.cpp` 文件都应该编译并链接成一个共享对象，该对象将在 `build-folder` 的 `lib` 文件夹中可用（`build-folder/lib/FnNamePrint.so`）。
- en: 'Now, let''s get started with writing the actual pass implementation. We need
    to create the source file for the pass in `lib/Transforms/FnNamePrint`: let''s
    name it `FnNamePrint.cpp`. The first step now is to choose the correct subclass.
    In this case, as we are trying to print names of each function, the `FunctionPass`
    class will serve our purpose by processing one function at a time. Also, we are
    only printing the name of function and not modifying anything within it, so we
    are choosing `FunctionPass` for simplicity. We could use `ModulePass` as well
    because it is an `Immutable Pass`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写实际的 `pass` 实现。我们需要在 `lib/Transforms/FnNamePrint` 中创建 `pass` 的源文件：让我们命名为
    `FnNamePrint.cpp`。现在的第一步是选择正确的子类。在这种情况下，因为我们试图打印每个函数的名称，所以 `FunctionPass` 类将一次处理一个函数来满足我们的目的。此外，我们只打印函数的名称，而不修改其内部的内容，所以我们选择
    `FunctionPass` 以保持简单。我们也可以使用 `ModulePass`，因为它是一个 `Immutable Pass`。
- en: 'Now, let''s write the source code for the pass implementation, which looks
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写 `pass` 实现的源代码，它看起来是这样的：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code we `include` the necessary headers first and use an `llvm`
    namespace:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先 `include` 所需的头文件，并使用 `llvm` 命名空间：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We declare our pass as a structure, `FnNamePrint`, which is a subclass of `FunctionPass`.
    In `runOnFunction` we implement the logic to print the function name. The `bool`
    value returned in the end signifies whether we have made any modification within
    the function. A `True` value is returned if some modifications was made, otherwise,
    `false` is returned. In our case, we are not making any modifications, so we return
    `false`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的 `pass` 声明为一个结构体，`FnNamePrint`，它是 `FunctionPass` 的子类。在 `runOnFunction`
    中，我们实现了打印函数名的逻辑。最后返回的 `bool` 值表示我们是否在函数内进行了任何修改。如果进行了修改，则返回 `True`，否则返回 `false`。在我们的例子中，我们没有进行任何修改，所以返回
    `false`。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we declare the `ID` for the pass, which is used to identify the pass:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明该 `pass` 的 `ID`，它用于识别该 `pass`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we need to register the passes with the Pass Manager. The first argument
    is the Pass name used by the `opt` tool to identify this pass. The second argument
    is the actual Pass name. The third and fourth arguments specify whether the pass
    modified the `cfg` and whether it is an analysis pass.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `pass` 注册到 `Pass Manager` 中。第一个参数是 `opt` 工具用于识别此 `pass` 的 `Pass` 名称。第二个参数是实际的
    `Pass` 名称。第三个和第四个参数指定 `pass` 是否修改了 `cfg` 以及它是否是一个分析 `pass`。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation of the pass is done. Now, before we use it, we need to build
    LLVM using the `make` command, which will build the shared object in the `lib`
    folder within the build (`build-folder/lib/FnNamePrint.so`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass` 的实现已完成。现在，在我们使用它之前，我们需要使用 `make` 命令构建 LLVM，这将构建构建（`build-folder/lib/FnNamePrint.so`）文件夹中的共享对象。'
- en: 'Now, we can run the pass over a test case using the `opt` tool in the following
    way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下方式使用 `opt` 工具在测试用例上运行 `pass`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `load` command line option specifies the path from where to pick the shared
    object of the pass and `–funcnameprint` is the option to opt tool to tell it to
    run the pass we have written. The Pass will print the names of all the function
    present in the testcase. For the example in the first section it will print out:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 命令行选项指定了从哪里获取 `pass` 的共享对象，`–funcnameprint` 是用于告诉 opt 工具运行我们编写的 `pass`
    的选项。该 `pass` 将打印出测试用例中所有函数的名称。对于第一部分中的示例，它将打印出：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we got started with writing a Pass. Now, we will see the significance of
    the `PassManager` class in LLVM.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们开始了编写 `Pass`。现在，我们将看到 `PassManager` 类在 LLVM 中的重要性。
- en: The `PassManager` class schedules the passes to be run efficiently. The `PassManager`
    is used by all LLVM tools that run passes for the execution of these passes. It
    is the responsibility of the `PassManager` to make sure the interaction between
    the passes is correctly done. As it tries to execute the passes in an optimized
    way, it must have information regarding how the passes interact with each other
    and what the different dependencies between the passes are.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManager` 类安排运行的 passes 以实现高效。`PassManager` 被所有运行 passes 的 LLVM 工具使用。确保
    passes 之间的交互正确是 `PassManager` 的责任。因为它试图以优化的方式执行 passes，它必须了解 passes 如何相互交互以及 passes
    之间的不同依赖关系。'
- en: A pass itself can specify the dependency on other passes, that is, which passes
    need to be run before the execution of the current pass. Also, it can specify
    the passes that will be invalidated by the execution of the current pass. The
    `PassManager` gets the analysis results before a pass is executed. We will later
    see how a pass can specify such dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 pass 可以指定对其他 passes 的依赖，即哪些 passes 需要在当前 pass 执行之前运行。它还可以指定由当前 pass 执行而失效的
    passes。`PassManager` 在执行 pass 之前获取分析结果。我们将在后面看到 pass 如何指定此类依赖。
- en: The main work of the `PassManager` is to avoid the calculation of analysis results
    time and again. This is done by keeping track of which analyses are available,
    which are invalidated, and which analyses are required. The `PassManager` tracks
    the lifetimes of the analysis results and frees the memory holding the analysis
    results when not required, allowing for optimal memory use.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManager` 的主要工作是避免反复计算分析结果。这是通过跟踪哪些分析可用、哪些已失效以及哪些分析是必需的来实现的。`PassManager`
    跟踪分析结果的生命周期，并在不需要时释放持有分析结果的内存，从而实现最优的内存使用。'
- en: The `PassManager` pipelines the passes together to get better memory and cache
    results, improving the cache behavior of the compiler. When a series of consecutive
    `FunctionPass` are given, it will execute all the `FunctionPass` on the first
    function, then all the `FunctionPass` on the second function, and so on. This
    improves cache behavior as it is only dealing with the single function part of
    the LLVM representation and not the entire program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManager` 将 passes 管道化以获得更好的内存和缓存结果，从而改善编译器的缓存行为。当给出一系列连续的 `FunctionPass`
    时，它将在第一个函数上执行所有 `FunctionPass`，然后在第二个函数上执行所有 `FunctionPass`，依此类推。这改善了缓存行为，因为它只处理
    LLVM 表示中的单个函数部分，而不是整个程序。'
- en: 'The `PassManager` also specifies the `–debug-pass` option with which we can
    see how one pass interacts with other passes. We can see what all passes are run
    using the `–debug-pass=Argument` option. We can use the `–debug-pass=Structure`
    option to see how the passes had run. It will also give us the names of the passes
    that ran. Let''s take the example of the test code in the first section of this
    chapter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManager` 还指定了 `–debug-pass` 选项，我们可以用它来查看一个 pass 如何与其他 pass 交互。我们可以使用 `–debug-pass=Argument`
    选项查看所有运行的 passes。我们可以使用 `–debug-pass=Structure` 选项来查看 passes 的运行情况。它还会给出运行过的 passes
    的名称。让我们以本章第一节的测试代码为例：'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the output, the `Pass Arguments` gives us the passes that are run and the
    following list is the structure used to run each pass. The Passes just after `ModulePass`
    `Manager` will show the passes run per module (here, it is empty). The passes
    in hierarchy of `FunctionPass` `Manager` show that these passes were run per function
    (`Function Name Print` and `Module Verifier`), which is the expected result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，`Pass Arguments` 给出了运行的 passes，以下列表是运行每个 pass 所使用的结构。紧接在 `ModulePass` `Manager`
    之后的 Passes 将显示每个模块运行的 passes（这里为空）。`FunctionPass` `Manager` 层级中的 passes 显示这些 passes
    是按函数运行的（这里是 `Function Name Print` 和 `Module Verifier`），这是预期的结果。
- en: 'The `PassManger` also provides some other useful flags, some of which are the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManger` 还提供了一些其他有用的标志，其中一些如下：'
- en: '**time-passes**: This gives time information about the pass along with the
    other passes that are lined up.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**time-passes**: 这提供了关于 pass 以及其他排队 passes 的时间信息。'
- en: '**stats**: This prints statistics about each pass.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stats**: 这会打印每个 pass 的统计信息。'
- en: '**instcount**: This collects the count of all instructions and reports them.
    `–stats` must also be Passes to the opt tool so that the results of `instcount`
    are visible.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**instcount**: 这会收集所有指令的计数并报告它们。`–stats` 也必须传递给 opt 工具，以便 `instcount` 的结果可见。'
- en: Using other Pass info in current Pass
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前 Pass 中使用其他 Pass 信息
- en: 'For the Pass Manager to work optimally it needs to know the dependencies between
    the Passes. Each of the passes can itself declare its dependencies: the analysis
    passes that need to be executed before this pass is executed and the passes that
    will get invalidated after the current pass is run. To specify these dependencies,
    a pass needs to implement the `getAnalysisUsage` method.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使遍历管理器最优运行，它需要知道遍历之间的依赖关系。每个遍历都可以自己声明其依赖关系：在执行此遍历之前需要执行的分析遍历以及当前遍历运行后将被使无效的遍历。为了指定这些依赖关系，一个遍历需要实现`getAnalysisUsage`方法。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using this method the current pass can specify the required and invalidated
    sets by filling in the details in the `AnalysisUsage` object. To fill in the information
    the Pass needs to call any of the following methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，当前遍历可以通过在`AnalysisUsage`对象中填写详细信息来指定所需和无效化的集合。为了填写信息，遍历需要调用以下任何一种方法：
- en: AnalysisUsage::addRequired<> method
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AnalysisUsage::addRequired<>`方法'
- en: 'This method arranges for the execution of a Pass prior to the current Pass.
    One example of this is: for memory copy optimization it needs the results of an
    alias analysis:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法安排在当前遍历之前执行一个遍历。一个例子是：对于内存复制优化，它需要别名分析的结果：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By adding the pass required to run, it is made sure that `Alias Analysis Pass`
    is run before the `MemCpyOpt` Pass. Also, this makes sure that if the `Alias Analysis`
    has been invalidated by some other Pass, it will be run before the `MemCpyOpt`
    Pass is run.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加需要运行的遍历，确保在`MemCpyOpt`遍历之前运行`Alias Analysis Pass`。这也确保了如果`Alias Analysis`已被其他遍历使无效，它将在运行`MemCpyOpt`遍历之前运行。
- en: AnalysisUsage:addRequiredTransitive<> method
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AnalysisUsage::addRequiredTransitive<>`方法'
- en: 'When an analysis chains to other analyses for results, this method should be
    used instead of the `addRequired` method. That is, when we need to preserve the
    order in which the analysis passes are run we use this method. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析链到其他分析以获取结果时，应使用此方法而不是`addRequired`方法。也就是说，当我们需要保留分析遍历的运行顺序时，我们使用此方法。例如：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `DependenceAnalysis` chains to `AliasAnalysis`, `ScalarEvolution` and
    `LoopInfo` Passes for the results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DependenceAnalysis`通过`AliasAnalysis`、`ScalarEvolution`和`LoopInfo`遍历链到结果。
- en: AnalysisUsage::addPreserved<> method
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AnalysisUsage::addPreserved<>`方法'
- en: 'By using this method a Pass can specify which analyses of other Passes it will
    not invalidate on running: that is, it will preserve the information already present,
    if any. This means that the subsequent passes that require the analysis would
    not need to run this again.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此方法，一个遍历可以指定它在运行时不会使其他遍历的分析无效：也就是说，如果存在，它将保留现有信息。这意味着后续需要该分析的遍历不需要再次运行。
- en: 'For example, in the case of the `MemCpyOpt` Pass seen earlier, it required
    the `AliasAnalysis` results and it also preserved them. Also:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面看到的`MemCpyOpt`遍历的情况下，它需要`AliasAnalysis`的结果，并且还保留了它们。此外：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To get a detailed understanding of how everything is linked and works together,
    you can pick up any of the transformation passes and go through the source code
    and you will know how they are getting information from other passes and how they
    are using it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细了解所有这些是如何相互关联和协同工作的，你可以选择任何转换遍历，查看源代码，你就会知道它们是如何从其他遍历获取信息以及如何使用这些信息的。
- en: Instruction simplification example
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令简化示例
- en: 'In this section, we will see how we fold instructions into simpler forms in
    LLVM. Here, the creation of new instructions will not take place. Instruction
    simplification does constant folding:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在LLVM中将指令折叠成更简单的形式。在这里，不会创建新的指令。指令简化包括常量折叠：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is, it simplifies the `sub` instruction to a constant value `1`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它将`sub`指令简化为常量值`1`。
- en: 'It can handle non-constant operands as well:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以处理非常量操作数：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It returns a value of variable `%x`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回变量`%x`的值
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, it returns an already existing value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它返回一个已存在的值。
- en: The implementations for the methods that simplify instructions are located in
    `lib/Analysis/InstructionSimplify.cpp`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简化指令的方法实现位于`lib/Analysis/InstructionSimplify.cpp`。
- en: 'Some of the important methods of dealing with the simplification of instructions
    are:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 处理指令简化的某些重要方法包括：
- en: '**SimplifyBinOp method**: This is used to simplify binary operations such as
    addition, subtraction, and multiplication, and so on. It has the function signature
    as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplifyBinOp方法**：此方法用于简化二进制运算，如加法、减法和乘法等。它的函数签名如下：'
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, by `Opcode`, we mean the operator instruction that we are trying to simplify.
    LHS and RHS are the operands on either side of the operator. `MaxRecurse` is the
    recursion level we specify after which the routine must stop trying simplification
    of the instruction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过 `Opcode` 指的是我们试图简化的操作符指令。LHS 和 RHS 是操作符两边的操作数。`MaxRecurse` 是我们指定的递归级别，在此之后，例程必须停止尝试简化指令。
- en: 'In this method, we have a switch case on the `Opcode`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们对 `Opcode` 有一个 switch 案例处理：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using this `Opcode,` the method decides which function it needs to call for
    simplification. Some of the methods are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Opcode`，该方法决定需要调用哪个函数进行简化。以下是一些方法：
- en: '**SimplifyAddInst**: This method tries to fold the result of the `Add` operator
    when the operands are known. Some of the folding is as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplifyAddInst**：此方法尝试在操作数已知时折叠 `Add` 操作符的结果。以下是一些折叠的例子：'
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code for the last simplification in the function `static` `Value *SimplifyAddInst(Value
    *Op0, Value *Op1, bool isNSW, bool isNUW, const Query &Q, unsigned MaxRecurse
    )` looks something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `static Value *SimplifyAddInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
    const Query &Q, unsigned MaxRecurse )` 中最后简化的代码看起来像这样：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the first condition matches the `(Y-X)` value in the expression as `Operand1:
    m_Value(Y)` denotes value of `Y` and `m_Specific(Op0)` denotes `X`. As soon as
    it is matched it folds the expression to a constant value `Y` and returns it.
    The case is similar for the second part of our condition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，第一个条件匹配表达式中的 `(Y-X)` 值，因为 `Operand1: m_Value(Y)` 表示 `Y` 的值，而 `m_Specific(Op0)`
    表示 `X`。一旦匹配成功，它将表达式折叠为常量值 `Y` 并返回它。对于条件的第二部分也是类似的情况：'
- en: '**SimplifySubInst**: This method tries to fold the result of `subtract` operator
    when the operators are known. Some examples for the same are as follows:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplifySubInst**：此方法尝试在操作符已知时折叠 `subtract` 操作符的结果。以下是一些相同示例：'
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The matching of instructions and folding is done similar to as shown in `SimplifyAddInst`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 指令匹配和折叠的执行方式类似于 `SimplifyAddInst` 中所示：
- en: '**SimplifyAndInst**: Similar to the two preceding methods, it tries to fold
    the result for the logical operator And. Some examples of this are:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplifyAndInst**：与前面两种方法类似，它尝试折叠逻辑运算符 And 的结果。以下是一些示例：'
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code for this, in the method looks like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，代码看起来像这样：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, it tries to match `A` and `~A` and returns a `Null` value, 0, when it
    matches the condition.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它尝试匹配 `A` 和 `~A`，并在匹配到条件时返回一个 `Null` 值，即 0。
- en: So, we have seen a bit of instruction simplification. Now, what do we do if
    we can replace a set of instructions with a more effective set of instructions?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了一些指令简化的例子。那么，如果我们可以用一组更有效的指令替换一组指令，我们该怎么办呢？
- en: Instruction Combining
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令组合
- en: Instruction combining is a LLVM Pass and compiler technique in which we replace
    a sequence of instructions with instructions that are more effective and give
    the same result on execution in a smaller number of machine cycles. Instruction
    combining does not alter the CFG of the program and is mainly used for algebraic
    simplification. The major difference between instruction combining and instruction
    simplification is that in instruction simplification we cannot generate new instructions,
    which is possible in instruction combining. This pass is run by specifying the
    `–instcombine` argument to the opt tool and is implemented in the `lib/transforms/instcombine`
    folder. The `instcombine` Pass combines
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 指令组合是 LLVM 传递和编译技术，其中我们用更有效且在更少的机器周期内执行相同结果的指令替换一系列指令。指令组合不会改变程序的 CFG，主要用于代数简化。指令组合与指令简化的主要区别在于，在指令简化中我们不能生成新的指令，而在指令组合中是可能的。此传递通过指定
    opt 工具的 `–instcombine` 参数来运行，并在 `lib/transforms/instcombine` 文件夹中实现。`instcombine`
    传递组合
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It has removed one redundant `add` instruction and hence combined the two `add`
    instructions to one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它已删除一个冗余的 `add` 指令，因此将两个 `add` 指令合并为一个。
- en: 'The LLVM page states that this pass guarantees that the following canonicalizations
    are performed on the program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 页面指出，此传递确保在程序上执行以下规范化的操作：
- en: Constant operand of a binary operator is moved to RHS.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元运算符的常数操作数被移动到 RHS。
- en: Bitwise operators with constant operands are grouped together with shifts being
    performed first then 'or' operations, 'and' operations and then 'xor operations'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有常数操作数的位运算符与位移运算一起分组，首先执行位移运算，然后是 'or' 操作，'and' 操作，最后是 'xor' 操作。
- en: If possible, comparison operators are converted from <,>,<=,>= to == or != .
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，比较运算符从 <,>,<=,>= 转换为 == 或 !=。
- en: All `cmp` instructions operating on Boolean values are replaced with logical
    operations.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有操作布尔值的 `cmp` 指令都被替换为逻辑操作。
- en: Add X, X is represented by X*2 , that is X<<1
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 X，X 表示为 X*2，即 X<<1
- en: Multipliers with a power-of-two constant argument are transformed into shifts.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数为 2 的幂的乘法器被转换为位移操作。
- en: 'This pass starts from `bool InstCombiner::runOnFunction(Function &F)` located
    in the `InstructionCombining.cpp` file. There are different files under the `lib/Transform/InstCombine`
    folder to combine instructions related to different instructions. The methods,
    before trying to combine instructions, try to simplify them. Some of these methods
    for simplification of the `instcombine` module are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从 `bool InstCombiner::runOnFunction(Function &F)` 开始，该函数位于 `InstructionCombining.cpp`
    文件中。在 `lib/Transform/InstCombine` 文件夹下有不同文件，用于组合与不同指令相关的指令。在尝试组合指令之前，这些方法试图简化它们。其中一些用于简化
    `instcombine` 模块的简化方法包括：
- en: '**SimplifyAssociativeOrCommutative function**: It performs simplification for
    operators that are associative or commutative. For commutative operators, it orders
    the operands from right to left in the order of increasing complexity. For associative
    operations of the form "`(X op Y) op Z`", it converts it to "`X op (Y op Z)`"
    if (Y op Z) can be simplified.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplifyAssociativeOrCommutative 函数**：它对具有结合律或交换律的运算符进行简化。对于交换律运算符，它按复杂度递增的顺序从右到左对操作数进行排序。对于形式为
    "`(X op Y) op Z`" 的结合律运算，如果 (Y op Z) 可以简化，则将其转换为 "`X op (Y op Z)`"。'
- en: '**tryFactorization function**: This method tries to simplify binary operations
    by factoring out common terms using commutative and distributive property of the
    operator. For example, `(A*B)+(A*C)` is simplified to `A*(B+C)`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tryFactorization 函数**：该方法尝试通过使用运算符的交换律和分配律提取公共项来简化二进制运算。例如，`(A*B)+(A*C)`
    被简化为 `A*(B+C)`。'
- en: Now, let's look at instruction combining. As described earlier, various functionalities
    are implemented in different files. Let's take an example testcode and see where
    to add code so that instruction combining happens for our testcode.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看指令组合。如前所述，不同的功能在不同的文件中实现。让我们以一个示例测试代码为例，看看在哪里添加代码，以便为我们的测试代码执行指令组合。
- en: 'Let''s write the testcode in `test.ll` for the pattern `(A | (B ^ C)) ^ ((A
    ^ C) ^ B)`, which can be reduced to `(A & (B ^ C))`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `test.ll` 中编写测试代码，以匹配模式 `(A | (B ^ C)) ^ ((A ^ C) ^ B)`，该模式可以简化为 `(A &
    (B ^ C))`：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code in LLVM for the handling of operators such as "And", "Or", and "Xor"
    lies in the `lib/Transforms/InstCombine/InstCombineAndOrXor.cpp` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 中处理 "And"、"Or" 和 "Xor" 等运算符的代码位于 `lib/Transforms/InstCombine/InstCombineAndOrXor.cpp`
    文件中。
- en: 'In the `InstCombineAndOrXor.cpp` file, in the `InstCombiner::visitXor(BinaryOperator
    &I)` function, go to the `if` condition `If` `(Op0I && Op1I)` and add the following
    snippet of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InstCombineAndOrXor.cpp` 文件中，在 `InstCombiner::visitXor(BinaryOperator &I)`
    函数中，转到 `if` 条件 `If` `(Op0I && Op1I)` 并添加以下代码片段：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As it is quite clear, the code added is to match the pattern `(A | (B ^ C))
    ^ ((A ^ C) ^ B)` and return `(A & (B ^ C))` when matched.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如此明显，添加的代码是为了匹配模式 `(A | (B ^ C)) ^ ((A ^ C) ^ B)` 并在匹配时返回 `(A & (B ^ C))`。
- en: To test the code, build LLVM and run the `instcombine` Pass with this test code
    and see the output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，构建 LLVM 并使用此测试代码运行 `instcombine` Pass，查看输出。
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So the output shows that now only one `xor` `and` one and operation is required
    instead of four `xor` and one `or` earlier`.`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出显示现在只需要一个 `xor` 和一个 `and` 操作，而不是之前所需的四个 `xor` 和一个 `or` 操作。
- en: To understand and add more transformations you can look into the source code
    in the `InstCombine` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解和添加更多转换，您可以查看 `InstCombine` 文件夹中的源代码。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this chapter, we looked into how simple transformations can be applied
    to IR. We looked into the opt tool, LLVM Pass infrastructure, the `Passmanager`
    and how to use information of one Pass in another Pass. We ended the chapter with
    examples of instruction simplification and instruction combining. In the next
    chapter, we will see some more advanced optimizations like Loop Optimization,
    Scalar Evolution, and others, where we will operate at a block of code rather
    than individual instructions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们探讨了如何将简单的转换应用于 IR。我们探讨了 opt 工具、LLVM Pass 基础设施、`Passmanager` 以及如何在
    Pass 之间使用信息。我们以指令简化和指令组合的示例结束本章。在下一章中，我们将看到一些更高级的优化，如循环优化、标量演化等，在这些优化中，我们将操作代码块而不是单个指令。
