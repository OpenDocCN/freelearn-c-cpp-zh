["```cpp\n\nclass Triple {\npublic:\n  enum ArchType {\n      // Many more members\n      m88k,      // M88000 (big endian): m88k\n  };\n  /// Tests whether the target is M88k.\n  bool isM88k() const {\n      return getArch() == Triple::m88k;\n  }\n// Many more methods\n};\n```", "```cpp\n\n switch (Kind) {\n     // Many more cases\n     case m88k:           return \"m88k\";\n  }\n```", "```cpp\n\n    #ifndef ELF_RELOC\n    #error \"ELF_RELOC must be defined\"\n    #endif\n    ELF_RELOC(R_88K_NONE, 0)\n    ELF_RELOC(R_88K_COPY, 1)\n    // Many more…\n    ```", "```cpp\n\n    // M88k Specific e_flags\n    enum : unsigned {\n        EF_88K_NABI = 0x80000000,   // Not ABI compliant\n        EF_88K_M88110 = 0x00000004  // File uses 88110-specific features\n    };\n    // M88k relocations.\n    enum {\n        #include \"ELFRelocs/M88k.def\"\n    };\n    ```", "```cpp\n\n      switch (EF.getHeader()->e_ident[ELF::EI_CLASS]) {\n    // Many more cases\n        case ELF::EM_88K:\n          return \"elf32-m88k\";\n      }\n    ```", "```cpp\n\n      switch (EF.getHeader().e_machine) {\n    // Many more cases\n      case ELF::EM_88K:\n        return Triple::m88k;\n    ```", "```cpp\n\n      switch (Machine) {\n    // Many more cases\n       case ELF::EM_88K:\n        switch (Type) {\n    #include \"llvm/BinaryFormat/ELFRelocs/M88k.def\"\n        default:\n          break;\n        }\n        break;\n      }\n    ```", "```cpp\n\n      ECase(EM_88K);\n    ```", "```cpp\n\n      case ELF::EM_88K:\n    #include \"llvm/BinaryFormat/ELFRelocs/M88k.def\"\n        break;\n    ```", "```cpp\n\nclass M88kReg<bits<5> Enc, string n> : Register<n> {\n  let HWEncoding{15-5} = 0;\n  let HWEncoding{4-0} = Enc;\n  let Namespace = \"M88k\";\n}\n```", "```cpp\n\nforeach I = 0-31 in {\n  let isConstant = !eq(I, 0) in\n    def R#I : M88kReg<I, \"r\"#I>;\n}\n```", "```cpp\n\nclass M88kRegisterClass<list<ValueType> types, int size,\n                        int alignment, dag regList,\n                        int copycost = 1>\n  : RegisterClass<\"M88k\", types, alignment, regList> {\n      let Size = size;\n      let CopyCost = copycost;\n}\n```", "```cpp\n\nclass M88kRegisterOperand<RegisterClass RC>\n    : RegisterOperand<RC> {\n  let DecoderMethod = \"decode\"#RC#\"RegisterClass\";\n}\n```", "```cpp\n\ndef GPR : M88kRegisterClass<[i32, f32], 32, 32,\n                            (add (sequence \"R%u\", 0, 31))>;\n```", "```cpp\n\ndef GPROpnd : M88kRegisterOperand<GPR> {\n  let GIZeroRegister = R0;\n}\n```", "```cpp\n\nlet Namespace = \"M88k\" in {\n  def sub_hi : SubRegIndex<32, 0>;\n  def sub_lo : SubRegIndex<32, 32>;\n}\n```", "```cpp\n\ndef GRPair : RegisterTuples<[sub_hi, sub_lo],\n                          [(add (sequence \"R%u\", 0, 30, 2)),\n                           (add (sequence \"R%u\", 1, 31, 2))]>;\n```", "```cpp\n\ndef GPR64 : M88kRegisterClass<[i64, f64], 64, 32,\n                              (add GRPair), /*copycost=*/ 2>;\ndef GPR64Opnd : M88kRegisterOperand<GPR64>;\n```", "```cpp\n\nclass InstM88k<dag outs, dag ins, string asm, string operands,\n               list<dag> pattern = []>\n  : Instruction {\n  bits<32> Inst;\n  bits<32> SoftFail = 0;\n  let Namespace = \"M88k\";\n  let Size = 4;\n  dag OutOperandList = outs;\n  dag InOperandList = ins;\n  let AsmString = !if(!eq(operands, \"\"), asm,\n                      !strconcat(asm, \" \", operands));\n  let Pattern = pattern;\n  let DecoderNamespace = \"M88k\";\n}\n```", "```cpp\n\nclass F_L<dag outs, dag ins, string asm, string operands,\n          list<dag> pattern = []>\n   : InstM88k<outs, ins, asm, operands, pattern> {\n  bits<5>  rd;\n  bits<5>  rs1;\n  let Inst{25-21} = rd;\n  let Inst{20-16} = rs1;\n}\n```", "```cpp\n\nclass F_LR<bits<5> func, bits<1> comp, string asm,\n           list<dag> pattern = []>\n   : F_L<(outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),\n         !if(comp, !strconcat(asm, \".c\"), asm),\n         \"$rd, $rs1, $rs2\", pattern> {\n  bits<5>  rs2;\n  let Inst{31-26} = 0b111101;\n  let Inst{15-11} = func;\n  let Inst{10}    = comp;\n  let Inst{9-5}   = 0b00000;\n  let Inst{4-0}   = rs2;\n}\n```", "```cpp\n\nmulticlass Logic<bits<5> Fun, string OpcStr, SDNode OpNode> {\n  let isCommutable = 1 in\n    def rr : F_LR<Fun, /*comp=*/0b0, OpcStr,\n                  [(set i32:$rd,\n                   (OpNode GPROpnd:$rs1, GPROpnd:$rs2))]>;\n  def rrc : F_LR<Fun, /*comp=*/0b1, OpcStr,\n                 [(set i32:$rd,\n                 (OpNode GPROpnd:$rs1, (not GPROpnd:$rs2)))]>;\n}\n```", "```cpp\n\ndefm AND : Logic<0b01000, \"and\", and>;\ndefm XOR : Logic<0b01010, \"xor\", xor>;\ndefm OR  : Logic<0b01011, \"or\", or>;\n```", "```cpp\n\ninclude \"llvm/Target/Target.td\"\ninclude \"M88kRegisterInfo.td\"\ninclude \"M88kInstrFormats.td\"\ninclude \"M88kInstrInfo.td\"\n```", "```cpp\n\ndef M88kInstrInfo : InstrInfo;\n```", "```cpp\n\ndef M88kAsmParser : AsmParser;\ndef M88kAsmParserVariant : AsmParserVariant {\n  let RegisterPrefix = \"%\";\n}\n```", "```cpp\n\ndef M88k : Target {\n  let InstructionSet = M88kInstrInfo;\n  let AssemblyParsers  = [M88kAsmParser];\n  let AssemblyParserVariants = [M88kAsmParserVariant];\n}\n```", "```cpp\n\n    using namespace llvm;\n    Target &llvm::getTheM88kTarget() {\n      static Target TheM88kTarget;\n      return TheM88kTarget;\n    }\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kTargetInfo() {\n        RegisterTarget<Triple::m88k, /*HasJIT=*/false> X(\n          getTheM88kTarget(), \"m88k\", \"M88k\", \"M88k\");\n    }\n    ```", "```cpp\n\n    namespace llvm {\n    class Target;\n    Target &getTheM88kTarget();\n    }\n    ```", "```cpp\n\n    add_llvm_component_library(LLVMM88kInfo\n      M88kTargetInfo.cpp\n      LINK_COMPONENTS  Support\n      ADD_TO_COMPONENT M88k)\n    ```", "```cpp\n\n    using namespace llvm;\n    #define GET_INSTRINFO_MC_DESC\n    #include \"M88kGenInstrInfo.inc\"\n    #define GET_SUBTARGETINFO_MC_DESC\n    #include \"M88kGenSubtargetInfo.inc\"\n    #define GET_REGINFO_MC_DESC\n    #include \"M88kGenRegisterInfo.inc\"\n    ```", "```cpp\n\n    static MCInstrInfo *createM88kMCInstrInfo() {\n        MCInstrInfo *X = new MCInstrInfo();\n        InitM88kMCInstrInfo(X);\n        return X;\n    }\n    ```", "```cpp\n\n    static MCRegisterInfo *\n    createM88kMCRegisterInfo(const Triple &TT) {\n        MCRegisterInfo *X = new MCRegisterInfo();\n        InitM88kMCRegisterInfo(X, M88k::R1);\n        return X;\n    }\n    ```", "```cpp\n\n    static MCSubtargetInfo *\n    createM88kMCSubtargetInfo(const Triple &TT,\n                              StringRef CPU, StringRef FS) {\n      return createM88kMCSubtargetInfoImpl(TT, CPU,\n                                           /*TuneCPU*/ CPU,\n                                           FS);\n    }\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kTargetMC() {\n      TargetRegistry::RegisterMCInstrInfo(\n          getTheM88kTarget(), createM88kMCInstrInfo);\n      TargetRegistry::RegisterMCRegInfo(\n          getTheM88kTarget(), createM88kMCRegisterInfo);\n      TargetRegistry::RegisterMCSubtargetInfo(\n          getTheM88kTarget(), createM88kMCSubtargetInfo);\n    }\n    ```", "```cpp\n\n    #define GET_REGINFO_ENUM\n    #include \"M88kGenRegisterInfo.inc\"\n    #define GET_INSTRINFO_ENUM\n    #include \"M88kGenInstrInfo.inc\"\n    #define GET_SUBTARGETINFO_ENUM\n    #include \"M88kGenSubtargetInfo.inc\"\n    ```", "```cpp\n\n#include \"TargetInfo/M88kTargetInfo.h\"\n#include \"llvm/MC/TargetRegistry.h\"\nextern \"C\" LLVM_EXTERNAL_VISIBILITY void\nLLVMInitializeM88kTarget() {\n  // TODO Register the target machine. See chapter 12.\n}\n```", "```cpp\n\nset(LLVM_ALL_EXPERIMENTAL_TARGETS ARC … M88k  …)\n```", "```cpp\n\n$ mkdir build\n$ cd build\n$ cmake -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k \\\n  ../llvm-m88k/llvm\n…\n-- Targeting M88k\n…\n```", "```cpp\n\n$ bin/llc –version\nLLVM (http://llvm.org/):\n  LLVM version 17.0.2\n  Registered Targets:\n    m88k     - M88k\n```", "```cpp\n\n    namespace llvm {\n    class Triple;\n    class M88kMCAsmInfo : public MCAsmInfoELF {\n    public:\n      explicit M88kMCAsmInfo(const Triple &TT);\n    };\n    ```", "```cpp\n\n    using namespace llvm;\n    M88kMCAsmInfo::M88kMCAsmInfo(const Triple &TT) {\n      IsLittleEndian = false;\n      UseDotAlignForAlignment = true;\n      MinInstAlignment = 4;\n      CommentString = \"|\"; // # as comment delimiter is only\n                           // allowed at first column\n      ZeroDirective = \"\\t.space\\t\";\n      Data64bitsDirective = \"\\t.quad\\t\";\n      UsesELFSectionDirectiveForBSS = true;\n      SupportsDebugInformation = false;\n      ExceptionsType = ExceptionHandling::SjLj;\n    }\n    ```", "```cpp\n\n    using namespace llvm;\n    #define DEBUG_TYPE \"mccodeemitter\"\n    STATISTIC(MCNumEmitted,\n              \"Number of MC instructions emitted\");\n    ```", "```cpp\n\n    namespace {\n    class M88kMCCodeEmitter : public MCCodeEmitter {\n      const MCInstrInfo &MCII;\n      MCContext &Ctx;\n    public:\n      M88kMCCodeEmitter(const MCInstrInfo &MCII,\n                        MCContext &Ctx)\n          : MCII(MCII), Ctx(Ctx) {}\n      ~M88kMCCodeEmitter() override = default;\n      void encodeInstruction(\n          const MCInst &MI, raw_ostream &OS,\n          SmallVectorImpl<MCFixup> &Fixups,\n          const MCSubtargetInfo &STI) const override;\n      uint64_t getBinaryCodeForInstr(\n          const MCInst &MI,\n          SmallVectorImpl<MCFixup> &Fixups,\n          const MCSubtargetInfo &STI) const;\n      unsigned\n      getMachineOpValue(const MCInst &MI,\n                        const MCOperand &MO,\n                        SmallVectorImpl<MCFixup> &Fixups,\n                        const MCSubtargetInfo &STI) const;\n    };\n    } // end anonymous namespace\n    ```", "```cpp\n\n    void M88kMCCodeEmitter::encodeInstruction(\n        const MCInst &MI, raw_ostream &OS,\n        SmallVectorImpl<MCFixup> &Fixups,\n        const MCSubtargetInfo &STI) const {\n      uint64_t Bits =\n          getBinaryCodeForInstr(MI, Fixups, STI);\n      ++MCNumEmitted;\n      support::endian::write<uint32_t>(OS, Bits,\n                                       support::big);\n    }\n    ```", "```cpp\n\n    unsigned M88kMCCodeEmitter::getMachineOpValue(\n        const MCInst &MI, const MCOperand &MO,\n        SmallVectorImpl<MCFixup> &Fixups,\n        const MCSubtargetInfo &STI) const {\n      if (MO.isReg())\n        return Ctx.getRegisterInfo()->getEncodingValue(\n            MO.getReg());\n      if (MO.isImm())\n        return static_cast<uint64_t>(MO.getImm());\n      return 0;\n    }\n    ```", "```cpp\n\n    #include \"M88kGenMCCodeEmitter.inc\"\n    MCCodeEmitter *\n    llvm::createM88kMCCodeEmitter(const MCInstrInfo &MCII,\n                                  MCContext &Ctx) {\n      return new M88kMCCodeEmitter(MCII, Ctx);\n    }\n    ```", "```cpp\n\n    namespace llvm {\n    class MCAsmInfo;\n    class MCOperand;\n    ```", "```cpp\n\n    class M88kInstPrinter : public MCInstPrinter {\n    public:\n      M88kInstPrinter(const MCAsmInfo &MAI,\n                      const MCInstrInfo &MII,\n                      const MCRegisterInfo &MRI)\n          : MCInstPrinter(MAI, MII, MRI) {}\n      std::pair<const char *, uint64_t>\n      getMnemonic(const MCInst *MI) override;\n      void printInstruction(const MCInst *MI,\n                            uint64_t Address,\n                            const MCSubtargetInfo &STI,\n                            raw_ostream &O);\n      static const char *getRegisterName(MCRegister RegNo);\n      void printOperand(const MCInst *MI, int OpNum,\n                        const MCSubtargetInfo &STI,\n                        raw_ostream &O);\n      void printInst(const MCInst *MI, uint64_t Address,\n                     StringRef Annot,\n                     const MCSubtargetInfo &STI,\n                     raw_ostream &O) override;\n    };\n    } // end namespace llvm\n    ```", "```cpp\n\n    using namespace llvm;\n    #define DEBUG_TYPE \"asm-printer\"\n    #include \"M88kGenAsmWriter.inc\"\n    ```", "```cpp\n\n    void M88kInstPrinter::printOperand(\n        const MCInst *MI, int OpNum,\n        const MCSubtargetInfo &STI, raw_ostream &O) {\n      const MCOperand &MO = MI->getOperand(OpNum);\n      if (MO.isReg()) {\n        if (!MO.getReg())\n          O << '0';\n        else\n          O << '%' << getRegisterName(MO.getReg());\n      } else if (MO.isImm())\n        O << MO.getImm();\n      else\n        llvm_unreachable(\"Invalid operand\");\n    }\n    ```", "```cpp\n\n    void M88kInstPrinter::printInst(\n        const MCInst *MI, uint64_t Address, StringRef Annot,\n        const MCSubtargetInfo &STI, raw_ostream &O) {\n      printInstruction(MI, Address, STI, O);\n      printAnnotation(O, Annot);\n    }\n    ```", "```cpp\n\n    static MCInstPrinter *createM88kMCInstPrinter(\n        const Triple &T, unsigned SyntaxVariant,\n        const MCAsmInfo &MAI, const MCInstrInfo &MII,\n        const MCRegisterInfo &MRI) {\n      return new M88kInstPrinter(MAI, MII, MRI);\n    }\n    static MCAsmInfo *\n    createM88kMCAsmInfo(const MCRegisterInfo &MRI,\n                        const Triple &TT,\n                        const MCTargetOptions &Options) {\n      return new M88kMCAsmInfo(TT);\n    }\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kTargetMC() {\n      // …\n      TargetRegistry::RegisterMCAsmInfo(\n          getTheM88kTarget(), createM88kMCAsmInfo);\n      TargetRegistry::RegisterMCCodeEmitter(\n          getTheM88kTarget(), createM88kMCCodeEmitter);\n      TargetRegistry::RegisterMCInstPrinter(\n          getTheM88kTarget(), createM88kMCInstPrinter);\n    }\n    ```", "```cpp\n\n    class M88kOperand : public MCParsedAsmOperand {\n      enum OperandKind { OpKind_Token, OpKind_Reg,\n                         OpKind_Imm };\n      OperandKind Kind;\n      SMLoc StartLoc, EndLoc;\n    ```", "```cpp\n\n       union {\n        StringRef Token;\n        unsigned RegNo;\n        const MCExpr *Imm;\n      };\n    ```", "```cpp\n\n    public:\n      M88kOperand(OperandKind Kind, SMLoc StartLoc,\n                  SMLoc EndLoc)\n          : Kind(Kind), StartLoc(StartLoc), EndLoc(EndLoc) {}\n      SMLoc getStartLoc() const override { return StartLoc; }\n      SMLoc getEndLoc() const override { return EndLoc; }\n    ```", "```cpp\n\n      bool isReg() const override {\n        return Kind == OpKind_Reg;\n      }\n      unsigned getReg() const override { return RegNo; }\n      static std::unique_ptr<M88kOperand>\n      createReg(unsigned Num, SMLoc StartLoc,\n                SMLoc EndLoc) {\n        auto Op = std::make_unique<M88kOperand>(\n            OpKind_Reg, StartLoc, EndLoc);\n        Op->RegNo = Num;\n        return Op;\n      }\n      void addRegOperands(MCInst &Inst, unsigned N) const {\n        assert(N == 1 && \"Invalid number of operands\");\n        Inst.addOperand(MCOperand::createReg(getReg()));\n      }\n    ```", "```cpp\n\n      void print(raw_ostream &OS) const override {\n        switch (Kind) {\n        case OpKind_Imm:\n          OS << \"Imm: \" << getImm() << \"\\n\"; break;\n        case OpKind_Token:\n          OS << \"Token: \" << getToken() << \"\\n\"; break;\n        case OpKind_Reg:\n          OS << \"Reg: \"\n             << M88kInstPrinter::getRegisterName(getReg())\n             << „\\n\"; break;\n        }\n      }\n    };\n    ```", "```cpp\n\n    class M88kAsmParser : public MCTargetAsmParser {\n    #define GET_ASSEMBLER_HEADER\n    #include \"M88kGenAsmMatcher.inc\"\n    ```", "```cpp\n\n      MCAsmParser &Parser;\n      const MCSubtargetInfo &SubtargetInfo;\n    ```", "```cpp\n\n      bool\n      ParseInstruction(ParseInstructionInfo &Info,\n                       StringRef Name, SMLoc NameLoc,\n                       OperandVector &Operands) override;\n      bool parseRegister(MCRegister &RegNo, SMLoc &StartLoc,\n                         SMLoc &EndLoc) override;\n      OperandMatchResultTy\n      tryParseRegister(MCRegister &RegNo, SMLoc &StartLoc,\n                       SMLoc &EndLoc) override;\n      bool parseRegister(MCRegister &RegNo, SMLoc &StartLoc,\n                         SMLoc &EndLoc,\n                         bool RestoreOnFailure);\n      bool parseOperand(OperandVector &Operands,\n                        StringRef Mnemonic);\n      bool MatchAndEmitInstruction(\n          SMLoc IdLoc, unsigned &Opcode,\n          OperandVector &Operands, MCStreamer &Out,\n          uint64_t &ErrorInfo,\n          bool MatchingInlineAsm) override;\n    ```", "```cpp\n\n    public:\n      M88kAsmParser(const MCSubtargetInfo &STI,\n                    MCAsmParser &Parser,\n                    const MCInstrInfo &MII,\n                    const MCTargetOptions &Options)\n          : MCTargetAsmParser(Options, STI, MII),\n            Parser(Parser), SubtargetInfo(STI) {\n        setAvailableFeatures(ComputeAvailableFeatures(\n            SubtargetInfo.getFeatureBits()));\n      }\n    };\n    ```", "```cpp\n\n    #define GET_REGISTER_MATCHER\n    #define GET_MATCHER_IMPLEMENTATION\n    #include \"M88kGenAsmMatcher.inc\"\n    ```", "```cpp\n\n    bool M88kAsmParser::ParseInstruction(\n        ParseInstructionInfo &Info, StringRef Name,\n        SMLoc NameLoc, OperandVector &Operands) {\n      Operands.push_back(\n          M88kOperand::createToken(Name, NameLoc));\n      if (getLexer().isNot(AsmToken::EndOfStatement)) {\n        if (parseOperand(Operands, Name)) {\n          return Error(getLexer().getLoc(),\n                       \"expected operand\");\n        }\n        while (getLexer().is(AsmToken::Comma)) {\n          Parser.Lex();\n          if (parseOperand(Operands, Name)) {\n            return Error(getLexer().getLoc(),\n                         \"expected operand\");\n          }\n        }\n        if (getLexer().isNot(AsmToken::EndOfStatement))\n          return Error(getLexer().getLoc(),\n                       \"unexpected token in argument list\");\n      }\n      Parser.Lex();\n      return false;\n    }\n    ```", "```cpp\n\n    bool M88kAsmParser::parseOperand(\n        OperandVector &Operands, StringRef Mnemonic) {\n      if (Parser.getTok().is(AsmToken::Percent)) {\n        MCRegister RegNo;\n        SMLoc StartLoc, EndLoc;\n        if (parseRegister(RegNo, StartLoc, EndLoc,\n                          /*RestoreOnFailure=*/false))\n          return true;\n        Operands.push_back(M88kOperand::createReg(\n            RegNo, StartLoc, EndLoc));\n        return false;\n      }\n      if (Parser.getTok().is(AsmToken::Integer)) {\n        SMLoc StartLoc = Parser.getTok().getLoc();\n        const MCExpr *Expr;\n        if (Parser.parseExpression(Expr))\n          return true;\n        SMLoc EndLoc = Parser.getTok().getLoc();\n        Operands.push_back(\n            M88kOperand::createImm(Expr, StartLoc, EndLoc));\n        return false;\n      }\n      return true;\n    }\n    ```", "```cpp\n\n    bool M88kAsmParser::parseRegister(\n        MCRegister &RegNo, SMLoc &StartLoc, SMLoc &EndLoc,\n        bool RestoreOnFailure) {\n      StartLoc = Parser.getTok().getLoc();\n      if (Parser.getTok().isNot(AsmToken::Percent))\n        return true;\n      const AsmToken &PercentTok = Parser.getTok();\n      Parser.Lex();\n      if (Parser.getTok().isNot(AsmToken::Identifier) ||\n          (RegNo = MatchRegisterName(\n               Parser.getTok().getIdentifier())) == 0) {\n        if (RestoreOnFailure)\n          Parser.getLexer().UnLex(PercentTok);\n        return Error(StartLoc, \"invalid register\");\n      }\n      Parser.Lex();\n      EndLoc = Parser.getTok().getLoc();\n      return false;\n    }\n    ```", "```cpp\n\n    bool M88kAsmParser::parseRegister(MCRegister &RegNo,\n                                      SMLoc &StartLoc,\n                                      SMLoc &EndLoc) {\n      return parseRegister(RegNo, StartLoc, EndLoc,\n                           /*RestoreOnFailure=*/false);\n    }\n    OperandMatchResultTy M88kAsmParser::tryParseRegister(\n        MCRegister &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) {\n      bool Result =\n          parseRegister(RegNo, StartLoc, EndLoc,\n                        /*RestoreOnFailure=*/true);\n      bool PendingErrors = getParser().hasPendingError();\n      getParser().clearPendingErrors();\n      if (PendingErrors)\n        return MatchOperand_ParseFail;\n      if (Result)\n        return MatchOperand_NoMatch;\n      return MatchOperand_Success;\n    }\n    ```", "```cpp\n\n    bool M88kAsmParser::MatchAndEmitInstruction(\n        SMLoc IdLoc, unsigned &Opcode,\n        OperandVector &Operands, MCStreamer &Out,\n        uint64_t &ErrorInfo, bool MatchingInlineAsm) {\n      MCInst Inst;\n      SMLoc ErrorLoc;\n      switch (MatchInstructionImpl(\n          Operands, Inst, ErrorInfo, MatchingInlineAsm)) {\n      case Match_Success:\n        Out.emitInstruction(Inst, SubtargetInfo);\n        Opcode = Inst.getOpcode();\n        return false;\n      case Match_MissingFeature:\n        return Error(IdLoc, \"Instruction use requires \"\n                            \"option to be enabled\");\n      case Match_MnemonicFail:\n        return Error(IdLoc,\n                     \"Unrecognized instruction mnemonic\");\n      case Match_InvalidOperand: {\n        ErrorLoc = IdLoc;\n        if (ErrorInfo != ~0U) {\n          if (ErrorInfo >= Operands.size())\n            return Error(\n                IdLoc, \"Too few operands for instruction\");\n          ErrorLoc = ((M88kOperand &)*Operands[ErrorInfo])\n                         .getStartLoc();\n          if (ErrorLoc == SMLoc())\n            ErrorLoc = IdLoc;\n        }\n        return Error(ErrorLoc,\n                     \"Invalid operand for instruction\");\n      }\n      default:\n        break;\n      }\n      llvm_unreachable(\"Unknown match type detected!\");\n    }\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kAsmParser() {\n      RegisterMCAsmParser<M88kAsmParser> X(\n          getTheM88kTarget());\n    }\n    ```", "```cpp\n\n$ echo 'and %r1,%r2,%r3' | \\\n  bin/llvm-mc --triple m88k-openbsd --show-encoding\n        .text\n        and %r1, %r2, %r3  | encoding: [0xf4,0x22,0x40,0x03]\n```", "```cpp\n\n    using namespace llvm;\n    #define DEBUG_TYPE \"m88k-disassembler\"\n    using DecodeStatus = MCDisassembler::DecodeStatus;\n    ```", "```cpp\n\n    namespace {\n    class M88kDisassembler : public MCDisassembler {\n    public:\n      M88kDisassembler(const MCSubtargetInfo &STI,\n                       MCContext &Ctx)\n          : MCDisassembler(STI, Ctx) {}\n      ~M88kDisassembler() override = default;\n      DecodeStatus\n      getInstruction(MCInst &instr, uint64_t &Size,\n                     ArrayRef<uint8_t> Bytes,\n                     uint64_t Address,\n                     raw_ostream &CStream) const override;\n    };\n    } // end anonymous namespace\n    ```", "```cpp\n\n    static MCDisassembler *\n    createM88kDisassembler(const Target &T,\n                           const MCSubtargetInfo &STI,\n                           MCContext &Ctx) {\n        return new M88kDisassembler(STI, Ctx);\n    }\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void\n    LLVMInitializeM88kDisassembler() {\n      TargetRegistry::RegisterMCDisassembler(\n          getTheM88kTarget(), createM88kDisassembler);\n    }\n    ```", "```cpp\n\n    static const uint16_t GPRDecoderTable[] = {\n        M88k::R0,  M88k::R1,  M88k::R2,  M88k::R3,\n        // …\n    };\n    static DecodeStatus\n    decodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,\n                           uint64_t Address,\n                           const void *Decoder) {\n      if (RegNo > 31)\n        return MCDisassembler::Fail;\n      unsigned Register = GPRDecoderTable[RegNo];\n      Inst.addOperand(MCOperand::createReg(Register));\n      return MCDisassembler::Success;\n    }\n    ```", "```cpp\n\n    #include \"M88kGenDisassemblerTables.inc\"\n    ```", "```cpp\n\n    DecodeStatus M88kDisassembler::getInstruction(\n        MCInst &MI, uint64_t &Size, ArrayRef<uint8_t> Bytes,\n        uint64_t Address, raw_ostream &CS) const {\n      if (Bytes.size() < 4) {\n        Size = 0;\n        return MCDisassembler::Fail;\n      }\n      Size = 4;\n      uint32_t Inst = 0;\n      for (uint32_t I = 0; I < Size; ++I)\n        Inst = (Inst << 8) | Bytes[I];\n      if (decodeInstruction(DecoderTableM88k32, MI, Inst,\n                            Address, this, STI) !=\n          MCDisassembler::Success) {\n          return MCDisassembler::Fail;\n      }\n      return MCDisassembler::Success;\n    }\n    ```", "```cpp\n\n$ echo \"0xf4,0x22,0x40,0x03\" | \\\n  bin/llvm-mc --triple m88k-openbsd –disassemble\n        .text\n        and %r1, %r2, %r3\n```"]