- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serial Peripheral Interface (SPI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **Serial Peripheral Interface** (**SPI**)
    protocol, another important communication protocol widely used in embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by delving into the basics of the SPI protocol, understanding
    its master-slave architecture, data transfer modes, and typical use cases. Next,
    we will examine the key registers of the SPI peripheral in STM32 microcontrollers,
    providing detailed insights into their configuration and usage. Finally, we will
    apply this knowledge to develop a bare-metal SPI driver, demonstrating practical
    implementation and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the SPI protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32F4 SPI peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the SPI driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the SPI protocol
    and be equipped to develop bare-metal drivers for SPI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All code examples for this chapter can be found on GitHub at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the SPI protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive into what SPI is, its key features, how it works, and some of the
    nuances that make it so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: What is SPI?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPI is a *synchronous* serial communication protocol developed by Motorola.
    Unlike **Universal Asynchronous Receiver-Transmitter** (**UART**), which is asynchronous,
    SPI *relies on a clock signal* to synchronize data transfer between devices. It’s
    designed for short-distance communication (usually no more than 30 cm), primarily
    between a microcontroller and peripheral devices such as sensors, SD cards, and
    display modules. Let’s see its key features.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SPI stands out due to its efficiency. Here are some of its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-duplex communication**: SPI supports simultaneous data transmission
    and reception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High speed**: SPI can operate at much higher speeds compared to protocols
    such as **Inter-Integrated Circuit** (**I2C**) and UART'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master-slave architecture**: One master device controls communication, while
    one or more slave devices respond'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible data length**: Can handle various data lengths, commonly 8 bits,
    but not limited to that'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to connect two SPI devices, we must understand the SPI interface.
  prefs: []
  type: TYPE_NORMAL
- en: The SPI interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SPI uses four primary lines for communication, each with several alternative
    names you might encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master In Slave Out (MISO)**: Also known as **Serial Data Out** (**SDO**)
    or **Data Out** (**DOUT**), this line carries data from the slave device to the
    master'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Out Slave In (MOSI)**: Also known as **Serial Data In** (**SDI**)
    or **Data In** (**DIN**), this line carries data from the master device to the
    slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Clock (SCK)**: Also referred to as **SCLK** (or simply **CLK**), this
    is the clock signal generated by the master to synchronize data transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave Select (SS)**: Also known as **Chip Select** (**CS**) or **Not Slave
    Select**(**NSS**), this line is used by the master to select which slave device
    to communicate with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When multiple slaves are used, each slave typically has its own SS line, allowing
    the master to control communication with each slave individually. *Figure 12**.1*
    illustrates the SPI connection between a single master and a single slave:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: The SPI interface](img/B21914_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: The SPI interface'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.2* depicts the SPI setup with a single master controlling multiple
    slaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The SPI interface – multiple slaves](img/B21914_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The SPI interface – multiple slaves'
  prefs: []
  type: TYPE_NORMAL
- en: When multiple slaves are connected to a single SPI bus, managing the MISO line
    is crucial to avoid communication errors. Since all slaves share this line, non-selected
    slaves could interfere with the signal from the selected slave if not properly
    controlled. To prevent such issues, several techniques are used. One common method
    is **tri-state buffering**, where each slave’s MISO line enters a high-impedance
    (high-Z) state when its CS line is inactive, effectively disconnecting it from
    the bus. This ensures only the selected slave drives the MISO line, preventing
    bus contention. Another approach is the **open-drain configuration** with a pull-up
    resistor, where the MISO line is left floating (high-Z) when transmitting a 1
    and pulled low by the selected slave when transmitting a 0\. This reduces contention
    risks but may result in slower communication speeds due to the time delay introduced
    by the pull-up resistor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the SPI protocol works.
  prefs: []
  type: TYPE_NORMAL
- en: How SPI works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SPI works on a simple principle: the master generates a clock signal and selects
    a slave to communicate with by *pulling the corresponding SS line low*. Data is
    then exchanged simultaneously between the master and the slave over the MOSI and
    MISO lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: The master sets the clock frequency and data format (for
    example, 8-bit data).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Slave selection**: The master pulls the SS line of the target slave low.
    In a multi-slave configuration, where each slave has its own CS line, the master
    first sets all CS lines high (inactive) before sending any initialization messages.
    This ensures that uninitialized slaves don’t mistakenly respond to commands not
    intended for them. Once all CS lines are confirmed high, the master then activates
    the CS line of the desired slave by pulling it low to begin controlled communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data transmission**: The master sends data to the slave on the MOSI line,
    while the slave sends data to the master on the MISO line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clock synchronization**: The master controls the clock, ensuring data is
    sampled and shifted at the correct times.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Completion**: Once the data transfer is complete, the master pulls the SS
    line high, deselecting the slave.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To successfully implement an SPI driver, it’s essential to understand key SPI
    configuration parameters. Let’s explore them one by one, starting with **Clock
    Phase** (**CPHA**) and **Clock** **Polarity** (**CPOL**).
  prefs: []
  type: TYPE_NORMAL
- en: CPHA and CPOL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In SPI communication, the settings for CPHA and CPOL determine the timing and
    characteristics of the clock signal used to synchronize data transfer between
    the master and slave devices. These settings are crucial for ensuring that data
    is correctly sampled and interpreted by both the master and the slave. Here’s
    a detailed look at how CPHA and CPOL affect SPI communication.
  prefs: []
  type: TYPE_NORMAL
- en: CPOL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CPOL determines the idle state of the clock signal (SCK). It controls whether
    the clock signal is high or low when no data is being transferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPOL = 0**: The clock signal is low (0) when idle. This means that the clock
    line remains low between data transmissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPOL = 1**: The clock signal is high (1) when idle. This means that the clock
    line remains high between data transmissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPHA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CPHA determines when data is sampled and when it is shifted out. It controls
    the edge of the clock signal on which data is read and written:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPHA = 0**: Data is sampled on the leading edge (first edge) of the clock
    pulse and shifted out on the trailing edge (second edge)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPHA = 1**: Data is shifted out on the leading edge (first edge) of the clock
    pulse and sampled on the trailing edge (second edge)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of CPOL and CPHA results in four different SPI modes, each affecting
    the timing of data sampling and shifting.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the appropriate SPI mode is crucial for ensuring proper communication
    between the master and slave devices. Both devices must be configured to use the
    same CPOL and CPHA settings to correctly interpret the data being exchanged. The
    choice of mode depends on the specific requirements of the devices and the timing
    constraints of the application. Let’s move on to SPI data modes.
  prefs: []
  type: TYPE_NORMAL
- en: Data modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPI is flexible with the data length it can handle. While **8-bit** data transfers
    are common, SPI can be configured to handle different data lengths, such as **16-bit**
    or **32-bit** transfers, depending on the application. The master and slave devices
    need to agree on the data length to ensure accurate communication. The last configuration
    parameter is the SPI speed.
  prefs: []
  type: TYPE_NORMAL
- en: SPI speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of SPI’s significant advantages is its speed. SPI can operate at very high
    frequencies, typically up to several tens of **MHz**, depending on the hardware
    capabilities of the master and slave devices. The actual speed used in an application
    depends on several factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device capabilities**: The maximum speed supported by both the master and
    the slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal integrity**: Higher speeds can lead to signal integrity issues such
    as crosstalk and reflections, especially over longer distances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power consumption**: Higher speeds consume more power, which might be a consideration
    in battery-powered applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our overview of the SPI protocol. In the next section, we will
    analyze the SPI peripheral in the STM32F4 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 SPI peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with other peripherals, STM32 microcontrollers often include several SPI
    peripherals; the number varies depending on the specific model. The STM32F411
    microcontroller has five SPI peripherals, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SPI1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-duplex and half-duplex communication**: Supports simultaneous two-way
    communication (full-duplex) or one-way communication (half-duplex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master/slave configuration**: Each SPI peripheral can be configured as either
    a master or a slave device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible data size**: Supports data sizes ranging from 4 to 16 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-speed communication**: Capable of operating at speeds up to 42 MHz in
    master mode and up to 21 MHz in slave mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct Memory Access (DMA) support**: DMA support for efficient data transfer
    without CPU intervention'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negative SS (NSS) pin management**: Hardware management of the NSS pin for
    multi-slave configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclic Redundancy Check (CRC) calculation**: Built-in hardware CRC calculation
    for data integrity verification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bidirectional mode**: Supports bidirectional data mode, allowing a single
    data line to be used for both sending and receiving data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine the key registers of this peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Key SPI registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get SPI up and running on the STM32F411 microcontroller, we need to configure
    several registers that control various aspects of the SPI peripheral. Let’s break
    down the main registers we’ll be working with, starting with the **Control Register**
    **1** register.
  prefs: []
  type: TYPE_NORMAL
- en: SPI Control Register 1 (SPI_CR1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SPI_CR1` register is central to configuring the SPI peripheral. It includes
    settings that define the **SPI mode**, **data format**, **clock settings**, and
    more. Key bits in this register include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPHA` to `0` means data is sampled on the first edge (leading edge), while
    setting it to `1` means data is sampled on the second edge (trailing edge).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPOL` to `0` means the clock is low when idle, and setting it to `1` means
    the clock is high when idle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSTR` to `1` makes the SPI peripheral a master, while `0` sets it as a slave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baud Rate Control (BR[2:0])**: These bits configure the baud rate for SPI
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPE` to `1` to activate SPI communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LSBFIRST` to `0` transmits the `1` transmits the **least significant bit**
    (**LSB**) first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SS Internal (SSI)**: This bit is used in master mode to internally control
    the SS line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` enables software management of the SS line, allowing the master to control
    it manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the SPI Status Register.
  prefs: []
  type: TYPE_NORMAL
- en: SPI Status Register (SPI_SR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SPI_SR` register provides real-time status updates on the SPI peripheral,
    informing us about various operational states and flags. Key bits in this register
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Buffer Not Empty (RXNE)**: This flag indicates that the receive buffer
    contains unread data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmit Buffer Empty (TXE)**: This flag signals that the transmit buffer
    is empty and ready for new data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRC Error Flag (CRCERR)**: This flag is set when a CRC error is detected,
    indicating possible data corruption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mode Fault (MODF)**: This flag signals a mode fault, often due to incorrect
    master/slave configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overrun Flag (OVR)**: This flag indicates an overrun condition, where the
    receive buffer wasn’t read in time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Busy Flag (BSY)**: This flag indicates that the SPI peripheral is currently
    engaged in a transmission or reception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last key register is the Data Register.
  prefs: []
  type: TYPE_NORMAL
- en: SPI Data Register (SPI_DR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SPI_DR` register is the conduit for data transmission and reception. It’s
    where we write data to be sent out and read data that’s been received:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SPI_DR` register, data is sent out over the `MOSI` line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPI_DR`, you get the data that was received on the `MISO` line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these registers in mind, we’re now ready to develop the SPI driver. Let’s
    jump into that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the SPI driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a copy of your previous project in your IDE and rename this copied project
    to `SPI`. Next, create a new file named `spi.c` in the `Src` folder and another
    file named `spi.h` in the `Inc` folder. Populate your `spi.c` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the function for configuring the SPI parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the function for receiving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the functions for controlling the CS pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, the function for deselecting the slave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through each part of the SPI initialization and communication code.
    We’ll start by looking at the defined macros and then dive into each function.
  prefs: []
  type: TYPE_NORMAL
- en: Defined macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s break down the meaning of the macros and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Over here, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SPI1EN`: This is defined as `(1U<<12)`, which sets bit 12\. It’s used to enable
    the clock for the SPI1 peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOAEN`: This is defined as `(1U<<0)`, which sets bit 0\. This enables the
    clock for `GPIOA`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_TXE`: This is defined as `(1U<<1)`. This indicates that the transmit buffer
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_RXNE`: This is defined as `(1U<<0)`. This indicates that the receive buffer
    is not empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_BSY`: This is defined as `(1U<<7)`. This indicates that the SPI interface
    is busy with a transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s break down the initialization function.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO initialization for SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s analyze the configuration of the SPI1 GPIO pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for `GPIOA` by setting the appropriate bit in the
    `AHB1` peripheral clock enable register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines configure `PA5`, `PA6`, and `PA7` pins to alternate function modes,
    necessary for SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This configures `PA9` as a general-purpose output pin, which will be used for
    SS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These lines set the alternate function registers to configure `PA5`, `PA6`,
    and `PA7` for `SPI1`.
  prefs: []
  type: TYPE_NORMAL
- en: SPI1 configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we have the code for configuring the SPI parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for `SPI1` by setting the appropriate bit in the
    `APB2` peripheral clock enable register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines configure the SPI clock prescaler to set the baud rate by dividing
    the `APB2` peripheral clock by 4, as SPI1 is connected to the `APB2` bus. The
    baud rate is determined by the `001` results in the peripheral clock being divided
    by 4, which dictates the speed at which data is transferred over the SPI bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines set the clock polarity and phase to ensure correct data sampling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This line ensures that full-duplex mode is enabled for simultaneous transmit
    and receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This line configures SPI to transmit the MSB first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sets `SPI1` to master mode, making it the controller of the SPI bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This line configures the SPI data frame size to `8` bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These lines enable `SS` line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the SPI peripheral for operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the `spi1_transmit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting data with SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This snippet deals with transmitting the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop waits until the transmit buffer is empty before sending the next
    byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sends the current byte of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures the SPI bus is not busy before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These two lines play a crucial role in managing the SPI communication process.
    After the master transmits data through the SPI Data Register, the same register
    captures the data received from the slave. To ensure incoming data is properly
    processed, we read the Data Register, even if we don’t need the value. This read
    operation automatically clears the OVR flag. It’s also advisable to read the Status
    Register as part of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `spi1_receive()` function.
  prefs: []
  type: TYPE_NORMAL
- en: SPI data reception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This deals with receiving the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sends dummy data to generate clock pulses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This line waits until data is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This line reads the received data:'
  prefs: []
  type: TYPE_NORMAL
- en: The last functions are the `cs_enable()` and `cs_disable()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: CS management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This line pulls the SS line low to enable the slave device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This line pulls the SS line high to disable the slave device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our next task is to populate the `spi.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: The header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Over here, we are simply exposing the functions to make them accessible in other
    files.
  prefs: []
  type: TYPE_NORMAL
- en: To effectively test the SPI driver, we need a suitable slave device. In the
    next section, we’ll dive into the **ADXL345 accelerometer**, which we’ll use as
    our slave device to test the SPI driver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the ADXL345 accelerometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ADXL345` is a gem in the world of digital accelerometers, and it’s perfect
    for testing our SPI module. Let’s dive into what makes this device so special
    and how it fits into our embedded system projects.'
  prefs: []
  type: TYPE_NORMAL
- en: What is ADXL345?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ADXL345 is a small, thin, ultralow power, `13`-bit) measurements with a selectable
    measurement range of **±2 g**, **±4 g**, **±8 g**, or **±****16 g**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The ADXL345](img/B21914_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The ADXL345'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze its key features.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of the ADXL345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following is a list of the ADXL345’s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ultralow power**: The device consumes as little as 23 µA in measurement mode
    and just 0.1 µA in standby mode, making it ideal for battery-powered applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-selectable resolution**: We can choose a resolution from 10 to 13 bits,
    providing a scale factor of 4 mg/LSB across all g ranges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible interface**: The ADXL345 supports both SPI (3- and 4-wire) and I2C
    digital interfaces, giving us flexibility in how you integrate it into your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Special sensing functions**: It includes single tap, double tap, and free-fall
    detection, along with activity/inactivity monitoring. These functions can be individually
    mapped to two interrupt output pins, making it highly responsive to physical events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide supply voltage range**: It operates from 2.0 V to 3.6 V, accommodating
    various power configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robust performance**: The ADXL345 can withstand a shock of up to 10,000 g,
    ensuring durability in rugged applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see some of its common applications.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given its robust feature set, the ADXL345 is well suited for a range of applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Industrial equipment**: For machinery monitoring and fault detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aerospace equipment**: In systems where reliability and precision are paramount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer electronics**: Examples are smartphones, gaming devices, and wearable
    technology'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health and sports**: For tracking motion and activity in health monitoring
    devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at its sensing function.
  prefs: []
  type: TYPE_NORMAL
- en: Sensing function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At its core, the ADXL345 measures acceleration along three axes: *x*, *y*,
    and *z*. The data is available in a 16-bit two''s complement format and can be
    accessed via either the SPI or I2C interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are its sensing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity and inactivity monitoring**: The accelerometer can detect movement
    or the absence thereof, making it great for sleep monitoring and fitness applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tap detection**: It can recognize single and double taps in any direction,
    which is useful for gesture-based controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free-fall detection**: The device can detect if it’s in free fall, which
    can be used in safety systems to trigger an alert or a response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 12**.4* shows the *x*, *y*, and *z* axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: The x, y, and z axes](img/B21914_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: The x, y, and z axes'
  prefs: []
  type: TYPE_NORMAL
- en: The ADXL345 also offers various low-power modes to help manage power consumption
    intelligently. These modes allow the device to enter sleep or standby states based
    on our defined thresholds and activity levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also includes a 32-level **FIFO buffer**, which helps in storing data temporarily
    to reduce the load on the host processor. This buffer is especially useful in
    applications requiring high data throughput or when the processor is busy with
    other tasks. Lastly, its pinout is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VDD I/O**: Digital interface supply voltage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Ground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CS**: CS for SPI communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INT1 and INT2**: Interrupt output pins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SDA/SDI/SDIO**: Serial data line for I2C or SPI input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCL/SCLK**: Serial clock line for I2C or SPI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive into developing the driver for this slave device, let’s first
    explore some key concepts of acceleration measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding key concepts – static acceleration of gravity, tilt-sensing, and
    dynamic acceleration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with accelerometers such as the ADXL345, it’s important to grasp
    some fundamental concepts that underpin their operation and applications. Let’s
    break down what static acceleration of gravity, tilt-sensing, and dynamic acceleration
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: Static acceleration of gravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Static acceleration of gravity** refers to the constant acceleration due
    to gravity that acts on an object at rest. This acceleration is always present
    and has a magnitude of approximately **9.8 meters per second squared (m/s²)**
    on the surface of the Earth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of an accelerometer such as the ADXL345, static acceleration
    is used to determine the orientation of the device. When the accelerometer is
    at rest and positioned flat, it measures the static acceleration of gravity along
    the *z* axis, which helps to identify which direction is “down.” This capability
    is crucial for applications such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orientation detection**: Determining the device’s orientation relative to
    the Earth’s surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tilt-sensing**: Measuring the tilt angle of the device by observing how gravity’s
    force changes across different axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next important concept is tilt-sensing.
  prefs: []
  type: TYPE_NORMAL
- en: Tilt-sensing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tilt-sensing** is the process of measuring the angle at which an object is
    tilted with respect to the force of gravity. This is achieved by analyzing the
    static acceleration readings from the accelerometer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine holding a tablet. When you tilt it forward, backward, or sideways,
    the accelerometer inside detects changes in the static acceleration along its
    *x*, *y*, and *z* axes. By comparing these changes, the device can calculate the
    tilt angle. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X-axis tilt**: If the device is tilted along the *x* axis, the static acceleration
    detected on the *x* axis will increase or decrease depending on the direction
    of the tilt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y-axis tilt**: Similarly, tilting along the *y* axis will cause variations
    in the static acceleration readings on the *y* axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z-axis stability**: The *z* axis usually detects the full force of gravity
    when the device is lying flat. Changes in tilt cause redistributions of this force
    among the *x* and *y* axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tilt-sensing is widely used in applications such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen orientation**: Automatically adjusting the display from portrait to
    landscape mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gaming controllers**: Detecting movements and tilts to enhance gameplay'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industrial equipment**: Monitoring the tilt of machinery or vehicles for
    stability and safety'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final key concept is dynamic acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic acceleration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dynamic acceleration** refers to the acceleration that results from motion
    or external forces acting on the device. Unlike static acceleration, which is
    constant, dynamic acceleration varies based on how the device is moving.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you shake or move the accelerometer, it measures these changes
    as dynamic acceleration. This type of acceleration is crucial for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Motion detection**: Identifying when the device is moved, which can be used
    in fitness trackers to count steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shock or impact sensing**: Detecting sudden impacts or vibrations, useful
    in crash detection systems or drop tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vibration monitoring**: Measuring vibrations in industrial machinery to predict
    failures or maintenance needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before wrapping up this section, let’s clarify one more concept we introduced
    earlier: “g.”'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with accelerometers such as the ADXL345, you often come across
    terms such as ±2 g, ±4 g, ±8 g, or ±16 g. These terms are crucial for understanding
    the measurement capabilities and limits of the device. Let’s break down what g
    means and how these ranges affect the performance and application of an accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: What is g?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *g* refers to the acceleration due to gravity at the Earth’s surface,
    which is approximately 9.8 **meters per second squared** (**m/s²**). It is used
    as a unit of measurement for acceleration. When we say an accelerometer can measure
    ±2 g, it means it can detect accelerations up to twice the force of gravity in
    either direction along an axis.
  prefs: []
  type: TYPE_NORMAL
- en: With this clarified, we are now ready to develop the driver for the ADXL345
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the ADXL345 driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file named `adxl345.c` in the `Src` folder and another file named
    `adxl345.h` in the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The header file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Populate the `adxl345.h` file with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#include "adxl345.h"'
  prefs: []
  type: TYPE_NORMAL
- en: void adxl_read(uint8_t address, uint8_t * rxdata)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Set read operation*/
  prefs: []
  type: TYPE_NORMAL
- en: address |= ADXL345_READ_OPERATION;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable multi-byte*/
  prefs: []
  type: TYPE_NORMAL
- en: address |= ADXL345_MULTI_BYTE_ENABLE;
  prefs: []
  type: TYPE_NORMAL
- en: /*Pull cs line low to enable slave*/
  prefs: []
  type: TYPE_NORMAL
- en: cs_enable();
  prefs: []
  type: TYPE_NORMAL
- en: /*Send address*/
  prefs: []
  type: TYPE_NORMAL
- en: spi1_transmit(&address,1);
  prefs: []
  type: TYPE_NORMAL
- en: /*Read 6 bytes */
  prefs: []
  type: TYPE_NORMAL
- en: spi1_receive(rxdata,6);
  prefs: []
  type: TYPE_NORMAL
- en: /*Pull cs line high to disable slave*/
  prefs: []
  type: TYPE_NORMAL
- en: cs_disable();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void adxl_write (uint8_t address, uint8_t value)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t data[2];
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable multi-byte, place address into buffer*/
  prefs: []
  type: TYPE_NORMAL
- en: data[0] = address|ADXL345_MULTI_BYTE_ENABLE;
  prefs: []
  type: TYPE_NORMAL
- en: /*Place data into buffer*/
  prefs: []
  type: TYPE_NORMAL
- en: data[1] = value;
  prefs: []
  type: TYPE_NORMAL
- en: /*Pull cs line low to enable slave*/
  prefs: []
  type: TYPE_NORMAL
- en: cs_enable();
  prefs: []
  type: TYPE_NORMAL
- en: /*Transmit data and address*/
  prefs: []
  type: TYPE_NORMAL
- en: spi1_transmit(data, 2);
  prefs: []
  type: TYPE_NORMAL
- en: /*Pull cs line high to disable slave*/
  prefs: []
  type: TYPE_NORMAL
- en: cs_disable();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void adxl_init (void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable SPI gpio*/
  prefs: []
  type: TYPE_NORMAL
- en: spi_gpio_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Config SPI*/
  prefs: []
  type: TYPE_NORMAL
- en: spi1_config();
  prefs: []
  type: TYPE_NORMAL
- en: /*Set data format range to +-4g*/
  prefs: []
  type: TYPE_NORMAL
- en: adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);
  prefs: []
  type: TYPE_NORMAL
- en: /*Reset all bits*/
  prefs: []
  type: TYPE_NORMAL
- en: adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);
  prefs: []
  type: TYPE_NORMAL
- en: /*Configure power control measure bit*/
  prefs: []
  type: TYPE_NORMAL
- en: adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdint.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "stm32f4xx.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adxl345.h"'
  prefs: []
  type: TYPE_NORMAL
- en: //Variables for storing accelerometer data
  prefs: []
  type: TYPE_NORMAL
- en: int16_t accel_x, accel_y, accel_z;
  prefs: []
  type: TYPE_NORMAL
- en: double accel_x_g, accel_y_g, accel_z_g;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t data_buffer[6];
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: // Initialize the ADXL345 accelerometer
  prefs: []
  type: TYPE_NORMAL
- en: adxl_init();
  prefs: []
  type: TYPE_NORMAL
- en: while (1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // Read accelerometer data starting from the data start
  prefs: []
  type: TYPE_NORMAL
- en: // register
  prefs: []
  type: TYPE_NORMAL
- en: adxl_read(ADXL345_REG_DATA_START, data_buffer);
  prefs: []
  type: TYPE_NORMAL
- en: // Combine high and low bytes to form the accelerometer data
  prefs: []
  type: TYPE_NORMAL
- en: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
  prefs: []
  type: TYPE_NORMAL
- en: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
  prefs: []
  type: TYPE_NORMAL
- en: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
  prefs: []
  type: TYPE_NORMAL
- en: // Convert raw data to g values
  prefs: []
  type: TYPE_NORMAL
- en: accel_x_g = accel_x * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: accel_y_g = accel_y * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: accel_z_g = accel_z * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: //Print values for debugging purposes
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\'
  prefs: []
  type: TYPE_NORMAL
- en: r",accel_x,accel_y,accel_z);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
  prefs: []
  type: TYPE_NORMAL
- en: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
  prefs: []
  type: TYPE_NORMAL
- en: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: accel_x_g = accel_x * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: accel_y_g = accel_y * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: accel_z_g = accel_z * 0.0078;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\r",accel_x,accel_y,accel_z);'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
