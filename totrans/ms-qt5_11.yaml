- en: Chapter 11.  Having Fun with Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter was a firework of threads, sockets, and workers. We hope
    that your minions have been working hard. In this chapter, we will turn our attention
    to the serialization with Qt. You will learn how to serialize data in multiple
    formats with a flexible system. The example project will be a virtual drum machine,
    in which you can compose you own drum beat, record it, play it, save it, and load
    it back. Your drum beat will be probably so awesome that you will want to share
    it: you will now be able to do it in various formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to architecture an application that plays and records sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QVariant` class and its inner mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible serialization system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt Multimedia framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag and drop handling with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering a button from your keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting the drum machine project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, before diving into the code, let''s study the structure of the project.
    The aim of the project is to be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Play and record a sound track from a drum machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save this track to a file and load it to play it back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To play a sound, we will lay out four big buttons that will play a specific
    drum sound upon click (or a keyboard event): a kick, a snare, a hi-hat, and a
    cymbal crash. These sounds will be `.wav` files loaded by the application. The
    user will be able to record his sequence of sounds and replay it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the serialization part, we do not only want to save the track to a single
    file format, we would rather do three:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only is it more fun to cover three formats, but it also gives us the opportunity
    to understand the advantages and limitations of each one, and how it fits within
    the Qt framework. The architecture we are going to implement will try to be flexible
    to handle future evolutions. You never know how a project can evolve!
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes'' organization looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecting the drum machine project](img/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the role of these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SoundEvent` class is the basic building block of a track. It is a simple
    class containing `timestamp` (when the sound has been played) and `soundId` variables
    (what sound has been played).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Track` class contains a list of `SoundEvents`, a duration and a state (playing,
    recording, stopped). Each time the user plays a sound, a `SoundEvent` class is
    created and added to the `Track` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PlaybackWorker` class is a worker class that runs in a different thread.
    It is responsible of looping through the `Track` class's `soundEvents` and triggering
    the proper sound when its `timestamp` has been reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class is an interface that must be implemented by each class
    that wants to be serialized (in our case: `SoundEvent` and `Track`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializer` class is an interface that must be implemented by each format-specific
    implementation class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JsonSerializer`, `XmlSerializer`, and `BinarySerializer` are the sub-classes
    of `Serializer` class that do the format-specific job to serialize/deserialize
    a `Serializable` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SoundEffectWidget` class is the widget that holds the information to play
    a single sound. It displays the button for one of our four sounds. It also owns
    a `QSoundEffect` class that sends the sound to the audio card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MainWindow` class holds everything together. It owns the `Track` class,
    spawns the `PlaybackWorker` thread, and triggers the serialization/deserialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output format should be easily swapped. To achieve this, we will rely on
    a modified version of the bridge design pattern that will allow `Serializable`
    and `Serializer` classes to evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: The whole project revolves around this notion of independence between modules.
    It goes to the extent that a sound can be replaced on the spot during a playback.
    Let's say that you listen to your incredible beat, and you want to try another
    snare sound. You will be able to replace it with a simple drag and drop of a `.wav`
    file on the `SoundEffectWidget` class holding the snare sound.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a drum track
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's buckle up and do this project! Create a new **Qt Widgets Application**
    project named `ch11-drum-machine`. As usual, add the `CONFIG += c++14` in `ch11-drum-machine.pro`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new C++ class named `SoundEvent`. Here is `SoundEvent.h` stripped
    from its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class contains only two public members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`: A `qint64` (`long long` type) that contains the current time of
    the `SoundEvent` in milliseconds since the beginning of the track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundId`: The ID of the sound that has been played'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In recording mode, each time the user plays a sound, a `SoundEvent` is created
    with the appropriate data. The `SoundEvent.cpp` file is so boring that we will
    not inflict it on you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class to build is `Track`. Again, create the new C++ class. Let''s
    review `Track.h` with its members only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now go into detail about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mDuration`: This variable holds the duration of the `Track` class. This member
    is reset to 0 when a recording is started and updated when the recording is stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSoundEvents`: This variable is the list of `SoundEvents` for the given `Track`.
    As the `unique_ptr` semantic states it, `Track` is the owner of the sound events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mTimer`: This variable is started each time `Track` is played or recorded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mState`: This variable is the current `State` of `Track` class, which can
    have three possible values: `STOPPED`, `PLAYING`, `RECORDING`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mPreviousState`: This variable is the previous `State` of `Track`. This is
    useful when you want to know which action to do on a new `STOPPED``State`. We
    will have to stop the playback if `mPreviousState` is in the `PLAYING` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Track` class is the pivot of the business logic of the project. It holds `mState`,
    which is the state of the whole application. Its content will be read during a
    playback of your awesome musical performance and also be serialized to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enrich `Track.h` with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will skip the simple getters and concentrate on the important functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elapsedTime()`: This function returns the value of the `mTimer.elapsed()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundEvents()`: This function is a little more complicated getter. The `Track`
    class is the owner of `mSoundEvents` content and we really want to enforce it.
    For this, the getter returns a `const &` to `mSoundEvents`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stateChanged()`: This function is emitted when the `mState` value is updated.
    The new `State` is passed as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: This function is a slot that starts to play the `Track`. This play
    is purely logical, the real playback will be triggered by `PlaybackWorker`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`record()`: This function is a slot that starts the recording state of `Track`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This function is a slot that stops the current start or record state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSoundEvent()`: This function creates a new `SoundEvent` with the given `soundId`
    and adds it to `mSoundEvents`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This function resets the content of `Track`: it clears `mSoundEvents`
    and sets `mDuration` to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setState()`: This function is a private helper function that updates `mState`, `mPreviousState`
    and emits the `stateChanged()` signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the header has been covered, we can study the interesting parts of
    `Track.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Calling `Track.play()` simply updates the state to `PLAYING` and starts `mTimer`.
    The `Track` class does not hold anything related to the Qt Multimedia API; it
    is limited to an evolved data holder (as it also manages a state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `record()`, which brings a lot of surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts by clearing the data, sets the state to `RECORDING`, and also starts `mTimer`.
    Now consider `stop()`, which is a slight variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are stopping in the `RECORDING` state, `mDuration` is updated. Nothing
    very fancy here. We saw three times the `setState()` call without seeing its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The current value of `mState` is stored in `mPreviousState` before being updated.
    Finally, `stateChanged()` is emitted with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state system of `Track` is completely covered. The last missing part is
    the `SoundEvents` interactions. We can start with the `addSoundEvent()` snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `soundEvent` is created only if we are in the `RECORDING` state. After that,
    a `SoundEvent` is added to `mSoundEvents` with the current elapsed time of `mTimer`
    and the passed `soundEventId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `clear()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because we use `unique_ptr<SoundEvent>` in `mSoundEvents`, the `mSoundEvents.clear()`
    function is enough to empty the vector and also delete each `SoundEvent`. This
    is one less thing you have to worry with smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: The `SoundEvent` and `Track` are the base classes that hold the information
    about your future beat. We are going to see the class responsible for reading
    this data to play it: `PlaybackWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class and update `PlaybackWorker.h` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PlaybackWorker` class will be running in a different thread. If your memory
    needs to be refreshed, go back to [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*.
    Its role is to iterate through the `Track` class''s content to trigger the sounds.
    Let''s break down this header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mTrack`: This function is the reference to the `Track` class on which `PlaybackWorker`
    is working. It is passed in the constructor as a `const` reference. With this
    information, you already know that `PlaybackWorker` cannot modify `mTrack` in
    any way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mIsPlaying`: This function is a flag used to be able to stop the worker from
    another thread. It is a `QAtomicInteger` to guarantee an atomic access to the
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playSound()`: This function is emitted by `PlaybackWorker` each time a sound
    needs to be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trackFinished()`: This function is emitted when the playback has been played
    until the end. If it has been stopped along the way, this signal will not be emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: This function is the main function of `PlaybackWorker`. In it, `mTrack`
    content will be queried to trigger sounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This function is the function that updates the `mIsPlaying` flag
    and causes `play()` to exit its loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The meat of the class lies in the `play()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that `play()` function does is to prepare its reading: `mIsPlaying`
    is set to `true`, a `QElapsedTimer` class is declared, and a `soundEventIndex`
    is initialized. Each time `timer.elapsed()` is called, we will know if a sound
    should be played.
  prefs: []
  type: TYPE_NORMAL
- en: To know which sound should be played, `soundEventIndex` will be used to know
    where we are in the `soundEvents` vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after that, the `timer` object is started and we enter in the `while`
    loop. This `while` loop has two conditions to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timer.elapsed() <= mTrack.duration()`: This condition states that we did not
    finish playing the track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mIsPlaying.load()`: This condition returns **true**: nobody asked `PlaybackWorker`
    to stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, you might have added the `soundEventIndex < soundEvents.size()`
    condition in the `while` condition. By doing so, you would have exited `PlaybackWorker`
    as soon as the last sound has been played. Technically, it works, but that would
    not have respected what the user recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a user that created a complex beat (do not underestimate what you can
    do with four sounds!) and decided on a long pause of 5 seconds at the end of the
    song. When he clicks on the stop button, the time display indicates 00:55 (for
    55 seconds). However, when he plays back his performance, the last sound finishes
    at 00:50\. The playback stops at 00:50 and the program does not respect what he
    recorded.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the `soundEventIndex < size()` test is moved inside the `while`
    loop and is used only as a fuse for the `soundEvents` read through.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this condition, we retrieve the reference to the current `soundEvent`.
    We then compare the elapsed time against the `timestamp` of the `soundEvent`.
    If `timer.elapsed()` is greater or equal to `soundEvent->timestamp`, the signal `playSound()`
    is emitted with the `soundId`.
  prefs: []
  type: TYPE_NORMAL
- en: This is only a request to play a sound. The `PlaybackWorker` class limits itself
    to read through `soundEvents` and trigger a `playSound()` at the proper moment.
    The real sound will be handled later on, with the `SoundEffectWidget` class.
  prefs: []
  type: TYPE_NORMAL
- en: At each iteration in the `while` loop, a `QThread::msleep(1)` is done to avoid
    a busy loop. We minimize the sleep because we want the playback to be as faithful
    as possible to the original score. The longer the sleep, the more discrepancy
    we may encounter in the playback timing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the whole `soundEvents` has been processed, the `trackFinished`
    signal is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Making your objects serializable with QVariant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we implemented the logic in our business classes, we have to think
    about what we are going to serialize and how we are going to do it. The user interacts
    with a `Track` class that contains all the data to be recorded and played back.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from here, we can assume that the object to be serialized is `Track`,
    which in turn should somehow bring along its `mSoundEvents` containing a list
    of `SoundEvent` instances. To achieve this, we will rely heavily on the `QVariant`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You might have worked with `QVariant` before. It is a generic placeholder for
    any primitive type (`char`, `int`, `double`, and so on) but also complex types
    (`QString`, `QDate`, `QPoint`, and many more).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete list of QVariant supported types is available at [http://doc.qt.io/qt-5/qmetatype.html#Type-enum](http://doc.qt.io/qt-5/qmetatype.html#Type-enum).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of `QVariant` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We store `21` in `variant`. From here, we can ask for `variant` to have a copy
    of the value casted to our desired type. Here we want an `int` value, so we call `variant.toInt()`.
    There are a lot of conversions already available with the `variant.toX()` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We can take a very quick peek at what happens behind the curtain in `QVariant`.
    How does it store all we feed it? The answer lies in the C++ type `union`. The `QVariant`
    class is a kind of super `union`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `union` is a special class type that can hold only one of its non-static
    data members at a time. A short snippet should illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, a `union` class is declared like a `struct`. By default, all the members
    are `public`. The specificity of the `union` is that it takes only the largest
    member size in memory. Here, `Sound` will take only as much as the `int duration`
    space in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Because `union` takes only this specific space, every member variable shares
    the same memory space. Therefore, only one member is available at a time, unless
    you want to have undefined behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `Sound` snippet, we start by initializing with the value `10`
    (by default the first member is initialized). From here, `s.duration` is accessible
    but `s.code` is considered undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Once we assign a value to `s.code`, `s.duration` becomes undefined and `s.code`
    is now accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `union` class makes the memory usage very efficient. In `QVariant`, when
    you store a value, it is stored in a private `union`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the list of primitive types and at the end the complex types, `QObject*`
    and `void*`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `Data`, a `QMetaType` object is initialized to know the type of the
    stored object. The combination of `union` and `QMetaType` lets `QVariant` know
    which `Data` member it should use to cast the value and give it back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know what a `union` is and how `QVariant` uses it, you might ask:
    why make a `QVariant` class at all? A simple `union` would not have been enough?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no. It is not enough because a `union` class cannot have members
    that do not have a default constructor. It drastically reduces the number of classes
    you can put in a `union`. Qt folks wanted to include many classes that did not
    have a default constructor in `union`. To mitigate this, `QVariant` was born.
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes `QVariant` very interesting is that it is possible to store custom
    types. If we wanted to convert `SoundEvent` class to a `QVariant` class, we would
    have added the following in `SoundEvent.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We already used `Q_DECLARE_METATYPE` macro in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This macro effectively registers `SoundEvent` to the `QMetaType` register,
    making it available for `QVariant`. Because `QDataStream` relies on `QVariant`,
    we had to use this macro in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to convert back and forth with a `QVariant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, the output of this snippet is `4365`, the original `timestamp`
    stored in `soundEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach would have been perfect if we wanted to do only binary serialization.
    Data can be easily written and read from. However, we want to output our `Track`
    and `SoundEvents` to standard formats: JSON and XML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a major issue with the `Q_DECLARE_METATYPE`/`QVariant` combo: it does
    not store any key for the fields of the serialized class. We can already foresee
    that the JSON object of a `SoundEvent` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is no way the `QVariant` class could know that we want a `timestamp` key.
    It will only store the raw binary data. The same principle applies for the XML
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we are going to use a variation of a `QVariant` with a `QVariantMap`.
    The `QVariantMap` class is only a `typedef` on `QMap<QString, QVariant>`. This
    map will be used to store the key names of the fields and the value in the `QVariant`
    class. In turn, these keys will be used by the JSON and XML serialization system
    to output a pretty file.
  prefs: []
  type: TYPE_NORMAL
- en: Because we aim to have a flexible serialization system, we have to be able to
    serialize and deserialize this `QVariantMap` in multiple formats. To achieve this,
    we will define an interface that gives the ability for a class to serialize/deserialize
    its content in a `QVariantMap`.
  prefs: []
  type: TYPE_NORMAL
- en: This `QVariantMap` will be used as an intermediate format, agnostic of the final
    JSON, XML, or binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C++ header named `Serializer.h`. Here is the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By implementing this abstract base class, a class will be `Serializable`. There
    are only two virtual pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `toVariant()` function, in which the class must return a `QVariant` (or,
    more precisely a `QVariantMap`, which can be casted to a `QVariant` thanks to
    the `QMetaType` system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fromVariant()` function, in which the class must initialize its members
    from the variant passed as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing so, we give the responsibility to the final class to load and save
    its content. After all, who knows better `SoundEvent` than `SoundEvent` itself?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see `Serializable` in action with `SoundEvent`. Update `SoundEvent.h`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SoundEvent` class is now `Serializable`. Let''s do the real work in `SoundEvent.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In `toVariant()`, we simply declare a `QVariantMap` that gets filled with `timestamp`
    and `soundId`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, in `fromVariant()`, we convert `variant` to a `QVariantMap`
    and retrieve its content with the same keys we used in `toVariant()`. It is as
    simple as that!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class that have to be `Serializable` is `Track`. After making `Track`
    inherit from `Serializable`, update `Track.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The principle is the same, although a bit more complex. The `mDuration` variable
    is stored in `map` object as we have seen for `SoundEvent`. For `mSoundEvents`,
    we have to generate a list of `QVariant` (a `QVariantList`) where each item is
    the converted `QVariant` version of a `soundEvent` key.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we simply loop over `mSoundEvents` and fill `list` with the `soundEvent->toVariant()`
    result we covered a few paragraphs before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `fromVariant()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, for each element of the key `soundEvents`, we create a new `SoundEvent`,
    load it with the content of `data`, and finally add it to the vector `mSoundEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects in JSON format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Track` and `SoundEvent` classes can now be converted to a common Qt format `QVariant`.
    We now need to write a `Track` (and its `SoundEvent` objects) class in a file
    with a text or a binary format. This example project allows you to handle all
    the formats. It will allow you to switch the saved file format in one line. So
    where to put the specific format code? That is the million dollar question! Here
    is a primary approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects in JSON format](img/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this proposition, the specific file format serialization code is inside
    a dedicated child class. Well, it works but what would the hierarchy look like
    if we add two new file formats? Moreover, each time we add a new object to serialize,
    we have to create all these children classes to handle the different serialization
    file formats. This massive inheritance tree can quickly become a sticky mess.
    The code will be unmaintainable. You do not want to do that. So, here is where
    the bridge pattern can be a good solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects in JSON format](img/image00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a bridge pattern, we decouple the classes in two inheritance hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: The components independent from the file format. The `SoundEvent` and `Track`
    objects do not care about JSON, XML, or a binary format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file format implementations. The `JsonSerializer`, `XmlSerializer` and `BinarySerializer`
    handle a generic format, `Serializable`, not a specific component such as `SoundEvent`
    or `Track`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that in a classic bridge pattern, an abstraction (`Serializable`) should
    contains an implementor (`Serializer`) variable. The caller only deals with the
    abstraction. However in this project example, `MainWindow` has the ownership of `Serializable`
    and also of `Serializer`. This is a personal choice to use the power of design
    pattern while keeping uncoupled functional classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of `Serializable` and `Serializer` is clear. The `Serializable` class
    is already implemented so you can now create a new C++ header file called `Serializer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Serializer` class is an interface, an abstract class with only pure virtual
    functions and no data. Let''s talk about the `save()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: This function saves `Serializable` to a file on the hard disk drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class is `const` and cannot be modified by this function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filepath` function indicates the destination file to create.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some `Serializer` implementations can use the `rootName` variable. For example,
    if we request to save a `Track` object, the `rootName` variable could be the string `track`.
    This is the label used to write the root element. The XML implementation requires
    this information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `load()` function is also easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: This function loads data from a file to fill a `Serializable` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class will be updated by this function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filepath` function indicates which file to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface `Serializer` is ready and waits for some implementations! Let''s
    start with JSON. Create a C++ class, `JsonSerializer`. Here is the header for `JsonSerializer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'No difficulties here; we have to provide an implementation of `save()` and `load()`.
    Here is the `save()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Qt framework provides a nice way to read and write a JSON file with the
    `QJsonDocument` class. We can create a `QJsonDocument` class from a `QVariant`
    class. Notice that the `QVariant` accepted by `QJsonDocument` must be a `QVariantMap`, `QVariantList`,
    or `QStringList`. No worries, the `toVariant()` function of `Track` class and `SoundEvent`
    generates a `QVariantMap`. Then, we can create a `QFile` file with the destination `filepath`.
    The `QJsonDocument::toJson()` function converts it to a UTF-8 encoded text representation.
    We write this result to the `QFile` file and close the file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QJsonDocument::toJson()` function can produce an `Indented` or a `Compact`
    JSON format. By default, the format is `QJsonDocument::Indented`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load()` implementation is also short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We open a `QFile` with the source `filepath`. We read all the data with `QFile::readAll()`.
    Then we can create a `QJsonDocument` class with the `QJsonDocument::fromJson()`
    function. Finally, we can fill our destination `Serializable` with the `QJsonDocument`
    converted to a `QVariant` class. Notice that the `QJsonDocument::toVariant()`
    function can return `QVariantList` or a `QVariantMap` depending the nature of
    the JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `Track` class saved with this `JsonSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The root element is a JSON object, represented by a map with two keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Duration`: This is a simple integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundEvents`: This is an array of objects. Each object is a map with the following
    keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundId`: This is an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp`: This is also an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects in XML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "The JSON serialization was a direct representation of the C++ objects and Qt\
    \ already provides all we need. However, the serialization of a C++ object can\
    \ be done with various representations in an XML format. So we have to write the\
    \ XML â\x86” `QVariant` conversion ourselves. We have decided to use the following\
    \ XML representation:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the `soundId` type gives this XML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C++ class `XmlSerializer` that also inherits from `Serializer`. Let''s
    begin with the `save()` function, here is `XmlSerializer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the `save()` implementation in `XmlSerializer.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `QFile` file with the `filepath` destination. We construct a `QXmlStreamWriter`
    object that writes in the `QFile`. By default, the writer will produce a compact
    XML; you can generate a pretty XML with the `QXmlStreamWriter::setAutoFormatting()`
    function. The `QXmlStreamWriter::writeStartDocument()` function writes the XML
    version and the encoding. We write our `QVariant` in the XML stream with our `writeVariantToStream()`
    function. Finally, we end the document and close the `QFile`. As already explained,
    writing a `QVariant` to an XML stream depends on how you want to represent the
    data. So we have to write the conversion function. Please update your class with `writeVariantToStream()`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This `writeVariantToStream()` function is a generic entry point. It will be
    called each time we want to put a `QVariant` in the XML stream. The `QVariant`
    class could be a list, a map, or data. So we apply a specific treatment if the `QVariant`
    is a container (`QVariantList` or `QVariantMap`). All the other cases are considered
    to be a data value. Here are the steps of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new XML element with the `writeStartElement()` function. The `nodeName`
    will be used to create the XML tag. For example, `<soundId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an XML attribute called `type` in the current element. We use the name
    of the type stored in the `QVariant`. For example, `<soundId type="int"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the `QVariant` data type, we call one of our XML serialization
    functions. For example, `<soundId type="int">2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we end the current XML element with `writeEndElement()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final result is: `<soundId type="int">2</soundId>`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this function, we call three helper functions that we will create now. The
    easiest one is `writeVariantValueToStream()`. Please update your `XmlSerializer`
    class with:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: If the `QVariant` is a simple type, we retrieve its `QString` representation.
    Then we use `QXmlStreamWriter::writeCharacters()` to write this `QString` in the
    XML stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second helper function is `writeVariantListToStream()`. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: At this step, we already know that the `QVariant` is a `QVariantList`. We call `QVariant::toList()`
    to retrieve the list. Then we iterate over all elements of the list and call our
    generic entry point, `writeVariantToStream()`. Notice that we retrieve the elements
    from a list so we do not have an element name. But the tag name does not matter
    for a list item serialization, so insert the arbitrary label `item`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last write helper function is `writeVariantMapToStream()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `QVariant` is a container but a `QVariantMap` this time. We call `writeVariantToStream()`
    for each element found. The tag name is important because this is a map. We use
    the map key from `QMapIterator::key()` as the node name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The saving part is over. We can now implement the loading part. Its architecture
    follows the same spirit as the saving functions. Let''s begin with the `load()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is to create a `QFile` with the source `filepath`. We
    construct a `QXmlStreamReader` with the `QFile`. The `QXmlStreamReader ::readNextStartElement()`
    function reads until the next start element in the XML stream. Then we can use
    our read helper function, `readVariantFromStream()`, to create a `QVariant` class
    from an XML stream. Finally, we can use our `Serializable::fromVariant()` to fill
    the destination `serializable`. Let''s implement the helper function, `readVariantFromStream()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The role of this function is to create a `QVariant`. Firstly, we retrieve the `"type"`
    from the XML attributes. In our case, we have only one attribute to handle. Then,
    depending on the type, we will call one of our three read helper functions. Let''s
    implement the `readVariantValueFromStream()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function create a `QVariant` with its data depending on the type. Like
    the previous function, we retrieve the type from the XML attribute. We also read
    the data as a text with the `QXmlStreamReader::readElementText()` function. A `QVariant`
    class is created with this `QString` data. At this step, the `QVariant` type is
    a `QString`. So we use the `QVariant::convert()` function to convert the `QVariant`
    to the real type (`int` , `qlonglong`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second read helper function is `readVariantListFromStream()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We know that the stream element contains an array. So, this function creates
    and returns a `QVariantList`. The `QXmlStreamReader::readNextStartElement()` function
    reads until the next start element and returns `true` if a start element is found
    within the current element. We call the entry-point function, `readVariantFromStream()`,
    for each element. Finally, we return the `QVariantList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last helper function to cover is `readVariantMapFromStream()`. Update your
    file with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function sounds like the `readVariantListFromStream()`. This time we have
    to create a `QVariantMap`. The key used for inserting a new item is the element
    name. We retrieve the name with the `QXmlStreamReader::name()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Track` class serialized with the `XmlSerializer` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Serializing objects in binary format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The XML serialization is fully functional! We can now switch to the last type
    of serialization covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary serialization is easier because Qt provides a direct way to do it.
    Please create a `BinarySerializer` class that inherits from `Serializer`. The
    header is common, we have only the override functions, `save()` and `load()`.
    Here is the implementation of the `save()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We hope you recognized the `QDataStream` class used in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This time we use this class to serialize binary data in a destination `QFile`.
    A `QDataStream` class accepts a `QVariant` class with the `<<` operator. Notice
    that the `rootName` variable is not used in the binary serializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `load()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `QVariant` and the `QDataStream` mechanism, the task is easy.
    We open the `QFile` with the source `filepath`. We construct a `QDatastream` class
    with this `QFile`. Then, we use the `>>` operator to read the root `QVariant`.
    Finally, we fill the source `Serializable` with our `Serializable::fromVariant()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry, we will not include an example of a `Track` class serialized with
    the `BinarySerializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: The serialization part is completed. The GUI part of this example project has
    been covered many times during the previous chapters of this book. The following
    sections will only cover specific features used in our `MainWindow` and `SoundEffectWidget`
    classes. Check the source code if you need the complete C++ classes.
  prefs: []
  type: TYPE_NORMAL
- en: Playing low latency sounds with QSoundEffect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project application `ch11-drum-machine` displays four `SoundEffectWidget`
    widgets: `kickWidget`, `snareWidget`, `hihatWidget`, and `crashWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `SoundEffectWidget` widget displays a `QLabel` and a `QPushButton`. The
    label displays the sound name. If the button is clicked, a sound is played.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt Multimedia module provides two main ways to play an audio file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QMediaPlayer`: This file can play songs, movies, and Internet radio with various
    input formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSoundEffect`: This file can play low-latency `.wav` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This project example is a virtual drum machine, so we are using a `QSoundEffect`
    object. The first step to use a `QSoundEffect` is to update your `.pro` file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can initialize the sound. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to create a valid `QUrl` for your sound file. The `urlKick`
    is initialized from a `.qrc` resources file path, while `urlBetterKick` is created
    from a local file path. Then we can create `QSoundEffect` and set the URL sound
    to play with the `QSoundEffect::setSource()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `QSoundEffect` object initialized, we can play the sound
    with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Triggering a QButton with your keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore the public slot, `triggerPlayButton()`, in the `SoundEffectWidget`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This widget has a `QPushButton` called `mPlayButton`. The `triggerPlayButton()`
    slot calls the `QPushButton::animateClick()` function, which simulates a click
    on the button over 100 ms by default. All signals will be sent as a real click
    does. The button really appears to be down. If you do not want the animation you
    can call `QPushButton::click()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now how to trigger this slot with a key. Each `SoundEffectWidget`
    has a `Qt:Key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `SoundEffectWidget` class provides a getter and a setter to get and set
    the member variable, `mTriggerKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainWindow` class initializes the keys of its four `SoundEffectWidget`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `QObject::eventFilter()` function is not called. To enable
    it and intercept these events, we need to install an event filter on the `MainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So each time the `MainWindow` receives an event, the `MainWindow::eventFilter()`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `MainWindow.h` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainWindow` class has a `QVector` with the four `SoundEffectWidgets` (`kickWidget`, `snareWidget`, `hihatWidget`,
    and `crashWidget`). Let''s see the implementation in `MainWindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is to check that the `QEvent` class is a `KeyPress` type.
    We do not care about other event types. If the event type is correct, we proceed
    to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Cast the `QEvent` class to `QKeyEvent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we search if the pressed key belongs to the `SoundEffectWidget` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a `SoundEffectWidget` class corresponds to the key, we call our `SoundEffectWidget::triggerPlayButton()`
    function and we return `true` to indicate that we consumed the event and it must
    not be propagated to others classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, we call the `QObject` class implementation of `eventFilter()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bringing PlaybackWorker to life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user can play a sound live with a mouse click or a keyboard key. But when
    he records an awesome beat, the application must be able to play it again with
    the `PlaybackWorker` class. Let''s see how `MainWindow` uses this worker. Here
    is the `MainWindow.h` related to the `PlaybackWorker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `MainWindow` has `PlaybackWorker` and a `QThread` member variables.
    Let''s see the implementation of `startPlayback()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze all the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We clear the current playback with the `clearPlayback()` function, which will
    be covered soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `QThread` and `PlaybackWorker` are constructed. The current track is
    given to the worker at this moment. As usual, the worker is then moved to its
    dedicated thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to play the track as soon as possible. So, when the `QThread` emits
    the `started()` signal, the `PlaybackWorker::play()` slot is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not want to worry about the `PlaybackWorker` memory. So when the `QThread`
    is over and it has sent the `finished()` signal, we call the `QObject::deleteLater()`
    slot, which schedules the worker for deletion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `PlaybackWorker` class needs to play a sound, the `playSound()` signal
    is emitted and our `MainWindow:playSoundEffect()` slot is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last connect covers when the `PlaybackWorker` class finishes playing the
    whole track. A `trackFinished()` signal is emitted and we call the `Track::Stop()`
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the thread is started with a high priority. Notice that some operating
    systems (for example, Linux) do not support thread priorities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now see the `stopPlayback()` body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `stop()` function of the `PlaybackWorker` from our thread. Because
    we use a `QAtomicInteger` in `stop()`, the function is thread-safe and can be
    directly called. Finally, we call our helper function, `clearPlayback()`. This
    is the second time that we use `clearPlayback()`, so let''s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here. If the thread is valid, we ask the thread to exit and wait
    1 second. Then, we set the thread and the worker to `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaybackWorker::PlaySound` signal is connected to `MainWindow::playSoundEffect()`.
    Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This slot retrieves the `SoundEffectWidget` class corresponding to the `soundId`.
    Then, we call the `triggerPlayButton()`, the same method that is called when you
    press the trigger key on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when you click on the button, press a key, or when the `PlaybackWorker`
    class requests to play a sound, the `QPushButton` of `SoundEffectWidget` emits
    the signal, `clicked()`. This signal is connected to our `SoundEffectWidget::play()`
    slot. The next snippet describes this slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy here. We call the `play()` function on the `QSoundEffect` already
    covered. Finally, we emit the `soundPlayed()` signal that is used by `Track` to
    add a new `SoundEvent` if we are in the `RECORDING` state.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting mouse drag and drop events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project example, if you drag and drop a `.wav` file on a `SoundEffectWidget`,
    you can change the sound played. The constructor of `SoundEffectWidget` performs
    a specific task to allow drag and drop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now override the drag and drop callbacks. Let''s start with the `dragEnterEvent()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `dragEnterEvent()` function is called each time the user drags an object
    on the widget. In our case, we only want to allow drag and drop on files that
    are of the MIME type: `"text/uri-list"` (a list of URIs, which can be `file://`, `http://`,
    and so on). In this case, though we can call the `QDragEnterEvent::acceptProposedAction()`
    function to notify that we accept this object for a drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a second function, `dropEvent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The first step is a sanity check. If the event does not have a URL, we do nothing.
    The `QMimeData::hasUrls()` function returns `true` only with the MIME type: `"text/uri-text"`.
    Notice that a user can drag and drop multiple files at once. In our case, we only
    handle the first URL. You can check that the file is a `.wav` file with its MIME
    type. If the MIME type is `"audio/wav"`, we call the `loadSound()` function, which
    updates the sound assigned to this `SoundEffectWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot show the complete application for `ch11-drum-machine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accepting mouse drag and drop events](img/image00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization is a good way to make your data persistent when you close your
    application. In this chapter, you learned to make your C++ objects serializable
    with `QVariant`. You created a flexible serialization structure with the Bridge
    pattern. You saved an object in a different text format such as JSON or XML and
    also in a binary format.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned to use the Qt Multimedia module to play some sound effects.
    These sounds can be triggered by a mouse click or by a keyboard key. You implemented
    a friendly user interaction, allowing you to load a new sound with a file drag
    and drop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover the `QTest` framework and how you can
    organize your project so it has a clean application/test separation.
  prefs: []
  type: TYPE_NORMAL
