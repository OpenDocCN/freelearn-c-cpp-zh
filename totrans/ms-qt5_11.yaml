- en: Chapter 11.  Having Fun with Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章. 与序列化一起玩乐
- en: 'The previous chapter was a firework of threads, sockets, and workers. We hope
    that your minions have been working hard. In this chapter, we will turn our attention
    to the serialization with Qt. You will learn how to serialize data in multiple
    formats with a flexible system. The example project will be a virtual drum machine,
    in which you can compose you own drum beat, record it, play it, save it, and load
    it back. Your drum beat will be probably so awesome that you will want to share
    it: you will now be able to do it in various formats.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章充满了线程、套接字和工作者的内容。我们希望你的小兵们一直在努力工作。在这一章中，我们将关注使用 Qt 的序列化。你将学习如何使用灵活的系统以多种格式序列化数据。示例项目将是一个虚拟鼓机，你可以创作自己的鼓点，录制、播放、保存和重新加载它。你的鼓点可能非常棒，以至于你想与他人分享：你现在可以以各种格式做到了。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to architecture an application that plays and records sounds
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个播放和录制声音的应用程序架构
- en: The `QVariant` class and its inner mechanics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVariant` 类及其内部机制'
- en: A flexible serialization system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个灵活的序列化系统
- en: JSON serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 序列化
- en: XML serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 序列化
- en: Binary serialization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制序列化
- en: The Qt Multimedia framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 多媒体框架
- en: Drag and drop handling with Qt
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt 处理拖放
- en: Triggering a button from your keyboard
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键盘触发按钮
- en: Architecting the drum machine project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建鼓机项目
- en: 'As usual, before diving into the code, let''s study the structure of the project.
    The aim of the project is to be able to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在深入代码之前，让我们研究一下项目的结构。项目的目标是能够：
- en: Play and record a sound track from a drum machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从鼓机播放和录制声音轨道
- en: Save this track to a file and load it to play it back
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此轨道保存到文件中并加载以播放
- en: 'To play a sound, we will lay out four big buttons that will play a specific
    drum sound upon click (or a keyboard event): a kick, a snare, a hi-hat, and a
    cymbal crash. These sounds will be `.wav` files loaded by the application. The
    user will be able to record his sequence of sounds and replay it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了播放声音，我们将布局四个大按钮，点击（或键盘事件）时将播放特定的鼓声：一个踢鼓、一个军鼓、一个高脚鼓和一个钹。这些声音将由应用程序加载的 `.wav`
    文件。用户将能够录制他的声音序列并重新播放。
- en: 'For the serialization part, we do not only want to save the track to a single
    file format, we would rather do three:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于序列化部分，我们不仅希望将轨道保存到单个文件格式，我们更愿意做三个：
- en: '**JSON** (**JavaScript Object Notation**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**（**JavaScript 对象表示法**）'
- en: '**XML** (**eXtensible Markup Language**)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**（**可扩展标记语言**）'
- en: '**Binary**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**'
- en: Not only is it more fun to cover three formats, but it also gives us the opportunity
    to understand the advantages and limitations of each one, and how it fits within
    the Qt framework. The architecture we are going to implement will try to be flexible
    to handle future evolutions. You never know how a project can evolve!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅涵盖三种格式更有趣，而且也给了我们了解每种格式的优缺点以及它们如何在 Qt 框架中定位的机会。我们将要实施的架构将力求灵活以应对未来的演变。你永远不知道一个项目会如何发展！
- en: 'The classes'' organization looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类的组织结构如下：
- en: '![Architecting the drum machine project](img/image00441.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![构建鼓机项目架构](img/image00441.jpeg)'
- en: 'Let''s review the role of these classes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些类的作用：
- en: The `SoundEvent` class is the basic building block of a track. It is a simple
    class containing `timestamp` (when the sound has been played) and `soundId` variables
    (what sound has been played).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundEvent` 类是轨道的基本构建块。它是一个简单的类，包含 `timestamp`（声音播放的时间）和 `soundId` 变量（播放了什么声音）。'
- en: The `Track` class contains a list of `SoundEvents`, a duration and a state (playing,
    recording, stopped). Each time the user plays a sound, a `SoundEvent` class is
    created and added to the `Track` class.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Track` 类包含一个 `SoundEvents` 列表、一个持续时间和一个状态（播放、录制、停止）。每次用户播放声音时，都会创建一个 `SoundEvent`
    类并将其添加到 `Track` 类。'
- en: The `PlaybackWorker` class is a worker class that runs in a different thread.
    It is responsible of looping through the `Track` class's `soundEvents` and triggering
    the proper sound when its `timestamp` has been reached.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaybackWorker` 类是一个在单独线程中运行的工人类。它负责遍历 `Track` 类的 `soundEvents` 并在其 `timestamp`
    达到时触发适当的音效。'
- en: The `Serializable` class is an interface that must be implemented by each class
    that wants to be serialized (in our case: `SoundEvent` and `Track`).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serializable` 类是一个接口，每个想要被序列化的类都必须实现（在我们的案例中：`SoundEvent` 和 `Track`）。'
- en: The `Serializer` class is an interface that must be implemented by each format-specific
    implementation class.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serializer` 类是一个接口，每个特定格式的实现类都必须实现它。'
- en: The `JsonSerializer`, `XmlSerializer`, and `BinarySerializer` are the sub-classes
    of `Serializer` class that do the format-specific job to serialize/deserialize
    a `Serializable` instance.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonSerializer`、`XmlSerializer` 和 `BinarySerializer` 是 `Serializer` 类的子类，它们执行特定格式的序列化和反序列化任务。'
- en: The `SoundEffectWidget` class is the widget that holds the information to play
    a single sound. It displays the button for one of our four sounds. It also owns
    a `QSoundEffect` class that sends the sound to the audio card.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundEffectWidget` 类是包含播放单个声音信息的窗口小部件。它显示我们四个声音中的一个按钮。它还拥有一个 `QSoundEffect`
    类，该类将声音发送到音频卡。'
- en: The `MainWindow` class holds everything together. It owns the `Track` class,
    spawns the `PlaybackWorker` thread, and triggers the serialization/deserialization.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow` 类将一切整合在一起。它拥有 `Track` 类，生成 `PlaybackWorker` 线程，并触发序列化和反序列化。'
- en: The output format should be easily swapped. To achieve this, we will rely on
    a modified version of the bridge design pattern that will allow `Serializable`
    and `Serializer` classes to evolve independently.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式应该易于更换。为了实现这一点，我们将依赖一个修改过的桥接设计模式，这将允许 `Serializable` 和 `Serializer` 类独立演进。
- en: The whole project revolves around this notion of independence between modules.
    It goes to the extent that a sound can be replaced on the spot during a playback.
    Let's say that you listen to your incredible beat, and you want to try another
    snare sound. You will be able to replace it with a simple drag and drop of a `.wav`
    file on the `SoundEffectWidget` class holding the snare sound.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目围绕模块之间独立性的概念展开。它甚至到了在播放过程中可以即时替换声音的程度。比如说，你正在听你令人难以置信的节奏，并想尝试另一个鼓声。你将能够通过简单地将
    `.wav` 文件拖放到持有鼓声的 `SoundEffectWidget` 类上来替换它。
- en: Creating a drum track
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建鼓点轨道
- en: Let's buckle up and do this project! Create a new **Qt Widgets Application**
    project named `ch11-drum-machine`. As usual, add the `CONFIG += c++14` in `ch11-drum-machine.pro`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们系好安全带，开始这个项目！创建一个新的 **Qt Widgets Application** 项目，命名为 `ch11-drum-machine`。像往常一样，在
    `ch11-drum-machine.pro` 中添加 `CONFIG += c++14`。
- en: 'Now create a new C++ class named `SoundEvent`. Here is `SoundEvent.h` stripped
    from its functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的 C++ 类，命名为 `SoundEvent`。以下是 `SoundEvent.h` 中移除了函数的部分：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class contains only two public members:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只包含两个公共成员：
- en: '`timestamp`: A `qint64` (`long long` type) that contains the current time of
    the `SoundEvent` in milliseconds since the beginning of the track'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`：一个包含从轨道开始以来 `SoundEvent` 当前时间的 `qint64` (`long long` 类型)，单位为毫秒。'
- en: '`soundId`: The ID of the sound that has been played'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soundId`：播放过的声音的 ID'
- en: In recording mode, each time the user plays a sound, a `SoundEvent` is created
    with the appropriate data. The `SoundEvent.cpp` file is so boring that we will
    not inflict it on you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在录制模式下，每次用户播放声音时，都会创建一个带有适当数据的 `SoundEvent`。`SoundEvent.cpp` 文件非常无聊，所以我们不会把它强加给你。
- en: 'The next class to build is `Track`. Again, create the new C++ class. Let''s
    review `Track.h` with its members only:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要构建的类是 `Track`。再次创建一个新的 C++ 类。让我们回顾一下 `Track.h` 中的成员：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now go into detail about them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以详细地介绍它们：
- en: '`mDuration`: This variable holds the duration of the `Track` class. This member
    is reset to 0 when a recording is started and updated when the recording is stopped.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mDuration`：这个变量持有 `Track` 类的持续时间。当开始录制时，这个成员被重置为 0，并在录制停止时更新。'
- en: '`mSoundEvents`: This variable is the list of `SoundEvents` for the given `Track`.
    As the `unique_ptr` semantic states it, `Track` is the owner of the sound events.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSoundEvents`：这个变量是给定 `Track` 的 `SoundEvents` 列表。正如 `unique_ptr` 语义所表明的，`Track`
    是声音事件的拥有者。'
- en: '`mTimer`: This variable is started each time `Track` is played or recorded.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTimer`：每次播放或录制 `Track` 时，这个变量都会启动。'
- en: '`mState`: This variable is the current `State` of `Track` class, which can
    have three possible values: `STOPPED`, `PLAYING`, `RECORDING`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mState`：这个变量是 `Track` 类的当前 `State`，它可以有三个可能的值：`STOPPED`、`PLAYING`、`RECORDING`。'
- en: '`mPreviousState`: This variable is the previous `State` of `Track`. This is
    useful when you want to know which action to do on a new `STOPPED``State`. We
    will have to stop the playback if `mPreviousState` is in the `PLAYING` state.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mPreviousState`：这个变量是 `Track` 的上一个 `State`。当你想知道在新的 `STOPPED` 状态上要执行什么操作时，这很有用。如果
    `mPreviousState` 处于 `PLAYING` 状态，我们将不得不停止播放。'
- en: The `Track` class is the pivot of the business logic of the project. It holds `mState`,
    which is the state of the whole application. Its content will be read during a
    playback of your awesome musical performance and also be serialized to a file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`类是项目业务逻辑的核心。它持有`mState`，这是整个应用程序的状态。其内容将在播放你令人惊叹的音乐表演时被读取，并将其序列化到文件中。'
- en: 'Let''s enrich `Track.h` with functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用函数丰富`Track.h`：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will skip the simple getters and concentrate on the important functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过简单的获取器，专注于重要的函数：
- en: '`elapsedTime()`: This function returns the value of the `mTimer.elapsed()`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsedTime()`：这个函数返回`mTimer.elapsed()`的值。'
- en: '`soundEvents()`: This function is a little more complicated getter. The `Track`
    class is the owner of `mSoundEvents` content and we really want to enforce it.
    For this, the getter returns a `const &` to `mSoundEvents`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soundEvents()`：这个函数是一个更复杂的获取器。`Track`类是`mSoundEvents`内容的拥有者，我们确实想强制执行这一点。为此，获取器返回`mSoundEvents`的`const
    &`。'
- en: '`stateChanged()`: This function is emitted when the `mState` value is updated.
    The new `State` is passed as a parameter.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stateChanged()`：当`mState`值更新时，会发出这个函数。新的`State`作为参数传递。'
- en: '`play()`: This function is a slot that starts to play the `Track`. This play
    is purely logical, the real playback will be triggered by `PlaybackWorker`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play()`：这个函数是一个槽，开始播放`Track`。这种播放完全是逻辑上的，真正的播放将由`PlaybackWorker`触发。'
- en: '`record()`: This function is a slot that starts the recording state of `Track`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record()`：这个函数是一个槽，开始`Track`的录制状态。'
- en: '`stop()`: This function is a slot that stops the current start or record state.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`：这个函数是一个槽，停止当前开始或录制状态。'
- en: '`addSoundEvent()`: This function creates a new `SoundEvent` with the given `soundId`
    and adds it to `mSoundEvents`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSoundEvent()`：这个函数使用给定的`soundId`创建一个新的`SoundEvent`并将其添加到`mSoundEvents`。'
- en: '`clear()`: This function resets the content of `Track`: it clears `mSoundEvents`
    and sets `mDuration` to `0`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`：这个函数重置`Track`的内容：它清除`mSoundEvents`并将`mDuration`设置为`0`。'
- en: '`setState()`: This function is a private helper function that updates `mState`, `mPreviousState`
    and emits the `stateChanged()` signal.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setState()`：这个函数是一个私有辅助函数，用于更新`mState`、`mPreviousState`并发出`stateChanged()`信号。'
- en: 'Now that the header has been covered, we can study the interesting parts of
    `Track.cpp`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经覆盖了头文件，我们可以研究`Track.cpp`中的有趣部分：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calling `Track.play()` simply updates the state to `PLAYING` and starts `mTimer`.
    The `Track` class does not hold anything related to the Qt Multimedia API; it
    is limited to an evolved data holder (as it also manages a state).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Track.play()`只是将状态更新为`PLAYING`并启动`mTimer`。`Track`类不包含与Qt多媒体API相关的任何内容；它仅限于一个进化的数据持有者（因为它还管理状态）。
- en: 'Now for `record()`, which brings a lot of surprises:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`record()`函数，它带来了很多惊喜：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It starts by clearing the data, sets the state to `RECORDING`, and also starts `mTimer`.
    Now consider `stop()`, which is a slight variation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先清除数据，将状态设置为`RECORDING`，并启动`mTimer`。现在考虑`stop()`，这是一个轻微的变化：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we are stopping in the `RECORDING` state, `mDuration` is updated. Nothing
    very fancy here. We saw three times the `setState()` call without seeing its body:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`RECORDING`状态下停止，`mDuration`将被更新。这里没有什么特别之处。我们看到了三次`setState()`调用，但没有看到其主体：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The current value of `mState` is stored in `mPreviousState` before being updated.
    Finally, `stateChanged()` is emitted with the new value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新之前，当前`mState`的值存储在`mPreviousState`中。最后，使用新值发出`stateChanged()`。
- en: 'The state system of `Track` is completely covered. The last missing part is
    the `SoundEvents` interactions. We can start with the `addSoundEvent()` snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`的状态系统被完全覆盖。最后缺失的部分是`SoundEvents`的交互。我们可以从`addSoundEvent()`片段开始：'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `soundEvent` is created only if we are in the `RECORDING` state. After that,
    a `SoundEvent` is added to `mSoundEvents` with the current elapsed time of `mTimer`
    and the passed `soundEventId`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们处于`RECORDING`状态时，才会创建`soundEvent`。之后，将带有当前`mTimer`的流逝时间和传递的`soundEventId`的`SoundEvent`添加到`mSoundEvents`。
- en: 'Now for the `clear()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`clear()`函数：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we use `unique_ptr<SoundEvent>` in `mSoundEvents`, the `mSoundEvents.clear()`
    function is enough to empty the vector and also delete each `SoundEvent`. This
    is one less thing you have to worry with smart pointers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`mSoundEvents`中使用`unique_ptr<SoundEvent>`，所以`mSoundEvents.clear()`函数足以清空向量并删除每个`SoundEvent`。这减少了你需要担心智能指针的事情。
- en: The `SoundEvent` and `Track` are the base classes that hold the information
    about your future beat. We are going to see the class responsible for reading
    this data to play it: `PlaybackWorker`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEvent`和`Track`是包含你未来节奏信息的基类。我们将看到负责读取这些数据以播放的类：`PlaybackWorker`。'
- en: 'Create a new C++ class and update `PlaybackWorker.h` like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，并像这样更新`PlaybackWorker.h`：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `PlaybackWorker` class will be running in a different thread. If your memory
    needs to be refreshed, go back to [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*.
    Its role is to iterate through the `Track` class''s content to trigger the sounds.
    Let''s break down this header:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaybackWorker`类将在不同的线程中运行。如果你的记忆需要刷新，请回到[第9章](part0090.xhtml#aid-2LQIK2 "第9章。使用多线程保持你的理智")，*使用多线程保持你的理智*。它的作用是遍历`Track`类的内容以触发声音。让我们分解这个头文件：'
- en: '`mTrack`: This function is the reference to the `Track` class on which `PlaybackWorker`
    is working. It is passed in the constructor as a `const` reference. With this
    information, you already know that `PlaybackWorker` cannot modify `mTrack` in
    any way.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTrack`: 这个函数是`PlaybackWorker`正在工作的`Track`类的引用。它作为`const`引用传递给构造函数。有了这个信息，你已经知道`PlaybackWorker`不能以任何方式修改`mTrack`。'
- en: '`mIsPlaying`: This function is a flag used to be able to stop the worker from
    another thread. It is a `QAtomicInteger` to guarantee an atomic access to the
    variable.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mIsPlaying`: 这个函数是一个标志，用于能够从另一个线程停止工作。它是一个`QAtomicInteger`，以保证对变量的原子访问。'
- en: '`playSound()`: This function is emitted by `PlaybackWorker` each time a sound
    needs to be played.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playSound()`: 这个函数由`PlaybackWorker`在需要播放声音时发出。'
- en: '`trackFinished()`: This function is emitted when the playback has been played
    until the end. If it has been stopped along the way, this signal will not be emitted.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trackFinished()`: 当播放被播放到结束时，这个函数会被发出。如果在途中停止，这个信号将不会被发出。'
- en: '`play()`: This function is the main function of `PlaybackWorker`. In it, `mTrack`
    content will be queried to trigger sounds.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play()`: 这个函数是`PlaybackWorker`的主要函数。在其中，将查询`mTrack`内容以触发声音。'
- en: '`stop()`: This function is the function that updates the `mIsPlaying` flag
    and causes `play()` to exit its loop.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`: 这个函数是更新`mIsPlaying`标志并导致`play()`退出其循环的函数。'
- en: 'The meat of the class lies in the `play()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类的核心在于`play()`函数：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing that `play()` function does is to prepare its reading: `mIsPlaying`
    is set to `true`, a `QElapsedTimer` class is declared, and a `soundEventIndex`
    is initialized. Each time `timer.elapsed()` is called, we will know if a sound
    should be played.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`play()`函数首先做的事情是准备它的读取：将`mIsPlaying`设置为`true`，声明一个`QElapsedTimer`类，并初始化一个`soundEventIndex`。每次调用`timer.elapsed()`时，我们都会知道是否应该播放声音。'
- en: To know which sound should be played, `soundEventIndex` will be used to know
    where we are in the `soundEvents` vector.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道应该播放哪个声音，`soundEventIndex`将用来知道我们在`soundEvents`向量中的位置。
- en: 'Right after that, the `timer` object is started and we enter in the `while`
    loop. This `while` loop has two conditions to continue:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，启动`timer`对象，我们进入`while`循环。这个`while`循环有两个条件以继续：
- en: '`timer.elapsed() <= mTrack.duration()`: This condition states that we did not
    finish playing the track'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer.elapsed() <= mTrack.duration()`: 这个条件表明我们没有完成播放曲目'
- en: '`mIsPlaying.load()`: This condition returns **true**: nobody asked `PlaybackWorker`
    to stop'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mIsPlaying.load()`: 这个条件返回**true**：没有人要求`PlaybackWorker`停止'
- en: Intuitively, you might have added the `soundEventIndex < soundEvents.size()`
    condition in the `while` condition. By doing so, you would have exited `PlaybackWorker`
    as soon as the last sound has been played. Technically, it works, but that would
    not have respected what the user recorded.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地讲，你可能在`while`条件中添加了`soundEventIndex < soundEvents.size()`条件。这样做的话，你会在最后一个声音播放完毕后立即退出`PlaybackWorker`。技术上，这是可行的，但这样就不会尊重用户记录的内容。
- en: Consider a user that created a complex beat (do not underestimate what you can
    do with four sounds!) and decided on a long pause of 5 seconds at the end of the
    song. When he clicks on the stop button, the time display indicates 00:55 (for
    55 seconds). However, when he plays back his performance, the last sound finishes
    at 00:50\. The playback stops at 00:50 and the program does not respect what he
    recorded.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用户创建了一个复杂的节奏（不要低估你用四个声音能做什么！）并在歌曲结束时决定有一个5秒的长时间暂停。当他点击停止按钮时，时间显示为00:55（55秒）。然而，当他播放他的表演时，最后一个声音在00:50结束。播放在00:50停止，程序不尊重他记录的内容。
- en: For this reason, the `soundEventIndex < size()` test is moved inside the `while`
    loop and is used only as a fuse for the `soundEvents` read through.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`soundEventIndex < size()`测试被移动到`while`循环内部，并仅用作通过`soundEvents`读取的保险丝。
- en: Inside this condition, we retrieve the reference to the current `soundEvent`.
    We then compare the elapsed time against the `timestamp` of the `soundEvent`.
    If `timer.elapsed()` is greater or equal to `soundEvent->timestamp`, the signal `playSound()`
    is emitted with the `soundId`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个条件内部，我们检索当前`soundEvent`的引用。然后我们将已过时间与`soundEvent`的`timestamp`进行比较。如果`timer.elapsed()`大于或等于`soundEvent->timestamp`，则使用`soundId`发出`playSound()`信号。
- en: This is only a request to play a sound. The `PlaybackWorker` class limits itself
    to read through `soundEvents` and trigger a `playSound()` at the proper moment.
    The real sound will be handled later on, with the `SoundEffectWidget` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个播放声音的请求。`PlaybackWorker`类仅限于读取`soundEvents`并在适当的时候触发`playSound()`。真正的声音将在稍后由`SoundEffectWidget`类处理。
- en: At each iteration in the `while` loop, a `QThread::msleep(1)` is done to avoid
    a busy loop. We minimize the sleep because we want the playback to be as faithful
    as possible to the original score. The longer the sleep, the more discrepancy
    we may encounter in the playback timing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的每次迭代中，都会执行`QThread::msleep(1)`以避免忙等待。我们尽量减少睡眠时间，因为我们希望回放尽可能忠实于原始乐谱。睡眠时间越长，回放时可能遇到的时差就越大。
- en: Finally, if the whole `soundEvents` has been processed, the `trackFinished`
    signal is emitted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果整个`soundEvents`已经被处理，将发出`trackFinished`信号。
- en: Making your objects serializable with QVariant
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QVariant使你的对象可序列化
- en: Now that we implemented the logic in our business classes, we have to think
    about what we are going to serialize and how we are going to do it. The user interacts
    with a `Track` class that contains all the data to be recorded and played back.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在业务类中实现了逻辑，我们必须考虑我们将要序列化什么以及我们将如何进行序列化。用户与包含所有要记录和回放数据的`Track`类进行交互。
- en: Starting from here, we can assume that the object to be serialized is `Track`,
    which in turn should somehow bring along its `mSoundEvents` containing a list
    of `SoundEvent` instances. To achieve this, we will rely heavily on the `QVariant`
    class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以假设要序列化的对象是`Track`，它应该以某种方式携带其包含`SoundEvent`实例列表的`mSoundEvents`。为了实现这一点，我们将大量依赖`QVariant`类。
- en: You might have worked with `QVariant` before. It is a generic placeholder for
    any primitive type (`char`, `int`, `double`, and so on) but also complex types
    (`QString`, `QDate`, `QPoint`, and many more).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经使用过`QVariant`。它是一个用于任何原始类型（`char`、`int`、`double`等）以及复杂类型（`QString`、`QDate`、`QPoint`等）的通用占位符。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete list of QVariant supported types is available at [http://doc.qt.io/qt-5/qmetatype.html#Type-enum](http://doc.qt.io/qt-5/qmetatype.html#Type-enum).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: QVariant支持的所有类型完整列表可在[http://doc.qt.io/qt-5/qmetatype.html#Type-enum](http://doc.qt.io/qt-5/qmetatype.html#Type-enum)找到。
- en: 'A simple example of `QVariant` is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant`的一个简单例子是：'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We store `21` in `variant`. From here, we can ask for `variant` to have a copy
    of the value casted to our desired type. Here we want an `int` value, so we call `variant.toInt()`.
    There are a lot of conversions already available with the `variant.toX()` syntax.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`variant`中存储`21`。从这里，我们可以要求`variant`拥有一个值副本，该值被转换为我们期望的类型。这里我们想要一个`int`值，所以我们调用`variant.toInt()`。`variant.toX()`语法已经提供了很多转换。
- en: We can take a very quick peek at what happens behind the curtain in `QVariant`.
    How does it store all we feed it? The answer lies in the C++ type `union`. The `QVariant`
    class is a kind of super `union`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速了解一下`QVariant`背后的情况。它是如何存储我们给它提供的内容的？答案在于C++类型的`union`。`QVariant`类是一种超级`union`。
- en: 'A `union` is a special class type that can hold only one of its non-static
    data members at a time. A short snippet should illustrate this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`是一种特殊类类型，一次只能持有其非静态数据成员中的一个。一个简短的代码片段可以说明这一点：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, a `union` class is declared like a `struct`. By default, all the members
    are `public`. The specificity of the `union` is that it takes only the largest
    member size in memory. Here, `Sound` will take only as much as the `int duration`
    space in memory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个类似于`struct`的`union`类。默认情况下，所有成员都是`public`的。`union`的特殊之处在于它在内存中只占用最大成员的大小。在这里，`Sound`将只占用内存中`int
    duration`空间的大小。
- en: Because `union` takes only this specific space, every member variable shares
    the same memory space. Therefore, only one member is available at a time, unless
    you want to have undefined behaviors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`union`只占用这个特定的空间，每个成员变量共享相同的内存空间。因此，一次只有一个成员是可用的，除非你想要有未定义的行为。
- en: When using the `Sound` snippet, we start by initializing with the value `10`
    (by default the first member is initialized). From here, `s.duration` is accessible
    but `s.code` is considered undefined.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Sound`片段时，我们首先使用默认值`10`（默认情况下第一个成员被初始化）进行初始化。从这里，`s.duration`是可访问的，但`s.code`被认为是未定义的。
- en: Once we assign a value to `s.code`, `s.duration` becomes undefined and `s.code`
    is now accessible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们给`s.code`赋值，`s.duration`就变为未定义，而`s.code`现在是可访问的。
- en: 'The `union` class makes the memory usage very efficient. In `QVariant`, when
    you store a value, it is stored in a private `union`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`类使得内存使用非常高效。在`QVariant`中，当你存储一个值时，它被存储在一个私有的`union`中：'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the list of primitive types and at the end the complex types, `QObject*`
    and `void*`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意基本类型列表，最后是复杂类型`QObject*`和`void*`。
- en: Besides `Data`, a `QMetaType` object is initialized to know the type of the
    stored object. The combination of `union` and `QMetaType` lets `QVariant` know
    which `Data` member it should use to cast the value and give it back to the caller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Data`，一个`QMetaType`对象被初始化以了解存储对象的类型。`union`和`QMetaType`的结合让`QVariant`知道应该使用哪个`Data`成员来转换值并将其返回给调用者。
- en: 'Now that you know what a `union` is and how `QVariant` uses it, you might ask:
    why make a `QVariant` class at all? A simple `union` would not have been enough?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`union`是什么以及`QVariant`如何使用它，你可能会问：为什么还要创建一个`QVariant`类呢？一个简单的`union`不是足够了吗？
- en: The answer is no. It is not enough because a `union` class cannot have members
    that do not have a default constructor. It drastically reduces the number of classes
    you can put in a `union`. Qt folks wanted to include many classes that did not
    have a default constructor in `union`. To mitigate this, `QVariant` was born.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。这还不够，因为`union`类不能有没有默认构造函数的成员。这极大地减少了你可以放入`union`中的类的数量。Qt开发者想要在`union`中包含许多没有默认构造函数的类。为了减轻这个问题，`QVariant`应运而生。
- en: 'What makes `QVariant` very interesting is that it is possible to store custom
    types. If we wanted to convert `SoundEvent` class to a `QVariant` class, we would
    have added the following in `SoundEvent.h`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant`非常有趣的地方在于它可以存储自定义类型。如果我们想将`SoundEvent`类转换为`QVariant`类，我们会在`SoundEvent.h`中添加以下内容：'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We already used `Q_DECLARE_METATYPE` macro in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This macro effectively registers `SoundEvent` to the `QMetaType` register,
    making it available for `QVariant`. Because `QDataStream` relies on `QVariant`,
    we had to use this macro in the last chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第10章](part0097.xhtml#aid-2SG6I2 "第10章。需要IPC？让你的仆从去工作")中使用了`Q_DECLARE_METATYPE`宏，*需要IPC？让你的仆从去工作*。这个宏有效地将`SoundEvent`注册到`QMetaType`注册表中，使其对`QVariant`可用。因为`QDataStream`依赖于`QVariant`，所以我们不得不在上一个章节中使用这个宏。
- en: 'Now to convert back and forth with a `QVariant`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要使用`QVariant`进行转换：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can guess, the output of this snippet is `4365`, the original `timestamp`
    stored in `soundEvent`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这个片段的输出是`4365`，这是存储在`soundEvent`中的原始`timestamp`。
- en: 'This approach would have been perfect if we wanted to do only binary serialization.
    Data can be easily written and read from. However, we want to output our `Track`
    and `SoundEvents` to standard formats: JSON and XML.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想进行二进制序列化，这种方法将完美无缺。数据可以轻松地写入和读取。然而，我们希望将`Track`和`SoundEvents`输出到标准格式：JSON和XML。
- en: 'There is a major issue with the `Q_DECLARE_METATYPE`/`QVariant` combo: it does
    not store any key for the fields of the serialized class. We can already foresee
    that the JSON object of a `SoundEvent` class will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_DECLARE_METATYPE`/`QVariant`组合有一个主要问题：它不存储序列化类字段的任何键。我们可以预见，`SoundEvent`类的JSON对象将看起来像这样：'
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is no way the `QVariant` class could know that we want a `timestamp` key.
    It will only store the raw binary data. The same principle applies for the XML
    counterpart.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant`类不可能知道我们想要一个`timestamp`键。它只会存储原始的二进制数据。同样的原则也适用于XML对应物。'
- en: For this reason, we are going to use a variation of a `QVariant` with a `QVariantMap`.
    The `QVariantMap` class is only a `typedef` on `QMap<QString, QVariant>`. This
    map will be used to store the key names of the fields and the value in the `QVariant`
    class. In turn, these keys will be used by the JSON and XML serialization system
    to output a pretty file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们将使用`QVariant`的一个变体，配合`QVariantMap`。`QVariantMap`类仅仅是`QMap<QString,
    QVariant>`的一个`typedef`。这个映射将用于存储字段的键名和`QVariant`类中的值。反过来，这些键将由JSON和XML序列化系统使用，以输出格式化的文件。
- en: Because we aim to have a flexible serialization system, we have to be able to
    serialize and deserialize this `QVariantMap` in multiple formats. To achieve this,
    we will define an interface that gives the ability for a class to serialize/deserialize
    its content in a `QVariantMap`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们旨在拥有一个灵活的序列化系统，我们必须能够以多种格式序列化和反序列化这个`QVariantMap`。为了实现这一点，我们将定义一个接口，它赋予一个类在`QVariantMap`中序列化/反序列化其内容的能力。
- en: This `QVariantMap` will be used as an intermediate format, agnostic of the final
    JSON, XML, or binary.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`QVariantMap`将被用作一个中间格式，与最终的JSON、XML或二进制格式无关。
- en: 'Create a C++ header named `Serializer.h`. Here is the content:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Serializer.h`的C++头文件。以下是内容：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By implementing this abstract base class, a class will be `Serializable`. There
    are only two virtual pure functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个抽象基类，一个类将变为`Serializable`。这里只有两个虚拟纯函数：
- en: The `toVariant()` function, in which the class must return a `QVariant` (or,
    more precisely a `QVariantMap`, which can be casted to a `QVariant` thanks to
    the `QMetaType` system)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toVariant()`函数，其中类必须返回一个`QVariant`（或者更精确地说是一个`QVariantMap`，它可以因为`QMetaType`系统而转换为`QVariant`）'
- en: The `fromVariant()` function, in which the class must initialize its members
    from the variant passed as a parameter
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromVariant()`函数，其中类必须从作为参数传递的变体中初始化其成员'
- en: By doing so, we give the responsibility to the final class to load and save
    its content. After all, who knows better `SoundEvent` than `SoundEvent` itself?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将加载和保存其内容的责任交给最终类。毕竟，谁比`SoundEvent`本身更了解`SoundEvent`呢？
- en: 'Let''s see `Serializable` in action with `SoundEvent`. Update `SoundEvent.h`
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Serializable`在`SoundEvent`上的实际应用。像这样更新`SoundEvent.h`：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `SoundEvent` class is now `Serializable`. Let''s do the real work in `SoundEvent.cpp`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEvent`类现在是`Serializable`。让我们在`SoundEvent.cpp`中做实际的工作：'
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In `toVariant()`, we simply declare a `QVariantMap` that gets filled with `timestamp`
    and `soundId`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toVariant()`中，我们简单地声明一个`QVariantMap`，并用`timestamp`和`soundId`填充它。
- en: On the other side, in `fromVariant()`, we convert `variant` to a `QVariantMap`
    and retrieve its content with the same keys we used in `toVariant()`. It is as
    simple as that!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，在`fromVariant()`中，我们将`variant`转换为`QVariantMap`，并使用与`toVariant()`中相同的键检索其内容。就这么简单！
- en: 'The next class that have to be `Serializable` is `Track`. After making `Track`
    inherit from `Serializable`, update `Track.cpp`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要实现序列化（`Serializable`）的类是`Track`。在使`Track`继承自`Serializable`之后，更新`Track.cpp`：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The principle is the same, although a bit more complex. The `mDuration` variable
    is stored in `map` object as we have seen for `SoundEvent`. For `mSoundEvents`,
    we have to generate a list of `QVariant` (a `QVariantList`) where each item is
    the converted `QVariant` version of a `soundEvent` key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 原则相同，尽管稍微复杂一些。`mDuration`变量以我们在`SoundEvent`中看到的方式存储在`map`对象中。对于`mSoundEvents`，我们必须生成一个`QVariant`（一个`QVariantList`）列表，其中每个项都是`soundEvent`键转换后的`QVariant`版本。
- en: To do so, we simply loop over `mSoundEvents` and fill `list` with the `soundEvent->toVariant()`
    result we covered a few paragraphs before.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需遍历`mSoundEvents`，并用之前提到的`soundEvent->toVariant()`结果填充`list`。
- en: 'Now for `fromVariant()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`fromVariant()`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, for each element of the key `soundEvents`, we create a new `SoundEvent`,
    load it with the content of `data`, and finally add it to the vector `mSoundEvents`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于`soundEvents`键的每个元素，我们创建一个新的`SoundEvent`，用`data`的内容加载它，并将其最终添加到`mSoundEvents`向量中。
- en: Serializing objects in JSON format
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以JSON格式序列化对象
- en: 'The `Track` and `SoundEvent` classes can now be converted to a common Qt format `QVariant`.
    We now need to write a `Track` (and its `SoundEvent` objects) class in a file
    with a text or a binary format. This example project allows you to handle all
    the formats. It will allow you to switch the saved file format in one line. So
    where to put the specific format code? That is the million dollar question! Here
    is a primary approach:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track`和`SoundEvent`类现在可以被转换成通用的Qt格式`QVariant`。我们现在需要将`Track`（及其`SoundEvent`对象）类写入一个文本或二进制格式的文件中。这个示例项目允许你处理所有格式。它将允许你在一行中切换保存的文件格式。那么具体格式代码应该放在哪里呢？这是一个价值百万的问题！这里有一个主要的方法：'
- en: '![Serializing objects in JSON format](img/image00442.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![以JSON格式序列化对象](img/image00442.jpeg)'
- en: 'In this proposition, the specific file format serialization code is inside
    a dedicated child class. Well, it works but what would the hierarchy look like
    if we add two new file formats? Moreover, each time we add a new object to serialize,
    we have to create all these children classes to handle the different serialization
    file formats. This massive inheritance tree can quickly become a sticky mess.
    The code will be unmaintainable. You do not want to do that. So, here is where
    the bridge pattern can be a good solution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提议中，特定的文件格式序列化代码位于一个专门的子类中。好吧，它工作得很好，但如果我们添加两种新的文件格式，层次结构会是什么样子？此外，每次我们添加一个要序列化的新对象时，我们必须创建所有这些子类来处理不同的序列化文件格式。这个庞大的继承树很快就会变得混乱不堪。代码将变得难以维护。你不想这样做。所以，这就是桥接模式可以成为一个好解决方案的地方：
- en: '![Serializing objects in JSON format](img/image00443.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![以JSON格式序列化对象](img/image00443.jpeg)'
- en: 'In a bridge pattern, we decouple the classes in two inheritance hierarchies:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在桥接模式中，我们解耦了两个继承层次结构中的类：
- en: The components independent from the file format. The `SoundEvent` and `Track`
    objects do not care about JSON, XML, or a binary format.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件格式无关的组件。`SoundEvent`和`Track`对象不关心JSON、XML或二进制格式。
- en: The file format implementations. The `JsonSerializer`, `XmlSerializer` and `BinarySerializer`
    handle a generic format, `Serializable`, not a specific component such as `SoundEvent`
    or `Track`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件格式实现。`JsonSerializer`、`XmlSerializer`和`BinarySerializer`处理一个通用格式`Serializable`，而不是特定的组件，如`SoundEvent`或`Track`。
- en: Notice that in a classic bridge pattern, an abstraction (`Serializable`) should
    contains an implementor (`Serializer`) variable. The caller only deals with the
    abstraction. However in this project example, `MainWindow` has the ownership of `Serializable`
    and also of `Serializer`. This is a personal choice to use the power of design
    pattern while keeping uncoupled functional classes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在经典的桥接模式中，一个抽象（`Serializable`）应该包含一个实现者（`Serializer`）变量。调用者只处理抽象。然而，在这个项目示例中，`MainWindow`拥有`Serializable`和`Serializer`的所有权。这是在保持功能类解耦的同时使用设计模式力量的个人选择。
- en: 'The architecture of `Serializable` and `Serializer` is clear. The `Serializable` class
    is already implemented so you can now create a new C++ header file called `Serializer.h`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serializable`和`Serializer`的架构是清晰的。`Serializable`类已经实现，因此你现在可以创建一个新的C++头文件，名为`Serializer.h`：'
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Serializer` class is an interface, an abstract class with only pure virtual
    functions and no data. Let''s talk about the `save()` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serializer`类是一个接口，一个只包含纯虚函数而没有数据的抽象类。让我们来谈谈`save()`函数：'
- en: This function saves `Serializable` to a file on the hard disk drive.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数将`Serializable`保存到硬盘驱动器上的文件中。
- en: The `Serializable` class is `const` and cannot be modified by this function.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serializable`类是`const`的，不能被这个函数修改。'
- en: The `filepath` function indicates the destination file to create.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filepath`函数指示要创建的目标文件'
- en: Some `Serializer` implementations can use the `rootName` variable. For example,
    if we request to save a `Track` object, the `rootName` variable could be the string `track`.
    This is the label used to write the root element. The XML implementation requires
    this information.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些`Serializer`实现可以使用`rootName`变量。例如，如果我们请求保存一个`Track`对象，`rootName`变量可以是字符串`track`。这是用于写入根元素的标签。XML实现需要这个信息。
- en: 'The `load()` function is also easy to understand:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`函数也容易理解：'
- en: This function loads data from a file to fill a `Serializable` class
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数从文件中加载数据以填充`Serializable`类
- en: The `Serializable` class will be updated by this function
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数将更新`Serializable`类
- en: The `filepath` function indicates which file to read
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filepath`函数指示要读取的文件'
- en: 'The interface `Serializer` is ready and waits for some implementations! Let''s
    start with JSON. Create a C++ class, `JsonSerializer`. Here is the header for `JsonSerializer.h`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `Serializer` 已准备就绪，等待一些实现！让我们从 JSON 开始。创建一个 C++ 类，`JsonSerializer`。以下是 `JsonSerializer.h`
    的头文件：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'No difficulties here; we have to provide an implementation of `save()` and `load()`.
    Here is the `save()` implementation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有困难；我们必须提供 `save()` 和 `load()` 的实现。以下是 `save()` 的实现：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Qt framework provides a nice way to read and write a JSON file with the
    `QJsonDocument` class. We can create a `QJsonDocument` class from a `QVariant`
    class. Notice that the `QVariant` accepted by `QJsonDocument` must be a `QVariantMap`, `QVariantList`,
    or `QStringList`. No worries, the `toVariant()` function of `Track` class and `SoundEvent`
    generates a `QVariantMap`. Then, we can create a `QFile` file with the destination `filepath`.
    The `QJsonDocument::toJson()` function converts it to a UTF-8 encoded text representation.
    We write this result to the `QFile` file and close the file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 框架提供了一个很好的方式来使用 `QJsonDocument` 类读取和写入 JSON 文件。我们可以从 `QVariant` 类创建一个 `QJsonDocument`
    类。请注意，`QJsonDocument` 接受的 `QVariant` 必须是 `QVariantMap`、`QVariantList` 或 `QStringList`。不用担心，`Track`
    类和 `SoundEvent` 的 `toVariant()` 函数会生成一个 `QVariantMap`。然后，我们可以使用目标 `filepath` 创建一个
    `QFile` 文件。`QJsonDocument::toJson()` 函数将其转换为 UTF-8 编码的文本表示。我们将此结果写入 `QFile` 文件并关闭文件。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `QJsonDocument::toJson()` function can produce an `Indented` or a `Compact`
    JSON format. By default, the format is `QJsonDocument::Indented`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJsonDocument::toJson()` 函数可以生成 `Indented` 或 `Compact` JSON 格式。默认情况下，格式是 `QJsonDocument::Indented`。'
- en: 'The `load()` implementation is also short:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 的实现也很简短：'
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We open a `QFile` with the source `filepath`. We read all the data with `QFile::readAll()`.
    Then we can create a `QJsonDocument` class with the `QJsonDocument::fromJson()`
    function. Finally, we can fill our destination `Serializable` with the `QJsonDocument`
    converted to a `QVariant` class. Notice that the `QJsonDocument::toVariant()`
    function can return `QVariantList` or a `QVariantMap` depending the nature of
    the JSON document.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用源 `filepath` 打开一个 `QFile`。使用 `QFile::readAll()` 读取所有数据。然后我们可以使用 `QJsonDocument::fromJson()`
    函数创建一个 `QJsonDocument` 类。最后，我们可以用转换为 `QVariant` 类的 `QJsonDocument` 填充我们的目标 `Serializable`。请注意，`QJsonDocument::toVariant()`
    函数可以返回 `QVariantList` 或 `QVariantMap`，具体取决于 JSON 文档的性质。
- en: 'Here is an example of a `Track` class saved with this `JsonSerializer`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这个 `JsonSerializer` 保存的 `Track` 类的示例：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The root element is a JSON object, represented by a map with two keys:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素是一个 JSON 对象，由包含两个键的映射表示：
- en: '`Duration`: This is a simple integer value'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`: 这是一个简单的整数值'
- en: '`soundEvents`: This is an array of objects. Each object is a map with the following
    keys:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soundEvents`: 这是一个对象的数组。每个对象是一个包含以下键的映射：'
- en: '`soundId`: This is an integer'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soundId`: 这是一个整数'
- en: '`timestamp`: This is also an integer'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`: 这也是一个整数值'
- en: Serializing objects in XML format
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 XML 格式序列化对象
- en: "The JSON serialization was a direct representation of the C++ objects and Qt\
    \ already provides all we need. However, the serialization of a C++ object can\
    \ be done with various representations in an XML format. So we have to write the\
    \ XML â\x86” `QVariant` conversion ourselves. We have decided to use the following\
    \ XML representation:"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 序列化是 C++ 对象的直接表示，Qt 已经提供了我们所需的一切。然而，C++ 对象的序列化可以用各种表示形式在 XML 格式中完成。因此，我们必须自己编写
    XML 到 `QVariant` 的转换。我们决定使用以下 XML 表示形式：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, the `soundId` type gives this XML representation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`soundId` 类型给出以下 XML 表示形式：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a C++ class `XmlSerializer` that also inherits from `Serializer`. Let''s
    begin with the `save()` function, here is `XmlSerializer.h`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个继承自 `Serializer` 的 C++ 类 `XmlSerializer`。让我们从 `save()` 函数开始，以下是 `XmlSerializer.h`：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can see the `save()` implementation in `XmlSerializer.cpp`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到 `XmlSerializer.cpp` 中的 `save()` 实现：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We create a `QFile` file with the `filepath` destination. We construct a `QXmlStreamWriter`
    object that writes in the `QFile`. By default, the writer will produce a compact
    XML; you can generate a pretty XML with the `QXmlStreamWriter::setAutoFormatting()`
    function. The `QXmlStreamWriter::writeStartDocument()` function writes the XML
    version and the encoding. We write our `QVariant` in the XML stream with our `writeVariantToStream()`
    function. Finally, we end the document and close the `QFile`. As already explained,
    writing a `QVariant` to an XML stream depends on how you want to represent the
    data. So we have to write the conversion function. Please update your class with `writeVariantToStream()`
    like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `filepath` 目的地创建一个 `QFile` 文件。我们构造一个写入 `QFile` 的 `QXmlStreamWriter` 对象。默认情况下，写入器将生成紧凑的
    XML；你可以使用 `QXmlStreamWriter::setAutoFormatting()` 函数生成格式化的 XML。`QXmlStreamWriter::writeStartDocument()`
    函数写入 XML 版本和编码。我们使用 `writeVariantToStream()` 函数将我们的 `QVariant` 写入 XML 流中。最后，我们结束文档并关闭
    `QFile`。如前所述，将 `QVariant` 写入 XML 流取决于你如何表示数据。因此，我们必须编写转换函数。请更新你的类，添加如下 `writeVariantToStream()`：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This `writeVariantToStream()` function is a generic entry point. It will be
    called each time we want to put a `QVariant` in the XML stream. The `QVariant`
    class could be a list, a map, or data. So we apply a specific treatment if the `QVariant`
    is a container (`QVariantList` or `QVariantMap`). All the other cases are considered
    to be a data value. Here are the steps of this function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `writeVariantToStream()` 函数是一个通用入口点。每次我们想要将一个 `QVariant` 放入 XML 流时，它都会被调用。`QVariant`
    类可以是列表、映射或数据。因此，如果 `QVariant` 是一个容器（`QVariantList` 或 `QVariantMap`），我们将应用特定的处理。所有其他情况都被视为数据值。以下是此函数的步骤：
- en: Start a new XML element with the `writeStartElement()` function. The `nodeName`
    will be used to create the XML tag. For example, `<soundId`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `writeStartElement()` 函数开始一个新的 XML 元素。`nodeName` 将用于创建 XML 标签。例如，`<soundId>`。
- en: Write an XML attribute called `type` in the current element. We use the name
    of the type stored in the `QVariant`. For example, `<soundId type="int"`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前元素中写入一个名为 `type` 的 XML 属性。我们使用存储在 `QVariant` 中的类型名称。例如，`<soundId type="int"
    />`。
- en: Depending on the `QVariant` data type, we call one of our XML serialization
    functions. For example, `<soundId type="int">2`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据数据类型 `QVariant`，我们调用我们的一个 XML 序列化函数。例如，`<soundId type="int">2`。
- en: 'Finally, we end the current XML element with `writeEndElement()`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `writeEndElement()` 结束当前 XML 元素：
- en: The final result is: `<soundId type="int">2</soundId>`
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终结果是：`<soundId type="int">2</soundId>`
- en: 'In this function, we call three helper functions that we will create now. The
    easiest one is `writeVariantValueToStream()`. Please update your `XmlSerializer`
    class with:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们调用我们现在将创建的三个辅助函数。其中最容易的是 `writeVariantValueToStream()`。请更新你的 `XmlSerializer`
    类：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the `QVariant` is a simple type, we retrieve its `QString` representation.
    Then we use `QXmlStreamWriter::writeCharacters()` to write this `QString` in the
    XML stream.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `QVariant` 是一个简单类型，我们检索它的 `QString` 表示形式。然后我们使用 `QXmlStreamWriter::writeCharacters()`
    将这个 `QString` 写入 XML 流中。
- en: 'The second helper function is `writeVariantListToStream()`. Here is its implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助函数是 `writeVariantListToStream()`。以下是它的实现：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: At this step, we already know that the `QVariant` is a `QVariantList`. We call `QVariant::toList()`
    to retrieve the list. Then we iterate over all elements of the list and call our
    generic entry point, `writeVariantToStream()`. Notice that we retrieve the elements
    from a list so we do not have an element name. But the tag name does not matter
    for a list item serialization, so insert the arbitrary label `item`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们已经知道 `QVariant` 是一个 `QVariantList`。我们调用 `QVariant::toList()` 来检索列表。然后我们遍历列表的所有元素并调用我们的通用入口点，`writeVariantToStream()`。请注意，我们从列表中检索元素，因此我们没有元素名称。但是，对于列表项的序列化，标签名称并不重要，所以插入任意标签
    `item`。
- en: 'The last write helper function is `writeVariantMapToStream()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个写入辅助函数是 `writeVariantMapToStream()`：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `QVariant` is a container but a `QVariantMap` this time. We call `writeVariantToStream()`
    for each element found. The tag name is important because this is a map. We use
    the map key from `QMapIterator::key()` as the node name.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant` 是一个容器，但这次是 `QVariantMap`。我们对每个找到的元素调用 `writeVariantToStream()`。标签名称对于映射很重要。我们使用
    `QMapIterator::key()` 作为节点名称。'
- en: 'The saving part is over. We can now implement the loading part. Its architecture
    follows the same spirit as the saving functions. Let''s begin with the `load()`
    function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 保存部分已经完成。现在我们可以实现加载部分。它的架构与保存函数遵循相同的理念。让我们从 `load()` 函数开始：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first thing to do is to create a `QFile` with the source `filepath`. We
    construct a `QXmlStreamReader` with the `QFile`. The `QXmlStreamReader ::readNextStartElement()`
    function reads until the next start element in the XML stream. Then we can use
    our read helper function, `readVariantFromStream()`, to create a `QVariant` class
    from an XML stream. Finally, we can use our `Serializable::fromVariant()` to fill
    the destination `serializable`. Let''s implement the helper function, `readVariantFromStream()`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个包含源 `filepath` 的 `QFile`。我们使用 `QFile` 构造一个 `QXmlStreamReader`。`QXmlStreamReader
    ::readNextStartElement()` 函数读取直到 XML 流中的下一个起始元素。然后我们可以使用我们的读取辅助函数 `readVariantFromStream()`
    从 XML 流中创建一个 `QVariant` 类。最后，我们可以使用我们的 `Serializable::fromVariant()` 来填充目标 `serializable`。让我们实现辅助函数
    `readVariantFromStream()`：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The role of this function is to create a `QVariant`. Firstly, we retrieve the `"type"`
    from the XML attributes. In our case, we have only one attribute to handle. Then,
    depending on the type, we will call one of our three read helper functions. Let''s
    implement the `readVariantValueFromStream()` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用是创建一个 `QVariant`。首先，我们从 XML 属性中检索 `"type"`。在我们的例子中，我们只有一个属性需要处理。然后，根据类型，我们将调用我们三个读取辅助函数中的一个。让我们实现
    `readVariantValueFromStream()` 函数：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function create a `QVariant` with its data depending on the type. Like
    the previous function, we retrieve the type from the XML attribute. We also read
    the data as a text with the `QXmlStreamReader::readElementText()` function. A `QVariant`
    class is created with this `QString` data. At this step, the `QVariant` type is
    a `QString`. So we use the `QVariant::convert()` function to convert the `QVariant`
    to the real type (`int` , `qlonglong`, and so on).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建一个根据类型数据而定的 `QVariant`。和之前的函数一样，我们从 XML 属性中检索类型。我们同样使用 `QXmlStreamReader::readElementText()`
    函数读取文本数据。使用这个 `QString` 数据创建一个 `QVariant` 类。在这个步骤中，`QVariant` 类型是 `QString`。因此，我们使用
    `QVariant::convert()` 函数将 `QVariant` 转换为实际类型（`int`、`qlonglong` 等）。
- en: 'The second read helper function is `readVariantListFromStream()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个读取辅助函数是 `readVariantListFromStream()`：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We know that the stream element contains an array. So, this function creates
    and returns a `QVariantList`. The `QXmlStreamReader::readNextStartElement()` function
    reads until the next start element and returns `true` if a start element is found
    within the current element. We call the entry-point function, `readVariantFromStream()`,
    for each element. Finally, we return the `QVariantList`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道流元素包含一个数组。因此，这个函数创建并返回一个 `QVariantList`。`QXmlStreamReader::readNextStartElement()`
    函数读取直到下一个起始元素，如果当前元素内找到起始元素则返回 `true`。我们为每个元素调用入口点函数 `readVariantFromStream()`。最后，我们返回
    `QVariantList`。
- en: 'The last helper function to cover is `readVariantMapFromStream()`. Update your
    file with the following snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要覆盖的辅助函数是 `readVariantMapFromStream()`。更新你的文件，使用以下片段：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function sounds like the `readVariantListFromStream()`. This time we have
    to create a `QVariantMap`. The key used for inserting a new item is the element
    name. We retrieve the name with the `QXmlStreamReader::name()` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数听起来像 `readVariantListFromStream()`。这次我们必须创建一个 `QVariantMap`。用于插入新项的键是元素名称。我们使用
    `QXmlStreamReader::name()` 函数检索名称。
- en: 'A `Track` class serialized with the `XmlSerializer` looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `XmlSerializer` 序列化的 `Track` 类看起来像这样：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Serializing objects in binary format
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以二进制格式序列化对象
- en: The XML serialization is fully functional! We can now switch to the last type
    of serialization covered in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: XML 序列化已经完全可用！我们现在可以切换到本章中介绍的序列化的最后一种类型。
- en: 'The binary serialization is easier because Qt provides a direct way to do it.
    Please create a `BinarySerializer` class that inherits from `Serializer`. The
    header is common, we have only the override functions, `save()` and `load()`.
    Here is the implementation of the `save()` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制序列化比较简单，因为 Qt 提供了一个直接的方法来做这件事。请创建一个继承自 `Serializer` 的 `BinarySerializer`
    类。头文件是通用的，我们只有重写的函数，`save()` 和 `load()`。以下是 `save()` 函数的实现：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We hope you recognized the `QDataStream` class used in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This time we use this class to serialize binary data in a destination `QFile`.
    A `QDataStream` class accepts a `QVariant` class with the `<<` operator. Notice
    that the `rootName` variable is not used in the binary serializer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能认出在 [第 10 章](part0097.xhtml#aid-2SG6I2 "第 10 章。需要 IPC？让你的小弟去工作") 中使用的
    `QDataStream` 类，*需要 IPC？让你的小弟去工作*。这次我们使用这个类在目标 `QFile` 中序列化二进制数据。`QDataStream`
    类接受一个带有 `<<` 操作符的 `QVariant` 类。请注意，`rootName` 变量在二进制序列化器中没有被使用。
- en: 'Here is the `load()` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `load()` 函数：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Thanks to the `QVariant` and the `QDataStream` mechanism, the task is easy.
    We open the `QFile` with the source `filepath`. We construct a `QDatastream` class
    with this `QFile`. Then, we use the `>>` operator to read the root `QVariant`.
    Finally, we fill the source `Serializable` with our `Serializable::fromVariant()`
    function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `QVariant` 和 `QDataStream` 机制，任务变得简单。我们使用源 `filepath` 打开 `QFile`。然后，我们使用这个
    `QFile` 构造一个 `QDataStream` 类。然后，我们使用 `>>` 操作符读取根 `QVariant`。最后，我们使用 `Serializable::fromVariant()`
    函数填充源 `Serializable`。
- en: Do not worry, we will not include an example of a `Track` class serialized with
    the `BinarySerializer` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，我们不会包含使用 `BinarySerializer` 类序列化的 `Track` 类的示例。
- en: The serialization part is completed. The GUI part of this example project has
    been covered many times during the previous chapters of this book. The following
    sections will only cover specific features used in our `MainWindow` and `SoundEffectWidget`
    classes. Check the source code if you need the complete C++ classes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化部分已完成。本例项目的 GUI 部分在本书的前几章中已经多次介绍。以下章节将仅涵盖在 `MainWindow` 和 `SoundEffectWidget`
    类中使用的特定功能。如果需要完整的 C++ 类，请检查源代码。
- en: Playing low latency sounds with QSoundEffect
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QSoundEffect 播放低延迟声音
- en: The project application `ch11-drum-machine` displays four `SoundEffectWidget`
    widgets: `kickWidget`, `snareWidget`, `hihatWidget`, and `crashWidget`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 项目应用程序 `ch11-drum-machine` 显示了四个 `SoundEffectWidget` 小部件：`kickWidget`、`snareWidget`、`hihatWidget`
    和 `crashWidget`。
- en: Each `SoundEffectWidget` widget displays a `QLabel` and a `QPushButton`. The
    label displays the sound name. If the button is clicked, a sound is played.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `SoundEffectWidget` 小部件显示一个 `QLabel` 和一个 `QPushButton`。标签显示声音名称。如果按钮被点击，就会播放声音。
- en: 'The Qt Multimedia module provides two main ways to play an audio file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 多媒体模块提供了两种主要方式来播放音频文件：
- en: '`QMediaPlayer`: This file can play songs, movies, and Internet radio with various
    input formats'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMediaPlayer`：这个文件可以播放歌曲、电影和互联网广播，支持各种输入格式'
- en: '`QSoundEffect`: This file can play low-latency `.wav` files'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSoundEffect`：这个文件可以播放低延迟的 `.wav` 文件'
- en: 'This project example is a virtual drum machine, so we are using a `QSoundEffect`
    object. The first step to use a `QSoundEffect` is to update your `.pro` file like
    this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目示例是一个虚拟鼓机，所以我们使用了一个 `QSoundEffect` 对象。使用 `QSoundEffect` 的第一步是更新你的 `.pro`
    文件，如下所示：
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you can initialize the sound. Here is an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以初始化声音。以下是一个示例：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first step is to create a valid `QUrl` for your sound file. The `urlKick`
    is initialized from a `.qrc` resources file path, while `urlBetterKick` is created
    from a local file path. Then we can create `QSoundEffect` and set the URL sound
    to play with the `QSoundEffect::setSource()` function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为你的声音文件创建一个有效的 `QUrl`。`urlKick` 从 `.qrc` 资源文件路径初始化，而 `urlBetterKick` 是从本地文件路径创建的。然后我们可以创建
    `QSoundEffect` 并使用 `QSoundEffect::setSource()` 函数设置要播放的 URL 声音。
- en: 'Now that we have a `QSoundEffect` object initialized, we can play the sound
    with the following code snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了一个 `QSoundEffect` 对象，我们可以使用以下代码片段来播放声音：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Triggering a QButton with your keyboard
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘触发 QButton
- en: 'Let''s explore the public slot, `triggerPlayButton()`, in the `SoundEffectWidget`
    class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索 `SoundEffectWidget` 类中的公共槽，`triggerPlayButton()`：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This widget has a `QPushButton` called `mPlayButton`. The `triggerPlayButton()`
    slot calls the `QPushButton::animateClick()` function, which simulates a click
    on the button over 100 ms by default. All signals will be sent as a real click
    does. The button really appears to be down. If you do not want the animation you
    can call `QPushButton::click()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小部件有一个名为 `mPlayButton` 的 `QPushButton`。`triggerPlayButton()` 槽调用 `QPushButton::animateClick()`
    函数，默认情况下通过 100 毫秒模拟按钮点击。所有信号都将像真实点击一样发送。按钮看起来确实被按下了。如果你不想有动画，可以调用 `QPushButton::click()`。
- en: 'Let''s see now how to trigger this slot with a key. Each `SoundEffectWidget`
    has a `Qt:Key`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用键盘触发这个槽。每个 `SoundEffectWidget` 都有一个 `Qt:Key`：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `SoundEffectWidget` class provides a getter and a setter to get and set
    the member variable, `mTriggerKey`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEffectWidget` 类提供了一个获取器和设置器来获取和设置成员变量 `mTriggerKey`。'
- en: 'The `MainWindow` class initializes the keys of its four `SoundEffectWidget`
    like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow` 类初始化其四个 `SoundEffectWidget` 的键如下：'
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'By default, the `QObject::eventFilter()` function is not called. To enable
    it and intercept these events, we need to install an event filter on the `MainWindow`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`QObject::eventFilter()` 函数不会被调用。为了启用它并拦截这些事件，我们需要在 `MainWindow` 上安装一个事件过滤器：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So each time the `MainWindow` receives an event, the `MainWindow::eventFilter()`
    function is called.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次 `MainWindow` 接收到事件时，都会调用 `MainWindow::eventFilter()` 函数。
- en: 'Here is the `MainWindow.h` header:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `MainWindow.h` 头文件：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `MainWindow` class has a `QVector` with the four `SoundEffectWidgets` (`kickWidget`, `snareWidget`, `hihatWidget`,
    and `crashWidget`). Let''s see the implementation in `MainWindow.cpp`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow` 类有一个 `QVector`，包含四个 `SoundEffectWidgets` (`kickWidget`、`snareWidget`、`hihatWidget`
    和 `crashWidget`)。让我们看看 `MainWindow.cpp` 中的实现：'
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The first thing to do is to check that the `QEvent` class is a `KeyPress` type.
    We do not care about other event types. If the event type is correct, we proceed
    to the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是检查 `QEvent` 类是否为 `KeyPress` 类型。我们不关心其他事件类型。如果事件类型正确，我们继续下一步：
- en: Cast the `QEvent` class to `QKeyEvent`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `QEvent` 类转换为 `QKeyEvent`。
- en: Then we search if the pressed key belongs to the `SoundEffectWidget` class.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们搜索按下的键是否属于 `SoundEffectWidget` 类。
- en: If a `SoundEffectWidget` class corresponds to the key, we call our `SoundEffectWidget::triggerPlayButton()`
    function and we return `true` to indicate that we consumed the event and it must
    not be propagated to others classes.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `SoundEffectWidget` 类与键相对应，我们调用我们的 `SoundEffectWidget::triggerPlayButton()`
    函数，并返回 `true` 以指示我们已消费该事件，并且它不得传播到其他类。
- en: Otherwise, we call the `QObject` class implementation of `eventFilter()`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们调用 `QObject` 类的 `eventFilter()` 实现。
- en: Bringing PlaybackWorker to life
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 `PlaybackWorker` 生动起来
- en: 'The user can play a sound live with a mouse click or a keyboard key. But when
    he records an awesome beat, the application must be able to play it again with
    the `PlaybackWorker` class. Let''s see how `MainWindow` uses this worker. Here
    is the `MainWindow.h` related to the `PlaybackWorker` class:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过鼠标点击或键盘键实时播放声音。但是，当他录制一个令人惊叹的节奏时，应用程序必须能够使用 `PlaybackWorker` 类再次播放它。让我们看看
    `MainWindow` 如何使用这个工作器。以下是与 `PlaybackWorker` 类相关的 `MainWindow.h`：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, `MainWindow` has `PlaybackWorker` and a `QThread` member variables.
    Let''s see the implementation of `startPlayback()`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`MainWindow` 有 `PlaybackWorker` 和一个 `QThread` 成员变量。让我们看看 `startPlayback()`
    的实现：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s analyze all the steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析所有步骤：
- en: We clear the current playback with the `clearPlayback()` function, which will
    be covered soon.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `clearPlayback()` 函数清除当前播放，这个功能很快就会介绍。
- en: The new `QThread` and `PlaybackWorker` are constructed. The current track is
    given to the worker at this moment. As usual, the worker is then moved to its
    dedicated thread.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `QThread` 和 `PlaybackWorker` 被构造。此时，当前曲目被传递给工作器。像往常一样，工作器随后被移动到其专用线程。
- en: We want to play the track as soon as possible. So, when the `QThread` emits
    the `started()` signal, the `PlaybackWorker::play()` slot is called.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望尽快播放曲目。因此，当 `QThread` 发出 `started()` 信号时，会调用 `PlaybackWorker::play()` 插槽。
- en: We do not want to worry about the `PlaybackWorker` memory. So when the `QThread`
    is over and it has sent the `finished()` signal, we call the `QObject::deleteLater()`
    slot, which schedules the worker for deletion.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不想担心 `PlaybackWorker` 的内存。因此，当 `QThread` 结束并发送了 `finished()` 信号时，我们调用 `QObject::deleteLater()`
    插槽，该插槽安排工作器进行删除。
- en: When the `PlaybackWorker` class needs to play a sound, the `playSound()` signal
    is emitted and our `MainWindow:playSoundEffect()` slot is called.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `PlaybackWorker` 类需要播放声音时，会发出 `playSound()` 信号，并调用我们的 `MainWindow::playSoundEffect()`
    插槽。
- en: The last connect covers when the `PlaybackWorker` class finishes playing the
    whole track. A `trackFinished()` signal is emitted and we call the `Track::Stop()`
    slot.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个连接覆盖了当 `PlaybackWorker` 类播放完整个曲目时的情况。会发出一个 `trackFinished()` 信号，然后我们调用 `Track::Stop()`
    插槽。
- en: Finally, the thread is started with a high priority. Notice that some operating
    systems (for example, Linux) do not support thread priorities.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以高优先级启动线程。请注意，某些操作系统（例如 Linux）不支持线程优先级。
- en: 'We can now see the `stopPlayback()` body:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到 `stopPlayback()` 函数体：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We call the `stop()` function of the `PlaybackWorker` from our thread. Because
    we use a `QAtomicInteger` in `stop()`, the function is thread-safe and can be
    directly called. Finally, we call our helper function, `clearPlayback()`. This
    is the second time that we use `clearPlayback()`, so let''s implement it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的线程中调用 `PlaybackWorker` 的 `stop()` 函数。因为我们使用 `QAtomicInteger` 在 `stop()`
    中，所以该函数是线程安全的，可以直接调用。最后，我们调用我们的辅助函数 `clearPlayback()`。这是我们第二次使用 `clearPlayback()`，所以让我们来实现它：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: No surprises here. If the thread is valid, we ask the thread to exit and wait
    1 second. Then, we set the thread and the worker to `nullptr`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何惊喜。如果线程有效，我们要求线程退出并等待 1 秒。然后，我们将线程和工作者设置为 `nullptr`。
- en: 'The `PlaybackWorker::PlaySound` signal is connected to `MainWindow::playSoundEffect()`.
    Here is the implementation:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaybackWorker::PlaySound` 信号连接到 `MainWindow::playSoundEffect()`。以下是其实施：'
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This slot retrieves the `SoundEffectWidget` class corresponding to the `soundId`.
    Then, we call the `triggerPlayButton()`, the same method that is called when you
    press the trigger key on your keyboard.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此槽获取与 `soundId` 对应的 `SoundEffectWidget` 类。然后，我们调用 `triggerPlayButton()`，这是当你按下键盘上的触发键时调用的相同方法。
- en: 'So, when you click on the button, press a key, or when the `PlaybackWorker`
    class requests to play a sound, the `QPushButton` of `SoundEffectWidget` emits
    the signal, `clicked()`. This signal is connected to our `SoundEffectWidget::play()`
    slot. The next snippet describes this slot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你点击按钮、按下一个键，或者当 `PlaybackWorker` 类请求播放声音时，`SoundEffectWidget` 的 `QPushButton`
    会发出 `clicked()` 信号。这个信号连接到我们的 `SoundEffectWidget::play()` 槽。下一个片段描述了这个槽：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Nothing fancy here. We call the `play()` function on the `QSoundEffect` already
    covered. Finally, we emit the `soundPlayed()` signal that is used by `Track` to
    add a new `SoundEvent` if we are in the `RECORDING` state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处。我们在已经覆盖的 `QSoundEffect` 上调用 `play()` 函数。最后，如果我们处于 `RECORDING` 状态，我们发出
    `soundPlayed()` 信号，该信号由 `Track` 用于添加新的 `SoundEvent`。
- en: Accepting mouse drag and drop events
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受鼠标拖放事件
- en: 'In this project example, if you drag and drop a `.wav` file on a `SoundEffectWidget`,
    you can change the sound played. The constructor of `SoundEffectWidget` performs
    a specific task to allow drag and drop:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目示例中，如果你将 `.wav` 文件拖放到 `SoundEffectWidget` 上，你可以更改播放的声音。`SoundEffectWidget`
    的构造函数执行特定任务以允许拖放：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can now override the drag and drop callbacks. Let''s start with the `dragEnterEvent()`
    function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以覆盖拖放回调。让我们从 `dragEnterEvent()` 函数开始：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `dragEnterEvent()` function is called each time the user drags an object
    on the widget. In our case, we only want to allow drag and drop on files that
    are of the MIME type: `"text/uri-list"` (a list of URIs, which can be `file://`, `http://`,
    and so on). In this case, though we can call the `QDragEnterEvent::acceptProposedAction()`
    function to notify that we accept this object for a drag and drop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragEnterEvent()` 函数会在用户在部件上拖动对象时被调用。在我们的例子中，我们只想允许拖放那些 MIME 类型为 `"text/uri-list"`（URI
    列表，可以是 `file://`、`http://` 等等）的文件。在这种情况下，尽管我们可以调用 `QDragEnterEvent::acceptProposedAction()`
    函数来通知我们接受这个对象进行拖放。'
- en: 'We can now add a second function, `dropEvent()`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加第二个函数，`dropEvent()`：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first step is a sanity check. If the event does not have a URL, we do nothing.
    The `QMimeData::hasUrls()` function returns `true` only with the MIME type: `"text/uri-text"`.
    Notice that a user can drag and drop multiple files at once. In our case, we only
    handle the first URL. You can check that the file is a `.wav` file with its MIME
    type. If the MIME type is `"audio/wav"`, we call the `loadSound()` function, which
    updates the sound assigned to this `SoundEffectWidget`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是进行合理性检查。如果事件没有 URL，我们就不做任何事情。`QMimeData::hasUrls()` 函数仅在 MIME 类型为 `"text/uri-text"`
    时返回 `true`。注意，用户可以一次性拖放多个文件。在我们的例子中，我们只处理第一个 URL。你可以检查文件是否为 `.wav` 文件，通过其 MIME
    类型。如果 MIME 类型是 `"audio/wav"`，我们调用 `loadSound()` 函数，该函数更新分配给此 `SoundEffectWidget`
    的声音。
- en: 'The following screenshot show the complete application for `ch11-drum-machine`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `ch11-drum-machine` 的完整应用程序：
- en: '![Accepting mouse drag and drop events](img/image00444.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![接受鼠标拖放事件](img/image00444.jpeg)'
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Serialization is a good way to make your data persistent when you close your
    application. In this chapter, you learned to make your C++ objects serializable
    with `QVariant`. You created a flexible serialization structure with the Bridge
    pattern. You saved an object in a different text format such as JSON or XML and
    also in a binary format.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是在你关闭应用程序时使你的数据持久化的好方法。在本章中，你学习了如何使用 `QVariant` 使你的 C++ 对象可序列化。你使用桥接模式创建了一个灵活的序列化结构。你将对象保存为不同的文本格式，如
    JSON 或 XML，以及二进制格式。
- en: You also learned to use the Qt Multimedia module to play some sound effects.
    These sounds can be triggered by a mouse click or by a keyboard key. You implemented
    a friendly user interaction, allowing you to load a new sound with a file drag
    and drop.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了使用 Qt 多媒体模块来播放一些音效。这些声音可以通过鼠标点击或键盘按键触发。你实现了友好的用户交互，允许你通过文件拖放来加载新的声音。
- en: In the next chapter, we will discover the `QTest` framework and how you can
    organize your project so it has a clean application/test separation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现 `QTest` 框架以及如何组织你的项目，使其具有清晰的应用程序/测试分离。
