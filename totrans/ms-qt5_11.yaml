- en: Chapter 11.  Having Fun with Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter was a firework of threads, sockets, and workers. We hope
    that your minions have been working hard. In this chapter, we will turn our attention
    to the serialization with Qt. You will learn how to serialize data in multiple
    formats with a flexible system. The example project will be a virtual drum machine,
    in which you can compose you own drum beat, record it, play it, save it, and load
    it back. Your drum beat will be probably so awesome that you will want to share
    it: you will now be able to do it in various formats.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How to architecture an application that plays and records sounds
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QVariant` class and its inner mechanics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible serialization system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary serialization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt Multimedia framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag and drop handling with Qt
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering a button from your keyboard
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting the drum machine project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, before diving into the code, let''s study the structure of the project.
    The aim of the project is to be able to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Play and record a sound track from a drum machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save this track to a file and load it to play it back
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To play a sound, we will lay out four big buttons that will play a specific
    drum sound upon click (or a keyboard event): a kick, a snare, a hi-hat, and a
    cymbal crash. These sounds will be `.wav` files loaded by the application. The
    user will be able to record his sequence of sounds and replay it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For the serialization part, we do not only want to save the track to a single
    file format, we would rather do three:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only is it more fun to cover three formats, but it also gives us the opportunity
    to understand the advantages and limitations of each one, and how it fits within
    the Qt framework. The architecture we are going to implement will try to be flexible
    to handle future evolutions. You never know how a project can evolve!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes'' organization looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecting the drum machine project](img/image00441.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the role of these classes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The `SoundEvent` class is the basic building block of a track. It is a simple
    class containing `timestamp` (when the sound has been played) and `soundId` variables
    (what sound has been played).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Track` class contains a list of `SoundEvents`, a duration and a state (playing,
    recording, stopped). Each time the user plays a sound, a `SoundEvent` class is
    created and added to the `Track` class.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PlaybackWorker` class is a worker class that runs in a different thread.
    It is responsible of looping through the `Track` class's `soundEvents` and triggering
    the proper sound when its `timestamp` has been reached.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class is an interface that must be implemented by each class
    that wants to be serialized (in our case: `SoundEvent` and `Track`).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializer` class is an interface that must be implemented by each format-specific
    implementation class.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JsonSerializer`, `XmlSerializer`, and `BinarySerializer` are the sub-classes
    of `Serializer` class that do the format-specific job to serialize/deserialize
    a `Serializable` instance.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SoundEffectWidget` class is the widget that holds the information to play
    a single sound. It displays the button for one of our four sounds. It also owns
    a `QSoundEffect` class that sends the sound to the audio card.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MainWindow` class holds everything together. It owns the `Track` class,
    spawns the `PlaybackWorker` thread, and triggers the serialization/deserialization.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output format should be easily swapped. To achieve this, we will rely on
    a modified version of the bridge design pattern that will allow `Serializable`
    and `Serializer` classes to evolve independently.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The whole project revolves around this notion of independence between modules.
    It goes to the extent that a sound can be replaced on the spot during a playback.
    Let's say that you listen to your incredible beat, and you want to try another
    snare sound. You will be able to replace it with a simple drag and drop of a `.wav`
    file on the `SoundEffectWidget` class holding the snare sound.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Creating a drum track
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's buckle up and do this project! Create a new **Qt Widgets Application**
    project named `ch11-drum-machine`. As usual, add the `CONFIG += c++14` in `ch11-drum-machine.pro`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new C++ class named `SoundEvent`. Here is `SoundEvent.h` stripped
    from its functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class contains only two public members:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`: A `qint64` (`long long` type) that contains the current time of
    the `SoundEvent` in milliseconds since the beginning of the track'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundId`: The ID of the sound that has been played'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In recording mode, each time the user plays a sound, a `SoundEvent` is created
    with the appropriate data. The `SoundEvent.cpp` file is so boring that we will
    not inflict it on you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class to build is `Track`. Again, create the new C++ class. Let''s
    review `Track.h` with its members only:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now go into detail about them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`mDuration`: This variable holds the duration of the `Track` class. This member
    is reset to 0 when a recording is started and updated when the recording is stopped.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSoundEvents`: This variable is the list of `SoundEvents` for the given `Track`.
    As the `unique_ptr` semantic states it, `Track` is the owner of the sound events.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mTimer`: This variable is started each time `Track` is played or recorded.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mState`: This variable is the current `State` of `Track` class, which can
    have three possible values: `STOPPED`, `PLAYING`, `RECORDING`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mPreviousState`: This variable is the previous `State` of `Track`. This is
    useful when you want to know which action to do on a new `STOPPED``State`. We
    will have to stop the playback if `mPreviousState` is in the `PLAYING` state.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Track` class is the pivot of the business logic of the project. It holds `mState`,
    which is the state of the whole application. Its content will be read during a
    playback of your awesome musical performance and also be serialized to a file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enrich `Track.h` with functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will skip the simple getters and concentrate on the important functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`elapsedTime()`: This function returns the value of the `mTimer.elapsed()`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundEvents()`: This function is a little more complicated getter. The `Track`
    class is the owner of `mSoundEvents` content and we really want to enforce it.
    For this, the getter returns a `const &` to `mSoundEvents`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stateChanged()`: This function is emitted when the `mState` value is updated.
    The new `State` is passed as a parameter.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: This function is a slot that starts to play the `Track`. This play
    is purely logical, the real playback will be triggered by `PlaybackWorker`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`record()`: This function is a slot that starts the recording state of `Track`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This function is a slot that stops the current start or record state.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSoundEvent()`: This function creates a new `SoundEvent` with the given `soundId`
    and adds it to `mSoundEvents`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This function resets the content of `Track`: it clears `mSoundEvents`
    and sets `mDuration` to `0`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setState()`: This function is a private helper function that updates `mState`, `mPreviousState`
    and emits the `stateChanged()` signal.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the header has been covered, we can study the interesting parts of
    `Track.cpp`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calling `Track.play()` simply updates the state to `PLAYING` and starts `mTimer`.
    The `Track` class does not hold anything related to the Qt Multimedia API; it
    is limited to an evolved data holder (as it also manages a state).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `record()`, which brings a lot of surprises:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It starts by clearing the data, sets the state to `RECORDING`, and also starts `mTimer`.
    Now consider `stop()`, which is a slight variation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we are stopping in the `RECORDING` state, `mDuration` is updated. Nothing
    very fancy here. We saw three times the `setState()` call without seeing its body:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The current value of `mState` is stored in `mPreviousState` before being updated.
    Finally, `stateChanged()` is emitted with the new value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The state system of `Track` is completely covered. The last missing part is
    the `SoundEvents` interactions. We can start with the `addSoundEvent()` snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `soundEvent` is created only if we are in the `RECORDING` state. After that,
    a `SoundEvent` is added to `mSoundEvents` with the current elapsed time of `mTimer`
    and the passed `soundEventId`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `clear()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we use `unique_ptr<SoundEvent>` in `mSoundEvents`, the `mSoundEvents.clear()`
    function is enough to empty the vector and also delete each `SoundEvent`. This
    is one less thing you have to worry with smart pointers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `SoundEvent` and `Track` are the base classes that hold the information
    about your future beat. We are going to see the class responsible for reading
    this data to play it: `PlaybackWorker`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class and update `PlaybackWorker.h` like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `PlaybackWorker` class will be running in a different thread. If your memory
    needs to be refreshed, go back to [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*.
    Its role is to iterate through the `Track` class''s content to trigger the sounds.
    Let''s break down this header:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`mTrack`: This function is the reference to the `Track` class on which `PlaybackWorker`
    is working. It is passed in the constructor as a `const` reference. With this
    information, you already know that `PlaybackWorker` cannot modify `mTrack` in
    any way.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mIsPlaying`: This function is a flag used to be able to stop the worker from
    another thread. It is a `QAtomicInteger` to guarantee an atomic access to the
    variable.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playSound()`: This function is emitted by `PlaybackWorker` each time a sound
    needs to be played.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trackFinished()`: This function is emitted when the playback has been played
    until the end. If it has been stopped along the way, this signal will not be emitted.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: This function is the main function of `PlaybackWorker`. In it, `mTrack`
    content will be queried to trigger sounds.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This function is the function that updates the `mIsPlaying` flag
    and causes `play()` to exit its loop.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The meat of the class lies in the `play()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing that `play()` function does is to prepare its reading: `mIsPlaying`
    is set to `true`, a `QElapsedTimer` class is declared, and a `soundEventIndex`
    is initialized. Each time `timer.elapsed()` is called, we will know if a sound
    should be played.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To know which sound should be played, `soundEventIndex` will be used to know
    where we are in the `soundEvents` vector.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after that, the `timer` object is started and we enter in the `while`
    loop. This `while` loop has two conditions to continue:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`timer.elapsed() <= mTrack.duration()`: This condition states that we did not
    finish playing the track'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mIsPlaying.load()`: This condition returns **true**: nobody asked `PlaybackWorker`
    to stop'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, you might have added the `soundEventIndex < soundEvents.size()`
    condition in the `while` condition. By doing so, you would have exited `PlaybackWorker`
    as soon as the last sound has been played. Technically, it works, but that would
    not have respected what the user recorded.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Consider a user that created a complex beat (do not underestimate what you can
    do with four sounds!) and decided on a long pause of 5 seconds at the end of the
    song. When he clicks on the stop button, the time display indicates 00:55 (for
    55 seconds). However, when he plays back his performance, the last sound finishes
    at 00:50\. The playback stops at 00:50 and the program does not respect what he
    recorded.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the `soundEventIndex < size()` test is moved inside the `while`
    loop and is used only as a fuse for the `soundEvents` read through.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Inside this condition, we retrieve the reference to the current `soundEvent`.
    We then compare the elapsed time against the `timestamp` of the `soundEvent`.
    If `timer.elapsed()` is greater or equal to `soundEvent->timestamp`, the signal `playSound()`
    is emitted with the `soundId`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This is only a request to play a sound. The `PlaybackWorker` class limits itself
    to read through `soundEvents` and trigger a `playSound()` at the proper moment.
    The real sound will be handled later on, with the `SoundEffectWidget` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: At each iteration in the `while` loop, a `QThread::msleep(1)` is done to avoid
    a busy loop. We minimize the sleep because we want the playback to be as faithful
    as possible to the original score. The longer the sleep, the more discrepancy
    we may encounter in the playback timing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the whole `soundEvents` has been processed, the `trackFinished`
    signal is emitted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Making your objects serializable with QVariant
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we implemented the logic in our business classes, we have to think
    about what we are going to serialize and how we are going to do it. The user interacts
    with a `Track` class that contains all the data to be recorded and played back.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Starting from here, we can assume that the object to be serialized is `Track`,
    which in turn should somehow bring along its `mSoundEvents` containing a list
    of `SoundEvent` instances. To achieve this, we will rely heavily on the `QVariant`
    class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: You might have worked with `QVariant` before. It is a generic placeholder for
    any primitive type (`char`, `int`, `double`, and so on) but also complex types
    (`QString`, `QDate`, `QPoint`, and many more).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete list of QVariant supported types is available at [http://doc.qt.io/qt-5/qmetatype.html#Type-enum](http://doc.qt.io/qt-5/qmetatype.html#Type-enum).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of `QVariant` is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We store `21` in `variant`. From here, we can ask for `variant` to have a copy
    of the value casted to our desired type. Here we want an `int` value, so we call `variant.toInt()`.
    There are a lot of conversions already available with the `variant.toX()` syntax.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We can take a very quick peek at what happens behind the curtain in `QVariant`.
    How does it store all we feed it? The answer lies in the C++ type `union`. The `QVariant`
    class is a kind of super `union`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'A `union` is a special class type that can hold only one of its non-static
    data members at a time. A short snippet should illustrate this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, a `union` class is declared like a `struct`. By default, all the members
    are `public`. The specificity of the `union` is that it takes only the largest
    member size in memory. Here, `Sound` will take only as much as the `int duration`
    space in memory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Because `union` takes only this specific space, every member variable shares
    the same memory space. Therefore, only one member is available at a time, unless
    you want to have undefined behaviors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: When using the `Sound` snippet, we start by initializing with the value `10`
    (by default the first member is initialized). From here, `s.duration` is accessible
    but `s.code` is considered undefined.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Once we assign a value to `s.code`, `s.duration` becomes undefined and `s.code`
    is now accessible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The `union` class makes the memory usage very efficient. In `QVariant`, when
    you store a value, it is stored in a private `union`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the list of primitive types and at the end the complex types, `QObject*`
    and `void*`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Besides `Data`, a `QMetaType` object is initialized to know the type of the
    stored object. The combination of `union` and `QMetaType` lets `QVariant` know
    which `Data` member it should use to cast the value and give it back to the caller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know what a `union` is and how `QVariant` uses it, you might ask:
    why make a `QVariant` class at all? A simple `union` would not have been enough?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no. It is not enough because a `union` class cannot have members
    that do not have a default constructor. It drastically reduces the number of classes
    you can put in a `union`. Qt folks wanted to include many classes that did not
    have a default constructor in `union`. To mitigate this, `QVariant` was born.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes `QVariant` very interesting is that it is possible to store custom
    types. If we wanted to convert `SoundEvent` class to a `QVariant` class, we would
    have added the following in `SoundEvent.h`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We already used `Q_DECLARE_METATYPE` macro in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This macro effectively registers `SoundEvent` to the `QMetaType` register,
    making it available for `QVariant`. Because `QDataStream` relies on `QVariant`,
    we had to use this macro in the last chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to convert back and forth with a `QVariant`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can guess, the output of this snippet is `4365`, the original `timestamp`
    stored in `soundEvent`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach would have been perfect if we wanted to do only binary serialization.
    Data can be easily written and read from. However, we want to output our `Track`
    and `SoundEvents` to standard formats: JSON and XML.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a major issue with the `Q_DECLARE_METATYPE`/`QVariant` combo: it does
    not store any key for the fields of the serialized class. We can already foresee
    that the JSON object of a `SoundEvent` class will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is no way the `QVariant` class could know that we want a `timestamp` key.
    It will only store the raw binary data. The same principle applies for the XML
    counterpart.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we are going to use a variation of a `QVariant` with a `QVariantMap`.
    The `QVariantMap` class is only a `typedef` on `QMap<QString, QVariant>`. This
    map will be used to store the key names of the fields and the value in the `QVariant`
    class. In turn, these keys will be used by the JSON and XML serialization system
    to output a pretty file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Because we aim to have a flexible serialization system, we have to be able to
    serialize and deserialize this `QVariantMap` in multiple formats. To achieve this,
    we will define an interface that gives the ability for a class to serialize/deserialize
    its content in a `QVariantMap`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This `QVariantMap` will be used as an intermediate format, agnostic of the final
    JSON, XML, or binary.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C++ header named `Serializer.h`. Here is the content:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By implementing this abstract base class, a class will be `Serializable`. There
    are only two virtual pure functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `toVariant()` function, in which the class must return a `QVariant` (or,
    more precisely a `QVariantMap`, which can be casted to a `QVariant` thanks to
    the `QMetaType` system)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fromVariant()` function, in which the class must initialize its members
    from the variant passed as a parameter
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing so, we give the responsibility to the final class to load and save
    its content. After all, who knows better `SoundEvent` than `SoundEvent` itself?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see `Serializable` in action with `SoundEvent`. Update `SoundEvent.h`
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `SoundEvent` class is now `Serializable`. Let''s do the real work in `SoundEvent.cpp`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In `toVariant()`, we simply declare a `QVariantMap` that gets filled with `timestamp`
    and `soundId`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, in `fromVariant()`, we convert `variant` to a `QVariantMap`
    and retrieve its content with the same keys we used in `toVariant()`. It is as
    simple as that!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class that have to be `Serializable` is `Track`. After making `Track`
    inherit from `Serializable`, update `Track.cpp`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The principle is the same, although a bit more complex. The `mDuration` variable
    is stored in `map` object as we have seen for `SoundEvent`. For `mSoundEvents`,
    we have to generate a list of `QVariant` (a `QVariantList`) where each item is
    the converted `QVariant` version of a `soundEvent` key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we simply loop over `mSoundEvents` and fill `list` with the `soundEvent->toVariant()`
    result we covered a few paragraphs before.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `fromVariant()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, for each element of the key `soundEvents`, we create a new `SoundEvent`,
    load it with the content of `data`, and finally add it to the vector `mSoundEvents`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects in JSON format
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Track` and `SoundEvent` classes can now be converted to a common Qt format `QVariant`.
    We now need to write a `Track` (and its `SoundEvent` objects) class in a file
    with a text or a binary format. This example project allows you to handle all
    the formats. It will allow you to switch the saved file format in one line. So
    where to put the specific format code? That is the million dollar question! Here
    is a primary approach:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects in JSON format](img/image00442.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'In this proposition, the specific file format serialization code is inside
    a dedicated child class. Well, it works but what would the hierarchy look like
    if we add two new file formats? Moreover, each time we add a new object to serialize,
    we have to create all these children classes to handle the different serialization
    file formats. This massive inheritance tree can quickly become a sticky mess.
    The code will be unmaintainable. You do not want to do that. So, here is where
    the bridge pattern can be a good solution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects in JSON format](img/image00443.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'In a bridge pattern, we decouple the classes in two inheritance hierarchies:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The components independent from the file format. The `SoundEvent` and `Track`
    objects do not care about JSON, XML, or a binary format.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file format implementations. The `JsonSerializer`, `XmlSerializer` and `BinarySerializer`
    handle a generic format, `Serializable`, not a specific component such as `SoundEvent`
    or `Track`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that in a classic bridge pattern, an abstraction (`Serializable`) should
    contains an implementor (`Serializer`) variable. The caller only deals with the
    abstraction. However in this project example, `MainWindow` has the ownership of `Serializable`
    and also of `Serializer`. This is a personal choice to use the power of design
    pattern while keeping uncoupled functional classes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of `Serializable` and `Serializer` is clear. The `Serializable` class
    is already implemented so you can now create a new C++ header file called `Serializer.h`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Serializer` class is an interface, an abstract class with only pure virtual
    functions and no data. Let''s talk about the `save()` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: This function saves `Serializable` to a file on the hard disk drive.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class is `const` and cannot be modified by this function.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filepath` function indicates the destination file to create.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some `Serializer` implementations can use the `rootName` variable. For example,
    if we request to save a `Track` object, the `rootName` variable could be the string `track`.
    This is the label used to write the root element. The XML implementation requires
    this information.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `load()` function is also easy to understand:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: This function loads data from a file to fill a `Serializable` class
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serializable` class will be updated by this function
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filepath` function indicates which file to read
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface `Serializer` is ready and waits for some implementations! Let''s
    start with JSON. Create a C++ class, `JsonSerializer`. Here is the header for `JsonSerializer.h`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'No difficulties here; we have to provide an implementation of `save()` and `load()`.
    Here is the `save()` implementation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Qt framework provides a nice way to read and write a JSON file with the
    `QJsonDocument` class. We can create a `QJsonDocument` class from a `QVariant`
    class. Notice that the `QVariant` accepted by `QJsonDocument` must be a `QVariantMap`, `QVariantList`,
    or `QStringList`. No worries, the `toVariant()` function of `Track` class and `SoundEvent`
    generates a `QVariantMap`. Then, we can create a `QFile` file with the destination `filepath`.
    The `QJsonDocument::toJson()` function converts it to a UTF-8 encoded text representation.
    We write this result to the `QFile` file and close the file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QJsonDocument::toJson()` function can produce an `Indented` or a `Compact`
    JSON format. By default, the format is `QJsonDocument::Indented`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load()` implementation is also short:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We open a `QFile` with the source `filepath`. We read all the data with `QFile::readAll()`.
    Then we can create a `QJsonDocument` class with the `QJsonDocument::fromJson()`
    function. Finally, we can fill our destination `Serializable` with the `QJsonDocument`
    converted to a `QVariant` class. Notice that the `QJsonDocument::toVariant()`
    function can return `QVariantList` or a `QVariantMap` depending the nature of
    the JSON document.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `Track` class saved with this `JsonSerializer`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The root element is a JSON object, represented by a map with two keys:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`Duration`: This is a simple integer value'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundEvents`: This is an array of objects. Each object is a map with the following
    keys:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`soundId`: This is an integer'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp`: This is also an integer'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects in XML format
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "The JSON serialization was a direct representation of the C++ objects and Qt\
    \ already provides all we need. However, the serialization of a C++ object can\
    \ be done with various representations in an XML format. So we have to write the\
    \ XML â\x86” `QVariant` conversion ourselves. We have decided to use the following\
    \ XML representation:"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, the `soundId` type gives this XML representation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a C++ class `XmlSerializer` that also inherits from `Serializer`. Let''s
    begin with the `save()` function, here is `XmlSerializer.h`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can see the `save()` implementation in `XmlSerializer.cpp`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We create a `QFile` file with the `filepath` destination. We construct a `QXmlStreamWriter`
    object that writes in the `QFile`. By default, the writer will produce a compact
    XML; you can generate a pretty XML with the `QXmlStreamWriter::setAutoFormatting()`
    function. The `QXmlStreamWriter::writeStartDocument()` function writes the XML
    version and the encoding. We write our `QVariant` in the XML stream with our `writeVariantToStream()`
    function. Finally, we end the document and close the `QFile`. As already explained,
    writing a `QVariant` to an XML stream depends on how you want to represent the
    data. So we have to write the conversion function. Please update your class with `writeVariantToStream()`
    like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This `writeVariantToStream()` function is a generic entry point. It will be
    called each time we want to put a `QVariant` in the XML stream. The `QVariant`
    class could be a list, a map, or data. So we apply a specific treatment if the `QVariant`
    is a container (`QVariantList` or `QVariantMap`). All the other cases are considered
    to be a data value. Here are the steps of this function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Start a new XML element with the `writeStartElement()` function. The `nodeName`
    will be used to create the XML tag. For example, `<soundId`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an XML attribute called `type` in the current element. We use the name
    of the type stored in the `QVariant`. For example, `<soundId type="int"`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the `QVariant` data type, we call one of our XML serialization
    functions. For example, `<soundId type="int">2`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we end the current XML element with `writeEndElement()`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final result is: `<soundId type="int">2</soundId>`
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this function, we call three helper functions that we will create now. The
    easiest one is `writeVariantValueToStream()`. Please update your `XmlSerializer`
    class with:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the `QVariant` is a simple type, we retrieve its `QString` representation.
    Then we use `QXmlStreamWriter::writeCharacters()` to write this `QString` in the
    XML stream.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The second helper function is `writeVariantListToStream()`. Here is its implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: At this step, we already know that the `QVariant` is a `QVariantList`. We call `QVariant::toList()`
    to retrieve the list. Then we iterate over all elements of the list and call our
    generic entry point, `writeVariantToStream()`. Notice that we retrieve the elements
    from a list so we do not have an element name. But the tag name does not matter
    for a list item serialization, so insert the arbitrary label `item`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The last write helper function is `writeVariantMapToStream()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `QVariant` is a container but a `QVariantMap` this time. We call `writeVariantToStream()`
    for each element found. The tag name is important because this is a map. We use
    the map key from `QMapIterator::key()` as the node name.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The saving part is over. We can now implement the loading part. Its architecture
    follows the same spirit as the saving functions. Let''s begin with the `load()`
    function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first thing to do is to create a `QFile` with the source `filepath`. We
    construct a `QXmlStreamReader` with the `QFile`. The `QXmlStreamReader ::readNextStartElement()`
    function reads until the next start element in the XML stream. Then we can use
    our read helper function, `readVariantFromStream()`, to create a `QVariant` class
    from an XML stream. Finally, we can use our `Serializable::fromVariant()` to fill
    the destination `serializable`. Let''s implement the helper function, `readVariantFromStream()`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The role of this function is to create a `QVariant`. Firstly, we retrieve the `"type"`
    from the XML attributes. In our case, we have only one attribute to handle. Then,
    depending on the type, we will call one of our three read helper functions. Let''s
    implement the `readVariantValueFromStream()` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function create a `QVariant` with its data depending on the type. Like
    the previous function, we retrieve the type from the XML attribute. We also read
    the data as a text with the `QXmlStreamReader::readElementText()` function. A `QVariant`
    class is created with this `QString` data. At this step, the `QVariant` type is
    a `QString`. So we use the `QVariant::convert()` function to convert the `QVariant`
    to the real type (`int` , `qlonglong`, and so on).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The second read helper function is `readVariantListFromStream()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We know that the stream element contains an array. So, this function creates
    and returns a `QVariantList`. The `QXmlStreamReader::readNextStartElement()` function
    reads until the next start element and returns `true` if a start element is found
    within the current element. We call the entry-point function, `readVariantFromStream()`,
    for each element. Finally, we return the `QVariantList`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The last helper function to cover is `readVariantMapFromStream()`. Update your
    file with the following snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function sounds like the `readVariantListFromStream()`. This time we have
    to create a `QVariantMap`. The key used for inserting a new item is the element
    name. We retrieve the name with the `QXmlStreamReader::name()` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Track` class serialized with the `XmlSerializer` looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Serializing objects in binary format
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The XML serialization is fully functional! We can now switch to the last type
    of serialization covered in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary serialization is easier because Qt provides a direct way to do it.
    Please create a `BinarySerializer` class that inherits from `Serializer`. The
    header is common, we have only the override functions, `save()` and `load()`.
    Here is the implementation of the `save()` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We hope you recognized the `QDataStream` class used in [Chapter 10](part0097.xhtml#aid-2SG6I2
    "Chapter 10.  Need IPC? Get Your Minions to Work"), *Need IPC? Get Your Minions
    to Work*. This time we use this class to serialize binary data in a destination `QFile`.
    A `QDataStream` class accepts a `QVariant` class with the `<<` operator. Notice
    that the `rootName` variable is not used in the binary serializer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `load()` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Thanks to the `QVariant` and the `QDataStream` mechanism, the task is easy.
    We open the `QFile` with the source `filepath`. We construct a `QDatastream` class
    with this `QFile`. Then, we use the `>>` operator to read the root `QVariant`.
    Finally, we fill the source `Serializable` with our `Serializable::fromVariant()`
    function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry, we will not include an example of a `Track` class serialized with
    the `BinarySerializer` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The serialization part is completed. The GUI part of this example project has
    been covered many times during the previous chapters of this book. The following
    sections will only cover specific features used in our `MainWindow` and `SoundEffectWidget`
    classes. Check the source code if you need the complete C++ classes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Playing low latency sounds with QSoundEffect
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project application `ch11-drum-machine` displays four `SoundEffectWidget`
    widgets: `kickWidget`, `snareWidget`, `hihatWidget`, and `crashWidget`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Each `SoundEffectWidget` widget displays a `QLabel` and a `QPushButton`. The
    label displays the sound name. If the button is clicked, a sound is played.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt Multimedia module provides two main ways to play an audio file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`QMediaPlayer`: This file can play songs, movies, and Internet radio with various
    input formats'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSoundEffect`: This file can play low-latency `.wav` files'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This project example is a virtual drum machine, so we are using a `QSoundEffect`
    object. The first step to use a `QSoundEffect` is to update your `.pro` file like
    this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you can initialize the sound. Here is an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first step is to create a valid `QUrl` for your sound file. The `urlKick`
    is initialized from a `.qrc` resources file path, while `urlBetterKick` is created
    from a local file path. Then we can create `QSoundEffect` and set the URL sound
    to play with the `QSoundEffect::setSource()` function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `QSoundEffect` object initialized, we can play the sound
    with the following code snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Triggering a QButton with your keyboard
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore the public slot, `triggerPlayButton()`, in the `SoundEffectWidget`
    class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This widget has a `QPushButton` called `mPlayButton`. The `triggerPlayButton()`
    slot calls the `QPushButton::animateClick()` function, which simulates a click
    on the button over 100 ms by default. All signals will be sent as a real click
    does. The button really appears to be down. If you do not want the animation you
    can call `QPushButton::click()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now how to trigger this slot with a key. Each `SoundEffectWidget`
    has a `Qt:Key`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `SoundEffectWidget` class provides a getter and a setter to get and set
    the member variable, `mTriggerKey`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainWindow` class initializes the keys of its four `SoundEffectWidget`
    like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'By default, the `QObject::eventFilter()` function is not called. To enable
    it and intercept these events, we need to install an event filter on the `MainWindow`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So each time the `MainWindow` receives an event, the `MainWindow::eventFilter()`
    function is called.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `MainWindow.h` header:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `MainWindow` class has a `QVector` with the four `SoundEffectWidgets` (`kickWidget`, `snareWidget`, `hihatWidget`,
    and `crashWidget`). Let''s see the implementation in `MainWindow.cpp`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The first thing to do is to check that the `QEvent` class is a `KeyPress` type.
    We do not care about other event types. If the event type is correct, we proceed
    to the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Cast the `QEvent` class to `QKeyEvent`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we search if the pressed key belongs to the `SoundEffectWidget` class.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a `SoundEffectWidget` class corresponds to the key, we call our `SoundEffectWidget::triggerPlayButton()`
    function and we return `true` to indicate that we consumed the event and it must
    not be propagated to others classes.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, we call the `QObject` class implementation of `eventFilter()`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bringing PlaybackWorker to life
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user can play a sound live with a mouse click or a keyboard key. But when
    he records an awesome beat, the application must be able to play it again with
    the `PlaybackWorker` class. Let''s see how `MainWindow` uses this worker. Here
    is the `MainWindow.h` related to the `PlaybackWorker` class:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, `MainWindow` has `PlaybackWorker` and a `QThread` member variables.
    Let''s see the implementation of `startPlayback()`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s analyze all the steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: We clear the current playback with the `clearPlayback()` function, which will
    be covered soon.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `QThread` and `PlaybackWorker` are constructed. The current track is
    given to the worker at this moment. As usual, the worker is then moved to its
    dedicated thread.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to play the track as soon as possible. So, when the `QThread` emits
    the `started()` signal, the `PlaybackWorker::play()` slot is called.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not want to worry about the `PlaybackWorker` memory. So when the `QThread`
    is over and it has sent the `finished()` signal, we call the `QObject::deleteLater()`
    slot, which schedules the worker for deletion.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `PlaybackWorker` class needs to play a sound, the `playSound()` signal
    is emitted and our `MainWindow:playSoundEffect()` slot is called.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last connect covers when the `PlaybackWorker` class finishes playing the
    whole track. A `trackFinished()` signal is emitted and we call the `Track::Stop()`
    slot.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the thread is started with a high priority. Notice that some operating
    systems (for example, Linux) do not support thread priorities.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now see the `stopPlayback()` body:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We call the `stop()` function of the `PlaybackWorker` from our thread. Because
    we use a `QAtomicInteger` in `stop()`, the function is thread-safe and can be
    directly called. Finally, we call our helper function, `clearPlayback()`. This
    is the second time that we use `clearPlayback()`, so let''s implement it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: No surprises here. If the thread is valid, we ask the thread to exit and wait
    1 second. Then, we set the thread and the worker to `nullptr`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaybackWorker::PlaySound` signal is connected to `MainWindow::playSoundEffect()`.
    Here is the implementation:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This slot retrieves the `SoundEffectWidget` class corresponding to the `soundId`.
    Then, we call the `triggerPlayButton()`, the same method that is called when you
    press the trigger key on your keyboard.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when you click on the button, press a key, or when the `PlaybackWorker`
    class requests to play a sound, the `QPushButton` of `SoundEffectWidget` emits
    the signal, `clicked()`. This signal is connected to our `SoundEffectWidget::play()`
    slot. The next snippet describes this slot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Nothing fancy here. We call the `play()` function on the `QSoundEffect` already
    covered. Finally, we emit the `soundPlayed()` signal that is used by `Track` to
    add a new `SoundEvent` if we are in the `RECORDING` state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Accepting mouse drag and drop events
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project example, if you drag and drop a `.wav` file on a `SoundEffectWidget`,
    you can change the sound played. The constructor of `SoundEffectWidget` performs
    a specific task to allow drag and drop:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can now override the drag and drop callbacks. Let''s start with the `dragEnterEvent()`
    function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `dragEnterEvent()` function is called each time the user drags an object
    on the widget. In our case, we only want to allow drag and drop on files that
    are of the MIME type: `"text/uri-list"` (a list of URIs, which can be `file://`, `http://`,
    and so on). In this case, though we can call the `QDragEnterEvent::acceptProposedAction()`
    function to notify that we accept this object for a drag and drop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a second function, `dropEvent()`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first step is a sanity check. If the event does not have a URL, we do nothing.
    The `QMimeData::hasUrls()` function returns `true` only with the MIME type: `"text/uri-text"`.
    Notice that a user can drag and drop multiple files at once. In our case, we only
    handle the first URL. You can check that the file is a `.wav` file with its MIME
    type. If the MIME type is `"audio/wav"`, we call the `loadSound()` function, which
    updates the sound assigned to this `SoundEffectWidget`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot show the complete application for `ch11-drum-machine`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Accepting mouse drag and drop events](img/image00444.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization is a good way to make your data persistent when you close your
    application. In this chapter, you learned to make your C++ objects serializable
    with `QVariant`. You created a flexible serialization structure with the Bridge
    pattern. You saved an object in a different text format such as JSON or XML and
    also in a binary format.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是在你关闭应用程序时使你的数据持久化的好方法。在本章中，你学习了如何使用 `QVariant` 使你的 C++ 对象可序列化。你使用桥接模式创建了一个灵活的序列化结构。你将对象保存为不同的文本格式，如
    JSON 或 XML，以及二进制格式。
- en: You also learned to use the Qt Multimedia module to play some sound effects.
    These sounds can be triggered by a mouse click or by a keyboard key. You implemented
    a friendly user interaction, allowing you to load a new sound with a file drag
    and drop.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了使用 Qt 多媒体模块来播放一些音效。这些声音可以通过鼠标点击或键盘按键触发。你实现了友好的用户交互，允许你通过文件拖放来加载新的声音。
- en: In the next chapter, we will discover the `QTest` framework and how you can
    organize your project so it has a clean application/test separation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现 `QTest` 框架以及如何组织你的项目，使其具有清晰的应用程序/测试分离。
