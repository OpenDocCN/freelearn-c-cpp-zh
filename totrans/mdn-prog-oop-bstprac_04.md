# *第三章*

# 综合考虑

在*第二章，论点*中，我们看到了使用面向对象编程（OOP）的核心好处可以通过少数几个考虑来实现：

+   对象是*独立的程序*，尽可能无知于上下文

+   对象通过*发送消息*进行通信

+   对象的行为由*合约*描述，这些合约表达了它们对消息的响应

+   对象可以在上下文中编写、更改、检查和适应

目前还没有一个系统能够同时支持所有这些要求。讽刺的是，尽管面向对象编程（OOP）已经变得*过于复杂*，正如第一章“对立”中所示，它也仍然*不完整*。在这本书的最后部分，让我们考虑一下这样一个系统会是什么样子。

## 对象是独立的程序

最容易解决的问题是可以让开发者独立设计对象，而不必表达限制开发者设计自由的约束。一种方法是为开发者提供一个`MetaObject`协议，允许他们根据特定上下文调整语言的规则。一个更简单的方法（无论是创建还是使用）是将*消息系统的原始部分*提供给开发者，按需组合以满足他们的设计目标。

这更容易创建，因为任何更复杂的系统都需要这些原始操作。使用起来也更简单，因为它允许开发者根据遇到的问题构建解决方案，而不是试图将现有规则适应他们为解决方案构建的模型。这种适应是我们第一章“对立”中探讨使用面向对象编程（OOP）的困难之一：如果你有 Java 继承，你需要使用 Java 继承来解决你的问题，即使你的问题看起来并不适合 Java 继承。

需要的原始操作数量很少。以下是一个基于第一章“对立”中探讨的对象函数式编程视图的 Python 示例。

**选择器类型**。这是一种可以用来命名消息的类型，因此它必须是可比较的：接收者需要知道消息中命名了哪个选择器，以便它可以决定要做什么。Python 的字符串类型足以作为选择器类型，尽管许多面向对象的语言使用内部字符串类型（例如 Ruby 的符号）来降低比较的成本。

使用`__getattr__()`函数来完成这项工作，无论是为了实现`object.attribute`语法还是为了实现`getattr(object, attribute)`函数，而且方便的是，它期望属性名是一个字符串，因此这与消息选择器兼容。

**发送消息的方式**。这将允许对象使用其自己的查找函数找到适当的方法实现，然后使用消息中提供的参数执行该方法。它看起来像这样：

```cpp
	def msg_send(obj, name, *args):
		message_arguments = [obj]
		message_arguments.extend(args)
		return getattr(obj,name)(*message_arguments)
```

注意到任何消息的第一个参数都是接收对象。这允许对象递归地给自己发送消息，即使被调用的方法不是在接收器上找到的，而是在一个被委托的对象上，否则这个对象可能对接收器一无所知。

**消息查找的递归情况**。如果一个对象不知道如何实现给定的消息，它可以请求另一个对象。这是 *委托*。它看起来是这样的：

```cpp
    def delegate(other, name):
        return getattr(other, name)
```

`doesNotUnderstand` 函数提供了这种行为（在我们的情况下，引发错误），我们还将提供一个使用 `doesNotUnderstand` 并可以终止任何委托链的 `Base` 类型：

```cpp
    def doesNotUnderstand(obj, name):
        raise ValueError("object {} does not respond to selector {}".format(obj, name))
	Base = type('Base', (), {
        '__getattr__': (lambda this, name:
            (lambda myself: myself) if name=="this"
            else (lambda myself: doesNotUnderstand(myself, name)))
        })
```

由于消息发送约定，`myself` 是接收消息的对象，而 `this` 是代表其处理消息的对象：这些可以是，但不一定必须是同一个对象。

现在这 13 行 Python 代码（在 **objective-py** 的 [`gitlab.labrary.online/leeg/objective-py`](https://gitlab.labrary.online/leeg/objective-py) 找到）足以构建任何形式的面向对象委托，包括常见的继承形式。

一个 **对象** 可以通过将所有未知消息委托给原型来继承原型。

**类** 是一个代表其实例实现方法的对象。一个类的创建实例包含它自己的所有数据，但将所有消息委托给类对象。

这个类可以没有父类（它不委托未知消息），有一个父类（它将所有未知消息委托给单个父类对象）或多个父类（它将未知消息委托给父类对象列表中的任何一个）。它还可以支持特性或混入，通过将它们添加到搜索方法实现的对象列表中来实现。

一个类甚至可以有一个 `metaclass`：一个类对象，它将接收到的消息委托给它。如果需要，`metaclass` 还可以有一个 `metametaclass`。

这些方案中的任何一个或多个都可以在同一个系统中使用，因为对象之间互不知晓，也不知道它们的构造方式。它们只知道它们可以使用 `msg_send()` 发送彼此的消息，并且可以使用 `delegate` 让另一个对象代表它们响应消息。

但是，Python 作为 Python，这些对象都在同一个线程、同一个进程中同步运行。它们还不是真正独立的程序。

继续使用 Python，通过为每个对象使用不同的 Python 解释器，我们可以很容易地将我们的对象分离到不同的进程中，通过使用 `execnet` 模块——[`codespeak.net/execnet/index.html`](https://codespeak.net/execnet/index.html)。

#### 一个简短但重要的补充

此处的示例（以及可在 [`gitlab.labrary.online/leeg/objactive-py`](https://gitlab.labrary.online/leeg/objactive-py) 获取）专注于展示运行隔离对象的可能性，实际上并不适合用于实际的应用或系统。本书中描述的简单面向对象原则缺乏生产系统，正是最初写这本书的动机！

每个对象可以存在于自己的模块中。创建对象涉及创建一个新的 Python 解释器并告诉它运行此模块：

```cpp
    def create_object():
        my_module = inspect.getmodule(create_object)
        gw = execnet.makegateway()
        channel = gw.remote_exec(my_module)
        return channel
```

当 `execnet` 运行一个模块时，它有一个特殊名称，我们可以用它来存储接收通道并安装消息处理程序。在此代码中，接收者存储在一个全局变量中；由于它在自己的 Python 解释器中运行，与我们的系统其他部分是分开的进程，因此这个 *全局* 实际上是接收对象的唯一标识：

```cpp
    if __name__ == '__channelexec__':
        global receiver
        receiver = channel
        channel.setcallback(handler)
        channel.waitclose()
```

`handler` 函数是我们对象的信使分发函数：它检查信使选择器并决定运行什么代码。这可以与之前的示例完全相同地工作——换句话说，它可以按照我们的意愿工作。一旦对象收到一个消息，它应该由 *该对象* 决定如何处理它，以及如何响应。

### 对象的行为可以用契约来描述

虽然任何对象都有权决定如何响应消息，但我们需要知道该对象是否代表对我们系统的有用补充。换句话说，我们想知道 *对象* 将如何响应 *什么* 消息。

如 *第二章，论文* 所见，Eiffel 语言将关于对象的知识封装成 *契约* 的形式，描述了每个方法的先决条件和后置条件，以及对象创建时和未执行方法时保持的不变量。

正如 *面向对象软件构造* 中的语言所暗示的，这个契约是一个有用的 *设计* 工具：用对象接收到的消息、接收这些消息时的期望以及发送者可以期望得到什么来描述你的对象。

Eiffel 还表明，契约是一个有效的 *正确性测试* 工具，因为对象契约中包含的断言可以在适当的时候进行检查，无论对象是在测试还是生产系统中使用。原则上，契约甚至可以用来 *生成* 基于属性的测试；"对于所有（预期输入结构）->（断言结果中某些属性成立)" 除了是先决条件和后置条件的陈述之外，还有什么？在实践中，这种集成尚不存在。

根据合同描述一个对象可以做什么，对象执行该操作必须满足什么条件，以及对象执行后会发生什么，它也是每个对象 *标准文档结构* 的绝佳候选人。我们已经在 HTTP API 的世界中看到，**Open API 规范**（以前称为 Swagger，[`swagger.io/specification`](https://swagger.io/specification)）是 API 支持的操作、其参数和响应的机器和人类可读描述。这种方法可以很容易地应用于单个对象；毕竟，一个对象代表了一个小型、隔离的计算机程序模型，因此它的消息边界 *就是* 支持特定操作的一个 API。

## 对象可以在上下文中编写、检查和更改

大卫·韦斯特将对象描述为计算机舞台上的 *演员*，甚至程序员拿起代表对象的 CRC 卡并扮演其在系统中的角色，解释他们使用的数据以及他们向其他对象发送的消息。对象本质上是一种实时、交互式的 *思考软件* 的方式，因此它们最好通过一种实时、交互式的方式 *将思想转化为软件*。

Smalltalk 环境，包括现代的 **Pharo** 和 **Amber**——[`www.amber-lang.net/`](https://www.amber-lang.net/)，证明了这样的工具是可能的。特别是 Pharo，它为开发者体验增添了新颖的功能，项目“关于”页面上的一个要点（[`pharo.org/about`](https://pharo.org/about)）告诉我们，“是的，我们在调试器中编码。”

目前，使用这种环境制作的软件的分发可能不是最优的。使用 Pharo，你可以将特定的类导出到一个包中，其他人可以使用已经设置好 Pharo 的包，或者你可以将整个 Pharo 环境的状态写入一个 *镜像文件*，并将 Pharo 虚拟机和镜像文件提供给将使用你的软件的人。Amber 也以这种方式工作，但在后台使用流行的 Bower 包管理器来管理 JavaScript，其 *镜像* 只包含实现 JavaScript 函数的几个类。此外，许多 JavaScript 开发者并不以传统方式 *分发* 他们的软件，因为它们要么被作为浏览器所需的服务提供，要么由开发者自己在 Node.js 服务中运行。

这种实时交互不仅限于 Smalltalk 世界。我正在使用 **GNU Emacs**——[`www.gnu.org/software/emacs/`](https://www.gnu.org/software/emacs/) 文本编辑器编写这本书的这一部分，它实际上是一个带有动态文本中心用户界面的 Emacs Lisp 解释器。在任何时候，我都可以输入一些 Emacs Lisp 并对其进行评估，包括定义新函数或重新定义现有函数。例如，给定一个包含以下内容的段落：

```cpp
    (defun words () (interactive) (shell-command (concat "wc -w " buffer-file-name)))
```

我可以将我的光标移至段落的末尾，运行 Emacs Lisp 的 `eval-last-sexp` 函数，然后得到一个新的 `words` 函数，它返回 1909（写作时的数字）这个部分手稿中的单词数。如果它没有这样做，如果我意外地计算了字符而不是单词，我可以编辑这个函数，重新评估它，并继续使用修正后的版本。在我重新构建它的时候，没有必要退出 Emacs，因为我正在编辑它在其中运行的相同环境中的代码。

## 将所有这些放在一起

在这里探索的所有部分都存在，但不在同一个地方。将这些部分组合起来是一项重大任务；在分离的进程中构建对象之间的消息传递和委派可能只需要几行源代码，通过合同设计是 `assert()` 语句的明智应用，但提供一个整个交互式环境以允许对这样的系统进行实时开发和调试则是一项更大的任务。那么为什么考虑它呢？

### 速度

当开发环境和部署环境相同时，开发者可以获得更高的保真度体验，这通过减少由于环境差异而导致更改“在 CI 中中断”（甚至在生产中）的可能性，从而降低了开发周期。

使用该软件的人也可以更有信心，因为他们知道开发者是在将要使用的相同环境中构建了这个东西。此外，在这个提议的开发系统中使用合同增加了信心，因为软件被声明（并证明）对所有*满意*的输入都有效，而不仅仅是开发者想到的几个测试用例。

这种保真度通常是以牺牲速度为代价提供给开发者的。程序员通过网络连接到类似生产的服务器，或者在他们的本地系统上构建虚拟机或容器镜像。这段时间被添加到典型的步骤中，例如编译或链接，这些步骤来自分离开发和部署，这给了我们时间在验证到目前为止的工作时分心并失去专注。

然而，最终的速度来自于*实验*。当开发接近部署时，更容易提出诸如“如果我将其改为那样会怎样？”等问题，并回答它们。当系统被分解为小型、隔离、独立的对象时，更容易更改或甚至丢弃和替换需要改进或适应的对象。

虽然通过合同进行设计有其价值，但随着对被模拟系统更多属性的了解和对象形状的信心增加，逐步向对象的合同中添加细节也有其价值。合同对于文档和对象行为的信心非常有用，但这些好处不必以强迫开发者的思维过程在规定的顺序中停靠在特定站点为代价。正如我们在*第一章，对立面*中看到的，迄今为止面向对象编程中的许多复杂性都源于要求软件团队在面向对象软件工程过程的特定点上考虑他们的用例、类层次结构、数据共享或其他系统属性。

最好这样说，“这里有一些工具，当它们有意义时使用它们”，这样开发者的体验就不会受到限制。如果这意味着花时间设计开发者系统，以便开发、构建、文档、测试和配置正在开发的东西可以按任何顺序进行，那么就这样吧。

### 定制

这样的实验也适合于*适应*。对软件工业化的频繁呼吁包括组件的标准化和最终用户根据需要将这些组件连接在一起的能力。布拉德·科克斯（Brad Cox）的软件集成电路、萨尔·索戈扬（Sal Soghoian）的 AppleScript 字典，甚至 NPM 存储库都代表了通过定义“可重用的事物”和“它们被重用的上下文”之间的边界来设计重用方法的方法。

在所有这些情况下，尽管如此，这种区别是任意的：一个软件集成电路（IC）可以实现一个完整的应用程序，或者 Mac 应用程序的内部可能用 AppleScript 编写。在实时开发环境中，这种区别被抹去，任何部分都可以用于扩展、修改或替换。有一个著名的故事是关于丹·英加尔斯（Dan Ingalls）在为包括史蒂夫·乔布斯（Steve Jobs）在内的苹果电脑团队进行演示时，向运行中的 Smalltalk 系统添加了平滑滚动功能（[`www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html`](http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html)）。在那个时刻，丹·英加尔斯的 Alto 电脑有了平滑滚动，而其他人的电脑没有。他不需要重新编译他的 Smalltalk 机器并将电脑关闭以重新部署，它只是开始那样工作。

我的观点是，将合同添加到实时编程环境*使*实验、定制和适应成为可能，因为它增加了对替换部件的信心。许多面向对象程序员已经设计他们的对象以符合 Liskov 替换原则，该原则（大致上）说，如果一个对象的前置条件至多与另一个对象相同，并且它的后置条件至少与另一个对象相同，那么它可以作为另一个对象的替代。

然而，在当前环境中，这种可替换性的想法不必要地与类型系统和继承耦合在一起。在所提出的系统中，一个对象是否具有继承性是其自身的事务，所以我们问一个更简单的问题：这个对象的合约是否与该对象的使用兼容？如果是，那么它们可以被交换，我们知道事情将会工作（至少在合约足够的情况下）。如果不是，那么我们知道**什么**将不会工作，以及需要什么适应来连接事物。

### 专有性

“但我们如何赚钱？”几十年来一直是那些不愿意使用新工具或技术的开发者的口号。我们说过，当免费和开源软件使我们的源代码对用户可用，然后开始运行用户连接的 GNU/Linux 服务器，以便他们可以下载我们的 JavaScript 源代码时，我们无法赚钱。

在这里描述的系统涉及将开发和部署环境相结合，那么我们怎么可能赚钱呢？用户难道不能免费提取我们的代码并自行运行，或者将其提供给朋友，或者卖给朋友吗？

系统上的每个对象都是一个在其自身进程中运行的**独立程序**，其接口是松散耦合的消息发送抽象。任何特定的对象都可能是一个基于专有算法的编译可执行文件，没有源代码的分布式。或者它可能运行在开发者的自有服务器上，远程处理消息，或者它可能被部署为**dApp**到**以太坊**或**NEO**。在每种情况下，开发者都避免了将源代码部署给最终用户，虽然这意味着用户无法检查或修改该对象，但这并不阻止他们**替换**它。

考虑在这样的系统下软件交付的经济可能如何改变是很有趣的。目前，一次性付费的应用程序、定期订阅费、免费应用程序带有付费内容或组件，以及免费（零成本）应用程序和组件都很常见。其他模型也存在：一些 API 提供商按使用次数收费，区块链 dApps 也通过代币间接收费来执行分布式功能。一个应用程序或网络服务有一个清晰的标志，通过用户定义的入口点（他们的网址或主屏幕图标）可见。软件企业如何为履行程序性合约收费，或者为应用程序中由其他对象增强的部分收费，甚至部署后替换的部分收费呢？

### 安全性

在讨论对象的专有性时提到，每个对象都隐藏在松散耦合的消息发送抽象之后。这种系统对安全性的影响如下：

+   为了使对象信任消息的内容，它必须拥有足够的信息来做出信任决定，并且有信心它收到的消息是按照预期发送的，没有修改。使用操作系统 IPC，对象之间发送的消息由内核介导，可以强制执行任何访问限制。

+   “足够的信息”可能包括消息代理提供的元数据，例如，关于发送者背景或导致发送此消息的事件链的信息。

+   对象接收消息的形式不必是传输时的形式；例如，消息层可以在发送时加密消息并添加一个在接收时检查的认证代码，在允许对象处理消息之前检查。从事 Web 应用程序开发的开发者对此已经很熟悉了，因为他们的请求涉及 HTTP 动词，如`GET`或`POST`，以及可读数据，如`JSON`，但随后以压缩格式通过加密、认证的 TLS 通道发送。没有理由这样的措施需要限制在应用程序的网络边缘，也没有理由（如微服务架构所示）网络边缘和系统的物理边缘在同一个地方。

### 多进程

计算机在每秒单任务指令方面已经很久没有变快了。尽管如此，它们仍然**是**从其中加载其代码和数据的内存的显著更快。

这个假设需要验证，但我的预测是，通过消息传递进行通信的小型、独立对象更适合今天的多核硬件架构，因为每个对象都是一个小的自包含程序，它应该比一个单一的应用程序进程更好地适应靠近 CPU 核心的缓存。

现代高性能计算架构已经是大规模并行系统，它们运行独立的工作负载实例，通过消息发送同步、共享数据和通信结果，通常基于 MPI 标准。在 HPC 中使用的许多处理器设计在指令频率方面甚至比桌面或服务器应用程序使用的处理器更**慢**，但单个包中具有更多的核心和更高的内存带宽。

将应用程序分解为独立的、分离的对象的想法与观察结果相一致，即我们不需要一个**快速程序**，而是一个由多个程序组成的**快速系统**。正如云计算架构一样，这样的系统可以通过扩展来提高速度。如果我们能够运行同一部件的数十个副本并在它们之间共享工作，那么我们就不必一定要使部件更快。

### 可用性

所有这些讨论都集中在本书中开发出的编写软件方法的益处（观察到的或假设的）。然而，我们需要现实一些，承认这里描述的工作方式尚未经过测试，并且与程序员目前的工作方式有重大差异。

Smalltalk 程序员已经深爱着他们的 Smalltalk，但 C++ 程序员也深爱着他们的 C++，因此没有一种适合所有程序员的解决方案，即使可以证明在某些所谓的软件构建过程或结果的客观属性上，一种工具或技术比其他工具或技术有优势。

有些人可能会采取“宁为鸡头，不为凤尾”的视角，而其他人可能会尝试这种方法（假设这样的系统甚至被构建出来！）并决定它不适合他们。还有一些人甚至可能会爱上这种**方式**的**想法**，尽管我们发现这可能会减慢他们的速度或比他们目前的工作方式产生更低质量的结果！实验和研究将有助于找出什么有效，对谁有效，以及如何改进。

这可能是整个系统中最大的创新领域。开发者的体验通常非常保守。"现代"项目使用几十年前为了满足技术而非经验约束而出现的编辑-编译-链接-运行-调试工作流程。奇怪的是，这从来不是由拥有设计师和用户体验专家的团队提供的消费产品的首选界面。

## 第三部分结论

本书的故事一直是解构与重建。三十年 OOP 的巨大复杂性被解构，以找到简单的核心，并在该核心周围重建面向对象编程体验。重建包含了该范式的所有独特和重要元素，同时摒弃了由附加咨询和对现有流程的屈服带来的复杂性。

重要的是，这种新的重建仍然从计算机的两个思想流派中吸取教训，我将它们称为**实验室学校**和**图书馆学校**。

**实验室学校**

实验室学校是实验性的方法。走出去，做一件事，并根据你对它表现出的观察来调整、改进或拒绝它。不要担心做对的事情，或者把事情做对，只需确保它被完成。你可以稍后调整它。

**极限编程**（**XP**）和精益创业运动都体现了实验室学校的影响。这两种方案都倡导实验和快速反馈。它们都建议从小和简单开始——XP 通过其 *Ya Ain't Gonna Need It* 原则，精益创业通过其 *最小可行产品*——然后根据反馈快速迭代。

Smalltalk 风格的面向对象编程也体现了实验室思维方式。通过消息发送的松散耦合让程序员能够轻松快速地替换系统中的协作对象。集成开发和部署环境使得一种称为**调试驱动设计**（Debugger-Driven Design）的风格成为可能——[`medium.com/concerning-pharo/pharo-50c66685913c`](https://medium.com/concerning-pharo/pharo-50c66685913c)：找出因为尚未构建而破坏系统的东西，构建它，然后让系统继续其新的行为。

**图书馆学校**

图书馆学校是研究驱动的方法。理解你的问题，发现一个解决方案的属性，这个解决方案适当地解决了问题，用这些属性实现解决方案。

与*面向对象软件工程*相关的学科显示出与图书馆学校的关联。以理性统一过程（Rational Unified Process）为例，它确实促进了*迭代和增量*开发，但这些增量往往是累加的而不是探索性的：先构建行走骨架，然后设计、实现和测试这个用例，然后是那个用例。添加更多用例，直到资金耗尽。确保在每一步你都能保留你仔细考虑过的类关系层次。

编程中的*如果类型检查通过，它就工作*原则似乎来自图书馆学校。类型系统是一个构建关于使用该系统类型的软件的证明的机器。通过一致地应用这些类型来设计你的软件，你将免费获得关于软件行为的定理([`ecee.colorado.edu/ecen5533/fall11/reading/free.pdf`](https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf))。

通过合同进行设计展示了将图书馆学校的思想应用于面向对象编程。一个对象的主要特征不是它的命名类型，而是它的*形状*：它响应的消息以及它对这些消息的响应。从形式方法中采用数学证明工具并将其应用于对象的形状，你最终得到*合同*：一个关于对象响应的消息及其接收这些消息产生的行为的数学陈述。

**图书馆**

从这些思想流派中我们可以学到很多经验教训，而不是站在任何一方，这里描述的系统采用了两者的细节。不是以累加的方式*让我们做这些人做的所有事情，并添加这些人做的所有事情*，而是以综合的方式*让我们看看这些人推广了哪些想法，以及它们如何可以结合在一起*。我们有来自图书馆的合同，但不需要*通过合同进行设计*：它们是实验室中一个活生生的、实验性的系统的一部分，可以随时添加或删除。

当然，这个环境存在一个很大的问题，这是由合成“图书馆”学派思想产生的。这个问题就是环境还不存在。去图书馆吧！
