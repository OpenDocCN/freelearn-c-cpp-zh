# 第 6 章. 快速简单的精灵 - 维多利亚时代高峰期

*在我们的第四个使用 Cocos2d-x 构建的游戏示例中，我将向你展示一个快速原型设计的简单技巧。在游戏开发中，你通常希望尽快测试你游戏的核心想法，因为一个游戏在你脑海中可能听起来很有趣，但现实中可能根本行不通。快速原型设计技术允许你在开发过程的早期就测试你的游戏，并在此基础上构建好的想法。*

下面是你将学习的内容：

+   如何快速创建占位符精灵

+   如何为平台游戏编写碰撞代码

+   如何为横版滚动游戏创建多样化的地形

# 游戏 - 维多利亚时代高峰期

在这个游戏（维多利亚时代高峰期）中，你控制一位在维多利亚时代的伦敦骑自行车的骑车人，试图避免他在回家的路上遇到高峰期交通。由于没有人能解释的原因，他骑自行车在建筑物的顶部。作为玩家，你的任务是确保他安全到达。

控制方式非常简单：你轻触屏幕使骑车人跳跃，当他处于空中时，如果你再次轻触屏幕，骑车人将打开他可靠的雨伞，这要么会减缓他的下降，要么会为他的跳跃增加动力。

这款游戏是一种常见的类型，通常被称为冲刺游戏或无尽跑酷游戏，这种类型在网上和各种应用商店中越来越受欢迎。通常在这些类型的游戏中，作为开发者的你有两个选择：要么让地形成为游戏中的主要障碍和挑战，要么让添加到地形中的元素成为主要挑战（敌人、拾取物、障碍物等）。对于这款游戏，我选择了第一个选项。

所以我们的挑战是创建一个游戏，其中地形是敌人，但不是不可战胜的。

# 游戏设置

这款游戏是一个通用应用程序，专为 iPad Retina 显示屏设计，但支持其他显示尺寸。它以横屏模式进行游戏，不支持多点触控。

# 使用 Cocos2d-x 进行快速原型设计

这种方法的理念是尽可能快速地创建精灵作为游戏元素的占位符，这样你就可以测试你的游戏想法并对其进行改进。本书中的每个游戏最初都是按照我即将展示的方式开发的，用简单的矩形代替纹理精灵。

这里展示的技术允许你创建任何大小和颜色的矩形，用于你的游戏逻辑：

![使用 Cocos2d-x 进行快速原型设计](img/00020.jpeg)

# 行动时间 - 创建占位符精灵

所以让我来展示如何做到这一点：

1.  如果你还没有下载，请继续下载 `4198_06_START_PROJECT.zip` 文件。

1.  当你在 Xcode 中打开项目时，你会看到我们为游戏所需的所有类，我们将在下一秒中讲解它们。但现在，请先转到 `GameLayer.cpp`。

1.  滚动到最后一个 `createGameScreen` 方法，并添加以下行：

    [PRE0]

    就这样。精灵是用一个名为 `blank.png` 的纹理创建的。这是一个位于 `Resources` 文件夹中的 1 x 1 像素的白色方块。然后我们将精灵纹理矩形的大小设置为 100 x 100 像素（`setTextureRect`），并用白色填充它（`setColor`）。通过调整纹理矩形的大小，我们实际上调整了精灵的大小。如果你现在运行游戏，你应该会在屏幕中央看到一个白色方块。

1.  现在删除之前的行，并用这些替换：

    [PRE1]

    这创建了 `_gameBatchNode`，它使用相同的 `blank.png` 文件作为其源纹理。现在我们准备好在 `_gameBatchNode` 内放置尽可能多的矩形，并且如果需要，为每个矩形设置不同的颜色。换句话说，我们可以用一张微小的图片构建整个测试游戏。这正是我们现在要做的。

1.  因此，为了完成这里的任务，添加这些最后一行：

    [PRE2]

## *刚才发生了什么？*

我们刚刚创建了一个占位符精灵，我们可以用它快速且轻松地测试游戏玩法想法。我们还创建了游戏的两个主要对象：`Player` 和 `Terrain` 对象。目前它们是空壳，但我们将从它们开始工作。但首先，让我们回顾一下不同的游戏元素。

# 玩家对象

这代表我们的自行车手。它会跳跃、漂浮，并与 `_terrain` 对象发生碰撞。它的 `x` 速度传递给 `_terrain` 对象，导致 `Terrain` 对象移动，向屏幕左侧滚动。

`Player` 对象再次从 `GameSprite` 类派生。这个类有获取器和设置器来获取下一个位置、移动向量以及精灵的宽度和高度。

`Player` 接口有内联辅助方法来检索与其当前位置相关的矩形边界信息（左、右、上、下），以及其下一个位置（`next_left`、`next_right`、`next_top`、`next_bottom`）。这些将在与 `_terrain` 对象的碰撞检测中使用。

# 块对象

这些对象构成了 `_terrain` 对象的各个独立部分。它们可以呈现建筑物的形状，或者建筑物之间的空隙。我们将有四种不同的建筑物类型，这些类型最终将代表我们引入精灵图集时的四种不同类型的纹理。这些块可以有不同的大小和高度。

`Block` 也从 `GameSprite` 派生，它也有内联辅助方法来检索其边界信息，但仅与其当前位置相关，因为 `Block` 并非技术上会移动。

# 地形对象

这个对象包含构成景观的各个 `Block` 对象。它包含足够的 `Block` 对象来填满屏幕，并且当 `_terrain` 对象向左滚动时，离开屏幕的 `Block` 对象会被移动到 `_terrain` 的右侧边缘，并作为新的块重新使用，确保连续滚动。

`_terrain`对象也负责与`_player`对象的碰撞检测，因为它可以快速访问我们进行碰撞检测所需的所有信息；即当前屏幕上所有块的信息，它们的大小、类型和位置。然后我们的主循环将调用`Terrain`对象来测试与`player`对象的碰撞。

让我们着手处理这些主要对象，从`Player`对象开始。

# 是时候动手编码玩家了

打开`Player.cpp`类。

1.  `_player`对象是通过一个静态方法创建的，该方法使用我们的`blank.png`文件来纹理精灵。该方法还调用`initPlayer`，这就是你应该为该方法输入的内容：

    [PRE3]

    `_player`对象的注册点将在精灵的顶部。这个顶部中心锚点的原因更多是与`_player`对象在漂浮时将被如何动画处理有关，而不是与任何碰撞逻辑要求有关。

1.  接下来是`setFloating`：

    [PRE4]

    `_hasFloated`属性将确保玩家在空中只能打开一次雨伞。当我们把`_floating`设置为`true`时，我们给`_player.y`向量一个加速。

1.  我们从`_player`的更新方法开始：

    [PRE5]

    随着时间的推移，游戏将增加`_player`对象的`_maxSpeed`，使游戏难度增加。这些第一行代码使得从`_players`当前的`_speed`到`_maxSpeed`的转换更加平滑，而不是立即改变。

    ### 注意

    维多利亚时代高峰时段没有关卡，因此找出一种方法使其游戏难度逐渐增加，但又不是不可能的，这一点非常重要。在逻辑中找到这个最佳点可能需要一些时间，这也是尽快测试游戏想法的另一个原因。在这里，我们通过增加玩家的速度和建筑物之间间隙的大小来使游戏更难。这些更新都在主循环的倒计时中完成。

1.  接下来，我们根据`_player`对象的`_state`移动状态更新`_player`对象：

    [PRE6]

    我们根据移动状态的不同，对重力和摩擦力有不同的取值。

    我们还设定了`_player`对象可以漂浮的时间限制，并且当`_player`对象不再漂浮时重置那个计时器。如果`_player`对象正在死亡（与墙壁碰撞），我们将`_player`对象向后和向下移动，直到它离开屏幕。

1.  我们以以下内容结束：

    [PRE7]

    当玩家按下屏幕进行跳跃时，我们不应该让精灵立即跳跃。状态的变化应该总是平滑发生的。因此，我们在`_player`中有一个名为`_jumping`的布尔属性。当玩家按下屏幕时，它被设置为`true`，我们缓慢地给`_vector.y`添加跳跃力。所以玩家按屏幕的时间越长，跳跃就越高，快速轻触会导致跳跃较短。这是任何平台游戏都值得添加的一个好功能。

    我们接下来用终端速度限制`y`速度，更新`_player`对象的下一个位置，如果`_player`正在漂浮，则更新漂浮计时器。

## *刚才发生了什么？*

`_player` 对象通过一系列状态进行更新。触摸屏幕将改变这个 `_state` 属性，以及与 `_terrain` 进行碰撞检查的结果。

现在让我们来编写 `Block` 类。

# 行动时间 - 编写 Block 对象的代码

再次使用一个静态方法 `create`，将使用 `blank.png` 创建我们的 `Block` 精灵。但这一次，我们实际上没有在 `create` 中更改 `Block` 的纹理矩形：

1.  在 `setupBlock` 方法中，`Block` 对象被正确地纹理化：

    [PRE8]

    `Block` 对象的外观将基于其类型、宽度和高度。

    `Block` 精灵的注册点设置为左上角。我们最终在这里更改 `Block` 对象的纹理矩形大小。

1.  然后我们根据类型设置 `Block` 对象的颜色：

    [PRE9]

    `kBlockGap` 表示没有建筑，只有 `_player` 对象必须跳过的空隙。在这种情况下，我们使方块不可见并从函数中返回。所以，再次强调，空隙在我们的逻辑中实际上是块的一种类型。

在这个测试版本中，不同的建筑类型用不同的颜色表示。稍后我们将使用不同的纹理。

## *发生了什么？*

`Block` 对象非常简单。我们只需要它的 `_width` 和 `_height` 值，无论它是空隙还是不是，这样我们就可以正确地运行与这些对象的碰撞检测。

## 规划 Terrain 类

在我们跳转到编写 `Terrain` 类之前，我们需要讨论一些关于随机性的问题。

在游戏开发者中，混淆随机性和可变性是一个非常常见的错误，而且知道何时需要什么非常重要。

随机数可以是任何东西。1234 是一组随机数字。下次你想得到一组随机数字，并且再次得到 1234，这将与之前一样随机。但不是变化的。

如果你决定构建随机地形，你可能会对结果感到失望，因为它不一定会有变化。此外，请记住，我们需要使地形成为游戏的关键挑战；但这意味着它既不能太简单也不能太难。真正的随机性不会给我们足够的控制，或者更糟糕的是，我们最终会得到一个长的条件列表，以确保我们有正确的块组合，这会在主循环中至少导致一个循环函数，这不是一个好主意。

我们需要通过应用自己的模式来控制结果及其可变性。

因此，我们将把这个模式的逻辑应用到我们的 `_terrain` 对象上，形成一个合适的随机选择池。我们将使用四个数组来存储决策中的可能结果，并在游戏中对其中三个数组进行洗牌，以增加地形中的“随机性”感觉。

这些数组是：

[PRE10]

这包含了我们在空隙之间一行中拥有的建筑（`Blocks`）的数量信息。

你可以通过添加新值或增加或减少一个值出现的次数来轻松更改`patterns`值。所以在这里，我们正在创建一个在间隙之间有更多两座建筑组合的地形，而不是三座或一座的组合。

接下来，考虑以下行：

[PRE11]

前面的行指定了每个新建筑的宽度和高度。这些将乘以我们为游戏确定的瓷砖大小，以获得你在`Block:setupBlock`中看到的最终宽度和高度值。

我们将使用`0`值表示高度，表示与上一个建筑之间没有高度变化。类似的逻辑可以很容易地应用于宽度。

最后：

[PRE12]

这些是建筑类型，这个数组将不会像前三个那样洗牌，所以这是我们将用于整个游戏的`types`的`patterns`数组，它将连续循环。你可以让它尽可能长。

## 构建地形对象

所以每次我们需要创建一个新的方块时，我们都会根据这些数组中包含的信息来设置它。

这给了我们更多的控制权，这样我们就不可能为玩家创建不可能的障碍物组合：这是随机构建的地形在冲刺游戏中常见的错误。

但同时，我们可以轻松地扩展这个逻辑以适应每一个可能的需求。例如，我们可以通过创建这些数组的多个版本来将等级逻辑应用于我们的游戏，这样随着游戏的难度增加，我们就开始从包含特别困难值组合的数组中采样数据。

我们仍然可以使用条件循环来进一步细化结果，我会至少给你一个这样的例子。

你在`patterns`数组中看到的值将被存储在名为`_blockPattern`、`_blockWidths`、`_blockHeights`和`_blockTypes`的列表中。

然后`Terrain`类负责在三个阶段构建游戏的地形。首先我们初始化`_terrain`对象，创建一个`Block`对象的池子。然后我们向`_terrain`对象添加第一个方块，直到达到最小宽度，以确保整个屏幕都填充了`Blocks`。最后我们分配各种方块对象。

# 是时候行动了——初始化我们的Terrain类

我们将在下一步中介绍这些步骤：

1.  首先需要实现的重要方法是`initTerrain`：

    [PRE13]

    我们有一个计时器来增加间隙的宽度（我们开始时使用两个瓷砖长度的间隙）。

    我们创建一个方块池，这样在游戏中就不会实例化任何方块。`20`个方块对于我们需要的来说已经足够多了。

    我们目前在地形中使用的方块将被存储在`_blocks`向量中。

    我们确定`_terrain`对象必须具有的最小宽度是屏幕宽度的`1.5`倍。我们将继续添加方块，直到`_terrain`对象达到这个最小宽度。最后，我们洗牌`patterns`数组并添加方块。

1.  `addBlocks`方法应该看起来像这样：

    [PRE14]

    `while` 循环内部的逻辑将继续添加方块，直到 `_terrain` 对象的 `currentWidth` 达到 `_minTerrainWidth`。为了达到 `_minTerrainWidth`，我们从池中检索的每个新方块都会被添加到 `_blocks` 向量中。

1.  方块根据它们的宽度进行分布：

    [PRE15]

## *发生了什么？*

`Terrain` 是 `Blocks` 的容器，我们刚刚添加了将新 `block` 对象添加到这个容器的逻辑。在 `addBlocks` 中，我们调用 `initBlock` 方法，该方法将使用我们 `patterns` 数组中的信息来初始化在地形中使用的每个方块。这就是我们将要实现的方法。

# 行动时间 – 初始化我们的 Blocks 对象

最后，我们将讨论基于我们的 `patterns` 数组初始化方块的方法：

1.  因此，在 `Terrain` 类中，我们以如下方式开始 `initBlock` 方法：

    [PRE16]

    首先确定我们正在初始化的建筑类型。看看我们是如何使用存储在 `_currentTypeIndex` 中的索引遍历 `_blockTypes` 数组的。我们会对其他 `patterns` 数组使用类似的逻辑。

1.  然后，让我们开始构建我们的方块：

    [PRE17]

    玩家必须点击屏幕开始游戏（`_startTerrain`）。在此之前，我们显示具有相同高度（两个地砖）和随机宽度的建筑：

    ![行动时间 – 初始化我们的 Blocks 对象](img/00021.jpeg)

    我们将存储 `_lastBlockHeight` 和 `_lastBlockWidth`，因为关于地形的信息越多，我们就能更好地应用自己的条件，正如你一会儿会看到的。

1.  考虑到我们设置为 `_startTerrain`：

    [PRE18]

    在下面的屏幕截图中，你可以看到我们方块使用的不同宽度：

    ![行动时间 – 初始化我们的 Blocks 对象](img/00022.jpeg)

    `_blockPattern` 中的信息决定了我们一行显示多少座建筑，一旦一个系列完成，我们通过将 `_showGap` 的布尔值设置为 `true` 来显示一个间隙。间隙的宽度基于 `_gapSize` 的当前值，随着游戏难度增加，它可能会增加，但不能小于两倍的地砖宽度。

1.  如果这次我们不创建间隙，我们将根据 `_blockWidths` 和 `_blockHeights` 的当前索引值确定新方块的宽度和高度：

    [PRE19]

    注意，我们在遍历完数组后重新洗牌了数组（`random_shuffle`）。

    我们使用 `_lastBlockHeight` 来对我们的地形应用一个额外的条件。我们不希望下一个方块相对于前一个建筑过高，至少在游戏初期不是这样，我们可以通过检查 `_gapSize` 的值来确定这一点，该值只有在游戏难度增加时才会增加。

    如果 `_blockHeights` 的值是 `0`，我们不会改变新建筑的层数，而是使用 `_lastBlockHeight` 的相同值。

1.  我们通过更新当前建筑系列的计数来确定是否应该显示下一个间隙，或者不显示：

    [PRE20]

## *发生了什么？*

我们最终可以使用我们的 `patterns` 数组并在地形中构建方块。在这里，我们可以无限地控制构建方块的方式。但关键思想是确保游戏不会变得荒谬地困难，我建议你多尝试一些值以获得更好的结果（不要理所当然地接受我的选择）。

在我们处理碰撞之前，让我们添加移动和重置地形的逻辑。

# 行动时间 - 移动和重置

我们在 `move` 方法中移动地形。

1.  `move` 方法接收一个参数，即 `x` 轴上的移动量：

    [PRE21]

    `xMove` 的值来自 `_player` 的速度。

    我们首先更新将使缝隙变宽的计时器。然后我们将地形向左移动。如果移动地形后，一个方块离开了屏幕，我们将方块移回到 `_blocks` 向量的末尾，并通过 `initBlock` 重新初始化它作为一个新的方块。

    我们调用 `addBlocks`，以防重新初始化的方块使得地形总宽度小于所需的最小宽度。

1.  接下来，我们的 `reset` 方法：

    [PRE22]

    每次我们重新启动游戏时都会调用 `reset` 方法。我们将 `_terrain` 移回到其起始点，并重新初始化 `_terrain` 对象中当前的所有 `Block` 对象。这是因为在 `_startTerrain = false`，这意味着所有方块应该具有相同的高度和随机的宽度。

    如果在重置的最后需要更多的方块以达到 `_minTerrainWidth`，我们将相应地添加它们。

## *刚才发生了什么？*

我们现在可以移动 `_terrain` 对象及其包含的所有方块，并且如果我们需要，我们可以重新开始整个过程。

再次强调，使用节点的容器行为极大地简化了我们的工作。当你滚动地形时，你也会滚动它包含的所有 `Block` 对象。

因此，我们最终准备好运行碰撞逻辑。

# 平台碰撞逻辑

我们已经拥有了检查碰撞所需的所有信息，这些信息可以通过 `Player` 和 `Block` 中找到的内置方法进行检查。

在这个游戏中，我们需要检查 `_player` 对象的底部与 `block` 对象的顶部之间的碰撞，以及 `_player` 对象的右侧与 `Block` 类的左侧之间的碰撞。我们将通过检查 `_player` 对象的当前位置和下一个位置来完成这一点。我们正在寻找以下条件：

![平台碰撞逻辑](img/00023.jpeg)

图表表示底部碰撞的条件，但同样的想法也适用于右侧碰撞。

在当前位置，`_player` 对象必须位于方块顶部之上或接触它。在下一个位置，`_player` 对象必须接触方块顶部或已经重叠它（或者完全移动过它）。这意味着发生了碰撞。

# 行动时间 - 添加碰撞检测

让我们看看这如何转化为代码：

1.  仍然在 `Terrain.cpp` 中：

    [PRE23]

    首先，我们声明`_player`对象当前正在下落，`inAir = true;`我们将让碰撞检查来确定这是否会保持为真。

    如果`_player`正在死亡，我们不检查碰撞，并且跳过与任何缝隙块的碰撞检查。

    我们在`y`轴上检查碰撞，在这里这意味着`_player`的底部和块的顶部。我们首先需要确定`_player`对象是否在我们想要检查碰撞的块的范围之内。这意味着`_player`对象的重心必须在块的左右两侧之间；否则，块离`_player`对象太远，可能会被忽略。

    然后，我们运行一个基本的检查，看看`_player`对象当前的位置和下一个位置之间是否有碰撞，使用我之前解释的条件。如果有，我们固定`_player`对象的位置，将其`y`向量速度更改为`0`，并且最终确定`inAir = false`，因为`_player`对象已经着陆。

1.  接下来，我们检查`x`轴上的碰撞，这意味着`_player`对象的右侧与块的左侧：

    [PRE24]

    相似的步骤用于确定我们是否有可行的块。

    如果我们确实有侧面碰撞，将`_player`状态更改为`kPlayerDying`，我们反转其`x`速度，这样`_player`状态就会向左移动并离开屏幕，然后我们从该方法返回。

1.  我们通过更新`_player`对象的状态来结束，基于我们的碰撞结果：

    [PRE25]

## *发生了什么事？*

我们刚刚将碰撞逻辑添加到我们的平台游戏中。就像我们在我们的第一个游戏，冰球一样，我们测试玩家的当前位置和下一个位置以确定当前迭代和下一个迭代之间是否发生了碰撞。测试只是寻找玩家和块边界之间的重叠。

# 添加控制

在像这样的冲刺游戏中，非常常见的是有非常简单的控制。通常，玩家只需按下屏幕进行跳跃。但我们增加了一些趣味，添加了一个浮动状态。

并且记住我们想要在状态之间有平滑的过渡，所以注意跳跃是如何实现的：不是通过立即对玩家的向量施加力，而是简单地改变一个`boolean`属性，并让`_player`对象的更新方法平滑地处理变化。

我们将在下一个步骤中处理触摸事件。

# 行动时间——处理触摸

让我们回到`GameLayer.cpp`并添加我们游戏的最终细节（有意为之）。

1.  首先，我们处理我们的`onTouchBegan`方法：

    [PRE26]

    如果我们没有运行游戏，并且`_player`对象死亡，我们在触摸时重置游戏。

1.  接下来，如果地形尚未开始，插入以下内容：

    [PRE27]

    记住，一开始建筑都是相同的高度，没有缝隙。一旦玩家按下屏幕，我们就通过`setStartTerrain`开始改变这一点。

1.  我们最后完成：

    [PRE28]

    现在，我们进入了游戏状态，如果 `_player` 对象正在下落，我们就通过调用 `setFloating` 来打开或关闭雨伞，具体情况而定。

    如果 `_player` 对象既没有下落也没有死亡，我们就通过 `setJumping(true)` 让它跳跃。

1.  在触摸结束之后，我们只需要停止任何跳跃：

    [PRE29]

## *刚才发生了什么？*

我们添加了游戏控制的逻辑。如果 `_player` 对象当前正在下落，它将变为漂浮状态；如果当前位于建筑顶部，它将变为跳跃状态。

是时候添加我们的主游戏循环了。

# 行动时间 - 编写主循环

最后，是我们逻辑中的最后一部分。

1.  在 `GameLayer.cpp` 中：

    [PRE30]

    如果 `_player` 对象离屏幕，我们停止游戏。

1.  现在更新所有元素、位置并检查碰撞：

    [PRE31]

1.  将 `_gameBatchNode` 与 `_player` 对象相关移动：

    [PRE32]

1.  随着时间的推移，通过增加 `_player` 对象的最大速度来使游戏难度逐渐提高：

    [PRE33]

## *刚才发生了什么？*

我们已经设置了测试游戏。从这里，我们可以测试我们的地形模式、速度和一般玩法，以找到可以改进的地方。

我们应该特别检查游戏是否变得过于困难，或者我们是否有组合的建筑根本无法通过。

例如，我发现从更大的建筑群开始，比如四到五个，然后慢慢减少到两个和一，在间隙之间，可以使游戏更具趣味性，因此模式可以改变以反映这一想法。

# 摘要

每个游戏在其核心玩法中都包含一个简单的想法。但通常，这个想法需要大量的测试和改进，我们才能确定它是否有趣，这就是为什么快速原型设计至关重要的原因。

我们可以使用 Cocos2d-x 快速测试核心玩法想法，并在几分钟内在模拟器或设备上运行它们。

此外，这里展示的技术可以用来构建界面元素（例如我们之前游戏中的能量条）以及整个游戏！如果你不相信我，可以去你附近的 App Store 查看游戏 *Square Ball*。

现在，随着游戏玩法逻辑的适当位置，我们可以继续制作这个游戏看起来更好！我们将在下一章中这样做。
