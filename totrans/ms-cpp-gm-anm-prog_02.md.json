["```cpp\nsudo apt install git \n```", "```cpp\ngit clone https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming \n```", "```cpp\nWindows Registry Editor Version 5.00\n [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem]\n \"LongPathsEnabled\"=dword:00000001 \n```", "```cpp\ngit clone https://github.com/assimp/assimp \n```", "```cpp\nC:\\Program Files\\assimp \n```", "```cpp\n    1> CMake generation finished. \n    ```", "```cpp\nsudo apt install libassimp-dev \n```", "```cpp\nsudo apt install git gcc g++ cmake ninja-build\n  libglew-dev libglm-dev libglfw3-dev zlib1g-dev \n```", "```cpp\nsudo apt install git llvm clang cmake ninja-build\n  libglew-dev libglm-dev libglfw3-dev zlib1g-dev \n```", "```cpp\nsudo apt install glslang-tools glslc libvulkan-dev vulkan-validationlayers \n```", "```cpp\nsudo pacman -S git cmake gcc ninja glew glm glfw assimp zlib \n```", "```cpp\nsudo pacman –S vulkan-devel glslang \n```", "```cpp\n$ cd chapter01/01_assimp_opengl\n$ mkdir build && cd build \n```", "```cpp\n$ cmake -G Ninja .. \n```", "```cpp\n$ ninja && ./Main \n```", "```cpp\n#include <assimp/scene.h>\n#include <assimp/Importer.hpp>\n#include <assimp/postprocess.h> \n```", "```cpp\n Assimp::Importer importer;\n  const aiScene *scene = importer.ReadFile(modelFilename,\n   aiProcess_Triangulate | aiProcess_GenNormals); \n```", "```cpp\n if(!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE ||\n      !scene->mRootNode) {\n    return false;\n  } \n```", "```cpp\n if (scene->HasTextures()) {\n    unsigned int numTextures = scene->mNumTextures;\n    for (int i = 0; i < scene->mNumTextures; ++i) { \n```", "```cpp\n std::string texName =\n        scene->mTextures[i]->mFilename.C_Str();\n      int height = scene->mTextures[i]->mHeight;\n      int width = scene->mTextures[i]->mWidth;\n      aiTexel* data = scene->mTextures[i]->pcData; \n```", "```cpp\n std::shared_ptr<Texture> newTex =\n        std::make_shared<Texture>();\n      if (!newTex->loadTexture(texName, data,\n          width, height)) {\n        return false;\n      } \n```", "```cpp\n std::string internalTexName = \"*\" + std::to_string(i);\n      mTextures.insert({internalTexName, newTex});\n  } \n```", "```cpp\n mPlaceholderTexture = std::make_shared<Texture>();\n  std::string placeholderTex = \"textures/missing_tex.png\";\n  if (!mPlaceholderTexture->loadTexture(placeholderTex)) {\n    return false;\n  } \n```", "```cpp\n std::string rootNodeName = rootNode->mName.C_Str();\n  mRootNode = AssimpNode::createNode(rootNodeName); \n```", "```cpp\n processNode(mRootNode, rootNode, scene, assetDirectory); \n```", "```cpp\n unsigned int numMeshes = aNode->mNumMeshes;\n    for (unsigned int i = 0; i < numMeshes; ++i) {\n      aiMesh* modelMesh = scene->mMeshes[aNode->mMeshes[i]]; \n```", "```cpp\n AssimpMesh mesh;\n      mesh.processMesh(modelMesh, scene, assetDirectory); \n```", "```cpp\n mModelMeshes.emplace_back(mesh.getMesh());\n      mTextures.merge(mesh.getTextures());\n      std::vector<std::shared_ptr<AssimpBone>> flatBones =\n        mesh.getBoneList();\n      mBoneList.insert(mBoneList.end(),\n        flatBones.begin(), flatBones.end());\n    }\n  } \n```", "```cpp\n mNodeMap.insert({nodeName, node});\n  mNodeList.emplace_back(node); \n```", "```cpp\n unsigned int numChildren = aNode->mNumChildren;\n  for (unsigned int i = 0; i < numChildren; ++i) {\n    std::string childName =\n      aNode->mChildren[i]->mName.C_Str();\n    std::shared_ptr<AssimpNode> childNode =\n      node->addChild(childName);\n    processNode(childNode, aNod->mChildren[i],\n      scene, assetDirectory);\n  } \n```", "```cpp\n for (auto mesh : mModelMeshes) {\n    VertexIndexBuffer buffer;\n    buffer.init();\n    buffer.uploadData(mesh.vertices, mesh.indices);\n    mVertexBuffers.emplace_back(buffer);\n  } \n```", "```cpp\n unsigned int numAnims = scene->mNumAnimations;\n  for (unsigned int i = 0; i < numAnims; ++i) {\n    const auto& animation = scene-> mAnimations[i]; \n```", "```cpp\n std::shared_ptr<AssimpAnimClip> animClip =\n      std::make_shared<AssimpAnimClip>();\n    animClip->addChannels(animation); \n```", "```cpp\n if (animClip->getClipName().empty()) {\n      animClip->setClipName(std::to_string(i));\n    } \n```", "```cpp\n mAnimClips.emplace_back(animClip);\n  } \n```", "```cpp\nFetchContent_Declare(\n  filedialog\n  GIT_REPOSITORY https://github.com/aiekick/ImGuiFileDialog\n  GIT_TAG        v0.6.7\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND \"\"\n) \n```", "```cpp\nget_property(current_compile_options DIRECTORY\n  PROPERTY COMPILE_OPTIONS)\nset_property(DIRECTORY PROPERTY\n  COMPILE_OPTIONS -I ${imgui_SOURCE_DIR}) \n```", "```cpp\nFetchContent_MakeAvailable(filedialog) \n```", "```cpp\nset_property(DIRECTORY PROPERTY\n  COMPILE_OPTIONS ${current_compile_options})\nunset(current_compile_options) \n```", "```cpp\n if (ImGui::Button(\"Import Model\")) {\n      IGFD::FileDialogConfig config;\n      config.path = \".\";\n      config.countSelectionMax = 1;\n      config.flags = ImGuiFileDialogFlags_Modal;\n      ImGuiFileDialog::Instance()->OpenDialog(\n        \"ChooseModelFile\", \"Choose Model File\", \".*\",\n        config);\n    } \n```", "```cpp\n if (ImGuiFileDialog::Instance()->Display(\n        \"ChooseModelFile\")) {\n      if (ImGuiFileDialog::Instance()->IsOk()) {\n      ...\n      }\n      ImGuiFileDialog::Instance()->Close();\n    } \n```", "```cpp\n\".*\" \n```", "```cpp\n\".jpg\" \n```", "```cpp\n\".jpg,.jpeg,.png\" \n```", "```cpp\n\"Supported Types{.gltf,.glb,.obj,.fbx,.dae}\" \n```", "```cpp\n\"Pictures{.jpg,.png},Models{.gltf,.glb},All Files{.*}\" \n```", "```cpp\n std::string filePathName =\n    ImGuiFileDialog::Instance()->GetFilePathName(); \n```", "```cpp\n if (modInstData.miModelAddCallbackFunction(\n      filePathName)) {\n    ...\n  } \n```", "```cpp\nusing modelAddCallback = std::function<bool(std::string)>; \n```", "```cpp\n mModelInstData.miModelAddCallbackFunction =\n    [this](std::string fileName) {\n     return addModel(fileName);\n   }; \n```", "```cpp\n for (const auto& channel : animChannels) {\n    std::string nodeNameToAnimate =\n      channel->getTargetNodeName();\n    std::shared_ptr<AssimpNode> node =\n      mAssimpModel->getNodeMap().at(nodeNameToAnimate); \n```", "```cpp\n node->setRotation(channel->getRotation(\n      mInstanceSettings.isAnimPlayTimePos));\n    node->setScaling(channel->getScaling(\n      mInstanceSettings.isAnimPlayTimePos));\n    node->setTranslation(channel->getTranslation(\n      mInstanceSettings.isAnimPlayTimePos));\n  } \n```", "```cpp\n mAssimpMode->getNodeMap().at(\n      mAssimpModel→getBoneList().at(0)->getBoneName()\n    ->setRootTransformMatrix(\n    mLocalTransformMatrix *\n    mAssimpModel->getRootTranformationMatrix()); \n```", "```cpp\n mBoneMatrices.clear();\n  for (auto& bone : mAssimpModel->getBoneList()) {\n    std::string nodeName = bone->getBoneName();\n    std::shared_ptr<AssimpNode> node =\n      mAssimpModel->getNodeMap().at(nodeName); \n```", "```cpp\n node->updateTRSMatrix(); \n```", "```cpp\n if (mAssimpModel->getBoneOffsetMatrices().count(\n        nodeName) > 0) {\n      mBoneMatrices.emplace_back(\n        mAssimpModel->getNodeMap().at(\n        nodeName)->getTRSMatrix() *\n        mAssimpModel\n->getBoneOffsetMatrices().at(nodeName));\n      }\n  } \n```", "```cpp\nstruct InstanceSettings {\n  glm::vec3 isWorldPosition = glm::vec3(0.0f);\n  glm::vec3 isWorldRotation = glm::vec3(0.0f);\n  float isScale = 1.0f;\n  bool isSwapYZAxis = false;\n  unsigned int isAnimClipNr = 0;\n  float isAnimPlayTimePos = 0.0f;\n  float isAnimSpeedFactor = 1.0f;\n}; \n```", "```cpp\nstruct ModelAndInstanceData {\n  std::vector<std::shared_ptr<AssimpModel>> miModelList{};\n  int miSelectedModel = 0; \n```", "```cpp\n std::vector<std::shared_ptr<AssimpInstance>>\n    miAssimpInstances{};\n  std::unordered_map<std::string,\n    std::vector<std::shared_ptr<AssimpInstance>>>\n  miAssimpInstancesPerModel{};\n  int miSelectedInstance = 0; \n```", "```cpp\n modelCheckCallback miModelCheckCallbackFunction;\n  modelAddCallback miModelAddCallbackFunction;\n  modelDeleteCallback miModelDeleteCallbackFunction;\n  instanceAddCallback miInstanceAddCallbackFunction;\n  instanceDeleteCallback miInstanceDeleteCallbackFunction;\n}; \n```", "```cpp\nusing modelCheckCallback = std::function<bool(std::string)>;\nusing modelAddCallback = std::function<bool(std::string)>;\nusing modelDeleteCallback =\n  std::function<void(std::string)>;\nusing instanceAddCallback =\n std::function<std::shared_ptr<\n AssimpInstance>(std::shared_ptr<AssimpModel>)>;\nusing instanceDeleteCallback =\n  std::function<void(std::shared_ptr<AssimpInstance>)>; \n```", "```cpp\nbool OGLRenderer::addModel(std::string modelFileName) {\n  if (hasModel(modelFileName)) {\n    return false;\n  } \n```", "```cpp\n std::shared_ptr<AssimpModel> model =\n    std::make_shared<AssimpModel>();\n  if (!model->loadModel(modelFileName)) {\n    return false;\n  } \n```", "```cpp\n mModelInstData.miModelList.emplace_back(model); \n```", "```cpp\n addInstance(model);\n  return true; \n```", "```cpp\nstd::shared_ptr<AssimpInstance>\n  OGLRenderer::addInstance(std::shared_ptr<AssimpModel>\n    model) { \n```", "```cpp\n std::shared_ptr<AssimpInstance> newInstance =\n    std::make_shared<AssimpInstance>(model); \n```", "```cpp\nmModelInstData.miAssimpInstances.emplace_back(newInstance);\nmModelInstData.miAssimpInstancesPerModel[\n  model->getModelFileName()\n  ].emplace_back(newInstance); \n```", "```cpp\n updateTriangleCount();\n  return newInstance;\n} \n```"]