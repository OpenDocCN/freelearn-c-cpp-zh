["```cpp\n-----\nPython 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0]\nLinux-5.19.0-43-generic-x86_64-with-glibc2.35\n-----\nIPython             8.13.2\njupyter_client      8.2.0\njupyter_core        5.3.0\nnotebook            6.5.4\n-----\nhvplot              0.8.3\nnumpy               1.24.3\npandas              2.0.1\nplotly              5.14.1\n-----\n```", "```cpp\nexchange_order_server.log:18:48:29.452140238 RDTSC Exchange_FIFOSequencer_addClientRequest 26\ntrading_engine_1.log:18:48:29.480664387 RDTSC Trading_FeatureEngine_onOrderBookUpdate 39272\ntrading_engine_1.log:18:48:29.480584410 RDTSC Trading_MarketOrderBook_addOrder 176\ntrading_engine_1.log:18:48:29.480712854 RDTSC Trading_OrderManager_moveOrder 32\ntrading_engine_1.log:18:48:29.254832602 RDTSC Trading_PositionKeeper_addFill 94350\ntrading_engine_1.log:18:48:29.480492650 RDTSC Trading_RiskManager_checkPreTradeRisk 1036\n...\n```", "```cpp\ntrading_engine_1.log:18:48:29.440526826 TTT T10_TradeEngine_LFQueue_write 1686008909440526763\nexchange_order_server.log:18:48:29.452087295 TTT T1_OrderServer_TCP_read 1686008909452087219\nexchange_market_data_publisher.log:18:48:29.467680305 TTT T5_MarketDataPublisher_LFQueue_read 1686008909467680251\ntrading_market_data_consumer_1.log:18:48:29.478030090 TTT T8_MarketDataConsumer_LFQueue_write 1686008909478029956\ntrading_engine_1.log:18:48:29.480552551 TTT T9_TradeEngine_LFQueue_read 1686008909480552495\n...\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ jupyter notebook\n...\n    To access the notebook, open this file in a browser:\n        file:///home/sghosh/.local/share/jupyter/runtime/nbserver-182382-open.html\n    Or copy and paste one of these URLs:\n        http://localhost:8888/?token=d28e3bd3b1f8109b12afe1210ae8c494c7 7a4128e23bdae7\n     or http://127.0.0.1:8888/?token=d28e3bd3b1f8109b12afe1210ae8c494c7 7a4128e23bdae7\n```", "```cpp\n    auto deallocate(const T *elem) noexcept {\n      const auto elem_index = (reinterpret_cast<const\n         ObjectBlock *>(elem) - &store_[0]);\n#if !defined(NDEBUG)\n      ASSERT(elem_index >= 0 && static_cast<size_t>\n       (elem_index) < store_.size(), \"Element being\n      deallocated does not belong to this Memory pool.\");\n      ASSERT(!store_[elem_index].is_free_, \"Expected in-use\n         ObjectBlock at index:\" + std::\n            to_string(elem_index));\n#endif\n      store_[elem_index].is_free_ = true;\n    }\n```", "```cpp\n    auto sequenceAndPublish() {\n      ...\n#if !defined(NDEBUG)\n      logger_->log(\"%:% %() % Processing % requests.\\n\",\n          __FILE__, __LINE__, __FUNCTION__, Common::\n            getCurrentTimeStr(&time_str_), pending_size_);\n#endif\n      ...\n      for (size_t i = 0; i < pending_size_; ++i) {\n        const auto &client_request =\n           pending_client_requests_.at(i);\n#if !defined(NDEBUG)\n        logger_->log(\"%:% %() % Writing RX:% Req:% to\n         FIFO.\\n\", __FILE__, __LINE__, __FUNCTION__,\n          Common::getCurrentTimeStr(&time_str_),\n                     client_request.recv_time_,\n                        client_request.request_.toString());\n#endif\n    ...\n    }\n```", "```cpp\n    auto pushValue(const char *value) noexcept {\n      while (*value) {\n        pushValue(*value);\n        ++value;\n      }\n    }\n```", "```cpp\n  enum class LogType : int8_t {\n    ...\n    DOUBLE = 8,\n    STRING = 9\n  };\n```", "```cpp\n  struct LogElement {\n    LogType type_ = LogType::CHAR;\n    union {\n      ...\n      double d;\n      char str[SOME_SIZE];\n    } u_;\n  };\n```", "```cpp\n    std::function<void(McastSocket *s)> recv_callback_;\n    ```", "```cpp\n    std::function<void(TCPSocket *s, Nanos rx_time)> recv_callback_;\n    ```", "```cpp\n    std::function<void()> recv_finished_callback_;\n    ```", "```cpp\n    std::function<void(TCPSocket *s, Nanos rx_time)> recv_callback_;\n    ```", "```cpp\n    std::function<void(TickerId ticker_id, Price price, Side side, MarketOrderBook *book)> algoOnOrderBookUpdate_;\n    ```", "```cpp\n    std::function<void(const Exchange::MEMarketUpdate *market_update, MarketOrderBook *book)> algoOnTradeUpdate_;\n    ```", "```cpp\n    std::function<void(const Exchange::MEClientResponse *client_response)> algoOnOrderUpdate_;\n    ```", "```cpp\n    auto pushValue(const char *value) noexcept {\n      LogElement l{LogType::STRING, {.s = {}}};\n      strncpy(l.u_.s, value, sizeof(l.u_.s) - 1);\n      pushValue(l);\n    }\n```", "```cpp\n#include \"common/logging.h\"\n#include \"common/opt_logging.h\"\n```", "```cpp\nstd::string random_string(size_t length) {\n  auto randchar = []() -> char {\n    const char charset[] =\n        \"0123456789\"\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz\";\n    const size_t max_index = (sizeof(charset) - 1);\n    return charset[rand() % max_index];\n  };\n  std::string str(length, 0);\n  std::generate_n(str.begin(), length, randchar);\n  return str;\n}\n```", "```cpp\ntemplate<typename T>\nsize_t benchmarkLogging(T *logger) {\n  constexpr size_t loop_count = 100000;\n  size_t total_rdtsc = 0;\n  for (size_t i = 0; i < loop_count; ++i) {\n    const auto s = random_string(128);\n    const auto start = Common::rdtsc();\n    logger->log(\"%\\n\", s);\n    total_rdtsc += (Common::rdtsc() - start);\n  }\n  return (total_rdtsc / loop_count);\n}\n```", "```cpp\nint main(int, char **) {\n  using namespace std::literals::chrono_literals;\n  {\n    Common::Logger logger(\"logger_benchmark_original.log\");\n    const auto cycles = benchmarkLogging(&logger);\n    std::cout << \"ORIGINAL LOGGER \" << cycles << \" CLOCK\n      CYCLES PER OPERATION.\" << std::endl;\n    std::this_thread::sleep_for(10s);\n  }\n  {\n    OptCommon::OptLogger opt_logger\n      (\"logger_benchmark_optimized.log\");\n    const auto cycles = benchmarkLogging(&opt_logger);\n    std::cout << \"OPTIMIZED LOGGER \" << cycles << \" CLOCK\n      CYCLES PER OPERATION.\" << std::endl;\n    std::this_thread::sleep_for(10s);\n  }\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/logger_benchmark\nORIGINAL LOGGER 25757 CLOCK CYCLES PER OPERATION.\nOPTIMIZED LOGGER 466 CLOCK CYCLES PER OPERATION.\n```", "```cpp\n    template<typename... Args>\n    T *allocate(Args... args) noexcept {\n      auto obj_block = &(store_[next_free_index_]);\n#if !defined(NDEBUG)\n      ASSERT(obj_block->is_free_, \"Expected free\n        ObjectBlock at index:\" + std::to_string\n          (next_free_index_));\n#endif\n      ...\n    }\n    auto deallocate(const T *elem) noexcept {\n      const auto elem_index = (reinterpret_cast<const\n        ObjectBlock *>(elem) - &store_[0]);\n#if !defined(NDEBUG)\n      ASSERT(elem_index >= 0 && static_cast\n        <size_t>(elem_index) < store_.size(), \"Element\n          being deallocated does not belong to this Memory\n            pool.\");\n      ASSERT(!store_[elem_index].is_free_, \"Expected in-use\n        ObjectBlock at index:\" + std::to_string\n          (elem_index));\n#endif\n      ...\n    }\n```", "```cpp\n#include \"common/mem_pool.h\"\n#include \"common/opt_mem_pool.h\"\n#include \"common/perf_utils.h\"\n#include \"exchange/market_data/market_update.h\"\n```", "```cpp\ntemplate<typename T>\nsize_t benchmarkMemPool(T *mem_pool) {\n  constexpr size_t loop_count = 100000;\n  size_t total_rdtsc = 0;\n  std::array<Exchange::MDPMarketUpdate*, 256>\n    allocated_objs;\n  for (size_t i = 0; i < loop_count; ++i) {\n    for(size_t j = 0; j < allocated_objs.size(); ++j) {\n      const auto start = Common::rdtsc();\n      allocated_objs[j] = mem_pool->allocate();\n      total_rdtsc += (Common::rdtsc() - start);\n    }\n    for(size_t j = 0; j < allocated_objs.size(); ++j) {\n      const auto start = Common::rdtsc();\n      mem_pool->deallocate(allocated_objs[j]);\n      total_rdtsc += (Common::rdtsc() - start);\n    }\n  }\n  return (total_rdtsc / (loop_count *\n    allocated_objs.size()));\n}\n```", "```cpp\nint main(int, char **) {\n  {\n    Common::MemPool<Exchange::MDPMarketUpdate>\n      mem_pool(512);\n    const auto cycles = benchmarkMemPool(&mem_pool);\n    std::cout << \"ORIGINAL MEMPOOL \" << cycles << \" CLOCK\n      CYCLES PER OPERATION.\" << std::endl;\n  }\n  {\n    OptCommon::OptMemPool<Exchange::MDPMarketUpdate>\n      opt_mem_pool(512);\n    const auto cycles = benchmarkMemPool(&opt_mem_pool);\n    std::cout << \"OPTIMIZED MEMPOOL \" << cycles << \" CLOCK\n      CYCLES PER OPERATION.\" << std::endl;\n  }\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/release_benchmark\nORIGINAL MEMPOOL 343 CLOCK CYCLES PER OPERATION.\nOPTIMIZED MEMPOOL 44 CLOCK CYCLES PER OPERATION.\n```", "```cpp\n#include <unordered_map>\n```", "```cpp\nnamespace Exchange {\n  class UnorderedMapMEOrderBook final {\n  private:\n    ...\n    std::unordered_map<ClientId, std::\n      unordered_map<OrderId, MEOrder *>> cid_oid_to_order_;\n    std::unordered_map<Price, MEOrdersAtPrice *>\n      price_orders_at_price_;\n    ...\n  };\n}\n```", "```cpp\n  MEOrderBook::~MEOrderBook() {\n    …\n    for (auto &itr: cid_oid_to_order_) {\n      itr.fill(nullptr);\n    }\n  }\n```", "```cpp\n    auto removeOrder(MEOrder *order) noexcept {\n      ...\n      cid_oid_to_order_[order->client_id_][order->\n        client_order_id_] = nullptr;\n      order_pool_.deallocate(order);\n    }\n    auto addOrder(MEOrder *order) noexcept {\n      ...\n      cid_oid_to_order_[order->client_id_][order->\n        client_order_id_] = order;\n    }\n  auto UnorderedMapMEOrderBook::cancel(ClientId client_id,\n    OrderId order_id, TickerId ticker_id) noexcept -> void {\n    auto is_cancelable = (client_id <\n      cid_oid_to_order_.size());\n    MEOrder *exchange_order = nullptr;\n    if (LIKELY(is_cancelable)) {\n      auto &co_itr = cid_oid_to_order_[client_id];\n      exchange_order = co_itr[order_id];\n      is_cancelable = (exchange_order != nullptr);\n    }\n    ...\n  }\n```", "```cpp\n    auto getOrdersAtPrice(Price price) const noexcept ->\n      MEOrdersAtPrice * {\n      if(price_orders_at_price_.find(priceToIndex(price))\n        == price_orders_at_price_.end())\n        return nullptr;\n      return price_orders_at_price_\n        .at(priceToIndex(price));\n    }\n    auto addOrdersAtPrice(MEOrdersAtPrice\n      *new_orders_at_price) noexcept {\n      price_orders_at_price_\n        [priceToIndex(new_orders_at_price->price_)] =\n          new_orders_at_price;\n      ...\n    }\n    auto removeOrdersAtPrice(Side side, Price price)\n      noexcept {\n      ...\n      price_orders_at_price_[priceToIndex(price)] =\n        nullptr;\n      orders_at_price_pool_.deallocate(orders_at_price);\n    }\n```", "```cpp\n#include \"matcher/matching_engine.h\"\n#include \"matcher/unordered_map_me_order_book.h\"\nstatic constexpr size_t loop_count = 100000;\n```", "```cpp\ntemplate<typename T>\nsize_t benchmarkHashMap(T *order_book, const\n  std::vector<Exchange::MEClientRequest>& client_requests) {\n  size_t total_rdtsc = 0;\n  for (size_t i = 0; i < loop_count; ++i) {\n    const auto& client_request = client_requests[i];\n    switch (client_request.type_) {\n      case Exchange::ClientRequestType::NEW: {\n        const auto start = Common::rdtsc();\n        order_book->add(client_request.client_id_,\n          client_request.order_id_,\n            client_request.ticker_id_,\n                        client_request.side_,\n                          client_request.price_,\n                            client_request.qty_);\n        total_rdtsc += (Common::rdtsc() - start);\n      }\n        break;\n      case Exchange::ClientRequestType::CANCEL: {\n        const auto start = Common::rdtsc();\n        order_book->cancel(client_request.client_id_,\n          client_request.order_id_,\n            client_request.ticker_id_);\n        total_rdtsc += (Common::rdtsc() - start);\n      }\n        break;\n      default:\n        break;\n    }\n  }\n  return (total_rdtsc / (loop_count * 2));\n}\n```", "```cpp\nint main(int, char **) {\n  srand(0);\n  Common::Logger logger(\"hash_benchmark.log\");\n  Exchange::ClientRequestLFQueue\n    client_requests(ME_MAX_CLIENT_UPDATES);\n  Exchange::ClientResponseLFQueue\n    client_responses(ME_MAX_CLIENT_UPDATES);\n  Exchange::MEMarketUpdateLFQueue\n    market_updates(ME_MAX_MARKET_UPDATES);\n  auto matching_engine = new Exchange::\n    MatchingEngine(&client_requests, &client_responses,\n      &market_updates);\n```", "```cpp\n  Common::OrderId order_id = 1000;\n  std::vector<Exchange::MEClientRequest>\n    client_requests_vec;\n  Price base_price = (rand() % 100) + 100;\n  while (client_requests_vec.size() < loop_count) {\n    const Price price = base_price + (rand() % 10) + 1;\n    const Qty qty = 1 + (rand() % 100) + 1;\n    const Side side = (rand() % 2 ? Common::Side::BUY :\n      Common::Side::SELL);\n    Exchange::MEClientRequest new_request\n      {Exchange::ClientRequestType::NEW, 0, 0, order_id++,\n        side, price, qty};\n    client_requests_vec.push_back(new_request);\n    const auto cxl_index = rand() %\n      client_requests_vec.size();\n    auto cxl_request = client_requests_vec[cxl_index];\n    cxl_request.type_ =\n      Exchange::ClientRequestType::CANCEL;\n    client_requests_vec.push_back(cxl_request);\n  }\n```", "```cpp\n  {\n    auto me_order_book = new Exchange::MEOrderBook(0,\n      &logger, matching_engine);\n    const auto cycles = benchmarkHashMap(me_order_book,\n      client_requests_vec);\n    std::cout << \"ARRAY HASHMAP \" << cycles << \" CLOCK\n      CYCLES PER OPERATION.\" << std::endl;\n  }\n  {\n    auto me_order_book = new Exchange::\n      UnorderedMapMEOrderBook(0, &logger, matching_engine);\n    const auto cycles = benchmarkHashMap(me_order_book,\n      client_requests_vec);\n    std::cout << \"UNORDERED-MAP HASHMAP \" << cycles << \"\n      CLOCK CYCLES PER OPERATION.\" << std::endl;\n  }\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/hash_benchmark\nSet core affinity for Common/Logger hash_benchmark.log 140327631447616 to -1\nSet core affinity for Common/Logger exchange_matching_engine.log 140327461033536 to -1\nARRAY HASHMAP 142650 CLOCK CYCLES PER OPERATION.\nUNORDERED-MAP HASHMAP 152457 CLOCK CYCLES PER OPERATION.\n```", "```cpp\n    auto recvCallback(TCPSocket *socket, Nanos rx_time)       noexcept {\n      ...\n      if (socket->next_rcv_valid_index_ >=         sizeof(OMClientRequest)) {\n          ...\n          if (cid_tcp_socket_[request->            me_client_request_.client_id_] != socket) {\n            ...\n            continue;\n          }\n          auto &next_exp_seq_num =             cid_next_exp_seq_num_[request->              me_client_request_.client_id_];\n          if (request->seq_num_ != next_exp_seq_num) {\n            ...\n            continue;\n          }\n          ...\n        }\n        ...\n      }\n    }\n```"]