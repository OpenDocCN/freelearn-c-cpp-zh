<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor076"/>5</h1>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>The Significance of Naming</h1>
<p>As you delve deeper into the world of C++, or any other programming language for that matter, one thing becomes increasingly clear – the power of a name. In this chapter, we will explore the profound importance of naming conventions in writing clean, maintainable, and efficient C++ code.</p>
<p>In computer programming, names are given to variables, functions, classes, and numerous other entities. These names serve as identifiers, playing a pivotal role in how we, as programmers, interact with the components of our code. While it may seem a trivial matter to some, choosing the right names can have a profound impact on the understandability and maintainability of a software project. The names we choose to represent the different elements of our program are the first layer of documentation that anyone, including our future selves, has when they approach our code.</p>
<p>Imagine a developer named Mia who works with a class named <code>WeatherData</code>. This class has two getter methods – <code>get_tempreture()</code> and <code>get_humidity()</code>. The former method simply returns the current temperature value stored in a member variable. It’s an O(1) operation, since it involves returning an already-stored value. The latter does more than just return a value. It actually initiates a connection to a remote weather service, retrieves the latest humidity data, and then returns it. This operation is considerably costly, involving network communication and data processing, making it far from an O(1) operation. Mia, focusing on optimizing a function in the project, sees these two getters and assumes they are similar in terms of efficiency due to their naming. She uses <code>get_humidity()</code> within a loop, expecting it to be a simple, efficient retrieval of a stored value, similar to <code>get_temperature()</code>. The performance of the function plummets due to the repeated, expensive calls to <code>get_humidity()</code>. The network requests and data processing involved in each call significantly slow down the execution, leading to an inefficient use of resources and a slowdown in the application’s performance. This could have been avoided if the method had been named <code>fetch_humidity()</code> instead of <code>get_humidity()</code>. The name <code>fetch_humidity()</code> would have made it clear that the method is not a simple getter but, rather, a more expensive operation that involves fetching data from a remote service.</p>
<p>The art of naming requires careful consideration and a good understanding of both the problem domain and the programming language. This chapter provides a comprehensive discussion of the general approach to creating and naming variables, class members, methods, and functions in C++. We will debate the trade-offs of long names versus short names, as well as the role of comments in clarifying our intentions.</p>
<p>We will explore the importance of coding conventions and the benefits they bring to individual developers and teams alike. Consistent application of a well-thought-out naming convention can streamline the coding process, reduce errors, and greatly enhance the readability of the code base.</p>
<p>By the end of this chapter, you will understand why good naming practices are not just an afterthought but also an essential component of good software development. We will equip you with strategies and conventions to help you write code that can be easily read, understood, and maintained by others – and by you, when you revisit your own code months or years down the line.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>General naming principles</h1>
<p>Regardless of <a id="_idIndexMarker171"/>the specific <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) language you’re using, certain universal <a id="_idIndexMarker172"/>naming principles can help improve the clarity and maintainability of your code. These principles aim to ensure that names in your code provide sufficient information about their use and functionality.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Descriptiveness</h2>
<p>Names should<a id="_idIndexMarker173"/> accurately describe the purpose or value of the variable, function, class, or method they are identifying. For instance, <code>getSalary()</code> for a function is more informative than simply <code>getS()</code>.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Consistency</h2>
<p>Consistency in<a id="_idIndexMarker174"/> naming <a id="_idIndexMarker175"/>conventions is one of the most vital principles in writing clear and maintainable code. When you’re consistent with your naming throughout your code base, it becomes much easier to read, understand, and debug your code. The reason for this is that once a developer learns your naming pattern, they can apply their understanding across the entire code base, rather than having to figure out what each individual name means in isolation.</p>
<p>Consistency applies to many areas, including the following:</p>
<ul>
<li><code>snake_case</code> (e.g., <code>employee_salary</code>), stick to that style throughout your entire code base. Don’t switch between snake_case, camelCase (e.g., <code>employeeSalary</code>), and PascalCase (e.g., <code>EmployeeSalary</code>).</li>
<li><code>m_</code> for member variables (e.g., <code>m_value</code>), ensure this rule is followed everywhere.</li>
<li><code>num</code> to represent <code>number</code> (as in <code>numEmployees</code>), then always use <code>num</code> whenever you mean <code>number</code>.</li>
<li><code>Employee</code>), method names are verbs (<code>calculateSalary</code>), and Boolean variables or methods often start with <code>is</code>, <code>has</code>, <code>can</code>, or similar prefixes (<code>isAvailable</code> and <code>hasCompleted</code>). Stick with these conventions consistently.</li>
</ul>
<p>Let’s say <a id="_idIndexMarker176"/>you’re <a id="_idIndexMarker177"/>working on a large code base where classes represent various types of employees in a company. You’ve decided to name your classes as singular nouns in PascalCase, methods as verbs in snake_case, and variables in snake_case too.</p>
<p>A consistent implementation of this naming convention might look like this:</p>
<pre class="source-code">
class SoftwareEngineer {
public:
    void assign_task(std::string task_name) {
        current_task_ = std::move(task_name);
    }
private:
    std::string current_task_;
};</pre>
<p>Let’s break down this code snippet:</p>
<ul>
<li>The <code>SoftwareEngineer</code> class is a singular noun and uses PascalCase</li>
<li>The <code>assign_task</code> method is a verb and uses snake_case</li>
<li>The variable <code>current_task</code> is in snake_case</li>
</ul>
<p>Being consistent with this convention will help anyone reading your code to immediately recognize what each name represents. This way, the cognitive load is reduced, and <a id="_idIndexMarker178"/>developers can focus on the actual logic, rather than<a id="_idIndexMarker179"/> being distracted by inconsistent or confusing names.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Unambiguity</h2>
<p>Unambiguity<a id="_idIndexMarker180"/> means that<a id="_idIndexMarker181"/> names should not be misleading. Avoid using names that could be interpreted in multiple ways, or that contradict established conventions or expectations. For example, suppose you have a <code>Document</code> class and a method named <code>process</code>. Without more context, the method name is ambiguous:</p>
<pre class="source-code">
class Document {
public:
    void process();
};</pre>
<p>In this case, <code>process</code> could mean a number of things. Are we going to parse the document? Are we going to render it? Are we going to save it to a file? Or are we going to perform all these operations? It’s unclear.</p>
<p>A more specific method name could help to clarify its purpose. Depending on what the method is supposed to do, it could be named <code>parse</code>, <code>render</code>, <code>save</code>, and so on:</p>
<pre class="source-code">
class Document {
public:
    void parse(const std::string&amp; content);
    void render();
    void save(const std::string&amp; file_path);
};</pre>
<p>Each of these method names gives a much clearer indication of what the method does, removing the <a id="_idIndexMarker182"/>ambiguity of the original <code>process</code> method<a id="_idIndexMarker183"/> name.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Pronounceability</h2>
<p>Names should be<a id="_idIndexMarker184"/> easily pronounceable. This facilitates verbal communication about the code between developers.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Scope and lifetimes</h2>
<p> Variables with larger<a id="_idIndexMarker185"/> scopes and longer lifetimes usually have more influence on a system and, hence, deserve more thoughtful, clear, and descriptive names. This helps ensure that they’re understood in all contexts where they’re used. Here’s a more detailed breakdown.</p>
<p>Global variables can be accessed from anywhere in a program, and their lifetime extends for the duration of the program. Therefore, they deserve especially careful consideration when naming. The name should be descriptive enough to clearly indicate its role in the system. Additionally, global variables can create unexpected dependencies, which makes the program harder to understand and maintain. Therefore, the use of global variables should be minimized:</p>
<pre class="source-code">
// Global variable
constexpr double GRAVITATIONAL_ACCELERATION = 9.8; // Clear and descriptive</pre>
<p>Class member variables can be accessed from any method within the class, and their lifetime is tied to the lifetime of the class instance. They should have clear and descriptive names that reflect their role within the class. It’s often useful to follow a naming convention that distinguishes them from local variables (e.g., an <code>m_</code> prefix or <code>_</code> suffix):</p>
<pre class="source-code">
class PhysicsObject {
    double mass_;  // Descriptive and follows naming convention
    // ...
};</pre>
<p>Local variables are confined to a specific function or block and exist only for the duration of that function or block. These variables typically need less descriptive names compared to global variables or class members, but they should still clearly convey their purpose:</p>
<pre class="source-code">
double compute_force(double mass, double acceleration) {
    double force = mass * acceleration;  // 'force' is clear in this context
    return force;
}</pre>
<p>Loop variables and temporary variables have the shortest scope and lifetime, usually confined to a small loop or a small block of code. As a result, they typically have the simplest names (such as <code>i</code>, <code>j</code>, and <code>temp</code>):</p>
<pre class="source-code">
for (int i = 0; i &lt; num; ++i) {  // 'i' is clear in this context
    // ...
}</pre>
<p>The key idea here is, the broader the scope and the longer the lifetime of a variable, the more potential<a id="_idIndexMarker186"/> there is for confusion about its purpose, so the more descriptive its name should be. The goal is to make code as clear and understandable as possible.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Avoid encoding type or scope information</h2>
<p>In modern<a id="_idIndexMarker187"/> programming languages, encoding type or scope information into names (often known as Hungarian notation) is usually unnecessary and can lead to confusion or errors, especially when refactoring. While this can occasionally be helpful, especially in languages with weak typing, it has several downsides that make it less suitable for use in strongly typed languages such as C++:</p>
<ul>
<li>The type of a variable might change in the future, but its name often doesn’t. This leads to misleading situations where a variable’s name suggests one type but it actually has another. For example, you might start with a vector of IDs (<code>std::vector&lt;Id&gt; id_array</code>) and later change it to <code>set&lt;Id&gt;</code> to avoid duplication, but the variable name still suggests it’s an array or vector.</li>
<li>Modern development environments provide features such as type inference, hovering tooltips showing types, and powerful refactoring tools, which all make manually encoding types into names largely redundant. For example, VS Code with the clangd plugin installed and the “inlay hints” feature turned on deducts types on<a id="_idIndexMarker188"/> the fly, including <code>auto</code>:</li>
</ul>
<div><div><img alt="Figure 5.1 – Inlay hints in VS Code" src="img/B19606_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Inlay hints in VS Code</p>
<p>This applies to CLion by JetBrains too:</p>
<ul>
<li>Prefixes in Hungarian notation can make variable names harder to read, especially for those not familiar with the notation. It may not be immediately obvious to a new developer what <code>dwCount</code> (a <code>DWORD</code>, or double word, often used to represent an unsigned long integer) means.</li>
<li>Strongly typed languages such as C++ already check type safety at compile time, reducing the need to encode type information in the variable name. In the following example, <code>integers</code> is declared as <code>std::vector&lt;int&gt;</code>, and <code>sentence</code> is declared as <code>std::string</code>. The C++ compiler is aware of these types and will<a id="_idIndexMarker189"/> ensure that operations on these variables are type-safe:</li>
</ul>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;string&gt;
int main() {
    std::vector&lt;int&gt; integers;
    std::string sentence;
    // The following will cause a compile-time error because
    // the type of 'sentence' is string, not vector&lt;int&gt;.
    integers = sentence;
    return 0;
}</pre>
<p>When the code attempts to assign <code>sentence</code> to <code>integers</code>, a compile-time error is produced because <code>sentence</code> is not of the correct type (<code>std::vector&lt;int&gt;</code>). This happens despite the fact that neither of the variable names encode type information.</p>
<p>The compiler’s type-checking eliminates the need to include the type in the variable names (such as <code>strSentence</code> or <code>vecIntegers</code>), a practice common in languages that do not perform such strong compile-time type-checking. The <code>integers</code> and <code>sentence</code> variable names are sufficiently descriptive without encoding the type information.</p>
<p>In programming, you often come across situations where multiple logical concepts are represented using the same underlying type. For instance, you may have identifiers for <code>Users</code> and <code>Products</code> in your system, both of which are represented as integers. While C++’s static type checking provides a level of safety, it won’t differentiate between <code>UserId</code> and <code>ProductId</code> – they’re both just integers as far as the compiler is concerned.</p>
<p>However, using the same type for these different concepts can lead to bugs. It’s entirely possible, for example, to mistakenly pass <code>UserId</code> where <code>ProductId</code> was expected, and the compiler wouldn’t catch this error.</p>
<p>To address this issue, you can leverage C++’s rich type system to introduce new types representing these different concepts, even when they share the same underlying representation. This way, the compiler can catch these bugs at compile time, enhancing the robustness <a id="_idIndexMarker190"/>of your software:</p>
<pre class="source-code">
// Define new types for User and Product IDs.
struct UserId {
    explicit UserId(int id): value(id) {}
    int value;
};
struct ProductId {
    explicit ProductId(int id): value(id) {}
    int value;
};
void process_user(UserId id) {
    // Processing user...
}
void process_product(ProductId id) {
    // Processing product...
}
int main() {
    UserId user_id(1);
    ProductId product_id(2);
    // The following line would cause a compile-time error because
    // a ProductId is being passed to process_user.
    process_user(product_id);
    return 0;
}</pre>
<p>In the preceding example, <code>UserId</code> and <code>ProductId</code> are distinct types. Even though their underlying representation is the same (<code>int</code>), passing <code>ProductId</code> to a function expecting <code>UserId</code> results in a compile-time error. This adds an additional layer of type safety to your code.</p>
<p>This is just a glimpse into how you can utilize C++’s rich static type system to create more robust <a id="_idIndexMarker191"/>and safer code. We will delve into this topic in more detail in <a href="B19606_06.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>,<em class="italic"> Utilizing a Rich Static Type System </em><em class="italic">in C++</em>.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Class and method naming</h2>
<p>In OOP languages, classes<a id="_idIndexMarker192"/> represent concepts or things, and their instances (objects) are specific manifestations of those things. As such, both class names and their instances are most appropriately named using nouns or noun phrases. They represent entities in the system, whether they’re tangible (such as <code>Employee</code> and <code>Invoice</code>) or conceptual (such as <code>Transaction</code> and <code>DatabaseConnection</code>).</p>
<p>On the other hand, methods in classes typically represent actions that an object of that class can perform, or messages that can be sent to it. As such, they’re most effectively named using verbs or verb phrases. They act as instructions that can be carried out by the object, allowing it to interact with other objects in meaningful ways.</p>
<p>Consider a <code>Document</code> class with a <code>print</code> method. We can say “document, print” or “print the document,” which is a clear, imperative statement in line with how we might communicate the action in everyday language.</p>
<p>Here’s an example:</p>
<pre class="source-code">
class Document {
public:
    void print();
};
Document report;
report.print();  // "report, print!"</pre>
<p>This noun-verb consistency in naming classes and methods aligns well with the way we naturally understand and communicate about objects and actions in the real world, contributing to the readability and comprehensibility of our code. Moreover, it lends itself well to the principle of encapsulation in OOP, where objects manage their own behavior (methods) and state (member variables).</p>
<p>Maintaining this convention allows developers to write code that’s more intuitive, self-documenting, and easier to maintain. It creates a common language and understanding among <a id="_idIndexMarker193"/>developers, reducing the cognitive load when reading code and making the code base easier to navigate and reason about. Therefore, it’s recommended to adhere to these conventions in OOP.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Naming variables</h2>
<p>Variable<a id="_idIndexMarker194"/> names<a id="_idIndexMarker195"/> should reflect the data they hold. A good variable name describes the kind of value the variable contains, not just its purpose in the algorithm you’ve written.</p>
<p>Avoiding magic numbers, Numerical values with unexplained meanings in the source code. They can lead to code that is harder to read, understand, and maintain. Let’s consider a <code>MessageSender</code> class that sends messages, and if a message size is greater than a certain limit, it splits the message into chunks:</p>
<pre class="source-code">
class MessageSender {
public:
    void send_message(const std::string&amp; message) {
        if (message.size() &gt; 1024) {
            // Split the message into chunks and send
        } else {
            // Send the message
        }
    }
};</pre>
<p>In the preceding code, <code>1024</code> is a magic number. It likely represents a maximum message size, but<a id="_idIndexMarker196"/> it’s not immediately clear. It can confuse <a id="_idIndexMarker197"/>others (or future you) reading your code. Here’s a refactored example with a named constant:</p>
<pre class="source-code">
class MessageSender {
    constexpr size_t MAX_MESSAGE_SIZE = 1024;
public:
    void send_message(const std::string&amp; message) {
        if (message.size() &gt; MAX_MESSAGE_SIZE) {
            // Split the message into chunks and send
        } else {
            // Send the message
        }
    }
};</pre>
<p>In this refactored version, we’ve replaced the magic number <code>1024</code> with a named constant, <code>MAX_MESSAGE_SIZE</code>. It’s now clear that <code>1024</code> is the maximum message size. Using named constants in this way makes your code more readable and maintainable. If the <a id="_idIndexMarker198"/>maximum message size needs to change in<a id="_idIndexMarker199"/> the future, you only need to update it in one place.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Utilize namespaces</h2>
<p>Namespaces in C++ are<a id="_idIndexMarker200"/> incredibly valuable in <a id="_idIndexMarker201"/>preventing naming conflicts and properly structuring your code. The issue of naming conflicts, or collisions, arises when two or more identifiers in a program bear the same name. For instance, you might have a class named <code>Id</code> in two subsystems of your application – networking representing a connection ID and user ID in user management. Using them both without namespaces would cause a naming collision, and the compiler wouldn’t know which <code>Id</code> you are referring to in your code.</p>
<p>To mitigate this, C++ provides the <code>namespace</code> keyword to encapsulate a functionality under a unique name. Namespaces are designed to solve the problem of name conflicts. By wrapping your code inside a namespace, you prevent it from colliding with same-named identifiers in other portions of your code or third-party libraries.</p>
<p>Here’s an example:</p>
<pre class="source-code">
namespace product_name {
    class Router {
        // class implementation
    };
}
// To use it elsewhere in the code
product_name::Router myRouter;</pre>
<p>In this case, <code>product_name::Router</code> won’t conflict with any other <code>Router</code> class in your product’s code or a third-party library. If you develop library code, it is highly recommended to wrap all its entities, such as classes, functions, and variables, in a namespace. This will prevent name clashes with other libraries or the user’s code.</p>
<p>It’s common in C++ to mirror the project’s directory structure with namespaces, making it easier to understand where different parts of the code base are located. For example, if you have a file at the <code>ProductRepo/Networking/Router.cpp</code> path, you might declare the <code>Router</code> class like this:</p>
<pre class="source-code">
namespace product_name {
    namespace networking {
        class Router {
            // class implementation
        };
    }
}</pre>
<p>You can then refer to the class with the fully qualified name <code>product_name::networking::Router</code>.</p>
<p>However, it’s worth noting that until C++20, the language didn’t natively support a module system that could replace or enhance the functionality provided by namespaces. With<a id="_idIndexMarker202"/> the arrival of modules in C++20, some<a id="_idIndexMarker203"/> of the practices might be changing, but understanding namespaces and their usage in naming is still vital.</p>
<p>Another way to use namespaces is to express the complexity levels of your code. For example, library code may have entities expected to be used by library consumers and internal ones. The following code snippet demonstrates this approach:</p>
<pre class="source-code">
// communication/client.hpp
namespace communication {
class Client {
public:
    // public high-level methods
private:
    using HttpClient = communication::advanced::HttpClient;
    HttpClient inner_client_;
};
} // namespace communication
// communication/http/client.hpp
namespace communication::advanced::http {
class Client {
    // Lower-level implementation
};
} // namespace communication::advanced</pre>
<p>In this extended example, the <code>communication::Client</code> class provides a high-level interface for sending and receiving messages. It uses the <code>advanced::http::Client</code> class for the actual implementation, but this detail is hidden from the users of the library. They don’t need to know about the advanced class unless they aren’t satisfied with the functionality provided by the default client and need more control.</p>
<p>The <code>Client</code> class, in the <code>communication::http::advanced</code> namespace, provides more low-level functionality that gives users more control over the details of the communication.</p>
<p>This organization makes it clear what functionality is intended for most users (<code>Client</code>) and what is provided for more advanced usage (<code>HttpClient</code>). Using namespaces in this way also helps avoid name clashes and keeps the code base well-organized. This approach is<a id="_idIndexMarker204"/> used<a id="_idIndexMarker205"/> by many libraries and frameworks – for example, it’s common for Boost libraries to have a <code>detail</code> namespace for internal implementation.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>The use of domain-specific language</h2>
<p>If there are well-established<a id="_idIndexMarker206"/> terms in the <a id="_idIndexMarker207"/>problem domain, use them in your code. This can make your code easier to understand for people familiar with the domain. For example, in finance, terms such as “portfolio,” “asset,” “bond,” “equity,” “ticker,” and “dividend” are commonly used. If you’re writing an application related to finance, it’s beneficial to use these terms in your class and variable names, as they clearly convey their roles to anyone with a background in finance.</p>
<p>Consider the following code snippet:</p>
<pre class="source-code">
class Portfolio {
public:
    void add_asset(std::unique_ptr&lt;Asset&gt; asset) {
        // add the asset to the portfolio
    }
    double total_dividend() const {
        // calculate the total dividends of the portfolio
    }
private:
    std::vector&lt;std::unique_ptr&lt;Asset&gt;&gt; assets_;
};
using Ticker = std::string;
class Asset {
public:
    Asset(const Ticker&amp; ticker, int64_t quantity) :
        ticker_{ticker},
        quantity_{quantity} {}
    virtual Asset() = default;
    virtual double total_dividend() const = 0;
    auto&amp; ticker() const { return ticker_; }
    int64_t quantity() const { return quantity_; }
private:
    Ticker ticker_;
    int64_t quantity_;
};
class Bond : public Asset {
public:
    Bond(const Ticker&amp; ticker, int64_t quantity) :
        Asset{ticker, quantity} {}
    double total_dividend() const override {
        // calculate bond dividend
    }
};
class Equity : public Asset {
public:
    Equity(const Ticker&amp; ticker, int64_t quantity) :
        Asset{ticker, quantity} {}
    double total_dividend() const override {
        // calculate equity dividend
    }
};</pre>
<p>In this example, <code>Portfolio</code>, <code>Asset</code>, <code>Bond</code>, <code>Equity</code>, <code>Ticker</code>, and <code>total_dividend()</code> are all terms that are directly borrowed from the domain of finance. A developer or stakeholder who’s familiar with finance will understand the purpose of these classes and methods just by their names. This helps to create a common language between the developers, stakeholders, and domain experts, which can greatly facilitate communication and understanding. Note that it is not recommended to use <code>double</code> in real-world financial applications, as it does not have an accurate enough representation to prevent rounding errors from accumulating when doing arithmetic with monetary values.</p>
<p>Remember, the goal of these principles is to make your code as clear and easy to understand as <a id="_idIndexMarker208"/>possible. Writing code is not <a id="_idIndexMarker209"/>just about communicating with the computer; it’s also about communicating with other developers, including your future self.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Balancing long names and comments in code</h2>
<p>Proper naming <a id="_idIndexMarker210"/>conventions play a critical role in the clarity and readability of your code. Names of classes, methods, and variables should be descriptive enough to convey their purpose and functionality. Ideally, a well-chosen name can replace the need for additional comments, making your code self-explanatory.</p>
<p>However, there’s a delicate balance to be struck. While long, descriptive names can be helpful, excessively long names can also be cumbersome and detract from the readability of code. On the other hand, overly short names can be ambiguous and make the code harder to understand. The key is to find the right balance – names should be long enough to convey their purpose, but not so long as to be unwieldy.</p>
<p>Consider this example from a hypothetical networking application:</p>
<pre class="source-code">
class Router {
public:
    void route(const Message&amp; message, Id receiver) {
        auto message_content = message.get_content();
        // Code to route the 'message_content' to the appropriate 'receiver'
    }
private:
    // Router's private members
};</pre>
<p>In this case, the <code>route</code> method name and the <code>message</code>, <code>receiver</code>, and <code>message_content</code> variable names are all sufficiently descriptive to understand what the method does and what each variable represents. Additional comments to explain their roles aren’t necessary.</p>
<p>That being said, there are cases where language constructs can’t fully express the intent or nuances of your code, such as when relying on specific behavior from a third-party library or when coding a complex algorithm. In these cases, additional comments are necessary to provide context or explain why certain decisions were made.</p>
<p>Take this, for<a id="_idIndexMarker211"/> instance:</p>
<pre class="source-code">
void route(const Message&amp; message, Id receiver) {
    auto message_content = message.get_content();
    // Note: The routing_library has an idiosyncratic behavior where
    // it treats receiver id as one-indexed. Hence we need to increment by 1.
    receiver++;
    // Code to route the 'message_content' to the appropriate 'receiver'
}</pre>
<p>In this case, the comment is necessary to highlight a specific behavior of the third-party routing library, which isn’t immediately apparent from the language constructs alone.</p>
<p>As a general rule, strive to make your code as self-explanatory as possible through good naming practices, but don’t hesitate to use comments when they’re necessary to provide important <a id="_idIndexMarker212"/>context or clarify complex logic. Remember, the ultimate goal is to create code that is easy to read, understand, and maintain.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Exploring popular C++ coding conventions – Google, LLVM, and Mozilla</h1>
<p>In the realm of C++ programming, adhering<a id="_idIndexMarker213"/> to a consistent coding convention is crucial to ensure code clarity and maintainability. Among the myriad of styles available, three prominent conventions stand out for their widespread use and distinct approaches – Google’s C++ Style Guide, LLVM Coding Standards, and Mozilla’s Coding Style. This overview delves into the key aspects of each, highlighting their unique practices and philosophies:</p>
<ul>
<li><code>.cc</code> and <code>.h</code> extensions for implementation and header files, respectively</li><li><code>kCamelCase</code></li><li><code>CamelCase</code> for class names</li><li><code>*</code> or <code>&amp;</code> with the variable name (<code>int* ptr</code>, not <code>int *ptr</code>)</li><li><strong class="bold">Limitations</strong>: Avoid non-const global variables, and prefer algorithms over loops where possible</li></ul></li>
<li><code>.cpp</code> extension, and header files use <code>.h</code>.</li><li><code>camelBack</code> style. Member variables have a trailing underscore.</li><li><code>CamelCase</code>.</li><li><code>*</code> or <code>&amp;</code> adjacent to the type (<code>int *ptr</code>, not <code>int* ptr</code>).</li><li><strong class="bold">Modern C++ usage</strong>: Encourages the use of modern C++ features and patterns.</li></ul></li>
<li><code>.cpp</code> and <code>.</code><code>h</code> extensions</li><li><code>camelCase</code> for variables and functions, <code>CamelCase</code> for classes, and <code>SCREAMING_SNAKE_CASE</code> for constants</li><li><code>CamelCase</code> is used for class names</li><li><code>*</code> or <code>&amp;</code> adjacent to the type</li><li><strong class="bold">Emphasis on performance</strong>: Encourages writing efficient code with a focus on browser performance</li></ul></li>
</ul>
<p>Each of these <a id="_idIndexMarker217"/>conventions has its own philosophy and rationale. Google’s style guide emphasizes consistency within a vast code base and across a large number of developers. LLVM’s standards focus on clean, efficient code that leverages modern C++ features. Mozilla’s style balances readability and performance, reflecting its origins in web technology development. It’s important to choose a style <a id="_idIndexMarker218"/>that aligns with your project’s goals, team size, and the specific technologies you work with.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Summary</h1>
<p>In this chapter, we explored the critical role of naming programming. We recognized that good, consistent naming practices elevate the readability and maintainability of code, while also aiding in its self-documentation.</p>
<p>We pondered over the balance between using long descriptive names and shorter names supplemented by comments, understanding that both have their place in different contexts. The use of domain-specific language in naming was recommended for clarity, while “magic numbers” were cautioned against due to their opacity.</p>
<p>The influence of a variable’s scope and lifetime on its naming was also discussed, emphasizing the need for more descriptive names for those variables with larger scopes and longer lifetimes.</p>
<p>The chapter wrapped up by stressing the value of adhering to a coding convention for naming, which instills consistency across the code base, thereby streamlining the code reading and comprehension process.</p>
<p>The insights garnered from this chapter serve as a foundation for the upcoming discussion on effectively leveraging the rich static type system in C++ for safer, cleaner, and clearer code. In the next chapter, we will shift our focus to the effective utilization of C++’s rich static type system.</p>
</div>
</body></html>