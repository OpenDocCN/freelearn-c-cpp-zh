<html><head></head><body>
<div id="_idContainer010">
<h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.2.1">The Significance of Naming</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As you delve deeper into the world of C++, or any other programming language for that matter, one thing becomes increasingly clear – the power of a name. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will explore the profound importance of naming conventions in writing clean, maintainable, and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">C++ code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In computer programming, names are given to variables, functions, classes, and numerous other entities. </span><span class="koboSpan" id="kobo.5.2">These names serve as identifiers, playing a pivotal role in how we, as programmers, interact with the components of our code. </span><span class="koboSpan" id="kobo.5.3">While it may seem a trivial matter to some, choosing the right names can have a profound impact on the understandability and maintainability of a software project. </span><span class="koboSpan" id="kobo.5.4">The names we choose to represent the different elements of our program are the first layer of documentation that anyone, including our future selves, has when they approach </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Imagine a developer named Mia who works with a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">WeatherData</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">This class has two getter methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">get_tempreture()</span></strong><span class="koboSpan" id="kobo.11.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">get_humidity()</span></strong><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">The former method simply returns the current temperature value stored in a member variable. </span><span class="koboSpan" id="kobo.13.3">It’s an O(1) operation, since it involves returning an already-stored value. </span><span class="koboSpan" id="kobo.13.4">The latter does more than just return a value. </span><span class="koboSpan" id="kobo.13.5">It actually initiates a connection to a remote weather service, retrieves the latest humidity data, and then returns it. </span><span class="koboSpan" id="kobo.13.6">This operation is considerably costly, involving network communication and data processing, making it far from an O(1) operation. </span><span class="koboSpan" id="kobo.13.7">Mia, focusing on optimizing a function in the project, sees these two getters and assumes they are similar in terms of efficiency due to their naming. </span><span class="koboSpan" id="kobo.13.8">She uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">get_humidity()</span></strong><span class="koboSpan" id="kobo.15.1"> within a loop, expecting it to be a simple, efficient retrieval of a stored value, similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">get_temperature()</span></strong><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">The performance of the function plummets due to the repeated, expensive calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">get_humidity()</span></strong><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">The network requests and data processing involved in each call significantly slow down the execution, leading to an inefficient use of resources and a slowdown in the application’s performance. </span><span class="koboSpan" id="kobo.19.3">This could have been avoided if the method had been named </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">fetch_humidity()</span></strong><span class="koboSpan" id="kobo.21.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">get_humidity()</span></strong><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">The name </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">fetch_humidity()</span></strong><span class="koboSpan" id="kobo.25.1"> would have made it clear that the method is not a simple getter but, rather, a more expensive operation that involves fetching data from a </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">remote service.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">The art of naming requires careful consideration and a good understanding of both the problem domain and the programming language. </span><span class="koboSpan" id="kobo.27.2">This chapter provides a comprehensive discussion of the general approach to creating and naming variables, class members, methods, and functions in C++. </span><span class="koboSpan" id="kobo.27.3">We will debate the trade-offs of long names versus short names, as well as the role of comments in clarifying </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">our intentions.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">We will explore the importance of coding conventions and the benefits they bring to individual developers and teams alike. </span><span class="koboSpan" id="kobo.29.2">Consistent application of a well-thought-out naming convention can streamline the coding process, reduce errors, and greatly enhance the readability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">By the end of this chapter, you will understand why good naming practices are not just an afterthought but also an essential component of good software development. </span><span class="koboSpan" id="kobo.31.2">We will equip you with strategies and conventions to help you write code that can be easily read, understood, and maintained by others – and by you, when you revisit your own code months or years down </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the line.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.33.1">General naming principles</span></h1>
<p><span class="koboSpan" id="kobo.34.1">Regardless of </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.35.1">the specific </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Object-Oriented Programming</span></strong><span class="koboSpan" id="kobo.37.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.38.1">OOP</span></strong><span class="koboSpan" id="kobo.39.1">) language you’re using, certain universal </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.40.1">naming principles can help improve the clarity and maintainability of your code. </span><span class="koboSpan" id="kobo.40.2">These principles aim to ensure that names in your code provide sufficient information about their use </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">and functionality.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.42.1">Descriptiveness</span></h2>
<p><span class="koboSpan" id="kobo.43.1">Names should</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.44.1"> accurately describe the purpose or value of the variable, function, class, or method they are identifying. </span><span class="koboSpan" id="kobo.44.2">For instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">getSalary()</span></strong><span class="koboSpan" id="kobo.46.1"> for a function is more informative than </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">simply </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">getS()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.50.1">Consistency</span></h2>
<p><span class="koboSpan" id="kobo.51.1">Consistency in</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.52.1"> naming </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.53.1">conventions is one of the most vital principles in writing clear and maintainable code. </span><span class="koboSpan" id="kobo.53.2">When you’re consistent with your naming throughout your code base, it becomes much easier to read, understand, and debug your code. </span><span class="koboSpan" id="kobo.53.3">The reason for this is that once a developer learns your naming pattern, they can apply their understanding across the entire code base, rather than having to figure out what each individual name means </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">in isolation.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Consistency applies to many areas, including </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Case style</span></strong><span class="koboSpan" id="kobo.58.1">: If you start by naming your variables in </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">snake_case</span></strong><span class="koboSpan" id="kobo.60.1"> (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">employee_salary</span></strong><span class="koboSpan" id="kobo.62.1">), stick to that style throughout your entire code base. </span><span class="koboSpan" id="kobo.62.2">Don’t switch between snake_case, camelCase (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">employeeSalary</span></strong><span class="koboSpan" id="kobo.64.1">), and PascalCase (</span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">e.g., </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">EmployeeSalary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Prefixes and suffixes</span></strong><span class="koboSpan" id="kobo.69.1">: If you use prefixes or suffixes to denote certain properties, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">m_</span></strong><span class="koboSpan" id="kobo.71.1"> for member variables (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">m_value</span></strong><span class="koboSpan" id="kobo.73.1">), ensure this rule is </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">followed everywhere.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Abbreviation rules</span></strong><span class="koboSpan" id="kobo.76.1">: If you decide to abbreviate certain words, ensure you do it consistently. </span><span class="koboSpan" id="kobo.76.2">For example, if you’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">num</span></strong><span class="koboSpan" id="kobo.78.1"> to represent </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">number</span></strong><span class="koboSpan" id="kobo.80.1"> (as in </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">numEmployees</span></strong><span class="koboSpan" id="kobo.82.1">), then always use </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">num</span></strong><span class="koboSpan" id="kobo.84.1"> whenever you </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">mean </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">number</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Naming conventions specific to language constructs</span></strong><span class="koboSpan" id="kobo.89.1">: In OOP languages, class names are typically nouns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Employee</span></strong><span class="koboSpan" id="kobo.91.1">), method names are verbs (</span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">calculateSalary</span></strong><span class="koboSpan" id="kobo.93.1">), and Boolean variables or methods often start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">is</span></strong><span class="koboSpan" id="kobo.95.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">has</span></strong><span class="koboSpan" id="kobo.97.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">can</span></strong><span class="koboSpan" id="kobo.99.1">, or similar prefixes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">isAvailable</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">hasCompleted</span></strong><span class="koboSpan" id="kobo.103.1">). </span><span class="koboSpan" id="kobo.103.2">Stick with these </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">conventions consistently.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.105.1">Let’s say </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.106.1">you’re </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.107.1">working on a large code base where classes represent various types of employees in a company. </span><span class="koboSpan" id="kobo.107.2">You’ve decided to name your classes as singular nouns in PascalCase, methods as verbs in snake_case, and variables in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">snake_case too.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">A consistent implementation of this naming convention might look </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.111.1">
class SoftwareEngineer {
public:
    void assign_task(std::string task_name) {
        current_task_ = std::move(task_name);
    }
private:
    std::string current_task_;
};</span></pre>
<p><span class="koboSpan" id="kobo.112.1">Let’s break down this </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">code snippet:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.114.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">SoftwareEngineer</span></strong><span class="koboSpan" id="kobo.116.1"> class is a singular noun and </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">uses PascalCase</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">assign_task</span></strong><span class="koboSpan" id="kobo.120.1"> method is a verb and </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">uses snake_case</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">The variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">current_task</span></strong><span class="koboSpan" id="kobo.124.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">in snake_case</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">Being consistent with this convention will help anyone reading your code to immediately recognize what each name represents. </span><span class="koboSpan" id="kobo.126.2">This way, the cognitive load is reduced, and </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.127.1">developers can focus on the actual logic, rather than</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.128.1"> being distracted by inconsistent or </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">confusing names.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.130.1">Unambiguity</span></h2>
<p><span class="koboSpan" id="kobo.131.1">Unambiguity</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.132.1"> means that</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.133.1"> names should not be misleading. </span><span class="koboSpan" id="kobo.133.2">Avoid using names that could be interpreted in multiple ways, or that contradict established conventions or expectations. </span><span class="koboSpan" id="kobo.133.3">For example, suppose you have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Document</span></strong><span class="koboSpan" id="kobo.135.1"> class and a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">process</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">Without more context, the method name </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">is ambiguous:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
class Document {
public:
    void process();
};</span></pre>
<p><span class="koboSpan" id="kobo.140.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">process</span></strong><span class="koboSpan" id="kobo.142.1"> could mean a number of things. </span><span class="koboSpan" id="kobo.142.2">Are we going to parse the document? </span><span class="koboSpan" id="kobo.142.3">Are we going to render it? </span><span class="koboSpan" id="kobo.142.4">Are we going to save it to a file? </span><span class="koboSpan" id="kobo.142.5">Or are we going to perform all these operations? </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">It’s unclear.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">A more specific method name could help to clarify its purpose. </span><span class="koboSpan" id="kobo.144.2">Depending on what the method is supposed to do, it could be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">parse</span></strong><span class="koboSpan" id="kobo.146.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">render</span></strong><span class="koboSpan" id="kobo.148.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">save</span></strong><span class="koboSpan" id="kobo.150.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">so on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
class Document {
public:
    void parse(const std::string&amp; content);
    void render();
    void save(const std::string&amp; file_path);
};</span></pre>
<p><span class="koboSpan" id="kobo.153.1">Each of these method names gives a much clearer indication of what the method does, removing the </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.154.1">ambiguity of the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">process</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.156.1">method</span></span><span class="No-Break"><a id="_idIndexMarker183"/></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1"> name.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.158.1">Pronounceability</span></h2>
<p><span class="koboSpan" id="kobo.159.1">Names should be</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.160.1"> easily pronounceable. </span><span class="koboSpan" id="kobo.160.2">This facilitates verbal communication about the code </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">between developers.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.162.1">Scope and lifetimes</span></h2>
<p><span class="koboSpan" id="kobo.163.1"> Variables with larger</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.164.1"> scopes and longer lifetimes usually have more influence on a system and, hence, deserve more thoughtful, clear, and descriptive names. </span><span class="koboSpan" id="kobo.164.2">This helps ensure that they’re understood in all contexts where they’re used. </span><span class="koboSpan" id="kobo.164.3">Here’s a more </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">detailed breakdown.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Global variables can be accessed from anywhere in a program, and their lifetime extends for the duration of the program. </span><span class="koboSpan" id="kobo.166.2">Therefore, they deserve especially careful consideration when naming. </span><span class="koboSpan" id="kobo.166.3">The name should be descriptive enough to clearly indicate its role in the system. </span><span class="koboSpan" id="kobo.166.4">Additionally, global variables can create unexpected dependencies, which makes the program harder to understand and maintain. </span><span class="koboSpan" id="kobo.166.5">Therefore, the use of global variables should </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">be minimized:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
// Global variable
constexpr double GRAVITATIONAL_ACCELERATION = 9.8; // Clear and descriptive</span></pre>
<p><span class="koboSpan" id="kobo.169.1">Class member variables can be accessed from any method within the class, and their lifetime is tied to the lifetime of the class instance. </span><span class="koboSpan" id="kobo.169.2">They should have clear and descriptive names that reflect their role within the class. </span><span class="koboSpan" id="kobo.169.3">It’s often useful to follow a naming convention that distinguishes them from local variables (e.g., an </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">m_</span></strong><span class="koboSpan" id="kobo.171.1"> prefix or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1"> suffix):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
class PhysicsObject {
    double mass_;  // Descriptive and follows naming convention
    // ...
</span><span class="koboSpan" id="kobo.174.2">};</span></pre>
<p><span class="koboSpan" id="kobo.175.1">Local variables are confined to a specific function or block and exist only for the duration of that function or block. </span><span class="koboSpan" id="kobo.175.2">These variables typically need less descriptive names compared to global variables or class members, but they should still clearly convey </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">their purpose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
double compute_force(double mass, double acceleration) {
    double force = mass * acceleration;  // 'force' is clear in this context
    return force;
}</span></pre>
<p><span class="koboSpan" id="kobo.178.1">Loop variables and temporary variables have the shortest scope and lifetime, usually confined to a small loop or a small block of code. </span><span class="koboSpan" id="kobo.178.2">As a result, they typically have the simplest names (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">i</span></strong><span class="koboSpan" id="kobo.180.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">j</span></strong><span class="koboSpan" id="kobo.182.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">temp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
for (int i = 0; i &lt; num; ++i) {  // 'i' is clear in this context
    // ...
</span><span class="koboSpan" id="kobo.186.2">}</span></pre>
<p><span class="koboSpan" id="kobo.187.1">The key idea here is, the broader the scope and the longer the lifetime of a variable, the more potential</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.188.1"> there is for confusion about its purpose, so the more descriptive its name should be. </span><span class="koboSpan" id="kobo.188.2">The goal is to make code as clear and understandable </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">as possible.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.190.1">Avoid encoding type or scope information</span></h2>
<p><span class="koboSpan" id="kobo.191.1">In modern</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.192.1"> programming languages, encoding type or scope information into names (often known as Hungarian notation) is usually unnecessary and can lead to confusion or errors, especially when refactoring. </span><span class="koboSpan" id="kobo.192.2">While this can occasionally be helpful, especially in languages with weak typing, it has several downsides that make it less suitable for use in strongly typed languages such </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">as C++:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.194.1">The type of a variable might change in the future, but its name often doesn’t. </span><span class="koboSpan" id="kobo.194.2">This leads to misleading situations where a variable’s name suggests one type but it actually has another. </span><span class="koboSpan" id="kobo.194.3">For example, you might start with a vector of IDs (</span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">std::vector&lt;Id&gt; id_array</span></strong><span class="koboSpan" id="kobo.196.1">) and later change it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">set&lt;Id&gt;</span></strong><span class="koboSpan" id="kobo.198.1"> to avoid duplication, but the variable name still suggests it’s an array </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">or vector.</span></span></li>
<li><span class="koboSpan" id="kobo.200.1">Modern development environments provide features such as type inference, hovering tooltips showing types, and powerful refactoring tools, which all make manually encoding types into names largely redundant. </span><span class="koboSpan" id="kobo.200.2">For example, VS Code with the clangd plugin installed and the “inlay hints” feature turned on deducts types on</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.201.1"> the fly, </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">including </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">auto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.205.1"><img alt="Figure 5.1 – Inlay hints in VS Code" src="image/B19606_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">Figure 5.1 – Inlay hints in VS Code</span></p>
<p><span class="koboSpan" id="kobo.207.1">This applies to CLion by </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">JetBrains too:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.209.1">Prefixes in Hungarian notation can make variable names harder to read, especially for those not familiar with the notation. </span><span class="koboSpan" id="kobo.209.2">It may not be immediately obvious to a new developer what </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">dwCount</span></strong><span class="koboSpan" id="kobo.211.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">DWORD</span></strong><span class="koboSpan" id="kobo.213.1">, or double word, often used to represent an unsigned long </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">integer) means.</span></span></li>
<li><span class="koboSpan" id="kobo.215.1">Strongly typed languages such as C++ already check type safety at compile time, reducing the need to encode type information in the variable name. </span><span class="koboSpan" id="kobo.215.2">In the following example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">integers</span></strong><span class="koboSpan" id="kobo.217.1"> is declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">std::vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.219.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">sentence</span></strong><span class="koboSpan" id="kobo.221.1"> is declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">std::string</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">The C++ compiler is aware of these types and will</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.224.1"> ensure that operations on these variables </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">are type-safe:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
#include &lt;vector&gt;
#include &lt;string&gt;
int main() {
    std::vector&lt;int&gt; integers;
    std::string sentence;
    // The following will cause a compile-time error because
    // the type of 'sentence' is string, not vector&lt;int&gt;.
</span><span class="koboSpan" id="kobo.226.2">    integers = sentence;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.227.1">When the code attempts to assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">sentence</span></strong><span class="koboSpan" id="kobo.229.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">integers</span></strong><span class="koboSpan" id="kobo.231.1">, a compile-time error is produced because </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">sentence</span></strong><span class="koboSpan" id="kobo.233.1"> is not of the correct type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">std::vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.235.1">). </span><span class="koboSpan" id="kobo.235.2">This happens despite the fact that neither of the variable names encode </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">type information.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">The compiler’s type-checking eliminates the need to include the type in the variable names (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">strSentence</span></strong><span class="koboSpan" id="kobo.239.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">vecIntegers</span></strong><span class="koboSpan" id="kobo.241.1">), a practice common in languages that do not perform such strong compile-time type-checking. </span><span class="koboSpan" id="kobo.241.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">integers</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">sentence</span></strong><span class="koboSpan" id="kobo.245.1"> variable names are sufficiently descriptive without encoding the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">type information.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">In programming, you often come across situations where multiple logical concepts are represented using the same underlying type. </span><span class="koboSpan" id="kobo.247.2">For instance, you may have identifiers for </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Users</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Products</span></strong><span class="koboSpan" id="kobo.251.1"> in your system, both of which are represented as integers. </span><span class="koboSpan" id="kobo.251.2">While C++’s static type checking provides a level of safety, it won’t differentiate between </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">UserId</span></strong><span class="koboSpan" id="kobo.253.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">ProductId</span></strong><span class="koboSpan" id="kobo.255.1"> – they’re both just integers as far as the compiler </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">is concerned.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">However, using the same type for these different concepts can lead to bugs. </span><span class="koboSpan" id="kobo.257.2">It’s entirely possible, for example, to mistakenly pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">UserId</span></strong><span class="koboSpan" id="kobo.259.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ProductId</span></strong><span class="koboSpan" id="kobo.261.1"> was expected, and the compiler wouldn’t catch </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">this error.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">To address this issue, you can leverage C++’s rich type system to introduce new types representing these different concepts, even when they share the same underlying representation. </span><span class="koboSpan" id="kobo.263.2">This way, the compiler can catch these bugs at compile time, enhancing the robustness </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.264.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">your software:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
// Define new types for User and Product IDs.
</span><span class="koboSpan" id="kobo.266.2">struct UserId {
    explicit UserId(int id): value(id) {}
    int value;
};
struct ProductId {
    explicit ProductId(int id): value(id) {}
    int value;
};
void process_user(UserId id) {
    // Processing user...
</span><span class="koboSpan" id="kobo.266.3">}
void process_product(ProductId id) {
    // Processing product...
</span><span class="koboSpan" id="kobo.266.4">}
int main() {
    UserId user_id(1);
    ProductId product_id(2);
    // The following line would cause a compile-time error because
    // a ProductId is being passed to process_user.
</span><span class="koboSpan" id="kobo.266.5">    process_user(product_id);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.267.1">In the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">UserId</span></strong><span class="koboSpan" id="kobo.269.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">ProductId</span></strong><span class="koboSpan" id="kobo.271.1"> are distinct types. </span><span class="koboSpan" id="kobo.271.2">Even though their underlying representation is the same (</span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">int</span></strong><span class="koboSpan" id="kobo.273.1">), passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ProductId</span></strong><span class="koboSpan" id="kobo.275.1"> to a function expecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">UserId</span></strong><span class="koboSpan" id="kobo.277.1"> results in a compile-time error. </span><span class="koboSpan" id="kobo.277.2">This adds an additional layer of type safety to </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">This is just a glimpse into how you can utilize C++’s rich static type system to create more robust </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.280.1">and safer code. </span><span class="koboSpan" id="kobo.280.2">We will delve into this topic in more detail in </span><a href="B19606_06.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.281.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.282.1">,</span><em class="italic"><span class="koboSpan" id="kobo.283.1"> Utilizing a Rich Static Type System </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.284.1">in C++</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.286.1">Class and method naming</span></h2>
<p><span class="koboSpan" id="kobo.287.1">In OOP languages, classes</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.288.1"> represent concepts or things, and their instances (objects) are specific manifestations of those things. </span><span class="koboSpan" id="kobo.288.2">As such, both class names and their instances are most appropriately named using nouns or noun phrases. </span><span class="koboSpan" id="kobo.288.3">They represent entities in the system, whether they’re tangible (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Employee</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Invoice</span></strong><span class="koboSpan" id="kobo.292.1">) or conceptual (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Transaction</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.294.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">DatabaseConnection</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">On the other hand, methods in classes typically represent actions that an object of that class can perform, or messages that can be sent to it. </span><span class="koboSpan" id="kobo.297.2">As such, they’re most effectively named using verbs or verb phrases. </span><span class="koboSpan" id="kobo.297.3">They act as instructions that can be carried out by the object, allowing it to interact with other objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">meaningful ways.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Document</span></strong><span class="koboSpan" id="kobo.301.1"> class with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">print</span></strong><span class="koboSpan" id="kobo.303.1"> method. </span><span class="koboSpan" id="kobo.303.2">We can say “document, print” or “print the document,” which is a clear, imperative statement in line with how we might communicate the action in </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">everyday language.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
class Document {
public:
    void print();
};
Document report;
report.print();  // "report, print!"</span></pre>
<p><span class="koboSpan" id="kobo.308.1">This noun-verb consistency in naming classes and methods aligns well with the way we naturally understand and communicate about objects and actions in the real world, contributing to the readability and comprehensibility of our code. </span><span class="koboSpan" id="kobo.308.2">Moreover, it lends itself well to the principle of encapsulation in OOP, where objects manage their own behavior (methods) and state (</span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">member variables).</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Maintaining this convention allows developers to write code that’s more intuitive, self-documenting, and easier to maintain. </span><span class="koboSpan" id="kobo.310.2">It creates a common language and understanding among </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.311.1">developers, reducing the cognitive load when reading code and making the code base easier to navigate and reason about. </span><span class="koboSpan" id="kobo.311.2">Therefore, it’s recommended to adhere to these conventions </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">in OOP.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.313.1">Naming variables</span></h2>
<p><span class="koboSpan" id="kobo.314.1">Variable</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.315.1"> names</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.316.1"> should reflect the data they hold. </span><span class="koboSpan" id="kobo.316.2">A good variable name describes the kind of value the variable contains, not just its purpose in the algorithm </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">you’ve written.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Avoiding magic numbers, Numerical values with unexplained meanings in the source code. </span><span class="koboSpan" id="kobo.318.2">They can lead to code that is harder to read, understand, and maintain. </span><span class="koboSpan" id="kobo.318.3">Let’s consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">MessageSender</span></strong><span class="koboSpan" id="kobo.320.1"> class that sends messages, and if a message size is greater than a certain limit, it splits the message </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">into chunks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
class MessageSender {
public:
    void send_message(const std::string&amp; message) {
        if (message.size() &gt; 1024) {
            // Split the message into chunks and send
        } else {
            // Send the message
        }
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.323.1">In the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">1024</span></strong><span class="koboSpan" id="kobo.325.1"> is a magic number. </span><span class="koboSpan" id="kobo.325.2">It likely represents a maximum message size, but</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.326.1"> it’s not immediately clear. </span><span class="koboSpan" id="kobo.326.2">It can confuse </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.327.1">others (or future you) reading your code. </span><span class="koboSpan" id="kobo.327.2">Here’s a refactored example with a </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">named constant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
class MessageSender {
    constexpr size_t MAX_MESSAGE_SIZE = 1024;
public:
    void send_message(const std::string&amp; message) {
        if (message.size() &gt; MAX_MESSAGE_SIZE) {
            // Split the message into chunks and send
        } else {
            // Send the message
        }
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.330.1">In this refactored version, we’ve replaced the magic number </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">1024</span></strong><span class="koboSpan" id="kobo.332.1"> with a named constant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">MAX_MESSAGE_SIZE</span></strong><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">It’s now clear that </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">1024</span></strong><span class="koboSpan" id="kobo.336.1"> is the maximum message size. </span><span class="koboSpan" id="kobo.336.2">Using named constants in this way makes your code more readable and maintainable. </span><span class="koboSpan" id="kobo.336.3">If the </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.337.1">maximum message size needs to change in</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.338.1"> the future, you only need to update it in </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">one place.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.340.1">Utilize namespaces</span></h2>
<p><span class="koboSpan" id="kobo.341.1">Namespaces in C++ are</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.342.1"> incredibly valuable in </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.343.1">preventing naming conflicts and properly structuring your code. </span><span class="koboSpan" id="kobo.343.2">The issue of naming conflicts, or collisions, arises when two or more identifiers in a program bear the same name. </span><span class="koboSpan" id="kobo.343.3">For instance, you might have a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Id</span></strong><span class="koboSpan" id="kobo.345.1"> in two subsystems of your application – networking representing a connection ID and user ID in user management. </span><span class="koboSpan" id="kobo.345.2">Using them both without namespaces would cause a naming collision, and the compiler wouldn’t know which </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Id</span></strong><span class="koboSpan" id="kobo.347.1"> you are referring to in </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">To mitigate this, C++ provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">namespace</span></strong><span class="koboSpan" id="kobo.351.1"> keyword to encapsulate a functionality under a unique name. </span><span class="koboSpan" id="kobo.351.2">Namespaces are designed to solve the problem of name conflicts. </span><span class="koboSpan" id="kobo.351.3">By wrapping your code inside a namespace, you prevent it from colliding with same-named identifiers in other portions of your code or </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">third-party libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.355.1">
namespace product_name {
    class Router {
        // class implementation
    };
}
// To use it elsewhere in the code
product_name::Router myRouter;</span></pre>
<p><span class="koboSpan" id="kobo.356.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">product_name::Router</span></strong><span class="koboSpan" id="kobo.358.1"> won’t conflict with any other </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Router</span></strong><span class="koboSpan" id="kobo.360.1"> class in your product’s code or a third-party library. </span><span class="koboSpan" id="kobo.360.2">If you develop library code, it is highly recommended to wrap all its entities, such as classes, functions, and variables, in a namespace. </span><span class="koboSpan" id="kobo.360.3">This will prevent name clashes with other libraries or the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">user’s code.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">It’s common in C++ to mirror the project’s directory structure with namespaces, making it easier to understand where different parts of the code base are located. </span><span class="koboSpan" id="kobo.362.2">For example, if you have a file at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">ProductRepo/Networking/Router.cpp</span></strong><span class="koboSpan" id="kobo.364.1"> path, you might declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Router</span></strong><span class="koboSpan" id="kobo.366.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
namespace product_name {
    namespace networking {
        class Router {
            // class implementation
        };
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.369.1">You can then refer to the class with the fully qualified </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">product_name::networking::Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">However, it’s worth noting that until C++20, the language didn’t natively support a module system that could replace or enhance the functionality provided by namespaces. </span><span class="koboSpan" id="kobo.373.2">With</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.374.1"> the arrival of modules in C++20, some</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.375.1"> of the practices might be changing, but understanding namespaces and their usage in naming is </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">still vital.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">Another way to use namespaces is to express the complexity levels of your code. </span><span class="koboSpan" id="kobo.377.2">For example, library code may have entities expected to be used by library consumers and internal ones. </span><span class="koboSpan" id="kobo.377.3">The following code snippet demonstrates </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">this approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
// communication/client.hpp
namespace communication {
class Client {
public:
    // public high-level methods
private:
    using HttpClient = communication::advanced::HttpClient;
    HttpClient inner_client_;
};
} // namespace communication
// communication/http/client.hpp
namespace communication::advanced::http {
class Client {
    // Lower-level implementation
};
} // namespace communication::advanced</span></pre>
<p><span class="koboSpan" id="kobo.380.1">In this extended example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">communication::Client</span></strong><span class="koboSpan" id="kobo.382.1"> class provides a high-level interface for sending and receiving messages. </span><span class="koboSpan" id="kobo.382.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">advanced::http::Client</span></strong><span class="koboSpan" id="kobo.384.1"> class for the actual implementation, but this detail is hidden from the users of the library. </span><span class="koboSpan" id="kobo.384.2">They don’t need to know about the advanced class unless they aren’t satisfied with the functionality provided by the default client and need </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">more control.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Client</span></strong><span class="koboSpan" id="kobo.388.1"> class, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">communication::http::advanced</span></strong><span class="koboSpan" id="kobo.390.1"> namespace, provides more low-level functionality that gives users more control over the details of </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the communication.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">This organization makes it clear what functionality is intended for most users (</span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Client</span></strong><span class="koboSpan" id="kobo.394.1">) and what is provided for more advanced usage (</span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">HttpClient</span></strong><span class="koboSpan" id="kobo.396.1">). </span><span class="koboSpan" id="kobo.396.2">Using namespaces in this way also helps avoid name clashes and keeps the code base well-organized. </span><span class="koboSpan" id="kobo.396.3">This approach is</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.397.1"> used</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.398.1"> by many libraries and frameworks – for example, it’s common for Boost libraries to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">detail</span></strong><span class="koboSpan" id="kobo.400.1"> namespace for </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">internal implementation.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.402.1">The use of domain-specific language</span></h2>
<p><span class="koboSpan" id="kobo.403.1">If there are well-established</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.404.1"> terms in the </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.405.1">problem domain, use them in your code. </span><span class="koboSpan" id="kobo.405.2">This can make your code easier to understand for people familiar with the domain. </span><span class="koboSpan" id="kobo.405.3">For example, in finance, terms such as “portfolio,” “asset,” “bond,” “equity,” “ticker,” and “dividend” are commonly used. </span><span class="koboSpan" id="kobo.405.4">If you’re writing an application related to finance, it’s beneficial to use these terms in your class and variable names, as they clearly convey their roles to anyone with a background </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">in finance.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
class Portfolio {
public:
    void add_asset(std::unique_ptr&lt;Asset&gt; asset) {
        // add the asset to the portfolio
    }
    double total_dividend() const {
        // calculate the total dividends of the portfolio
    }
private:
    std::vector&lt;std::unique_ptr&lt;Asset&gt;&gt; assets_;
};
using Ticker = std::string;
class Asset {
public:
    Asset(const Ticker&amp; ticker, int64_t quantity) :
        ticker_{ticker},
        quantity_{quantity} {}
    virtual Asset() = default;
    virtual double total_dividend() const = 0;
    auto&amp; ticker() const { return ticker_; }
    int64_t quantity() const { return quantity_; }
private:
    Ticker ticker_;
    int64_t quantity_;
};
class Bond : public Asset {
public:
    Bond(const Ticker&amp; ticker, int64_t quantity) :
        Asset{ticker, quantity} {}
    double total_dividend() const override {
        // calculate bond dividend
    }
};
class Equity : public Asset {
public:
    Equity(const Ticker&amp; ticker, int64_t quantity) :
        Asset{ticker, quantity} {}
    double total_dividend() const override {
        // calculate equity dividend
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.410.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Portfolio</span></strong><span class="koboSpan" id="kobo.412.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Asset</span></strong><span class="koboSpan" id="kobo.414.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Bond</span></strong><span class="koboSpan" id="kobo.416.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Equity</span></strong><span class="koboSpan" id="kobo.418.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Ticker</span></strong><span class="koboSpan" id="kobo.420.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">total_dividend()</span></strong><span class="koboSpan" id="kobo.422.1"> are all terms that are directly borrowed from the domain of finance. </span><span class="koboSpan" id="kobo.422.2">A developer or stakeholder who’s familiar with finance will understand the purpose of these classes and methods just by their names. </span><span class="koboSpan" id="kobo.422.3">This helps to create a common language between the developers, stakeholders, and domain experts, which can greatly facilitate communication and understanding. </span><span class="koboSpan" id="kobo.422.4">Note that it is not recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">double</span></strong><span class="koboSpan" id="kobo.424.1"> in real-world financial applications, as it does not have an accurate enough representation to prevent rounding errors from accumulating when doing arithmetic with </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">monetary values.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">Remember, the goal of these principles is to make your code as clear and easy to understand as </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.427.1">possible. </span><span class="koboSpan" id="kobo.427.2">Writing code is not </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.428.1">just about communicating with the computer; it’s also about communicating with other developers, including your </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">future self.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.430.1">Balancing long names and comments in code</span></h2>
<p><span class="koboSpan" id="kobo.431.1">Proper naming </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.432.1">conventions play a critical role in the clarity and readability of your code. </span><span class="koboSpan" id="kobo.432.2">Names of classes, methods, and variables should be descriptive enough to convey their purpose and functionality. </span><span class="koboSpan" id="kobo.432.3">Ideally, a well-chosen name can replace the need for additional comments, making your </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">code self-explanatory.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">However, there’s a delicate balance to be struck. </span><span class="koboSpan" id="kobo.434.2">While long, descriptive names can be helpful, excessively long names can also be cumbersome and detract from the readability of code. </span><span class="koboSpan" id="kobo.434.3">On the other hand, overly short names can be ambiguous and make the code harder to understand. </span><span class="koboSpan" id="kobo.434.4">The key is to find the right balance – names should be long enough to convey their purpose, but not so long as to </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">be unwieldy.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Consider this example from a hypothetical </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">networking application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
class Router {
public:
    void route(const Message&amp; message, Id receiver) {
        auto message_content = message.get_content();
        // Code to route the 'message_content' to the appropriate 'receiver'
    }
private:
    // Router's private members
};</span></pre>
<p><span class="koboSpan" id="kobo.439.1">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">route</span></strong><span class="koboSpan" id="kobo.441.1"> method name and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">message</span></strong><span class="koboSpan" id="kobo.443.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">receiver</span></strong><span class="koboSpan" id="kobo.445.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">message_content</span></strong><span class="koboSpan" id="kobo.447.1"> variable names are all sufficiently descriptive to understand what the method does and what each variable represents. </span><span class="koboSpan" id="kobo.447.2">Additional comments to explain their roles </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">aren’t necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">That being said, there are cases where language constructs can’t fully express the intent or nuances of your code, such as when relying on specific behavior from a third-party library or when coding a complex algorithm. </span><span class="koboSpan" id="kobo.449.2">In these cases, additional comments are necessary to provide context or explain why certain decisions </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">were made.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">Take this, </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">for</span></span><span class="No-Break"><a id="_idIndexMarker211"/></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1"> instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
void route(const Message&amp; message, Id receiver) {
    auto message_content = message.get_content();
    // Note: The routing_library has an idiosyncratic behavior where
    // it treats receiver id as one-indexed. </span><span class="koboSpan" id="kobo.454.2">Hence we need to increment by 1.
</span><span class="koboSpan" id="kobo.454.3">    receiver++;
    // Code to route the 'message_content' to the appropriate 'receiver'
}</span></pre>
<p><span class="koboSpan" id="kobo.455.1">In this case, the comment is necessary to highlight a specific behavior of the third-party routing library, which isn’t immediately apparent from the language </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">constructs alone.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">As a general rule, strive to make your code as self-explanatory as possible through good naming practices, but don’t hesitate to use comments when they’re necessary to provide important </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.458.1">context or clarify complex logic. </span><span class="koboSpan" id="kobo.458.2">Remember, the ultimate goal is to create code that is easy to read, understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">and maintain.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.460.1">Exploring popular C++ coding conventions – Google, LLVM, and Mozilla</span></h1>
<p><span class="koboSpan" id="kobo.461.1">In the realm of C++ programming, adhering</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.462.1"> to a consistent coding convention is crucial to ensure code clarity and maintainability. </span><span class="koboSpan" id="kobo.462.2">Among the myriad of styles available, three prominent conventions stand out for their widespread use and distinct approaches – Google’s C++ Style Guide, LLVM Coding Standards, and Mozilla’s Coding Style. </span><span class="koboSpan" id="kobo.462.3">This overview delves into the key aspects of each, highlighting their unique practices </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">and philosophies:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.464.1">Google’s C++ Style Guide</span></strong><span class="koboSpan" id="kobo.465.1">: Google’s</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.466.1"> guidelines are designed for internal use, but they are widely adopted in the open source community. </span><span class="koboSpan" id="kobo.466.2">Key features include </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">the following:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.468.1">Filenames</span></strong><span class="koboSpan" id="kobo.469.1">: Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">.cc</span></strong><span class="koboSpan" id="kobo.471.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">.h</span></strong><span class="koboSpan" id="kobo.473.1"> extensions for implementation and header </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">files, respectively</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.475.1">Variable names</span></strong><span class="koboSpan" id="kobo.476.1">: Regular variables use lowercase with underscores, class members have a trailing underscore, and constants are </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">kCamelCase</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.479.1">Class names</span></strong><span class="koboSpan" id="kobo.480.1">: Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">CamelCase</span></strong><span class="koboSpan" id="kobo.482.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">class names</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.484.1">Indentation and formatting</span></strong><span class="koboSpan" id="kobo.485.1">: Use spaces instead of tabs, with a </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">two-space indent</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.487.1">Pointer and reference expressions</span></strong><span class="koboSpan" id="kobo.488.1">: Place </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">*</span></strong><span class="koboSpan" id="kobo.490.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">&amp;</span></strong><span class="koboSpan" id="kobo.492.1"> with the variable name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">int* ptr</span></strong><span class="koboSpan" id="kobo.494.1">, not </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">int *ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">)</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.497.1">Limitations</span></strong><span class="koboSpan" id="kobo.498.1">: Avoid non-const global variables, and prefer algorithms over loops </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">where possible</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.500.1">LLVM Coding Standards</span></strong><span class="koboSpan" id="kobo.501.1">: Used in the LLVM Compiler Infrastructure, these standards emphasize </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.502.1">readability </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">and efficiency:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.504.1">Filenames</span></strong><span class="koboSpan" id="kobo.505.1">: Source files use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">.cpp</span></strong><span class="koboSpan" id="kobo.507.1"> extension, and header files </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.511.1">Variable names</span></strong><span class="koboSpan" id="kobo.512.1">: Variables and functions use </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">camelBack</span></strong><span class="koboSpan" id="kobo.514.1"> style. </span><span class="koboSpan" id="kobo.514.2">Member variables have a </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">trailing underscore.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.516.1">Class names</span></strong><span class="koboSpan" id="kobo.517.1">: Classes and structs are </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">CamelCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.521.1">Indentation and formatting</span></strong><span class="koboSpan" id="kobo.522.1">: Two spaces for indentation, with a strong emphasis on readability and avoiding </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">over-compact code.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.524.1">Pointer and reference expressions</span></strong><span class="koboSpan" id="kobo.525.1">: Place </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">*</span></strong><span class="koboSpan" id="kobo.527.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">&amp;</span></strong><span class="koboSpan" id="kobo.529.1"> adjacent to the type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">int *ptr</span></strong><span class="koboSpan" id="kobo.531.1">, not </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">int* ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">).</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.534.1">Modern C++ usage</span></strong><span class="koboSpan" id="kobo.535.1">: Encourages the use of modern C++ features </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">and patterns.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.537.1">Mozilla Coding Style</span></strong><span class="koboSpan" id="kobo.538.1">: While not as universally recognized as Google or LLVM, Mozilla’s coding style is still </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.539.1">significant, especially in projects related to </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">their technologies:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.541.1">Filenames</span></strong><span class="koboSpan" id="kobo.542.1">: Uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">.cpp</span></strong><span class="koboSpan" id="kobo.544.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1"> extensions</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.548.1">Variable names</span></strong><span class="koboSpan" id="kobo.549.1">: Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">camelCase</span></strong><span class="koboSpan" id="kobo.551.1"> for variables and functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">CamelCase</span></strong><span class="koboSpan" id="kobo.553.1"> for classes, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">SCREAMING_SNAKE_CASE</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.555.1">for constants</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.556.1">Class names</span></strong><span class="koboSpan" id="kobo.557.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">CamelCase</span></strong><span class="koboSpan" id="kobo.559.1"> is used for </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">class names</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.561.1">Indentation and formatting</span></strong><span class="koboSpan" id="kobo.562.1">: Prefer four spaces for indentation, and follow a clear block </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">separation style</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.564.1">Pointer and reference expressions</span></strong><span class="koboSpan" id="kobo.565.1">: Similar to LLVM, place </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">*</span></strong><span class="koboSpan" id="kobo.567.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">&amp;</span></strong><span class="koboSpan" id="kobo.569.1"> adjacent to </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the type</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.571.1">Emphasis on performance</span></strong><span class="koboSpan" id="kobo.572.1">: Encourages writing efficient code with a focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">browser performance</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.574.1">Each of these </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.575.1">conventions has its own philosophy and rationale. </span><span class="koboSpan" id="kobo.575.2">Google’s style guide emphasizes consistency within a vast code base and across a large number of developers. </span><span class="koboSpan" id="kobo.575.3">LLVM’s standards focus on clean, efficient code that leverages modern C++ features. </span><span class="koboSpan" id="kobo.575.4">Mozilla’s style balances readability and performance, reflecting its origins in web technology development. </span><span class="koboSpan" id="kobo.575.5">It’s important to choose a style </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.576.1">that aligns with your project’s goals, team size, and the specific technologies you </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">work with.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.578.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.579.1">In this chapter, we explored the critical role of naming programming. </span><span class="koboSpan" id="kobo.579.2">We recognized that good, consistent naming practices elevate the readability and maintainability of code, while also aiding in </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">its self-documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">We pondered over the balance between using long descriptive names and shorter names supplemented by comments, understanding that both have their place in different contexts. </span><span class="koboSpan" id="kobo.581.2">The use of domain-specific language in naming was recommended for clarity, while “magic numbers” were cautioned against due to </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">their opacity.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The influence of a variable’s scope and lifetime on its naming was also discussed, emphasizing the need for more descriptive names for those variables with larger scopes and </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">longer lifetimes.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">The chapter wrapped up by stressing the value of adhering to a coding convention for naming, which instills consistency across the code base, thereby streamlining the code reading and </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">comprehension process.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">The insights garnered from this chapter serve as a foundation for the upcoming discussion on effectively leveraging the rich static type system in C++ for safer, cleaner, and clearer code. </span><span class="koboSpan" id="kobo.587.2">In the next chapter, we will shift our focus to the effective utilization of C++’s rich static </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">type system.</span></span></p>
</div>
</body></html>