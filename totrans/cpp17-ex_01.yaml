- en: Getting Started with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides an introduction to **Object-Oriented Programming** (**OOP**)
    in C++. We start by looking into a simple program that rolls a dice. We write
    the code and compile, link, and execute the program.
  prefs: []
  type: TYPE_NORMAL
- en: Then we continue by constructing a simple object-oriented hierarchy, involving
    the `Person` base class and its two subclasses, `Student` and `Employee`. We also
    look into pointers and dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create two simple data types—stack and queue. A **stack** is constituted
    of a set of values ordered in a bottom-to-top manner, where we are interested
    in the top value only. A **queue** is a traditional queue of values, where we
    add values at the rear and inspect values at the front.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by implementing a simple game: rolling the dice. Its main purpose
    is to provide an introduction to the environment and teach you how to set up the
    project, and how to compile, link, and execute the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we start looking at object-oriented programming by writing a class hierarchy
    with `Person` as the base class and `Student` and `Employee` as subclasses. This
    provides an introduction to inheritance, encapsulation, and dynamic binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we write classes for the abstract data types stack and queue. A stack
    is a structure where we both add and remove values at the top, while a queue is
    more like a traditional queue where we add values at the rear and remove them
    from the front.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling the dice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an introduction, we start by writing a program that rolls a dice. We use
    the built-in random generator to generate an integer value between one and six,
    inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, the initial `include` directives allow us to include
    header files, which mostly hold declarations of the standard library. We need
    the `CStdLib` header file to use the random generator, the `CTime` header file
    to initiate the random generator with the current time, and the `IOStream` header
    file to write the result.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library is stored in a `namespace` called `std`. A `namespace`
    can be considered a container holding code. We gain access to the standard library
    with the `using namespace` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Every C++ program holds exactly one `main` function. The execution of the program
    always starts in the `main` function. We use the `srand` and `time` standard functions
    to initialize the random generator, and `rand` to generate the actual random value.
    The percent (`%`) is the modulus operator, which divides two integers and gives
    the remainder of the division. In this way, the value of the `dice` integer variable
    is always at least one and at most six. Finally, we write the value of the `dice`
    variable with `cout`, which is an object used by the standard library to write
    text and values.
  prefs: []
  type: TYPE_NORMAL
- en: The programs of the first four chapters were written with Visual Studio, while
    the programs of the remaining chapters are written with Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are instructions on how to create a project, write the code,
    and execute the application. When we have started Visual Studio, we follow the
    following steps to create our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we select the New and Project items in the File menu, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3286a2c4-c1ce-451b-b518-300e356a4880.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We choose the Win32 Console Application type, and name the project `Dice`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f5ba715-fd89-4045-84ae-59809b91744f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first dialog we just press the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92382e5d-80ec-45b6-8d03-e65e27d2cf03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second dialog, we choose the Empty project checkbox and click on the
    Finish button. In this way, a project without files will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/919e66ae-8eb8-418f-bb40-ffac49c8446f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we have created our project, we need to add a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8f2e8ac-3736-4e11-92ea-3d10a8f1c712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We choose a C++ File(.cpp) and name it `Main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbf1c8f0-1c72-40c1-83ff-f3ccbccc114b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we input the code in the `Main.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2c816f2-d507-42c2-bb96-0deea233f28b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we execute the program. The easiest way to do this is to choose the
    Start Debugging or Start Without Debugging menu option. In this way, the program
    is compiled, linked, and executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d544cad4-596d-4de1-9746-81edd5feacee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output of the execution is displayed in a command window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d041451b-d5b6-443a-9e1a-d7a0a2e9cbbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding classes – the Car class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue by looking at a simple class that handles a car, including its
    speed and direction. A class is a very central feature in object-oriented languages.
    In C++, its specification is made up of two parts—its definition and implementation.
    The definition part is often placed in a header file (with the `.h` suffix), while
    the implementation part is placed in a file with the `.cpp` suffix, as in the `Car.h`
    and `Car.cpp` files. However, template classes, which are introduced in [Chapter
    3](6814bf19-e75b-4083-8447-892dd8416f49.xhtml), *Building a Library Management
    System*, are stored in one file only.
  prefs: []
  type: TYPE_NORMAL
- en: A class is made up of its members, where a member is a field or a method. A
    **field** holds a value of a specific type. A **method** is a mathematical abstraction
    that may take input values and return a value. The input values of a method are
    called parameters. However, in C++ it is possible to define a function without
    parameters and without return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object is an instance of the class; we can create many objects of one class.
    The methods can be divided into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor**: A constructor is called when the object is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspector**: An inspector inspects the fields of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modificator**: A modificator modifies the values of the fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructor**: A destructor is called when the object is destroyed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, the methods of a class don''t give direct access to the fields, as
    this would mean that the method names/types would have to change if the fields
    change. Instead, the methods should give access to a class property. These are
    the conceptual elements of a class that may not map to a single field. Each member
    of the class is `public`, `protected`, or `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: A `public` member is accessible by all other parts of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `protected` member is accessible only by its own members or members of its
    subclasses, which are introduced in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `private` member is accessible by its own members only. However, that is not
    completely true. A class can invite other classes to become its friends, in which
    case they are given access to its `private` and `protected` members. We will look
    into friends in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following `Car` class definition has two constructors and one destructor.
    They always have the same name as the `Car` class in this case. The destructor
    is preceded by a tilde (`~`). A constructor without parameters is called the default
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: More than one method can have the same name, as long as they have different
    parameter lists, which is called **overloading**. More specifically, it is called
    context-free overloading. There is also context-dependent overloading, in which
    case two methods have the same name and parameter list, but different return types.
    However, context-dependent overloading is not supported by C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, a class can hold several constructors, as long as they have different
    parameter lists. However, the destructor is not allowed to have parameters. Therefore,
    a class can hold only one destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Car.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getSpeed` and `getDirection` methods are inspectors returning the current
    speed and direction of the car. The return values hold the `int` type, which is
    short for integer. They are marked as constant with the `const` keyword since
    they do not change the fields of the class. However, a constructor or destructor
    cannot be constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accelerate`, `decelerate`, `turnLeft`, and `turnRight` methods are modificators,
    setting the current speed and direction of the car. They cannot be marked as constant
    since they change the fields of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_speed` and `m_direction` fields hold the current speed and direction
    of the car. The `-m prefix` indicates that they are members of a class, as opposed
    to fields local to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation file, we must include the `Car.h` header file. The `#include`
    directive is part of the preprocessor and simply causes the content of the `Car.h` file
    to be included in the file. In the previous section, we included system files
    with the angle bracket  characters (`<` and `>`). In this case, we include local
    files with quotes (`"`). The system include files (with angle brackets) include
    system code that are part of the language, while local include files (with quotes)
    include code that we write ourselves, as part of our project. Technically, the
    system include files are often included from a special directory in the file system,
    while the local include files are often included locally in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Car.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor initializes both `speed` and `direction` and set it
    to `0`. The colon (`:`) notation is used to initialize the fields. The text between
    two slashes (`//`) and the end of the line is called a line comment and is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second constructor initializes both `speed` and `direction` to the given
    parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding constructors, it would be possible to use the assignment operator
    (`=`) instead of the class initialization notation, as in the following code.
    However, that is considered to be inefficient since the code may be optimized
    with the preceding initialization notation. Note that we use one equals sign (`=`)
    for assignments. For the comparison of two values, we use two equals signs (`==`),
    a method which is introduced in [Chapter 2](856debf4-f653-4211-928d-b3296fe56d99.xhtml), *Data
    Structures and Algorithms*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor does nothing in this class; it is included only for the sake
    of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getSpeed` and `getDirection` methods simply return the current speed and
    direction of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A plus sign directly followed by an equals sign is called **compound assignment**
    and causes the right value to be added to the left value. In the same way, a minus
    sign directly followed by an equals sign causes the right value to be subtracted
    from the left value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text between a slash (`/`) directly followed by an asterisk (`*`), and
    an asterisk directly followed by a slash, is called a **block comment** and is
    ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to test our class. To do so, we include the `Car.h` file, just
    as we did in the `Car.cpp` file. However, we also include the system `IOStream` header
    file. As in the previous section, the system headers are enclosed in arrow brackets
    (`<` and `>`). We also need to use the `namespace std` to use its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In C++, a function can be a part of a class or can be free-standing without
    a class. Functions of a class are often called methods. A function is a mathematical
    abstraction. It has input values, which are called parameters, and returns a value.
    However, in C++ a function is allowed to have zero parameters, and it may return
    the special type void, indicating that it does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, the execution of the program always starts
    at the function named `main`, and every program must have exactly one function
    named `main`. Unlike some other languages, it is not necessary to name the file
    `Main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in this book, every file holding the `main` function is named `Main.cpp`
    out of convenience. The `void` keyword indicates that `main` does not return a
    value. Note that while constructors and destructors never return values, and are
    not marked with `void`, other methods and functions that do not return values
    must be marked with `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an object of the `Car` class that we call `redVolvo`. An object is
    an instance of the class; `redVolvo` is one of many cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing information, we use the `cout` object (short for console output),
    which normally writes to a text window. The operator made up of two left arrow
    brackets (`<<`) is called the output stream operator. The `endl` directive makes
    the next output start at the beginning of the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A `blueFiat` object is a constant object of the `Car` class. This means that
    it can only be initialized by one of the constructors and then inspected, but
    not modified. More specifically, only constant methods can be called on a constant
    object, and only methods that do not modify the fields of the object can be constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the code, the output is displayed in a command window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01041d1d-7233-4864-95f8-a124b9836463.png)'
  prefs: []
  type: TYPE_IMG
- en: Extending the Car class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we modify the `Car` class. In the earlier version, we initialized
    the fields in the constructors. An alternative way to initialize the fields is
    to initialize them directly in the class definition. However, this feature shall
    be used with care since it may result in unnecessary initializations. If the second
    constructor in the `Car` class is called, the fields are initialized twice, which
    is ineffective.
  prefs: []
  type: TYPE_NORMAL
- en: '**Car.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `Car` class is defined in the `Car.h` file, its methods are defined
    in the `Car.cpp` file. Note that we begin by including the `Car.h` file, in order
    for the definitions of the methods to comply with their declaration in `Car.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Car.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the `Car` class of the previous section has some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to accelerate the car indefinitely, and it is possible to decelerate
    the car to a negative speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to turn the car so that the direction is negative or more than
    360 degrees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by setting the maximum speed of the car to `200` miles/hour. If
    the speed exceeds `200` miles per hour we set it to `200` miles/hour. We use the
    `if` statement, which takes a condition, and executes the following statement
    if the condition is true. In the case here, the statement `(m_speed = 200;)` is
    enclosed by brackets. This is not necessary since it is only one statement. However,
    it would be necessary in the case of more than one statement. In this book, we
    always use the brackets for clarity, regardless of the number of statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Car.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the speed becomes negative, we change the sign of the speed to make it positive.
    Note that we cannot write `m_speed -= m_speed`. That would set the speed to zero
    since it would subtract the speed from itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since the value is negative, it becomes positive when we change the sign. We
    also turn the car by `180` degrees to change its direction. Note that we also,
    in this case, must check that the car does not exceed the speed limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we must check whether the direction is less than 180 degrees.
    If it is, we add `180` degrees; otherwise, we subtract `180` degrees to keep the
    direction in the interval `0` to `360` degrees. We use the `if...else` statement
    to do that. If the condition of the `if` statement is not true, the statement
    after the `else` keyword is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When turning the car, we use the modulo (`%`), operator. When dividing by `360`,
    the modulo operator gives the remainder of the division. For instance, when 370
    is divided by `360` the remainder is 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function creates one object of the `Car` class—`redVolvo`. We start
    by writing its speed and direction, then we accelerate and turn left and again
    write its speed and acceleration. Finally, we decelerate and turn right and write
    its speed and direction one last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the code, the output is displayed in a command window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4ae7e52-8fdf-4251-80bd-1de8d8b555ee.png)'
  prefs: []
  type: TYPE_IMG
- en: A class hierarchy – the Person, Student, and Employee classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue with a class hierarchy, where `Person` is the base class with
    `Student` and `Employee` as its subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bedb9c8-d793-4af2-9526-82118247b200.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a person has a name, we use the C++ standard class string to store the name.
    The `virtual` keyword marks that the `print` method is subject to dynamic binding,
    which we will look into later in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Person.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `String` header, which allows us to use the `string` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Person.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Student` and `Employee` classes are subclasses of `Person`, and they inherit
    `Person` publicly. Sometimes the term extension is used instead of inheritance.
    The inheritance can be `public`, `protected`, or `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: With `public` inheritance, all members of the base class have the same access
    to the subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `protected` inheritance, all `public` members of the base class become
    protected in the subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `private` inheritance, all `public` and `protected` members of the base
    class become private in the subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Student` and `Employee` classes have the text fields `m_university` and
    `m_company`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Student.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The file `Student.cpp` defines the methods of the `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Student.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The subclass can call a constructor of the base class by stating its `name`
    with the colon notation (`:`). The constructor of `Student` calls the constructor
    of `Person` with the name as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We must state that we call `print` in `Person` rather than `Student` by using
    the double colon notation (`::`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `Employee` class is similar to `Student`. However, it holds the field `c_company` instead
    of `m_university`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Employee.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The file `Employee.cpp` defines the methods of the `Employee` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Employee.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the name of the person and the company they are
    employed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `main` function starts by including the system header files `String`
    and `IOStream`, which hold declarations about string handling and input and output
    streams. Since all standard headers are included in the standard namespace, we
    gain access to the system declaration with the `using` the `namespace` directive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the three objects, `Monica`, `Demi`, and `Charles`, and we call `print`
    on each of them. In all three cases the `print` method of the class `Person`,
    `Student`, and `Employee` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The asterisk (`*`) marks that `personPtr` is a pointer to an object of `Person`,
    rather than an object of `Person`. A pointer to an object holds the memory address
    of the object, rather than the object itself. However, at the moment it does not
    hold any address at all. We will soon assign it to the address of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The ampersand (`&`) is an operator that provides the address of an object, which
    is assigned to the pointer `personPtr`. We assign `personPtr` in turn to the addresses
    of the `Person`, `Student`, and `Employee` objects and call `print` in each case.
    As `print` is marked as virtual in `Person`, `print`, in the class of the object
    the pointer currently points at, is called. Since `print` is marked as virtual
    in the base class `Person`, it is not necessary to mark `print` as virtual in
    the subclasses `Student` and `Employee`. When accessing a member of a pointer
    to an object, we use the arrow (`->`) operator instead of the point operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `personPtr` points at an object of `Person`, print in `Person` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When `personPtr` points at an object of `Student`, `print` in `Student` is
    called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When `personPtr` points at an object of `Employee`, print `Employee` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This process is called dynamic binding. If we omit the virtual marking in `Person`,
    static binding would occur and print in `Person` would be called in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of object-oriented programming is built on the three cornerstones
    of encapsulation, inheritance, and dynamic binding. A language that does not support
    any of these features cannot be called object-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: A simple data type – the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is a simple data type where we add values to the top, remove the
    value on the top, and can only inspect the top value. In this section, we implement
    a stack of integers. In the next chapter, we look into template classes that can
    hold values of arbitrary types. We use a linked list, which is a construction
    where a pointer points at the first cell in the linked list, and each cell holds
    a pointer to the next cell in the linked list. Naturally, the linked list must
    end eventually. We use `nullptr` to mark the end of the linked list, which is
    a C++ standard pointer to a special null address.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need a class to hold each cell of the linked list. The cell
    holds an integer value and a pointer to the next cell in the list, or `nullptr`
    if it is the last cell of the list. In the following section, we will look into
    cell classes that hold pointers to both the previous and the next cell.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cell.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to implement methods directly in the class definition; they
    are called inline methods. However, it is usually done for short methods only.
    A rule of thumb is that inline methods shall not exceed one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Each cell holds a value and the address of the next cell in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Cell.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A cell is initialized with a value and a pointer to the next cell in the linked
    list. Note that `m_next` has the value `nullptr` if the cell is the last cell
    in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In a stack, we are in interested in its top value only. The default constructor
    initializes the stack to be empty. Push adds a value at the top of the stack,
    top returns the top value, pop removes the top value, size returns the number
    of values in the stack, and empty returns `true` if the stack is empty. The bool
    type is a logical type that can hold the values `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_firstCellPtr` field is a pointer to the first cell of the linked list
    holding the values of the stack. When the stack is empty, `m_firstCellPtr` will
    hold the value `nullptr`. The `m_size` field holds the current size of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `CAssert` header is included for the assert macro, which is used to test
    whether certain conditions are true. A macro is part of the preprocessor that
    performs certain text replacements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor sets the stack to empty by initializing the pointer
    to the first cell to `nullptr` and the size to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When pushing a new value at the top of the stack, we use the new operator to
    dynamically allocate the memory needed for the cell. If we run out of memory,
    `nullptr` is returned, which is tested by the assert macro. If `m_firstCellPtr`
    equals `nullptr`, the execution is aborted with an error message. The exclamation
    mark (`!`) followed by an equals sign (`=`) constitutes the not-equal operator.
    Two plus signs (`++`) constitute the increments operator, which means that the
    value is increased by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The increment operator actually comes in two versions—prefix (`++m_size`) and
    postfix (`m_size++`). In the prefix case, the value is first increased and then
    returned, while in the postfix case the value is increased but the original value
    is returned. However, in this case, it does not matter which version we use since
    we are only interested in the result—that the value of `m_size` is increased by
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When returning the top value of the stack, we must first check that the stack
    is not empty, since it would be illogical to return the top value of an empty
    stack. If the stack is empty, the execution is aborted with an error message.
    The single exclamation mark (`!`) is the logical `not` operator. We return the
    top value, which is stored in the first cell in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We must also check that the stack is not empty when popping the top value of
    the stack. We set the pointer to the first cell in the linked list to point at
    the next cell. However, before that, we must store the first pointer, `deleteCellPtr`,
    in order to deallocate the memory of the cell it points at.
  prefs: []
  type: TYPE_NORMAL
- en: 'We deallocate the memory with the `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way as the increment operator above, two minus signs (`--`) constitutes
    the `decrement` operator, which decreases the value by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `size` method simply returns the value of the `m_size` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A stack is empty if the pointer to the first cell pointer equals `nullptr`.
    Informally, we say that the pointer is null if it equals `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We test the stack by pushing, topping, and popping some values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When printing a Boolean value, the `stream` operator does not print `true`
    or `false`, but rather one for `true` and zero for `false`. In order to really
    print `true` or `false` we use the `condition` operator. It takes three values,
    separated by a question mark (`?`) and a colon (`:`). If the first value is `true`
    the second value is returned. If the first value is `false` the third value is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A more advanced data type – the queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue is a model of a traditional queue; we enter values at the rear, and
    inspect and remove values at the front. It is also possible to decide on the number
    of values it holds and whether it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the stack in the previous section, we implement the queue with a
    linked list. We reuse the `Cell` class; however, in the queue case, we need to
    set the next link of a cell. Therefore, we rename `next` to `getNext` and add
    the new `setNext` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cell.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the queue with a linked list in a manner similar to the stack.
    The constructor initializes an empty queue, `enter` enters a value at the rear
    of the queue, `remove` removes the value at its front, `size` return the current
    size of the queue, and `empty` returns `true` if it is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queue.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the stack case, we were only interested in its top, which was stored at
    the beginning of the linked list. In the queue case, we are interested in both
    the front and rear, which means that we need to access both the first and last
    cell of the linked list. Therefore, we have the two pointers, `m_firstCellPtr`
    and `m_lastCellPtr`, pointing at the first and last cell in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Queue.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When the queue is created, it is empty; the pointers are null and the size
    is zero. Since there are no cells in the linked list, both the cell pointers points
    at `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When entering a new value at the rear of the queue, we check if the queue is
    empty. If it is empty, both the pointers are set to point at the new cell. If
    it is not empty, the last cell next-pointer is set to point at the new cell, and
    then the last cell pointer is set to be the new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method simply returns the value of the first cell in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove` method sets the first cell to point at the second cell. However,
    first we must store its address in order to deallocate its memory with the C++
    standard `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the queue by entering and removing a few values. We enter the values
    one, two, and three, which are placed in the queue in that order. We then remove
    the first two values, and enter the value four. Then the queue holds the values
    three and four:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked into the basics of object-oriented programming.
    We have started by creating a project and executing a program for rolling a dice.
    We have also created a class hierarchy, including the base class `Person` and
    its two subclasses `Student` and `Employee`. By defining pointers to the objects,
    we have performed the dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have created two data types—stack and queue. A stack is a structure
    where we are interested in the value at the top only. We can add values at the
    top, inspect the top value, and remove the top value. A queue is a traditional
    queue where we enter values at the rear while we inspect and remove values from
    the front.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to create data types, and more advanced
    data types, such as lists and sets. We will also look into to more advanced features
    of C++.
  prefs: []
  type: TYPE_NORMAL
