<html><head></head><body>
<div id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Introducing Low Latency Application Development in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Let us kick off our journey with low latency applications by introducing them in this first chapter. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will first understand the behavior and requirements of latency-sensitive and latency-critical applications. </span><span class="koboSpan" id="kobo.3.3">We will understand the huge business impact that application latencies have for businesses that rely on quick and strict </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">response times.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will also discuss why C++ is one of the most preferred programming languages when it comes to low latency application development. </span><span class="koboSpan" id="kobo.5.2">We will spend a large part of this book building an entire low latency electronic trading system from scratch in C++. </span><span class="koboSpan" id="kobo.5.3">So, this will serve as a good chapter for you to understand the motivation for using C++ as well as what makes it the most popular language for low </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">latency applications.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will also present some of the important low latency applications in different business areas. </span><span class="koboSpan" id="kobo.7.2">Part of the motivation is to make you understand that latencies are indeed very critical in different business areas for use cases that are sensitive to response times. </span><span class="koboSpan" id="kobo.7.3">The other part of the motivation is to identify the similarities in the behavior, expectations, design, and implementation of these applications. </span><span class="koboSpan" id="kobo.7.4">Even though they solve different business problems, the low latency requirements of these applications are often built on similar technical design and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">implementation principles.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Understanding the requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">latency-sensitive applications</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Understanding why C++ is the preferred </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">programming language</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Introducing some important low </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">latency applications</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">In order to build ultra-low latency applications effectively, we should first understand the terms and concepts we will refer to throughout the rest of this book. </span><span class="koboSpan" id="kobo.17.2">We should also understand why C++ has emerged as the clear choice for most low latency application development. </span><span class="koboSpan" id="kobo.17.3">It is also important to always keep the business impact of low latencies in mind because the aim is to build low latency applications to benefit the business’s bottom line. </span><span class="koboSpan" id="kobo.17.4">This chapter discusses these ideas so that you can build a good foundation before we dive into the technical details in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this book.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.19.1">Understanding requirements for latency-sensitive applications</span></h1>
<p><span class="koboSpan" id="kobo.20.1">In this section, we will discuss some concepts that are required to build an understanding of what </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.21.1">metrics matter for latency-sensitive applications. </span><span class="koboSpan" id="kobo.21.2">First, let’s define clearly what latency means and what latency-sensitive </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">applications are.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.23.1">Latency</span></strong><span class="koboSpan" id="kobo.24.1"> is defined as the time delay between when a task is started to the time when the task is finished. </span><span class="koboSpan" id="kobo.24.2">By definition, any </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.25.1">processing or work will incur some overhead or latency – that is, no system has zero latency unless the system does absolutely no work. </span><span class="koboSpan" id="kobo.25.2">The important detail here is that some systems might have latency that is an infinitesimal fraction of a millisecond and the tolerance for an additional microsecond there might </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">be low.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Low latency applications are applications that execute tasks and respond or return results as quickly as possible. </span><span class="koboSpan" id="kobo.27.2">The point here is that reaction latency is an important criterion for </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.28.1">such applications where higher latencies can degrade performance or even render an application completely useless. </span><span class="koboSpan" id="kobo.28.2">On the other hand, when such applications perform with the low latencies that are expected of them, they can beat the competition, run at maximum speed, achieve maximum throughput, or increase productivity and improve the user experience – depending on the application </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">and business.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Low latency can be thought of as both a quantitative as well as a qualitative term. </span><span class="koboSpan" id="kobo.30.2">The quantitative aspect is pretty obvious, but the qualitative aspect might not necessarily be obvious. </span><span class="koboSpan" id="kobo.30.3">Depending on the context, architects and developers might be willing to accept higher latencies in some cases but be unwilling to accept an extra microsecond in some contexts. </span><span class="koboSpan" id="kobo.30.4">For instance, if a user refreshes a web page or they wait for a video to load, a few seconds of latency is quite acceptable. </span><span class="koboSpan" id="kobo.30.5">However, once the video loads and starts playing, it can no longer incur a few seconds of latency to render or display without negatively impacting the user experience. </span><span class="koboSpan" id="kobo.30.6">An extreme example is high-speed financial trading systems where a few extra microseconds can make a huge difference between a profitable firm and a firm that cannot compete </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">In the following subsections, we will present some nomenclature that applies to low latency applications. </span><span class="koboSpan" id="kobo.32.2">It is important to understand these terms well so that we can continue our </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.33.1">discussion on low latency applications, as we will refer to these concepts frequently. </span><span class="koboSpan" id="kobo.33.2">The concepts and terms we will discuss next are used to differentiate between different latency-sensitive applications, the measurement of latencies, and the requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">these applications.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.35.1">Understanding latency-sensitive versus latency-critical applications</span></h2>
<p><span class="koboSpan" id="kobo.36.1">There is a subtle but important difference between the terms </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">latency-sensitive applications</span></strong><span class="koboSpan" id="kobo.38.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">latency-critical applications</span></strong><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">A latency-sensitive application is one in which, as performance latencies are reduced, it improves the business impact or profitability. </span><span class="koboSpan" id="kobo.40.3">So, the system might still be functional and possibly profitable at higher performance </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.41.1">latencies but can be significantly more profitable if latencies are reduced. </span><span class="koboSpan" id="kobo.41.2">Examples of such applications would be operating systems (OSes), web browsers, databases, and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">A latency-critical application, on the other hand, is one that fails completely if performance latency is </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.44.1">higher than a certain threshold. </span><span class="koboSpan" id="kobo.44.2">The point here is that while latency-sensitive applications might only lose part of their profitability at higher latencies, latency-critical applications fail entirely at high enough latencies. </span><span class="koboSpan" id="kobo.44.3">Examples of such applications are traffic control systems, financial trading systems, autonomous vehicles, and some </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">medical appliances.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.46.1">Measuring latency</span></h2>
<p><span class="koboSpan" id="kobo.47.1">In this section, we will discuss different methods of measuring latency. </span><span class="koboSpan" id="kobo.47.2">The real difference between these methods comes down to what is considered the beginning of the processing task </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.48.1">and what is the end of the processing task. </span><span class="koboSpan" id="kobo.48.2">Another approach would be the units of what we are measuring – time is the most common one but in some cases, CPU clock cycles can also be used if it comes down to instruction-level measurements. </span><span class="koboSpan" id="kobo.48.3">Let’s look at the different measurements next, but first, we present a diagram of a generic server-client system without diving into the specifics of the use case or transport protocols. </span><span class="koboSpan" id="kobo.48.4">This is because measuring latency is generic and applies to many different applications with this kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">server-client setup.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.50.1"><img alt="Figure 1.1 – A general server-client system with timestamps between different hops " src="image/Figure_1.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.51.1">Figure 1.1 – A general server-client system with timestamps between different hops</span></p>
<p><span class="koboSpan" id="kobo.52.1">We present this diagram </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.53.1">here because, in the next few subsections, we will define and understand latencies between the different hops on the round-trip path from the server client and back to </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the server.</span></span></p>
<h3><span class="koboSpan" id="kobo.55.1">Time to first byte</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.56.1">Time to first byte</span></strong><span class="koboSpan" id="kobo.57.1"> is measured as the time elapsed from when the sender sends the first byte of a </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.58.1">request (or response) to the moment </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.59.1">when the receiver receives the first byte. </span><span class="koboSpan" id="kobo.59.2">This typically (but not necessarily) applies to network links or systems where there are data transfer operations that are latency-sensitive. </span><span class="koboSpan" id="kobo.59.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.61.1">.1</span></em><span class="koboSpan" id="kobo.62.1">, time to first byte would be the difference between </span><span class="koboSpan" id="kobo.63.1"><img alt="" src="image/Formula_1.1.png"/></span><span class="koboSpan" id="kobo.64.1"> and </span><span class="koboSpan" id="kobo.65.1"><img alt="" src="image/Formula_1.2.png"/></span> </p>
<h3><span class="koboSpan" id="kobo.66.1">Round-trip time</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.67.1">Round-trip time</span></strong><span class="koboSpan" id="kobo.68.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.69.1">RTT</span></strong><span class="koboSpan" id="kobo.70.1">) is the sum of the time it takes for a packet to travel from one process to another and </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.71.1">then the time it takes for the response </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.72.1">packet to reach the original process. </span><span class="koboSpan" id="kobo.72.2">Again, this is typically (but not necessarily) used for network traffic going back and forth between server and client processes, but can also be used for two processes communicating </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">in general.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">RTT, by default, includes the time taken by the server process to read, process, and respond to the request sent by the sender – that is, RTT generally includes server processing </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.75.1">times. </span><span class="koboSpan" id="kobo.75.2">In the context of </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.76.1">electronic trading, the true RTT latency is based on </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">three components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.78.1">First, the time it </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.79.1">takes for information from the exchange to reach </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the participant</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Second, the time it takes for the execution of the algorithms to analyze the information and make </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">a decision</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">Finally, the time it take for the decision to reach the exchange and get processed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">matching engine</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.85.1">We will discuss this more in the last section of this book, </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Analyzing and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.87.1">improving performance</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.89.1">Tick-to-trade</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.90.1">Tick-to-trade</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.92.1">TTT</span></strong><span class="koboSpan" id="kobo.93.1">) is similar to RTT and is a term most commonly used in electronic trading systems. </span><span class="koboSpan" id="kobo.93.2">TTT is defined as the time from when a packet (usually a market data packet) first hits a </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.94.1">participant’s infrastructure (trading server) to the time when the participant is done processing the packet and sends a </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.95.1">packet out (order request) to the trading exchange. </span><span class="koboSpan" id="kobo.95.2">So, TTT includes the time spent by the trading infrastructure to read the packet, process it, calculate trading signals, generate an order request in reaction to that, and </span><em class="italic"><span class="koboSpan" id="kobo.96.1">put it on the wire</span></em><span class="koboSpan" id="kobo.97.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Putting it on the wire</span></strong><span class="koboSpan" id="kobo.99.1"> typically means writing something to a network </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.100.1">socket. </span><span class="koboSpan" id="kobo.100.2">We will revisit this topic and explore it in greater detail in the last section of this book, </span><em class="italic"><span class="koboSpan" id="kobo.101.1">Analyzing and improving performance</span></em><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.104.1">.1</span></em><span class="koboSpan" id="kobo.105.1">, TTT would be the difference between </span><span class="koboSpan" id="kobo.106.1"><img alt="" src="image/Formula_1.2.png"/></span> <span class="No-Break"><span class="koboSpan" id="kobo.107.1">and </span><span class="koboSpan" id="kobo.108.1"><img alt="" src="image/Formula_1.4.png"/></span></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.110.1">CPU clock cycles</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.111.1">CPU clock cycles</span></strong><span class="koboSpan" id="kobo.112.1"> are basically </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.113.1">the smallest increment of work </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.114.1">that can be done by the CPU processor. </span><span class="koboSpan" id="kobo.114.2">In reality, they are the amount of time between two pulses of the oscillator that drives the CPU processor. </span><span class="koboSpan" id="kobo.114.3">Measuring CPU clock cycles is typically used to measure latency at the instruction level – that is, at an extremely low level at the processor level. </span><span class="koboSpan" id="kobo.114.4">C++ is both a low-level as well as a high-level language; it lets you get as close to the hardware as needed and also provides higher-level abstractions such as classes, templates, and so on. </span><span class="koboSpan" id="kobo.114.5">But generally, C++ developers do not spend a lot of time dealing with extremely low-level or possibly assembly code. </span><span class="koboSpan" id="kobo.114.6">This means that the compiled machine code might not be exactly what a C++ developer expects. </span><span class="koboSpan" id="kobo.114.7">Additionally, depending on the compiler versions, the processor architectures, and so on, there may be even more sources of differences. </span><span class="koboSpan" id="kobo.114.8">So, for extremely performance-sensitive low latency code, it is often </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.115.1">not uncommon for engineers to </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.116.1">measure how many instructions are executed and how many CPU clock cycles are required to do so. </span><span class="koboSpan" id="kobo.116.2">This level of optimization is typically the highest level of optimization possible, alongside </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">kernel-level optimizations.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">Now that we have seen some different methods of measuring latencies in different applications, in the next section, we will look at some latency summary metrics and how each one of them can be important under </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">different scenarios.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.120.1">Differentiating between latency metrics</span></h2>
<p><span class="koboSpan" id="kobo.121.1">The relative importance of a specific latency metric over the other depends on the application and </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.122.1">the business itself. </span><span class="koboSpan" id="kobo.122.2">As an example, a latency-critical application such as an autonomous vehicle software system cares about peak latency much more than the mean latency. </span><span class="koboSpan" id="kobo.122.3">Low latency electronic trading systems typically care more about mean latency and smaller latency variance than they do about peak latency. </span><span class="koboSpan" id="kobo.122.4">Video streaming and playback applications might generally prioritize high throughput over lower latency variance due to the nature of the application and </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the consumers.</span></span></p>
<h3><span class="koboSpan" id="kobo.124.1">Throughput versus latency</span></h3>
<p><span class="koboSpan" id="kobo.125.1">Before we look </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.126.1">at the metrics themselves, first, we need to clearly </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.127.1">understand the difference between two terms – </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">throughput</span></strong><span class="koboSpan" id="kobo.129.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">latency</span></strong><span class="koboSpan" id="kobo.131.1"> – which are very similar to each other and often used interchangeably but should not be. </span><span class="koboSpan" id="kobo.131.2">Throughput is defined as how much work gets done in a certain period of time, and latency is how quickly a single task is completed. </span><span class="koboSpan" id="kobo.131.3">To improve throughput, the usual approach is to introduce parallelism and add additional computing, memory, and networking resources. </span><span class="koboSpan" id="kobo.131.4">Note that each individual task might not be processed as quickly as possible, but overall, more tasks will be completed after a </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.132.1">certain amount of time. </span><span class="koboSpan" id="kobo.132.2">This is because, while being </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.133.1">processed individually, each task might take longer than in a low latency setup, but the parallelism boosts throughput over a set of tasks. </span><span class="koboSpan" id="kobo.133.2">Latency, on the other hand, is measured for each individual task from beginning to finish, even if fewer tasks are </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">executed overall.</span></span></p>
<h3><span class="koboSpan" id="kobo.135.1">Mean latency</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.136.1">Mean latency</span></strong><span class="koboSpan" id="kobo.137.1"> is basically the </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.138.1">expected average response time of a system. </span><span class="koboSpan" id="kobo.138.2">It is simply the average of all the latency measurement observations. </span><span class="koboSpan" id="kobo.138.3">This metric includes large outliers, so can be a noisy metric for systems that experience a large range of </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">performance latencies.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Median latency</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.141.1">Median latency</span></strong><span class="koboSpan" id="kobo.142.1"> is typically a better metric for the expected response time of a system. </span><span class="koboSpan" id="kobo.142.2">Since it is </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.143.1">the median of the latency measurement observations, it excludes the impact of large outliers. </span><span class="koboSpan" id="kobo.143.2">Due to this, it is sometimes preferred over the mean </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">latency metric.</span></span></p>
<h3><span class="koboSpan" id="kobo.145.1">Peak latency</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.146.1">Peak latency</span></strong><span class="koboSpan" id="kobo.147.1"> is an important </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.148.1">metric for systems where a single large outlier in performance can have a devastating impact on the system. </span><span class="koboSpan" id="kobo.148.2">Large values of peak latency can also significantly influence the mean latency metric of </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the system.</span></span></p>
<h3><span class="koboSpan" id="kobo.150.1">Latency variance</span></h3>
<p><span class="koboSpan" id="kobo.151.1">For systems that </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.152.1">require a latency profile that is as deterministic as possible, the actual </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">variance</span></strong><span class="koboSpan" id="kobo.154.1"> of the performance latency is an important metric. </span><span class="koboSpan" id="kobo.154.2">This is typically important where the expected latencies are quite predictable. </span><span class="koboSpan" id="kobo.154.3">For systems with low latency variance, the mean, median, and peak latencies are all expected to be quite close to </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">each other.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.156.1">Requirements of latency-sensitive applications</span></h2>
<p><span class="koboSpan" id="kobo.157.1">In this section, we will formally describe the behavior of latency-sensitive applications and the </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.158.1">performance profile that these applications are expected to adhere to. </span><span class="koboSpan" id="kobo.158.2">Obviously, latency-sensitive applications need low latency performance, but here we will try to explore minor subtleties in the term </span><em class="italic"><span class="koboSpan" id="kobo.159.1">low latency</span></em><span class="koboSpan" id="kobo.160.1"> and discuss some different ways of looking </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">at it.</span></span></p>
<h3><span class="koboSpan" id="kobo.162.1">Correctness and robustness</span></h3>
<p><span class="koboSpan" id="kobo.163.1">When we think of latency-sensitive applications, it is often the case that we think low latency is the single </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.164.1">most important aspect of such applications. </span><span class="koboSpan" id="kobo.164.2">But in reality, a huge requirement of such applications is correctness and we mean very high levels of robustness and fault tolerance. </span><span class="koboSpan" id="kobo.164.3">Intuitively, this idea should make complete sense; these applications require very low latency to be successful, which then should tell you that these applications also have very high throughput and need to process huge amounts of inputs and produce a large number of outputs. </span><span class="koboSpan" id="kobo.164.4">Hence, the system needs to achieve very close to 100% correctness and be very robust as well for the application to be successful in their business area. </span><span class="koboSpan" id="kobo.164.5">Additionally, the correctness and robustness requirements need to be maintained as the application grows and changes during </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">its lifetime.</span></span></p>
<h3><span class="koboSpan" id="kobo.166.1">Low latencies on average</span></h3>
<p><span class="koboSpan" id="kobo.167.1">This is the most </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.168.1">obvious requirement when we think about latency-sensitive applications. </span><span class="koboSpan" id="kobo.168.2">The expected reaction or processing latency needs to be as low as possible for the application or business overall to succeed. </span><span class="koboSpan" id="kobo.168.3">Here, we care about the mean and median performance latency and need it to be as low as possible. </span><span class="koboSpan" id="kobo.168.4">By design, this means the system cannot have too many outliers or very high peaks in </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">performance latency.</span></span></p>
<h3><span class="koboSpan" id="kobo.170.1">Capped peak latency</span></h3>
<p><span class="koboSpan" id="kobo.171.1">We use the term </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">capped peak latency</span></strong><span class="koboSpan" id="kobo.173.1"> to refer to the requirement that there needs to be a well-defined </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.174.1">upper threshold </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.175.1">for the maximum possible latency the application can ever encounter. </span><span class="koboSpan" id="kobo.175.2">This behavior is important for all latency-sensitive applications, but most important for latency-critical applications. </span><span class="koboSpan" id="kobo.175.3">But even in the general case, applications that have extremely high-performance latency for a handful of cases will typically destroy the </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.176.1">performance of the system. </span><span class="koboSpan" id="kobo.176.2">What this really means is that the application needs to handle any input, scenario, or sequence of events and do so within a low latency period. </span><span class="koboSpan" id="kobo.176.3">Of course, the performance to handle a very rare and specific scenario can possibly be much higher than the most likely case, but the point here is that it cannot be unbounded </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">or unacceptable.</span></span></p>
<h3><span class="koboSpan" id="kobo.178.1">Predictable latency – low latency variance</span></h3>
<p><span class="koboSpan" id="kobo.179.1">Some applications prefer that the expected performance latency is predictable, even if that means sacrificing </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.180.1">latency a little bit if the average latency metric is higher than it could be. </span><span class="koboSpan" id="kobo.180.2">What this really means is that such applications will make sure that the expected performance latency for all kinds of different inputs or events has as little variance as possible. </span><span class="koboSpan" id="kobo.180.3">It is impossible to achieve zero latency variance, but some choices can be made in data structures, algorithms, code implementation, and setup to try to minimize this as much </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">as possible.</span></span></p>
<h3><span class="koboSpan" id="kobo.182.1">High throughput</span></h3>
<p><span class="koboSpan" id="kobo.183.1">As mentioned before, low latency and throughput are related but not identical. </span><span class="koboSpan" id="kobo.183.2">For that reason, sometimes </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.184.1">some applications that need the highest throughput possible might have some differences in design and implementation to maximize throughput. </span><span class="koboSpan" id="kobo.184.2">The point is that maximizing throughput might come at the cost of sacrificing average performance latencies or increasing peak latencies to </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">achieve that.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">In this section, we introduced the concepts that apply to low latency application performance and the business impact of those metrics. </span><span class="koboSpan" id="kobo.186.2">We will need these concepts in the rest of the book when we refer to the performance of the applications we build. </span><span class="koboSpan" id="kobo.186.3">Next, we will move the conversation forward and explore the programming languages available for low latency application development. </span><span class="koboSpan" id="kobo.186.4">We will discuss the characteristics of the languages that support low latency applications and understand why C++ has risen to the top of the list when it comes to developing and improving </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">latency-sensitive applications.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.188.1">Understanding why C++ is the preferred programming language</span></h1>
<p><span class="koboSpan" id="kobo.189.1">There are several high-level language choices when it comes to low latency applications – Java, Scala, Go, and C++. </span><span class="koboSpan" id="kobo.189.2">In this section, we will discuss why C++ is one of the most popular languages when it comes to low latency applications. </span><span class="koboSpan" id="kobo.189.3">We will discuss several characteristics of the C++ language that support the high-level language constructs to support large code bases. </span><span class="koboSpan" id="kobo.189.4">The power of C++ is that it also provides very low-level access, similar to the C programming language, to support a very high level of control </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">and optimization.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.191.1">Compiled language</span></h2>
<p><span class="koboSpan" id="kobo.192.1">C++ is a compiled language and not an interpreted language. </span><span class="koboSpan" id="kobo.192.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">compiled language</span></strong><span class="koboSpan" id="kobo.194.1"> is a programming </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.195.1">language where the source code is translated into a machine code binary that is ready to run on a specific architecture. </span><span class="koboSpan" id="kobo.195.2">Examples of compiled languages are C, C++, Erlang, Haskell, Rust, and Go. </span><span class="koboSpan" id="kobo.195.3">The alternative to compiled languages is interpreted languages. </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Interpreted languages</span></strong><span class="koboSpan" id="kobo.197.1"> are different in the sense that the program is run by an interpreter, which runs through the source </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.198.1">line by line and executes each command. </span><span class="koboSpan" id="kobo.198.2">Some examples of interpreted languages are Ruby, Python, </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">and JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Interpreted languages are inherently slower than compiled languages because, unlike compiled languages where the translation into machine instructions is done at compile time, here the interpretation to machine instructions is done at runtime. </span><span class="koboSpan" id="kobo.200.2">However, with the development of just-in-time compilation, interpreted languages are not tremendously slower. </span><span class="koboSpan" id="kobo.200.3">For compiled languages, the code is already pre-built for the target hardware so there is no extra interpretation step at runtime. </span><span class="koboSpan" id="kobo.200.4">Since C++ is a compiled language, it gives the developers a lot of control over the hardware. </span><span class="koboSpan" id="kobo.200.5">This means competent developers can optimize things such as memory management, CPU usage, cache performance, and so on. </span><span class="koboSpan" id="kobo.200.6">Additionally, since compiled languages are converted into machine code for specific hardware at compile time, it can be optimized to a large degree. </span><span class="koboSpan" id="kobo.200.7">Hence, compiled languages in general, and especially C++, are faster and more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to execute.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.202.1">Closer to hardware – low-level language</span></h2>
<p><span class="koboSpan" id="kobo.203.1">Compared to other popular programming languages such as Python, Java, and so on, C++ is low level so it’s extremely close to the hardware. </span><span class="koboSpan" id="kobo.203.2">This is especially useful when the software is tightly </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.204.1">coupled with the target hardware it runs on and possibly even in cases where low-level support is required. </span><span class="koboSpan" id="kobo.204.2">Being extremely close to the hardware also means that there is a significant speed advantage when building systems in C++. </span><span class="koboSpan" id="kobo.204.3">Especially in low latency applications such as </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">high-frequency trading</span></strong><span class="koboSpan" id="kobo.206.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">HFT</span></strong><span class="koboSpan" id="kobo.208.1">) where a few microseconds can make a huge difference, C++ is </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.209.1">generally the established gold standard in </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the industry.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">We will discuss an example of how being closer to the hardware helps boost C++ performance over another language such as Java. </span><span class="koboSpan" id="kobo.211.2">A C/C++ pointer is the actual address of an object in memory. </span><span class="koboSpan" id="kobo.211.3">So, the software can access memory and objects in memory directly without needing extra abstractions that would slow it down. </span><span class="koboSpan" id="kobo.211.4">This, however, does mean that the application developer will often have to explicitly manage the creation, ownership, destruction, and lifetime of objects instead of relying on the programming language to manage things for you as in Python or Java. </span><span class="koboSpan" id="kobo.211.5">An extreme case of C++ being close to the hardware is that it is possible to call assembly instructions straight from C++ statements – we will see an example of this in </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">later chapters.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.213.1">Deterministic usage of resources</span></h2>
<p><span class="koboSpan" id="kobo.214.1">It is critical for low latency applications to use resources very efficiently. </span><span class="koboSpan" id="kobo.214.2">Embedded applications (which are also often used in real-time applications) are especially limited in time and memory </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.215.1">resources. </span><span class="koboSpan" id="kobo.215.2">In languages such as Java and Python that rely on automatic garbage collection, there is an element of non-determinism – that is, the garbage collector can introduce large latencies in performance unpredictably. </span><span class="koboSpan" id="kobo.215.3">Additionally, for systems that are very limited in memory, low-level languages such as C and C++ can do special things such as placing data at custom sections or addresses in memory through pointers. </span><span class="koboSpan" id="kobo.215.4">In languages such as C and C++, the programmer is in charge of explicit creation, management, and deallocation of memory resources, allowing for deterministic and efficient use </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">of resources.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.217.1">Speed and high performance</span></h2>
<p><span class="koboSpan" id="kobo.218.1">C++ is faster than most </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.219.1">other programming languages for the reasons we have already discussed. </span><span class="koboSpan" id="kobo.219.2">It also provides excellent concurrency and multithreading support. </span><span class="koboSpan" id="kobo.219.3">Obviously, this is another good feature when it comes to developing low latency applications that are latency-sensitive or even latency-critical. </span><span class="koboSpan" id="kobo.219.4">Such requirements are also often found in applications around servers that are under heavy load such as web servers, application servers, database servers, trading servers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Another advantage of C++ is due to its compile-time optimization ability. </span><span class="koboSpan" id="kobo.221.2">C and C++ support features such as macros or pre-processor directives, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">constexpr</span></strong><span class="koboSpan" id="kobo.223.1"> specifier, and template metaprogramming. </span><span class="koboSpan" id="kobo.223.2">These allow us to move a large part of the processing from runtime to compile time. </span><span class="koboSpan" id="kobo.223.3">Basically, this means we minimize the work done during runtime on the critical code path by moving a lot of the processing to the compilation step when building the machine code binary. </span><span class="koboSpan" id="kobo.223.4">We will discuss these features heavily in later chapters when we build a complete electronic trading system, and their benefits will become very clear at </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">that point.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.225.1">Language constructs and features</span></h2>
<p><span class="koboSpan" id="kobo.226.1">The C++ language itself is a perfect combination of flexibility and feature richness. </span><span class="koboSpan" id="kobo.226.2">It allows a lot of </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.227.1">freedom for the developers, who can leverage it to tune applications down to a very low level. </span><span class="koboSpan" id="kobo.227.2">However, it also provides a lot of higher-level abstractions, which can be used to build very large, feature-rich, versatile, and scalable applications, while still being extremely low latency when required. </span><span class="koboSpan" id="kobo.227.3">In this section, we will explore some of those C++-specific language features that put it in a unique position of low-level control and high-level </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">abstraction features.</span></span></p>
<h3><span class="koboSpan" id="kobo.229.1">Portability</span></h3>
<p><span class="koboSpan" id="kobo.230.1">First off, C++ is highly portable and can build applications that can be compiled for a lot of different </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.231.1">operating systems, platforms, CPU architecture, and so on. </span><span class="koboSpan" id="kobo.231.2">Since it does not require a runtime interpreter that differs for different platforms, all that is required to do is build the correct binaries at compile time, which is relatively straightforward, and the final deployed binary can just run on any platform. </span><span class="koboSpan" id="kobo.231.3">Additionally, some of the other features we have already discussed (such as the ability to run in low-memory and weaker CPU architectures </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.232.1">combined with the lack of garbage collection requirements) make it even more portable than some of the other </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">high-level languages.</span></span></p>
<h3><span class="koboSpan" id="kobo.234.1">Compiler optimizations</span></h3>
<p><span class="koboSpan" id="kobo.235.1">We have discussed that C++ is a compiled language, which makes it inherently faster than interpreted languages since it does not incur additional runtime costs. </span><span class="koboSpan" id="kobo.235.2">Since the developer’s complete </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.236.1">source code is compiled into the final executable binary, compilers have an opportunity to holistically analyze all the objects and code paths. </span><span class="koboSpan" id="kobo.236.2">This leads to the possibility of very high levels of optimization at compile times. </span><span class="koboSpan" id="kobo.236.3">Modern compilers work closely with modern hardware to produce some surprisingly optimized machine code. </span><span class="koboSpan" id="kobo.236.4">The point here is that developers can focus on solving business problems and, assuming the C++ developers are competent, the compiled program is still extremely optimized without requiring a lot of the developer’s time and effort. </span><span class="koboSpan" id="kobo.236.5">Since C++ allows you to directly inline assembly code as well, it gives the developers an even greater chance to work with the compiler and produce highly </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">optimized executables.</span></span></p>
<h3><span class="koboSpan" id="kobo.238.1">Statically typed</span></h3>
<p><span class="koboSpan" id="kobo.239.1">When it comes to type systems in programming languages, there are two options – </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">statically typed language</span></strong><span class="koboSpan" id="kobo.241.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">dynamically typed language</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">A statically typed language performs checks around data types (integers, floats, doubles, structures, and classes) and interactions </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.244.1">between these types during the compilation process. </span><span class="koboSpan" id="kobo.244.2">A dynamically typed language performs </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.245.1">these type checks at runtime. </span><span class="koboSpan" id="kobo.245.2">Examples of statically typed </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.246.1">languages are C++ and Java, and examples of dynamically typed languages are Python, Perl, </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">and JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">One big benefit of statically typed languages is that since all the type-checking is done at compile time, it gives </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.249.1">us the opportunity to find and eliminate many bugs before the program is even run. </span><span class="koboSpan" id="kobo.249.2">Obviously, type checking alone cannot find all possible bugs, but the point we’re trying to make here is that statically typed languages do a significantly better job at finding errors and bugs related to types at compile time. </span><span class="koboSpan" id="kobo.249.3">This is especially true for low latency applications that are highly numerical </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">in nature.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Another huge benefit of statically typed languages, especially when it comes to low latency applications, is that since the type-checking is done at compile time, there is an additional </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.252.1">opportunity for the compiler to optimize the types and type interactions at compile time. </span><span class="koboSpan" id="kobo.252.2">In fact, a </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.253.1">large part of the reason that compiled languages are much faster is due to the static versus dynamic type-checking system itself. </span><span class="koboSpan" id="kobo.253.2">This is also a big reason why, for a dynamically typed language such as Python, high-performance libraries such as NumPy require types when creating arrays </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">and matrices.</span></span></p>
<h3><span class="koboSpan" id="kobo.255.1">Multiple paradigms</span></h3>
<p><span class="koboSpan" id="kobo.256.1">Unlike some other languages, C++ does not force the developer to follow a specific programming paradigm. </span><span class="koboSpan" id="kobo.256.2">It supports a lot of different programming paradigms such as monolithic, procedural, </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.258.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.259.1">OOP</span></strong><span class="koboSpan" id="kobo.260.1">), generic programming, </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.261.1">and so on. </span><span class="koboSpan" id="kobo.261.2">This makes it a good fit for a wide range of applications because it gives the developer </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.262.1">the flexibility to design their program in a way that facilitates maximum optimization and lowest latencies instead of forcing a programming paradigm onto </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">that application.</span></span></p>
<h3><span class="koboSpan" id="kobo.264.1">Libraries</span></h3>
<p><span class="koboSpan" id="kobo.265.1">Out of the box, C++ already comes with a large C and C++ library, which provides a lot of data structures, algorithms, </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.266.1">and abstractions for tasks such as </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.268.1">Network programming</span></span></li>
<li><span class="koboSpan" id="kobo.269.1">Dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">memory management</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.271.1">Numeric operations</span></span></li>
<li><span class="koboSpan" id="kobo.272.1">Error and </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">exception handling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.274.1">String operations</span></span></li>
<li><span class="koboSpan" id="kobo.275.1">Commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">needed algorithms</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.277.1">Input/output</span></strong><span class="koboSpan" id="kobo.278.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.279.1">I/O</span></strong><span class="koboSpan" id="kobo.280.1">) operations including </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">file operations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.282.1">Multithreading support</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.283.1">Additionally, the huge community of C++ developers has built and open-sourced a lot of the libraries; we will discuss some of the most popular ones in the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">following subsections.</span></span></p>
<h4><span class="koboSpan" id="kobo.285.1">Standard Template Library</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.286.1">Standard Template Library</span></strong><span class="koboSpan" id="kobo.287.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.288.1">STL</span></strong><span class="koboSpan" id="kobo.289.1">) is a very popular and widely used templatized and header-only library </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.290.1">containing data structures and containers, iterators and allocators for these containers, and algorithms for tasks such as sorting, searching, algorithms for the containers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">so on.</span></span></p>
<h4><span class="koboSpan" id="kobo.292.1">Boost</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.293.1">Boost</span></strong><span class="koboSpan" id="kobo.294.1"> is a large C++ library </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.295.1">that provides support for multithreading, network </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.296.1">operations, image processing, </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">regular expressions</span></strong><span class="koboSpan" id="kobo.298.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">regex</span></strong><span class="koboSpan" id="kobo.300.1">), linear algebra, unit testing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">so on.</span></span></p>
<h4><span class="koboSpan" id="kobo.302.1">Asio</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.303.1">Asio</span></strong><span class="koboSpan" id="kobo.304.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.305.1">asynchronous input/output</span></strong><span class="koboSpan" id="kobo.306.1">) is another well-known and widely used library that comes in two </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.307.1">versions: </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">non-Boost</span></strong><span class="koboSpan" id="kobo.309.1"> and one that is part of the Boost library. </span><span class="koboSpan" id="kobo.309.2">It provides support for multithreading concurrency and for implementing and using the asynchronous I/O model and is portable to all </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">major platforms.</span></span></p>
<h4><span class="koboSpan" id="kobo.311.1">GNU Scientific Library</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.312.1">GNU Scientific Library</span></strong><span class="koboSpan" id="kobo.313.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.314.1">GSL</span></strong><span class="koboSpan" id="kobo.315.1">) provides support for a wide range of mathematical concepts and operations </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.316.1">such as complex numbers, matrices, and calculus, and manages </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">other functions.</span></span></p>
<h4><span class="koboSpan" id="kobo.318.1">Active Template Library</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.319.1">Active Template Library</span></strong><span class="koboSpan" id="kobo.320.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">ATL</span></strong><span class="koboSpan" id="kobo.322.1">) is a template-heavy C++ library to help program the </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Component Object Model</span></strong><span class="koboSpan" id="kobo.324.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.325.1">COM</span></strong><span class="koboSpan" id="kobo.326.1">). </span><span class="koboSpan" id="kobo.326.2">It replaces </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.327.1">the </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.328.1">previous </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Microsoft Foundation Classes</span></strong><span class="koboSpan" id="kobo.330.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">MFC</span></strong><span class="koboSpan" id="kobo.332.1">) library and improves upon it. </span><span class="koboSpan" id="kobo.332.2">It is developed by Microsoft and is open source and </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.333.1">heavily uses an important low latency C++ feature, the </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.335.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.336.1">CRTP</span></strong><span class="koboSpan" id="kobo.337.1">), which we will also explore and </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.338.1">use heavily in this book. </span><span class="koboSpan" id="kobo.338.2">It supports COM features </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.339.1">such as dual interfaces, ActiveX controls, connection points, tear-off interfaces, COM enumerator interfaces, and a </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">lot more.</span></span></p>
<h4><span class="koboSpan" id="kobo.341.1">Eigen</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.342.1">Eigen</span></strong><span class="koboSpan" id="kobo.343.1"> is a powerful C++ library for mathematical and scientific applications. </span><span class="koboSpan" id="kobo.343.2">It has functions for linear algebra, </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.344.1">numerical methods and solvers, numeric types such as complex numbers, features and operations for geometry, and </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">much more.</span></span></p>
<h4><span class="koboSpan" id="kobo.346.1">LAPACK</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.347.1">Linear Algebra Package</span></strong><span class="koboSpan" id="kobo.348.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.349.1">LAPACK</span></strong><span class="koboSpan" id="kobo.350.1">) is another large and extremely powerful C++ library </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.351.1">specifically for linear algebra and linear equations and to support routines for large matrices. </span><span class="koboSpan" id="kobo.351.2">It implements a lot of functionality such as </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.352.1">solving simultaneous linear equations, least squares methods, eigenvalues, </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">singular value decomposition</span></strong><span class="koboSpan" id="kobo.354.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.355.1">SVD</span></strong><span class="koboSpan" id="kobo.356.1">), and many </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">more applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.358.1">OpenCV</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.359.1">Open Source Computer Vision</span></strong><span class="koboSpan" id="kobo.360.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.361.1">OpenCV</span></strong><span class="koboSpan" id="kobo.362.1">) is one of the most well-known C++ libraries when it </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.363.1">comes to computer graphics and vision-related applications. </span><span class="koboSpan" id="kobo.363.2">It is also available for Java and Python and provides many algorithms for face and object recognition, 3D models, machine learning, deep learning, </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">and more.</span></span></p>
<h4><span class="koboSpan" id="kobo.365.1">mlpack</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.366.1">mlpack</span></strong><span class="koboSpan" id="kobo.367.1"> is a super-fast, header-only C++ library for a wide variety of machine learning models and the mathematical </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.368.1">operations related to them. </span><span class="koboSpan" id="kobo.368.2">It also has support for other languages such as Go, Julia, R, </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">and Python.</span></span></p>
<h4><span class="koboSpan" id="kobo.370.1">QT</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.371.1">QT</span></strong><span class="koboSpan" id="kobo.372.1"> is by far the most popular library when it comes to building cross-platform graphical programs in C++. </span><span class="koboSpan" id="kobo.372.2">It works </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.373.1">on Windows, Linux, macOS, and even platforms such as Android and embedded systems. </span><span class="koboSpan" id="kobo.373.2">It is open source and is used to build </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">GUI widgets.</span></span></p>
<h4><span class="koboSpan" id="kobo.375.1">Crypto++</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.376.1">Crypto++</span></strong><span class="koboSpan" id="kobo.377.1"> is a free open source C++ library to support algorithms, operations, and utilities for </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.378.1">cryptography. </span><span class="koboSpan" id="kobo.378.2">It has many cryptographic algorithms, random number generators, block ciphers, functions, public-key operations, secret sharing, and more across many platforms such as Linux, Windows, macOS, iOS, </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">and Android.</span></span></p>
<h3><span class="koboSpan" id="kobo.380.1">Suitable for big projects</span></h3>
<p><span class="koboSpan" id="kobo.381.1">In the previous section, we discussed the design and a lot of features of C++ that make it a great fit for low latency applications. </span><span class="koboSpan" id="kobo.381.2">Another aspect of C++ is that because of the flexibility it provides to </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.382.1">the developer and all the high-level abstractions it allows you to build, it is actually very well suited to very large real-world projects. </span><span class="koboSpan" id="kobo.382.2">Huge projects such as compilers, cloud processing and storage systems, and </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">OSes</span></strong><span class="koboSpan" id="kobo.384.1"> are built in C++ for these reasons. </span><span class="koboSpan" id="kobo.384.2">We </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.385.1">will dive into these and many other applications that try to strike a balance between low latency performance, feature richness, and different business cases, and quite often, C++ is the perfect fit for developing </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">such systems.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.387.1">Mature and large community support</span></h2>
<p><span class="koboSpan" id="kobo.388.1">The C programming language was originally created in 1972, and then C++ (originally referred to as C with classes) was created in 1983. </span><span class="koboSpan" id="kobo.388.2">C++ is a very mature language and is embedded extensively into many applications in many different business areas. </span><span class="koboSpan" id="kobo.388.3">Some examples are the </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.389.1">Unix operating system, Oracle MySQL, the Linux kernel, Microsoft Office, and Microsoft Visual Studio – these were all written in C++. </span><span class="koboSpan" id="kobo.389.2">The fact that C++ has been around for 40 years means that most software problems have been encountered and solutions have been designed and implemented. </span><span class="koboSpan" id="kobo.389.3">C++ is also very popular and taught as part of most computer science degrees and, additionally, has a huge library of developer tools, third-party components, open source projects, libraries, manuals, tutorials, books, and so on dedicated to it. </span><span class="koboSpan" id="kobo.389.4">The bottom line is that there is </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.390.1">a large amount of documentation, examples, and community support backing up new C++ developers and new </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">C++ projects.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.392.1">Language under active development</span></h2>
<p><span class="koboSpan" id="kobo.393.1">Even though C++ is 40 years old, it is still very much under active development. </span><span class="koboSpan" id="kobo.393.2">Ever since the first C++ version was commercially released in 1985, there have been multiple improvements </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.394.1">and enhancements to the C++ standard and the language. </span><span class="koboSpan" id="kobo.394.2">In chronological order, C++ 98, C++ 03, C++ 0X, C++ 11, C++ 14, C++ 17, and C++ 20 have been released, and C++ 23 is being developed. </span><span class="koboSpan" id="kobo.394.3">Each version comes with improvements and new features. </span><span class="koboSpan" id="kobo.394.4">So, C++ is a powerful language and is constantly evolving with time and adding modern features. </span><span class="koboSpan" id="kobo.394.5">Here is a diagram showing the evolution of </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.395.1">C++ over </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the years:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.397.1"><img alt="Figure 1.2 – Evolution of C++ " src="image/Figure_1.2_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.398.1">Figure 1.2 – Evolution of C++</span></p>
<p><span class="koboSpan" id="kobo.399.1">Given the already mature state of the C++ programming language, super-fast speed, perfect combination </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.400.1">of high-level abstractions and low-level hardware access and control, huge knowledge base, and developer community along with best practices, libraries, and tools, C++ is a clear pick for low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">In this section, we looked at the choice of the C++ programming language for low latency application development. </span><span class="koboSpan" id="kobo.402.2">We discussed the various characteristics, features, libraries, and community support that make it a great fit for these applications. </span><span class="koboSpan" id="kobo.402.3">It is no surprise that C++ is deeply embedded into most applications that have strict performance requirements. </span><span class="koboSpan" id="kobo.402.4">In the next section, we will look at a lot of different low latency applications in different </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.403.1">business areas with the goal of understanding the similarities that such </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">applications share.</span></span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.405.1">Introducing some important low latency applications</span></h1>
<p><span class="koboSpan" id="kobo.406.1">In this section, we will explore some common low latency applications in different business areas in order </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.407.1">to familiarize ourselves with different kinds of latency-sensitive applications and how latency plays an important part in their performance. </span><span class="koboSpan" id="kobo.407.2">Additionally, discussing these applications will reveal some similarities in the nature and design of </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">these applications.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.409.1">Lower-level low latency applications</span></h2>
<p><span class="koboSpan" id="kobo.410.1">First, we will start with applications that would be considered extremely low-level, meaning very close </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.411.1">to the hardware. </span><span class="koboSpan" id="kobo.411.2">Note that all low latency applications have at least some portion of the application that is low-level since, by definition, that is how low latency performance is achieved. </span><span class="koboSpan" id="kobo.411.3">These applications, however, have large portions of the entire application dealing with mostly low-level details; let us discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">those next.</span></span></p>
<h3><span class="koboSpan" id="kobo.413.1">Telecommunications</span></h3>
<p><span class="koboSpan" id="kobo.414.1">We already discussed that C++ is one of the fastest programming languages out there. </span><span class="koboSpan" id="kobo.414.2">It is used a lot in </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.415.1">building telephone switches, routers, internet, space probes, and various other parts of telecommunications infrastructure. </span><span class="koboSpan" id="kobo.415.2">These applications are required to handle a large number of simultaneous connections and facilitate communication between them. </span><span class="koboSpan" id="kobo.415.3">These applications need to perform these tasks with speed and efficiency, making them a good example of low </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">latency applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.417.1">Embedded systems</span></h3>
<p><span class="koboSpan" id="kobo.418.1">Since C++ is closer to the hardware compared to other high-level programming languages, it is used </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.419.1">in latency-sensitive embedded systems. </span><span class="koboSpan" id="kobo.419.2">Some examples of these would be machines used in the field of medicine, surgical tools, smart watches, and so on. </span><span class="koboSpan" id="kobo.419.3">C++ is usually the language of choice for medical applications such as MRI machines, lab testing systems, and systems to manage patient information. </span><span class="koboSpan" id="kobo.419.4">Additionally, there are use cases to model medical data, run simulations for research, and </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">so on.</span></span></p>
<h3><span class="koboSpan" id="kobo.421.1">Compilers</span></h3>
<p><span class="koboSpan" id="kobo.422.1">Interestingly, compilers for various programming languages use C and C++ to build the compilers for those </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.423.1">languages. </span><span class="koboSpan" id="kobo.423.2">The reason for this is, again, that C and C++ are low-level languages closer to the hardware and can build these compilers efficiently. </span><span class="koboSpan" id="kobo.423.3">The compiler applications themselves are able to optimize the code for the programming language to a very large degree and produce low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">machine code.</span></span></p>
<h3><span class="koboSpan" id="kobo.425.1">Operating systems</span></h3>
<p><span class="koboSpan" id="kobo.426.1">From Microsoft Windows to macOS to Linux itself, all the major OSes are built in C++ – yet again, another example of a low latency application where the fact that C++ is a low-level language makes it an </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.427.1">ideal fit. </span><span class="koboSpan" id="kobo.427.2">OSes are extremely large and extremely complex. </span><span class="koboSpan" id="kobo.427.3">In addition to that, they have to have low latency and be highly performant to be a competitive </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">modern OS.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">For instance, Linux is typically the OS of choice for many high-load servers as well as servers designed for low latency applications, so the OS itself needs to have very high performance. </span><span class="koboSpan" id="kobo.429.2">In addition to traditional OSes, C and C++ are also heavily used to build mobile OSes such as iOS, Android, and Windows phone kernels. </span><span class="koboSpan" id="kobo.429.3">In summary, OSes need to be extremely fast and efficient at managing all the system and hardware resources. </span><span class="koboSpan" id="kobo.429.4">C++ developers building OSes can leverage the language’s abilities to build </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">super-low-latency OSes.</span></span></p>
<h3><span class="koboSpan" id="kobo.431.1">Cloud/distributed systems</span></h3>
<p><span class="koboSpan" id="kobo.432.1">Organizations that develop and use cloud and distributed storage and processing systems have </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.433.1">very low latency requirements. </span><span class="koboSpan" id="kobo.433.2">For this reason, they rely heavily on a programming language such as C++. </span><span class="koboSpan" id="kobo.433.3">Distributed storage systems have to support very fast and very efficient filesystem operations, so need to be close to the hardware. </span><span class="koboSpan" id="kobo.433.4">Additionally, distributed processing generally means high levels of concurrency, reliance on low latency multithreading libraries, as well as high load tolerance and scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">optimization requirements.</span></span></p>
<h3><span class="koboSpan" id="kobo.435.1">Databases</span></h3>
<p><span class="koboSpan" id="kobo.436.1">Databases are another good example of applications that need low latencies and high levels of concurrency </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.437.1">and parallelism. </span><span class="koboSpan" id="kobo.437.2">Databases are also critical components in many different applications in many different business areas. </span><span class="koboSpan" id="kobo.437.3">Postgres, MySQL, and MongoDB (which are by far the most popular database systems right now) are written in C and C++ – yet another example of why C++ is the preferred language for low latency applications. </span><span class="koboSpan" id="kobo.437.4">C++ is also ideal for designing and structuring databases to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">storage efficiency.</span></span></p>
<h3><span class="koboSpan" id="kobo.439.1">Flight software and traffic control</span></h3>
<p><span class="koboSpan" id="kobo.440.1">Flight software for commercial airplanes and military aircraft is a class of latency-critical applications. </span><span class="koboSpan" id="kobo.440.2">Here, not </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.441.1">only is it important that the </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.442.1">code follow very strict guidelines, be extremely robust, and be very well tested but the applications also need to respond and react to events predictably and within strict </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">latency thresholds.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">Traffic control software depends on many sensors, which need to monitor the speed, location, and volume </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.445.1">of vehicles and </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.446.1">transmit them to the central software. </span><span class="koboSpan" id="kobo.446.2">The software then uses the information to control traffic signs, maps, and traffic lights. </span><span class="koboSpan" id="kobo.446.3">Obviously, for such real-time applications, there is a requirement for it to be low latency and easily able to handle the large volume of data quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">and efficiently.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.448.1">Higher-level low latency applications</span></h2>
<p><span class="koboSpan" id="kobo.449.1">In this subsection, we will discuss what many might consider slightly higher-level low latency applications. </span><span class="koboSpan" id="kobo.449.2">These </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.450.1">are the applications people typically think of when trying to solve business problems; however, one thing to keep in mind is that these applications still have to implement and use lower-level optimization techniques to provide the performance that is required </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">of them.</span></span></p>
<h3><span class="koboSpan" id="kobo.452.1">Graphics and video game applications</span></h3>
<p><span class="koboSpan" id="kobo.453.1">Graphics applications </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.454.1">require super-fast </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.455.1">rendering performance and serve as another example of a </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.456.1">low latency application. </span><span class="koboSpan" id="kobo.456.2">Graphics software employs techniques from computer vision, image processing, and so on, which typically involves a lot of very fast and very efficient matrix operations on numerous large matrices. </span><span class="koboSpan" id="kobo.456.3">When it comes to graphics rendering in video games, there are even more stringent requirements for low latency performance since these are interactive applications, and speed and responsiveness are critical to the user experience. </span><span class="koboSpan" id="kobo.456.4">Nowadays, video games are typically made available on multiple platforms to reach a larger </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.457.1">target audience. </span><span class="koboSpan" id="kobo.457.2">What this means is that these applications, or slightly stripped-down versions of these </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.458.1">applications, need to run on low-end devices, which might not have a lot </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.459.1">of computation and </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.460.1">memory resources available. </span><span class="koboSpan" id="kobo.460.2">Video games overall have a lot of resource-intensive operations – rendering graphics, handling multiple players simultaneously, fast responsiveness to user inputs, and so on. </span><span class="koboSpan" id="kobo.460.3">C++ is a very good fit for all these applications and has been used to create a lot of well-known games such as Counter-Strike, Starcraft, and Warcraft, and game engines such as Unreal Engine. </span><span class="koboSpan" id="kobo.460.4">C++ is also a good fit for different gaming platforms – Windows PCs, Nintendo Switch, Xbox, </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">and PlayStation.</span></span></p>
<h3><span class="koboSpan" id="kobo.462.1">Augmented reality and virtual reality applications</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.463.1">Augmented reality</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">AR</span></strong><span class="koboSpan" id="kobo.466.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">virtual reality</span></strong><span class="koboSpan" id="kobo.468.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.469.1">VR</span></strong><span class="koboSpan" id="kobo.470.1">) are both technologies that augment and enhance </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.471.1">a real-life environment or create a whole new virtual environment. </span><span class="koboSpan" id="kobo.471.2">While AR just augments the </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.472.1">environment </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.473.1">by adding digital elements to our live view, VR creates a </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.474.1">completely new simulated environment. </span><span class="koboSpan" id="kobo.474.2">So, these applications take graphics rendering and video game applications to a whole </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">new level.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">AR and VR technology has found a lot of different business use cases, such as design and construction, maintenance and repairs, training and education, healthcare, retail and marketing, and even in the field of technology itself. </span><span class="koboSpan" id="kobo.476.2">AR and VR applications have similar requirements as video game applications and need to handle large amounts of data from various sources in real </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.477.1">time, as well as handle user interactions </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.478.1">seamlessly and smoothly. </span><span class="koboSpan" id="kobo.478.2">The technical challenges for these applications are handling limited processing capability and available memory, possibly limited mobile bandwidth, and maintaining low latency and real-time performance to not hurt the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">user experience.</span></span></p>
<h3><span class="koboSpan" id="kobo.480.1">Browsers</span></h3>
<p><span class="koboSpan" id="kobo.481.1">Web browsers are often more complicated than they might appear. </span><span class="koboSpan" id="kobo.481.2">There are rendering engines in a web browser </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.482.1">that require </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.483.1">low latencies and efficient processing. </span><span class="koboSpan" id="kobo.483.2">Additionally, there are often interactions with databases and interactive rendering code so that users do not have to wait a long time for the content to update or for interactive content to respond. </span><span class="koboSpan" id="kobo.483.3">Due to the low latency requirements of web browsers, it is no surprise that C++ is often the preferred language for this application as well. </span><span class="koboSpan" id="kobo.483.4">In fact, some of the most popular web browsers (Google Chrome, Mozilla Firefox, Safari, Opera, etc.) heavily </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">employ C++.</span></span></p>
<h3><span class="koboSpan" id="kobo.485.1">Search engines</span></h3>
<p><span class="koboSpan" id="kobo.486.1">Search engines are another use case that requires low latency and highly efficient data structures, algorithms, </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.487.1">and code bases. </span><span class="koboSpan" id="kobo.487.2">Modern </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.488.1">search engines such as Google use techniques such as internet crawling technology, indexing infrastructures, page rank algorithms, and other complex algorithms including machine learning. </span><span class="koboSpan" id="kobo.488.2">Google’s search engine relies on C++ to implement all these requirements in a highly low latency and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">efficient fashion.</span></span></p>
<h3><span class="koboSpan" id="kobo.490.1">Libraries</span></h3>
<p><span class="koboSpan" id="kobo.491.1">Many high-level libraries often have stringent performance requirements and can be regarded as low latency applications themselves but usually, they are key components in larger low latency </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.492.1">applications and businesses. </span><span class="koboSpan" id="kobo.492.2">These </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.493.1">libraries cover different areas – network programming, data structures, faster algorithms, databases, multithreading, mathematical libraries (for example, machine learning), and many more. </span><span class="koboSpan" id="kobo.493.2">Such libraries require very low latency and high-performance processing such as computations that involve many matrix operations on a large number of matrices, a lot of which can also be very large </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">in size.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">It should be clear here that performance is critical in such applications – another area where C++ is often used quite heavily. </span><span class="koboSpan" id="kobo.495.2">Even though a lot of these libraries such as TensorFlow are available </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.496.1">in Python, under the hood, the core machine learning </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.497.1">mathematical operations are actually implemented in C++ to power these machine learning methods on </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">huge datasets.</span></span></p>
<h3><span class="koboSpan" id="kobo.499.1">Banking and financial applications</span></h3>
<p><span class="koboSpan" id="kobo.500.1">Banking applications are another class of low latency applications that need to process millions of transactions </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.501.1">every day and require low latency, high concurrency, and robustness. </span><span class="koboSpan" id="kobo.501.2">Large banks have millions of clients </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.502.1">and hundreds of millions </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.503.1">of transactions that all need to be executed correctly </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.504.1">and quickly and be able to scale up to handle the client load and thus database and server loads. </span><span class="koboSpan" id="kobo.504.2">C++ is automatically the choice here for a lot of these banking applications for the reasons we have </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">discussed before.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">When it comes to applications such as financial modeling, electronic trading systems, and trading strategies, low latency is more critical than in any other field. </span><span class="koboSpan" id="kobo.506.2">The speed and deterministic performance of C++ make it ideal for processing billions of market updates. </span><span class="koboSpan" id="kobo.506.3">sending millions of orders, and transacting at the exchange, especially when it comes to HFT. </span><span class="koboSpan" id="kobo.506.4">Since markets update very quickly, trading applications need the right data very quickly to execute trades extremely quickly. </span><span class="koboSpan" id="kobo.506.5">Large latencies in this system can cause losses that destroy a significant amount of trading profits, or worse. </span><span class="koboSpan" id="kobo.506.6">On the research and development side of things, simulations over many trading instruments across multiple exchanges also need large-scale low latency distributed processing to be done quickly and efficiently. </span><span class="koboSpan" id="kobo.506.7">The quantitative development and research and risk analysis libraries are also written in C++ because they need to process massive amounts of data as quickly as possible. </span><span class="koboSpan" id="kobo.506.8">One of the best examples of this would be the pricing and risk libraries that calculate fair trading prices for options products and run many simulations to assess options risk, as the search space </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">is enormous.</span></span></p>
<h3><span class="koboSpan" id="kobo.508.1">Mobile phone applications</span></h3>
<p><span class="koboSpan" id="kobo.509.1">Modern mobile phone applications are quite feature-rich. </span><span class="koboSpan" id="kobo.509.2">Additionally, they have to run on platforms </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.510.1">with very limited hardware resources. </span><span class="koboSpan" id="kobo.510.2">This makes it even more important that the implementation </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.511.1">of these applications be very low latency and highly efficient in how they use the limited resources they have. </span><span class="koboSpan" id="kobo.511.2">However, these applications </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.512.1">still need to be extremely quick to respond to user interactions, possibly handle backend connectivity, and render high-quality graphics on mobile devices. </span><span class="koboSpan" id="kobo.512.2">Mobile platforms such as Android and the Windows OS, browsers such as Google Chrome and Firefox, and apps such as YouTube have a lot of </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">C++ involvement.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.514.1">Internet of Things and machine-to-machine applications</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.515.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.516.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.517.1">IoT</span></strong><span class="koboSpan" id="kobo.518.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">machine-to-machine</span></strong><span class="koboSpan" id="kobo.520.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.521.1">M2M</span></strong><span class="koboSpan" id="kobo.522.1">) applications are based on connecting devices </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.523.1">to collect, store and exchange data with each other automatically. </span><span class="koboSpan" id="kobo.523.2">Overall, while IoT and M2M are similar in nature, there are some differences around aspects such as networks, scalability, interoperability, and </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">human interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">IoT is a broad term that refers to connecting different physical devices together. </span><span class="koboSpan" id="kobo.525.2">IoT devices are generally </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.526.1">actuators and sensors that are embedded inside other larger devices such as smart thermostats, refrigerators, doorbells, cars, smart watches, TVs, and medical devices. </span><span class="koboSpan" id="kobo.526.2">These devices operate on platforms with limited computing resources, power requirements, and minimal available </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">memory resources.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">M2M is a communication method where multiple machines interact with each other using wired or </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.529.1">wireless connections without any human oversight or interaction. </span><span class="koboSpan" id="kobo.529.2">The point here is that internet </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.530.1">connectivity is not necessary for M2M. </span><span class="koboSpan" id="kobo.530.2">So IoT is a subset of M2M, but M2M is a broader universe of M2M communication-based systems. </span><span class="koboSpan" id="kobo.530.3">M2M technology is used in different applications such as security, tracking and tracing, automation, manufacturing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">facility management.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">We have already discussed these applications before, but to summarize again here, IoT and M2M technology are used in applications such as telecommunications, medical and healthcare, pharmaceuticals, automotive and aerospace industries, retail and logistics and supply chain management, manufacturing, and military satellite data </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">analysis systems.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">This section was all about different business areas and use cases where low latency applications thrive and, in some cases, are a necessity for the business. </span><span class="koboSpan" id="kobo.534.2">Our hope is that you understand that low latency applications are used in many different areas, even though it might not be immediately obvious. </span><span class="koboSpan" id="kobo.534.3">The other objective here was to establish similarities that these applications share, even though they are designed to solve different </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">business problems.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.536.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.537.1">In this chapter, we provided an introduction to low latency applications. </span><span class="koboSpan" id="kobo.537.2">First, we defined latency-sensitive and latency-critical applications and different measures of latency. </span><span class="koboSpan" id="kobo.537.3">We then discussed different metrics that are important in low latency applications and other considerations that define the requirements of low </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">latency applications.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">We spent a section of this chapter understanding why C++ is most frequently chosen for low latency applications across different businesses. </span><span class="koboSpan" id="kobo.539.2">Specifically, we discussed the features of the language itself and also the flexibility and low-level nature of the language, which makes C++ a perfect fit when it comes to low </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">latency applications.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">Finally, we looked at many different examples of low latency applications across different businesses and the similarities they share. </span><span class="koboSpan" id="kobo.541.2">The point of that discussion is that even though the business cases are different, these applications share a lot of common requirements and features. </span><span class="koboSpan" id="kobo.541.3">Again, here, C++ is a good fit for most (if not all) of these low latency applications in different </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">business areas.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">In the next chapter, we will discuss some of the most popular low latency applications in much greater detail. </span><span class="koboSpan" id="kobo.543.2">In this book, we will be using low latency electronic trading as a case study to understand and apply C++ low latency techniques. </span><span class="koboSpan" id="kobo.543.3">However, before we do that, we will explore other low latency applications such as real-time video streaming, real-time offline and online video gaming applications, and IoT applications </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">as well.</span></span></p>
</div>
</body></html>