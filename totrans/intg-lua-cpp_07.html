<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-155"><a id="_idTextAnchor157"/>7</h1>
<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Working with C++ Types</h1>
<p>In the previous chapter, we learned how to call C++ code from Lua and how to register C++ modules. You might have observed that you can create objects in C++ and register them to Lua, but how about creating C++ objects freely in Lua? This is what we will set out to achieve in this chapter.</p>
<p>We will learn about the following topics and export C++ types to Lua in a top-down approach:</p>
<ul>
<li>How to use the Lua registry</li>
<li>How to use userdata</li>
<li>Exporting C++ type to Lua</li>
</ul>
<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Technical requirements</h1>
<p>Here are the technical requirements for this chapter:</p>
<ul>
<li>You can access the source code for this chapter at <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07</a>.</li>
<li>The previous chapter showed you how to register C++ modules; you must have finished coding the questions. You can check out the answers in the <code>begin</code> folder, which can be found in this book’s GitHub repository.</li>
<li>In this chapter, due to its complexity, we are adopting a top-down approach so that you only get a working implementation toward the end of this chapter. You can always check the <code>end</code> folder in this book’s GitHub repository if you prefer to see the complete code from the beginning.</li>
</ul>
<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>How to use the Lua registry</h1>
<p>The <strong class="bold">Lua registry</strong> is a <a id="_idIndexMarker322"/>global table that can be accessed by all C/C++ code. It is one of the places that C++ code can keep state across different function calls. You cannot access this table in Lua code unless you use the Lua <em class="italic">debug</em> library. However, you should not use the debug library in production code; so, the registry is for C/C++ code only.</p>
<p class="callout-heading">The registry versus upvalues</p>
<p class="callout">In the previous chapter, we learned about Lua <em class="italic">upvalues</em>. An <em class="italic">upvalue</em> keeps a state for a specific Lua C function across calls. The <em class="italic">registry</em>, on the other hand, can be accessed by all Lua C functions.</p>
<p>To export C++ types to Lua, we will use Lua userdata to represent the type and the registry so that we have a metatable for functions for the type. We will learn about the registry first, then the userdata, and finally put everything together to export C++ types to Lua.</p>
<p>Let’s add support for the registry in our Lua executor so that we know how to use it.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Supporting the registry</h2>
<p>Since <a id="_idIndexMarker323"/>the registry is a table, we must get a value with a key and set a value with a key. We can use <code>LuaValue</code> to represent different types of Lua values.</p>
<p>In <code>LuaExecutor.h</code>, add the following function declarations:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue getRegistry(const LuaValue &amp;key);
    void setRegistry(const LuaValue &amp;key,
                     const LuaValue &amp;value);
};</pre>
<p><code>getRegistry</code> will return the value from the registry for <code>key</code>. <code>setRegistry</code> will set <code>value</code> with <code>key</code> to the registry.</p>
<p>Now, let’s implement them and learn which Lua library functions can be used. In <code>LuaExecutor.cc</code>, implement <code>getRegistry</code>, as follows:</p>
<pre class="source-code">
LuaValue LuaExecutor::getRegistry(const LuaValue &amp;key)
{
    pushValue(key);
    lua_gettable(L, LUA_REGISTRYINDEX);
    return popValue();
}</pre>
<p>This looks<a id="_idIndexMarker324"/> simple, right? It reuses two pieces of knowledge we have come across from the previous chapters:</p>
<ul>
<li>We use <code>lua_gettable</code> to get a value from a table, where the top of the stack is the key and the table is located in the position in the stack specified by the function parameter. We learned about this in <em class="italic">Chapter 5</em>.</li>
<li>Similar to upvalues, the registry is a special use case regarding the Lua stack, so it also has a pseudo-index called <code>LUA_REGISTRYINDEX</code>. We first encountered this pseudo-index in <em class="italic">Chapter 6</em>.</li>
<li>By combining these two points, we get an even simpler implementation compared to getting a value for a normal table. This is because we do not need to push the table onto the stack.</li>
</ul>
<p>Next, we will implement <code>setRegistry</code>. In <code>LuaExecutor.cc</code>, add the following code:</p>
<pre class="source-code">
void LuaExecutor::setRegistry(const LuaValue &amp;key,
                              const LuaValue &amp;value)
{
    pushValue(key);
    pushValue(value);
    lua_settable(L, LUA_REGISTRYINDEX);
}</pre>
<p>This only <a id="_idIndexMarker325"/>needs to call one Lua library function: <code>lua_settable</code>. <code>value</code> is located on top of the stack and <code>key</code> is located second to the top. This simplicity is due to the great design of the Lua API regarding the pseudo-index.</p>
<p>With our Lua executor extended, let’s test it to see how the registry works.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor162"/>Testing the registry</h2>
<p>In <code>main.cpp</code>, replace<a id="_idIndexMarker326"/> the test code, as follows:</p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto key = LuaString::make("darabumba");
    lua-&gt;setRegistry(key,
        LuaString::make("gwentuklutar"));
    auto v1 = lua-&gt;getRegistry(key);
    lua-&gt;setRegistry(key, LuaString::make("wanghaoran"));
    auto v2 = lua-&gt;getRegistry(key);
    std::cout &lt;&lt; getLuaValueString(key)
              &lt;&lt; " -&gt; " &lt;&lt; getLuaValueString(v1)
              &lt;&lt; " -&gt; " &lt;&lt; getLuaValueString(v2);
    return 0;
}</pre>
<p>The test code is doing the following, separated by newlines:</p>
<ul>
<li>Creates <code>LuaExecutor</code> and a listener, as usual</li>
<li>Sets the registry with a key-value pair using some strings</li>
<li>Sets the key to another value</li>
<li>Prints out the key, the initial value, and the current value</li>
</ul>
<p>If you have <a id="_idIndexMarker327"/>done everything correctly, you should see the following output:</p>
<pre class="source-code">
darabumba -&gt; gwentuklutar -&gt; wanghaoran</pre>
<p>In the previous chapter, we used an upvalue to store a light userdata. Now, let’s test light userdata with the registry. Replace the registry operations with the following:</p>
<pre class="source-code">
auto regkey = LuaLightUserData::make(listener.get());
lua-&gt;setRegistry(regkey, LuaString::make(
    "a LuaExecutorListener implementation"));
auto regValue = lua-&gt;getRegistry(regkey);
std::cout &lt;&lt; std::hex &lt;&lt; listener.get() &lt;&lt; " is "
          &lt;&lt; getLuaValueString(regValue);</pre>
<p>Here, we used light userdata as the key and a string as a value explaining what the key is. You should see an output similar to the following:</p>
<pre class="source-code">
0x14f7040d0 is a LuaExecutorListener implementation</pre>
<p>Your key address will differ in each run.</p>
<p>Now that we’ve covered the registry and reviewed light userdata, let’s learn about Lua userdata.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor163"/>How to use userdata</h1>
<p>From this <a id="_idIndexMarker328"/>section onwards, we will transform the <code>Destinations</code> class from the previous chapter and register it to Lua as a type so that Lua code can create objects from it. Before we dive into the details, let’s make some high-level changes to show what we want at the project level.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor164"/>Preparing the C++ type</h2>
<p>In the previous <a id="_idIndexMarker329"/>chapter, we passed a name to the constructor for the <code>Destinations</code> class because we created its instances in C++ and needed to set a name to Lua for each instance.</p>
<p>In this<a id="_idIndexMarker330"/> chapter, we will export the C++ type to Lua. Lua will create the object and assign it a name. All changes will be in the <code>Destinations</code> class. The mechanism we implemented in the Lua executor to register C++ modules is flexible enough to support the registration of C++ types as well.</p>
<p>To reflect this change and difference, we will change the constructor and how the module name is provided. In <code>Destinations.h</code>, change the constructor, as follows:</p>
<pre class="source-code">
class Destinations : public LuaModule
{
public:
    Destinations();
};</pre>
<p>Then, delete the following private member variable:</p>
<pre class="source-code">
class Destinations : public LuaModule
private:
    std::string name;
};</pre>
<p>We will register a type instead of an instance. We can use a static variable for the Lua table name. You can change the constructor in <code>Destinations.cc</code> accordingly:</p>
<pre class="source-code">
Destinations::Destinations() : wishlist({}) {}</pre>
<p>Now, let’s reimplement how to provide the Lua type/table name. In <code>Destinations.cc</code>, change <code>luaName</code> so that it uses a static variable:</p>
<pre class="source-code">
namespace
{
    const std::string NAME("Destinations");
}
const std::string &amp;Destinations::luaName() const
{
    return NAME;
}</pre>
<p>Add a <a id="_idIndexMarker331"/>string<a id="_idIndexMarker332"/> constant called <code>NAME</code> with a value of <code>Destinations</code> at the beginning of the anonymous namespace and return it in <code>luaName</code>.</p>
<p>Finally, change the test code in <code>main.cpp</code>, as follows:</p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto wishlist = std::make_unique&lt;Destinations&gt;<strong class="bold">()</strong>;
    lua-&gt;registerModule(*wishlist.get());
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>Compared to the code at the end of <em class="italic">Chapter 6</em>, the only change here is that we removed the parameter to the constructor for the <code>Destinations</code> class.</p>
<p>This is what we want on the C++ side. Make sure it compiles. From now on, we will focus on re-wrapping <a id="_idIndexMarker333"/>the <code>Destinations</code> class and making <code>script.lua</code> create <a id="_idIndexMarker334"/>objects from it.</p>
<p>Next, let’s learn about userdata.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>What is userdata?</h2>
<p>In the previous<a id="_idIndexMarker335"/> chapter, we exported an instance of the class as a table and the class member functions as table functions. To export a type directly, we will create a userdata instead of a table.</p>
<p>In <em class="italic">Chapter 2</em>, we learned that userdata is one of the basic types in Lua, but we did not dive into the details. In the previous chapter, we used lightuserdata. Is there any difference between userdata and lightuserdata?</p>
<p>A userdata is an arbitrary sequence of data that’s created from C/C++ code by calling the Lua library and Lua treats it transparently. On the other hand, lightuserdata must be a C/C++ pointer.</p>
<p>What makes userdata more suitable to represent new types, is that, like a table, you can set metamethods and metatables to it. This is how you provide type functions and make it a useful type in Lua.</p>
<p class="callout-heading">Object-oriented programming in Lua</p>
<p class="callout">In <em class="italic">Chapter 5</em>, we learned about object-oriented programming in Lua and the <code>__index</code> metatable. If this sounds unfamiliar, please revisit that chapter before continuing.</p>
<p>Now, let’s look at what we should put into the userdata so that we can export C++ types.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>Designing the userdata</h2>
<p>To create<a id="_idIndexMarker336"/> userdata, Lua provides the following function:</p>
<pre class="source-code">
void *lua_newuserdatauv (
    lua_State *L, size_t size, int nuvalue);</pre>
<p>This function allocates a consecutive memory block with a length of <code>size</code> bytes as a userdata and pushes a reference to the userdata onto the stack. You can also attach user values to the userdata. The count of user values is passed in <code>nuvalue</code>. We will not use user values, so we will pass <code>0</code>. <code>lua_newuserdatauv</code> returns the address of the raw memory that’s been allocated.</p>
<p>Since<a id="_idIndexMarker337"/> Lua is written in C, you can use <code>lua_newuserdatauv</code> to allocate a C array or structure. Lua will even take care of deallocating it during garbage collection.</p>
<p>With C++, we want the userdata to represent a class. It is not portable or convenient to call this Lua library function to allocate a C++ class. So, we will take matters into our own hands – we will create the C++ object on our own and make the userdata a pointer to the object.</p>
<p class="callout-heading">Decoupling</p>
<p class="callout">Although we are integrating Lua into C++, we have chosen to decouple the C++ side and the Lua side as much as possible and only expose the necessary interfaces. C++ memory management is a complex topic already. We have chosen to let C++ manage the C++ object creation and only use Lua userdata to keep a pointer and as a garbage collection signal.</p>
<p>Let’s start by writing a Lua C function for object creation. In <code>Destinations.cc</code>, at the end of the anonymous namespace, add a function called <code>luaNew</code>. Add it to the <code>REGS</code> vector as well:</p>
<pre class="source-code">
int luaNew(lua_State *L);
const std::vector&lt;luaL_Reg&gt; REGS = {
    {"new", luaNew},
    ...
    {NULL, NULL}};
int luaNew(lua_State *L)
{
    Destinations *obj = new Destinations();
    Destinations **userdata =
        reinterpret_cast&lt;Destinations **&gt;(
            lua_newuserdatauv(L, sizeof(obj), 0));
    *userdata = obj;
    return 1;
}</pre>
<p><code>luaNew</code> will be <a id="_idIndexMarker338"/>responsible for creating <code>Destinations</code> instances. This is a three-step process:</p>
<p>First, we create an instance of the class in the heap with <code>new</code> and store its pointer in <code>obj</code>.</p>
<p>Then, we call <code>lua_newuserdatauv</code> to create a userdata to hold the pointer in <code>obj</code>. <code>userdata</code> will have a size of <code>sizeof(obj)</code>, which is the size of a C++ object pointer. Because <code>lua_newuserdatauv</code> returns the pointer to the raw memory and we have made this memory hold a pointer to the <code>Destinations</code> instance, we need to save the address of the allocated memory as a pointer to a pointer.</p>
<p>Finally, we make <code>*userdata</code> point to <code>obj</code>. Since <code>userdata</code> is already on top of the stack, we can return <code>1</code> to return the allocated userdata to Lua.</p>
<p>When Lua code creates a <code>Destinations</code> instance via <code>luaNew</code>, the Lua side will get a userdata.</p>
<p class="callout-heading">A pointer to a pointer</p>
<p class="callout">C++ allows you to create a pointer to a pointer. In such a case, one pointer holds the address of the other pointer. This is not frequently used in pure C++ code but can be useful for interacting with C APIs. The Lua library is a C library.</p>
<p>Next, let’s <a id="_idIndexMarker339"/>prepare <code>script.lua</code> so that it can use the C++ type.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>Preparing the Lua script</h2>
<p>Replace the <a id="_idIndexMarker340"/>content of <code>script.lua</code>, as follows:</p>
<pre class="source-code">
dst = Destinations.new()
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())
dst = Destinations.new()
dst:wish("Beijing")
dst:went("Berlin")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())</pre>
<p>This first part of the script is similar to the script we used for the previous chapter, except that we changed to <code>Destinations.new()</code> with the new table name and we switched to use the object calling convention with colons. The second part of the script is a repetition of the first part with different city names. This is to demonstrate that we can create many <code>Destinations</code> instances in Lua.</p>
<p>If you run the project at this point, you will see the following error:</p>
<pre class="source-code">
[LuaExecutor] Failed to execute: script.lua:2: attempt to index a userdata value (global 'dst')</pre>
<p>For now, this is expected. Because we returned a userdata instead of a table to Lua, so far, it is just a raw piece of memory that’s transparent to Lua. Lua does not know how to call a method on a piece of raw memory. As explained earlier, we need to set a metatable to the userdata for this to work. We will do this next to put everything together.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Exporting C++ types to Lua</h1>
<p>In the<a id="_idIndexMarker341"/> previous section, we returned the pointer to the class instance to Lua as a userdata. In this section, we will export member functions for the userdata. To do this, we need to set the metatable for the userdata.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Setting a metatable for the userdata</h2>
<p>In <em class="italic">Chapter 5</em>, we<a id="_idIndexMarker342"/> learned that each table can have a metatable. Similarly, each userdata can also have a metatable. In <em class="italic">Chapter 2</em>, we learned that in Lua code, the metatable needs to be set during object creation.</p>
<p>Here, we need to set the metatable during object creation in C++ code. Instead of creating a new metatable for each object, we can create a single metatable and store it in the registry. Then, each object only needs to reference this single metatable. This will increase efficiency and reduce memory footprint. The Lua library even provides helper functions for this.</p>
<p>First, let’s see the code; an explanation will follow. Replace the content for <code>luaNew</code>, as follows:</p>
<pre class="source-code">
const std::string METATABLE_NAME(
    "Destinations.Metatable");
int luaNew(lua_State *L)
{
    Destinations *obj = new Destinations();
    Destinations **userdata =
        reinterpret_cast&lt;Destinations **&gt;(
            lua_newuserdatauv(L, sizeof(obj), 0));
    *userdata = obj;
    int type = luaL_getmetatable(
        L, METATABLE_NAME.c_str());
    if (type == LUA_TNIL)
    {
        lua_pop(L, 1);
        luaL_newmetatable(L, METATABLE_NAME.c_str());
        lua_pushvalue(L, -1);
        lua_setfield(L, -2, "__index");
        luaL_setfuncs(L, REGS.data(), 0);
    }
    lua_setmetatable(L, 1);
    return 1;
}</pre>
<p>As you <a id="_idIndexMarker343"/>can see, the code here is separated by newlines. In this case, we have only inserted the second section. The rest of the code is kept as-is. Additionally, we declared a new constant called <code>METATABLE_NAME</code>. You can put this after the <code>NAME</code> constant. The second code section does the following:</p>
<ol>
<li>First, it gets the metatable containing the <code>METATABLE_NAME</code> key from the registry. The <code>luaL_getmetatable</code> library function is used for this.</li>
<li>If it’s not found, the metatable is created. We will expand on this detail later.</li>
<li>Finally, the code section sets the metatable to the userdata with <code>lua_setmetatable</code>. This library function expects the metatable to be on top of the stack. In our case, the position of the userdata in the stack is specified via the <code>1</code> parameter. <code>lua_setmetatable</code> will pop the metatable from the stack.</li>
</ol>
<p>To understand this better, see the following figure:</p>
<div><div><img alt="Figure 7.1 – Setting the metatable" height="298" src="img/B20927_07_01.jpg" width="1084"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Setting the metatable</p>
<p>The <a id="_idIndexMarker344"/>preceding figure shows how the stack’s state changes when the metatable is already in the registry.</p>
<p>Next, let’s look at the case when the metatable is not in the registry.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Creating a metatable for the userdata</h2>
<p>In our<a id="_idIndexMarker345"/> implementation, the metatable is created when a class instance is created from Lua for the first time. Specifically, the code to create the metatable is as follows; this was copied from the previous code listing:</p>
<pre class="source-code">
    if (type == LUA_TNIL)
    {
        lua_pop(L, 1);
        luaL_newmetatable(L, METATABLE_NAME.c_str());
        lua_pushvalue(L, -1);
        lua_setfield(L, -2, "__index");
        luaL_setfuncs(L, REGS.data(), 0);
    }</pre>
<p>When we need to create the metatable, the stack’s state changes, as shown in the following figure:</p>
<div><div><img alt="Figure 7.2 – Creating the metatable" height="690" src="img/B20927_07_02.jpg" width="1081"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Creating the metatable</p>
<p>Eight steps <a id="_idIndexMarker346"/>are involved in this process. Steps 4 to 7 deal with creating the new metatable.</p>
<ol>
<li>Creates a userdata with <code>lua_newuserdatauv</code> that holds a pointer to the class instance.</li>
<li>Tries to get a metatable from the registry with <code>luaL_getmetatable</code>. The metatable does not exist yet, so we will get a nil value.</li>
<li>Pops the nil value from the stack with <code>lua_pop</code>. Because it is not useful and is on top of the userdata in the stack, we need to return the userdata as the top of the stack.</li>
<li>Creates an empty metatable in the registry with <code>luaL_newmetatable</code>.</li>
<li>Pushes a copy of the reference to the metatable onto the stack with <code>lua_pushvalue</code>. Now, we have two references to the same metatable; we will use these in the next step.</li>
<li>Sets the <code>__index</code> field of the metatable as itself with <code>lua_setfield</code>. This ensures that we do not need to create another table for the <code>__index</code> field.</li>
<li>Sets the type functions in <code>REGS</code> to the metatable with <code>luaL_setfuncs</code>.</li>
<li>Sets the metatable to the userdata with <code>lua_setmetatable</code>.</li>
</ol>
<p>With this, when<a id="_idIndexMarker347"/> the Lua code calls a method on the userdata object, it will dispatch to the proper Lua C function wrapper.</p>
<p>How can we get the object in C++ in the Lua C wrapper function?</p>
<p>In the previous chapter, we used upvalue. Although this can still work, it is no longer suitable here. Let’s make object retrieval in C++ work again.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor171"/>Getting the object in C++</h2>
<p>In <code>script.lua</code>, we <a id="_idIndexMarker348"/>have changed the Lua code so that it uses the object calling convention with colons. This means that the object will be passed to the Lua C functions as the first argument.</p>
<p>To get the object reference, rewrite the <code>getObj</code> function, as follows:</p>
<pre class="source-code">
inline Destinations *getObj(lua_State *L)
{
    luaL_checkudata(L, 1, METATABLE_NAME.c_str());
    return *reinterpret_cast&lt;Destinations **&gt;(
        lua_touserdata(L, 1));
}</pre>
<p>This function is called from Lua C wrapper functions to get the object reference. This was first implemented in the previous chapter using an upvalue.</p>
<p>First, using the Lua <code>luaL_checkudata</code> library function, we check that the first argument is a userdata with a metatable in the <code>METATABLE_NAME</code> registry. This is a security measure to ensure that the Lua code does not pass an object of another type. The check on the metatable’s name works because only C/C++ code can access the registry.</p>
<p>Then, we return the first argument as a userdata cast to <code>Destinations **</code> and dereferenced to get the object pointer.</p>
<p>Since we <a id="_idIndexMarker349"/>are now passing the object from Lua in the calls, we need to modify our wrapper functions slightly.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor172"/>Making wrappers work again</h2>
<p>In <code>luaWish</code> and <code>luaWent</code>, we were expecting a list of cities. Now, we need to exclude the first argument. There<a id="_idIndexMarker350"/> is only one character to change. Rewrite <code>luaWish</code>, as follows:</p>
<pre class="source-code">
int luaWish(lua_State *L)
{
    Destinations *obj = getObj(L);
    std::vector&lt;std::string&gt; places;
    int nArgs = lua_gettop(L);
    for (int i = <strong class="bold">2</strong>; i &lt;= nArgs; i++)
    {
        places.push_back(lua_tostring(L, i));
    }
    obj-&gt;wish(places);
    return 0;
}</pre>
<p>We only changed <code>i = 1</code> to <code>i = 2</code> for the <code>for</code> loop. You can do the same for <code>luaWent</code>.</p>
<p>Now that we have exported the <code>Destinations</code> C++ type to Lua, let’s test it.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor173"/>Testing it out</h2>
<p>Since we<a id="_idIndexMarker351"/> have adopted a top-down approach in this chapter, all the test code is complete. Now, we only need to run the project.</p>
<p>If you’ve been following along, you should see the following output:</p>
<pre class="source-code">
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
[Lua] Visited: Berlin
[Lua] Unvisited: Beijing</pre>
<p>The first <a id="_idIndexMarker352"/>two lines are from the first object that was created in <code>script.lua</code>. The last two lines are from the second object that was created.</p>
<p>If you have made any errors in the code, you will see some error output here. Go back and see what you have missed. In this chapter, the code is a continuation of the previous chapter, but the stack’s state is quite complex.</p>
<p>Should we say, “Congratulations”? Wait a moment; have you discovered something we missed in the exported type?</p>
<p>Let’s print something in the constructor and the destructor to trace the object’s life cycle. Rewrite the constructor and the destructor, as follows:</p>
<pre class="source-code">
Destinations::Destinations() : wishlist({})
{
    std::cout &lt;&lt; "Destinations instance created: "
              &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::endl;
}
Destinations::~Destinations()
{
    std::cout &lt;&lt; "Destinations instance destroyed: "
              &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::endl;
}</pre>
<p>The constructor and the destructor simply output the object pointer value in hex format.</p>
<p>Run the project again and see what you get. You should see something similar to the following<a id="_idIndexMarker353"/> output:</p>
<pre class="source-code">
Destinations instance created: 0x12df07150
Destinations instance created: 0x12f804170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
Destinations instance created: 0x12f8043a0
[Lua] Visited: Berlin
[Lua] Unvisited: Beijing
Destinations instance destroyed: 0x12df07150</pre>
<p>Three instances are created, but only one is destroyed! The one that gets destroyed is the one that was created in <code>main.cpp</code> and was serving as the prototype for the <code>Destinations</code> type. This means that we are leaking objects in Lua!</p>
<p>We need to fix this!</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor174"/>Providing a finalizer</h2>
<p>Are<a id="_idIndexMarker354"/> you wondering why there is a memory leak?</p>
<p>This is because Lua uses garbage collection. We allocate a userdata and use it as a pointer. It is this pointer that gets garbage collected when the userdata is out of scope in Lua. The C++ object itself is not deleted.</p>
<p>Lua supports using userdata in this way perfectly fine, but you need to help Lua delete the object when the associated userdata is garbage collected. To help Lua, you can provide a <code>__gc</code> metamethod in the metatable. This is called a <strong class="bold">finalizer</strong>. It is invoked during the garbage collection process to delete your real object.</p>
<p>Let’s provide a finalizer named <code>luaDelete</code> for the <code>Destinations</code> type. Add another Lua C function above <code>luaNew</code>:</p>
<pre class="source-code">
int luaDelete(lua_State *L)
{
    Destinations *obj = getObj(L);
    delete obj;
    return 0;
}</pre>
<p>Easy, right? Lua <a id="_idIndexMarker355"/>passes the userdata object to the finalizer during garbage collection.</p>
<p>Now, let’s register it. In <code>luaNew</code>, add two more lines, as follows:</p>
<pre class="source-code">
int luaNew(lua_State *L)
{
    ....
    if (type == LUA_TNIL)
    {
        ...
        <strong class="bold">lua_pushcfunction(L, luaDelete);</strong>
        <strong class="bold">lua_setfield(L, -2, "__gc");</strong>
    }
    ...
}</pre>
<p>This sets the <code>__gc</code> metamethod for the metatable to our <code>luaDelete</code> function.</p>
<p>The interactions between Lua and C++ can be seen in the following diagram:</p>
<div><div><img alt="Figure 7.3 – Object creation and destruction" height="843" src="img/B20927_07_03.jpg" width="482"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Object creation and destruction</p>
<p>When Lua<a id="_idIndexMarker356"/> code creates an object of the <code>Destinations</code> class, it triggers a call to <code>luaNew</code>, which creates the C++ object and returns its pointer as a userdata. When Lua is done with the object, after a while, garbage collection is triggered and the <code>luaDelete</code> C++ finalizer is called.</p>
<p>Let’s run the project again. You should see an output similar to the following:</p>
<pre class="source-code">
Destinations instance created: 0x14c609a60
Destinations instance created: 0x14c704170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
Destinations instance created: 0x14c7043a0
[Lua] Visited: Berlin
[Lua] Unvisited: Beijing
Destinations instance destroyed: 0x14c609a60
Destinations instance destroyed: 0x14c7043a0
Destinations instance destroyed: 0x14c704170</pre>
<p>With that, we <a id="_idIndexMarker357"/>have created three instances and destroyed three instances.</p>
<p>Congratulations!</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor175"/>Summary</h1>
<p>In this chapter, we learned how to export C++ types to Lua so that Lua code can create C++ objects. We also learned about the registry and the userdata type. Last but not least, we implemented a finalizer for garbage collection.</p>
<p>The work in this chapter is based on registering C++ modules from the previous chapter. You can choose to export a C++ class or C++ class instances. It is a matter of design choice and your project’s needs.</p>
<p>In the next chapter, we will learn how to implement a template class to help export C++ types to Lua.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor176"/>Exercise</h1>
<p>In <code>main.cpp</code>, we created an instance of <code>Destinations</code> and registered it to Lua. In Lua code, this instance is used to create more instances. This is fine, considering that Lua uses prototype-based object-oriented programming as well. If you want to make your C++ code more like C++’s way of doing things, you can create a factory class for <code>Destinations</code> and register the factory to Lua. Do this and make the factory only export the <code>luaNew</code> function. You shouldn’t need to change <code>script.lua</code> or the Lua C wrapper function implementations.</p>
</div>
</div></body></html>