- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Main Software Development Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the main software design principles that are
    used to create well-structured and maintainable code. One of the most important
    principles is SOLID, which stands for Single Responsibility Principle, Open-Closed
    Principle, Liskov Substitution Principle, Interface Segregation Principle, and
    Dependency Inversion Principle. These principles are designed to help developers
    create code that is easy to understand, test, and modify. We will also discuss
    the importance of levels of abstraction, which is the practice of breaking down
    complex systems into smaller, more manageable parts. Additionally, we will explore
    the concepts of side effects and mutability and how they can affect the overall
    quality of software. By understanding and applying these principles, developers
    can create software that is more robust, reliable, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID is a set of principles that were first introduced by Robert C. Martin
    in his book *Agile Software Development, Principles, Patterns, and Practices*,
    in 2000\. Robert C. Martin, also known as Uncle Bob, is a software engineer, author,
    and speaker. He is considered one of the most influential figures in the software
    development industry, known for his work on the SOLID principles and his contributions
    to the field of object-oriented programming. Martin has been a software developer
    for more than 40 years and has worked on a wide variety of projects, from small
    systems to large enterprise systems. He is also a well-known speaker and has given
    presentations on software development at many conferences and events around the
    world. He is an advocate of agile methodologies, and he has been influential in
    the development of the Agile Manifesto. The SOLID principles were developed as
    a way to help developers create more maintainable and scalable code by promoting
    good design practices. The principles were based on Martin’s experience as a software
    developer and his observation that many software projects suffer from poor design,
    which makes them difficult to understand, change, and maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles are intended to be a guide for object-oriented software
    design, and they are based on the idea that software should be easy to understand,
    change, and extend over time. The principles are meant to be applied in conjunction
    with other software development practices, such as test-driven development and
    continuous integration. By following SOLID principles, developers can create code
    that is more robust, less prone to bugs, and easier to maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Single Responsibility Principle** (**SRP**) is one of the five SOLID principles
    of object-oriented software design. It states that a class should have only one
    reason to change, meaning that a class should have only one responsibility. This
    principle is intended to promote code that is easy to understand, change, and
    test.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the SRP is that a class should have a single, well-defined purpose.
    This makes it easier to understand the class’s behavior and makes it less likely
    that changes to the class will have unintended consequences. When a class has
    only one responsibility, it is also less likely to have bugs, and it is easier
    to write automated tests for it.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the SRP can be a useful way to improve the design of a software system
    by making it more modular and easier to understand. By following this principle,
    a developer can create classes that are small, focused, and easy to reason about.
    This makes it easier to maintain and improve the software over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a messaging system that supports multiple message types sent
    over the network. The system has a `Message` class that receives sender and receiver
    IDs and raw data to be sent. Additionally, it supports saving messages to the
    disk and sending itself via the `send` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Message` class is responsible for multiple concerns, such as saving messages
    from/to the filesystem, serializing data, sending messages, and holding the sender
    and receiver IDs and raw data. It would be better to separate these responsibilities
    into different classes or modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Message` class is only responsible for storing the data and serializing
    it to JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save` method can be extracted to a separate `MessageSaver` class, having
    a single responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And the `send` method is implemented in a dedicated `MessageSender` class. All
    three classes have a single and clear responsibility, and any further changes
    in any of them would not affect the others. This approach allows isolating the
    changes in the code base. It becomes crucial in a complex system requiring long
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the SRP states that a class should have only one reason to change,
    meaning that a class should have only one responsibility. This principle is intended
    to promote code that is easy to understand, change, and test, and it helps in
    creating a more modular, maintainable, and scalable code base. By following this
    principle, developers can create classes that are small, focused, and easy to
    reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications of the SRP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SRP can be applied not only to classes but also to larger components, such
    as applications. At the architecture level, the SRP is often implemented as microservices
    architecture. The idea of microservices is to build a software system as a collection
    of small, independent services that communicate with each other over a network
    rather than building it as a monolithic application. Each microservice is *responsible
    for a specific business capability and can be developed, deployed, and scaled
    independently from the other services*. This allows for greater flexibility, scalability,
    and ease of maintenance, as changes to one service do not affect the entire system.
    Microservices also enable a more agile development process, as teams can work
    on different services in parallel, and also allows for a more fine-grained approach
    to security, monitoring, and testing, as each service can be handled individually.
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Open-Closed principle states that a module or class should be open for extension
    but closed for modification. In other words, it should be possible to add new
    functionality to a module or class without modifying its existing code. This principle
    helps to promote software maintainability and flexibility. An example of this
    principle in C++ is the use of inheritance and polymorphism. A base class can
    be written with the ability to be extended by derived classes, allowing for new
    functionality to be added without modifying the base class. Another example is
    using interfaces or abstract classes to define a contract for a set of related
    classes, allowing new classes to be added that conform to the contract without
    modifying existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Open-closed Principle can be used to improve our message-sending components.
    The current version supports only one message type. If we want to add more data,
    we need to change the `Message` class: add fields, hold a message type as an additional
    variable, and not to mention serialization based on this variable. In order to
    avoid changes in existing code, let us rewrite the `Message` class to be purely
    virtual, providing the `serialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us assume that we need to add another two message types: a “start”
    message supporting start delay (often done for debugging purposes) and a “stop”
    message supporting stop delay (can be used for scheduling); they can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that none of the implementations requires changes in other classes, and
    each of them provides its own version of the `serialize` method. The `MessageSender`
    and `MessageSaver` classes do not need additional adjustments to support the new
    class hierarchy of messages. However, we are going to change them too. The main
    reason is to make them extendable without requiring changes. For example, a message
    can be saved not only to the filesystem but also to remote storage. In this case,
    `MessageSaver` becomes purely virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation responsible for saving to the filesystem is a class derived
    from `MessageSaver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the remote storage saver is another class in the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Liskov Substitution Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Liskov Substitution Principle** (**LSP**) is a fundamental principle in
    object-oriented programming that states that objects of a superclass should be
    able to be replaced with objects of a subclass without affecting the correctness
    of the program. This principle is also known as the Liskov principle, named after
    Barbara Liskov, who first formulated it. The LSP is based on the idea of inheritance
    and polymorphism, where a subclass can inherit the properties and methods of its
    parent class and can be used interchangeably with it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow the LSP, subclasses must be “behaviorally compatible” with
    their parent class. This means that they should have the same method signatures
    and follow the same contracts, such as input and output types and ranges. Additionally,
    the behavior of a method in a subclass should not violate any of the contracts
    established in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a new `Message` type, `InternalMessage`, which does not support
    the `serialize` method. One might be tempted to implement it in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `InternalMessage` is a subtype of `Message` but cannot
    be serialized, throwing an exception instead. This design is problematic for a
    few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InternalMessage` is a subtype of `Message`, then we should be able to use
    `InternalMessage` wherever `Message` is expected without affecting the correctness
    of the program. By throwing an exception in the `serialize` method, we are breaking
    this principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialize` must handle exceptions, which might not have been necessary when
    dealing with other `Message` types. This introduces additional complexity and
    the potential for errors in the caller code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program crashes**: If the exception is not properly handled, it could lead
    to the program crashing, which is certainly not a desirable outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could return an empty string instead of throwing an exception, but this still
    violates the LSP, as the `serialize` method is expected to return a serialized
    message, not an empty string. It also introduces ambiguity, as it’s not clear
    whether an empty string is the result of a successful serialization of a message
    with no data or an unsuccessful serialization of `InternalMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to separate the concerns of a `Message` and a `SerializableMessage`,
    where only `SerializableMessage`s have a `serialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this corrected design, the base `Message` class does not include a `serialize`
    method, and a new `SerializableMessage` class has been introduced that includes
    this method. This way, only messages that can be serialized will inherit from
    `SerializableMessage`, and we adhere to the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to the LSP allows for more flexible and maintainable code, as it enables
    the use of polymorphism and allows for substituting objects of a class with objects
    of its subclasses without affecting the overall behavior of the program. This
    way, the program can take advantage of the new functionality provided by the subclass
    while maintaining the same behavior as the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Segregation Principle
  prefs: []
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle** (**ISP**) is a principle in object-oriented
    programming that states that a class should only implement the interfaces it uses.
    In other words, it suggests that interfaces should be fine-grained and client-specific
    rather than having a single, large, and all-encompassing interface. The ISP is
    based on the idea that it is better to have many small interfaces that each define
    a specific set of methods rather than a single large interface that defines many
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of the ISP is that it promotes a more modular and flexible
    design, as it allows for the creation of interfaces that are tailored to the specific
    needs of a client. This way, it reduces the number of unnecessary methods that
    a client needs to implement, and also it reduces the risk of a client depending
    on methods that it does not need.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the ISP can be observed when creating our example messages from
    MessagePack or JSON files. Following the best practices, we would create an interface
    providing two methods, `from_message_pack` and `from_json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current implementations need to implement both methods, but what if a particular
    class does not need to support both options? The smaller the interface, the better.
    The `MessageParser` interface will be split into two separate interfaces, each
    requiring the implementation of either JSON or MessagePack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This design allows for objects derived from `JsonMessageParser` and `MessagePackMessageParser`
    to understand how to construct themselves from JSON and MessagePack, respectively,
    while preserving the independence and functionality of each function. The system
    remains flexible as new smaller objects can still be composed to achieve the desired
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to the ISP makes the code more maintainable and less prone to errors,
    as it reduces the number of unnecessary methods that a client needs to implement,
    and it also reduces the risk of a client depending on methods that it does not
    need.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency inversion principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dependency inversion principle is based on the idea that it is better to
    depend on abstractions rather than on concrete implementations, as it allows for
    greater flexibility and maintainability. It allows the decoupling of high-level
    modules from low-level modules, making them more independent and less prone to
    changes in the low-level modules. This way, it makes it easy to change low-level
    implementations without affecting high-level modules and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DIP can be illustrated for our messaging system if we try to use all the
    components via another class. Let us assume that there is a class responsible
    for message routing. In order to build such a class, we are going to use `MessageSender`
    as a communication module, `Message` based classes, and `MessageSaver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The new class provides only one `route` method, which is called once a new message
    is available. The router handles the message to the `MessageHandler` class if
    the message’s sender ID equals the router’s. Otherwise, the router forwards the
    message to the corresponding receiver. In case the delivery of the message fails
    and the communication layer throws an exception, the router saves the message
    via `MessageSaver`. Those messages will be delivered some other time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem is that if any dependency needs to be changed, the router’s
    code has to be updated accordingly. For example, if the application needs to support
    several types of senders (TCP and UDP), the message saver (filesystem versus remote)
    or message handler’s logic changes. In order to make `MessageRouter` agnostic
    to such changes, we can rewrite it using the DIP principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this revised version of the code, `MessageRouter` is now decoupled from specific
    implementations of the message handling, sending, and saving logic. Instead, it
    relies on abstractions represented by `BaseMessageHandler`, `BaseMessageSender`,
    and `BaseMessageSaver`. This way, any class that derives from these base classes
    can be used with `MessageRouter`, which makes the code more flexible and easier
    to extend in the future. The router is not concerned with the specifics of how
    messages are handled, sent, or saved – it only needs to know that these operations
    can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to the DIP makes code more maintainable and less prone to errors. It
    decouples high-level modules from low-level modules, making them more independent
    and less prone to changes in low-level modules. It also allows for greater flexibility,
    making it easy to change low-level implementations without affecting high-level
    modules and vice versa. Later in this book, dependency inversion will help us
    mock parts of the system while developing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The KISS principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The KISS principle, which stands for “Keep It Simple, Stupid,” is a design philosophy
    that emphasizes the importance of keeping things simple and straightforward. This
    principle is particularly relevant in the world of programming, where complex
    code can lead to bugs, confusion, and slow development time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how the KISS principle can be applied in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` loop instead of a complex algorithm can often be just as effective and
    much easier to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep Functions Small**: Functions in C++ should be small, focused, and easy
    to understand. Complex functions can quickly become difficult to maintain and
    debug, so try to keep functions as simple and concise as possible. A good rule
    of thumb is to aim for functions that are no longer than 30-50 lines of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Clear and Concise Variable Names**: In C++, variable names play a crucial
    role in making code readable and understandable. Avoid using abbreviations and
    instead opt for clear and concise names that accurately describe the purpose of
    the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid Deep Nesting**: Nested loops and conditional statements can make code
    hard to read and follow. Try to keep the nesting levels as shallow as possible,
    and consider breaking up complex functions into smaller, simpler functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write Simple, Readable Code**: Above all, aim to write code that is easy
    to understand and follow. This means using clear and concise language and avoiding
    complicated expressions and structures. Code that is simple and easy to follow
    is much more likely to be maintainable and bug-free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid Complex Inheritance Hierarchy**: Complex inheritance hierarchies can
    make code more difficult to understand, debug, and maintain. The more complex
    the inheritance structure, the harder it becomes to keep track of the relationships
    between classes and determine how changes will affect the rest of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, the KISS principle is a simple and straightforward design philosophy
    that can help developers write clear, concise, and maintainable code. By keeping
    things simple, developers can avoid bugs and confusion and speed up development
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The KISS and SOLID Principles together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SOLID principles and the KISS principle are both important design philosophies
    in software development, but they can sometimes contradict each other.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles are a set of five principles that guide the design of software,
    aimed at making it more maintainable, scalable, and flexible. They focus on creating
    a clean, modular architecture that follows good object-oriented design practices.
  prefs: []
  type: TYPE_NORMAL
- en: The KISS principle, on the other hand, is all about keeping things simple. It
    advocates for straightforward, simple solutions, avoiding complex algorithms and
    structures that can make code hard to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: While both SOLID and KISS aim to improve software quality, they can sometimes
    be at odds. For example, following the SOLID principles may result in code that
    is more complex and harder to understand to achieve greater modularity and maintainability.
    Similarly, the KISS principle may result in less flexible and scalable code to
    keep it simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, developers often have to strike a balance between the SOLID principles
    and the KISS principle. On the one hand, they want to write code that is maintainable,
    scalable, and flexible. On the other hand, they want to write code that is simple
    and easy to understand. Finding this balance requires careful consideration of
    trade-offs and an understanding of when each approach is most appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I have to choose between the SOLID and KISS approaches, I think about
    something my boss, Amir Taya, said, “When building a Ferrari, you need to start
    from a scooter.” This phrase is an exaggerated example of KISS: if you do not
    know how to build a feature, make the simplest working version (KISS), re-iterate,
    and extend the solution using SOLID principles if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects and immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Side effects and immutability are two important concepts in programming that
    have a significant impact on the quality and maintainability of code.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects refer to changes that occur in the state of the program as a result
    of executing a particular function or piece of code. Side effects can be explicit,
    such as writing data to a file or updating a variable, or implicit, such as modifying
    the global state or causing unexpected behavior in other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability, on the other hand, refers to the property of a variable or data
    structure that cannot be modified after it has been created. In functional programming,
    immutability is achieved by making data structures and variables constant and
    avoiding side effects.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of avoiding side effects and using immutable variables lies in
    the fact that they make code easier to understand, debug, and maintain. When code
    has few side effects, it is easier to reason about what it does and what it does
    not do. This makes finding and fixing bugs and making changes to the code easier
    without affecting other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, code with many side effects is harder to understand, as the state
    of the program can change in unexpected ways. This makes it more difficult to
    debug and maintain and can lead to bugs and unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages have long emphasized the use of immutability
    and the avoidance of side effects, but it is now possible to write code with these
    properties using C++. The easiest way to achieve it is to follow the **C++ Core
    Guidelines for Constants** **and Immutability**.
  prefs: []
  type: TYPE_NORMAL
- en: Con.1 – by default, make objects immutable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can declare a built-in data type or an instance of a user-defined data
    type as constant, resulting in the same effect. Attempting to modify it will result
    in a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows the prevention of hard-to-notice changes of value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably, the only exception is function parameters passed by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Such parameters are rarely passed as `const` and rarely mutated. In order to
    avoid confusion, it is recommended not to enforce this rule in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Con.2 – by default, make member functions const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A member function (method) shall be marked as `const` unless it changes the
    observable state of an object. The reason behind this is to give a more precise
    statement of design intent, better readability, maintainability, more errors caught
    by the compiler, and theoretically more optimization opportunities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two types of constness: **physical** and **logical**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` and cannot be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` but can be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical constness can be achieved with the `mutable` keyword. In general, it
    is a rare use case. The only good example I can think of is storing in an internal
    cache or using a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to change the `mutex` variable to lock it, but this
    does not affect the logical constness of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please be aware that there exist legacy codes/libraries that provide functions
    that declare `T*`, despite not making any changes to the `T`. This presents an
    issue for individuals who are trying to mark all logically constant methods as
    `const`. In order to enforce constness, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the library/code to be const-correct, which is the preferred solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a wrapper function casting away the constness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that this solution is a patch that can be used only when the declaration
    of `read_data` cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Con.3 – by default, pass pointers and references to const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is easy; it is far easier to reason about programs when called functions
    do not modify state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the two following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Does the `foo` function modify the data the `p` pointer points to? We cannot
    answer by looking at the declaration, so we assume it does by default. However,
    the `bar` function states explicitly that the content of `p` will not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Con.4 – use const to define objects with values that do not change after construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This rule is very similar to the first one, enforcing the constness of objects
    that are not expected to be changed in the future. It is often helpful with classes
    such as `Config` that are created at the beginning of the application and not
    changed during its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Con.5 – use constexpr for values that can be computed at compile time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring variables as `constexpr` is preferred over `const` if the value is
    computed at compile time. It provides such benefits as better performance, better
    compile-time checking, guaranteed compile-time evaluation, and no possibility
    of race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Constness and data races
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data races occur when multiple threads access a shared variable simultaneously,
    and at least one tries to modify it. There are synchronization primitives such
    as mutexes, critical sections, spinlocks, and semaphores, allowing the prevention
    of data races. The problem with these primitives is that they either do expensive
    system calls or overuse the CPU, which makes the code less efficient. However,
    if none of the threads modifies the variable, there is no place for data races.
    We learned that `constexpr` is thread-safe (does not need synchronization) because
    it is defined at compile time. What about `const`? It can be thread-safe under
    the below conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable has been `const` since its creation. If a thread has direct or
    indirect (via a pointer or reference) non-const access to the variable, all the
    readers need to use mutexes. The following code snippet illustrates constant and
    non-constant access from multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `a` function, the `value` variable is owned as non-constant by both
    the main thread and `t`, which makes the code potentially not thread-safe (if
    a developer decides to change the `value` later in the main thread). In the `b`,
    the main thread has “write” access to `value` while `t` receives it via a `const`
    reference, but still, it is not thread-safe. The `c` function is an example of
    very bad code: the `value` is created as a constant in the main thread and passed
    as a `const` reference but then the constness is cast away, which makes this function
    not thread-safe. Only the `d` function is thread-safe because neither the main
    thread nor `t` can modify the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data type and all sub-types of the variable are either physically constant
    or their logical constness implementation is thread-safe. For example, in the
    following example, the `Point` struct is physically constant because its `x` and
    `y` field members are primitive integers, and both threads have only `const` access
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataReader` class that we saw earlier is logically constant because it
    has a mutable variable, `mutex`, but this implementation is also thread-safe (due
    to the lock):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let us look into the following case. The `RequestProcessor` class
    processes some heavy requests and caches the results in an internal variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This class is logically safe, but the `cache_` variable is changed in a non-thread-safe
    way, which makes the class non-thread-safe even when declared as `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when working with STL containers, it is essential to remember that,
    despite current implementations tending to be thread-safe (physically and logically),
    the standard provides very specific thread-safety guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: All functions in a container can be called simultaneously by various threads
    on different containers. Broadly, functions from the C++ standard library don’t
    read objects accessible to other threads unless they are reachable through the
    function arguments, which includes the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: All `const` member functions are thread-safe, meaning they can be invoked simultaneously
    by various threads on the same container. Furthermore, the `begin()`, `end()`,
    `rbegin()`, `rend()`, `front()`, `back()`, `data()`, `find()`, `lower_bound()`,
    `upper_bound()`, `equal_range()`, `at()`, and `operator[]` (except in associative
    containers) member functions also behave as `const` with regard to thread safety.
    In other words, they can also be invoked by various threads on the same container.
    Broadly, C++ standard library functions won’t modify objects unless those objects
    are reachable, directly or indirectly, via the function’s non-const arguments,
    which includes the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Different elements in the same container can be altered simultaneously by different
    threads, with the exception of `std::vector<bool>` elements. For example, a `std::vector`
    of `std::future` objects can receive values from multiple threads at once.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on iterators, such as incrementing an iterator, read the underlying
    container but don’t modify it. These operations can be performed concurrently
    with operations on other iterators of the same container, with the `const` member
    functions, or with reads from the elements. However, operations that invalidate
    any iterators modify the container and must not be performed concurrently with
    any operations on existing iterators, even those that are not invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of the same container can be altered concurrently with those member
    functions that don’t access these elements. Broadly, C++ standard library functions
    won’t read objects indirectly accessible through their arguments (including other
    elements of a container) except when required by its specification.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, operations on containers (as well as algorithms or other C++ standard
    library functions) can be internally parallelized as long as the user-visible
    results remain unaffected. For example, `std::transform` can be parallelized,
    but `std::for_each` cannot, as it is specified to visit each element of a sequence
    in order.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of having a single mutable reference to an object became one of the
    pillars of the Rust programming language. This rule is in place to prevent data
    races, which occur when multiple threads access the same mutable data concurrently,
    resulting in unpredictable behavior and potential crashes. By allowing only one
    mutable reference to an object at a time, Rust ensures that concurrent access
    to the same data is properly synchronized and avoids data races.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this rule helps prevent mutable aliasing, which occurs when multiple
    mutable references to the same data exist simultaneously. Mutable aliasing can
    lead to subtle bugs and make code difficult to reason about, especially in large
    and complex code bases. By allowing only one mutable reference to an object, Rust
    avoids mutable aliasing and helps ensure that code is correct and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s worth noting that Rust also allows multiple immutable references
    to an object, which can be useful in scenarios where concurrent access is necessary
    but mutations are not. By allowing multiple immutable references, Rust can provide
    better performance and concurrency while still maintaining safety and correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the SOLID principles, the KISS principle, constness,
    and immutability. Let’s see what you learned!
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID principles: SOLID is a set of five principles that help us create code
    that’s easy to maintain, scalable, and flexible. By understanding these principles,
    you’re on your way to designing code that’s a dream to work with!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The KISS principle: The KISS principle is all about keeping things simple.
    By following this principle, you’ll avoid overcomplicating your code, making it
    easier to maintain and debug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constness: Constness is a property in C++ that makes objects read-only. By
    declaring objects as `const`, you can ensure that their values won’t be accidentally
    changed, making your code more stable and predictable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutability: Immutability is all about making sure objects can’t be changed
    after their creation. By making objects immutable, you can avoid sneaky bugs and
    make your code more predictable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these design principles under your belt, you’re on your way to writing
    code that’s both robust and reliable. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will try to understand what causes bad code.
  prefs: []
  type: TYPE_NORMAL
