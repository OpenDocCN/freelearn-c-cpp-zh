- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Main Software Development Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要软件开发原则
- en: In this chapter, we will explore the main software design principles that are
    used to create well-structured and maintainable code. One of the most important
    principles is SOLID, which stands for Single Responsibility Principle, Open-Closed
    Principle, Liskov Substitution Principle, Interface Segregation Principle, and
    Dependency Inversion Principle. These principles are designed to help developers
    create code that is easy to understand, test, and modify. We will also discuss
    the importance of levels of abstraction, which is the practice of breaking down
    complex systems into smaller, more manageable parts. Additionally, we will explore
    the concepts of side effects and mutability and how they can affect the overall
    quality of software. By understanding and applying these principles, developers
    can create software that is more robust, reliable, and scalable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于创建结构良好且易于维护的代码的主要软件设计原则。其中最重要的原则之一是SOLID原则，它代表单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则。这些原则旨在帮助开发者创建易于理解、测试和修改的代码。我们还将讨论抽象层次的重要性，这是将复杂系统分解成更小、更易于管理的部分的做法。此外，我们还将探讨副作用和可变性概念及其如何影响软件的整体质量。通过理解和应用这些原则，开发者可以创建更健壮、更可靠和可扩展的软件。
- en: SOLID
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID
- en: SOLID is a set of principles that were first introduced by Robert C. Martin
    in his book *Agile Software Development, Principles, Patterns, and Practices*,
    in 2000\. Robert C. Martin, also known as Uncle Bob, is a software engineer, author,
    and speaker. He is considered one of the most influential figures in the software
    development industry, known for his work on the SOLID principles and his contributions
    to the field of object-oriented programming. Martin has been a software developer
    for more than 40 years and has worked on a wide variety of projects, from small
    systems to large enterprise systems. He is also a well-known speaker and has given
    presentations on software development at many conferences and events around the
    world. He is an advocate of agile methodologies, and he has been influential in
    the development of the Agile Manifesto. The SOLID principles were developed as
    a way to help developers create more maintainable and scalable code by promoting
    good design practices. The principles were based on Martin’s experience as a software
    developer and his observation that many software projects suffer from poor design,
    which makes them difficult to understand, change, and maintain over time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一组原则，最初由Robert C. Martin在他的2000年出版的《敏捷软件开发：原则、模式和实践》一书中提出。Robert C.
    Martin，也被称为Uncle Bob，是一位软件工程师、作家和演讲家。他被认为是在软件开发行业中最具影响力的人物之一，以其对SOLID原则的工作和对面向对象编程领域的贡献而闻名。Martin作为一名软件工程师已有40多年的经验，参与过从小型系统到大型企业系统的各种项目。他也是一位知名的演讲家，在世界各地的许多会议和活动中发表了关于软件开发的演讲。他是敏捷方法的倡导者，对敏捷宣言的发展产生了重要影响。SOLID原则的开发是为了帮助开发者通过促进良好的设计实践来创建更易于维护和可扩展的代码。这些原则基于Martin作为软件工程师的经验以及他观察到许多软件项目因设计不佳而难以理解、更改和维护的观察。
- en: The SOLID principles are intended to be a guide for object-oriented software
    design, and they are based on the idea that software should be easy to understand,
    change, and extend over time. The principles are meant to be applied in conjunction
    with other software development practices, such as test-driven development and
    continuous integration. By following SOLID principles, developers can create code
    that is more robust, less prone to bugs, and easier to maintain over time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则旨在作为面向对象软件设计的指南，并基于软件应易于理解、随时间变化和扩展的想法。这些原则旨在与其他软件开发实践结合使用，例如测试驱动开发和持续集成。遵循SOLID原则，开发者可以创建更健壮、更少出现错误且易于长期维护的代码。
- en: The Single Responsibility Principle
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The **Single Responsibility Principle** (**SRP**) is one of the five SOLID principles
    of object-oriented software design. It states that a class should have only one
    reason to change, meaning that a class should have only one responsibility. This
    principle is intended to promote code that is easy to understand, change, and
    test.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）是面向对象软件设计的五个SOLID原则之一。它指出，一个类应该只有一个改变的理由，这意味着一个类应该只有一个职责。这个原则旨在促进易于理解、更改和测试的代码。'
- en: The idea behind the SRP is that a class should have a single, well-defined purpose.
    This makes it easier to understand the class’s behavior and makes it less likely
    that changes to the class will have unintended consequences. When a class has
    only one responsibility, it is also less likely to have bugs, and it is easier
    to write automated tests for it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SRP背后的理念是一个类应该有一个单一、明确的目的。这使得理解类的行为更加容易，并减少了类变更产生意外后果的可能性。当一个类只有一个职责时，它也更不容易出现错误，并且为其编写自动化测试也更加容易。
- en: Applying the SRP can be a useful way to improve the design of a software system
    by making it more modular and easier to understand. By following this principle,
    a developer can create classes that are small, focused, and easy to reason about.
    This makes it easier to maintain and improve the software over time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用SRP可以通过使系统更加模块化和易于理解来提高软件系统的设计。通过遵循这个原则，开发者可以创建小型、专注且易于推理的类。这使得随着时间的推移维护和改进软件变得更加容易。
- en: 'Let us look at a messaging system that supports multiple message types sent
    over the network. The system has a `Message` class that receives sender and receiver
    IDs and raw data to be sent. Additionally, it supports saving messages to the
    disk and sending itself via the `send` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个支持通过网络发送多种消息类型的消息系统。该系统有一个`Message`类，它接收发送者和接收者ID以及要发送的原始数据。此外，它还支持将消息保存到磁盘并通过`send`方法发送自身：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Message` class is responsible for multiple concerns, such as saving messages
    from/to the filesystem, serializing data, sending messages, and holding the sender
    and receiver IDs and raw data. It would be better to separate these responsibilities
    into different classes or modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类负责多个关注点，例如从/到文件系统保存消息、序列化数据、发送消息以及持有发送者和接收者ID和原始数据。将这些职责分离到不同的类或模块中会更好。'
- en: 'The `Message` class is only responsible for storing the data and serializing
    it to JSON format:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类只负责存储数据和将其序列化为JSON格式：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `save` method can be extracted to a separate `MessageSaver` class, having
    a single responsibility:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法可以被提取到一个单独的`MessageSaver`类中，拥有单一职责：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And the `send` method is implemented in a dedicated `MessageSender` class. All
    three classes have a single and clear responsibility, and any further changes
    in any of them would not affect the others. This approach allows isolating the
    changes in the code base. It becomes crucial in a complex system requiring long
    compilation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 而`send`方法是在一个专门的`MessageSender`类中实现的。这三个类都有单一且明确的责任，并且任何对其中任何一个类的进一步更改都不会影响其他类。这种方法允许在代码库中隔离更改。在需要长时间编译的复杂系统中，这一点变得至关重要。
- en: In summary, the SRP states that a class should have only one reason to change,
    meaning that a class should have only one responsibility. This principle is intended
    to promote code that is easy to understand, change, and test, and it helps in
    creating a more modular, maintainable, and scalable code base. By following this
    principle, developers can create classes that are small, focused, and easy to
    reason about.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，SRP（单一职责原则）指出，一个类应该只有一个改变的理由，这意味着一个类应该只有一个职责。这个原则旨在促进易于理解、更改和测试的代码，并有助于创建更模块化、可维护和可扩展的代码库。遵循这个原则，开发者可以创建小型、专注且易于推理的类。
- en: Other applications of the SRP
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SRP的其他应用
- en: The SRP can be applied not only to classes but also to larger components, such
    as applications. At the architecture level, the SRP is often implemented as microservices
    architecture. The idea of microservices is to build a software system as a collection
    of small, independent services that communicate with each other over a network
    rather than building it as a monolithic application. Each microservice is *responsible
    for a specific business capability and can be developed, deployed, and scaled
    independently from the other services*. This allows for greater flexibility, scalability,
    and ease of maintenance, as changes to one service do not affect the entire system.
    Microservices also enable a more agile development process, as teams can work
    on different services in parallel, and also allows for a more fine-grained approach
    to security, monitoring, and testing, as each service can be handled individually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）不仅适用于类，也适用于更大的组件，如应用程序。在架构层面，SRP通常实现为微服务架构。微服务的理念是将软件系统构建为一系列小型、独立的服务的集合，这些服务通过网络相互通信，而不是将其构建为一个单体应用程序。每个微服务*负责特定的业务能力，并且可以独立于其他服务进行开发、部署和扩展*。这允许有更大的灵活性、可扩展性和易于维护，因为对一个服务的更改不会影响整个系统。微服务还使开发过程更加敏捷，因为团队可以并行工作在不同的服务上，同时也允许对安全、监控和测试采取更细粒度的方法，因为每个服务都可以单独处理。
- en: The Open-Closed Principle
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放-封闭原则
- en: The Open-Closed principle states that a module or class should be open for extension
    but closed for modification. In other words, it should be possible to add new
    functionality to a module or class without modifying its existing code. This principle
    helps to promote software maintainability and flexibility. An example of this
    principle in C++ is the use of inheritance and polymorphism. A base class can
    be written with the ability to be extended by derived classes, allowing for new
    functionality to be added without modifying the base class. Another example is
    using interfaces or abstract classes to define a contract for a set of related
    classes, allowing new classes to be added that conform to the contract without
    modifying existing code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开放-封闭原则指出，模块或类应该是可扩展的，但应该是封闭的以进行修改。换句话说，应该能够在不修改现有代码的情况下向模块或类添加新功能。这个原则有助于促进软件的可维护性和灵活性。C++中这个原则的一个例子是使用继承和多态。可以编写一个基类，使其能够被派生类扩展，从而在不修改基类的情况下添加新功能。另一个例子是使用接口或抽象类来定义一组相关类的合同，允许添加符合合同的新类，而无需修改现有代码。
- en: 'The Open-closed Principle can be used to improve our message-sending components.
    The current version supports only one message type. If we want to add more data,
    we need to change the `Message` class: add fields, hold a message type as an additional
    variable, and not to mention serialization based on this variable. In order to
    avoid changes in existing code, let us rewrite the `Message` class to be purely
    virtual, providing the `serialize` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开放-封闭原则可以用来改进我们的消息发送组件。当前版本只支持一种消息类型。如果我们想添加更多数据，我们需要修改`Message`类：添加字段，保留一个额外的消息类型变量，而且不用说基于这个变量的序列化。为了避免对现有代码的修改，让我们将`Message`类重写为纯虚拟的，提供`serialize`方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let us assume that we need to add another two message types: a “start”
    message supporting start delay (often done for debugging purposes) and a “stop”
    message supporting stop delay (can be used for scheduling); they can be implemented
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们需要添加另外两种消息类型：一种支持启动延迟的“启动”消息（通常用于调试目的）和一种支持停止延迟的“停止”消息（可用于调度）；它们可以按以下方式实现：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that none of the implementations requires changes in other classes, and
    each of them provides its own version of the `serialize` method. The `MessageSender`
    and `MessageSaver` classes do not need additional adjustments to support the new
    class hierarchy of messages. However, we are going to change them too. The main
    reason is to make them extendable without requiring changes. For example, a message
    can be saved not only to the filesystem but also to remote storage. In this case,
    `MessageSaver` becomes purely virtual:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些实现都不需要修改其他类，每个实现都提供了自己的`serialize`方法版本。`MessageSender`和`MessageSaver`类不需要额外的调整来支持消息的新类层次结构。然而，我们也将对它们进行修改。主要原因是为了使它们可扩展而不需要修改。例如，消息不仅可以保存到文件系统，还可以保存到远程存储。在这种情况下，`MessageSaver`变为纯虚拟的：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The implementation responsible for saving to the filesystem is a class derived
    from `MessageSaver`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 负责保存到文件系统的实现是从 `MessageSaver` 派生出来的类：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the remote storage saver is another class in the hierarchy:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并且远程存储保存器是层次结构中的另一个类：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Liskov Substitution Principle
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov 替换原则
- en: The **Liskov Substitution Principle** (**LSP**) is a fundamental principle in
    object-oriented programming that states that objects of a superclass should be
    able to be replaced with objects of a subclass without affecting the correctness
    of the program. This principle is also known as the Liskov principle, named after
    Barbara Liskov, who first formulated it. The LSP is based on the idea of inheritance
    and polymorphism, where a subclass can inherit the properties and methods of its
    parent class and can be used interchangeably with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov 替换原则**（**LSP**）是面向对象编程中的一个基本原则，它指出，超类对象应该能够被子类对象替换，而不会影响程序的正确性。这个原则也被称为
    Liskov 原则，以 Barbara Liskov 的名字命名，她是第一个提出这个原则的人。LSP 基于继承和多态的概念，其中子类可以继承其父类的属性和方法，并且可以与它互换使用。'
- en: In order to follow the LSP, subclasses must be “behaviorally compatible” with
    their parent class. This means that they should have the same method signatures
    and follow the same contracts, such as input and output types and ranges. Additionally,
    the behavior of a method in a subclass should not violate any of the contracts
    established in the parent class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循 LSP，子类必须与它们的父类“行为兼容”。这意味着它们应该有相同的方法签名并遵循相同的契约，例如输入和输出类型和范围。此外，子类中方法的行为不应违反父类中建立的任何契约。
- en: 'Let’s consider a new `Message` type, `InternalMessage`, which does not support
    the `serialize` method. One might be tempted to implement it in the following
    way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个新的 `Message` 类型，`InternalMessage`，它不支持 `serialize` 方法。有人可能会倾向于以下方式实现它：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, `InternalMessage` is a subtype of `Message` but cannot
    be serialized, throwing an exception instead. This design is problematic for a
    few reasons:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`InternalMessage` 是 `Message` 的一个子类型，但不能被序列化，而是抛出异常。这种设计存在几个问题：
- en: '`InternalMessage` is a subtype of `Message`, then we should be able to use
    `InternalMessage` wherever `Message` is expected without affecting the correctness
    of the program. By throwing an exception in the `serialize` method, we are breaking
    this principle.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InternalMessage` 是 `Message` 的一个子类型，那么我们应该能够在期望 `Message` 的任何地方使用 `InternalMessage`，而不会影响程序的正确性。通过在
    `serialize` 方法中抛出异常，我们打破了这一原则。'
- en: '`serialize` must handle exceptions, which might not have been necessary when
    dealing with other `Message` types. This introduces additional complexity and
    the potential for errors in the caller code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize` 必须处理异常，这在处理其他 `Message` 类型时可能并不必要。这引入了额外的复杂性，并在调用者代码中引入了错误的可能性。'
- en: '**Program crashes**: If the exception is not properly handled, it could lead
    to the program crashing, which is certainly not a desirable outcome.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序崩溃**：如果异常没有得到适当的处理，可能会导致程序崩溃，这当然不是期望的结果。'
- en: We could return an empty string instead of throwing an exception, but this still
    violates the LSP, as the `serialize` method is expected to return a serialized
    message, not an empty string. It also introduces ambiguity, as it’s not clear
    whether an empty string is the result of a successful serialization of a message
    with no data or an unsuccessful serialization of `InternalMessage`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以返回一个空字符串而不是抛出异常，但这仍然违反了 LSP，因为 `serialize` 方法预期返回一个序列化的消息，而不是一个空字符串。这也引入了歧义，因为不清楚空字符串是没有任何数据的消息成功序列化的结果，还是
    `InternalMessage` 序列化失败的结果。
- en: 'A better approach is to separate the concerns of a `Message` and a `SerializableMessage`,
    where only `SerializableMessage`s have a `serialize` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是分离 `Message` 和 `SerializableMessage` 的关注点，其中只有 `SerializableMessage`
    有 `serialize` 方法：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this corrected design, the base `Message` class does not include a `serialize`
    method, and a new `SerializableMessage` class has been introduced that includes
    this method. This way, only messages that can be serialized will inherit from
    `SerializableMessage`, and we adhere to the LSP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修正的设计中，基类 `Message` 不包括 `serialize` 方法，并引入了一个新的 `SerializableMessage` 类，其中包含这个方法。这样，只有可以序列化的消息才会从
    `SerializableMessage` 继承，并且我们遵循了 LSP。
- en: Adhering to the LSP allows for more flexible and maintainable code, as it enables
    the use of polymorphism and allows for substituting objects of a class with objects
    of its subclasses without affecting the overall behavior of the program. This
    way, the program can take advantage of the new functionality provided by the subclass
    while maintaining the same behavior as the superclass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循LSP（里氏替换原则）可以使代码更加灵活和易于维护，因为它允许使用多态，并允许用子类对象替换类对象，而不会影响程序的整体行为。这样，程序可以利用子类提供的新功能，同时保持与超类相同的行为。
- en: The Interface Segregation Principle
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The **Interface Segregation Principle** (**ISP**) is a principle in object-oriented
    programming that states that a class should only implement the interfaces it uses.
    In other words, it suggests that interfaces should be fine-grained and client-specific
    rather than having a single, large, and all-encompassing interface. The ISP is
    based on the idea that it is better to have many small interfaces that each define
    a specific set of methods rather than a single large interface that defines many
    methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（ISP）是面向对象编程中的一个原则，它指出一个类应该只实现它使用的接口。换句话说，它建议接口应该是细粒度和客户端特定的，而不是一个单一、庞大且包罗万象的接口。ISP基于这样一个观点：拥有许多小型接口，每个接口定义一组特定的方法，比拥有一个定义了许多方法的单一大型接口要好。'
- en: One of the key benefits of the ISP is that it promotes a more modular and flexible
    design, as it allows for the creation of interfaces that are tailored to the specific
    needs of a client. This way, it reduces the number of unnecessary methods that
    a client needs to implement, and also it reduces the risk of a client depending
    on methods that it does not need.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ISP（接口隔离原则）的一个关键好处是它促进了更模块化和灵活的设计，因为它允许创建针对客户端特定需求的接口。这样，它减少了客户端需要实现的不必要方法数量，同时也减少了客户端依赖于它不需要的方法的风险。
- en: An example of the ISP can be observed when creating our example messages from
    MessagePack or JSON files. Following the best practices, we would create an interface
    providing two methods, `from_message_pack` and `from_json`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当从MessagePack或JSON文件创建我们的示例消息时，可以观察到ISP（接口隔离原则）的一个例子。遵循最佳实践，我们会创建一个提供两个方法`from_message_pack`和`from_json`的接口。
- en: 'The current implementations need to implement both methods, but what if a particular
    class does not need to support both options? The smaller the interface, the better.
    The `MessageParser` interface will be split into two separate interfaces, each
    requiring the implementation of either JSON or MessagePack:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现需要实现这两个方法，但如果一个特定的类不需要支持这两种选项怎么办？接口越小越好。`MessageParser`接口将被拆分为两个独立的接口，每个接口都需要实现JSON或MessagePack之一：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This design allows for objects derived from `JsonMessageParser` and `MessagePackMessageParser`
    to understand how to construct themselves from JSON and MessagePack, respectively,
    while preserving the independence and functionality of each function. The system
    remains flexible as new smaller objects can still be composed to achieve the desired
    functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计允许从`JsonMessageParser`和`MessagePackMessageParser`派生的对象理解如何分别从JSON和MessagePack构建自己，同时保持每个函数的独立性和功能性。系统保持灵活性，因为新的更小的对象仍然可以组合起来以实现所需的功能。
- en: Adhering to the ISP makes the code more maintainable and less prone to errors,
    as it reduces the number of unnecessary methods that a client needs to implement,
    and it also reduces the risk of a client depending on methods that it does not
    need.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循ISP可以使代码更易于维护且更少出错，因为它减少了客户端需要实现的不必要方法数量，同时也减少了客户端依赖于它不需要的方法的风险。
- en: The Dependency inversion principle
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The Dependency inversion principle is based on the idea that it is better to
    depend on abstractions rather than on concrete implementations, as it allows for
    greater flexibility and maintainability. It allows the decoupling of high-level
    modules from low-level modules, making them more independent and less prone to
    changes in the low-level modules. This way, it makes it easy to change low-level
    implementations without affecting high-level modules and vice versa.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则基于这样一个观点：依赖抽象比依赖具体实现要好，因为它提供了更大的灵活性和可维护性。它允许将高级模块与低级模块解耦，使它们更加独立，并减少对低级模块变化的敏感性。这样，它使得在不影响高级模块的情况下轻松更改低级实现，反之亦然。
- en: 'The DIP can be illustrated for our messaging system if we try to use all the
    components via another class. Let us assume that there is a class responsible
    for message routing. In order to build such a class, we are going to use `MessageSender`
    as a communication module, `Message` based classes, and `MessageSaver`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试通过另一个类使用所有组件，可以说明DIP（依赖倒置原则）在我们的消息系统中是如何体现的。让我们假设有一个负责消息路由的类。为了构建这样一个类，我们将使用`MessageSender`作为通信模块，`Message`基于的类，以及`MessageSaver`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The new class provides only one `route` method, which is called once a new message
    is available. The router handles the message to the `MessageHandler` class if
    the message’s sender ID equals the router’s. Otherwise, the router forwards the
    message to the corresponding receiver. In case the delivery of the message fails
    and the communication layer throws an exception, the router saves the message
    via `MessageSaver`. Those messages will be delivered some other time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类只提供了一个`route`方法，该方法在新的消息可用时被调用一次。如果消息的发送者ID与路由器相同，路由器将处理消息到`MessageHandler`类。否则，路由器将消息转发到相应的接收者。如果消息传递失败且通信层抛出异常，路由器将通过`MessageSaver`保存消息。这些消息将在其他时间传递。
- en: 'The only problem is that if any dependency needs to be changed, the router’s
    code has to be updated accordingly. For example, if the application needs to support
    several types of senders (TCP and UDP), the message saver (filesystem versus remote)
    or message handler’s logic changes. In order to make `MessageRouter` agnostic
    to such changes, we can rewrite it using the DIP principle:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，如果任何依赖项需要更改，路由器的代码必须相应更新。例如，如果应用程序需要支持多种类型的发送者（TCP和UDP）、消息保存器（文件系统与远程）或消息处理逻辑发生变化。为了使`MessageRouter`对这种变化无感知，我们可以使用DIP原则重写它：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this revised version of the code, `MessageRouter` is now decoupled from specific
    implementations of the message handling, sending, and saving logic. Instead, it
    relies on abstractions represented by `BaseMessageHandler`, `BaseMessageSender`,
    and `BaseMessageSaver`. This way, any class that derives from these base classes
    can be used with `MessageRouter`, which makes the code more flexible and easier
    to extend in the future. The router is not concerned with the specifics of how
    messages are handled, sent, or saved – it only needs to know that these operations
    can be performed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码的修订版本中，`MessageRouter`现在与消息处理、发送和保存逻辑的具体实现解耦。相反，它依赖于由`BaseMessageHandler`、`BaseMessageSender`和`BaseMessageSaver`表示的抽象。这样，任何从这些基类派生的类都可以与`MessageRouter`一起使用，这使得代码更加灵活，并便于未来扩展。路由器不关心消息处理、发送或保存的具体细节——它只需要知道这些操作可以执行。
- en: Adhering to the DIP makes code more maintainable and less prone to errors. It
    decouples high-level modules from low-level modules, making them more independent
    and less prone to changes in low-level modules. It also allows for greater flexibility,
    making it easy to change low-level implementations without affecting high-level
    modules and vice versa. Later in this book, dependency inversion will help us
    mock parts of the system while developing unit tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循DIP（依赖倒置原则）可以使代码更易于维护且更不易出错。它将高级模块与低级模块解耦，使它们更加独立，并减少对低级模块变化的敏感性。它还提供了更大的灵活性，使得在不影响高级模块的情况下轻松更改低级实现，反之亦然。本书后面将介绍依赖倒置如何帮助我们开发单元测试时模拟系统的一部分。
- en: The KISS principle
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS原则
- en: The KISS principle, which stands for “Keep It Simple, Stupid,” is a design philosophy
    that emphasizes the importance of keeping things simple and straightforward. This
    principle is particularly relevant in the world of programming, where complex
    code can lead to bugs, confusion, and slow development time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: KISS原则，即“保持简单，傻瓜”，是一种强调保持事物简单直接的设计哲学。这一原则在编程领域尤为重要，因为复杂的代码可能导致错误、困惑和缓慢的开发速度。
- en: 'Here are some examples of how the KISS principle can be applied in C++:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些如何在C++中应用KISS原则的例子：
- en: '`for` loop instead of a complex algorithm can often be just as effective and
    much easier to understand.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环代替复杂的算法往往同样有效，而且更容易理解。
- en: '**Keep Functions Small**: Functions in C++ should be small, focused, and easy
    to understand. Complex functions can quickly become difficult to maintain and
    debug, so try to keep functions as simple and concise as possible. A good rule
    of thumb is to aim for functions that are no longer than 30-50 lines of code.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持函数简洁**：C++中的函数应该小巧、专注且易于理解。复杂的函数很快就会变得难以维护和调试，因此尽量保持函数尽可能简单和简洁。一个很好的经验法则是使函数的代码行数不超过30-50行。'
- en: '**Use Clear and Concise Variable Names**: In C++, variable names play a crucial
    role in making code readable and understandable. Avoid using abbreviations and
    instead opt for clear and concise names that accurately describe the purpose of
    the variable.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用清晰简洁的变量名**：在C++中，变量名在使代码可读和理解方面起着至关重要的作用。避免使用缩写，而应选择清晰简洁的名称，准确描述变量的用途。'
- en: '**Avoid Deep Nesting**: Nested loops and conditional statements can make code
    hard to read and follow. Try to keep the nesting levels as shallow as possible,
    and consider breaking up complex functions into smaller, simpler functions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免深层嵌套**：嵌套循环和条件语句会使代码难以阅读和遵循。尽量保持嵌套级别尽可能浅，并考虑将复杂的函数分解成更小、更简单的函数。'
- en: '**Write Simple, Readable Code**: Above all, aim to write code that is easy
    to understand and follow. This means using clear and concise language and avoiding
    complicated expressions and structures. Code that is simple and easy to follow
    is much more likely to be maintainable and bug-free.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写简单、易读的代码**：首先，目标是编写易于理解和遵循的代码。这意味着使用清晰简洁的语言，并避免复杂的表达式和结构。简单且易于遵循的代码更有可能易于维护且无错误。'
- en: '**Avoid Complex Inheritance Hierarchy**: Complex inheritance hierarchies can
    make code more difficult to understand, debug, and maintain. The more complex
    the inheritance structure, the harder it becomes to keep track of the relationships
    between classes and determine how changes will affect the rest of the code.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免复杂的继承层次结构**：复杂的继承层次结构会使代码更难以理解、调试和维护。继承结构越复杂，跟踪类之间的关系以及确定更改如何影响其余代码就越困难。'
- en: In conclusion, the KISS principle is a simple and straightforward design philosophy
    that can help developers write clear, concise, and maintainable code. By keeping
    things simple, developers can avoid bugs and confusion and speed up development
    time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，KISS原则是一种简单直接的设计理念，可以帮助开发者编写清晰、简洁且易于维护的代码。通过保持简单，开发者可以避免错误和混淆，并加快开发速度。
- en: The KISS and SOLID Principles together
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS原则和SOLID原则都是软件开发中的重要设计理念，但它们有时可能会相互矛盾。
- en: The SOLID principles and the KISS principle are both important design philosophies
    in software development, but they can sometimes contradict each other.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则和KISS原则都是软件开发中的重要设计理念，但它们有时可能会相互矛盾。
- en: The SOLID principles are a set of five principles that guide the design of software,
    aimed at making it more maintainable, scalable, and flexible. They focus on creating
    a clean, modular architecture that follows good object-oriented design practices.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一套指导软件开发设计的五个原则，旨在使软件更具可维护性、可扩展性和灵活性。它们侧重于创建一个干净、模块化的架构，遵循良好的面向对象设计实践。
- en: The KISS principle, on the other hand, is all about keeping things simple. It
    advocates for straightforward, simple solutions, avoiding complex algorithms and
    structures that can make code hard to understand and maintain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，KISS原则的核心是保持简单。它提倡简单直接的方法，避免复杂的算法和结构，这些可能会使代码难以理解和维护。
- en: While both SOLID and KISS aim to improve software quality, they can sometimes
    be at odds. For example, following the SOLID principles may result in code that
    is more complex and harder to understand to achieve greater modularity and maintainability.
    Similarly, the KISS principle may result in less flexible and scalable code to
    keep it simple and straightforward.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOLID原则和KISS原则都旨在提高软件质量，但它们有时可能会产生冲突。例如，遵循SOLID原则可能会导致代码更加复杂且难以理解，以实现更大的模块化和可维护性。同样，KISS原则可能会导致代码不够灵活和可扩展，以保持其简单和直接。
- en: In practice, developers often have to strike a balance between the SOLID principles
    and the KISS principle. On the one hand, they want to write code that is maintainable,
    scalable, and flexible. On the other hand, they want to write code that is simple
    and easy to understand. Finding this balance requires careful consideration of
    trade-offs and an understanding of when each approach is most appropriate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，开发者通常需要在SOLID原则和KISS原则之间取得平衡。一方面，他们希望编写可维护、可扩展和灵活的代码。另一方面，他们希望编写简单且易于理解的代码。找到这种平衡需要仔细考虑权衡，并理解何时采用每种方法最为合适。
- en: 'When I have to choose between the SOLID and KISS approaches, I think about
    something my boss, Amir Taya, said, “When building a Ferrari, you need to start
    from a scooter.” This phrase is an exaggerated example of KISS: if you do not
    know how to build a feature, make the simplest working version (KISS), re-iterate,
    and extend the solution using SOLID principles if needed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我必须在SOLID方法和KISS方法之间做出选择时，我会想起我的老板Amir Taya说过的话：“当你建造法拉利时，你需要从一辆踏板车开始。”这句话是KISS的一个夸张例子：如果你不知道如何构建一个功能，就创建一个最简单的可工作版本（KISS），然后迭代，并在需要时使用SOLID原则扩展解决方案。
- en: Side effects and immutability
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用和不可变性
- en: Side effects and immutability are two important concepts in programming that
    have a significant impact on the quality and maintainability of code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用和不可变性是编程中的两个重要概念，对代码的质量和可维护性有重大影响。
- en: Side effects refer to changes that occur in the state of the program as a result
    of executing a particular function or piece of code. Side effects can be explicit,
    such as writing data to a file or updating a variable, or implicit, such as modifying
    the global state or causing unexpected behavior in other parts of the code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是指由于执行特定函数或代码片段而导致程序状态发生变化。副作用可以是显式的，例如将数据写入文件或更新变量，也可以是隐式的，例如修改全局状态或在代码的其他部分引起意外的行为。
- en: Immutability, on the other hand, refers to the property of a variable or data
    structure that cannot be modified after it has been created. In functional programming,
    immutability is achieved by making data structures and variables constant and
    avoiding side effects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不可变性是指变量或数据结构在创建后不能被修改的特性。在函数式编程中，通过使数据结构和变量成为常量并避免副作用来实现不可变性。
- en: The importance of avoiding side effects and using immutable variables lies in
    the fact that they make code easier to understand, debug, and maintain. When code
    has few side effects, it is easier to reason about what it does and what it does
    not do. This makes finding and fixing bugs and making changes to the code easier
    without affecting other parts of the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 避免副作用和使用不可变变量的重要性在于，它们使代码更容易理解、调试和维护。当代码副作用较少时，更容易推理出它做什么以及它不做什么。这使得找到和修复错误以及修改代码更容易，而不会影响系统的其他部分。
- en: In contrast, code with many side effects is harder to understand, as the state
    of the program can change in unexpected ways. This makes it more difficult to
    debug and maintain and can lead to bugs and unexpected behavior.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，具有许多副作用的代码更难以理解，因为程序的状态可能会以意想不到的方式发生变化。这使得调试和维护更加困难，并可能导致错误和意外行为。
- en: Functional programming languages have long emphasized the use of immutability
    and the avoidance of side effects, but it is now possible to write code with these
    properties using C++. The easiest way to achieve it is to follow the **C++ Core
    Guidelines for Constants** **and Immutability**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言长期以来一直强调使用不可变性和避免副作用，但现在使用C++编写具有这些特性的代码也是可能的。实现它的最简单方法是遵循**C++核心指南中的常量和不可变性**。
- en: Con.1 – by default, make objects immutable
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Con.1 – 默认情况下，使对象不可变
- en: 'You can declare a built-in data type or an instance of a user-defined data
    type as constant, resulting in the same effect. Attempting to modify it will result
    in a compiler error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将内置数据类型或用户定义数据类型的实例声明为常量，从而产生相同的效果。尝试修改它将导致编译器错误：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The same applies to loops:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于循环：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach allows the prevention of hard-to-notice changes of value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以防止难以察觉的值的变化。
- en: 'Probably, the only exception is function parameters passed by value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可能唯一的例外是按值传递的函数参数：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Such parameters are rarely passed as `const` and rarely mutated. In order to
    avoid confusion, it is recommended not to enforce this rule in such cases.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的参数很少作为`const`传递，也很少被修改。为了避免混淆，建议在这种情况下不要强制执行此规则。
- en: Con.2 – by default, make member functions const
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Con.2 – 默认情况下，使成员函数为const
- en: 'A member function (method) shall be marked as `const` unless it changes the
    observable state of an object. The reason behind this is to give a more precise
    statement of design intent, better readability, maintainability, more errors caught
    by the compiler, and theoretically more optimization opportunities:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数（方法）应当被标记为`const`，除非它改变了对象的可观察状态。这样做的原因是为了给出更精确的设计意图声明，更好的可读性，更好的可维护性，编译器能捕获更多错误，以及理论上更多的优化机会：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two types of constness: **physical** and **logical**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的const属性：**物理**和**逻辑**：
- en: '`const` and cannot be changed.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`且不能被更改。'
- en: '`const` but can be changed.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`但可以被更改。'
- en: 'Logical constness can be achieved with the `mutable` keyword. In general, it
    is a rare use case. The only good example I can think of is storing in an internal
    cache or using a mutex:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑常量属性可以通过`mutable`关键字实现。通常情况下，这是一个很少用的用例。我能想到的唯一好例子是将数据存储在内部缓存中或使用互斥锁：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we need to change the `mutex` variable to lock it, but this
    does not affect the logical constness of the object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要更改`mutex`变量来锁定它，但这不会影响对象的逻辑常量属性。
- en: 'Please be aware that there exist legacy codes/libraries that provide functions
    that declare `T*`, despite not making any changes to the `T`. This presents an
    issue for individuals who are trying to mark all logically constant methods as
    `const`. In order to enforce constness, you can do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存在一些遗留代码/库提供了声明`T*`的函数，尽管它们没有对`T`进行任何更改。这给试图将所有逻辑上常量方法标记为`const`的个人带来了问题。为了强制const属性，你可以执行以下操作：
- en: Update the library/code to be const-correct, which is the preferred solution.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新库/代码以使其符合const-correct，这是首选解决方案。
- en: Provide a wrapper function casting away the constness.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个包装函数来去除const属性。
- en: Example
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this solution is a patch that can be used only when the declaration
    of `read_data` cannot be modified.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个解决方案是一个补丁，只能在无法修改`read_data`的声明时使用。
- en: Con.3 – by default, pass pointers and references to const
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Con.3 – 默认情况下，传递指针和引用到const
- en: This one is easy; it is far easier to reason about programs when called functions
    do not modify state.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单；当被调用的函数不修改状态时，推理程序更容易。
- en: 'Let us look at the two following functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个函数：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Does the `foo` function modify the data the `p` pointer points to? We cannot
    answer by looking at the declaration, so we assume it does by default. However,
    the `bar` function states explicitly that the content of `p` will not be changed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`函数是否修改了`p`指针指向的数据？仅通过查看声明我们无法回答，所以我们默认假设它修改了。然而，`bar`函数明确指出`p`的内容将不会被更改。'
- en: Con.4 – use const to define objects with values that do not change after construction
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Con.4 – 使用const定义在构造后值不改变的对象
- en: 'This rule is very similar to the first one, enforcing the constness of objects
    that are not expected to be changed in the future. It is often helpful with classes
    such as `Config` that are created at the beginning of the application and not
    changed during its lifetime:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则与第一条非常相似，强制对象在未来的预期中不被更改的const属性。这对于像`Config`这样的类非常有帮助，这些类在应用程序开始时创建，并在其生命周期内不发生变化：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Con.5 – use constexpr for values that can be computed at compile time
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Con.5 – 对于可以在编译时计算出的值使用constexpr
- en: Declaring variables as `constexpr` is preferred over `const` if the value is
    computed at compile time. It provides such benefits as better performance, better
    compile-time checking, guaranteed compile-time evaluation, and no possibility
    of race conditions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值在编译时计算，将变量声明为`constexpr`比声明为`const`更可取。它提供了更好的性能、更好的编译时检查、保证的编译时评估以及没有竞争条件发生的可能性。
- en: Constness and data races
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量属性和数据竞争
- en: Data races occur when multiple threads access a shared variable simultaneously,
    and at least one tries to modify it. There are synchronization primitives such
    as mutexes, critical sections, spinlocks, and semaphores, allowing the prevention
    of data races. The problem with these primitives is that they either do expensive
    system calls or overuse the CPU, which makes the code less efficient. However,
    if none of the threads modifies the variable, there is no place for data races.
    We learned that `constexpr` is thread-safe (does not need synchronization) because
    it is defined at compile time. What about `const`? It can be thread-safe under
    the below conditions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时访问一个共享变量，并且至少有一个尝试修改它时，就会发生数据竞争。有一些同步原语，如互斥锁、临界区、自旋锁和信号量，可以防止数据竞争。这些原语的问题在于它们要么执行昂贵的系统调用，要么过度使用
    CPU，这使代码效率降低。然而，如果没有线程修改变量，就没有数据竞争的地方。我们了解到 `constexpr` 是线程安全的（不需要同步），因为它是在编译时定义的。那么
    `const` 呢？在以下条件下它可以线程安全。
- en: 'The variable has been `const` since its creation. If a thread has direct or
    indirect (via a pointer or reference) non-const access to the variable, all the
    readers need to use mutexes. The following code snippet illustrates constant and
    non-constant access from multiple threads:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变量自创建以来一直是 `const` 的。如果一个线程直接或间接（通过指针或引用）对变量有非 `const` 访问权限，所有读取者都需要使用互斥锁。以下代码片段展示了从多个线程对常量和非常量访问的示例：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `a` function, the `value` variable is owned as non-constant by both
    the main thread and `t`, which makes the code potentially not thread-safe (if
    a developer decides to change the `value` later in the main thread). In the `b`,
    the main thread has “write” access to `value` while `t` receives it via a `const`
    reference, but still, it is not thread-safe. The `c` function is an example of
    very bad code: the `value` is created as a constant in the main thread and passed
    as a `const` reference but then the constness is cast away, which makes this function
    not thread-safe. Only the `d` function is thread-safe because neither the main
    thread nor `t` can modify the variable.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `a` 函数中，`value` 变量由主线程和 `t` 都以非 `const` 的方式拥有，这使得代码可能不是线程安全的（如果开发者在主线程中稍后决定更改
    `value`）。在 `b` 中，主线程对 `value` 有“写入”访问权限，而 `t` 通过一个 `const` 引用接收它，但仍然不是线程安全的。`c`
    函数是糟糕代码的一个例子：`value` 在主线程中被创建为一个常量，并通过 `const` 引用传递，但随后常量性被取消，这使得这个函数不是线程安全的。只有
    `d` 函数是线程安全的，因为主线程和 `t` 都不能修改这个变量。
- en: 'The data type and all sub-types of the variable are either physically constant
    or their logical constness implementation is thread-safe. For example, in the
    following example, the `Point` struct is physically constant because its `x` and
    `y` field members are primitive integers, and both threads have only `const` access
    to it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的数据类型及其所有子类型要么是物理常量，要么它们的逻辑常量实现是线程安全的。例如，在以下示例中，`Point` 结构体是物理常量，因为它的 `x`
    和 `y` 字段成员是原始整数，并且两个线程都只有对它的 `const` 访问权限：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `DataReader` class that we saw earlier is logically constant because it
    has a mutable variable, `mutex`, but this implementation is also thread-safe (due
    to the lock):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的 `DataReader` 类在逻辑上是常量的，因为它有一个可变的变量 `mutex`，但这个实现也是线程安全的（由于锁的存在）：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, let us look into the following case. The `RequestProcessor` class
    processes some heavy requests and caches the results in an internal variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看以下情况。`RequestProcessor` 类处理一些重量级请求并将结果缓存到一个内部变量中：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This class is logically safe, but the `cache_` variable is changed in a non-thread-safe
    way, which makes the class non-thread-safe even when declared as `const`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在逻辑上是安全的，但 `cache_` 变量以非线程安全的方式更改，这使得即使在声明为 `const` 的情况下，这个类也不是线程安全的。
- en: Note that when working with STL containers, it is essential to remember that,
    despite current implementations tending to be thread-safe (physically and logically),
    the standard provides very specific thread-safety guarantees.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当与 STL 容器一起工作时，必须记住，尽管当前实现倾向于线程安全（在物理和逻辑上），但标准提供了非常具体的线程安全保证。
- en: All functions in a container can be called simultaneously by various threads
    on different containers. Broadly, functions from the C++ standard library don’t
    read objects accessible to other threads unless they are reachable through the
    function arguments, which includes the `this` pointer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的所有函数都可以被不同容器上的各种线程同时调用。从广义上讲，除非通过函数参数可访问，否则 C++ 标准库中的函数不会读取其他线程可访问的对象，这包括
    `this` 指针。
- en: All `const` member functions are thread-safe, meaning they can be invoked simultaneously
    by various threads on the same container. Furthermore, the `begin()`, `end()`,
    `rbegin()`, `rend()`, `front()`, `back()`, `data()`, `find()`, `lower_bound()`,
    `upper_bound()`, `equal_range()`, `at()`, and `operator[]` (except in associative
    containers) member functions also behave as `const` with regard to thread safety.
    In other words, they can also be invoked by various threads on the same container.
    Broadly, C++ standard library functions won’t modify objects unless those objects
    are reachable, directly or indirectly, via the function’s non-const arguments,
    which includes the `this` pointer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`const`成员函数都是线程安全的，这意味着它们可以被多个线程在同一个容器上同时调用。此外，`begin()`、`end()`、`rbegin()`、`rend()`、`front()`、`back()`、`data()`、`find()`、`lower_bound()`、`upper_bound()`、`equal_range()`、`at()`和`operator[]`（在关联容器中除外）成员函数在线程安全性方面也表现为`const`。换句话说，它们也可以被多个线程在同一个容器上调用。广泛地说，C++
    标准库函数不会修改对象，除非这些对象可以通过函数的非`const`参数直接或间接地访问，这包括`this`指针。
- en: Different elements in the same container can be altered simultaneously by different
    threads, with the exception of `std::vector<bool>` elements. For example, a `std::vector`
    of `std::future` objects can receive values from multiple threads at once.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同一容器中的不同元素可以由不同的线程同时修改，但`std::vector<bool>`元素除外。例如，一个`std::vector`的`std::future`对象可以一次从多个线程接收值。
- en: Operations on iterators, such as incrementing an iterator, read the underlying
    container but don’t modify it. These operations can be performed concurrently
    with operations on other iterators of the same container, with the `const` member
    functions, or with reads from the elements. However, operations that invalidate
    any iterators modify the container and must not be performed concurrently with
    any operations on existing iterators, even those that are not invalidated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器上的操作，如递增迭代器，读取底层容器但不修改它。这些操作可以与其他迭代器的操作、`const`成员函数或对元素的读取同时进行。然而，会使任何迭代器失效的操作会修改容器，并且不能与任何现有迭代器的操作同时进行，即使是那些未被失效的迭代器。
- en: Elements of the same container can be altered concurrently with those member
    functions that don’t access these elements. Broadly, C++ standard library functions
    won’t read objects indirectly accessible through their arguments (including other
    elements of a container) except when required by its specification.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同一容器的元素可以与那些不访问这些元素的成员函数同时修改。广泛地说，C++ 标准库函数不会通过其参数间接读取对象（包括容器的其他元素），除非其规范要求。
- en: Lastly, operations on containers (as well as algorithms or other C++ standard
    library functions) can be internally parallelized as long as the user-visible
    results remain unaffected. For example, `std::transform` can be parallelized,
    but `std::for_each` cannot, as it is specified to visit each element of a sequence
    in order.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只要用户可见的结果不受影响，容器上的操作（以及算法或其他 C++ 标准库函数）可以在内部并行化。例如，`std::transform`可以并行化，但`std::for_each`不能，因为它指定了按顺序访问序列中的每个元素。
- en: The idea of having a single mutable reference to an object became one of the
    pillars of the Rust programming language. This rule is in place to prevent data
    races, which occur when multiple threads access the same mutable data concurrently,
    resulting in unpredictable behavior and potential crashes. By allowing only one
    mutable reference to an object at a time, Rust ensures that concurrent access
    to the same data is properly synchronized and avoids data races.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的单个可变引用作为Rust编程语言的一个支柱的想法。此规则旨在防止数据竞争，当多个线程同时访问相同的可变数据时，就会发生数据竞争，导致不可预测的行为和潜在的崩溃。通过一次只允许对对象的一个可变引用，Rust确保了对同一数据的并发访问得到适当的同步，并避免了数据竞争。
- en: In addition, this rule helps prevent mutable aliasing, which occurs when multiple
    mutable references to the same data exist simultaneously. Mutable aliasing can
    lead to subtle bugs and make code difficult to reason about, especially in large
    and complex code bases. By allowing only one mutable reference to an object, Rust
    avoids mutable aliasing and helps ensure that code is correct and easy to understand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此规则有助于防止可变别名，当存在对同一数据的多个可变引用同时存在时，就会发生可变别名。可变别名可能导致微妙的错误，并使代码难以推理，尤其是在大型和复杂的代码库中。通过只允许对对象的一个可变引用，Rust
    避免了可变别名，并有助于确保代码的正确性和易于理解。
- en: However, it’s worth noting that Rust also allows multiple immutable references
    to an object, which can be useful in scenarios where concurrent access is necessary
    but mutations are not. By allowing multiple immutable references, Rust can provide
    better performance and concurrency while still maintaining safety and correctness.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，Rust也允许对对象有多个不可变引用，这在需要并发访问但不需要修改的场景中可能很有用。通过允许多个不可变引用，Rust可以在保持安全性和正确性的同时提供更好的性能和并发性。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the SOLID principles, the KISS principle, constness,
    and immutability. Let’s see what you learned!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了SOLID原则、KISS原则、const属性和不可变性。让我们看看你学到了什么！
- en: 'SOLID principles: SOLID is a set of five principles that help us create code
    that’s easy to maintain, scalable, and flexible. By understanding these principles,
    you’re on your way to designing code that’s a dream to work with!'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则：SOLID是一组五个原则，帮助我们创建易于维护、可扩展和灵活的代码。通过理解这些原则，你将走向设计出易于工作的代码的梦想之路！
- en: 'The KISS principle: The KISS principle is all about keeping things simple.
    By following this principle, you’ll avoid overcomplicating your code, making it
    easier to maintain and debug.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS原则：KISS原则的核心是保持简单。通过遵循这一原则，你可以避免过度复杂化你的代码，使其更容易维护和调试。
- en: 'Constness: Constness is a property in C++ that makes objects read-only. By
    declaring objects as `const`, you can ensure that their values won’t be accidentally
    changed, making your code more stable and predictable.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Const属性：Const属性是C++中的一个特性，它使对象变为只读。通过将对象声明为`const`，你可以确保它们的值不会意外改变，从而使你的代码更加稳定和可预测。
- en: 'Immutability: Immutability is all about making sure objects can’t be changed
    after their creation. By making objects immutable, you can avoid sneaky bugs and
    make your code more predictable.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性：不可变性确保对象在创建后不能被改变。通过使对象不可变，你可以避免隐蔽的bug，并使你的代码更具可预测性。
- en: With these design principles under your belt, you’re on your way to writing
    code that’s both robust and reliable. Happy coding!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些设计原则之后，你将走向编写既健壮又可靠的代码的道路。祝您编码愉快！
- en: In the next chapter, we will try to understand what causes bad code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试理解导致糟糕代码的原因。
