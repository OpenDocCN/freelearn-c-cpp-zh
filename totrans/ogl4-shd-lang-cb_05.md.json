["```cpp\nGLuint Texture::loadTexture( const std::string & fName ) {\n  int width, height;\n  unsigned char * data = Texture::loadPixels(fName, width, height);\n  GLuint tex = 0;\n  if( data != nullptr ) {\n    glGenTextures(1, &tex);\n    glBindTexture(GL_TEXTURE_2D, tex);\n    glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, width, height);\n    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, \n              width, height, GL_RGBA, GL_UNSIGNED_BYTE, data);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, \n    GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, \n    GL_NEAREST);\n\n    Texture::deletePixels(data);\n  }\n  return tex;\n}\n```", "```cpp\nGLuint tid = Texture::loadTexture(\"brick1.png\");\n\nglActiveTexture(GL_TEXTURE0); \nglBindTexture(GL_TEXTURE_2D, tid);\n\n// Set the Tex1 sampler uniform to refer to texture unit 0 \nint loc = glGetUniformLocation(programHandle, \"Tex1\"); \nglUniform1i(loc, 0); \n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \nlayout (location = 2) in vec2 VertexTexCoord; \n\nout vec3 Position; \nout vec3 Normal; \nout vec2 TexCoord; \n\n// Other uniforms...\n\nvoid main() \n{ \n  TexCoord = VertexTexCoord; \n  // Assign other output variables here... \n}\n```", "```cpp\nin vec3 Position; \nin vec3 Normal; \nin vec2 TexCoord; \n\n// The texture sampler object\nuniform sampler2D Tex1; \n\n// Light/material uniforms...\n\nvoid blinnPhong( vec3 pos, vec3 n ) { \n  vec3 texColor = texture(Tex1, TexCoord).rgb;\n  vec3 ambient = Light.La * texColor;\n  // ...\n  vec3 diffuse = texColor * sDotN;\n  // Compute spec...\n  return ambient + Light.L * (diffuse + spec);   \n} \nvoid main() { \n  FragColor = vec4( blinnPhong(Position, normalize(Normal) ), 1 ); \n} \n```", "```cpp\nint loc = glGetUniformLocation(programHandle, \"Tex1\"); \nglUniform1i(loc, 0);\n```", "```cpp\nlayout (binding=0) uniform sampler2D Tex1;\n```", "```cpp\n GLuint brick = Texture::loadTexture(\"brick1.jpg\");\n GLuint moss = Texture::loadTexture(\"moss.png\");\n\n// Load brick texture file into channel 0\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, brick);\n// Load moss texture file into channel 1\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, moss); \n```", "```cpp\nlayout(binding=0) uniform sampler2D BrickTex; \nlayout(binding=1) uniform sampler2D MossTex;\n```", "```cpp\nvec4 brickTexColor = texture( BrickTex, TexCoord );\nvec4 mossTexColor = texture( MossTex, TexCoord );\nvec3 col = mix(brickTexColor.rgb, mossTexColor.rgb, mossTexColor.a);\nvec3 ambient = Light.La * col;\n// ...\nvec3 diffuse = col * sDotN;\n```", "```cpp\nglActiveTexture(GL_TEXTURE0); \n```", "```cpp\nglActiveTexture(GL_TEXTURE1); \n```", "```cpp\nglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA ); \n```", "```cpp\nlayout(binding=0) uniform sampler2D BaseTex; \nlayout(binding=1) uniform sampler2D AlphaTex;\n```", "```cpp\nvoid main() {\n    vec4 alphaMap = texture( AlphaTex, TexCoord );\n\n    if(alphaMap.a < 0.15 )\n        discard;\n    else {\n        if( gl_FrontFacing ) {\n            FragColor = vec4( \n            blinnPhong(Position,normalize(Normal)), 1.0 );\n        } else {\n            FragColor = vec4( blinnPhong(Position,normalize(-\n            Normal)), 1.0 );\n        }\n    }\n}\n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \nlayout (location = 2) in vec2 VertexTexCoord; \nlayout (location = 3) in vec4 VertexTangent; \n\nout vec3 LightDir; \nout vec2 TexCoord; \nout vec3 ViewDir; \n\n// Other uniform variables...\n\nvoid main() { \n  // Transform normal and tangent to eye space \n  vec3 norm = normalize(NormalMatrix * VertexNormal); \n  vec3 tang = normalize(NormalMatrix * VertexTangent.xyz); \n  // Compute the binormal \n  vec3 binormal = normalize( cross( norm, tang ) ) * \n  VertexTangent.w; \n  // Matrix for transformation to tangent space \n  mat3 toObjectLocal = mat3( \n      tang.x, binormal.x, norm.x, \n      tang.y, binormal.y, norm.y, \n      tang.z, binormal.z, norm.z ) ; \n  // Get the position in eye coordinates \n  vec3 pos = vec3( ModelViewMatrix *  \n                     vec4(VertexPosition,1.0) ); \n\n  // Transform light dir. and view dir. to tangent space \n  LightDir = toObjectLocal * (Light.Position.xyz - pos); \n  ViewDir = toObjectLocal * normalize(-pos); \n\n  // Pass along the texture coordinate \n  TexCoord = VertexTexCoord; \n\n  gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 LightDir; \nin vec2 TexCoord; \nin vec3 ViewDir; \n\nlayout(binding=0) uniform sampler2D ColorTex; \nlayout(binding=1) uniform sampler2D NormalMapTex; \n\n// Other uniform variables...\n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 blinnPhong( vec3 n ) {\n  // Similar to previous examples, except \n  // using normalize(LightDir) and normalize(ViewDir)...\n}\n\nvoid main() { \n    // Lookup the normal from the normal map\n    vec3 norm = texture(NormalMapTex, TexCoord).xyz;\n    norm = 2.0 * norm - 1.0;\n    FragColor = vec4( blinnPhong(norm), 1.0 );\n}\n```", "```cpp\nin vec3 LightDir;  // Tangent space\nin vec2 TexCoord;\nin vec3 ViewDir;  // Tangent space\n\nlayout(binding=0) uniform sampler2D ColorTex;\nlayout(binding=1) uniform sampler2D NormalMapTex;\nlayout(binding=2) uniform sampler2D HeightMapTex;\n\n// Light and material uniforms \n\nlayout( location = 0 ) out vec4 FragColor;\n\nvec3 blinnPhong( ) {\n  vec3 v = normalize(ViewDir);\n  vec3 s = normalize(LightDir);\n\n  const float bumpFactor = 0.015; \n  float height = 1 - texture(HeightMapTex, TexCoord).r;\n  vec2 delta = v.xy * height * bumpFactor / v.z;\n  vec2 tc = TexCoord.xy - delta;\n\n  vec3 n = texture(NormalMapTex, tc).xyz;\n  n.xy = 2.0 * n.xy - 1.0;\n  n = normalize(n);\n\n  float sDotN = max( dot(s,n), 0.0 );\n\n  vec3 texColor = texture(ColorTex, tc).rgb;\n  vec3 ambient = Light.La * texColor;\n  vec3 diffuse = texColor * sDotN;\n  vec3 spec = vec3(0.0);\n  if( sDotN > 0.0 ) { \n    vec3 h = normalize( v + s );\n    spec = Material.Ks *\n            pow( max( dot(h,n), 0.0 ), Material.Shininess );\n  }\n  return ambient + Light.L * (diffuse + spec);\n}\n\n```", "```cpp\nin vec3 LightDir;  // Tangent space\nin vec2 TexCoord;\nin vec3 ViewDir;   // Tangent space\n\nlayout(binding=0) uniform sampler2D ColorTex;\nlayout(binding=1) uniform sampler2D NormalMapTex;\nlayout(binding=2) uniform sampler2D HeightMapTex;\n\n// Material and light uniforms...\n\nlayout( location = 0 ) out vec4 FragColor;\n\nconst float bumpScale = 0.03;\n\nvec2 findOffset(vec3 v, out float height) {\n  const int nSteps = int(mix(60, 10, abs(v.z)));\n  float htStep = 1.0 / nSteps;\n  vec2 deltaT = (v.xy * bumpScale) / (nSteps * v.z);\n  float ht = 1.0;\n  vec2 tc = TexCoord.xy;\n  height = texture(HeightMapTex, tc).r;\n  while( height < ht ) {\n    ht -= htStep;\n    tc -= deltaT;\n    height = texture(HeightMapTex, tc).r;\n  }\n  return tc;\n}\n\nbool isOccluded(float height, vec2 tc, vec3 s) {\n  // Shadow ray cast\n  const int nShadowSteps = int(mix(60,10,s.z));\n  float htStep = 1.0 / nShadowSteps;\n  vec2 deltaT = (s.xy * bumpScale) / ( nShadowSteps * s.z );\n  float ht = height + htStep * 0.5;\n  while( height < ht && ht < 1.0 ) {\n    ht += htStep;\n    tc += deltaT;\n    height = texture(HeightMapTex, tc).r;\n  }\n\n  return ht < 1.0;\n}\n\nvec3 blinnPhong( ) { \n  vec3 v = normalize(ViewDir);\n  vec3 s = normalize( LightDir );\n\n  float height = 1.0;\n  vec2 tc = findOffset(v, height);\n\n  vec3 texColor = texture(ColorTex, tc).rgb;\n  vec3 n = texture(NormalMapTex, tc).xyz;\n  n.xy = 2.0 * n.xy - 1.0;\n  n = normalize(n);\n\n  float sDotN = max( dot(s,n), 0.0 );\n  vec3 diffuse = vec3(0.0), \n      ambient = Light.La * texColor,\n      spec = vec3(0.0);\n\n  if( sDotN > 0.0 && !isOccluded(height, tc, s) ) {\n    diffuse = texColor * sDotN;\n    vec3 h = normalize( v + s );\n    spec = Material.Ks *\n            pow( max( dot(h,n), 0.0 ), Material.Shininess );\n  }\n\n  return ambient + Light.L * (diffuse + spec);\n}\n```", "```cpp\nGLuint Texture::loadCubeMap(const std::string &baseName, \nconst std::string &extension) {\n    GLuint texID;\n    glGenTextures(1, &texID);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, texID);\n\n    const char * suffixes[] = { \"posx\", \"negx\", \"posy\", \n    \"negy\", \"posz\", \"negz\" };\n    GLint w, h;\n\n    // Load the first one to get width/height\n    std::string texName = baseName + \"_\" + suffixes[0] + extension;\n    GLubyte * data = Texture::loadPixels(texName, w, h, false);\n\n    // Allocate immutable storage for the whole cube map texture\n    glTexStorage2D(GL_TEXTURE_CUBE_MAP, 1, GL_RGBA8, w, h);\n    glTexSubImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, \n        0, 0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, data);\n    stbi_image_free(data);\n\n    // Load the other 5 cube-map faces\n    for( int i = 1; i < 6; i++ ) {\n        std::string texName = baseName + \"_\" + suffixes[i] + \n        extension;\n        data = Texture::loadPixels(texName, w, h, false);\n        glTexSubImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, \n            0, 0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, data);\n        stbi_image_free(data);\n    }\n\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, \n    GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, \n    GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, \n    GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, \n    GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, \n    GL_CLAMP_TO_EDGE);\n\n    return texID;\n}\n```", "```cpp\n\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \nlayout (location = 2) in vec2 VertexTexCoord; \n\nout vec3 ReflectDir;      // The direction of the reflected ray \n\nuniform vec3 WorldCameraPosition; \nuniform mat4 ModelViewMatrix; \nuniform mat4 ModelMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP; \n\nvoid main() {\n  // Compute the reflected direction in world coords. \n  vec3 worldPos = vec3(ModelMatrix *  \n                             vec4(VertexPosition,1.0) ); \n  vec3 worldNorm = vec3(ModelMatrix *  \n                              vec4(VertexNormal, 0.0)); \n  vec3 worldView = normalize( WorldCameraPosition - worldPos );\n  ReflectDir = reflect(-worldView, worldNorm ); \n\n  gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 ReflectDir;   // The direction of the reflected ray \n\n// The cube map \nlayout(binding=0) uniform samplerCube CubeMapTex; \n\nuniform float ReflectFactor; // Amount of reflection \nuniform vec4 MaterialColor;  // Color of the object's \"Tint\"  \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n  // Access the cube map texture \n  vec4 cubeMapColor = texture(CubeMapTex, ReflectDir); \n  FragColor = mix(MaterialColor, CubeMapColor, ReflectFactor);\n} \n```", "```cpp\nvec4 cubeMapColor = texture(CubeMapTex, ReflectDir) \n```", "```cpp\n\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \n\nout vec3 ReflectDir;  // Reflected direction \nout vec3 RefractDir;  // Transmitted direction \n\nstruct MaterialInfo { \n   float Eta;       // Ratio of indices of refraction \n   float ReflectionFactor; // Percentage of reflected light \n}; \nuniform MaterialInfo Material; \n\nuniform vec3 WorldCameraPosition; \nuniform mat4 ModelViewMatrix; \nuniform mat4 ModelMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP; \n\nvoid main() { \n   vec3 worldPos = vec3( ModelMatrix *  \n                              vec4(VertexPosition,1.0) ); \n   vec3 worldNorm = vec3(ModelMatrix *  \n                              vec4(VertexNormal, 0.0)); \n   vec3 worldView = normalize( WorldCameraPosition -  \n                                    worldPos ); \n\n   ReflectDir = reflect(-worldView, worldNorm ); \n   RefractDir = refract(-worldView, worldNorm,  \n                             Material.Eta );\n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 ReflectDir; \nin vec3 RefractDir; \n\nlayout(binding=0) uniform samplerCube CubeMapTex; \nstruct MaterialInfo { \n  float Eta;  // Ratio of indices of refraction \n  float ReflectionFactor; // Percentage of reflected light \n}; \nuniform MaterialInfo Material; \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n  // Access the cube map texture \n  vec4 reflectColor = texture(CubeMapTex, ReflectDir); \n  vec4 refractColor = texture(CubeMapTex, RefractDir); \n\n  FragColor = mix(refractColor, reflectColor,  \n                     Material.ReflectionFactor); \n}\n```", "```cpp\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, \n                 GL_LINEAR); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  \n                GL_LINEAR); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,  \n                GL_CLAMP_TO_BORDER); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,   \n                GL_CLAMP_TO_BORDER); \n```", "```cpp\nvec3 projPos, projAt, projUp;\n// Set the above 3 to appropriate values...\nmat4 projView = glm::lookAt(projPos, projAt, projUp);\n```", "```cpp\nmat4 projProj = glm::perspective(glm::radians(30.0f), 1.0f, 0.2f, 1000.0f);\nmat4 bias = glm::translate(mat4(1.0f), vec3(0.5f));\nbias = glm::scale(bias, vec3(0.5f));\nprog.setUniform(\"ProjectorMatrix\", bias * projProj * projView);\n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition;\nlayout (location = 1) in vec3 VertexNormal;\n\nout vec3 EyeNormal;   // Normal in eye coordinates\nout vec4 EyePosition; // Position in eye coordinates\nout vec4 ProjTexCoord;\n\nuniform mat4 ProjectorMatrix;\n\nuniform mat4 ModelViewMatrix;\nuniform mat4 ModelMatrix;\nuniform mat3 NormalMatrix;\nuniform mat4 MVP;\n\nvoid main() {\n  vec4 pos4 = vec4(VertexPosition,1.0);\n\n  EyeNormal = normalize(NormalMatrix * VertexNormal);\n  EyePosition = ModelViewMatrix * pos4;\n  ProjTexCoord = ProjectorMatrix * (ModelMatrix * pos4);\n  gl_Position = MVP * pos4;\n}\n```", "```cpp\nin vec3 EyeNormal;       // Normal in eye coordinates \nin vec4 EyePosition;     // Position in eye coordinates \nin vec4 ProjTexCoord; \n\nlayout(binding=0) uniform sampler2D ProjectorTex; \n\n// Light and material uniforms...\n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 blinnPhong( vec3 pos, vec3 norm ) { \n  // Blinn-Phong model...\n} \n\nvoid main() { \n  vec3 color = blinnPhong(EyePosition.xyz, normalize(EyeNormal));\n\n  vec3 projTexColor = vec3(0.0);\n  if( ProjTexCoord.z > 0.0 )\n    projTexColor = textureProj( ProjectorTex, ProjTexCoord ).rgb;\n\n  FragColor = vec4(color + projTexColor * 0.5, 1);\n} \n```", "```cpp\nGLuint fboHandle;  // The handle to the FBO \n\n// Generate and bind the framebuffer \nglGenFramebuffers(1, &fboHandle); \nglBindFramebuffer(GL_FRAMEBUFFER, fboHandle); \n\n// Create the texture object \nGLuint renderTex; \nglGenTextures(1, &renderTex); \nglActiveTexture(GL_TEXTURE0);  // Use texture unit 0 \nglBindTexture(GL_TEXTURE_2D, renderTex); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, 512, 512); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  \n                GL_LINEAR); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,  \n                GL_LINEAR); \n\n// Bind the texture to the FBO \nglFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,  \n                       GL_TEXTURE_2D, renderTex, 0); \n\n// Create the depth buffer \nGLuint depthBuf; \nglGenRenderbuffers(1, &depthBuf); \nglBindRenderbuffer(GL_RENDERBUFFER, depthBuf); \nglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT,  \n                      512, 512); \n\n// Bind the depth buffer to the FBO \nglFramebufferRenderbuffer(GL_FRAMEBUFFER,  \n                          GL_DEPTH_ATTACHMENT, \n                          GL_RENDERBUFFER, depthBuf); \n\n// Set the target for the fragment shader outputs \nGLenum drawBufs[] = {GL_COLOR_ATTACHMENT0}; \nglDrawBuffers(1, drawBufs); \n\n// Unbind the framebuffer, and revert to default \nglBindFramebuffer(GL_FRAMEBUFFER, 0); \n```", "```cpp\n// Bind to texture's FBO \nglBindFramebuffer(GL_FRAMEBUFFER, fboHandle); \nglViewport(0,0,512,512);  // Viewport for the texture\n\n// Use the texture for the cow here \nint loc = glGetUniformLocation(programHandle, \"Texture\"); \nglUniform1i(loc, 1);\n\n// Setup the projection matrix and view matrix \n// for the scene to be rendered to the texture here. \n// (Don't forget to match aspect ratio of the viewport.) \n\nrenderTextureScene(); \n\n// Unbind texture's FBO (back to default FB) \nglBindFramebuffer(GL_FRAMEBUFFER, 0); \nglViewport(0,0,width,height);  // Viewport for main window \n\n// Use the texture that is linked to the FBO \nint loc = glGetUniformLocation(programHandle, \"Texture\"); \nglUniform1i(loc, 0); \n\n// Reset projection and view matrices here...\nrenderScene();\n```", "```cpp\nGLuint texID; \nglGenTextures(1, &texID); \nglBindTexture(GL_TEXTURE_2D, texID); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, w, h); \nglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, w, h, GL_RGBA, \n   GL_UNSIGNED_BYTE, data);\n```", "```cpp\nglActiveTexture(GL_TEXTURE0); \nglBindTexture(GL_TEXTURE_2D, texID); \n```", "```cpp\nGLuint samplers[2]; \nglGenSamplers(2, samplers); \nlinearSampler = samplers[0]; \nnearestSampler = samplers[1]; \n```", "```cpp\nglSamplerParameteri(linearSampler, GL_TEXTURE_MAG_FILTER,  \n                    GL_LINEAR); \nglSamplerParameteri(linearSampler, GL_TEXTURE_MIN_FILTER,  \n                    GL_LINEAR); \n```", "```cpp\nglSamplerParameteri(nearestSampler, GL_TEXTURE_MAG_FILTER,  \n                    GL_NEAREST); \nglSamplerParameteri(nearestSampler, GL_TEXTURE_MIN_FILTER,  \n                    GL_NEAREST); \n```", "```cpp\nglBindSampler(0, nearestSampler); \n// Render objects that use nearest-neighbor sampling \nglBindSampler(0, linearSampler); \n// Render objects that use linear sampling\n```", "```cpp\nnSamples = 1000\nforeach texel t in output map\n  n = direction towards t\n  rad = 0\n  for i = 1 to nSamples\n     li = uniform random direction in the \n          hemisphere around n in world coords\n     L = read from environment map at li\n     nDotL = dot( n, li )\n     rad += L * nDotL\n  set texel t to (2 / nSamples) * rad\n```", "```cpp\n// Input attributes...\n\nout vec3 Position; // world coords\nout vec3 Normal;   // world coords.\nout vec2 TexCoord;\n\n// Matrix uniforms ...\n\nvoid main() {\n    TexCoord = VertexTexCoord;\n    Position = (ModelMatrix * vec4(VertexPosition,1)).xyz;\n    Normal = normalize( ModelMatrix * vec4(VertexNormal,0) ).xyz;\n    gl_Position = MVP * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nconst float PI = 3.14159265358979323846;\n\nin vec3 Position;\nin vec3 Normal;\nin vec2 TexCoord;\n\nlayout(binding=0) uniform samplerCube DiffConvTex;\nlayout(binding=1) uniform sampler2D ColorTex;\n\nlayout( location = 0 ) out vec4 FragColor;\n\nconst float gamma = 2.2;\n\nvoid main() {\n    vec3 n = normalize(Normal);\n\n    // Look up reflected light from diffuse cube map\n    vec3 light = texture(DiffConvTex, n).rgb;\n    vec3 color = texture(ColorTex, TexCoord).rgb;\n    color = pow(color, vec3(gamma));   // decode\n    color *= light;\n\n    color = pow( color, vec3(1.0/gamma));  // gamma encode\n\n    FragColor = vec4( color, 1 );\n}\n```"]