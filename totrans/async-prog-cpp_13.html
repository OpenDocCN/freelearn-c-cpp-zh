<html><head></head><body>
  <div id="_idContainer068">
   <h1 class="chapter-number" id="_idParaDest-268">
    <a id="_idTextAnchor267">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     13
    </span>
   </h1>
   <h1 id="_idParaDest-269">
    <a id="_idTextAnchor268">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Improving Asynchronous Software Performance
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we’ll introduce the performance aspects of asynchronous code.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Code performance and optimization is a deep and complex subject, and we can’t cover everything in just one chapter.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     We aim to give you a good introduction to the subject with some examples of how to measure performance and optimize
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      your code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     This chapter will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      key topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.7.1">
      Performance measurement tools with a focus on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.8.1">
       multithreaded applications
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      What’s false sharing, how to spot it, and how to fix/improve
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       our code
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      An introduction to modern CPUs’ memory
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       cache architecture
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      A review of
     </span>
     <a id="_idIndexMarker996">
     </a>
     <span class="koboSpan" id="kobo.14.1">
      the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.15.1">
       single-producer-single-consumer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.16.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.17.1">
       SPSC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.18.1">
      ) lock-free queue we implemented in
     </span>
     <a href="B22219_05.xhtml#_idTextAnchor097">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.19.1">
         Chapter 5
        </span>
       </em>
      </span>
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-270">
    <a id="_idTextAnchor269">
    </a>
    <span class="koboSpan" id="kobo.20.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.21.1">
     Like in the previous chapters, you’ll need a modern C++ compiler that supports C++20.
    </span>
    <span class="koboSpan" id="kobo.21.2">
     We’ll be using GCC 13 and Clang 18.
    </span>
    <span class="koboSpan" id="kobo.21.3">
     You’ll also need a PC with an Intel/AMD multicore CPU running Linux.
    </span>
    <span class="koboSpan" id="kobo.21.4">
     For this chapter, we used Ubuntu 24.04 LTS running on a workstation with a CPU AMD Ryzen Threadripper Pro 5975WX (32 cores).
    </span>
    <span class="koboSpan" id="kobo.21.5">
     A CPU with 8 cores is ideal but 4 cores is enough to run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      the examples.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.23.1">
     We’ll also be using the Linux
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.24.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.25.1">
     tool.
    </span>
    <span class="koboSpan" id="kobo.25.2">
     We’ll explain how to get and install these tools later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     The examples for this chapter can be found in this book’s GitHub
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      repository:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.29.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-271">
    <a id="_idTextAnchor270">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     Performance measurement tools
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     To learn about the
    </span>
    <a id="_idIndexMarker997">
    </a>
    <span class="koboSpan" id="kobo.33.1">
     performance of our applications, we need to be able to measure it.
    </span>
    <span class="koboSpan" id="kobo.33.2">
     If there’s one key takeaway from this chapter, it’s to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.34.1">
      never estimate or guess your code performance
     </span>
    </em>
    <span class="koboSpan" id="kobo.35.1">
     .
    </span>
    <span class="koboSpan" id="kobo.35.2">
     To know whether your program meets its performance requirements (either latency or throughput), you need to measure, measure, and then
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      measure again.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     Once you have the data from your performance tests, you’ll know the hotspots in your code.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Maybe they’re related to memory access patterns or thread contention (such as, for example, when multiple threads must wait to acquire a lock to access a resource).
    </span>
    <span class="koboSpan" id="kobo.37.3">
     This is where the second most important takeaway comes into play:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.38.1">
      set a goal when optimizing your application
     </span>
    </em>
    <span class="koboSpan" id="kobo.39.1">
     .
    </span>
    <span class="koboSpan" id="kobo.39.2">
     Don’t aim to achieve the best performance possible because there always will be room for improvement.
    </span>
    <span class="koboSpan" id="kobo.39.3">
     The right thing to do is to set a clear specification with targets such as maximum processing time for a transaction or the number of network packets processed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      per second.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     With these two main ideas in mind, let’s start with the different methods we can use to measure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      code performance.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-272">
    <a id="_idTextAnchor271">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     In-code profiling
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     A very simple but useful
    </span>
    <a id="_idIndexMarker998">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     way to start understanding the performance of our
    </span>
    <a id="_idIndexMarker999">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     code is
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.47.1">
      in-code profiling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.48.1">
     , which consists of adding some extra code to measure the execution time of some code sections.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     This method is good to use as a tool while we’re writing the code (of course, we need to have access to the source code).
    </span>
    <span class="koboSpan" id="kobo.48.3">
     This will allow us to find some performance issues in our code, as we’ll see later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     We’re going to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.51.1">
      std::chrono
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     as our initial approach to profiling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      our code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     The following code snippet shows how we can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      std::chrono
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     to do some basic profiling of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      our code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.58.1">
auto start = std::chrono::high_resolution_clock::now();
// processing to profile
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);
std::cout &lt; duration.count() &lt;&lt; " milliseconds\n";</span></pre>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Here, we get two time samples that call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      high_resolution_clock::now()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     and print the time lapse converted into milliseconds.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     Depending on the time we estimate the processing is going to take, we could use either microseconds or seconds, for example.
    </span>
    <span class="koboSpan" id="kobo.61.3">
     With this simple technique, we can easily get an idea of how long the processing takes and we can easily compare
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      different options.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.64.1">
      std::chrono::high_resolution_clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.65.1">
     is the clock type that offers the highest precision (smallest tick period provided by the implementation).
    </span>
    <span class="koboSpan" id="kobo.65.2">
     The C++ Standard Library allows it to be an alias of either
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      std::chrono::system_clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      std::chrono::steady_clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     .
    </span>
    <span class="koboSpan" id="kobo.69.2">
     libstdc++ has it aliased to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      std::chrono::system_clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     , whereas libc++ uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      std::chrono::steady_clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     .
    </span>
    <span class="koboSpan" id="kobo.73.2">
     For the examples in this chapter, we’ve used GCC and libstdc++.
    </span>
    <span class="koboSpan" id="kobo.73.3">
     The
    </span>
    <a id="_idIndexMarker1000">
    </a>
    <span class="koboSpan" id="kobo.74.1">
     clock resolution
    </span>
    <a id="_idIndexMarker1001">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      1 nanosecond:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.77.1">
/**
 *  @brief Highest-resolution clock
 *
 *  This is the clock "with the shortest tick period." </span><span class="koboSpan" id="kobo.77.2">Alias to
 *  std::system_clock until higher-than-nanosecond definitions
 *  become feasible.
 </span><span class="koboSpan" id="kobo.77.3">*  @ingroup chrono
*/
using high_resolution_clock = system_clock;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     Now, let’s see a full example
    </span>
    <a id="_idIndexMarker1002">
    </a>
    <span class="koboSpan" id="kobo.79.1">
     of profiling two of the C++ Standard
    </span>
    <a id="_idIndexMarker1003">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     Library algorithms to sort vectors –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.81.1">
      std::sort
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.83.1">
       std::stable_sort
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.84.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.85.1">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;utility&gt;
int uniform_random_number(int min, int max) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution dis(min, max);
    return dis(gen);
}
std::vector&lt;int&gt; random_vector(std::size_t n, int32_t min_val, int32_t max_val) {
    std::vector&lt;int&gt; rv(n);
    std::ranges::generate(rv, [&amp;] {
            return uniform_random_number(min_val, max_val);
        });
    return rv;
}
using namespace std::chrono;
int main() {
    constexpr uint32_t elements = 100000000;
    int32_t minval = 1;
    int32_t maxval = 1000000000;
    auto rv1 = random_vector(elements, minval, maxval);
    auto rv2 = rv1;
    auto start = high_resolution_clock::now();
    std::ranges::sort(rv1);
    auto end = high_resolution_clock::now();
    auto duration = duration_cast&lt;milliseconds&gt;(end - start);
    std::cout &lt;&lt; "Time to std::sort "
              &lt;&lt; elements &lt;&lt; " elements with values in ["
              &lt;&lt; minval &lt;&lt; "," &lt;&lt; maxval &lt;&lt; "] "
              &lt;&lt; duration.count() &lt;&lt; " milliseconds\n";
    start = high_resolution_clock::now();
    std::ranges::stable_sort(rv2);
    end = high_resolution_clock::now();
    duration = duration_cast&lt;milliseconds&gt;(end - start);
    std::cout &lt;&lt; "Time to std::stable_sort "
              &lt;&lt; elements &lt;&lt; " elements with values in ["
              &lt;&lt; minval &lt;&lt; "," &lt;&lt; maxval &lt;&lt; "] "
              &lt;&lt; duration.count() &lt;&lt; " milliseconds\n";
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.86.1">
     The preceding code generates a vector of normally distributed random numbers and then sorts the vector with both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.87.1">
      std::sort()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.88.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      std::stable_sort()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     .
    </span>
    <span class="koboSpan" id="kobo.90.2">
     Both functions sort the vector, but
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.91.1">
      std::sort()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     uses a combination of quicksort and insertion sort algorithms called introsort, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.93.1">
      std::stable_sort()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     uses merge sort.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     The sort is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.95.1">
      stable
     </span>
    </em>
    <span class="koboSpan" id="kobo.96.1">
     because equivalent keys have the same order in both the original and sorted vectors.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     For a vector of integers, this isn’t important, but if the vector has three elements with the same value, after sorting the vector, the numbers will be in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      same order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.98.1">
     After running the code, we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.100.1">
Time to std::sort 100000000 elements with values in [1,1000000000] 6019 milliseconds
Time to std::stable_sort 100000000 elements with values in [1,1000000000] 7342 milliseconds</span></pre>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     In this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.102.1">
      std::stable_sort()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     is slower
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.104.1">
      than
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.105.1">
       std::sort()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.107.1">
     In this section, we learned about a simple way to measure the running time of sections of our code.
    </span>
    <span class="koboSpan" id="kobo.107.2">
     This method is intrusive and requires that we modify the code; it’s mostly used while we
    </span>
    <a id="_idIndexMarker1004">
    </a>
    <span class="koboSpan" id="kobo.108.1">
     develop
    </span>
    <a id="_idIndexMarker1005">
    </a>
    <span class="koboSpan" id="kobo.109.1">
     our applications.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     In the next section, we’re going to introduce another way to measure execution time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      called micro-benchmarks.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-273">
    <a id="_idTextAnchor272">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     Code micro-benchmarks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     Sometimes, we just want
    </span>
    <a id="_idIndexMarker1006">
    </a>
    <span class="koboSpan" id="kobo.113.1">
     to analyze
    </span>
    <a id="_idIndexMarker1007">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     a small section of code in isolation.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     We may need to run it more than once and then get the average running time or run it with different input data.
    </span>
    <span class="koboSpan" id="kobo.114.3">
     In these cases, we can use a benchmark (also
    </span>
    <a id="_idIndexMarker1008">
    </a>
    <span class="koboSpan" id="kobo.115.1">
     called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.116.1">
      micro-benchmark
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     ) library to do just that – execute small parts of our code in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.118.1">
      different conditions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     Micro-benchmarks must be used as a guide.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Bear in mind that the code runs in isolation, and this can give us very different results when we run all the code together due to the many complex interactions among different sections of our code.
    </span>
    <span class="koboSpan" id="kobo.119.3">
     Use them carefully and be aware that micro-benchmarks can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      be misleading.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     There are many libraries we can use to benchmark our code.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     We’ll use
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.122.1">
      Google Benchmark
     </span>
    </em>
    <span class="koboSpan" id="kobo.123.1">
     , a very good and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      well-known library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     Let’s start by getting the code and compiling the library.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     To get the code, run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      following commands:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.127.1">
git clone https://github.com/google/benchmark.git
cd benchmark
git clone https://github.com/google/googletest.git</span></pre>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     Once we have the code for both the benchmark and Google Test libraries (the latter is required to compile the former), we’ll
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      build it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     Create a directory for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      the build:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.132.1">
mkdir build
cd build</span></pre>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     With that, we’ve created the build directory inside the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      benchmark directory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     Next, we’ll use CMake
    </span>
    <a id="_idIndexMarker1009">
    </a>
    <span class="koboSpan" id="kobo.136.1">
     to configure the
    </span>
    <a id="_idIndexMarker1010">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     build and create all the necessary information
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.139.1">
       make
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.140.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.141.1">
cmake .. </span><span class="koboSpan" id="kobo.141.2">-DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBRARIES=ON -DCMAKE_INSTALL_PREFIX=/usr/lib/x86_64-linux-gnu/</span></pre>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Finally, run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      make
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     to build and install
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      the libraries:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.146.1">
make -j16
sudo make install</span></pre>
   <p>
    <span class="koboSpan" id="kobo.147.1">
     You also need to add the library to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      CmakeLists.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.149.2">
     We’ve done that for you in the code for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.150.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.151.1">
     Once Google Benchmark has been installed, we can work on an example with a few benchmark functions to learn how to use the library for some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      basic benchmarking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     Note that both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      std::chrono
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     and Google Benchmark aren’t specific tools for working with asynchronous/multithreaded code and are more like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      generic tools.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     This is our first
    </span>
    <a id="_idIndexMarker1011">
    </a>
    <span class="koboSpan" id="kobo.158.1">
     example of
    </span>
    <a id="_idIndexMarker1012">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      Google Benchmark:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.161.1">
#include &lt;benchmark/benchmark.h&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
void BM_vector_push_back(benchmark::State&amp; state) {
    for (auto _ : state) {
        std::vector&lt;int&gt; vec;
        for (int i = 0; i &lt; state.range(0); i++) {
            vec.push_back(i);
        }
    }
}
void BM_vector_emplace_back(benchmark::State&amp; state) {
    for (auto _ : state) {
        std::vector&lt;int&gt; vec;
        for (int i = 0; i &lt; state.range(0); i++) {
            vec.emplace_back(i);
        }
    }
}
void BM_vector_insert(benchmark::State&amp; state) {
    for (auto _ : state) {
        std::vector&lt;int&gt; vec;
        for (int i = 0; i &lt; state.range(0); i++) {
            vec.insert(vec.begin(), i);
        }
    }
}
BENCHMARK(BM_vector_push_back)-&gt;Range(1, 1000);
BENCHMARK(BM_vector_emplace_back)-&gt;Range(1, 1000);
BENCHMARK(BM_vector_insert)-&gt;Range(1, 1000);
int main(int argc, char** argv) {
    benchmark::Initialize(&amp;argc, argv);
    benchmark::RunSpecifiedBenchmarks();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     We need to
    </span>
    <a id="_idIndexMarker1013">
    </a>
    <span class="koboSpan" id="kobo.163.1">
     include the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      library
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker1014">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      header:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.166.1">
#include &lt;benchmark/benchmark.h&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     All benchmark functions have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      following signature:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.169.1">
void benchmark_function(benchmark::State&amp; state);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.170.1">
     This is a function with one parameter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      benchmark::State&amp; state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     , that returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     .
    </span>
    <span class="koboSpan" id="kobo.174.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      benchmark::State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     parameter has a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      dual purpose:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.178.1">
       Controlling the iteration loop
      </span>
     </strong>
     <span class="koboSpan" id="kobo.179.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.180.1">
       benchmark::State
      </span>
     </strong>
     <span class="koboSpan" id="kobo.181.1">
      object is used to control how many times a benchmarked function or piece of code should be executed.
     </span>
     <span class="koboSpan" id="kobo.181.2">
      This helps measure the performance accurately by repeating the test enough times to minimize variability and collect
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.182.1">
       meaningful data.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.183.1">
       Measuring time and statistics
      </span>
     </strong>
     <span class="koboSpan" id="kobo.184.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.185.1">
       state
      </span>
     </strong>
     <span class="koboSpan" id="kobo.186.1">
      object keeps track of how long the benchmarked code takes to run, and it provides mechanisms to report metrics such as elapsed time, iterations, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.187.1">
       custom counters.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     We’ve implemented three functions to benchmark adding elements to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     sequence in different ways: the first function uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      std::vector::push_back
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     , the second uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      std::vector::emplace_back
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     , and the third uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      std::vector::insert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     .
    </span>
    <span class="koboSpan" id="kobo.196.2">
     The first two functions add elements at the end of the vector, while the third function adds elements at the beginning of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      the vector.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     Once we’ve implemented the benchmark functions, we need to tell the library that they must be run as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      a benchmark:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.200.1">
BENCHMARK(BM_vector_push_back)-&gt;Range(1, 1000);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      BENCHMARK
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     macro to do this.
    </span>
    <span class="koboSpan" id="kobo.203.2">
     For the benchmarks in this example, we set the number of elements to be inserted into the vector in each iteration.
    </span>
    <span class="koboSpan" id="kobo.203.3">
     The range goes from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      1000
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     and each iteration will insert eight times the number of elements of the previous iteration until it
    </span>
    <a id="_idIndexMarker1015">
    </a>
    <span class="koboSpan" id="kobo.208.1">
     reaches
    </span>
    <a id="_idIndexMarker1016">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     the maximum.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     In this case, it will insert 1, 8, 64, 512, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      1,000 elements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     When we run our first benchmark program, we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.213.1">
2024-10-17T05:02:37+01:00
Running ./13x02-benchmark_vector
Run on (64 X 3600 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB (x32)
  L1 Instruction 32 KiB (x32)
  L2 Unified 512 KiB (x32)
  L3 Unified 32768 KiB (x4)
Load Average: 0.00, 0.02, 0.16
----------------------------------------------------------------------
Benchmark                            Time             CPU   Iterations
----------------------------------------------------------------------
BM_vector_push_back/1             10.5 ns         10.5 ns     63107997
BM_vector_push_back/8             52.0 ns         52.0 ns     13450361
BM_vector_push_back/64             116 ns          116 ns      6021740
BM_vector_push_back/512            385 ns          385 ns      1819732
BM_vector_push_back/1000           641 ns          641 ns      1093474
BM_vector_emplace_back/1          10.8 ns         10.8 ns     64570848
BM_vector_emplace_back/8          53.3 ns         53.3 ns     13139191
BM_vector_emplace_back/64          108 ns          108 ns      6469997
BM_vector_emplace_back/512         364 ns          364 ns      1924992
BM_vector_emplace_back/1000        616 ns          616 ns      1138392
BM_vector_insert/1                10.6 ns         10.6 ns     65966159
BM_vector_insert/8                58.6 ns         58.6 ns     11933446
BM_vector_insert/64                461 ns          461 ns      1485319
BM_vector_insert/512              7249 ns         7249 ns        96756
BM_vector_insert/1000            23352 ns        23348 ns        29742</span></pre>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     First, the program
    </span>
    <a id="_idIndexMarker1017">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     prints information
    </span>
    <a id="_idIndexMarker1018">
    </a>
    <span class="koboSpan" id="kobo.216.1">
     about the execution of the benchmark: the date and time, the name of the executable, and information about the CPU it’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      running on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.218.1">
     Take a look at the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      following line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.220.1">
Load Average: 0.00, 0.02, 0.16</span></pre>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     This line gives us an estimate of the CPU load: from 0.0 (no load at all or very low load) to 1.0 (fully loaded).
    </span>
    <span class="koboSpan" id="kobo.221.2">
     The three numbers correspond to the CPU load for the last 5, 10, and 15
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      minutes, respectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.223.1">
     After printing the CPU load information, the benchmark prints the results of each iteration.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     Here’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.225.1">
BM_vector_push_back/64             116 ns          116 ns      6021740</span></pre>
   <p>
    <span class="koboSpan" id="kobo.226.1">
     This means that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      BM_vector_push_back
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     was called 6,021,740 times (the number of iterations) while inserting 64 elements into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.229.1">
      the vector.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      Time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      CPU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     columns give us the average time for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      each iteration:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.236.1">
       Time
      </span>
     </strong>
     <span class="koboSpan" id="kobo.237.1">
      : This is the real time that’s elapsed from the beginning to the end of each benchmark execution.
     </span>
     <span class="koboSpan" id="kobo.237.2">
      It includes everything that happens during the benchmark: CPU computation, I/O operations, context switches,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.238.1">
       and more.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.239.1">
       CPU time
      </span>
     </strong>
     <span class="koboSpan" id="kobo.240.1">
      : This is the amount of time the CPU spent processing the instructions of the benchmark.
     </span>
     <span class="koboSpan" id="kobo.240.2">
      It can be smaller than or equal
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.241.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.242.1">
        Time
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.243.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     In our benchmark, because the operations are simple, we can see that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.245.1">
      Time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.246.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      CPU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     are mostly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      the same.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     Looking at the results, we can come to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      following conclusions:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.252.1">
      For simple objects such as 32-bit integers, both
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       push_back
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.255.1">
       emplace_back
      </span>
     </strong>
     <span class="koboSpan" id="kobo.256.1">
      take the same amount
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.257.1">
       of time.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.258.1">
      Here,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.259.1">
       insert
      </span>
     </strong>
     <span class="koboSpan" id="kobo.260.1">
      takes the same amount of time as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.261.1">
       push_back
      </span>
     </strong>
     <span class="koboSpan" id="kobo.262.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.263.1">
       emplace_back
      </span>
     </strong>
     <span class="koboSpan" id="kobo.264.1">
      for a small number of elements but from 64 elements onwards, it takes considerably more time.
     </span>
     <span class="koboSpan" id="kobo.264.2">
      This is because
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.265.1">
       insert
      </span>
     </strong>
     <span class="koboSpan" id="kobo.266.1">
      must copy all the elements after each insertion (we insert the elements at the beginning of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.267.1">
       the vector).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     The following
    </span>
    <a id="_idIndexMarker1019">
    </a>
    <span class="koboSpan" id="kobo.269.1">
     example also sorts a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     sequence, but
    </span>
    <a id="_idIndexMarker1020">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     this time, we’ll use a micro-benchmark to measure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      execution time:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.274.1">
#include &lt;benchmark/benchmark.h&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
std::vector&lt;int&gt; rv1, rv2;
int uniform_random_number(int min, int max) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution dis(min, max);
    return dis(gen);
}
std::vector&lt;int&gt; random_vector(std::size_t n, int32_t min_val, int32_t max_val) {
    std::vector&lt;int&gt; rv(n);
    std::ranges::generate(rv, [&amp;] {
        return uniform_random_number(min_val, max_val);
    });
    return rv;
}
static void BM_vector_sort(benchmark::State&amp; state, std::vector&lt;int&gt;&amp; vec) {
    for (auto _ : state) {
        std::ranges::sort(vec);
    }
}
static void BM_vector_stable_sort(benchmark::State&amp; state, std::vector&lt;int&gt;&amp; vec) {
    for (auto _ : state) {
        std::ranges::stable_sort(vec);
    }
}
BENCHMARK_CAPTURE(BM_vector_sort, vector, rv1)-&gt;Iterations(1)-&gt;Unit(benchmark::kMillisecond);
BENCHMARK_CAPTURE(BM_vector_stable_sort, vector, rv2)-&gt;Iterations(1)-&gt;Unit(benchmark::kMillisecond);
int main(int argc, char** argv) {
    constexpr uint32_t elements = 100000000;
    int32_t minval = 1;
    int32_t maxval = 1000000000;
    rv1 = random_vector(elements, minval, maxval);
    rv2 = rv1;
    benchmark::Initialize(&amp;argc, argv);
    benchmark::RunSpecifiedBenchmarks();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     The preceding
    </span>
    <a id="_idIndexMarker1021">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     code
    </span>
    <a id="_idIndexMarker1022">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     generates a vector of random numbers.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     Here, we run two benchmark functions to sort the vector: one using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      std::sort
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     and another using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      std::stable_sort
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     .
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Note that we use two copies of the same vector, so the input is the same for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      both functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     The following line of code uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      BENCHMARK_CAPTURE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     macro.
    </span>
    <span class="koboSpan" id="kobo.285.2">
     This macro allows us to pass parameters to our benchmark functions – in this case, a reference to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     (we pass by reference to avoid copying the vector and impacting the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      benchmark result).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     We specify the results to be in milliseconds instead
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      of nanoseconds:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.291.1">
BENCHMARK_CAPTURE(BM_vector_sort, vector, rv1)-&gt;Iterations(1)-&gt;Unit(benchmark::kMillisecond);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.292.1">
     Here are the results of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.293.1">
      the benchmark:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.294.1">
-------------------------------------------------------------------------
Benchmark                          Time         CPU   Iterations
-------------------------------------------------------------------------
BM_vector_sort                     5877 ms      5876 ms            1
BM_vector_stable_sort.             7172 ms      7171 ms            1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     The results are consistent with the ones we got measuring time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.297.1">
       std::chrono
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     For our last Google
    </span>
    <a id="_idIndexMarker1023">
    </a>
    <span class="koboSpan" id="kobo.300.1">
     Benchmark
    </span>
    <a id="_idIndexMarker1024">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     example, we’ll create a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      thread (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.303.1">
       std::thread
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      ):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.305.1">
#include &lt;benchmark/benchmark.h&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
static void BM_create_terminate_thread(benchmark::State&amp; state) {
    for (auto _ : state) {
        std::thread thread([]{ return -1; });
        thread.join();
    }
}
BENCHMARK(BM_create_terminate_thread)-&gt;Iterations(2000);
int main(int argc, char** argv) {
    benchmark::Initialize(&amp;argc, argv);
    benchmark::RunSpecifiedBenchmarks();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.306.1">
     This example is simple:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.307.1">
      BM_create_terminate_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     creates a thread (doing nothing, just returning 0) and waits for it to end (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      thread.join())
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     .
    </span>
    <span class="koboSpan" id="kobo.310.2">
     We run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      2000
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     iterations to get
    </span>
    <a id="_idIndexMarker1025">
    </a>
    <span class="koboSpan" id="kobo.313.1">
     an estimation of the
    </span>
    <a id="_idIndexMarker1026">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     time it takes to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      a thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     The results are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.318.1">
---------------------------------------------------------------
----------
Benchmark                        Time             CPU
Iterations
---------------------------------------------------------------
----------
BM_create_terminate_thread.       32424 ns        21216 ns     2000</span></pre>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     In this section, we learned how to use the Google Benchmark library to create micro-benchmarks to measure the execution time of some functions.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     Again, micro-benchmarks are
    </span>
    <a id="_idIndexMarker1027">
    </a>
    <span class="koboSpan" id="kobo.320.1">
     just an approximation
    </span>
    <a id="_idIndexMarker1028">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     and due to the isolated nature of the code being benchmarked, they may be misleading.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     Use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      them carefully.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-274">
    <a id="_idTextAnchor273">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     The Linux perf tool
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     Using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      std::chrono
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     in our
    </span>
    <a id="_idIndexMarker1029">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     code or a micro-benchmark
    </span>
    <a id="_idIndexMarker1030">
    </a>
    <span class="koboSpan" id="kobo.328.1">
     library such as Google Benchmark requires gaining access to the code to be profiled and also being able to modify it by either adding extra calls to measure the execution time of code sections or running small snippets as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      micro-benchmark functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.330.1">
     With the Linux
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     tool, we can analyze the execution of a program without changing any of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      its code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     The Linux
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.335.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     tool is a powerful, flexible, and widely used performance analysis and profiling utility for Linux systems.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     It provides detailed insights into system performance at the kernel and user
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      space levels.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     Let’s consider the main uses
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.340.1">
       perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     First, we
    </span>
    <a id="_idIndexMarker1031">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     have
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.344.1">
      CPU profiling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     .
    </span>
    <span class="koboSpan" id="kobo.345.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     tool allows you to capture the execution profile of a process, measuring which functions consume most of the CPU time.
    </span>
    <span class="koboSpan" id="kobo.347.2">
     This can be very useful in helping to identify CPU-intensive parts of the code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.348.1">
      and bottlenecks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.349.1">
     The following command line will run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     on the small
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      13x07-thread_contention
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     program we wrote to illustrate the basics of the tool.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     The code for this application can be found in this book’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.355.1">
perf record --call-graph dwarf ./13x07-thread_contention</span></pre>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      --call-graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     option records the data of the function call hierarchy in a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      perf.data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     , while the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      dwarf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     option instructs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     to use the dwarf file format to debug symbols (to get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      function names).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     After the previous command, we must run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.368.1">
 perf script &gt; out.perf</span></pre>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     This will dump the recorded data (including the call stack) into a text file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.371.1">
       out.perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     Now, we need to convert the text file into a picture with the call graph.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     To do this, we can run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.375.1">
gprof2dot -f perf out.perf -o callgraph.dot</span></pre>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     This will generate a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      callgraph.dot
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     that can be visualized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.379.1">
      using Graphviz.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.380.1">
     You may need to install
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.381.1">
      gprof2dot
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     .
    </span>
    <span class="koboSpan" id="kobo.382.2">
     For this, you need Python installed on your PC.
    </span>
    <span class="koboSpan" id="kobo.382.3">
     Run the following command to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      install
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.384.1">
       gprof2dot
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.386.1">
pip install gprof2dot</span></pre>
   <p>
    <span class="koboSpan" id="kobo.387.1">
     Install Graphviz too.
    </span>
    <span class="koboSpan" id="kobo.387.2">
     In Ubuntu, you can do this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      like so:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.389.1">
sudo apt-get install graphviz</span></pre>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     Finally, you can generate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      callgraph.png
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     picture by running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.394.1">
dot -Tpng callgraph.dot -o callgraph.png</span></pre>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     Another very common
    </span>
    <a id="_idIndexMarker1032">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     way to visualize the call graph
    </span>
    <a id="_idIndexMarker1033">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     of a program is by using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.398.1">
      flame graph.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.399.1">
     To generate a flame graph, clone the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.400.1">
       FlameGraph
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      repository:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.402.1">
git clone https://github.com/brendangregg/FlameGraph.git</span></pre>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.404.1">
      FlameGraph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     folder, you’ll find the scripts to generate the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      flame graphs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     Run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.408.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.409.1">
FlameGraph/stackcollapse-perf.pl out.perf &gt; out.folded</span></pre>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     This command will collapse the stack traces into a format that can be used by the FlameGraph tool.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     Now, run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.412.1">
Flamegraph/flamegraph.pl out.folded &gt; flamegraph.svg</span></pre>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     You can visualize the flame graph with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      web browser:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.415.1">
      <img alt="Figure 13.1: ﻿An overview of a flame graph" src="image/B22219_13_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.416.1">
     Figure 13.1: An overview of a flame graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.417.1">
     Now, let’s learn how to gather the performance statistics of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.418.1">
      a program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.419.1">
     The following command will show the number of instructions that have been executed and CPU cycles that were used during the execution of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      13x05-sort_perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     .
    </span>
    <span class="koboSpan" id="kobo.421.2">
     The number of instructions per cycle is the average number of instructions the CPU executes in each clock cycle.
    </span>
    <span class="koboSpan" id="kobo.421.3">
     This metric is only useful when we microbenchmark or measure short parts of the code.
    </span>
    <span class="koboSpan" id="kobo.421.4">
     For this example, we can see that the CPU is executing one instruction per cycle, which is average for a modern CPU.
    </span>
    <span class="koboSpan" id="kobo.421.5">
     In multithreaded code, we can get a much bigger number due to the parallel nature of the execution, but this metric is generally used to measure and optimize code executed in a single CPU core.
    </span>
    <span class="koboSpan" id="kobo.421.6">
     The number must be
    </span>
    <a id="_idIndexMarker1034">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     interpreted as how busy we keep the
    </span>
    <a id="_idIndexMarker1035">
    </a>
    <span class="koboSpan" id="kobo.423.1">
     CPU because it depends on many factors, such as the number of memory reads/writes, memory access patterns (linear consecutive/no linear), level of branching in the code, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      so on:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.425.1">
perf stat -e instructions,cycles ./13x05-sort_perf</span></pre>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     After running the preceding command, we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      following result:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.428.1">
Performance counter stats for './13x05-sort_perf':
    30,993,024,309      instructions                     #     1.03   
             insn per cycle
    30,197,863,655      cycles
       6.657835162 seconds time elapsed
       6.502372000 seconds user
       0.155008000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     Running the following command, you can get the list of all the predefined events you can analyze
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.431.1">
       perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.432.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.433.1">
perf list</span></pre>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     Let’s do a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      few more:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.436.1">
perf stat -e branches ./13x05-sort_perf</span></pre>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     The previous command measures the number of branch instructions that have been executed.
    </span>
    <span class="koboSpan" id="kobo.437.2">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      following result:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.439.1">
Performance counter stats for './13x05-sort_perf':
     5,246,138,882      branches
       6.712285274 seconds time elapsed
       6.551799000 seconds user
       0.159970000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     Here, we can see
    </span>
    <a id="_idIndexMarker1036">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     that a sixth of the instructions that
    </span>
    <a id="_idIndexMarker1037">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     were executed are branching instructions, which is expected in a program that sorts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      large vectors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     As mentioned previously, measuring the level of branching in our code is important, especially for short sections of the code (to avoid interactions that can impact what’s being measured).
    </span>
    <span class="koboSpan" id="kobo.444.2">
     A CPU will run instructions much faster if there are no branches or there are just a few.
    </span>
    <span class="koboSpan" id="kobo.444.3">
     The main issue with branches is that the CPU may need to rebuild the pipeline and that can be costly, especially if branches are in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      inner/critical loops.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     The following command will report the number of L1 cache data accesses (we will see the CPU cache in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.447.1">
      next section):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.448.1">
perf stat -e all_data_cache_accesses ./13x05-sort_perf</span></pre>
   <p>
    <span class="koboSpan" id="kobo.449.1">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      following result:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.451.1">
Performance counter stats for './13x05-sort_perf':
    21,286,061,764      all_data_cache_accesses
       6.718844368 seconds time elapsed
       6.561416000 seconds user
       0.157009000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     Let’s go back to our lock contention example and gather some useful statistics
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.454.1">
       perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Another benefit of using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.457.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     is
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.459.1">
      CPU migrations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     – that is, the
    </span>
    <a id="_idIndexMarker1038">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     number of times a thread was moved from one CPU core to another.
    </span>
    <span class="koboSpan" id="kobo.461.2">
     Thread migration between cores can degrade cache performance
    </span>
    <a id="_idIndexMarker1039">
    </a>
    <span class="koboSpan" id="kobo.462.1">
     since threads lose the benefit
    </span>
    <a id="_idIndexMarker1040">
    </a>
    <span class="koboSpan" id="kobo.463.1">
     of cached data when moving to a new core (more on caches in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.464.1">
      next section).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.465.1">
     Let’s run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.466.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.467.1">
perf stat -e cpu-migrations ./13x07-thread_contention</span></pre>
   <p>
    <span class="koboSpan" id="kobo.468.1">
     This results in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.469.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.470.1">
Performance counter stats for './13x08-thread_contention':
                45      cpu-migrations
      50.476706194 seconds time elapsed
      57.333880000 seconds user
     262.123060000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.471.1">
     Let’s look at another advantage of using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.472.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.473.1">
     :
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.474.1">
      context switches
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     .
    </span>
    <span class="koboSpan" id="kobo.475.2">
     It
    </span>
    <a id="_idIndexMarker1041">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     counts the number of context switches (how many times a thread is swapped out and another thread is scheduled) during the execution.
    </span>
    <span class="koboSpan" id="kobo.476.2">
     High-context switching can indicate that too many threads are competing for CPU time, leading to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      performance degradation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     Let’s run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.479.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.480.1">
perf stat -e context-switches ./13x07-thread_contention</span></pre>
   <p>
    <span class="koboSpan" id="kobo.481.1">
     This results in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.483.1">
Performance counter stats for './13x08-thread_contention':
        13,867,866      cs
      47.618283562 seconds time elapsed
      52.931213000 seconds user
     247.033479000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     That’s a wrap on
    </span>
    <a id="_idIndexMarker1042">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     this section.
    </span>
    <span class="koboSpan" id="kobo.485.2">
     Here, we introduced
    </span>
    <a id="_idIndexMarker1043">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     the Linux
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.487.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     tool and some of its applications.
    </span>
    <span class="koboSpan" id="kobo.488.2">
     We’ll study the CPU memory cache and false sharing in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.489.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-275">
    <a id="_idTextAnchor274">
    </a>
    <span class="koboSpan" id="kobo.490.1">
     False sharing
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     In this section, we’ll study a
    </span>
    <a id="_idIndexMarker1044">
    </a>
    <span class="koboSpan" id="kobo.492.1">
     common issue with multithreaded applications called
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.493.1">
       false sharing
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.494.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.495.1">
     We already know that the ideal implementation of a multithreaded application is minimizing the data that’s shared among its different threads.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     Ideally, we should share data just for read access because in that case, we don’t need to synchronize the threads to access the shared data and thus we don’t need to pay the runtime cost and deal with issues such as deadlock
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      and livelock.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     Now, let’s consider a simple example: four threads run in parallel, generate random numbers, and calculate their sum.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     Each thread works independently, generating random numbers and calculating the sum stored in a variable just written by itself.
    </span>
    <span class="koboSpan" id="kobo.497.3">
     This is the ideal (though for this example, a bit contrived) application, with threads working independently without any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      shared data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     The following code is the full source for the example we’re going to analyze in this section.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     You can refer
    </span>
    <a id="_idIndexMarker1045">
    </a>
    <span class="koboSpan" id="kobo.500.1">
     to it while you read
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      the explanations:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
struct result_data {
    unsigned long result { 0 };
};
struct alignas(64) aligned_result_data {
    unsigned long result { 0 };
};
void set_affinity(int core) {
    if (core &lt; 0) {
        return;
    }
    cpu_set_t cpuset;
    CPU_ZERO(&amp;cpuset);
    CPU_SET(core, &amp;cpuset);
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &amp;cpuset) != 0) {
        perror("pthread_setaffinity_np");
        exit(EXIT_FAILURE);
    }
}
template &lt;typename T&gt;
auto random_sum(T&amp; data, const std::size_t seed, const unsigned long iterations, const int core) {
    set_affinity(core);
    std::mt19937 gen(seed);
    std::uniform_int_distribution dist(1, 5);
    for (unsigned long i = 0; i &lt; iterations; ++i) {
        data.result += dist(gen);
    }
}
using namespace std::chrono;
void sum_random_unaligned(int num_threads, uint32_t iterations) {
    auto* data = new(static_cast&lt;std::align_val_t&gt;(64)) result_data[num_threads];
    auto start = high_resolution_clock::now();
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0; i &lt; num_threads; ++i) {
        set_affinity(i);
        threads.emplace_back(random_sum&lt;result_data&gt;, std::ref(data[i]), i, iterations, i);
    }
    for (auto&amp; thread : threads) {
        thread.join();
    }
    auto end = high_resolution_clock::now();
    auto duration = std::chrono::duration_cast&lt;milliseconds&gt;(end - start);
    std::cout &lt;&lt; "Non-aligned data: " &lt;&lt; duration.count() &lt;&lt; " milliseconds" &lt;&lt; std::endl;
    operator delete[] (data, static_cast&lt;std::align_val_t&gt;(64));
}
void sum_random_aligned(int num_threads, uint32_t iterations) {
    auto* aligned_data = new(static_cast&lt;std::align_val_t&gt;(64)) aligned_result_data[num_threads];
    auto start = high_resolution_clock::now();
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0; i &lt; num_threads; ++i) {
        set_affinity(i);
        threads.emplace_back(random_sum&lt;aligned_result_data&gt;, std::ref(aligned_data[i]), i, iterations, i);
    }
    for (auto&amp; thread : threads) {
        thread.join();
    }
    auto end = high_resolution_clock::now();
    auto duration = std::chrono::duration_cast&lt;milliseconds&gt;(end - start);
    std::cout &lt;&lt; "Aligned data: " &lt;&lt; duration.count() &lt;&lt; " milliseconds" &lt;&lt; std::endl;
    operator delete[] (aligned_data, static_cast&lt;std::align_val_t&gt;(64));
}
int main() {
    constexpr unsigned long iterations{ 100000000 };
    constexpr unsigned int num_threads = 8;
    sum_random_unaligned(8, iterations);
    sum_random_aligned(8, iterations);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     If you compile and run
    </span>
    <a id="_idIndexMarker1046">
    </a>
    <span class="koboSpan" id="kobo.504.1">
     the previous code, you’ll get an output similar to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.505.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.506.1">
Non-aligned data: 4403 milliseconds
Aligned data: 160 milliseconds</span></pre>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     The program just calls two functions:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.508.1">
      sum_random_unaligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.509.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.510.1">
      sum_random_aligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     .
    </span>
    <span class="koboSpan" id="kobo.511.2">
     Both functions do the same: they create eight threads, and each thread generates random numbers and calculates their sum.
    </span>
    <span class="koboSpan" id="kobo.511.3">
     No data is shared among the threads.
    </span>
    <span class="koboSpan" id="kobo.511.4">
     You can see that the functions are pretty much the same and the main difference is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.512.1">
      sum_random_unaligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.513.1">
     uses the following data structure to store the sum of the generated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      random numbers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.515.1">
struct result_data {
    unsigned long result { 0 };
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      sum_random_aligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     function uses a slightly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      different one:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.520.1">
struct alignas(64) aligned_result_data {
    unsigned long result { 0 };
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.521.1">
     The only difference is the use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      alignas(64)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     in informing the compiler that the data structure instances must be aligned at a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      64-byte boundary.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     We can see that the difference in performance is quite dramatic because the threads are performing the same tasks.
    </span>
    <span class="koboSpan" id="kobo.525.2">
     Just aligning the variables written by each thread to a 64-byte boundary greatly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.526.1">
      improves performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     To understand why
    </span>
    <a id="_idIndexMarker1047">
    </a>
    <span class="koboSpan" id="kobo.528.1">
     this is happening, we need to consider a feature of modern CPUs – the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      memory cache.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-276">
    <a id="_idTextAnchor275">
    </a>
    <span class="koboSpan" id="kobo.530.1">
     CPU memory cache
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.531.1">
     Modern CPUs are very
    </span>
    <a id="_idIndexMarker1048">
    </a>
    <span class="koboSpan" id="kobo.532.1">
     fast at computing and when we want to achieve maximum performance, memory access is the main bottleneck.
    </span>
    <span class="koboSpan" id="kobo.532.2">
     A good estimate for memory access is about 150 nanoseconds.
    </span>
    <span class="koboSpan" id="kobo.532.3">
     In that time, our 3.6 GHz CPU has gone through 540 clock cycles.
    </span>
    <span class="koboSpan" id="kobo.532.4">
     As a rough estimate, if the CPU executes an instruction every two cycles, that’s 270 instructions.
    </span>
    <span class="koboSpan" id="kobo.532.5">
     For a normal application, memory access is an issue, even though the compiler may reorder the instructions it generates and the CPU may also reorder the instructions to optimize memory access and try to run as many instructions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.533.1">
      as possible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.534.1">
     Therefore, to improve the performance of modern CPUs, we have what’s called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.535.1">
      CPU cache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.537.1">
      memory cache
     </span>
    </strong>
    <span class="koboSpan" id="kobo.538.1">
     , which is memory in the chip to store both data and instructions.
    </span>
    <span class="koboSpan" id="kobo.538.2">
     This memory is much faster than RAM and allows the CPU to retrieve data much faster, significantly boosting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.539.1">
      overall performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.540.1">
     As an example of a real-life cache, think about a cook.
    </span>
    <span class="koboSpan" id="kobo.540.2">
     They need some ingredients to make lunch for their restaurant clients.
    </span>
    <span class="koboSpan" id="kobo.540.3">
     Now, imagine that they only buy those ingredients when a client comes to the restaurant and orders their food.
    </span>
    <span class="koboSpan" id="kobo.540.4">
     That will be very slow.
    </span>
    <span class="koboSpan" id="kobo.540.5">
     They can also go to the supermarket and buy ingredients for, say, a full day.
    </span>
    <span class="koboSpan" id="kobo.540.6">
     Now, they can cook for all their clients and serve them their meals in a much
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.541.1">
      shorter period.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.542.1">
     CPU caches follow the same concept: when the CPU needs to access a variable, say a 4-byte integer, it reads 64 bytes (this size may be different, depending on the CPU, but most modern CPUs use that size) of contiguous memory
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.543.1">
      just in case
     </span>
    </em>
    <span class="koboSpan" id="kobo.544.1">
     it may need to access more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.545.1">
      contiguous data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.546.1">
     Linear memory data structures such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.547.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.548.1">
     will perform better from a memory access point of view because in these cases, the cache can be a big performance improvement.
    </span>
    <span class="koboSpan" id="kobo.548.2">
     For other types of data structures, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.549.1">
      std::list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.550.1">
     , this won’t be the case.
    </span>
    <span class="koboSpan" id="kobo.550.2">
     Of course, this is just about optimizing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      cache use.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     You may be wondering why if in-CPU cache memory is so good, isn’t all memory like that?
    </span>
    <span class="koboSpan" id="kobo.552.2">
     The answer
    </span>
    <a id="_idIndexMarker1049">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     is cost.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     Cache memory is very fast (much faster than RAM), but it’s also
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.554.1">
      very expensive.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.555.1">
     Modern CPUs employ a hierarchical cache structure, typically consisting of three levels called L1, L2,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      and L3:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.557.1">
       L1 cache
      </span>
     </strong>
     <span class="koboSpan" id="kobo.558.1">
      is the smallest
     </span>
     <a id="_idIndexMarker1050">
     </a>
     <span class="koboSpan" id="kobo.559.1">
      and fastest.
     </span>
     <span class="koboSpan" id="kobo.559.2">
      It’s also the closest to the CPU, as well as the most expensive.
     </span>
     <span class="koboSpan" id="kobo.559.3">
      It’s often split into two parts: an instruction cache for storing instructions and a data cache for storing data.
     </span>
     <span class="koboSpan" id="kobo.559.4">
      The typical sizes are 64 Kb split into 32 Kb for instructions and 32 Kb for data.
     </span>
     <span class="koboSpan" id="kobo.559.5">
      The typical access time to the L1 cache is between 1 and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.560.1">
       3 nanoseconds.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.561.1">
       L2 cache
      </span>
     </strong>
     <span class="koboSpan" id="kobo.562.1">
      is larger and slightly slower than L1, but still much faster than RAM.
     </span>
     <span class="koboSpan" id="kobo.562.2">
      Typical L2 cache sizes are between 128 Kb and 512 Kb (the CPU used to run the examples in this chapter has 512 Kb of L2 cache per core).
     </span>
     <span class="koboSpan" id="kobo.562.3">
      Typical access times for L2 cache are about 3 to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.563.1">
       5 nanoseconds.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.564.1">
       L3 cache
      </span>
     </strong>
     <span class="koboSpan" id="kobo.565.1">
      is the largest and slowest of the three.
     </span>
     <span class="koboSpan" id="kobo.565.2">
      The L1 and L2 caches are per core (each core has its own L1 and L2 cache), but L3 is shared by more than one core.
     </span>
     <span class="koboSpan" id="kobo.565.3">
      Our CPU has 32 Mb of L3 cache shared by each group of eight cores.
     </span>
     <span class="koboSpan" id="kobo.565.4">
      The typical access
     </span>
     <a id="_idIndexMarker1051">
     </a>
     <span class="koboSpan" id="kobo.566.1">
      time is about 10 to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.567.1">
       15 nanoseconds.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.568.1">
     With that, let’s turn our attention to another important concept related to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      memory cache.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-277">
    <a id="_idTextAnchor276">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     Cache coherency
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     The CPU doesn’t access
    </span>
    <a id="_idIndexMarker1052">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     RAM directly.
    </span>
    <span class="koboSpan" id="kobo.572.2">
     This access is always done through the cache, and RAM is accessed only if the CPU doesn’t find the data required in the cache.
    </span>
    <span class="koboSpan" id="kobo.572.3">
     In multi-core systems, each core having its own cache means that one piece of RAM may be present in the cache of multiple cores at the same time.
    </span>
    <span class="koboSpan" id="kobo.572.4">
     These copies need to be synchronized all the time; otherwise, computation results could
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.573.1">
      be incorrect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.574.1">
     So far, we’ve seen that each core has its own L1 cache.
    </span>
    <span class="koboSpan" id="kobo.574.2">
     Let’s go back to our example and think about what happens when we run the function using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.575.1">
      non-aligned memory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.576.1">
     In this case, each instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.577.1">
      result_data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     is 8 bytes.
    </span>
    <span class="koboSpan" id="kobo.578.2">
     We create an array of 8 instances of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.579.1">
      result_data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.580.1">
     , one for each thread.
    </span>
    <span class="koboSpan" id="kobo.580.2">
     The total memory that’s occupied will be 64 bytes and all the instances will be contiguous in memory.
    </span>
    <span class="koboSpan" id="kobo.580.3">
     Every time a thread updates the sum of random numbers, it changes the value that’s stored in the cache.
    </span>
    <span class="koboSpan" id="kobo.580.4">
     Remember that the CPU will always read and write 64 bytes in one go (something called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.581.1">
      cache line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     – you can
    </span>
    <a id="_idIndexMarker1053">
    </a>
    <span class="koboSpan" id="kobo.583.1">
     think of it as the smallest memory access unit).
    </span>
    <span class="koboSpan" id="kobo.583.2">
     All the variables are in the same cache line and even if the threads don’t share them (each thread has its own variable –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.584.1">
      sum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.585.1">
     ), the CPU doesn’t know that and needs to make the changes visible for all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.586.1">
      the cores.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.587.1">
     Here, we have 8 cores, and each core is running a thread.
    </span>
    <span class="koboSpan" id="kobo.587.2">
     Each core has loaded 64 bytes of memory from RAM into the L1 cache.
    </span>
    <span class="koboSpan" id="kobo.587.3">
     Since the threads only read the variables, everything is OK, but as soon as one thread modifies its variable, the contents of the cache line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      are invalidated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.589.1">
     Now, because the cache line is invalid in the remaining 7 cores, the CPU needs to propagate the changes to all the cores.
    </span>
    <span class="koboSpan" id="kobo.589.2">
     As mentioned previously, even if the threads don’t share the variables, the CPU can’t possibly know that, and it updates all the cache lines for all the cores to keep the values consistent.
    </span>
    <span class="koboSpan" id="kobo.589.3">
     This is called cache coherency.
    </span>
    <span class="koboSpan" id="kobo.589.4">
     If the threads shared the variables, it would be incorrect not to propagate the changes to all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.590.1">
      the cores.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.591.1">
     In our example, the cache coherency protocol generates quite a lot of traffic inside the CPU because all the threads
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.592.1">
      share the memory region where the variables reside
     </span>
    </em>
    <span class="koboSpan" id="kobo.593.1">
     , even though they don’t from the program’s point of view.
    </span>
    <span class="koboSpan" id="kobo.593.2">
     This is the reason we call it false sharing: the variables are shared because of the way the cache and the cache coherency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.594.1">
      protocol work.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.595.1">
     When we align the data to a 64-byte boundary, each instance occupies 64 bytes.
    </span>
    <span class="koboSpan" id="kobo.595.2">
     This guarantees that they are in their own cache line and no cache coherency traffic is necessary because in this case, there’s no data sharing.
    </span>
    <span class="koboSpan" id="kobo.595.3">
     In this second case, performance is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      much better.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     Let’s use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.598.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.599.1">
     to confirm that this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.600.1">
      really happening.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.601.1">
     First, we run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.602.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.603.1">
     while executing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      sum_random_unaligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     .
    </span>
    <span class="koboSpan" id="kobo.605.2">
     We want to see how many times the program accesses the cache and how many times there’s a cache miss.
    </span>
    <span class="koboSpan" id="kobo.605.3">
     Each time the cache needs to be updated because it contains data that’s also in a cache line in another core
    </span>
    <a id="_idIndexMarker1054">
    </a>
    <span class="koboSpan" id="kobo.606.1">
     counts as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.607.1">
      cache miss:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.608.1">
perf stat -e cache-references,cache-misses ./13x07-false_sharing</span></pre>
   <p>
    <span class="koboSpan" id="kobo.609.1">
     We obtain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.610.1">
      these results:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.611.1">
Performance counter stats for './13x07-false_sharing':
       251,277,877      cache-references
       242,797,999      cache-misses
                        # 96.63% of all cache refs</span></pre>
   <p>
    <span class="koboSpan" id="kobo.612.1">
     Most of the cache references are cache misses.
    </span>
    <span class="koboSpan" id="kobo.612.2">
     This is expected because of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.613.1">
      false sharing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.614.1">
     Now, if we run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      sum_random_aligned
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     , the results are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      quite different:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.618.1">
Performance counter stats for './13x07-false_sharing':
           851,506      cache-references
           231,703      cache-misses
                        # 27.21% of all cache refs</span></pre>
   <p>
    <span class="koboSpan" id="kobo.619.1">
     The number of both cache references and cache misses is much smaller.
    </span>
    <span class="koboSpan" id="kobo.619.2">
     This is because there’s no need to constantly update the caches in all the cores to keep
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.620.1">
      cache coherency.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.621.1">
     In this section, we saw one of the most common performance issues of multithreaded code: false sharing.
    </span>
    <span class="koboSpan" id="kobo.621.2">
     We saw a function example with and without false sharing and the negative impact false
    </span>
    <a id="_idIndexMarker1055">
    </a>
    <span class="koboSpan" id="kobo.622.1">
     sharing has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.623.1">
      on performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.624.1">
     In the next section, we’ll go back to the SPSC lock-free queue we implemented in
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.625.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.626.1">
     and improve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.627.1">
      its performance.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-278">
    <a id="_idTextAnchor277">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     SPSC lock-free queue
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     In
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.630.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.631.1">
     , we implemented
    </span>
    <a id="_idIndexMarker1056">
    </a>
    <span class="koboSpan" id="kobo.632.1">
     an SPSC lock-free queue as an example of how to synchronize access to a data structure from two threads without using locks.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     This queue is accessed by just two threads: one producer pushing data to the queue and one consumer popping data from the queue.
    </span>
    <span class="koboSpan" id="kobo.632.3">
     It’s the easiest queue
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      to synchronize.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.634.1">
     We used two atomic variables to represent the head (buffer index to read) and tail (buffer index to write) of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.635.1">
      the queue:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.636.1">
std::atomic&lt;std::size_t&gt; head_ { 0 };
std::atomic&lt;std::size_t&gt; tail_ { 0 };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.637.1">
     To avoid false sharing, we can change the code to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.638.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.639.1">
alignas(64) std::atomic&lt;std::size_t&gt; head_ { 0 };
alignas(64) std::atomic&lt;std::size_t&gt; tail_ { 0 };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.640.1">
     After this change, we can run the code we implemented to measure the number of operations per second (push/pop) performed by the producer and consumer threads.
    </span>
    <span class="koboSpan" id="kobo.640.2">
     The code can be found in this book’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.641.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.642.1">
     Now, we can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.643.1">
      run
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.644.1">
       perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.646.1">
perf stat -e cache-references,cache-misses ./13x09-spsc_lock_free_queue</span></pre>
   <p>
    <span class="koboSpan" id="kobo.647.1">
     We’ll get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      following results:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.649.1">
101559149 ops/sec
 Performance counter stats for ‹./13x09-spsp_lock_free_queue›:
       532,295,487      cache-references
       219,861,054      cache-misses                     #   41.30% of all cache refs
       9.848523651 seconds time elapsed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     Here, we can see that the queue is capable of about 100 million operations per second.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     Also, there are roughly 41%
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      cache misses.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     Let’s review how the queue works.
    </span>
    <span class="koboSpan" id="kobo.652.2">
     Here, the producer is the only thread writing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.653.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.654.1">
     and the consumer is the only thread writing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.655.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.656.1">
     .
    </span>
    <span class="koboSpan" id="kobo.656.2">
     Still, both threads need to read
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.657.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.658.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.659.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.660.1">
     .
    </span>
    <span class="koboSpan" id="kobo.660.2">
     We’ve declared both atomic variables as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.661.1">
      aligned(64)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.662.1">
     so that they’re guaranteed to be in different cache lines and there’s no false sharing.
    </span>
    <span class="koboSpan" id="kobo.662.2">
     However, there is true sharing.
    </span>
    <span class="koboSpan" id="kobo.662.3">
     True sharing also generates cache
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.663.1">
      coherency traffic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.664.1">
     True sharing means that both threads have shared access to both variables, even if each variable is just written
    </span>
    <a id="_idIndexMarker1057">
    </a>
    <span class="koboSpan" id="kobo.665.1">
     by one thread (and always the same thread).
    </span>
    <span class="koboSpan" id="kobo.665.2">
     In this case, to improve performance, we must reduce sharing, avoiding as much of the read access from each thread to both variables as we can.
    </span>
    <span class="koboSpan" id="kobo.665.3">
     We can’t avoid data sharing, but we can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      reduce it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.667.1">
     Let’s focus on the producer (it’s the same mechanism for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.668.1">
      the consumer):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.669.1">
bool push(const T &amp;item) {
    std::size_t tail = tail_.load(std::memory_order_relaxed);
    std::size_t next_tail = (tail + 1) &amp; (capacity_ - 1);
    if (next_tail == cache_head_) {
        cache_head_ = head_.load(std::memory_order_acquire);
        if (next_tail == cache_head_) {
            return false;
        }
    }
    buffer_[tail] = item;
    tail_.store(next_tail, std::memory_order_release);
    return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.670.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.671.1">
      push()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.672.1">
     function is only called by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.673.1">
      the producer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.674.1">
     Let’s analyze what the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.675.1">
      function does:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.676.1">
      It atomically reads the last index where an item was stored in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.677.1">
       ring buffer:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.678.1">
std::size_t tail = tail_.load(std::memory_order_relaxed);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.679.1">
      It calculates
     </span>
     <a id="_idIndexMarker1058">
     </a>
     <span class="koboSpan" id="kobo.680.1">
      the index where the item will be stored in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.681.1">
       ring buffer:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.682.1">
std::size_t next_tail = (tail + 1) &amp; (capacity_ - 1);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.683.1">
      It checks whether the ring buffer is full.
     </span>
     <span class="koboSpan" id="kobo.683.2">
      However, instead of reading
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.684.1">
       head_
      </span>
     </strong>
     <span class="koboSpan" id="kobo.685.1">
      ,  it reads the cached
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.686.1">
       head value:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.687.1">
    if (next_tail == cache_head_) {</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.688.1">
       Initially, both
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.689.1">
        cache_head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.690.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.691.1">
        cache_tail_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.692.1">
       are set to zero.
      </span>
      <span class="koboSpan" id="kobo.692.2">
       As mentioned previously, the goal of using these two variables is to minimize cache updates between cores.
      </span>
      <span class="koboSpan" id="kobo.692.3">
       The cache variables technique works like so: every time
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.693.1">
        push
       </span>
      </strong>
      <span class="koboSpan" id="kobo.694.1">
       (or
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.695.1">
        pop
       </span>
      </strong>
      <span class="koboSpan" id="kobo.696.1">
       ) is called, we atomically read
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.697.1">
        tail_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.698.1">
       (which is written by the same thread, so no cache updates are required) and generate the next index where we’ll store the item that’s passed as a parameter to the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.699.1">
        push
       </span>
      </strong>
      <span class="koboSpan" id="kobo.700.1">
       function.
      </span>
      <span class="koboSpan" id="kobo.700.2">
       Now, instead of using
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.701.1">
        head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.702.1">
       to check whether the queue is full, we use
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.703.1">
        cache_head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.704.1">
       , which is only accessed by one thread (the producer thread), avoiding any cache coherency traffic.
      </span>
      <span class="koboSpan" id="kobo.704.2">
       If the queue is “full,” then we update
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.705.1">
        cache_head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.706.1">
       by atomically loading
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.707.1">
        head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.708.1">
       .
      </span>
      <span class="koboSpan" id="kobo.708.2">
       After this update, we check again.
      </span>
      <span class="koboSpan" id="kobo.708.3">
       If the second check results in the queue being full, then we
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.709.1">
        return
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.710.1">
         false
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.711.1">
        .
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.712.1">
       The advantage of using these local variables (
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.713.1">
        cache_head_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.714.1">
       for the producer and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.715.1">
        cache_tail_
       </span>
      </strong>
      <span class="koboSpan" id="kobo.716.1">
       for the consumer) is that they reduce true sharing – that is, accessing variables that may be updated in the cache of a different core.
      </span>
      <span class="koboSpan" id="kobo.716.2">
       This will work better when the producer pushes several items in the queue before the consumer tries to get them (same for the consumer).
      </span>
      <span class="koboSpan" id="kobo.716.3">
       Say that the producer inserts 10 items in the queue and the consumer tries to get one item.
      </span>
      <span class="koboSpan" id="kobo.716.4">
       In this case, the first check with the cache variable will tell us that the queue is empty but after updating with the real value, it will be OK.
      </span>
      <span class="koboSpan" id="kobo.716.5">
       The consumer can get nine more items just by checking whether the queue is empty by only reading the
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.717.1">
         cache_tail_
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.718.1">
        variable.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.719.1">
      If the ring buffer
     </span>
     <a id="_idIndexMarker1059">
     </a>
     <span class="koboSpan" id="kobo.720.1">
      is full, then
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.721.1">
       update
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.722.1">
        cache_head_
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.723.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.724.1">
head_.load(std::memory_order_acquire);
        if (next_tail == cache_head_) {
            return false;
        }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.725.1">
      If the buffer is full (not just that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.726.1">
       cache_head_
      </span>
     </strong>
     <span class="koboSpan" id="kobo.727.1">
      needs to be updated), then return
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.728.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.729.1">
      .
     </span>
     <span class="koboSpan" id="kobo.729.2">
      The producer can’t push a new item to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.730.1">
       the queue.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.731.1">
      If the buffer isn’t full, add the item to the ring buffer and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.732.1">
       return
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.733.1">
        true
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.734.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.735.1">
buffer_[tail] = item;
    tail_.store(next_tail, std::memory_order_release);
    return true;</span></pre>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.736.1">
     We’ve potentially reduced the number of times the producer thread will access
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.737.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.738.1">
     and hence reduced cache coherency traffic.
    </span>
    <span class="koboSpan" id="kobo.738.2">
     Think about this case: the producer and the consumer use the queue and the producer calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.739.1">
      push()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.740.1">
     .
    </span>
    <span class="koboSpan" id="kobo.740.2">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.741.1">
      push()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.742.1">
     updates
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.743.1">
      cache_head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.744.1">
     , it may be more than one slot ahead of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.745.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.746.1">
     , which means we don’t need to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.747.1">
      read
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.748.1">
       tail_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.749.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.750.1">
     The same principle applies to the consumer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.751.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.752.1">
       pop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.753.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.754.1">
     Let’s run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.755.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.756.1">
     again after modifying the code to reduce cache
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.757.1">
      coherency traffic:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.758.1">
162493489 ops/sec
 Performance counter stats for ‹./13x09-spsp_lock_free_queue›:
       474,296,947      cache-references
       148,898,301      cache-misses                     #   31.39% of all cache refs
       6.156437788 seconds time elapsed
      12.309295000 seconds user
       0.000999000 seconds sys</span></pre>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     Here, we can that performance has improved by about 60% and that there is a smaller number of cache
    </span>
    <a id="_idIndexMarker1060">
    </a>
    <span class="koboSpan" id="kobo.760.1">
     references and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.761.1">
      cache misses.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.762.1">
     With that, we’ve learned how reducing access to shared data between two threads can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.763.1">
      improve performance.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-279">
    <a id="_idTextAnchor278">
    </a>
    <span class="koboSpan" id="kobo.764.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.765.1">
     In this chapter, we covered three methods you can use to profile your code:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      std::chrono
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     , micro-benchmarking with the Google Benchmark library, and the Linux
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.768.1">
       perf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.769.1">
      tool.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.770.1">
     We also saw how to improve multithreaded programs’ performance by both reducing/eliminating false sharing and reducing true sharing, reducing the cache
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.771.1">
      coherency traffic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.772.1">
     This chapter provided a basic introduction to some profiling techniques that will be very useful as a starting point for further studies.
    </span>
    <span class="koboSpan" id="kobo.772.2">
     As we said at the beginning of this chapter, performance is a complex subject and deserves its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.773.1">
      own book.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-280">
    <a id="_idTextAnchor279">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.775.1">
      Fedor G.
     </span>
     <span class="koboSpan" id="kobo.775.2">
      Pikus,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.776.1">
       The Art of Writing Efficient Programs
      </span>
     </em>
     <span class="koboSpan" id="kobo.777.1">
      , First Edition, Packt
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.778.1">
       Publishing, 2021.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.779.1">
      Ulrich Drepper,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.780.1">
       What Every Programmer Should Know About
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.781.1">
        Memory
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.782.1">
       , 2007.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.783.1">
      Shivam Kunwar,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.784.1">
       Optimizing Multithreading
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.785.1">
        Performance
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.786.1">
       (
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=yN7C3SO4Uj8">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.787.1">
        https://www.youtube.com/watch?v=yN7C3SO4Uj8
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.788.1">
       ).
      </span>
     </span>
    </li>
   </ul>
  </div>
 </body></html>