<html><head></head><body>
<div><div><h1 data-number="1.3" class="calibre5">3</h1>
<h1 id="sigil_toc_id_42" class="calibre5"><a id="x1-530003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang AST</h1>
<p class="hidden">The parsing stage of any compiler generates a parse tree, and the <strong class="calibre12">Abstract</strong> <strong class="calibre12">Syntax Tree (AST) </strong>is a fundamental <a id="dx1-53001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>algorithmic structure that is generated during the parsing of a given input program. The AST serves as the framework for the Clang frontend and is the primary tool for various Clang utilities, including linters. Clang offers sophisticated tools for searching (or matching) various AST nodes. These tools are implemented using a <strong class="calibre12">Domain-Specific Language (DSL)</strong>. It’s crucial to <a id="dx1-53002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>understand its implementation to use it effectively.</p>
<p class="hidden">We will start with the basic data structures and the class hierarchy that Clang uses to construct the AST. Additionally, we will explore the methods used for AST traversal and highlight some helper classes that facilitate node matching during this traversal. We will cover the following topics:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Basic blocks used to construct the AST</p></li>
<li class="calibre14"><p class="calibre15">How the AST can be traversed</p></li>
<li class="calibre14"><p class="calibre15">The recursive visitor as the fundamental AST traversal tool</p></li>
<li class="calibre14"><p class="calibre15">AST matchers and their role in assisting with AST traversal</p></li>
<li class="calibre14"><p class="calibre15">Clang-Query as the basic tool to explore AST internals</p></li>
<li class="calibre14"><p class="calibre15">Compilation errors and their impact on the AST</p></li>
</ul>
<p class="hidden"><a id="x1-53003r127" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h2 data-number="1.3.1" id="sigil_toc_id_43" class="likechapterhead">3.1  <a id="x1-540001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter3 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3</a>. <a id="x1-54001r129" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.2" id="sigil_toc_id_44" class="likechapterhead">3.2  <a id="x1-550002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>AST</h2>
<p class="hidden">The AST is usually depicted as a tree, with its leaf nodes corresponding to various objects, such as function declarations <a id="dx1-55001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and loop bodies. Typically, the AST represents the result of syntax analysis, i.e., parsing. Clang’s AST nodes were designed to be immutable. This design requires that the Clang AST stores results from semantic analysis, meaning the Clang AST represents the outcomes of both syntax and semantic analyses.</p>

<p class="hidden">Important note</p>

<p class="hidden">Although Clang also employs an AST, it’s worth noting that the Clang AST is not a true tree. The presence of backward edges makes ”graph” a more appropriate term for describing Clang’s AST.</p>

<p class="hidden">Typical tree structure implemented in C++ has all nodes derived from a base class. Clang uses a different approach. It splits different C++ constructions into separate groups with basic classes for each of them:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Statements: <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Stmt</code> is the basic class for all statements. That includes ordinary statements such as <code class="calibre13">if </code>statements (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">IfStmt</code> class) as well as expressions and other C++ constructions.</p></li>
<li class="calibre14"><p class="calibre15">Declarations: <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Decl</code> is the base class for declarations. This includes a variable, typedef, function, struct, and more. There is also a separate base class for declarations with context, that is, declarations that might contain other declarations. The class is called <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclContext</code>. The declarations contained in <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclContext</code> can be accessed using the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclContext</code><code class="calibre13">::</code><code class="calibre13">decls</code> method. Translation units (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">TranslationUnitDecl</code> class) and namespaces (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">NamespaceDecl</code> class) are typical examples of declarations with context.</p></li>
<li class="calibre14"><p class="calibre15">Types: C++ has a rich type system. It includes basic types such as <code class="calibre13">int</code> for integers as well as custom defined types and type redefinition via <code class="calibre13">typedef</code> or <code class="calibre13">using</code>. Types in C++ can have qualifiers such as <code class="calibre13">const</code> and can represent different memory addressing modes, aka pointers, references, and so on. Clang uses <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> as the basic class for type representations in AST.</p></li>
</ul>
<p class="hidden">It’s worth noting that <a id="dx1-55002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>there are additional relations between the groups. For example, the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclStmt</code> class, which inherits from <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Stmt</code>, has methods to retrieve corresponding declarations. Additionally, expressions (represented by the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Expr</code> class), which inherit from <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Stmt</code> have methods to work with types. Let’s look at all the groups in detail. <a id="x1-55003r111" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.3.2.1" id="sigil_toc_id_45" class="likesectionhead">3.2.1  <a id="x1-560001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Statements</h3>
<p class="hidden"><code class="calibre13">Stmt</code> is the basic class for all statements. The statements can be combined into two sets (see <a href="#Figure3.1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.1</a>). The first one <a id="dx1-56001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>contains statements with values and the opposite group is for statements without values.</p>
<div><div><img src="img/Figure3.1_B19722.png" alt="Figure 3.1: Clang AST: statements " class="calibre36"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 3.1</strong>: Clang AST: statements </p>
</div>
<p class="hidden">The group of statements without a value consist of different C++ constructions such as <code class="calibre13">if </code>statements (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">IfStmt</code> class) or compound statements (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CompoundStmt</code> class). The majority of all <a id="dx1-56004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>statements fall into the group.</p>
<p class="hidden">The group of statements with a value consists of one base class <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ValueStmt</code> that has several children, such as <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">LabelStmt</code> (for label representation) or <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ExprStmt</code> (for expression representation), see <a href="#Figure3.2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.2</a>.</p>
<div><div><img src="img/Figure3.2_B19722.png" alt="Figure 3.2: Clang AST: statements with a value " class="calibre37"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 3.2</strong>: Clang AST: statements with a value </p>
</div>
<p class="hidden"><a id="x1-56007r131" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.3.2.2" id="sigil_toc_id_46" class="likesectionhead">3.2.2  <a id="x1-570002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Declarations</h3>
<p class="hidden">Declarations can also be combined into two primary groups: declarations with context and without. Declarations with <a id="dx1-57001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>context can be considered as placeholders for other declarations. For example, a C++ namespace as well as a translation unit or function declaration might contain other declarations. A declaration of a friend entity (<code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclFriend</code>) can be considered an example of a declaration without context.</p>
<p class="hidden">It has to be noted that classes that are inherited from <code class="calibre13">DeclContext</code> also have <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Decl</code> as their top parent.</p>
<p class="hidden">Some declarations can be redeclared, as in the following example:</p>
<pre class="source-code">1 extern int a; 
 
2 int a = 1;</pre>
<p class="hidden"><a id="x1-57005r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-57006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.3</strong>: Declarations example: redeclaration.cpp </p>
<p class="hidden">Such declarations have an additional parent that is implemented via a <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Redeclarable</code><code class="calibre13">&lt;...&gt;</code> template. <a id="x1-57007r134" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.3.2.3" id="sigil_toc_id_47" class="likesectionhead">3.2.3  <a id="x1-580003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Types</h3>
<p class="hidden">C++ is a statically typed language, which means that the types of variables must be declared at compile time. The types allow the <a id="dx1-58001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiler to make a reasonable conclusion about the program’s meaning, which makes types an important part of semantic analysis. <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> is the basic class for types in Clang.</p>
<p class="hidden">Types in C/C++ might have qualifiers that are called CV-qualifiers, as specified in the standard [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, basic.type.qualifier]. CV here stands for two keywords <code class="calibre13">const</code> and <code class="calibre13">volatile</code> that can be used as the qualifier for a type.</p>

<p class="hidden">Important note</p>

<p class="hidden">The C99 standard has an additional type qualifier, <code class="calibre13">restrict</code>, which is also supported by Clang [<a href="B19722_Bib.xhtml#Xstandard_c99" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">25</a>, 6.7.3]. The type qualifier indicates to the compiler that, for the lifetime of the pointer, no other pointer will be used to access the object it points to. This allows the compiler to perform optimizations such as vectorization that wouldn’t be possible otherwise. <code class="calibre13">restrict</code> helps limit pointer aliasing effects, which occur when multiple pointers reference the same memory location, thereby aiding optimizations. However, if the programmer’s declaration of intent is not followed, and the object is accessed by an independent pointer, it results in undefined behavior.</p>

<p class="hidden">Clang has a special class to support a type with a qualifier, <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">QualType</code>, which is a pair of a pointer to <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> and a bit mask with information about the type qualifier. The class has a method to retrieve a pointer to the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> and check different qualifiers. The following code (LLVM 18.x, <code class="calibre13">clang/lib/AST/ExprConstant.cpp</code>, <em class="calibre11">Line</em> <em class="calibre11">3918</em>) shows how we can check a type for a const qualifier:</p>
<pre class="source-code">  bool checkConst(QualType QT) { 
 

    // Assigning to a const object has undefined behavior. 
 

    if (QT.isConstQualified()) { 
 

      Info.FFDiag(E, diag::note_constexpr_modify_const_type) &lt;&lt; QT; 
 

      return false; 
 
    } 
 
    return true; 
 
  }</pre>
<p class="hidden"><a id="x1-58011r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-58012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.4</strong>: checkConst implementation from clang/lib/AST/ExprConstant.cpp </p>
<p class="hidden">It’s worth mentioning that <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">QualType</code> has <code class="calibre13">operator</code><code class="calibre13">-&gt;()</code> and <code class="calibre13">operator</code><code class="calibre13">*()</code> implemented, that is, it can be considered as a smart pointer for the underlying <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> class.</p>
<p class="hidden">In addition to qualifiers, the type can <a id="dx1-58013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>have additional information that represents different memory address models. For instance, there can be a pointer to an object or reference. <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code> has the following helper methods to check different address models:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code><code class="calibre13">::</code><code class="calibre13">isPointerType</code><code class="calibre13">()</code> for pointer type check</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Type</code><code class="calibre13">::</code><code class="calibre13">isReferenceType</code><code class="calibre13">()</code> for reference type check</p></li>
</ul>
<p class="hidden">Types in C/C++ can also use aliases, which are introduced by using the <code class="calibre13">typedef</code> or <code class="calibre13">using</code> keywords. The following code defines <code class="calibre13">foo</code> and <code class="calibre13">bar</code> as aliases for the <code class="calibre13">int</code> type.</p>
<pre id="listing-22" class="source-code">1using foo = int; 
 
2 typedef int bar;</pre>
<p class="hidden"><a id="x1-58016r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-58017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.5</strong>: Type alias declarations </p>
<p class="hidden">Original types, <code class="calibre13">int</code> in our case, are called canonical. You can test whether the type is canonical or not using the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">QualType</code><code class="calibre13">::</code><code class="calibre13">isCanonical</code><code class="calibre13">()</code> method. <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">QualType</code> also provides a method to retrieve the canonical type from an alias: <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">QualType</code><code class="calibre13">::</code><code class="calibre13">getCanonicalType</code><code class="calibre13">()</code>.</p>
<p class="hidden">After gaining knowledge of the basic <a id="dx1-58018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>blocks used for the AST in Clang, it’s time to investigate how these blocks can be used for AST traversal. This is the basic operation used by the compiler and compiler tools, and we will use it extensively throughout the book. <a id="x1-58019r130" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.3.3" id="sigil_toc_id_48" class="likechapterhead">3.3  <a id="x1-590003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>AST traversal</h2>
<p class="hidden">The compiler requires traversal of the AST to generate IR code. Thus, having a well-structured data structure for tree traversal is paramount for AST design. To put it another way, the design of the AST should prioritize facilitating easy tree traversal. A standard approach in many <a id="dx1-59001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>systems is to have a common base class for all AST nodes. This class typically provides a method to retrieve the node’s children, allowing for tree traversal using popular algorithms such as Breadth-First Search (BFS) [<a href="B19722_Bib.xhtml#Xbook_cormen2009introduction" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">19</a>]. Clang, however, takes a different approach: its AST nodes don’t share a common ancestor. This poses the question: how is tree traversal organized in Clang?</p>
<p class="hidden">Clang employs three unique techniques:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">The Curiously Recurring Template Pattern (CRTP) for visitor class definition</p></li>
<li class="calibre14"><p class="calibre15">Ad hoc methods tailored specifically for different nodes</p></li>
<li class="calibre14"><p class="calibre15">Macros, which can be perceived as the connecting layer between the ad hoc methods and CRTP</p></li>
</ul>
<p class="hidden">We will explore these techniques through a simple program designed to identify function definitions and display the function names together with their parameters. <a id="x1-59002r137" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.3.3.1" id="sigil_toc_id_49" class="likesectionhead">3.3.1  <a id="x1-600001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>DeclVisitor test tool</h3>
<p class="hidden">Our test tool will build upon the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclVisitor</code> class, which is defined as a straightforward visitor <a id="dx1-60001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>class aiding in the creation of <a id="dx1-60002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>visitors for C/C++ declarations.</p>
<p class="hidden">We will use the same CMake file as was created for our first Clang tool (see <a href="B19722_01.xhtml#x1-30031r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.13</a>). The sole <a id="dx1-60003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>addition to the new tool <a id="dx1-60004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is the <code class="calibre13">clangAST </code>library. The resultant <code class="calibre13">CMakeLists.txt </code>is shown in <a href="#x1-60029r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.6</a>:</p>
<pre class="source-code">2 project("declvisitor") 
 
3  
 
4 if ( NOT DEFINED ENV{LLVM_HOME}) 
 

5   message(FATAL_ERROR "$LLVM_HOME is not defined") 
 

6 else() 
 
7   message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

9   set(LLVM_LIB ${LLVM_HOME}/lib) 
 

10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

11   find_package(LLVM REQUIRED CONFIG) 
 

12   include_directories(${LLVM_INCLUDE_DIRS}) 
 

13   link_directories(${LLVM_LIBRARY_DIRS}) 
 




14   set(SOURCE_FILE DeclVisitor.cpp) 
 

15   add_executable(declvisitor ${SOURCE_FILE}) 
 

16   set_target_properties(declvisitor PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

17   target_link_libraries(declvisitor 
 
18     LLVMSupport 
 

19     clangAST 
 
20     clangBasic 
 
21     clangFrontend 
 

22     clangSerialization 
 
23     clangTooling 
 
24   )</pre>
<p class="hidden"><a id="x1-60029r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.6</strong>: CMakeLists.txt file for DeclVisitor test tool </p>
<p class="hidden">The <code class="calibre13">main</code> function of our tool is presented below:</p>
<pre class="source-code">1 #include "clang/Tooling/CommonOptionsParser.h" 
 

2 #include "clang/Tooling/Tooling.h" 
 

3 #include "llvm/Support/CommandLine.h" // llvm::cl::extrahelp 
 

4  
 
5 #include "FrontendAction.hpp" 
 
6  
 
7 namespace { 
 

8 llvm::cl::OptionCategory TestCategory("Test project"); 
 

9 llvm::cl::extrahelp 
 
10     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); 
 

11 } // namespace 
 
12  
 
13 int main(int argc, const char **argv) { 
 

14   llvm::Expected&lt;clang::tooling::CommonOptionsParser&gt; OptionsParser = 
 

15       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); 
 

16   if (!OptionsParser) { 
 
17     llvm::errs() &lt;&lt; OptionsParser.takeError(); 
 

18     return 1; 
 
19   } 
 
20   clang::tooling::ClangTool Tool(OptionsParser-&gt;getCompilations(), 
 

21                                  OptionsParser-&gt;getSourcePathList()); 
 

22   return Tool.run(clang::tooling::newFrontendActionFactory&lt; 
 

23                       clangbook::declvisitor::FrontendAction&gt;() 
 

24                       .get()); 
 
25 }</pre>
<p class="hidden"><a id="x1-60057r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60058" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.7</strong>: The main function of the DeclVisitor test tool </p>
<p class="hidden">From <em class="calibre11">Lines 5 and 23</em>, it’s evident that we <a id="dx1-60059" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>employ a custom frontend <a id="dx1-60060" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>action specific to our project: <code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">declvisitor</code><code class="calibre13">::</code><code class="calibre13">FrontendAction</code>.</p>
<p class="hidden">The following is the code for this class:</p>
<pre class="source-code">1 #include "Consumer.hpp" 
 
2 #include "clang/Frontend/FrontendActions.h" 
 

3  
 
4 namespace clangbook { 
 
5 namespace declvisitor { 
 

6 class FrontendAction : public clang::ASTFrontendAction { 
 

7 public: 
 
8   virtual std::unique_ptr&lt;clang::ASTConsumer&gt; 
 

9   CreateASTConsumer(clang::CompilerInstance &amp;CI, 
 

10                     llvm::StringRef File) override { 
 

11     return std::make_unique&lt;Consumer&gt;(); 
 
12   } 
 
13 }; 
 

14 } // namespace declvisitor 
 
15 } // namespace clangbook</pre>
<p class="hidden"><a id="x1-60077r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60078" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.8</strong>: Custom FrontendAction class for the DeclVisitor test tool </p>
<p class="hidden">You’ll notice that we have overridden the <code class="calibre13">CreateASTConsumer</code> function from <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTFrontendAction</code> class to <a id="dx1-60079" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>instantiate an object of our custom AST <a id="dx1-60080" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>consumer class <code class="calibre13">Consumer</code>, defined in <code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">declvisitor</code> namespace, as highlighted in <a href="#x1-60077r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.8</a>, <em class="calibre11">Lines 9-12</em>.</p>
<p class="hidden">The implementation for the class is as follows:</p>
<pre class="source-code">1 #include "Visitor.hpp" 
 
2 #include "clang/Frontend/ASTConsumers.h" 
 

3  
 
4 namespace clangbook { 
 
5 namespace declvisitor { 
 

6 class Consumer : public clang::ASTConsumer { 
 

7 public: 
 
8   Consumer() : V(std::make_unique&lt;Visitor&gt;()) {} 
 

9  
 
10   virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) override { 
 

11     V-&gt;Visit(Context.getTranslationUnitDecl()); 
 

12   } 
 
13  
 
14 private: 
 
15   std::unique_ptr&lt;Visitor&gt; V; 
 
16 }; 
 

17 } // namespace declvisitor 
 
18 } // namespace clangbook</pre>
<p class="hidden"><a id="x1-60100r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60101" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.9</strong>: Consumer class for the DeclVisitor test tool </p>
<p class="hidden">Here, we can see <a id="dx1-60102" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that we’ve created a sample <a id="dx1-60103" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>visitor and invoked it using an overridden method <code class="calibre13">HandleTranslationUnit</code> from the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTConsumer</code> class (see <a href="#x1-60100r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.9</a>, <em class="calibre11">Line 11</em>).</p>
<p class="hidden">However, the most intriguing portion is the code for the visitor:</p>
<pre class="source-code">1 #include "clang/AST/DeclVisitor.h" 
 
2  
 

3 namespace clangbook { 
 
4 namespace declvisitor { 
 

5 class Visitor : public clang::DeclVisitor&lt;Visitor&gt; { 
 

6 public: 
 
7   void VisitFunctionDecl(const clang::FunctionDecl *FD) { 
 

8     llvm::outs() &lt;&lt; "Function: ’" &lt;&lt; FD-&gt;getName() &lt;&lt; "’\n"; 
 

9     for (auto Param : FD-&gt;parameters()) { 
 

10       Visit(Param); 
 
11     } 
 
12   } 
 
13   void VisitParmVarDecl(const clang::ParmVarDecl *PVD) { 
 

14     llvm::outs() &lt;&lt; "\tParameter: ’" &lt;&lt; PVD-&gt;getName() &lt;&lt; "’\n"; 
 

15   } 
 
16   void VisitTranslationUnitDecl(const clang::TranslationUnitDecl *TU) { 
 

17     for (auto Decl : TU-&gt;decls()) { 
 

18       Visit(Decl); 
 
19     } 
 
20   } 
 
21 }; 
 

22 } // namespace declvisitor 
 
23 } // namespace clangbook</pre>
<p class="hidden"><a id="x1-60128r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60129" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.10</strong>: Visitor class implementation </p>
<p class="hidden">We will explore the <a id="dx1-60130" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>code in more depth later. For now, we observe that it prints the function name at <em class="calibre11">Line 8 </em>and the parameter name at <em class="calibre11">Line</em> <em class="calibre11">14</em>.</p>
<p class="hidden">We can compile our program using the <a id="dx1-60131" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>same sequence of commands as we did for our test project, as detailed in <a href="B19722_01.xhtml#x1-300004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.4</em></a><em class="calibre11">, Test project – syntax</em> <em class="calibre11">check with a Clang tool</em>.</p>
<pre id="verbatim-47" class="console">export LLVM_HOME=&lt;...&gt;/llvm-project/install
mkdir build
cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ...
ninja</pre>
<p class="hidden"><a id="x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60133" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.11</strong>: Configure and build commands for the DeclVisitor test tool </p>
<p class="hidden">As you may notice, we used the <code class="calibre13">-DCMAKE</code><code class="calibre13">_BUILD</code><code class="calibre13">_TYPE=Debug </code>option for CMake. The option we are using will slow <a id="dx1-60134" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>down the overall performance, but we <a id="dx1-60135" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>use it because we might want to investigate the resulting program under debugger.</p>

<p class="hidden">Important note</p>

<p class="hidden">The build command we used for our tool assumes that the required libraries are installed under the <code class="calibre13">&lt;...&gt;/llvm-project/install </code>folder, which was specified with the<code class="calibre13">-DCMAKE</code><code class="calibre13">_INSTALL</code><code class="calibre13">_PREFIX </code>option during the CMake configure command, as described in <a href="B19722_01.xhtml#x1-300004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.4</em></a><em class="calibre11">, Test project –</em> <em class="calibre11">syntax check with a Clang tool</em>. See <a href="B19722_01.xhtml#x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.12</a>:</p>
<pre id="listing-23" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_USE_LINKER=gold -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm</pre>
<p class="hidden">The required build artifacts must be installed using the <code class="calibre13">ninja install</code> command.</p>

<p class="hidden">We will use the same program we referenced in our previous investigations (see <a href="B19722_02.xhtml#x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.5</a>) to also study AST traversal:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) 
 

3     return a; 
 
4   return b; 
 
5 }</pre>
<p class="hidden"><a id="x1-60143r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60144" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.12</strong>: Test program max.cpp </p>
<p class="hidden">This program <a id="dx1-60145" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>consists of a single function, <code class="calibre13">max</code>, which <a id="dx1-60146" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>takes two parameters, <code class="calibre13">a</code> and <code class="calibre13">b</code>, and returns the maximum of the two.</p>
<p class="hidden">We can run our program as follows:</p>
<pre id="verbatim-48" class="console">$ ./declvisitor max.cpp -- -std=c++17
...
Function: ’max’
        Parameter: ’a’
        Parameter: ’b’</pre>
<p class="hidden"><a id="x1-60147r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-60148" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.13</strong>: The result of running the declvisitor utility on a test file </p>

<p class="hidden">Important note</p>

<p class="hidden">We used ’- -’ to pass additional arguments to the compiler in <a href="#x1-60147r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.13</a>, specifically indicating that we want to use C++17 with the option ’-std=c++17’. We can also pass other compiler arguments. An alternative is to specify the compilation database path with the ’-p’ option, as shown below:</p>
<pre id="verbatim-49" class="console">$ ./declvisitor max.cpp -p &lt;path&gt;</pre>
<p class="hidden">Here, <code class="calibre13">&lt;path&gt; </code>is the path to the folder containing the compilation database. You can find more information about the compilation database in <a href="B19722_09.xhtml#x1-1810009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 9</em></a><em class="calibre11">, Appendix 1: Compilation Database</em>.</p>

<p class="hidden">Let’s investigate the <code class="calibre13">Visitor </code>class implementation in detail. <a id="x1-60149r142" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.3.3.2" id="sigil_toc_id_50" class="likesectionhead">3.3.2  <a id="x1-610002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Visitor implementation</h3>
<p class="hidden">Let’s delve into the <code class="calibre13">Visitor </code>code (see <a href="#x1-60128r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.10</a>). Firstly, you’ll notice an unusual construct where our <a id="dx1-61001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>class is derived from a base <a id="dx1-61002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>class parameterized by our own class:</p>
<pre class="source-code">5 class Visitor : public clang::DeclVisitor&lt;Visitor&gt; {
                                                                     

                                                                     </pre>
<p class="hidden"><a id="x1-61005r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.14</strong>: Visitor class declaration </p>
<p class="hidden">This construct is <a id="dx1-61007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>known as the Curiously Recurring Template Pattern, or CRTP.</p>
<p class="hidden">The Visitor class has several callbacks that are triggered when a corresponding AST node is encountered. The first callback targets the AST node representing a function declaration:</p>
<pre class="source-code">7   void VisitFunctionDecl(const clang::FunctionDecl *FD) { 
 

8     llvm::outs() &lt;&lt; "Function: ’" &lt;&lt; FD-&gt;getName() &lt;&lt; "’\n"; 
 

9     for (auto Param : FD-&gt;parameters()) { 
 

10       Visit(Param); 
 
11     } 
 
12   }</pre>
<p class="hidden"><a id="x1-61015r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.15</strong>: FunctionDecl callback </p>
<p class="hidden">As shown in <a href="#x1-61015r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.15</a>, the function name is printed on <em class="calibre11">Line 8</em>. Our subsequent step involves printing the names of the parameters. To retrieve the function parameters, we can utilize the <code class="calibre13">parameters</code><code class="calibre13">()</code> method from the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FunctionDecl</code> class. This method was previously mentioned as an ad hoc approach for AST traversal. Each AST node provides its own methods to access child nodes. Since we have an AST node of a specific type (i.e., <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FunctionDecl</code><code class="calibre13">*</code>) as an argument, we can employ these methods.</p>
<p class="hidden">The function parameter is passed to the <code class="calibre13">Visit</code><code class="calibre13">(...)</code> method of the base class <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclVisitor</code><code class="calibre13">&lt;&gt;</code>, as shown in <em class="calibre11">Line 12 </em>of <a href="#x1-61015r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.15</a>. This call is subsequently transformed into another callback, specifically for the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ParmVarDecl</code> AST node:</p>
<pre class="source-code">13   void VisitParmVarDecl(const clang::ParmVarDecl *PVD) { 
 

14     llvm::outs() &lt;&lt; "\tParameter: ’" &lt;&lt; PVD-&gt;getName() &lt;&lt; "’\n"; 
 

15   }</pre>
<p class="hidden"><a id="x1-61021r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.16</strong>: ParmVarDecl callback </p>
<p class="hidden">You might be wondering how this conversion is achieved. The answer lies in a combination of the CRTP and C/C++ macros. To understand this, we need to dive into the <code class="calibre13">Visit</code><code class="calibre13">()</code> method implementation of the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DeclVisitor</code><code class="calibre13">&lt;&gt;</code> class. This implementation heavily relies on C/C++ macros, so to get a <a id="dx1-61023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>glimpse of the actual code, we must expand these macros. This can be <a id="dx1-61024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>done using the <code class="calibre13">shell</code>-E compiler option. Let’s make some modifications to <code class="calibre13">CMakeLists.txt </code>and introduce a new custom target.</p>
<pre class="source-code">                                                                     

                                                                     
25   add_custom_command( 
 
26     OUTPUT ${SOURCE_FILE}.preprocessed 
 

27     COMMAND ${CMAKE_CXX_COMPILER} -E -I ${LLVM_HOME}/include ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCE_FILE} &gt; ${SOURCE_FILE}.preprocessed 
 

28     DEPENDS ${SOURCE_FILE} 
 
29     COMMENT "Preprocessing ${SOURCE_FILE}" 
 

30   ) 
 
31   add_custom_target(preprocess ALL DEPENDS ${SOURCE_FILE}.preprocessed)</pre>
<p class="hidden"><a id="x1-61033r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61034" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.17</strong>: Custom target to expand macros </p>
<p class="hidden">We can run the target as follows:</p>
<pre id="verbatim-50" class="console">$ ninja preprocess</pre>
<p class="hidden">The resulting file can be located in the build folder specified earlier, named <code class="calibre13">DeclVisitor.cpp.preprocessed </code>. The build folder containig the file was specified by us earlier when executing the cmake command (see <a href="#x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.11</a>). Within this file, the generated code for the <code class="calibre13">Visit</code><code class="calibre13">()</code> method appears as follows:</p>
<pre id="listing-24" class="source-code">1RetTy Visit(typename Ptr&lt;Decl&gt;::type D) { 
 

2   switch (D-&gt;getKind()) { 
 
3    ... 
 
4    case Decl::ParmVar: return static_cast&lt;ImplClass*&gt;(this)-&gt;VisitParmVarDecl(static_cast&lt;typename Ptr&lt;ParmVarDecl&gt;::type&gt;(D)); 
 

5    ... 
 
6   } 
 
7 }</pre>
<p class="hidden"><a id="x1-61042r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.18</strong>: Generated code for Visit() method </p>
<p class="hidden">This code showcases the use of the CRTP in Clang. In this context, CRTP is employed to redirect back to our <code class="calibre13">Visitor</code> class, which is referenced as <code class="calibre13">ImplClass</code>. CRTP allows the base class to call a method from an inherited class. This pattern can serve as an alternative to virtual functions and <a id="dx1-61044" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>offers several advantages, the most <a id="dx1-61045" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>notable being performance-related. Specifically, the method call is resolved at compile time, eliminating the need for a vtable lookup associated with virtual method calls.</p>
<p class="hidden">The code was generated using C/C++ macros, as demonstrated here. This particular code was sourced from the <code class="calibre13">clang/include/clang/AST/DeclVisitor.h </code>header:</p>
<pre class="source-code">34 #define DISPATCH(NAME, CLASS) \ 
 

35   return static_cast&lt;ImplClass*&gt;(this)-&gt;Visit##NAME(static_cast&lt;PTR(CLASS)&gt;(D))</pre>
<p class="hidden"><a id="x1-61049r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-61050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.19</strong>: DISPATCH macro definition from clang/include/clang/AST/DeclVisitor.h </p>
<p class="hidden"><code class="calibre13">NAME</code> from <a href="#x1-61049r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.19</a> is replaced with the node name; in our case, it’s <code class="calibre13">ParmVarDecl</code>.</p>
<p class="hidden"><code class="calibre13">DeclVisitor</code> is used to traverse C++ declarations. Clang also has <code class="calibre13">StmtVisitor</code> and <code class="calibre13">TypeVisitor</code> to traverse statements and types, respectively. These are built on the same principles as we considered in our example with the declaration visitor. However, these visitors come with several issues. They can only be used with specific groups of AST nodes. For instance, <code class="calibre13">DeclVisitor</code> can only be used with descendants of the <code class="calibre13">Decl</code> class. Another limitation is that we are required to implement recursion. For example, we set up recursion to traverse the function declaration in lines 9-11 (<a href="#x1-60128r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.10</a>). The same recursion was employed to traverse <a id="dx1-61051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>declarations within the translation unit (see <a href="#x1-60128r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.10</a>, <em class="calibre11">Lines 17-19</em>). This brings up another concern: it’s possible to miss some parts of the recursion. For instance, our code will not function correctly if the <code class="calibre13">max</code> function declaration is specified inside a namespace. To address such scenarios, we would need to implement an additional visit method specifically for namespace declarations.</p>
<p class="hidden">These challenges are addressed by the recursive visitor, which we will discuss shortly. <a id="x1-61052r141" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.3.4" id="sigil_toc_id_51" class="likechapterhead">3.4  <a id="x1-620004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Recursive AST visitor</h2>
<p class="hidden">Recursive AST visitors address the limitations observed with specialized visitors. We will create the same program, which searches <a id="dx1-62001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for and prints function declarations along with their parameters, but we’ll use a recursive visitor this time.</p>
<p class="hidden">The <code class="calibre13">CMakeLists.txt </code>for recursive visitor test tool will be used in a similar way as before. Only the project name (<em class="calibre11">Lines 2 and 15-17 </em>in <a href="#x1-62028r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.20</a>) and source filename (<em class="calibre11">Line 14 </em>in <a href="#x1-62028r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.20</a> were changed:</p>
<pre class="source-code">1 cmake_minimum_required(VERSION 3.16) 
 

2 project("recursivevisitor") 
 
3  
 
4 if ( NOT DEFINED ENV{LLVM_HOME}) 
 

5   message(FATAL_ERROR "$LLVM_HOME is not defined") 
 

6 else() 
 
7   message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

9   set(LLVM_LIB ${LLVM_HOME}/lib) 
 

10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

11   find_package(LLVM REQUIRED CONFIG) 
 

12   include_directories(${LLVM_INCLUDE_DIRS}) 
 




13   link_directories(${LLVM_LIBRARY_DIRS}) 
 

14   set(SOURCE_FILE RecursiveVisitor.cpp) 
 

15   add_executable(recursivevisitor ${SOURCE_FILE}) 
 

16   set_target_properties(recursivevisitor PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

17   target_link_libraries(recursivevisitor 
 

18     LLVMSupport 
 
19     clangAST 
 
20     clangBasic 
 

21     clangFrontend 
 
22     clangSerialization 
 

23     clangTooling 
 
24   ) 
 
25 endif()</pre>
<p class="hidden"><a id="x1-62028r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-62029" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.20</strong>: CMakeLists.txt file for the RecursiveVisitor test tool </p>
<p class="hidden">The <code class="calibre13">main</code> function for our tool is <a id="dx1-62030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>similar to the ‘DeclVisitor‘ one defined in <a href="#x1-60057r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.7</a>.</p>
<pre class="source-code">1 #include "clang/Tooling/CommonOptionsParser.h" 
 

2 #include "clang/Tooling/Tooling.h" 
 

3 #include "llvm/Support/CommandLine.h" // llvm::cl::extrahelp 
 

4  
 
5 #include "FrontendAction.hpp" 
 
6  
 
7 namespace { 
 

8 llvm::cl::OptionCategory TestCategory("Test project"); 
 

9 llvm::cl::extrahelp 
 
10     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); 
 

11 } // namespace 
 
12  
 
13 int main(int argc, const char **argv) { 
 

14   llvm::Expected&lt;clang::tooling::CommonOptionsParser&gt; OptionsParser = 
 

15       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); 
 

16   if (!OptionsParser) { 
 
17     llvm::errs() &lt;&lt; OptionsParser.takeError(); 
 

18     return 1; 
 
19   } 
 
20   clang::tooling::ClangTool Tool(OptionsParser-&gt;getCompilations(), 
 

21                                  OptionsParser-&gt;getSourcePathList()); 
 

22   return Tool.run(clang::tooling::newFrontendActionFactory&lt; 
 

23                       clangbook::recursivevisitor::FrontendAction&gt;() 
 

24                       .get()); 
 
25 }</pre>
<p class="hidden"><a id="x1-62057r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-62058" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.21</strong>: The main function for the RecursiveVisitor test tool </p>
<p class="hidden">As you can see, we changed only the <a id="dx1-62059" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>namespace name for our custom frontend action at <em class="calibre11">Line 23</em>.</p>
<p class="hidden">The code for the frontend action and consumer is the same as in <a href="#x1-60077r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.8</a> and <a href="#x1-60100r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.9</a>, with the only difference being the namespace change from <code class="calibre13">declvisitor</code> to <code class="calibre13">recursivevisitor</code>. The most interesting part of the program is the <code class="calibre13">Visitor </code>class implementation.</p>
<pre class="source-code">1 #include "clang/AST/RecursiveASTVisitor.h" 
 
2  
 

3 namespace clangbook { 
 
4 namespace recursivevisitor { 
 

5 class Visitor : public clang::RecursiveASTVisitor&lt;Visitor&gt; { 
 

6 public: 
 
7   bool VisitFunctionDecl(const clang::FunctionDecl *FD) { 
 

8     llvm::outs() &lt;&lt; "Function: ’" &lt;&lt; FD-&gt;getName() &lt;&lt; "’\n"; 
 

9     return true; 
 
10   } 
 
11   bool VisitParmVarDecl(const clang::ParmVarDecl *PVD) { 
 

12     llvm::outs() &lt;&lt; "\tParameter: ’" &lt;&lt; PVD-&gt;getName() &lt;&lt; "’\n"; 
 

13     return true; 
 
14   } 
 
15 }; 
 
16 } // namespace recursivevisitor 
 

17 } // namespace clangbook</pre>
<p class="hidden"><a id="x1-62078r22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-62079" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.22</strong>: Visitor class implementation </p>
<p class="hidden">There are several changes compared to the code for ‘DeclVisitor‘ (see <a href="#x1-60128r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.10</a>). The first is that recursion isn’t implemented. We’ve only implemented the callbacks for nodes of interest to us. A reasonable question arises: how is the recursion controlled? The answer lies in another change: our callbacks now <a id="dx1-62080" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>return a boolean result. The <code class="calibre13">false</code> value indicates that the recursion should stop, while <code class="calibre13">true</code> signals the visitor to continue the traversal.</p>
<p class="hidden">The program can be compiled using the same sequence of commands as we used previously. See <a href="#x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.11</a>.</p>
<p class="hidden">We can run our program as follows, see <a href="#x1-62081r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.23</a>:</p>
<pre id="verbatim-51" class="console">$ ./recursivevisitor max.cpp -- -std=c++17
...
Function: ’max’
        Parameter: ’a’
        Parameter: ’b’</pre>
<p class="hidden"><a id="x1-62081r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-62082" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.23</strong>: The result of running the recursivevisitor utility on a test file </p>
<p class="hidden">As we can see, it produces the same <a id="dx1-62083" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>result as we obtained with the DeclVisitor implementation. The AST traversal techniques considered so far are not the only ways for AST traversal. Most of the tools that we will consider later will use a different approach based on AST matchers. <a id="x1-62084r169" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.5" id="sigil_toc_id_52" class="likechapterhead">3.5  <a id="x1-630005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>AST matchers</h2>
<p class="hidden">AST matchers [<a href="B19722_Bib.xhtml#Xllvm_astmatchers" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">16</a>] provide another approach for locating specific AST nodes. They can be particularly useful in linters <a id="dx1-63001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>when searching for improper pattern usage or in refactoring tools when identifying AST nodes for modification.</p>
<p class="hidden">We will create a simple program to test AST matches. The program will identify a function definition with the name <code class="calibre13">max</code>. We will use a slightly modified <code class="calibre13">CMakeLists.txt </code>file from the previous examples to include the libraries required to support AST matches:</p>
<pre class="source-code">1 cmake_minimum_required(VERSION 3.16) 
 

2 project("matchvisitor") 
 
3  
 
4 if ( NOT DEFINED ENV{LLVM_HOME}) 
 

5   message(FATAL_ERROR "$LLVM_HOME is not defined") 
 

6 else() 
 
7   message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

9   set(LLVM_LIB ${LLVM_HOME}/lib) 
 

10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

11   find_package(LLVM REQUIRED CONFIG) 
 

12   include_directories(${LLVM_INCLUDE_DIRS}) 
 

13   link_directories(${LLVM_LIBRARY_DIRS}) 
 

14   set(SOURCE_FILE MatchVisitor.cpp) 
 

15   add_executable(matchvisitor ${SOURCE_FILE}) 
 

16   set_target_properties(matchvisitor PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

17   target_link_libraries(matchvisitor 
 

18     LLVMFrontendOpenMP 
 
19     LLVMSupport 
 

20     clangAST 
 
21     clangASTMatchers 
 
22     clangBasic 
 

23     clangFrontend 
 
24     clangSerialization 
 

25     clangTooling 
 
26   ) 
 
27 endif()</pre>
<p class="hidden"><a id="x1-63030r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-63031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.24</strong>: CMakeLists.txt for AST matchers test tool </p>
<p class="hidden">There are two <a id="dx1-63032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>additional libraries added: <code class="calibre13">LLVMFrontendOpenMP </code>and <code class="calibre13">clangASTMatchers </code>(see <em class="calibre11">Lines 18 and 21 </em>in <a href="#x1-63030r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.24</a>). The <code class="calibre13">main</code> function for our tool looks like this:</p>
<pre class="source-code">1 #include "clang/Tooling/CommonOptionsParser.h" 
 

2 #include "clang/Tooling/Tooling.h" 
 

3 #include "llvm/Support/CommandLine.h" // llvm::cl::extrahelp 
 

4 #include "MatchCallback.hpp" 
 
5  
 
6 namespace { 
 

7 llvm::cl::OptionCategory TestCategory("Test project"); 
 

8 llvm::cl::extrahelp 
 
9     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); 
 

10 } // namespace 
 
11  
 
12 int main(int argc, const char **argv) { 
 

13   llvm::Expected&lt;clang::tooling::CommonOptionsParser&gt; OptionsParser = 
 

14       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); 
 

15   if (!OptionsParser) { 
 
16     llvm::errs() &lt;&lt; OptionsParser.takeError(); 
 

17     return 1; 
 
18   } 
 
19   clang::tooling::ClangTool Tool(OptionsParser-&gt;getCompilations(), 
 

20                                  OptionsParser-&gt;getSourcePathList()); 
 

21   clangbook::matchvisitor::MatchCallback MC; 
 

22   clang::ast_matchers::MatchFinder Finder; 
 

23   Finder.addMatcher(clangbook::matchvisitor::M, &amp;MC); 
 

24   return Tool.run(clang::tooling::newFrontendActionFactory(&amp;Finder).get()); 
 

25 }</pre>
<p class="hidden"><a id="x1-63059r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-63060" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.25</strong>: The main function for AST matchers test tool </p>
<p class="hidden">As you can observe (<em class="calibre11">Lines 21-23</em>), we employ the <code class="calibre13">MatchFinder</code> class and define a custom callback (included via the header in <em class="calibre11">Line 4</em>) that outlines <a id="dx1-63061" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the specific AST node we intend to match. The callback is implemented as follows:</p>
<pre class="source-code">1 #include "clang/ASTMatchers/ASTMatchFinder.h" 
 

2 #include "clang/ASTMatchers/ASTMatchers.h" 
 
3  
 

4 namespace clangbook { 
 
5 namespace matchvisitor { 
 

6 using namespace clang::ast_matchers; 
 

7 static const char *MatchID = "match-id"; 
 

8 clang::ast_matchers::DeclarationMatcher M = 
 

9     functionDecl(decl().bind(MatchID), matchesName("max")); 
 

10  
 
11 class MatchCallback : public clang::ast_matchers::MatchFinder::MatchCallback { 
 

12 public: 
 
13   virtual void 
 
14   run(const clang::ast_matchers::MatchFinder::MatchResult &amp;Result) final { 
 

15     if (const auto *FD = Result.Nodes.getNodeAs&lt;clang::FunctionDecl&gt;(MatchID)) { 
 

16       const auto &amp;SM = *Result.SourceManager; 
 

17       const auto &amp;Loc = FD-&gt;getLocation(); 
 

18       llvm::outs() &lt;&lt; "Found ’max’ function at " &lt;&lt; SM.getFilename(Loc) &lt;&lt; ":" 
 

19                    &lt;&lt; SM.getSpellingLineNumber(Loc) &lt;&lt; ":" 
 

20                    &lt;&lt; SM.getSpellingColumnNumber(Loc) &lt;&lt; "\n"; 
 

21     } 
 
22   } 
 
23 }; 
 
24  
 
25 } // namespace matchvisitor 
 

26 } // namespace clangbook</pre>
<p class="hidden"><a id="x1-63089r26" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-63090" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.26</strong>: The match callback for the AST matchers test tool </p>
<p class="hidden">The most crucial section of the <a id="dx1-63091" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>code is located at lines 7-9. Each matcher is identified by an ID, which, in our case, is ’match-id’. The matcher itself is defined in <em class="calibre11">Lines 8-9</em>:</p>
<pre class="source-code">8 clang::ast_matchers::DeclarationMatcher M = 
 
9     functionDecl(decl().bind(MatchID), matchesName("max"));</pre>
<p class="hidden">This matcher seeks a function declaration that has a specific name, using <code class="calibre13">functionDecl</code><code class="calibre13">()</code>, as seen in <code class="calibre13">matchesName</code><code class="calibre13">()</code>. We utilized a specialized Domain-Specific Language (DSL) to specify the matcher. The DSL is implemented using C++ macros. We can also create our own matchers, as will be shown in <a href="B19722_07.xhtml#x1-1440003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 7.3.3</em></a><em class="calibre11">, Check implementation</em>. It’s worth noting that the recursive AST visitor <a id="dx1-63095" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>serves as the backbone for AST traversal inside the matcher’s implementation.</p>
<p class="hidden">The program can be compiled using the same sequence of commands as we used previously. See <a href="#x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.11</a>.</p>
<p class="hidden">We will utilize a slightly modified version of the example shown in <a href="B19722_02.xhtml#x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.5</a>, with an additional function added:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) return a; 
 

3   return b; 
 
4 } 
 
5  
 
6 int min(int a, int b) { 
 

7   if (a &gt; b) return b; 
 
8   return a; 
 
9 }</pre>
<p class="hidden"><a id="x1-63106r27" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-63107" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.27</strong>: Test program minmax.cpp for AST matchers </p>
<p class="hidden">When we run our test tool on the example, we will obtain the following output:</p>
<pre id="verbatim-52" class="console">./matchvisitor minmax.cpp -- -std=c++17
...
Found the ’max’ function at minmax.cpp:1:5</pre>
<p class="hidden"><a id="x1-63108r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-63109" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.28</strong>: The result of running the matchvisitor utility on a test file </p>
<p class="hidden">As we can see, it has located only one <a id="dx1-63110" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>function declaration with the name specified for the matcher.</p>
<p class="hidden">The DSL for matchers is typically employed in custom Clang tools, such as clang-tidy (as discussed in <a href="B19722_05.xhtml#x1-990005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 5</em></a><em class="calibre11">, Clang-Tidy Linter Framework</em>), but it can also be used as a standalone tool. A specialized program called <code class="calibre13">clang-query</code> enables the execution of different match queries, which can be used to search for specific AST nodes in analyzed C++ code. Let’s see how the tool works. <a id="x1-63111r177" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.6" id="sigil_toc_id_53" class="likechapterhead">3.6  <a id="x1-640006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Explore Clang AST with clang-query</h2>
<p class="hidden">AST matchers are incredibly useful, and there’s a utility that facilitates checking various matchers and analyzing the AST of <a id="dx1-64001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>your source code. This utility is known as <code class="calibre13">clang-query </code>tool. You can build and <a id="dx1-64002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>install this utility using the following command:</p>
<pre id="verbatim-53" class="console">$ ninja install-clang-query</pre>
<p class="hidden"><a id="x1-64003r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-64004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.29</strong>: The clang-query installation </p>
<p class="hidden">You can run the tool as follows:</p>
<pre id="verbatim-54" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-query minmax.cpp</pre>
<p class="hidden"><a id="x1-64005r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-64006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.30</strong>: Running clang-query on a test file </p>
<p class="hidden">We can use the <code class="calibre13">match </code>command as follows:</p>
<pre id="verbatim-55" class="console">clang-query&gt; match functionDecl(decl().bind("match-id"), matchesName("max"))
Match #1:
minmax.cpp:1:1: note: "match-id" binds here
int max(int a, int b) {
^~~~~~~~~~~~~~~~~~~~~~~
minmax.cpp:1:1: note: "root" binds here
int max(int a, int b) {
^~~~~~~~~~~~~~~~~~~~~~~
1  match.
clang-query&gt;</pre>
<p class="hidden"><a id="x1-64007r31" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-64008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.31</strong>: Working with clang-query </p>
<p class="hidden"><a href="#x1-64007r31" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.31</a> demonstrates the default output, referred to as <code class="calibre13">’diag’ </code>. Among several potential outputs, the most relevant one for us is <code class="calibre13">’dump’ </code>. When the <a id="dx1-64009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>output is set to <code class="calibre13">’dump’ </code>, clang-query will display the located AST node. For example, the following demonstrates <a id="dx1-64010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>how to match a function parameter named <code class="calibre13">a </code>:</p>
<pre id="verbatim-56" class="console">clang-query&gt; set output dump
clang-query&gt; match parmVarDecl(hasName("a"))
Match #1:
Binding for "root":
ParmVarDecl 0x6775e48 &lt;minmax.cpp:1:9, col:13&gt; col:13 used a ’int’
Match #2:
Binding for "root":
ParmVarDecl 0x6776218 &lt;minmax.cpp:6:9, col:13&gt; col:13 used a ’int’
2  matches.
clang-query&gt;</pre>
<p class="hidden"><a id="x1-64011r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-64012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.32</strong>: Working with clang-query using dump output </p>
<p class="hidden">This tool proves useful when you wish to test a particular matcher or investigate a portion of the AST tree. We will utilize this tool to explore how Clang handles compilation errors. <a id="x1-64013r188" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.7" id="sigil_toc_id_54" class="likechapterhead">3.7  <a id="x1-650007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Processing AST in the case of errors</h2>
<p class="hidden">One of the most interesting aspects of Clang pertains to error processing. Error processing encompasses error detection, the display of corresponding error messages, and potential error recovery. The latter is particularly intriguing in terms of the Clang AST. Error recovery occurs when Clang doesn’t halt <a id="dx1-65001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>upon encountering a compilation error but continues to compile in order to detect additional issues.</p>
<p class="hidden">Such behavior is beneficial for various reasons. The most evident one is user convenience. When programmers compile a program, they typically prefer to be informed about as many errors as possible in a single compilation run. If the compiler were to stop at the first error, the programmer would have to correct that error, recompile, then address the subsequent error, and recompile again, and so forth. This iterative process can be tedious and frustrating, especially with larger code bases or intricate errors. While this behavior is particularly useful for compiled languages such as C/C++, it’s worth noting that interpreted languages also exhibit this behavior, which can assist users in handling errors step by step.</p>
<p class="hidden">Another compelling reason centers on IDE integration, which will be discussed in more detail in <a href="B19722_08.xhtml#x1-1520008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 8</em></a><em class="calibre11">, IDE Support and Clangd</em>. IDEs offer navigation support coupled with an integrated compiler. We will explore <code class="calibre13">clangd </code>as one such tool. Editing code in IDEs often leads to compilation errors. Most errors are confined to specific sections of the code, and it might be suboptimal to cease navigation in such cases.</p>
<p class="hidden">Clang employs various techniques for error recovery. For the syntax stage of parsing, it utilizes heuristics; for instance, if a user forgets to insert a semicolon, Clang may attempt to add it as part of the recovery process. The Recovery Phase can be abbreviated as DIRT where D stands for Delete a character (for example, an extra semicolon), I stands for Insert a character (as in the example presented), R stands for Replace (which replaces a character to match a particular token), and T stands for Transpose (rearranging two characters to match a token).</p>
<p class="hidden">Clang performs full recovery if it’s possible and produces an AST that corresponds to the modified file with all compilation errors fixed. The most interesting case is when full recovery is not possible, and Clang implements unique techniques to manage recovery while AST is created.</p>
<p class="hidden">Consider a program (maxerr.cpp) that is syntactically <a id="dx1-65002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>correct but has a semantic error. For example, it might use an undeclared variable. In this program, refer to <em class="calibre11">Line 3 </em>where the undeclared variable <code class="calibre13">ab</code> is used:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) { 
 

3     return ab; 
 
4   } 
 
5   return b; 
 
6 }</pre>
<p class="hidden"><a id="x1-65010r33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-65011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.33</strong>: The maxerr.cpp test program with a semantic error – undeclared variable </p>
<p class="hidden">We are interested in the AST result produced by Clang, and we will use <code class="calibre13">clang-query </code>to examine it, which can be run as follows:</p>
<pre id="verbatim-57" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-query maxerr.cpp
...
maxerr.cpp:3:12: error: use of undeclared identifier ’ab’
    return ab;
           ^</pre>
<p class="hidden"><a id="x1-65012r34" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-65013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.34</strong>: Compilation error example </p>
<p class="hidden">From the output, we can see that clang-query displayed a compilation error detected by the compiler. It’s worth noting that, despite this, an AST was produced for the program, and we can examine it. We are particularly interested in the return statements and can use the corresponding matcher to highlight the relevant parts of the AST.</p>
<p class="hidden">We will also set up the output to produce the AST and search for return statements that are of interest to us:</p>
<pre id="verbatim-58" class="console">clang-query&gt; set output dump
clang-query&gt; match returnStmt()</pre>
<p class="hidden"><a id="x1-65014r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-65015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.35</strong>: Setting the matcher for return statement </p>
<p class="hidden">The resulting output identifies two return <a id="dx1-65016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>statements in our program: the first match on <em class="calibre11">Line 5 </em>and the second match on <em class="calibre11">Line 3</em>:</p>
<pre id="verbatim-59" class="console">Match #1:
Binding for "root":
ReturnStmt 0x6b63230 &lt;maxerr.cpp:5:3, col:10&gt;
‘-ImplicitCastExpr 0x6b63218 &lt;col:10&gt; ’int’ &lt;LValueToRValue&gt;
  ‘-DeclRefExpr 0x6b631f8 &lt;col:10&gt; ’int’ lvalue ParmVar 0x6b62ec8 ’b’ ’int’


Match #2:
Binding for "root":
ReturnStmt 0x6b631b0 &lt;maxerr.cpp:3:5, col:12&gt;
‘-RecoveryExpr 0x6b63190 &lt;col:12&gt; ’&lt;dependent type&gt;’ contains-errors lvalue

2  matches.</pre>
<p class="hidden"><a id="x1-65017r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-65018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 3.36</strong>: ReturnStmt node matches at maxerr.cpp test program </p>
<p class="hidden">As we can see, the first match corresponds to semantically correct code on <em class="calibre11">Line 5</em> and contains a reference to the <code class="calibre13">a</code> parameter. The second match is for <em class="calibre11">Line 3</em>, which has a compilation error. Notably, Clang has inserted a special type of AST node: <code class="calibre13">RecoveryExpr</code>. It’s worth noting that, in certain situations, Clang might produce an incomplete AST. This can cause issues with Clang tools, such as lint checks. In instances of compilation errors, lint checks might yield unexpected results because Clang couldn’t recover accurately from the compilation errors. We will revisit the <a id="dx1-65019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>problem when exploring the clang-tidy lint check framework in <a href="B19722_05.xhtml#x1-990005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 5</em></a><em class="calibre11">, Clang-Tidy Linter Framework</em>. <a id="x1-65020r193" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.8" id="sigil_toc_id_55" class="likechapterhead">3.8  <a id="x1-660008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">We explored the Clang AST, a major instrument for creating various Clang tools. We learned about the architectural design principles chosen for the implementation of the Clang AST and investigated different methods for AST traversal. We delved into specialized traversal techniques, such as those for C/C++ declarations, and also looked into more universal techniques that employ recursive visitors and Clang AST matchers. Our exploration concluded with the <code class="calibre13">clang-query </code>tool and how it can be used for Clang AST exploration. Specifically, we used it to understand how Clang processes compilation errors.</p>
<p class="hidden">The next chapter will discuss the basic libraries used in Clang and LLVM development. We will explore the LLVM code style and foundational Clang/LLVM classes, such as <code class="calibre13">SourceManager</code> and <code class="calibre13">SourceLocation</code>. We will also cover the TableGen library, which is used for code generation, and the LLVM Integration Test (LIT) framework. <a id="x1-66001r199" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.3.9" id="sigil_toc_id_56" class="likechapterhead">3.9  <a id="x1-670009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">How to write RecursiveASTVisitor: <a href="https://clang.llvm.org/docs/RAVFrontendAction.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/RAVFrontendAction.html</a></p></li>
<li class="calibre14"><p class="calibre15">AST Matcher Reference: <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/LibASTMatchersReference.html</a></p></li>
</ul>
<p class="hidden"><a id="x1-67001r128" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


</div>
</div>
</body></html>