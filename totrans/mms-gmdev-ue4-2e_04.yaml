- en: U.I. Necessities, Menus, HUD, and Load/Save
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to work on another fundamental necessity of any
    game: our UI, and as a typical example of it, we''ll add loading and saving of
    our game state to our game. Unreal provides some great tools for these two things,
    especially UMG for creating UIs, which we will explore here. When it comes to
    loading and saving your game, it is a system almost every game uses in some form,
    but none in the same way, and the complexity of it will be absolutely driven by
    your design and desired player experience. We''ll first get our inventory showing
    up in our HUD. In the next section we''ll address some strategies for saving based
    on different game types, and then we''ll tackle one of Unreal''s most difficult:
    saving in-map and restoring to an exact point during gameplay.  In this chapter,
    we''ll:'
  prefs: []
  type: TYPE_NORMAL
- en: Make inventory icons using an automated screen-capture level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate the icons into the player's HUD on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronize the inventory with the HUD/U.I.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and load the full game state from anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the U.I. for loading and saving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, it is recommended to simply begin at the point of progress reached
    in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review
    and When to Use BP Scripting*, as the GitHub project does here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4)'
  prefs: []
  type: TYPE_NORMAL
- en: While the [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint
    Review and When to Use BP Scripting*, content is not specifically required, [Chapter
    2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons for the
    Player*, will be heavily used and referenced, so those classes should be considered
    mandatory for the value of this work.
  prefs: []
  type: TYPE_NORMAL
- en: Engine version used: 4.19.0.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating UMG into our player's HUD class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons
    for the Player*, we managed to create an inventory system for our player, a means
    of picking up new weapons, and an input scheme for switching between them. However,
    other than visually seeing which projectile was fired, we had no real reference
    for what we had in hand. So now we will give the player a display so they can
    see what they are using, and as part of that, we will finally add some new art
    assets from the free Unreal Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Building icons for the inventory with screen captures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make this exercise more meaningful and a bit more of a real-world scenario,
    we need more art. As stated before, however, this is not a book about generating
    art or most UE4 content. That said, as a technical developer trying to prove what
    can and can't be done, and without requiring you, the reader, to spend money on
    Marketplace content or outsourced art studios the way a production game typically
    would, we will use some stand-in art that's free. So the first thing to do is
    to get to the Epic Games Launcher. As first noted in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml),
    *Making a C++ Project for a First-Person Shooter*, it's usually best to just make
    a shortcut directly to your UE4 editor executable. In case you forgot, here is
    that sentence where I recommend "*creating a shortcut to your UE4 install folder's*
    `/Engine/Binaries/Win64/UE4Editor.exe`," or of course you can manually just go
    and click it to launch it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This launches the editor with no game, brings up a list of game projects you
    could open, but also in that Unreal Project Browser in the top-right is a Marketplace
    button, so let''s head there. At the very top, make sure you select Unreal Engine,
    then on the left, click Marketplace. At the top of the content row, you will find
    what can be a great friend to teams looking to prototype with cool-looking content
    or make games based on some amazing Epic released assets, the Free tab. Scroll
    down to Infinity Blade: Weapons and Add to Cart (and then check out with the little
    shopping cart in the top-right corner):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/524d4530-5cbc-4bc5-b550-2488e2a4f428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These will now appear when you select the Library item on the left, below Marketplace.
    So now, all we need to do is add them to our project to get access to all this
    great content. Now, glancing at what this package gives you, these are all melee
    weapons of course, but unfortunately, at the time of writing, there is not a pack
    of free ranged (gun) weapons, so we''ll make do with what we''ve got. Click Library
    and scroll to the Vault section to where you find Infinity Blade: Weapons add
    click Add to Project. From here you will need to click the box for Show all projects
    at the top, and select our Mastering project. It will complain these assets are
    not compatible with Other engine version, so select 4.19 from the dropdown (or
    whichever is the newest version at or behind the local engine you have been building)
    and then Add to Project. It may then need to download the assets. Wait for this
    to finish, of course.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, opening our project in the editor, if you have your sources panel open, you
    will see in the Content Browser a new folder, `/Content/InfinityBladeWeapons`,
    under which there are several which are characters (note that some are static
    meshes, but as our original gun and pickups expect, we will stick to some of the
    character weapons). Feel free to open, for example, `/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager`
    and open the `SK_Blunt_Ravager` skeletal mesh to get a look at this interesting
    spiky hammer weapon. We''ll use a few of these to make some new weapons for our
    game. Since we have already been through this process in [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory
    and Weapons for the Player*, I will quickly list the steps I am using here to
    create a few new items:'
  prefs: []
  type: TYPE_NORMAL
- en: In our `/Content/FirstPersonCPP/Blueprints` folder, I'll right-click BigBallGun
    and Duplicate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I'll do the same thing for the pickup (BigBallGunPickup).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the ravager weapon, I will now rename these blueprints RavagerGun (yes,
    we're making a gun out of a hammer, but again, the art is just what we have available),
    and RavagerGunPickup, leaving the other items (such as projectile) the same as
    the BigBallGun.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening the RavagerGun in the full BP editor, and selecting its WeaponMesh component,
    I can now set this to the SK_Blunt_Ravager we just looked at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, I set the BallGunPickup mesh component to use the same skeletal
    mesh, and rename the component to PickupMesh so that as we duplicate them in the
    future this has a generic name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png)'
  prefs: []
  type: TYPE_IMG
- en: And lastly, to differentiate it, I set the Weapon Power to 2 in the RavagerGunPickup(self)
    details and select the RavagerGun from its Mastering Weapon Pickup fly-out. You
    can, of course, set the weapon's Projectile to any you'd like, or make a new one,
    adjust its position in the player's hands, and so on; but for now, we have an
    axe that shoots!
  prefs: []
  type: TYPE_NORMAL
- en: Adding one of the pick-ups to the level and testing it quickly is a good checkpoint
    to add the project to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling down the GitHub project from this point will require a bit more time
    as these assets download (which are larger than the entire rest of the project
    to this point!), but that delay will only happen the first time they are pulled.
  prefs: []
  type: TYPE_NORMAL
- en: I will repeat this process of adding a weapon and pick-up two more times until
    there's a total of five weapons at the moment that can be differentiated. For
    organization purposes now that there are more than a couple of blueprints, I'm
    moving all of these weapons, projectiles, and pickups to a new `/Content/FirstPersonCPP/Blueprints/Weapons`
    folder. Our next step is to get some icons built from these models. Some projects
    will have artists that want to draw these by hand; other games may have no artists
    and use this technique or simply draw the actors directly into a render target
    texture to display these items. The render target idea is explored further in
    the additional reading section, but for now, let's focus on generating icons from
    screenshots in an automated way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish great looking, alpha-masked output icons for high-quality UI
    use, we will need to do a few things in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a new Camera Actor that automates our process and takes our screenshots.
    Implementing this camera will have several parts as well, including placement
    and orientation of our weapon actors, taking depth-masked screenshots, and importing
    those back to our actors as textures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new level, add an instance of our new camera to it, and add a SkyLight
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hook the imported texture back into our pick-ups to pass to the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an icon widget in UMG that takes a weapon's texture on creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a list in UMG and add this to the HUD. Hook the inventory class to the
    list widget and have it update to reflect the player's weapon choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With most significant game features such as this, there are a number of steps,
    and each has various levels of complexity; but if you can order them in such a
    way to implement and test each of them as we go, as the preceding process is designed
    to do, it's just a matter of time before you go from A to B and have your finished
    system. So let's get started with the new camera class. In the editor at the `/Content/Blueprints`
    level, I'll add a new C++ class and name it MasteringIconCamera, and derive it
    from CameraActor. This camera's whole job will be to open weapon pickups and place
    them in a nice way in front of it and then take screenshots, which  we will use
    as icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an opportunity to show where using blueprints can be a real time saver.
    It''s most definitely possible to simply place a camera directly in a level, and
    with some work, get its viewport to take screenshots. If time permits and someone
    is determined or is very experienced with these systems in C++, it can be done
    with effort. Or, you can make a game mode in blueprint, make a new pawn in blueprint,
    and no C++ native classes are needed. As we have made blueprint classes before,
    I''ll just list the steps taken in this section and, as always, if problems arise,
    this progress is available in GitHub to check against:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Blueprints folder, create an IconMaker folder, and in it create a new
    blueprint based off Pawn, named IconPawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a game mode based on GameModeBase. Name it IconGameMode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the game mode, uncheck Allow Tick Before Begin Play (set false), set HUD
    Class to None, and set Default Pawn Class to IconPawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In IconPawn, under its DefaultSceneRoot, add a ChildActor component and set
    its Child Actor Class to MasteringIconCamera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that child camera, uncheck Constrain Aspect Ratio in Camera Component's Camera
    Settings (this avoids a check from often asserting when using custom depth field
    screenshots).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally set the FOV (for experimental purposes, I set it to 45 as it makes
    some of the math easier to test later). Any range from very small to 90+ is fine.
    Normally for this kind of thing I'd want to use an orthographic camera for simplicity,
    but lighting has had many problems in UE4's orthographic rendering for years.
    We handle FOV in code, as seen later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is it for the blueprint classes. Now we need a new level to use them in.
    So in the editor, be sure to save your blueprints, then go to File > New Level,
    picking the Empty Level template and naming it `IconScreenshotMap`. Drag an Icon
    Pawn into the level and in the Details pane with it selected, be sure its location and
    its rotation is set to `0`, `0`, `0`. We can also borrow a trick from the FPS
    template''s example map, and under our in-level pawn''s Pawn properties, set Auto
    Possess Player to Player 0\. This way, when the game starts, it puts the local
    default player right into this pawn rather than making one from a player spawn.
    Another tip: you can copy all of the lighting objects (or the whole lighting folder)
    from `FirstPersonExampleMap` and paste them into this map.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, you will certainly need a Sky Light and probably want a Directional
    Light as in the GitHub version, but this is a bit subjective for changing the
    look of the weapons as we screenshot them. Tthe GitHub version may be a bit too
    bright, making the renders a little washed out; but again, this is subjective
    and not the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a level and lighting, let's fix up some World Settings in the
    main editor tab for the level. Set the GameMode Override to IconGameMode, and
    down in Physics, we want to check the Override World Gravity box and set it to
    0.0 (we don't want our pawn immediately, or ever, falling). For completeness,
    I added a pickup for the default ball gun and put a scale on the big ball gun
    pickup to differentiate it later. So now our level and picture-grabbing pawn are
    all set; all we need now is for the camera in it to actually do something!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin in its `BeginPlay` function back in C++. Our header has several
    member variables and a number of functions that we''ll need to automate our screen-grabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the interest of brevity when posting progress here, I''m leaving out a lot
    of the normal spacing and comments that might normally accompany these things
    in a professional environment. Hopefully, the more traditional and formal examples
    in the previous chapters have given some good overall guidelines there, but if
    you notice these things missing here, it''s to save space as we have a lot to
    cover, not out of bad habit. As usual, when there are new concepts, they will
    be discussed along with the code here. In this case, there''s a new `UPROPERTY`
    tag, `Transient`. This tells the engine that these properties are never to be
    saved with the object: they''re used during its lifetime and can be used as any
    other `UPROPERTY` can, but changes to them do not "dirty" the object to require
    saving, and the contents are never serialized in and out with an instance of the
    object. A brief note on the properties near the bottom: `ShotDelay` is the amount
    of time we pause between loading a new weapon pickup in-game and taking its screenshot.
    This is there primarily to allow some frames for the game to spawn the objects
    and then update them to be in the proper MIP map level of detail. We will be asynchronously
    loading in all the blueprints for the weapon pickups, but this delay is still
    needed because even with assets loaded, objects often still come in at their lowest
    MIP level and if we take a screenshot right then, the quality is at its worst:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are a few interesting things to discuss here. The first is commented at
    the top that `BeginPlay` can be, and will be, called multiple times on a single
    object (generally two), and we only need to or want to do the work here once.
    So first, we set the player into cinematic mode, shutting down movement and HUD
    and anything else that's not really needed with our super basic pawn, but a good
    idea in areas such as this in general. We set this camera as the view target and
    get our path, which is defaulted to where the weapon, pickup, and projectile blueprints
    were moved: `/Game/FirstPersonCPP/Blueprints/Weapons`. However, this can be edited
    on an individual icon camera to point to any specific folder as it's an exposed
    `UPROPERTY` (just like the screenshot resolution and delay mentioned earlier).
    Next, the `UObjectLibrary` class is used to mass-find our pickup objects in the
    path. We quickly iterate the list of them, making soft references to those objects.
    This is not strictly required, but like a few other topics in this chapter, it's
    meant to be instructive and start building good habits when you're thinking about
    how to reference objects as you go. On a PC, often you can simply load all the
    necessary assets all the time for a given level and only free them when you finish
    playing. On mobile and other platforms, memory can be at a premium, so it's good
    to have the tools in hand to load assets in the background, not stopping the game,
    and then also to be sure they will be freed by garbage collection later when they're
    no longer needed. Once the list of pickups is made, we send that to the `StreamableManager`
    to batch stream in our blueprints that we need to use. In that request, we add
    a callback to ourselves using `FStreamableDelegate`'s `CreateUObject` (this creates
    a callback tied to a `UObject`, in most cases using the `this` pointer). When
    all these blueprints are loaded into memory, it will call `OnFinishedLoadingAssets`,
    which we'll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: To speed up testing during work like this (where you simply need to open a level,
    have it run, and exit), you can right-click the Mastering project in the Solution
    Explorer and add the map name and `-game` to your Command Arguments line so it
    looks like this: `"$(SolutionDir)$(ProjectName).uproject" IconScreenshotMap -game
    -skipcompile -debug`. This tells the DebugGame Editor build to launch directly
    into the game, but as an Editor build. It will still use uncooked content. If
    you built DebugGame, you will get an error on startup if you are not also cooking
    your content.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once our blueprints are all loaded, we need to spawn one of each of these
    as actors into the world, take our shot, and then destroy that one and move to
    the next. We''ll do this with a timer and a lambda function (our first, but certainly
    not last). Look at what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first convert our soft references (the `TArray` of `FSoftObjectPath`
    items) to hard references (in this case, a simple `UPROPERTY` `TArray` of `UBlueprint`
    pointers). If you find yourself having trouble with memory leaks or running out
    of memory, always remember that a `UPROPERTY` pointer in UE4 will count as a hard
    reference to the object it points to, preventing it from being freed until you
    null out that pointer (or point it at another object), or the object with the
    pointer is destroyed upon which it is also released. You can always walk up the
    chain of `UObject` `Outer` pointers to find out who ultimately owns any other
    `UObject`, but right now, we want to force all these blueprints to stay loaded
    in memory, hence why we convert the soft references to hard ones. After this,
    we cue up our first pickup to be shot by calling `SpawnAndPlaceNextActor`, which
    we will get to shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most programmers learning C++ in the last 5 or so years, lambda functions
    are pretty common. For those learning C++ in earlier years this could be something
    new, but they''re incredibly useful and supported by many areas of UE4\. We use
    one here in a simple timer from the game''s timer manager: we set an initial delay
    to our `ShotDelay` member time, as well as the rate the timer will fire at since
    we set it to looping, and only break this looping when a special condition is
    hit. `CurrentWeaponIndex` being 0 means we have finished and are out of pickups
    to capture. The way to stop a looping (or any active non-looping) timer is to
    have the timer manager clear that timer based on the handle you passed when you
    set the timer. Now, every `ShotDelay` interval, we''ll call `TakeShot`, which
    also cues up the next shot when it finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next thing called is that `TakeShot` function, let''s look at it next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice in many of these functions there are `checks` before simply calling
    functions on those items, such as the Mesh pointer. Given how automated this functionality
    is, if content creators were having trouble building proper pickups, you would
    be alerted anywhere important here, but if this were a problem you'd likely want
    to handle those kinds of setup mistakes in a way that doesn't crash the editor
    for non-programmers (people hooked into Visual Studio or the like can always skip
    passed check assertions with Set Next Statement or the like). But again, for brevity,
    and as a minimal safeguard to alert of a problem before a simple crash, these
    `checks` are at least here. So, getting that Mesh, we then set it up for a proper
    screenshot, make sure our game's global screenshot resolutions are set to ours,
    set up our screenshot's properties, and take one using the game viewport. It's
    by far the easiest one to access, and this is why we take ours from the player
    pawn's perspective here. We then set an intentionally short timer so the next
    frame we move to the next actor, or signal to the previous timer that we're done
    via resetting the weapon index. As noted in the comment, if you destroy an actor
    (as `SpawnAndPlaceNextActor` will) it is likely that it then will not show up
    at the time the screenshot is resolved, but if you wait one frame for the shot
    to finish, there's no problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'So you''ve seen it a couple of times now; let''s look at `SpawnAndPlaceNextActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this function is much more straightforward and does not require much
    attention. We destroy any current existing actor, get the one our index is set
    to as a blueprint, spawn one of those in the world with the blueprint's `GeneratedClass`,
    stop it from spinning, fix its location, and increment our index.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we fix up that location? By finally using a little bit of basic
    3D math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If curious about the commented out bounding box/offset drawing chunks, feel
    free to enable one or both and see what they show you. The reason I used them
    and left them in was because `SkeletalMeshActors` primarily get their bounding
    information at the time the assets are imported from whatever external tool they
    were built in (3D Studio MAX, Maya, and so on) set by the artists. As I found
    some of the Infinity Blade weapons' bounding a bit odd, I used this to make sure
    it was indeed how the assets were made, and there was not a math or other programming
    error.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we get the bounding extents of the actor, find its longest
    dimension (X, Y, or Z) and push it back until that longest side is just at the
    edge of our view frustum. If it turns out a weapon is more wide than it is long,
    we rotate the larger side to face our camera too. Figuring out how far away in
    X to move our actor to best fill/fit the screen before the shot is then just a
    bit of simple trigonometry. We can get the field of view of the camera frustum,
    and if we then consider a top-down sort of view of that frustum split down the
    middle as two right triangles, we know to get that longest side to fit we then
    use the tangent of half that frustum angle for one of the triangles. By definition,
    that tangent being the opposite side's length over the adjacent side's length,
    we divide the long side of our bounding to know how far to push the object out
    now. We also subtract out the relative position offset (InPos) of the bounding
    box itself and should have a reasonably centered location to return.
  prefs: []
  type: TYPE_NORMAL
- en: Running our icon map now should generate a screenshot in the Saved folder of
    our project for each pickup. This is a good checkpoint for GitHub, and we'll use
    those screenshots to finally make some UI elements next.
  prefs: []
  type: TYPE_NORMAL
- en: Using UMG to display inventory icons on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the previous section''s significant amount of code, we''ll be back working
    mostly in blueprints and the editor in this section. One quick aside: when moving
    assets in the editor, it will leave behind a redirector `.uasset` file of the
    one you moved. All this does is point anything that looks for the old one to the
    new one. There''s a Fix-Up Redirectors commandlet you can run, which searches
    your content folder for all of these and any objects referencing them, points
    them properly to the new location, and deletes the redirector. This can also be
    done manually in the content browser by finding the Other Filters | Show Redirectors filter
    setting, and you can right-click on them in the content browser and select Fix
    Up to get rid of them. I did that at this point to keep things tidy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So now under FirstPersonCPP I next make a Textures folder and click the Import
    button in the content browser: browsing to where the screenshots were added (`/Saved/Screenshots/Windows`).
    Select the generated `.png` files here (five in my case) and let them all import
    as textures. It''s good to have a naming convention for searching blueprints as
    projects get larger, so for all of these textures I simply name them `T_`(weapon
    name). Of course, with some effort in UE4''s C++ using the `FileManager` we could
    cleverly automate renaming the `.png` files rather easily, but importing them
    into game content as textures is a bit more involved—bulk selecting them here
    and manually renaming is sufficient for us as we get on to the task of drawing
    them in an inventory UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing your inventory and HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving to actually draw our icons and cycle them is the first portion of this
    book where not all steps of implementation will be fully shown. All of the work
    as always is available on GitHub, and it is recommended to go look at each change
    in this `Chapter 4` branch submission, but for discussion purposes, the focus
    will be on new concepts going forward and decision making. This is, after all,
    a Mastering book, so expect the pace and complexity of work to pick up. First,
    a bit of housekeeping, as this complexity does ramp up: as a project moves into
    a more mature state, the sheer number of source files tends to increase and it''s
    best early on to start managing these into logical directories. There are really
    two main schemes for how you group things in your project hierarchy: by function
    or by system. Functionally grouping source files is along the lines of (in our
    current reorganization) things such as all UI widget classes, with maybe subfolders
    for complex specialized types. Grouping by system would be (as I''ve done here)
    more like all things related to inventory. While these may seem like trivial decisions,
    or it may feel OK with modern IDEs to simply leave every class in one flat hierarchy,
    project size and developer team size should drive your decisions here. The important
    part is to make architectural decisions like this early and then stick to them
    throughout a project for the team''s consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, on to the fun stuff! The main new class we need to create in C++ is `UUserWidget`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as they''re new to this book, note the keyword for `BlueprintImplementableEvent`:
    these functions are actually not implemented in C++, only declared in the header.
    Their actual functionality comes in the blueprint events they generate. We''ll
    get to those in a bit, but let''s now look at how they are used and then we''ll
    trace that to how they are triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here is we are hooking into an event in the `Inventory` class
    that will broadcast to all its listeners (our bindings) when events happen, passing
    weapon properties into our blueprint implementation. So, how do we do this? First
    we add these events to our inventory class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `.cpp`, after a good amount of refactoring (and a couple of bug
    fixes I''m not too ashamed to admit), we have lines like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similarly added for, well, adding a weapon, and the newly implemented removal
    of weapons as well (this is done when ammo runs out).
  prefs: []
  type: TYPE_NORMAL
- en: For a game like this, it's important to have a design in mind for how to show
    the player their inventory and know whether things such as ammo pickups without
    being a weapon pickup are possible, of course. In this case, if you're out of
    ammo, you might as well not have the weapon at all, so we remove it from the display.
    You could, of course, gray it out or the like, but again, make sure at all times
    your design drives your implementation decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we''re now communicating to our inventory display object key events when
    the inventory is changed in C++. Let''s take a moment than to see what that looks
    like on the blueprint side of this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b12ef8d5-0d03-4aa8-98c7-5f393b3cda46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note here, but it will be kept brief: notice the
    functions and variables on the left. These are blueprint-only things added with
    the + button to make all of this work. This is where a bit of mystery will remain
    unless you go to GitHub and look at all of the implementations. Hopefully, the
    functionality of these functions and variables is clear from the naming. As inventory
    items are added, widgets are added to a ScrollBox widget. The layout will follow,
    but the important concepts are that we''ll track weapon classes and icon widgets
    in parallel arrays so we can map them for selection and removal. That function
    is demonstrative of why all the functions won''t be shown here directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/048979b9-3e71-4dc7-a0f9-b4e9aba2911c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is not even a particularly complex function, but it''s already a bit tight
    to get into one shot. Notice at the print-string node there''s a redirector node.
    They can be added by dragging from an execution pin (white ones) at any time,
    and then dragged around to help sometimes with the spaghetti that visual scripting
    can create. Hopefully, also you''re familiar with input and output variables (seen
    in the bottom left), blueprint functions can be extremely useful for quick implementation,
    and are all but required when working with UMG widgets. Some UI/UX designers may
    be comfortable implementing their own functionality, but mostly those roles will
    be more involved with the Designer tab, in the top-right. Let''s quickly look
    at that for this scrolling inventory widget that we''ll draw, currently, at the
    top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d86defb-fe30-4e5a-8456-336718fbe902.png)'
  prefs: []
  type: TYPE_IMG
- en: Of note in the top-right is that the ScrollBox widget, in this case, is checked
    to be a variable (you can see it referenced in blueprint scripting) and the slightly
    odd arrangement of HorizontalBox widgets on the left, which basically sandwich
    our ScrollBox into a Canvas widget in the middle that is the size we want. There
    are a **lot** of widget settings to get all this correct, including an Image-based
    widget named InventoryItem that can be reviewed in the GitHub project. Looking
    for what was modified to make things work as they do is always just a search for
    those little yellow looping arrows (which, as you know if clicked, revert a value
    to its default) indicating what has been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to make all of this work also requires adding a blueprint for our MasteringGameMode
    and MasteringHUD so that the former can set the latter as the HUD to use, and
    World Settings in the main level editing window can be set to use that mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ea8f568-dd31-4371-ade8-afac646e4081.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that I un-hardcoded the crosshair texture, but exposing things like this
    to blueprint means adding extra code to handle if they are not set up properly.
  prefs: []
  type: TYPE_NORMAL
- en: So the net result of this is that we can now scroll through our weapons, see
    which is selected (as it is the only full-alpha object in our list), and as we
    cycle what's in-hand, it cycles our ScrollBox full of icons, removing any that
    run out of ammo!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a54a386a-82cb-4a67-8230-a00dbbb95735.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you find yourself getting errors trying to compile your widgets, be sure
    to note the change to `Mastering.Build.cs`. This is where you can include source
    modules your game may find itself needing (and to this point, we did not need
    UMG):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One last note (which will be well known to experienced GitHub users): I submitted
    my changes, *then* moved my files to reorganize them. GitHub sees moves as a deletion
    of the old file and addition of a new file, so you would lose the change history,
    but that can be seen in the two submissions that go along with this effort.'
  prefs: []
  type: TYPE_NORMAL
- en: So now our inventory is synced up and good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Using UMG and game save slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UE 4.19+ gives us a nice class to actually save and load a chunk of data for
    objects we want to save. In our case, this will be every actor that can change
    its state or position, which right now is not a lot. But as a game grows, if in-scene
    saves are desired, it is incredibly important to start this process as early as
    possible too. Our biggest challenge will be the one class we implemented in [Chapter
    3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review and When to
    Use BP Scripting*, where almost its entire functionality was implemented on the
    blueprint side. Creating a solution that works with both native C++ classes and
    blueprints will be our all-inclusive goal for this section. The UMG UI will be
    a bit lighter than the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a widget for save slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the bulk of the work in this section will be actually implementing the
    loading and saving of various actor classes, we do of course need an interface
    to display this to players, and that is what we will do first. Our next step then
    is a UMG widget that we can bring up with buttons to facilitate this. So, back
    in the editor, we need a widget that has some touch-points back to C++ code so
    we can do the bulk of the work. To simplify this, we''ll make a new C++ class
    based on `UUserWidget`, call it MainMenuWidget, and add the class to the UI folder.
    Then, like before, we make a new blueprint asset and we will add 4 buttons to
    that in its design, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice we set its initial visibility to Hidden, and at the ButtonBox level,
    the anchor is set to center screen with X and Y alignments of 0.5\. As always,
    feel free to reference the version in GitHub for all UMG/blueprint issues not
    specifically discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we bind the click events for each of those buttons. Click each button,
    and at the bottom of its Details tab are the events for input with a big green
    + button. Click that for each button''s OnClicked event and you''ll be taken to
    the blueprint graph at that event where it''s added. We add these functions to
    the widget class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wire the save event to the `SaveGame` function, and wire the load event to
    the `LoadGame` function as well, of course. `Open` is called by an input: we need
    to bind one in player settings as we have done in the past. I set mine to *F10*
    as this is common in several games, but of course it can be any key, touch, or
    gesture desired. In `MasteringCharacter`, I bind this input to a simple pass-through
    function that gets the HUD like so and calls a function with the same name on
    that HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the widget class, the `Open` and `Close` functions are worth looking
    at, but only open is listed here as close is essentially the same thing in reverse,
    setting the input mode to `FInputModeGameOnly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now with *F10*, while playing, our main menu comes up, and when the Return to
    Game button is clicked, its event just calls close now on the widget, which unpauses
    the game and returns mouse control to our normal player input. The last special
    event, the button labeled Exit Game, has a simple blueprint node call to quit
    playing (and exit standalone), utilizing the Execute Console Command node, with
    the command `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the project, this is changed to a Quit Game node as this works when
    console commands may be unavailable (release builds, certain platforms, and so
    on). The Quit Game node is also nice because on mobile platforms it can simply
    send your app to the background instead of fully ending its execution. Keep in
    mind that iOS and Android can effectively end the execution of an app that is
    in the background if the OS decides it needs its resources; but again, at least
    the Quit Game node works across platforms and allows you the choice to try just
    going to the background.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the menu side at the moment. Now we need to actually save our
    game, finally!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a save game file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As noted at the top of this section, our actual game and the state of all our
    dynamic actors is done in three major steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an interface to all actors that need to save. This involves a few changes
    to our moving platform, which we'll try to keep straightforward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialize all our actors' desired variables to an `FArchive` by tagging our
    `UPROPERTIES`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write this to a file we can then serialize everything back out from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For very simple saving (such as player stats and the current level), be sure
    to check out the `USaveGame` document link in the *Further reading* section at
    the end of the chapter. Now, on to our relatively complex version.
  prefs: []
  type: TYPE_NORMAL
- en: First we need an interface that we'll add to all of our actors that we care
    about saving, this is the first time we need to make a C++ class outside the editor.
  prefs: []
  type: TYPE_NORMAL
- en: When making new C++ from files, it's often just easiest to right-click the tabs
    at the top of Visual Studio, open Containing Folder, copy paste a `.h` and `.cpp`
    file up one folder, rename them as needed, copy them back down to the proper folder,
    then generate project files by right-clicking the `.uproject` or using the batch
    file style mentioned in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter.* Of course, the body of the files needs
    to be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header of the `.h` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And what is nice about BlueprintNativeEvent is that we can fire these from C++,
    but have them executed in blueprint. The class we have some new work to do for
    is our moving platform, which again, exists and is defined solely in blueprint.
    Making the interface `BlueprintType` means we can add this easily to our platform
    blueprint-only class. So, heading to that class, here are the steps we need to
    get it saving properly to the archive. Open the moving platform class, click Class
    Settings at the top main menu bar, and on the right, you'll see Implemented Interfaces,
    and we can click Add and select Saved Actor Interface to add this functionality
    on the blueprint side. Once we compile the blueprint, we can add an event then
    for when the actor is loaded. To properly set it in the right state, we need to
    click on its two variables in the My Blueprint tab on the left, and in their Details
    tab, click the down arrow to expose the rest of its options and check the box
    for SaveGame for both the GoingHome and StartPosition blueprint variables. Now,
    when we serialize a platform to an archive, these will be saved and loaded and
    while ideally we would "lasso" select a set of nodes and right-click and select
    Collapse to Function, we can't do this here because asynchronous nodes such as MoveComponentTo
    have to stay in the Event Graph layer. But let's add an event for the interface's
    Actor Loaded and then just copy paste some of the movement nodes, making sure
    that if the platform needs to be moving it goes the right way (based on the Going
    Home variable). There's no harm telling a platform to go where it already is,
    so we'll set it on the case it has Going Home set to move to its Start Position.
    Also fixed slightly is the on-actor-overlap event from before. It will go to Start
    Position + 300 in Z, rather than its current position. So that fixes arguably
    our hardest case, the blueprint-only class of the group. Let's add the interface
    to our other classes, and give them a general save functionality as well as a
    couple of specific ones (such as our `MasteringCharacter`).
  prefs: []
  type: TYPE_NORMAL
- en: MyData will consist of all the `UPROPERTY` items we tag with `SaveGame`. Right
    now, the only one of these we would really need to add is the player's inventory;
    but because that has class references and an array of structs that also directly
    reference a texture and class, we'll custom handle inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Saving class and asset references directly does *not* work if you tag those
    `UPROPERTIES`. If an object references another object that will be created when
    the level is loaded, this may work, or to be safe you can look up placed-in-world
    actors by name in a fix-up pass. Most times, you save the class as a string, then
    respawn whatever object that is, as we will do extensively here as well as with
    our inventory special case saving.
  prefs: []
  type: TYPE_NORMAL
- en: If we had other basic types (such as the blueprint variables on our moving platform),
    simply add `UPROPERTY(SaveGame)` to their definition and they automatically serialize
    in and out with the actor data. To make inventory load and save properly, we need
    a couple of new structs and its own serialization to and from them, which we will
    demonstrate in the next section. Since it is not an actor class, it is a little
    annoying to put its structs in the same place as those actor saving ones, but
    this still seems at this level of complexity to be the best place. So now, how
    do we use this menu, some new UI, and a lot of saving and loading code to save
    everything that can change in our levels at any moment and load right back? Let's
    dive into that now!
  prefs: []
  type: TYPE_NORMAL
- en: Save and load from our menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Saving our data is relatively straightforward, but as with all load/save systems,
    is mirrored with a little more difficulty on the load side. This functionality
    is almost exclusively implemented in the `MainMenuWidget` class, though I can
    see that the class might grow, moving it to the `SavedActorInterface` or the like;
    but let''s now go forward with what is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For saving there is a fair bit going on here, some of which is just basic file
    I/O, but other parts may be unintuitive and are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We save the timestamp and then split the map name with the `_` character. This
    is a bit of a risk because you'd, of course, want to make it very clear to level
    designers not to add this character to their map names. In this case, when we're
    playing and testing in PIE, it appends a couple of things to the left of the map
    name that end with `_` and so splitting from the end gets us, for example, `FirstPersonExampleMap`
    without the PIE prefixes that wind up there when playing in the editor. We then
    get a list of all actors that implement our save interface and iterate them. We
    then always save out the relevant actor transient data, but also look to see whether
    we've found our mastering character to do a bit of inventory work. As noted earlier,
    our inventory saving (and loading) needs to be done with the `FInventoryItemData`
    struct and not the `FWeaponProperties` struct inventory uses directly, because
    the latter references a class and texture directly (we need them saved by their
    path/name to properly serialize and then be reloaded from them).
  prefs: []
  type: TYPE_NORMAL
- en: We set all the relevant information, then serialize to a binary for output and
    save the file, giving it the name of the timestamp we used. You could of course
    let the user pick the name, or save it otherwise, but this at least shows clearly
    when loading what time this save was from.
  prefs: []
  type: TYPE_NORMAL
- en: After we have saved, we set the mouse cursor back to hidden, unpause the game,
    and close the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading, we first have to add some more UI to allow the player to pick
    the save that they want to load (or cancel):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e333d904-ecd1-451e-b0fc-97d700fc8e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the switcher UMG item. This lets us basically switch (of course) what
    is shown by the widget from that hierarchy down. We set this from nodes in the
    main menu blueprint, like when we open the loading portion here in a new function
    from the load-button''s on clicked event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0366ca45-5235-4ed9-a1e1-871f5162da28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then call the native function to get all the save files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we create and add a button for each of them (with the main menu as
    a member) to the load game list. We make a quick UserWidget blueprint that has
    a simple button and text layout like so, that has one job to do when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9bae0fb-3fe2-4a61-bdd4-891e057a56ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For those looking closely, there are a couple of points that could be handled
    differently. We will be addressing them later in the book. I would call out that
    we load (or restart) the map for the save, loading its data, and then, storing
    it in a static member variable that survives the map re-loading and is then triggered
    by the HUD''s `BeginPlay`. We''ll be exploring ways to switch from level to level
    and pass data between them in [Chapter 6](978665f4-5638-4a71-9f86-c0349e090ae7.xhtml),
    *Changing Levels, Streaming, and Retaining Your Data*, so fear not if you still
    have questions there. Also, at the moment, the only way to delete save files is
    to go to your content folder, but with all the work we''ve done here, adding a
    delete to your menus should not be an issue. And one last note: it''s also possible
    in a number of ways to hook one widget to another. In this case, I simply pass
    the menu to the button when the menu makes it. There''s nothing wrong with using
    clever techniques, just keep in mind that going with the simplest solution sometimes
    saves time, which every game ends up needing as it gets closer to being ready
    for the public.'
  prefs: []
  type: TYPE_NORMAL
- en: So that's it, we made it! Checking GitHub, there's a new level with some changes
    in it, but that's really just there for now to prove out load-save from level
    to level and back again. Have fun testing that out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter really ramps up the complexity level of work closer to the mastering
    level. After some warm-up work, it''s definitely time to dig into this level of
    detail and start to really learn the tips and tricks that can make or break a
    game in development. The work here should give a solid base to a number of levels
    of UI work: we made a bunch of new weapons, used our pick-ups to generate screenshot
    icons of them, added these back to the pick-ups and our inventory, utilized that
    inventory to build and sync up a scroll bar of weapons, and made menus and an
    entire save-anywhere system for all of our objects, whew! The project is finally
    starting to look more like a real game compared to the bare-bones template we
    began with, but one thing is missing: enemies to fight. But fear not, we''ll have
    those by the end of the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it important to commit any changes to files to GitHub before moving them
    to a new folder location?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the steps needed to make a pawn that won't move or fall upon starting
    an empty level?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two ways of cleaning up redirectors in UE4, and why is it important
    to do so from time to time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What UMG child widgets can be used for placing and spacing other widgets within
    a parent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using `BlueprintImplementableEvents` in communicating
    from C++ to UMG?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which types of `UPROPERTIES` must absolutely not be attempted to serialize when
    saving class variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What alternative to saving those properties was used here to save and restore
    those special types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which system was used to implement in only a few lines the building of a list
    of files matching an extension?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simple saves with `USaveGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code](https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code)'
  prefs: []
  type: TYPE_NORMAL
