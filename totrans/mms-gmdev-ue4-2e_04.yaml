- en: U.I. Necessities, Menus, HUD, and Load/Save
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to work on another fundamental necessity of any
    game: our UI, and as a typical example of it, we''ll add loading and saving of
    our game state to our game. Unreal provides some great tools for these two things,
    especially UMG for creating UIs, which we will explore here. When it comes to
    loading and saving your game, it is a system almost every game uses in some form,
    but none in the same way, and the complexity of it will be absolutely driven by
    your design and desired player experience. We''ll first get our inventory showing
    up in our HUD. In the next section we''ll address some strategies for saving based
    on different game types, and then we''ll tackle one of Unreal''s most difficult:
    saving in-map and restoring to an exact point during gameplay.  In this chapter,
    we''ll:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Make inventory icons using an automated screen-capture level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate the icons into the player's HUD on screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronize the inventory with the HUD/U.I.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and load the full game state from anywhere
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the U.I. for loading and saving
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, it is recommended to simply begin at the point of progress reached
    in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review
    and When to Use BP Scripting*, as the GitHub project does here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: While the [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint
    Review and When to Use BP Scripting*, content is not specifically required, [Chapter
    2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons for the
    Player*, will be heavily used and referenced, so those classes should be considered
    mandatory for the value of this work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Engine version used: 4.19.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Integrating UMG into our player's HUD class
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons
    for the Player*, we managed to create an inventory system for our player, a means
    of picking up new weapons, and an input scheme for switching between them. However,
    other than visually seeing which projectile was fired, we had no real reference
    for what we had in hand. So now we will give the player a display so they can
    see what they are using, and as part of that, we will finally add some new art
    assets from the free Unreal Marketplace.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Building icons for the inventory with screen captures
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make this exercise more meaningful and a bit more of a real-world scenario,
    we need more art. As stated before, however, this is not a book about generating
    art or most UE4 content. That said, as a technical developer trying to prove what
    can and can't be done, and without requiring you, the reader, to spend money on
    Marketplace content or outsourced art studios the way a production game typically
    would, we will use some stand-in art that's free. So the first thing to do is
    to get to the Epic Games Launcher. As first noted in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml),
    *Making a C++ Project for a First-Person Shooter*, it's usually best to just make
    a shortcut directly to your UE4 editor executable. In case you forgot, here is
    that sentence where I recommend "*creating a shortcut to your UE4 install folder's*
    `/Engine/Binaries/Win64/UE4Editor.exe`," or of course you can manually just go
    and click it to launch it as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个练习更有意义，更接近现实场景，我们需要更多的艺术作品。然而，正如之前所述，这本书并不是关于生成艺术或大多数UE4内容的。话虽如此，作为一个试图证明可以和不可以做什么的技术开发者，并且不需要你，读者，像制作游戏那样在Marketplace内容或外包艺术工作室上花钱，我们将使用一些免费替代的艺术作品。所以首先要做的是打开Epic
    Games Launcher。正如在[第一章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)中首次提到的，“为第一人称射击游戏创建C++项目”，通常最好的做法是直接创建一个指向你的UE4编辑器可执行文件的快捷方式。如果你忘记了，这里就是我推荐“创建一个指向你的UE4安装文件夹的`/Engine/Binaries/Win64/UE4Editor.exe`”的句子，或者当然你也可以手动点击它来启动它。
- en: 'This launches the editor with no game, brings up a list of game projects you
    could open, but also in that Unreal Project Browser in the top-right is a Marketplace
    button, so let''s head there. At the very top, make sure you select Unreal Engine,
    then on the left, click Marketplace. At the top of the content row, you will find
    what can be a great friend to teams looking to prototype with cool-looking content
    or make games based on some amazing Epic released assets, the Free tab. Scroll
    down to Infinity Blade: Weapons and Add to Cart (and then check out with the little
    shopping cart in the top-right corner):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '这将启动编辑器而没有游戏，会弹出一个你可以打开的游戏项目列表，但在右上角的Unreal项目浏览器中有一个Marketplace按钮，所以让我们去那里。在最顶部，确保你选择了Unreal
    Engine，然后在左侧点击Marketplace。在内容行顶部，你会找到一个对于想要使用酷炫内容进行原型设计或基于一些惊人的Epic发布资产制作游戏的团队来说可能非常有用的朋友，那就是免费标签。滚动到Infinity
    Blade: Weapons并添加到购物车（然后点击右上角的购物车结账）：'
- en: '![](img/524d4530-5cbc-4bc5-b550-2488e2a4f428.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/524d4530-5cbc-4bc5-b550-2488e2a4f428.png)'
- en: 'These will now appear when you select the Library item on the left, below Marketplace.
    So now, all we need to do is add them to our project to get access to all this
    great content. Now, glancing at what this package gives you, these are all melee
    weapons of course, but unfortunately, at the time of writing, there is not a pack
    of free ranged (gun) weapons, so we''ll make do with what we''ve got. Click Library
    and scroll to the Vault section to where you find Infinity Blade: Weapons add
    click Add to Project. From here you will need to click the box for Show all projects
    at the top, and select our Mastering project. It will complain these assets are
    not compatible with Other engine version, so select 4.19 from the dropdown (or
    whichever is the newest version at or behind the local engine you have been building)
    and then Add to Project. It may then need to download the assets. Wait for this
    to finish, of course.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '当你选择左侧Marketplace下面的库项目时，这些内容将会显示出来。所以现在，我们只需要将它们添加到我们的项目中，以便访问所有这些精彩内容。现在，看看这个包提供的内容，这些都是近战武器，但遗憾的是，在撰写本文时，没有免费的长距离（枪械）武器包，所以我们只能将就使用我们已有的。点击库，滚动到宝库部分，找到Infinity
    Blade: Weapons并点击添加到项目。从这里，你需要点击顶部的显示所有项目框，并选择我们的Mastering项目。它可能会抱怨这些资产与其它引擎版本不兼容，所以从下拉菜单中选择4.19（或者本地引擎构建的最新版本）然后添加到项目。可能还需要下载这些资产。当然，等待这个过程完成。'
- en: 'Now, opening our project in the editor, if you have your sources panel open, you
    will see in the Content Browser a new folder, `/Content/InfinityBladeWeapons`,
    under which there are several which are characters (note that some are static
    meshes, but as our original gun and pickups expect, we will stick to some of the
    character weapons). Feel free to open, for example, `/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager`
    and open the `SK_Blunt_Ravager` skeletal mesh to get a look at this interesting
    spiky hammer weapon. We''ll use a few of these to make some new weapons for our
    game. Since we have already been through this process in [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory
    and Weapons for the Player*, I will quickly list the steps I am using here to
    create a few new items:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开我们的项目，如果您打开了源代码面板，您将在内容浏览器中看到一个新文件夹，`/Content/InfinityBladeWeapons`，其中包含几个角色（请注意，其中一些是静态网格，但正如我们的原始枪和拾取物所期望的，我们将坚持使用一些角色武器）。您可以自由打开，例如，`/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager`，并打开`SK_Blunt_Ravager`骨骼网格来查看这个有趣的带刺锤子武器。我们将使用其中的一些来为我们的游戏制作一些新武器。由于我们已经在[第2章](5cc3645d-8420-4178-9897-2c71100caeac.xhtml)中经历了这个过程，*玩家的库存和武器*，我将快速列出我在这里创建一些新物品所使用的步骤：
- en: In our `/Content/FirstPersonCPP/Blueprints` folder, I'll right-click BigBallGun
    and Duplicate it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`/Content/FirstPersonCPP/Blueprints`文件夹中，我将右键单击BigBallGun并复制它。
- en: I'll do the same thing for the pickup (BigBallGunPickup).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将对拾取物（BigBallGunPickup）做同样的事情。
- en: For the ravager weapon, I will now rename these blueprints RavagerGun (yes,
    we're making a gun out of a hammer, but again, the art is just what we have available),
    and RavagerGunPickup, leaving the other items (such as projectile) the same as
    the BigBallGun.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于破坏者武器，我现在将把这些蓝图重命名为RavagerGun（是的，我们正在用锤子制作一把枪，但再次强调，艺术只是我们目前可用的），以及RavagerGunPickup，其他物品（如弹丸）与BigBallGun保持相同：
- en: Opening the RavagerGun in the full BP editor, and selecting its WeaponMesh component,
    I can now set this to the SK_Blunt_Ravager we just looked at.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完整的BP编辑器中打开RavagerGun，并选择其WeaponMesh组件，我现在可以将其设置为刚刚查看过的SK_Blunt_Ravager。
- en: 'Similarly, I set the BallGunPickup mesh component to use the same skeletal
    mesh, and rename the component to PickupMesh so that as we duplicate them in the
    future this has a generic name:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我将BallGunPickup网格组件设置为使用相同的骨骼网格，并将组件重命名为PickupMesh，这样在将来复制它们时就有了一个通用的名称：
- en: '![](img/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png)'
- en: And lastly, to differentiate it, I set the Weapon Power to 2 in the RavagerGunPickup(self)
    details and select the RavagerGun from its Mastering Weapon Pickup fly-out. You
    can, of course, set the weapon's Projectile to any you'd like, or make a new one,
    adjust its position in the player's hands, and so on; but for now, we have an
    axe that shoots!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了区分它，我在RavagerGunPickup(self)的详细信息中将武器功率设置为2，并在其Mastering Weapon Pickup下拉菜单中选择RavagerGun。当然，您可以将武器的弹丸设置为任何您想要的，或者创建一个新的，调整其在玩家手中的位置等；但到目前为止，我们有一个可以发射斧头的武器！
- en: Adding one of the pick-ups to the level and testing it quickly is a good checkpoint
    to add the project to GitHub.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将其中一个拾取物添加到关卡中并快速测试是一个很好的检查点，可以将项目添加到GitHub。
- en: Pulling down the GitHub project from this point will require a bit more time
    as these assets download (which are larger than the entire rest of the project
    to this point!), but that delay will only happen the first time they are pulled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始拉取GitHub项目将需要更多的时间，因为这些资产下载（比到目前为止项目的其余部分都要大！），但这种延迟只会发生在第一次拉取时。
- en: I will repeat this process of adding a weapon and pick-up two more times until
    there's a total of five weapons at the moment that can be differentiated. For
    organization purposes now that there are more than a couple of blueprints, I'm
    moving all of these weapons, projectiles, and pickups to a new `/Content/FirstPersonCPP/Blueprints/Weapons`
    folder. Our next step is to get some icons built from these models. Some projects
    will have artists that want to draw these by hand; other games may have no artists
    and use this technique or simply draw the actors directly into a render target
    texture to display these items. The render target idea is explored further in
    the additional reading section, but for now, let's focus on generating icons from
    screenshots in an automated way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish great looking, alpha-masked output icons for high-quality UI
    use, we will need to do a few things in this order:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Make a new Camera Actor that automates our process and takes our screenshots.
    Implementing this camera will have several parts as well, including placement
    and orientation of our weapon actors, taking depth-masked screenshots, and importing
    those back to our actors as textures.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new level, add an instance of our new camera to it, and add a SkyLight
    to it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hook the imported texture back into our pick-ups to pass to the UI.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an icon widget in UMG that takes a weapon's texture on creation.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a list in UMG and add this to the HUD. Hook the inventory class to the
    list widget and have it update to reflect the player's weapon choice.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With most significant game features such as this, there are a number of steps,
    and each has various levels of complexity; but if you can order them in such a
    way to implement and test each of them as we go, as the preceding process is designed
    to do, it's just a matter of time before you go from A to B and have your finished
    system. So let's get started with the new camera class. In the editor at the `/Content/Blueprints`
    level, I'll add a new C++ class and name it MasteringIconCamera, and derive it
    from CameraActor. This camera's whole job will be to open weapon pickups and place
    them in a nice way in front of it and then take screenshots, which  we will use
    as icons.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an opportunity to show where using blueprints can be a real time saver.
    It''s most definitely possible to simply place a camera directly in a level, and
    with some work, get its viewport to take screenshots. If time permits and someone
    is determined or is very experienced with these systems in C++, it can be done
    with effort. Or, you can make a game mode in blueprint, make a new pawn in blueprint,
    and no C++ native classes are needed. As we have made blueprint classes before,
    I''ll just list the steps taken in this section and, as always, if problems arise,
    this progress is available in GitHub to check against:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In the Blueprints folder, create an IconMaker folder, and in it create a new
    blueprint based off Pawn, named IconPawn.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a game mode based on GameModeBase. Name it IconGameMode.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the game mode, uncheck Allow Tick Before Begin Play (set false), set HUD
    Class to None, and set Default Pawn Class to IconPawn.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In IconPawn, under its DefaultSceneRoot, add a ChildActor component and set
    its Child Actor Class to MasteringIconCamera.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that child camera, uncheck Constrain Aspect Ratio in Camera Component's Camera
    Settings (this avoids a check from often asserting when using custom depth field
    screenshots).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally set the FOV (for experimental purposes, I set it to 45 as it makes
    some of the math easier to test later). Any range from very small to 90+ is fine.
    Normally for this kind of thing I'd want to use an orthographic camera for simplicity,
    but lighting has had many problems in UE4's orthographic rendering for years.
    We handle FOV in code, as seen later.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is it for the blueprint classes. Now we need a new level to use them in.
    So in the editor, be sure to save your blueprints, then go to File > New Level,
    picking the Empty Level template and naming it `IconScreenshotMap`. Drag an Icon
    Pawn into the level and in the Details pane with it selected, be sure its location and
    its rotation is set to `0`, `0`, `0`. We can also borrow a trick from the FPS
    template''s example map, and under our in-level pawn''s Pawn properties, set Auto
    Possess Player to Player 0\. This way, when the game starts, it puts the local
    default player right into this pawn rather than making one from a player spawn.
    Another tip: you can copy all of the lighting objects (or the whole lighting folder)
    from `FirstPersonExampleMap` and paste them into this map.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In any case, you will certainly need a Sky Light and probably want a Directional
    Light as in the GitHub version, but this is a bit subjective for changing the
    look of the weapons as we screenshot them. Tthe GitHub version may be a bit too
    bright, making the renders a little washed out; but again, this is subjective
    and not the focus of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a level and lighting, let's fix up some World Settings in the
    main editor tab for the level. Set the GameMode Override to IconGameMode, and
    down in Physics, we want to check the Override World Gravity box and set it to
    0.0 (we don't want our pawn immediately, or ever, falling). For completeness,
    I added a pickup for the default ball gun and put a scale on the big ball gun
    pickup to differentiate it later. So now our level and picture-grabbing pawn are
    all set; all we need now is for the camera in it to actually do something!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin in its `BeginPlay` function back in C++. Our header has several
    member variables and a number of functions that we''ll need to automate our screen-grabs:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the interest of brevity when posting progress here, I''m leaving out a lot
    of the normal spacing and comments that might normally accompany these things
    in a professional environment. Hopefully, the more traditional and formal examples
    in the previous chapters have given some good overall guidelines there, but if
    you notice these things missing here, it''s to save space as we have a lot to
    cover, not out of bad habit. As usual, when there are new concepts, they will
    be discussed along with the code here. In this case, there''s a new `UPROPERTY`
    tag, `Transient`. This tells the engine that these properties are never to be
    saved with the object: they''re used during its lifetime and can be used as any
    other `UPROPERTY` can, but changes to them do not "dirty" the object to require
    saving, and the contents are never serialized in and out with an instance of the
    object. A brief note on the properties near the bottom: `ShotDelay` is the amount
    of time we pause between loading a new weapon pickup in-game and taking its screenshot.
    This is there primarily to allow some frames for the game to spawn the objects
    and then update them to be in the proper MIP map level of detail. We will be asynchronously
    loading in all the blueprints for the weapon pickups, but this delay is still
    needed because even with assets loaded, objects often still come in at their lowest
    MIP level and if we take a screenshot right then, the quality is at its worst:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发布进度时保持简洁，我在这里省略了很多在专业环境中通常伴随这些内容的正常间距和注释。希望前几章中更传统和正式的例子已经提供了一些很好的总体指导原则，但如果您注意到这里缺少这些内容，那是因为我们需要覆盖的内容很多，而不是出于坏习惯。通常情况下，当有新概念时，它们将与代码一起在这里进行讨论。在这种情况下，有一个新的`UPROPERTY`标签，`Transient`。这告诉引擎这些属性永远不会与对象一起保存：它们在其生命周期内使用，可以像任何其他`UPROPERTY`一样使用，但对其更改不会使对象“变脏”而需要保存，并且内容永远不会与对象的实例进行序列化和反序列化。关于底部附近的属性简要说明：`ShotDelay`是在游戏中加载新的武器拾取并截图之间暂停的时间量。这主要是为了给游戏一些帧的时间来生成对象，然后更新它们以处于正确的MIP地图细节级别。我们将异步加载所有武器拾取的蓝图，但这个延迟仍然是必需的，因为即使有加载的资产，对象通常仍然以最低的MIP级别进入，如果我们当时截图，质量是最差的：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a few interesting things to discuss here. The first is commented at
    the top that `BeginPlay` can be, and will be, called multiple times on a single
    object (generally two), and we only need to or want to do the work here once.
    So first, we set the player into cinematic mode, shutting down movement and HUD
    and anything else that's not really needed with our super basic pawn, but a good
    idea in areas such as this in general. We set this camera as the view target and
    get our path, which is defaulted to where the weapon, pickup, and projectile blueprints
    were moved: `/Game/FirstPersonCPP/Blueprints/Weapons`. However, this can be edited
    on an individual icon camera to point to any specific folder as it's an exposed
    `UPROPERTY` (just like the screenshot resolution and delay mentioned earlier).
    Next, the `UObjectLibrary` class is used to mass-find our pickup objects in the
    path. We quickly iterate the list of them, making soft references to those objects.
    This is not strictly required, but like a few other topics in this chapter, it's
    meant to be instructive and start building good habits when you're thinking about
    how to reference objects as you go. On a PC, often you can simply load all the
    necessary assets all the time for a given level and only free them when you finish
    playing. On mobile and other platforms, memory can be at a premium, so it's good
    to have the tools in hand to load assets in the background, not stopping the game,
    and then also to be sure they will be freed by garbage collection later when they're
    no longer needed. Once the list of pickups is made, we send that to the `StreamableManager`
    to batch stream in our blueprints that we need to use. In that request, we add
    a callback to ourselves using `FStreamableDelegate`'s `CreateUObject` (this creates
    a callback tied to a `UObject`, in most cases using the `this` pointer). When
    all these blueprints are loaded into memory, it will call `OnFinishedLoadingAssets`,
    which we'll look at next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: To speed up testing during work like this (where you simply need to open a level,
    have it run, and exit), you can right-click the Mastering project in the Solution
    Explorer and add the map name and `-game` to your Command Arguments line so it
    looks like this: `"$(SolutionDir)$(ProjectName).uproject" IconScreenshotMap -game
    -skipcompile -debug`. This tells the DebugGame Editor build to launch directly
    into the game, but as an Editor build. It will still use uncooked content. If
    you built DebugGame, you will get an error on startup if you are not also cooking
    your content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once our blueprints are all loaded, we need to spawn one of each of these
    as actors into the world, take our shot, and then destroy that one and move to
    the next. We''ll do this with a timer and a lambda function (our first, but certainly
    not last). Look at what we have so far:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we first convert our soft references (the `TArray` of `FSoftObjectPath`
    items) to hard references (in this case, a simple `UPROPERTY` `TArray` of `UBlueprint`
    pointers). If you find yourself having trouble with memory leaks or running out
    of memory, always remember that a `UPROPERTY` pointer in UE4 will count as a hard
    reference to the object it points to, preventing it from being freed until you
    null out that pointer (or point it at another object), or the object with the
    pointer is destroyed upon which it is also released. You can always walk up the
    chain of `UObject` `Outer` pointers to find out who ultimately owns any other
    `UObject`, but right now, we want to force all these blueprints to stay loaded
    in memory, hence why we convert the soft references to hard ones. After this,
    we cue up our first pickup to be shot by calling `SpawnAndPlaceNextActor`, which
    we will get to shortly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将我们的软引用（`FSoftObjectPath` 项的 `TArray`）转换为硬引用（在这种情况下，是一个简单的 `UPROPERTY`
    `TArray` 的 `UBlueprint` 指针）。如果你发现自己遇到了内存泄漏或内存不足的问题，请始终记住，UE4 中的 `UPROPERTY` 指针将被视为指向的对象的硬引用，直到你将该指针置为空（或指向另一个对象），或者拥有该指针的对象被销毁时，该对象才会被释放。你可以通过遍历
    `UObject` 的 `Outer` 指针链来找出最终拥有任何其他 `UObject` 的对象，但现在是我们要强制所有这些蓝图保持在内存中，这就是为什么我们将软引用转换为硬引用的原因。之后，我们通过调用
    `SpawnAndPlaceNextActor` 来安排第一个拾取物被射击，我们稍后会讨论这个函数。
- en: 'For most programmers learning C++ in the last 5 or so years, lambda functions
    are pretty common. For those learning C++ in earlier years this could be something
    new, but they''re incredibly useful and supported by many areas of UE4\. We use
    one here in a simple timer from the game''s timer manager: we set an initial delay
    to our `ShotDelay` member time, as well as the rate the timer will fire at since
    we set it to looping, and only break this looping when a special condition is
    hit. `CurrentWeaponIndex` being 0 means we have finished and are out of pickups
    to capture. The way to stop a looping (or any active non-looping) timer is to
    have the timer manager clear that timer based on the handle you passed when you
    set the timer. Now, every `ShotDelay` interval, we''ll call `TakeShot`, which
    also cues up the next shot when it finishes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在过去 5 年左右学习 C++ 的程序员来说，lambda 函数相当常见。对于那些早年学习 C++ 的人来说，这可能是新事物，但它们非常有用，并且得到了
    UE4 许多领域的支持。我们在游戏计时器管理器的一个简单计时器中使用了它：我们将 `ShotDelay` 成员时间设置为初始延迟，以及计时器将触发的速率，因为我们将其设置为循环，只有在满足特殊条件时才会中断这个循环。`CurrentWeaponIndex`
    为 0 表示我们已经完成并且没有拾取物可以捕获。停止循环（或任何活动的非循环）计时器的方法是让计时器管理器根据你设置计时器时传递的句柄清除该计时器。现在，每隔
    `ShotDelay` 间隔，我们将调用 `TakeShot`，这也会在完成时安排下一次射击。
- en: 'As the next thing called is that `TakeShot` function, let''s look at it next:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要讨论的是名为 `TakeShot` 的函数，让我们来看看它：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You'll notice in many of these functions there are `checks` before simply calling
    functions on those items, such as the Mesh pointer. Given how automated this functionality
    is, if content creators were having trouble building proper pickups, you would
    be alerted anywhere important here, but if this were a problem you'd likely want
    to handle those kinds of setup mistakes in a way that doesn't crash the editor
    for non-programmers (people hooked into Visual Studio or the like can always skip
    passed check assertions with Set Next Statement or the like). But again, for brevity,
    and as a minimal safeguard to alert of a problem before a simple crash, these
    `checks` are at least here. So, getting that Mesh, we then set it up for a proper
    screenshot, make sure our game's global screenshot resolutions are set to ours,
    set up our screenshot's properties, and take one using the game viewport. It's
    by far the easiest one to access, and this is why we take ours from the player
    pawn's perspective here. We then set an intentionally short timer so the next
    frame we move to the next actor, or signal to the previous timer that we're done
    via resetting the weapon index. As noted in the comment, if you destroy an actor
    (as `SpawnAndPlaceNextActor` will) it is likely that it then will not show up
    at the time the screenshot is resolved, but if you wait one frame for the shot
    to finish, there's no problems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在这些函数中，在直接调用这些项目上的函数之前，比如Mesh指针，都有`检查`。鉴于这个功能的自动化程度，如果内容创作者在构建合适的拾取物品时遇到麻烦，你会在任何重要的地方收到警告，但如果这是一个问题，你可能会希望以不会使编辑器崩溃的方式处理这些设置错误（连接到Visual
    Studio等的人可以始终通过设置下一个语句等方式跳过检查断言）。但再次强调，为了简洁，并且作为在简单崩溃之前警告问题的最小保障，这些`检查`至少在这里。因此，获取那个Mesh后，我们将其设置为适当的截图，确保我们的游戏的全局截图分辨率设置为我们的设置，设置截图的属性，并使用游戏视口进行截图。这是最容易访问的，这也是为什么我们在这里从玩家角色视角进行截图的原因。然后我们设置一个故意很短的计时器，以便在下一次帧中移动到下一个演员，或者通过重置武器索引向之前的计时器发送完成信号。正如注释中所述，如果你销毁一个演员（如`SpawnAndPlaceNextActor`所做的那样），那么在截图解析时它可能不会显示出来，但如果你等待一帧让拍摄完成，就没有问题。
- en: 'So you''ve seen it a couple of times now; let''s look at `SpawnAndPlaceNextActor`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过它几次了；让我们看看`SpawnAndPlaceNextActor`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hopefully, this function is much more straightforward and does not require much
    attention. We destroy any current existing actor, get the one our index is set
    to as a blueprint, spawn one of those in the world with the blueprint's `GeneratedClass`,
    stop it from spinning, fix its location, and increment our index.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个函数更加直接，不需要太多关注。我们销毁任何当前存在的演员，获取我们索引设置为蓝图的那个演员，在世界中使用该蓝图的自定义类`GeneratedClass`创建一个，停止它旋转，修复其位置，并增加我们的索引。
- en: 'So, how do we fix up that location? By finally using a little bit of basic
    3D math:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何修复那个位置呢？通过最终使用一点基本的3D数学：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If curious about the commented out bounding box/offset drawing chunks, feel
    free to enable one or both and see what they show you. The reason I used them
    and left them in was because `SkeletalMeshActors` primarily get their bounding
    information at the time the assets are imported from whatever external tool they
    were built in (3D Studio MAX, Maya, and so on) set by the artists. As I found
    some of the Infinity Blade weapons' bounding a bit odd, I used this to make sure
    it was indeed how the assets were made, and there was not a math or other programming
    error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对注释掉的边界框/偏移绘制块感到好奇，可以随意启用一个或两个，看看它们会显示什么。我之所以使用它们并保留它们，是因为`SkeletalMeshActors`主要在从外部工具（如3D
    Studio MAX、Maya等）导入资产时获取边界信息，这是由艺术家设置的。由于我发现《无尽之刃》武器的一些边界设置有些奇怪，所以我使用这个方法来确保资产确实是按照这种方式制作的，并且没有数学或其他编程错误。
- en: In this function, we get the bounding extents of the actor, find its longest
    dimension (X, Y, or Z) and push it back until that longest side is just at the
    edge of our view frustum. If it turns out a weapon is more wide than it is long,
    we rotate the larger side to face our camera too. Figuring out how far away in
    X to move our actor to best fill/fit the screen before the shot is then just a
    bit of simple trigonometry. We can get the field of view of the camera frustum,
    and if we then consider a top-down sort of view of that frustum split down the
    middle as two right triangles, we know to get that longest side to fit we then
    use the tangent of half that frustum angle for one of the triangles. By definition,
    that tangent being the opposite side's length over the adjacent side's length,
    we divide the long side of our bounding to know how far to push the object out
    now. We also subtract out the relative position offset (InPos) of the bounding
    box itself and should have a reasonably centered location to return.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Running our icon map now should generate a screenshot in the Saved folder of
    our project for each pickup. This is a good checkpoint for GitHub, and we'll use
    those screenshots to finally make some UI elements next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Using UMG to display inventory icons on screen
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the previous section''s significant amount of code, we''ll be back working
    mostly in blueprints and the editor in this section. One quick aside: when moving
    assets in the editor, it will leave behind a redirector `.uasset` file of the
    one you moved. All this does is point anything that looks for the old one to the
    new one. There''s a Fix-Up Redirectors commandlet you can run, which searches
    your content folder for all of these and any objects referencing them, points
    them properly to the new location, and deletes the redirector. This can also be
    done manually in the content browser by finding the Other Filters | Show Redirectors filter
    setting, and you can right-click on them in the content browser and select Fix
    Up to get rid of them. I did that at this point to keep things tidy.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'So now under FirstPersonCPP I next make a Textures folder and click the Import
    button in the content browser: browsing to where the screenshots were added (`/Saved/Screenshots/Windows`).
    Select the generated `.png` files here (five in my case) and let them all import
    as textures. It''s good to have a naming convention for searching blueprints as
    projects get larger, so for all of these textures I simply name them `T_`(weapon
    name). Of course, with some effort in UE4''s C++ using the `FileManager` we could
    cleverly automate renaming the `.png` files rather easily, but importing them
    into game content as textures is a bit more involved—bulk selecting them here
    and manually renaming is sufficient for us as we get on to the task of drawing
    them in an inventory UI.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing your inventory and HUD
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving to actually draw our icons and cycle them is the first portion of this
    book where not all steps of implementation will be fully shown. All of the work
    as always is available on GitHub, and it is recommended to go look at each change
    in this `Chapter 4` branch submission, but for discussion purposes, the focus
    will be on new concepts going forward and decision making. This is, after all,
    a Mastering book, so expect the pace and complexity of work to pick up. First,
    a bit of housekeeping, as this complexity does ramp up: as a project moves into
    a more mature state, the sheer number of source files tends to increase and it''s
    best early on to start managing these into logical directories. There are really
    two main schemes for how you group things in your project hierarchy: by function
    or by system. Functionally grouping source files is along the lines of (in our
    current reorganization) things such as all UI widget classes, with maybe subfolders
    for complex specialized types. Grouping by system would be (as I''ve done here)
    more like all things related to inventory. While these may seem like trivial decisions,
    or it may feel OK with modern IDEs to simply leave every class in one flat hierarchy,
    project size and developer team size should drive your decisions here. The important
    part is to make architectural decisions like this early and then stick to them
    throughout a project for the team''s consistency.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, on to the fun stuff! The main new class we need to create in C++ is `UUserWidget`,
    like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, as they''re new to this book, note the keyword for `BlueprintImplementableEvent`:
    these functions are actually not implemented in C++, only declared in the header.
    Their actual functionality comes in the blueprint events they generate. We''ll
    get to those in a bit, but let''s now look at how they are used and then we''ll
    trace that to how they are triggered:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What''s happening here is we are hooking into an event in the `Inventory` class
    that will broadcast to all its listeners (our bindings) when events happen, passing
    weapon properties into our blueprint implementation. So, how do we do this? First
    we add these events to our inventory class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And in the `.cpp`, after a good amount of refactoring (and a couple of bug
    fixes I''m not too ashamed to admit), we have lines like these:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly added for, well, adding a weapon, and the newly implemented removal
    of weapons as well (this is done when ammo runs out).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: For a game like this, it's important to have a design in mind for how to show
    the player their inventory and know whether things such as ammo pickups without
    being a weapon pickup are possible, of course. In this case, if you're out of
    ammo, you might as well not have the weapon at all, so we remove it from the display.
    You could, of course, gray it out or the like, but again, make sure at all times
    your design drives your implementation decisions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'So we''re now communicating to our inventory display object key events when
    the inventory is changed in C++. Let''s take a moment than to see what that looks
    like on the blueprint side of this concept:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b12ef8d5-0d03-4aa8-98c7-5f393b3cda46.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note here, but it will be kept brief: notice the
    functions and variables on the left. These are blueprint-only things added with
    the + button to make all of this work. This is where a bit of mystery will remain
    unless you go to GitHub and look at all of the implementations. Hopefully, the
    functionality of these functions and variables is clear from the naming. As inventory
    items are added, widgets are added to a ScrollBox widget. The layout will follow,
    but the important concepts are that we''ll track weapon classes and icon widgets
    in parallel arrays so we can map them for selection and removal. That function
    is demonstrative of why all the functions won''t be shown here directly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/048979b9-3e71-4dc7-a0f9-b4e9aba2911c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'This is not even a particularly complex function, but it''s already a bit tight
    to get into one shot. Notice at the print-string node there''s a redirector node.
    They can be added by dragging from an execution pin (white ones) at any time,
    and then dragged around to help sometimes with the spaghetti that visual scripting
    can create. Hopefully, also you''re familiar with input and output variables (seen
    in the bottom left), blueprint functions can be extremely useful for quick implementation,
    and are all but required when working with UMG widgets. Some UI/UX designers may
    be comfortable implementing their own functionality, but mostly those roles will
    be more involved with the Designer tab, in the top-right. Let''s quickly look
    at that for this scrolling inventory widget that we''ll draw, currently, at the
    top of the screen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d86defb-fe30-4e5a-8456-336718fbe902.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Of note in the top-right is that the ScrollBox widget, in this case, is checked
    to be a variable (you can see it referenced in blueprint scripting) and the slightly
    odd arrangement of HorizontalBox widgets on the left, which basically sandwich
    our ScrollBox into a Canvas widget in the middle that is the size we want. There
    are a **lot** of widget settings to get all this correct, including an Image-based
    widget named InventoryItem that can be reviewed in the GitHub project. Looking
    for what was modified to make things work as they do is always just a search for
    those little yellow looping arrows (which, as you know if clicked, revert a value
    to its default) indicating what has been modified.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to make all of this work also requires adding a blueprint for our MasteringGameMode
    and MasteringHUD so that the former can set the latter as the HUD to use, and
    World Settings in the main level editing window can be set to use that mode:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ea8f568-dd31-4371-ade8-afac646e4081.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Notice that I un-hardcoded the crosshair texture, but exposing things like this
    to blueprint means adding extra code to handle if they are not set up properly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有将十字准星纹理硬编码，但将此类事物暴露给蓝图意味着需要添加额外的代码来处理它们是否设置正确。
- en: So the net result of this is that we can now scroll through our weapons, see
    which is selected (as it is the only full-alpha object in our list), and as we
    cycle what's in-hand, it cycles our ScrollBox full of icons, removing any that
    run out of ammo!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终结果是我们可以现在滚动浏览我们的武器，看到哪个被选中（因为它是我们列表中唯一的全alpha对象），当我们循环手中的物品时，我们的ScrollBox中的图标也会循环，移除任何耗尽弹药的图标！
- en: '![](img/a54a386a-82cb-4a67-8230-a00dbbb95735.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a54a386a-82cb-4a67-8230-a00dbbb95735.png)'
- en: 'If you find yourself getting errors trying to compile your widgets, be sure
    to note the change to `Mastering.Build.cs`. This is where you can include source
    modules your game may find itself needing (and to this point, we did not need
    UMG):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在编译小部件时遇到错误，请确保注意`Mastering.Build.cs`中的更改。这是你可以包含游戏可能需要的源模块的地方（到目前为止，我们不需要UMG）：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One last note (which will be well known to experienced GitHub users): I submitted
    my changes, *then* moved my files to reorganize them. GitHub sees moves as a deletion
    of the old file and addition of a new file, so you would lose the change history,
    but that can be seen in the two submissions that go along with this effort.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点（对于经验丰富的GitHub用户来说可能很熟悉）：我提交了我的更改，然后移动我的文件来重新组织它们。GitHub将移动视为旧文件的删除和新文件的添加，因此你会丢失更改历史，但可以在与这项工作相关的两个提交中看到。
- en: So now our inventory is synced up and good to go!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库存已经同步并准备就绪！
- en: Using UMG and game save slots
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UMG和游戏保存槽位
- en: UE 4.19+ gives us a nice class to actually save and load a chunk of data for
    objects we want to save. In our case, this will be every actor that can change
    its state or position, which right now is not a lot. But as a game grows, if in-scene
    saves are desired, it is incredibly important to start this process as early as
    possible too. Our biggest challenge will be the one class we implemented in [Chapter
    3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review and When to
    Use BP Scripting*, where almost its entire functionality was implemented on the
    blueprint side. Creating a solution that works with both native C++ classes and
    blueprints will be our all-inclusive goal for this section. The UMG UI will be
    a bit lighter than the last section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UE 4.19+为我们提供了一个很好的类，可以实际保存和加载数据块，用于我们想要保存的对象。在我们的案例中，这将是我们现在可以改变其状态或位置的每个演员，目前并不多。但随着游戏的发展，如果希望在场景内保存，尽早开始这个过程也非常重要。我们最大的挑战将是我们在[第3章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)中实现的那个类，*蓝图审查和何时使用BP脚本*，其中几乎全部功能都是在蓝图端实现的。创建一个同时适用于原生C++类和蓝图解决方案将是本节的全局目标。UMG
    UI将比本章上一节更轻量。
- en: Creating a widget for save slots
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建保存槽位的控件
- en: 'While the bulk of the work in this section will be actually implementing the
    loading and saving of various actor classes, we do of course need an interface
    to display this to players, and that is what we will do first. Our next step then
    is a UMG widget that we can bring up with buttons to facilitate this. So, back
    in the editor, we need a widget that has some touch-points back to C++ code so
    we can do the bulk of the work. To simplify this, we''ll make a new C++ class
    based on `UUserWidget`, call it MainMenuWidget, and add the class to the UI folder.
    Then, like before, we make a new blueprint asset and we will add 4 buttons to
    that in its design, like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节的大部分工作将是实际实现各种演员类的加载和保存，但我们当然需要一个界面来向玩家展示这些信息，这正是我们将要做的。接下来的步骤是一个UMG小部件，我们可以通过按钮来激活它。因此，回到编辑器中，我们需要一个具有一些与C++代码交互点的控件，这样我们就可以完成大部分工作。为了简化这个过程，我们将基于`UUserWidget`创建一个新的C++类，命名为MainMenuWidget，并将其添加到UI文件夹中。然后，就像之前一样，我们创建一个新的蓝图资产，并在其设计中添加4个按钮，如下所示：
- en: '![](img/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png)'
- en: Notice we set its initial visibility to Hidden, and at the ButtonBox level,
    the anchor is set to center screen with X and Y alignments of 0.5\. As always,
    feel free to reference the version in GitHub for all UMG/blueprint issues not
    specifically discussed here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将它的初始可见性设置为隐藏，并在ButtonBox级别，锚点设置为屏幕中心，X和Y对齐为0.5。就像往常一样，请随时参考GitHub上的版本，以解决这里未具体讨论的所有UMG/蓝图问题。
- en: 'Next, we bind the click events for each of those buttons. Click each button,
    and at the bottom of its Details tab are the events for input with a big green
    + button. Click that for each button''s OnClicked event and you''ll be taken to
    the blueprint graph at that event where it''s added. We add these functions to
    the widget class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wire the save event to the `SaveGame` function, and wire the load event to
    the `LoadGame` function as well, of course. `Open` is called by an input: we need
    to bind one in player settings as we have done in the past. I set mine to *F10*
    as this is common in several games, but of course it can be any key, touch, or
    gesture desired. In `MasteringCharacter`, I bind this input to a simple pass-through
    function that gets the HUD like so and calls a function with the same name on
    that HUD:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Back in the widget class, the `Open` and `Close` functions are worth looking
    at, but only open is listed here as close is essentially the same thing in reverse,
    setting the input mode to `FInputModeGameOnly`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now with *F10*, while playing, our main menu comes up, and when the Return to
    Game button is clicked, its event just calls close now on the widget, which unpauses
    the game and returns mouse control to our normal player input. The last special
    event, the button labeled Exit Game, has a simple blueprint node call to quit
    playing (and exit standalone), utilizing the Execute Console Command node, with
    the command `exit`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Later in the project, this is changed to a Quit Game node as this works when
    console commands may be unavailable (release builds, certain platforms, and so
    on). The Quit Game node is also nice because on mobile platforms it can simply
    send your app to the background instead of fully ending its execution. Keep in
    mind that iOS and Android can effectively end the execution of an app that is
    in the background if the OS decides it needs its resources; but again, at least
    the Quit Game node works across platforms and allows you the choice to try just
    going to the background.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the menu side at the moment. Now we need to actually save our
    game, finally!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Creating a save game file
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As noted at the top of this section, our actual game and the state of all our
    dynamic actors is done in three major steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Add an interface to all actors that need to save. This involves a few changes
    to our moving platform, which we'll try to keep straightforward.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialize all our actors' desired variables to an `FArchive` by tagging our
    `UPROPERTIES`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write this to a file we can then serialize everything back out from.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For very simple saving (such as player stats and the current level), be sure
    to check out the `USaveGame` document link in the *Further reading* section at
    the end of the chapter. Now, on to our relatively complex version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: First we need an interface that we'll add to all of our actors that we care
    about saving, this is the first time we need to make a C++ class outside the editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: When making new C++ from files, it's often just easiest to right-click the tabs
    at the top of Visual Studio, open Containing Folder, copy paste a `.h` and `.cpp`
    file up one folder, rename them as needed, copy them back down to the proper folder,
    then generate project files by right-clicking the `.uproject` or using the batch
    file style mentioned in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter.* Of course, the body of the files needs
    to be replaced.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The header of the `.h` should look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And what is nice about BlueprintNativeEvent is that we can fire these from C++,
    but have them executed in blueprint. The class we have some new work to do for
    is our moving platform, which again, exists and is defined solely in blueprint.
    Making the interface `BlueprintType` means we can add this easily to our platform
    blueprint-only class. So, heading to that class, here are the steps we need to
    get it saving properly to the archive. Open the moving platform class, click Class
    Settings at the top main menu bar, and on the right, you'll see Implemented Interfaces,
    and we can click Add and select Saved Actor Interface to add this functionality
    on the blueprint side. Once we compile the blueprint, we can add an event then
    for when the actor is loaded. To properly set it in the right state, we need to
    click on its two variables in the My Blueprint tab on the left, and in their Details
    tab, click the down arrow to expose the rest of its options and check the box
    for SaveGame for both the GoingHome and StartPosition blueprint variables. Now,
    when we serialize a platform to an archive, these will be saved and loaded and
    while ideally we would "lasso" select a set of nodes and right-click and select
    Collapse to Function, we can't do this here because asynchronous nodes such as MoveComponentTo
    have to stay in the Event Graph layer. But let's add an event for the interface's
    Actor Loaded and then just copy paste some of the movement nodes, making sure
    that if the platform needs to be moving it goes the right way (based on the Going
    Home variable). There's no harm telling a platform to go where it already is,
    so we'll set it on the case it has Going Home set to move to its Start Position.
    Also fixed slightly is the on-actor-overlap event from before. It will go to Start
    Position + 300 in Z, rather than its current position. So that fixes arguably
    our hardest case, the blueprint-only class of the group. Let's add the interface
    to our other classes, and give them a general save functionality as well as a
    couple of specific ones (such as our `MasteringCharacter`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: MyData will consist of all the `UPROPERTY` items we tag with `SaveGame`. Right
    now, the only one of these we would really need to add is the player's inventory;
    but because that has class references and an array of structs that also directly
    reference a texture and class, we'll custom handle inventory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Saving class and asset references directly does *not* work if you tag those
    `UPROPERTIES`. If an object references another object that will be created when
    the level is loaded, this may work, or to be safe you can look up placed-in-world
    actors by name in a fix-up pass. Most times, you save the class as a string, then
    respawn whatever object that is, as we will do extensively here as well as with
    our inventory special case saving.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If we had other basic types (such as the blueprint variables on our moving platform),
    simply add `UPROPERTY(SaveGame)` to their definition and they automatically serialize
    in and out with the actor data. To make inventory load and save properly, we need
    a couple of new structs and its own serialization to and from them, which we will
    demonstrate in the next section. Since it is not an actor class, it is a little
    annoying to put its structs in the same place as those actor saving ones, but
    this still seems at this level of complexity to be the best place. So now, how
    do we use this menu, some new UI, and a lot of saving and loading code to save
    everything that can change in our levels at any moment and load right back? Let's
    dive into that now!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Save and load from our menu
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Saving our data is relatively straightforward, but as with all load/save systems,
    is mirrored with a little more difficulty on the load side. This functionality
    is almost exclusively implemented in the `MainMenuWidget` class, though I can
    see that the class might grow, moving it to the `SavedActorInterface` or the like;
    but let''s now go forward with what is done:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For saving there is a fair bit going on here, some of which is just basic file
    I/O, but other parts may be unintuitive and are discussed here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We save the timestamp and then split the map name with the `_` character. This
    is a bit of a risk because you'd, of course, want to make it very clear to level
    designers not to add this character to their map names. In this case, when we're
    playing and testing in PIE, it appends a couple of things to the left of the map
    name that end with `_` and so splitting from the end gets us, for example, `FirstPersonExampleMap`
    without the PIE prefixes that wind up there when playing in the editor. We then
    get a list of all actors that implement our save interface and iterate them. We
    then always save out the relevant actor transient data, but also look to see whether
    we've found our mastering character to do a bit of inventory work. As noted earlier,
    our inventory saving (and loading) needs to be done with the `FInventoryItemData`
    struct and not the `FWeaponProperties` struct inventory uses directly, because
    the latter references a class and texture directly (we need them saved by their
    path/name to properly serialize and then be reloaded from them).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We set all the relevant information, then serialize to a binary for output and
    save the file, giving it the name of the timestamp we used. You could of course
    let the user pick the name, or save it otherwise, but this at least shows clearly
    when loading what time this save was from.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: After we have saved, we set the mouse cursor back to hidden, unpause the game,
    and close the main menu.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading, we first have to add some more UI to allow the player to pick
    the save that they want to load (or cancel):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e333d904-ecd1-451e-b0fc-97d700fc8e9f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Notice the switcher UMG item. This lets us basically switch (of course) what
    is shown by the widget from that hierarchy down. We set this from nodes in the
    main menu blueprint, like when we open the loading portion here in a new function
    from the load-button''s on clicked event:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0366ca45-5235-4ed9-a1e1-871f5162da28.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'We then call the native function to get all the save files:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And then we create and add a button for each of them (with the main menu as
    a member) to the load game list. We make a quick UserWidget blueprint that has
    a simple button and text layout like so, that has one job to do when clicked:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9bae0fb-3fe2-4a61-bdd4-891e057a56ec.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'For those looking closely, there are a couple of points that could be handled
    differently. We will be addressing them later in the book. I would call out that
    we load (or restart) the map for the save, loading its data, and then, storing
    it in a static member variable that survives the map re-loading and is then triggered
    by the HUD''s `BeginPlay`. We''ll be exploring ways to switch from level to level
    and pass data between them in [Chapter 6](978665f4-5638-4a71-9f86-c0349e090ae7.xhtml),
    *Changing Levels, Streaming, and Retaining Your Data*, so fear not if you still
    have questions there. Also, at the moment, the only way to delete save files is
    to go to your content folder, but with all the work we''ve done here, adding a
    delete to your menus should not be an issue. And one last note: it''s also possible
    in a number of ways to hook one widget to another. In this case, I simply pass
    the menu to the button when the menu makes it. There''s nothing wrong with using
    clever techniques, just keep in mind that going with the simplest solution sometimes
    saves time, which every game ends up needing as it gets closer to being ready
    for the public.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: So that's it, we made it! Checking GitHub, there's a new level with some changes
    in it, but that's really just there for now to prove out load-save from level
    to level and back again. Have fun testing that out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter really ramps up the complexity level of work closer to the mastering
    level. After some warm-up work, it''s definitely time to dig into this level of
    detail and start to really learn the tips and tricks that can make or break a
    game in development. The work here should give a solid base to a number of levels
    of UI work: we made a bunch of new weapons, used our pick-ups to generate screenshot
    icons of them, added these back to the pick-ups and our inventory, utilized that
    inventory to build and sync up a scroll bar of weapons, and made menus and an
    entire save-anywhere system for all of our objects, whew! The project is finally
    starting to look more like a real game compared to the bare-bones template we
    began with, but one thing is missing: enemies to fight. But fear not, we''ll have
    those by the end of the next chapter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将工作复杂性提升到接近精通水平的程度。经过一些热身工作后，确实到了深入研究这一层次细节并开始真正学习那些可以使游戏开发成功或失败的小技巧的时候了。这里的工作应该为多个层次的UI工作提供一个坚实的基础：我们制作了许多新武器，使用拾取物生成它们的截图图标，将这些图标添加回拾取物和我们的库存中，利用这个库存构建并同步武器滚动条，并为所有对象制作了菜单和整个任意保存系统，哇！与最初我们开始时的裸骨模板相比，项目终于开始更像一个真正的游戏了，但有一件事还缺失：敌人。但不用担心，我们将在下一章的结尾拥有它们。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to commit any changes to files to GitHub before moving them
    to a new folder location?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在将文件移动到新文件夹位置之前，将任何更改提交到GitHub很重要？
- en: What are the steps needed to make a pawn that won't move or fall upon starting
    an empty level?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在启动空关卡时不会移动或掉落的NPC需要哪些步骤？
- en: What are the two ways of cleaning up redirectors in UE4, and why is it important
    to do so from time to time?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4中清理重定向器的两种方法是什么，为什么有时这样做很重要？
- en: What UMG child widgets can be used for placing and spacing other widgets within
    a parent?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父窗口中放置和间距其他小部件时，可以使用哪些UMG子部件？
- en: What is the advantage of using `BlueprintImplementableEvents` in communicating
    from C++ to UMG?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BlueprintImplementableEvents`在C++与UMG之间通信的优势是什么？
- en: Which types of `UPROPERTIES` must absolutely not be attempted to serialize when
    saving class variables?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存类变量时，哪些类型的`UPROPERTIES`绝对不能尝试序列化？
- en: What alternative to saving those properties was used here to save and restore
    those special types?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，为了保存和恢复这些特殊类型，使用了哪种保存属性的替代方法？
- en: Which system was used to implement in only a few lines the building of a list
    of files matching an extension?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用几行代码实现匹配扩展名的文件列表构建的系统是哪个？
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Simple saves with `USaveGame`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`USaveGame`的简单保存：
- en: '[https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code](https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code](https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code)'
