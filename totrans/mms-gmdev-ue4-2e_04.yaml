- en: U.I. Necessities, Menus, HUD, and Load/Save
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 必需品、菜单、HUD 和加载/保存
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will get to work on another fundamental necessity of any
    game: our UI, and as a typical example of it, we''ll add loading and saving of
    our game state to our game. Unreal provides some great tools for these two things,
    especially UMG for creating UIs, which we will explore here. When it comes to
    loading and saving your game, it is a system almost every game uses in some form,
    but none in the same way, and the complexity of it will be absolutely driven by
    your design and desired player experience. We''ll first get our inventory showing
    up in our HUD. In the next section we''ll address some strategies for saving based
    on different game types, and then we''ll tackle one of Unreal''s most difficult:
    saving in-map and restoring to an exact point during gameplay.  In this chapter,
    we''ll:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将着手处理任何游戏的基本需求之一：我们的UI，作为一个典型的例子，我们将向我们的游戏添加加载和保存游戏状态的功能。Unreal为这两项功能提供了出色的工具，特别是UMG用于创建UI，我们将在本节中探讨。当涉及到加载和保存游戏时，几乎每个游戏都以某种形式使用该系统，但没有一个是以相同的方式，其复杂性将完全由你的设计和期望的玩家体验所驱动。我们首先将使我们的库存显示在我们的HUD上。在下一节中，我们将讨论基于不同游戏类型的保存策略，然后我们将解决Unreal最困难的问题之一：在地图中保存并在游戏过程中恢复到精确点。在本章中，我们将：
- en: Make inventory icons using an automated screen-capture level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动屏幕截图级别制作库存图标
- en: Integrate the icons into the player's HUD on screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图标集成到屏幕上的玩家HUD中
- en: Synchronize the inventory with the HUD/U.I.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库存与HUD/UI同步
- en: Save and load the full game state from anywhere
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何地方保存和加载完整游戏状态
- en: Build the U.I. for loading and saving
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建加载和保存的UI
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As usual, it is recommended to simply begin at the point of progress reached
    in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review
    and When to Use BP Scripting*, as the GitHub project does here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，建议从[第3章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)达到的进度点开始，即*蓝图回顾和何时使用BP脚本*，正如GitHub项目中所做的那样：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4)'
- en: While the [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint
    Review and When to Use BP Scripting*, content is not specifically required, [Chapter
    2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons for the
    Player*, will be heavily used and referenced, so those classes should be considered
    mandatory for the value of this work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第3章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)，*蓝图回顾和何时使用BP脚本*的内容不是特别必需的，[第2章](5cc3645d-8420-4178-9897-2c71100caeac.xhtml)，*玩家的库存和武器*将被大量使用和参考，因此这些类应被视为强制性，以体现这项工作的价值。
- en: Engine version used: 4.19.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.0。
- en: Integrating UMG into our player's HUD class
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将UMG集成到我们的玩家HUD类中
- en: In [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory and Weapons
    for the Player*, we managed to create an inventory system for our player, a means
    of picking up new weapons, and an input scheme for switching between them. However,
    other than visually seeing which projectile was fired, we had no real reference
    for what we had in hand. So now we will give the player a display so they can
    see what they are using, and as part of that, we will finally add some new art
    assets from the free Unreal Marketplace.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](5cc3645d-8420-4178-9897-2c71100caeac.xhtml)，*玩家的库存和武器*中，我们成功为我们的玩家创建了一个库存系统，一种拾取新武器的方法，以及一个在它们之间切换的输入方案。然而，除了视觉上看到发射了哪种弹丸外，我们没有实际参考我们手中有什么。因此，现在我们将为玩家提供一个显示，让他们可以看到他们正在使用什么，作为其中的一部分，我们最终将添加一些来自免费Unreal市场的新的艺术资产。
- en: Building icons for the inventory with screen captures
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏幕截图构建库存图标
- en: To make this exercise more meaningful and a bit more of a real-world scenario,
    we need more art. As stated before, however, this is not a book about generating
    art or most UE4 content. That said, as a technical developer trying to prove what
    can and can't be done, and without requiring you, the reader, to spend money on
    Marketplace content or outsourced art studios the way a production game typically
    would, we will use some stand-in art that's free. So the first thing to do is
    to get to the Epic Games Launcher. As first noted in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml),
    *Making a C++ Project for a First-Person Shooter*, it's usually best to just make
    a shortcut directly to your UE4 editor executable. In case you forgot, here is
    that sentence where I recommend "*creating a shortcut to your UE4 install folder's*
    `/Engine/Binaries/Win64/UE4Editor.exe`," or of course you can manually just go
    and click it to launch it as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个练习更有意义，更接近现实场景，我们需要更多的艺术作品。然而，正如之前所述，这本书并不是关于生成艺术或大多数UE4内容的。话虽如此，作为一个试图证明可以和不可以做什么的技术开发者，并且不需要你，读者，像制作游戏那样在Marketplace内容或外包艺术工作室上花钱，我们将使用一些免费替代的艺术作品。所以首先要做的是打开Epic
    Games Launcher。正如在[第一章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)中首次提到的，“为第一人称射击游戏创建C++项目”，通常最好的做法是直接创建一个指向你的UE4编辑器可执行文件的快捷方式。如果你忘记了，这里就是我推荐“创建一个指向你的UE4安装文件夹的`/Engine/Binaries/Win64/UE4Editor.exe`”的句子，或者当然你也可以手动点击它来启动它。
- en: 'This launches the editor with no game, brings up a list of game projects you
    could open, but also in that Unreal Project Browser in the top-right is a Marketplace
    button, so let''s head there. At the very top, make sure you select Unreal Engine,
    then on the left, click Marketplace. At the top of the content row, you will find
    what can be a great friend to teams looking to prototype with cool-looking content
    or make games based on some amazing Epic released assets, the Free tab. Scroll
    down to Infinity Blade: Weapons and Add to Cart (and then check out with the little
    shopping cart in the top-right corner):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '这将启动编辑器而没有游戏，会弹出一个你可以打开的游戏项目列表，但在右上角的Unreal项目浏览器中有一个Marketplace按钮，所以让我们去那里。在最顶部，确保你选择了Unreal
    Engine，然后在左侧点击Marketplace。在内容行顶部，你会找到一个对于想要使用酷炫内容进行原型设计或基于一些惊人的Epic发布资产制作游戏的团队来说可能非常有用的朋友，那就是免费标签。滚动到Infinity
    Blade: Weapons并添加到购物车（然后点击右上角的购物车结账）：'
- en: '![](img/524d4530-5cbc-4bc5-b550-2488e2a4f428.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/524d4530-5cbc-4bc5-b550-2488e2a4f428.png)'
- en: 'These will now appear when you select the Library item on the left, below Marketplace.
    So now, all we need to do is add them to our project to get access to all this
    great content. Now, glancing at what this package gives you, these are all melee
    weapons of course, but unfortunately, at the time of writing, there is not a pack
    of free ranged (gun) weapons, so we''ll make do with what we''ve got. Click Library
    and scroll to the Vault section to where you find Infinity Blade: Weapons add
    click Add to Project. From here you will need to click the box for Show all projects
    at the top, and select our Mastering project. It will complain these assets are
    not compatible with Other engine version, so select 4.19 from the dropdown (or
    whichever is the newest version at or behind the local engine you have been building)
    and then Add to Project. It may then need to download the assets. Wait for this
    to finish, of course.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '当你选择左侧Marketplace下面的库项目时，这些内容将会显示出来。所以现在，我们只需要将它们添加到我们的项目中，以便访问所有这些精彩内容。现在，看看这个包提供的内容，这些都是近战武器，但遗憾的是，在撰写本文时，没有免费的长距离（枪械）武器包，所以我们只能将就使用我们已有的。点击库，滚动到宝库部分，找到Infinity
    Blade: Weapons并点击添加到项目。从这里，你需要点击顶部的显示所有项目框，并选择我们的Mastering项目。它可能会抱怨这些资产与其它引擎版本不兼容，所以从下拉菜单中选择4.19（或者本地引擎构建的最新版本）然后添加到项目。可能还需要下载这些资产。当然，等待这个过程完成。'
- en: 'Now, opening our project in the editor, if you have your sources panel open, you
    will see in the Content Browser a new folder, `/Content/InfinityBladeWeapons`,
    under which there are several which are characters (note that some are static
    meshes, but as our original gun and pickups expect, we will stick to some of the
    character weapons). Feel free to open, for example, `/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager`
    and open the `SK_Blunt_Ravager` skeletal mesh to get a look at this interesting
    spiky hammer weapon. We''ll use a few of these to make some new weapons for our
    game. Since we have already been through this process in [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory
    and Weapons for the Player*, I will quickly list the steps I am using here to
    create a few new items:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开我们的项目，如果您打开了源代码面板，您将在内容浏览器中看到一个新文件夹，`/Content/InfinityBladeWeapons`，其中包含几个角色（请注意，其中一些是静态网格，但正如我们的原始枪和拾取物所期望的，我们将坚持使用一些角色武器）。您可以自由打开，例如，`/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager`，并打开`SK_Blunt_Ravager`骨骼网格来查看这个有趣的带刺锤子武器。我们将使用其中的一些来为我们的游戏制作一些新武器。由于我们已经在[第2章](5cc3645d-8420-4178-9897-2c71100caeac.xhtml)中经历了这个过程，*玩家的库存和武器*，我将快速列出我在这里创建一些新物品所使用的步骤：
- en: In our `/Content/FirstPersonCPP/Blueprints` folder, I'll right-click BigBallGun
    and Duplicate it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`/Content/FirstPersonCPP/Blueprints`文件夹中，我将右键单击BigBallGun并复制它。
- en: I'll do the same thing for the pickup (BigBallGunPickup).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将对拾取物（BigBallGunPickup）做同样的事情。
- en: For the ravager weapon, I will now rename these blueprints RavagerGun (yes,
    we're making a gun out of a hammer, but again, the art is just what we have available),
    and RavagerGunPickup, leaving the other items (such as projectile) the same as
    the BigBallGun.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于破坏者武器，我现在将把这些蓝图重命名为RavagerGun（是的，我们正在用锤子制作一把枪，但再次强调，艺术只是我们目前可用的），以及RavagerGunPickup，其他物品（如弹丸）与BigBallGun保持相同：
- en: Opening the RavagerGun in the full BP editor, and selecting its WeaponMesh component,
    I can now set this to the SK_Blunt_Ravager we just looked at.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完整的BP编辑器中打开RavagerGun，并选择其WeaponMesh组件，我现在可以将其设置为刚刚查看过的SK_Blunt_Ravager。
- en: 'Similarly, I set the BallGunPickup mesh component to use the same skeletal
    mesh, and rename the component to PickupMesh so that as we duplicate them in the
    future this has a generic name:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我将BallGunPickup网格组件设置为使用相同的骨骼网格，并将组件重命名为PickupMesh，这样在将来复制它们时就有了一个通用的名称：
- en: '![](img/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png)'
- en: And lastly, to differentiate it, I set the Weapon Power to 2 in the RavagerGunPickup(self)
    details and select the RavagerGun from its Mastering Weapon Pickup fly-out. You
    can, of course, set the weapon's Projectile to any you'd like, or make a new one,
    adjust its position in the player's hands, and so on; but for now, we have an
    axe that shoots!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了区分它，我在RavagerGunPickup(self)的详细信息中将武器功率设置为2，并在其Mastering Weapon Pickup下拉菜单中选择RavagerGun。当然，您可以将武器的弹丸设置为任何您想要的，或者创建一个新的，调整其在玩家手中的位置等；但到目前为止，我们有一个可以发射斧头的武器！
- en: Adding one of the pick-ups to the level and testing it quickly is a good checkpoint
    to add the project to GitHub.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将其中一个拾取物添加到关卡中并快速测试是一个很好的检查点，可以将项目添加到GitHub。
- en: Pulling down the GitHub project from this point will require a bit more time
    as these assets download (which are larger than the entire rest of the project
    to this point!), but that delay will only happen the first time they are pulled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始拉取GitHub项目将需要更多的时间，因为这些资产下载（比到目前为止项目的其余部分都要大！），但这种延迟只会发生在第一次拉取时。
- en: I will repeat this process of adding a weapon and pick-up two more times until
    there's a total of five weapons at the moment that can be differentiated. For
    organization purposes now that there are more than a couple of blueprints, I'm
    moving all of these weapons, projectiles, and pickups to a new `/Content/FirstPersonCPP/Blueprints/Weapons`
    folder. Our next step is to get some icons built from these models. Some projects
    will have artists that want to draw these by hand; other games may have no artists
    and use this technique or simply draw the actors directly into a render target
    texture to display these items. The render target idea is explored further in
    the additional reading section, but for now, let's focus on generating icons from
    screenshots in an automated way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我将重复这个过程，添加武器和拾取两次，直到此时总共有五把可以区分的武器。为了组织现在超过几个蓝图的情况，我将所有这些武器、弹丸和拾取移动到一个新的`/Content/FirstPersonCPP/Blueprints/Weapons`文件夹。我们的下一步是从这些模型中生成一些图标。有些项目会有艺术家想要手动绘制这些图标；其他游戏可能没有艺术家，使用这种技术或直接将演员绘制到渲染目标纹理中以显示这些物品。渲染目标的想法在附加阅读部分中进一步探讨，但就现在而言，让我们专注于以自动化方式从截图生成图标。
- en: 'To accomplish great looking, alpha-masked output icons for high-quality UI
    use, we will need to do a few things in this order:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现高质量UI使用的出色外观、alpha掩码输出图标，我们需要按以下顺序做几件事情：
- en: Make a new Camera Actor that automates our process and takes our screenshots.
    Implementing this camera will have several parts as well, including placement
    and orientation of our weapon actors, taking depth-masked screenshots, and importing
    those back to our actors as textures.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Camera Actor来自动化我们的过程并获取我们的截图。实现这个相机将包括几个部分，包括我们武器演员的放置和方向、获取深度掩码截图，并将这些截图作为纹理导入到我们的演员中。
- en: Make a new level, add an instance of our new camera to it, and add a SkyLight
    to it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的关卡，向其中添加我们新的相机实例，并添加一个SkyLight。
- en: Hook the imported texture back into our pick-ups to pass to the UI.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导入的纹理重新连接到我们的拾取中，以便传递给UI。
- en: Make an icon widget in UMG that takes a weapon's texture on creation.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UMG中创建一个图标小部件，在创建时获取武器的纹理。
- en: Build a list in UMG and add this to the HUD. Hook the inventory class to the
    list widget and have it update to reflect the player's weapon choice.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UMG中构建一个列表并将其添加到HUD中。将库存类连接到列表小部件，并使其更新以反映玩家的武器选择。
- en: With most significant game features such as this, there are a number of steps,
    and each has various levels of complexity; but if you can order them in such a
    way to implement and test each of them as we go, as the preceding process is designed
    to do, it's just a matter of time before you go from A to B and have your finished
    system. So let's get started with the new camera class. In the editor at the `/Content/Blueprints`
    level, I'll add a new C++ class and name it MasteringIconCamera, and derive it
    from CameraActor. This camera's whole job will be to open weapon pickups and place
    them in a nice way in front of it and then take screenshots, which  we will use
    as icons.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的大多数重要游戏功能，有一系列步骤，每个步骤都有不同复杂程度；但如果你能以这种方式排序，以便在实施和测试每个步骤时，就像前面的过程所设计的那样，那么从A到B并拥有你的完成系统只是时间问题。所以，让我们开始新的相机类。在编辑器中的`/Content/Blueprints`级别，我将添加一个新的C++类，命名为MasteringIconCamera，并从CameraActor派生。这个相机的全部工作就是打开武器拾取，并以一种优雅的方式将其放在它前面，然后进行截图，我们将使用这些截图作为图标。
- en: 'Here is an opportunity to show where using blueprints can be a real time saver.
    It''s most definitely possible to simply place a camera directly in a level, and
    with some work, get its viewport to take screenshots. If time permits and someone
    is determined or is very experienced with these systems in C++, it can be done
    with effort. Or, you can make a game mode in blueprint, make a new pawn in blueprint,
    and no C++ native classes are needed. As we have made blueprint classes before,
    I''ll just list the steps taken in this section and, as always, if problems arise,
    this progress is available in GitHub to check against:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示使用蓝图可以节省实际时间的例子。直接在关卡中放置相机，并通过一些工作，使其视口能够截图，这是绝对可能的。如果时间允许，并且有人决心或非常熟悉这些C++系统，这可以通过努力实现。或者，你可以在蓝图内创建一个游戏模式，创建一个新的Pawn蓝图，并且不需要C++原生类。因为我们之前已经创建了蓝图类，所以我将只列出本节中采取的步骤，并且，如往常一样，如果出现问题，这个进度可以在GitHub上检查：
- en: In the Blueprints folder, create an IconMaker folder, and in it create a new
    blueprint based off Pawn, named IconPawn.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blueprints文件夹中，创建一个名为IconMaker的文件夹，并在其中创建一个基于Pawn的新蓝图，命名为IconPawn。
- en: Create a game mode based on GameModeBase. Name it IconGameMode.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 GameModeBase 创建一个游戏模式。将其命名为 IconGameMode。
- en: In the game mode, uncheck Allow Tick Before Begin Play (set false), set HUD
    Class to None, and set Default Pawn Class to IconPawn.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式中，取消选中 Allow Tick Before Begin Play（设置为 false），将 HUD Class 设置为 None，并将
    Default Pawn Class 设置为 IconPawn。
- en: In IconPawn, under its DefaultSceneRoot, add a ChildActor component and set
    its Child Actor Class to MasteringIconCamera.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IconPawn 中，在其 DefaultSceneRoot 下，添加一个 ChildActor 组件并将其 Child Actor Class 设置为
    MasteringIconCamera。
- en: In that child camera, uncheck Constrain Aspect Ratio in Camera Component's Camera
    Settings (this avoids a check from often asserting when using custom depth field
    screenshots).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个子相机中，取消选中 Camera Component 的 Camera Settings 中的 Constrain Aspect Ratio（这避免了在使用自定义深度场截图时经常断言的检查）。
- en: Optionally set the FOV (for experimental purposes, I set it to 45 as it makes
    some of the math easier to test later). Any range from very small to 90+ is fine.
    Normally for this kind of thing I'd want to use an orthographic camera for simplicity,
    but lighting has had many problems in UE4's orthographic rendering for years.
    We handle FOV in code, as seen later.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地设置 FOV（出于实验目的，我将它设置为 45，因为这使一些数学计算更容易测试）。从小到大 90+ 的任何范围都行。通常，为了简化这类事情，我想要使用正交相机，但
    UE4 的正交渲染在灯光方面已经存在很多问题多年了。我们将在代码中处理 FOV，如后面所示。
- en: 'This is it for the blueprint classes. Now we need a new level to use them in.
    So in the editor, be sure to save your blueprints, then go to File > New Level,
    picking the Empty Level template and naming it `IconScreenshotMap`. Drag an Icon
    Pawn into the level and in the Details pane with it selected, be sure its location and
    its rotation is set to `0`, `0`, `0`. We can also borrow a trick from the FPS
    template''s example map, and under our in-level pawn''s Pawn properties, set Auto
    Possess Player to Player 0\. This way, when the game starts, it puts the local
    default player right into this pawn rather than making one from a player spawn.
    Another tip: you can copy all of the lighting objects (or the whole lighting folder)
    from `FirstPersonExampleMap` and paste them into this map.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是蓝图类的内容。现在我们需要一个新的关卡来使用它们。因此，在编辑器中，请确保保存你的蓝图，然后转到文件 > 新建关卡，选择空关卡模板并将其命名为 `IconScreenshotMap`。将
    Icon Pawn 拖入关卡，并在选择它的情况下，确保其位置和旋转设置为 `0`，`0`，`0`。我们还可以从 FPS 模板的示例地图中借用一个技巧，在我们的关卡
    pawn 属性下，将 Auto Possess Player 设置为 Player 0。这样，当游戏开始时，它会将本地默认玩家直接放入这个 pawn，而不是从玩家生成中创建一个。另一个提示：你可以从
    `FirstPersonExampleMap` 复制所有照明对象（或整个照明文件夹）并将其粘贴到这个地图中。
- en: In any case, you will certainly need a Sky Light and probably want a Directional
    Light as in the GitHub version, but this is a bit subjective for changing the
    look of the weapons as we screenshot them. Tthe GitHub version may be a bit too
    bright, making the renders a little washed out; but again, this is subjective
    and not the focus of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你肯定需要天空光，可能还想像 GitHub 版本那样使用方向光，但关于改变武器外观的问题，这有点主观，因为我们在截图时可能会觉得 GitHub
    版本有点太亮，使得渲染效果略显模糊；但再次强调，这很主观，并不是本章的重点。
- en: Now that we have a level and lighting, let's fix up some World Settings in the
    main editor tab for the level. Set the GameMode Override to IconGameMode, and
    down in Physics, we want to check the Override World Gravity box and set it to
    0.0 (we don't want our pawn immediately, or ever, falling). For completeness,
    I added a pickup for the default ball gun and put a scale on the big ball gun
    pickup to differentiate it later. So now our level and picture-grabbing pawn are
    all set; all we need now is for the camera in it to actually do something!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了关卡和照明，让我们在主编辑器标签页中修复一些 World Settings。将 GameMode Override 设置为 IconGameMode，在物理部分，我们想要勾选
    Override World Gravity 复选框并将其设置为 0.0（我们不希望我们的 pawn 立即或永远掉落）。为了完整性，我添加了一个默认球枪拾取，并给大球枪拾取添加了一个缩放，以便稍后区分。所以现在我们的关卡和截图
    pawn 都已设置好；我们现在需要的只是让关卡中的相机真正做些事情！
- en: 'We''ll begin in its `BeginPlay` function back in C++. Our header has several
    member variables and a number of functions that we''ll need to automate our screen-grabs:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从其 `BeginPlay` 函数开始，回到 C++。我们的头文件中有几个成员变量和许多我们需要自动化的函数来抓取屏幕截图：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the interest of brevity when posting progress here, I''m leaving out a lot
    of the normal spacing and comments that might normally accompany these things
    in a professional environment. Hopefully, the more traditional and formal examples
    in the previous chapters have given some good overall guidelines there, but if
    you notice these things missing here, it''s to save space as we have a lot to
    cover, not out of bad habit. As usual, when there are new concepts, they will
    be discussed along with the code here. In this case, there''s a new `UPROPERTY`
    tag, `Transient`. This tells the engine that these properties are never to be
    saved with the object: they''re used during its lifetime and can be used as any
    other `UPROPERTY` can, but changes to them do not "dirty" the object to require
    saving, and the contents are never serialized in and out with an instance of the
    object. A brief note on the properties near the bottom: `ShotDelay` is the amount
    of time we pause between loading a new weapon pickup in-game and taking its screenshot.
    This is there primarily to allow some frames for the game to spawn the objects
    and then update them to be in the proper MIP map level of detail. We will be asynchronously
    loading in all the blueprints for the weapon pickups, but this delay is still
    needed because even with assets loaded, objects often still come in at their lowest
    MIP level and if we take a screenshot right then, the quality is at its worst:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发布进度时保持简洁，我在这里省略了很多在专业环境中通常伴随这些内容的正常间距和注释。希望前几章中更传统和正式的例子已经提供了一些很好的总体指导原则，但如果您注意到这里缺少这些内容，那是因为我们需要覆盖的内容很多，而不是出于坏习惯。通常情况下，当有新概念时，它们将与代码一起在这里进行讨论。在这种情况下，有一个新的`UPROPERTY`标签，`Transient`。这告诉引擎这些属性永远不会与对象一起保存：它们在其生命周期内使用，可以像任何其他`UPROPERTY`一样使用，但对其更改不会使对象“变脏”而需要保存，并且内容永远不会与对象的实例进行序列化和反序列化。关于底部附近的属性简要说明：`ShotDelay`是在游戏中加载新的武器拾取并截图之间暂停的时间量。这主要是为了给游戏一些帧的时间来生成对象，然后更新它们以处于正确的MIP地图细节级别。我们将异步加载所有武器拾取的蓝图，但这个延迟仍然是必需的，因为即使有加载的资产，对象通常仍然以最低的MIP级别进入，如果我们当时截图，质量是最差的：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a few interesting things to discuss here. The first is commented at
    the top that `BeginPlay` can be, and will be, called multiple times on a single
    object (generally two), and we only need to or want to do the work here once.
    So first, we set the player into cinematic mode, shutting down movement and HUD
    and anything else that's not really needed with our super basic pawn, but a good
    idea in areas such as this in general. We set this camera as the view target and
    get our path, which is defaulted to where the weapon, pickup, and projectile blueprints
    were moved: `/Game/FirstPersonCPP/Blueprints/Weapons`. However, this can be edited
    on an individual icon camera to point to any specific folder as it's an exposed
    `UPROPERTY` (just like the screenshot resolution and delay mentioned earlier).
    Next, the `UObjectLibrary` class is used to mass-find our pickup objects in the
    path. We quickly iterate the list of them, making soft references to those objects.
    This is not strictly required, but like a few other topics in this chapter, it's
    meant to be instructive and start building good habits when you're thinking about
    how to reference objects as you go. On a PC, often you can simply load all the
    necessary assets all the time for a given level and only free them when you finish
    playing. On mobile and other platforms, memory can be at a premium, so it's good
    to have the tools in hand to load assets in the background, not stopping the game,
    and then also to be sure they will be freed by garbage collection later when they're
    no longer needed. Once the list of pickups is made, we send that to the `StreamableManager`
    to batch stream in our blueprints that we need to use. In that request, we add
    a callback to ourselves using `FStreamableDelegate`'s `CreateUObject` (this creates
    a callback tied to a `UObject`, in most cases using the `this` pointer). When
    all these blueprints are loaded into memory, it will call `OnFinishedLoadingAssets`,
    which we'll look at next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情需要讨论。首先，在顶部有注释说明`BeginPlay`可以在单个对象（通常是两个）上多次调用，并且我们只需要或想要在这里执行一次操作。因此，首先，我们将玩家设置为电影模式，关闭移动和HUD以及我们超级基本的pawn不需要的其他任何东西，但在这种一般领域，这是一个好主意。我们将这个摄像头设置为视图目标并获取我们的路径，该路径默认为武器、拾取和投射物蓝图移动到的位置：`/Game/FirstPersonCPP/Blueprints/Weapons`。然而，这可以在单个图标摄像头中编辑，指向任何特定的文件夹，因为它是一个暴露的`UPROPERTY`（就像之前提到的截图分辨率和延迟一样）。接下来，使用`UObjectLibrary`类在路径中批量查找我们的拾取对象。我们快速遍历这些对象的列表，对这些对象进行软引用。这并不是严格必要的，但就像本章中的其他几个主题一样，它旨在具有指导性，并在你思考如何引用对象时开始建立良好的习惯。在PC上，通常你可以始终为给定级别加载所有必要的资产，并在游戏结束后才释放它们。在移动和其他平台上，内存可能非常宝贵，因此拥有在后台加载资产的工具，不停止游戏，并且在它们不再需要时通过垃圾回收确保它们被释放是很好的。一旦制作出拾取对象的列表，我们将它发送到`StreamableManager`以批量流式传输我们需要的蓝图。在这个请求中，我们使用`FStreamableDelegate`的`CreateUObject`添加一个回调给自己（这创建了一个与`UObject`绑定的回调，在大多数情况下使用`this`指针）。当所有这些蓝图都加载到内存中时，它将调用`OnFinishedLoadingAssets`，我们将在下一节中查看。
- en: To speed up testing during work like this (where you simply need to open a level,
    have it run, and exit), you can right-click the Mastering project in the Solution
    Explorer and add the map name and `-game` to your Command Arguments line so it
    looks like this: `"$(SolutionDir)$(ProjectName).uproject" IconScreenshotMap -game
    -skipcompile -debug`. This tells the DebugGame Editor build to launch directly
    into the game, but as an Editor build. It will still use uncooked content. If
    you built DebugGame, you will get an error on startup if you are not also cooking
    your content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快此类工作（你只需要打开一个级别，让它运行，然后退出）的测试速度，你可以在解决方案资源管理器中右键单击Mastering项目，并将地图名称和`-game`添加到你的命令参数行，使其看起来像这样：`"$(SolutionDir)$(ProjectName).uproject"
    IconScreenshotMap -game -skipcompile -debug`。这告诉DebugGame编辑器构建直接进入游戏，但作为一个编辑器构建。它仍然会使用未烹饪的内容。如果你构建了DebugGame，如果你没有同时烹饪你的内容，启动时将会出现错误。
- en: 'So, once our blueprints are all loaded, we need to spawn one of each of these
    as actors into the world, take our shot, and then destroy that one and move to
    the next. We''ll do this with a timer and a lambda function (our first, but certainly
    not last). Look at what we have so far:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们的蓝图全部加载完毕，我们需要将这些蓝图中的每一个作为演员实例化到世界中，然后进行拍摄，接着销毁该实例并移动到下一个。我们将使用计时器和lambda函数（这是我们第一次使用，但肯定不是最后一次）来完成这项工作。看看我们到目前为止做了什么：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we first convert our soft references (the `TArray` of `FSoftObjectPath`
    items) to hard references (in this case, a simple `UPROPERTY` `TArray` of `UBlueprint`
    pointers). If you find yourself having trouble with memory leaks or running out
    of memory, always remember that a `UPROPERTY` pointer in UE4 will count as a hard
    reference to the object it points to, preventing it from being freed until you
    null out that pointer (or point it at another object), or the object with the
    pointer is destroyed upon which it is also released. You can always walk up the
    chain of `UObject` `Outer` pointers to find out who ultimately owns any other
    `UObject`, but right now, we want to force all these blueprints to stay loaded
    in memory, hence why we convert the soft references to hard ones. After this,
    we cue up our first pickup to be shot by calling `SpawnAndPlaceNextActor`, which
    we will get to shortly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将我们的软引用（`FSoftObjectPath` 项的 `TArray`）转换为硬引用（在这种情况下，是一个简单的 `UPROPERTY`
    `TArray` 的 `UBlueprint` 指针）。如果你发现自己遇到了内存泄漏或内存不足的问题，请始终记住，UE4 中的 `UPROPERTY` 指针将被视为指向的对象的硬引用，直到你将该指针置为空（或指向另一个对象），或者拥有该指针的对象被销毁时，该对象才会被释放。你可以通过遍历
    `UObject` 的 `Outer` 指针链来找出最终拥有任何其他 `UObject` 的对象，但现在是我们要强制所有这些蓝图保持在内存中，这就是为什么我们将软引用转换为硬引用的原因。之后，我们通过调用
    `SpawnAndPlaceNextActor` 来安排第一个拾取物被射击，我们稍后会讨论这个函数。
- en: 'For most programmers learning C++ in the last 5 or so years, lambda functions
    are pretty common. For those learning C++ in earlier years this could be something
    new, but they''re incredibly useful and supported by many areas of UE4\. We use
    one here in a simple timer from the game''s timer manager: we set an initial delay
    to our `ShotDelay` member time, as well as the rate the timer will fire at since
    we set it to looping, and only break this looping when a special condition is
    hit. `CurrentWeaponIndex` being 0 means we have finished and are out of pickups
    to capture. The way to stop a looping (or any active non-looping) timer is to
    have the timer manager clear that timer based on the handle you passed when you
    set the timer. Now, every `ShotDelay` interval, we''ll call `TakeShot`, which
    also cues up the next shot when it finishes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在过去 5 年左右学习 C++ 的程序员来说，lambda 函数相当常见。对于那些早年学习 C++ 的人来说，这可能是新事物，但它们非常有用，并且得到了
    UE4 许多领域的支持。我们在游戏计时器管理器的一个简单计时器中使用了它：我们将 `ShotDelay` 成员时间设置为初始延迟，以及计时器将触发的速率，因为我们将其设置为循环，只有在满足特殊条件时才会中断这个循环。`CurrentWeaponIndex`
    为 0 表示我们已经完成并且没有拾取物可以捕获。停止循环（或任何活动的非循环）计时器的方法是让计时器管理器根据你设置计时器时传递的句柄清除该计时器。现在，每隔
    `ShotDelay` 间隔，我们将调用 `TakeShot`，这也会在完成时安排下一次射击。
- en: 'As the next thing called is that `TakeShot` function, let''s look at it next:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要讨论的是名为 `TakeShot` 的函数，让我们来看看它：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You'll notice in many of these functions there are `checks` before simply calling
    functions on those items, such as the Mesh pointer. Given how automated this functionality
    is, if content creators were having trouble building proper pickups, you would
    be alerted anywhere important here, but if this were a problem you'd likely want
    to handle those kinds of setup mistakes in a way that doesn't crash the editor
    for non-programmers (people hooked into Visual Studio or the like can always skip
    passed check assertions with Set Next Statement or the like). But again, for brevity,
    and as a minimal safeguard to alert of a problem before a simple crash, these
    `checks` are at least here. So, getting that Mesh, we then set it up for a proper
    screenshot, make sure our game's global screenshot resolutions are set to ours,
    set up our screenshot's properties, and take one using the game viewport. It's
    by far the easiest one to access, and this is why we take ours from the player
    pawn's perspective here. We then set an intentionally short timer so the next
    frame we move to the next actor, or signal to the previous timer that we're done
    via resetting the weapon index. As noted in the comment, if you destroy an actor
    (as `SpawnAndPlaceNextActor` will) it is likely that it then will not show up
    at the time the screenshot is resolved, but if you wait one frame for the shot
    to finish, there's no problems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在这些函数中，在直接调用这些项目上的函数之前，比如Mesh指针，都有`检查`。鉴于这个功能的自动化程度，如果内容创作者在构建合适的拾取物品时遇到麻烦，你会在任何重要的地方收到警告，但如果这是一个问题，你可能会希望以不会使编辑器崩溃的方式处理这些设置错误（连接到Visual
    Studio等的人可以始终通过设置下一个语句等方式跳过检查断言）。但再次强调，为了简洁，并且作为在简单崩溃之前警告问题的最小保障，这些`检查`至少在这里。因此，获取那个Mesh后，我们将其设置为适当的截图，确保我们的游戏的全局截图分辨率设置为我们的设置，设置截图的属性，并使用游戏视口进行截图。这是最容易访问的，这也是为什么我们在这里从玩家角色视角进行截图的原因。然后我们设置一个故意很短的计时器，以便在下一次帧中移动到下一个演员，或者通过重置武器索引向之前的计时器发送完成信号。正如注释中所述，如果你销毁一个演员（如`SpawnAndPlaceNextActor`所做的那样），那么在截图解析时它可能不会显示出来，但如果你等待一帧让拍摄完成，就没有问题。
- en: 'So you''ve seen it a couple of times now; let''s look at `SpawnAndPlaceNextActor`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过它几次了；让我们看看`SpawnAndPlaceNextActor`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hopefully, this function is much more straightforward and does not require much
    attention. We destroy any current existing actor, get the one our index is set
    to as a blueprint, spawn one of those in the world with the blueprint's `GeneratedClass`,
    stop it from spinning, fix its location, and increment our index.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个函数更加直接，不需要太多关注。我们销毁任何当前存在的演员，获取我们索引设置为蓝图的那个演员，在世界中使用该蓝图的自定义类`GeneratedClass`创建一个，停止它旋转，修复其位置，并增加我们的索引。
- en: 'So, how do we fix up that location? By finally using a little bit of basic
    3D math:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何修复那个位置呢？通过最终使用一点基本的3D数学：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If curious about the commented out bounding box/offset drawing chunks, feel
    free to enable one or both and see what they show you. The reason I used them
    and left them in was because `SkeletalMeshActors` primarily get their bounding
    information at the time the assets are imported from whatever external tool they
    were built in (3D Studio MAX, Maya, and so on) set by the artists. As I found
    some of the Infinity Blade weapons' bounding a bit odd, I used this to make sure
    it was indeed how the assets were made, and there was not a math or other programming
    error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对注释掉的边界框/偏移绘制块感到好奇，可以随意启用一个或两个，看看它们会显示什么。我之所以使用它们并保留它们，是因为`SkeletalMeshActors`主要在从外部工具（如3D
    Studio MAX、Maya等）导入资产时获取边界信息，这是由艺术家设置的。由于我发现《无尽之刃》武器的一些边界设置有些奇怪，所以我使用这个方法来确保资产确实是按照这种方式制作的，并且没有数学或其他编程错误。
- en: In this function, we get the bounding extents of the actor, find its longest
    dimension (X, Y, or Z) and push it back until that longest side is just at the
    edge of our view frustum. If it turns out a weapon is more wide than it is long,
    we rotate the larger side to face our camera too. Figuring out how far away in
    X to move our actor to best fill/fit the screen before the shot is then just a
    bit of simple trigonometry. We can get the field of view of the camera frustum,
    and if we then consider a top-down sort of view of that frustum split down the
    middle as two right triangles, we know to get that longest side to fit we then
    use the tangent of half that frustum angle for one of the triangles. By definition,
    that tangent being the opposite side's length over the adjacent side's length,
    we divide the long side of our bounding to know how far to push the object out
    now. We also subtract out the relative position offset (InPos) of the bounding
    box itself and should have a reasonably centered location to return.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们获取角色的边界范围，找到它的最长维度（X、Y或Z），并将其推回，直到最长边刚好在我们的视锥边缘。如果发现一个武器比它长更宽，我们将较大的侧面旋转以面向我们的摄像机。在拍摄之前，确定我们的角色在X轴上移动多远以最好地填充/适应屏幕，这只是一个简单的三角计算。我们可以获取摄像机视锥的视野，如果我们考虑一个从上到下的视图，将视锥从中间分开成两个直角三角形，我们知道要使最长边适应，我们使用视锥角度的一半的正切值来处理一个三角形。根据定义，这个正切是相对边长与相邻边长的比值，我们通过长边来除以知道现在要将对象推多远。我们还减去边界框本身的相对位置偏移（InPos），应该有一个相当居中的位置返回。
- en: Running our icon map now should generate a screenshot in the Saved folder of
    our project for each pickup. This is a good checkpoint for GitHub, and we'll use
    those screenshots to finally make some UI elements next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的图标地图应该会在项目的Saved文件夹中为每个拾取生成一个截图。这是一个好的GitHub检查点，我们将使用这些截图来最终制作一些UI元素。
- en: Using UMG to display inventory icons on screen
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UMG在屏幕上显示库存图标
- en: 'After the previous section''s significant amount of code, we''ll be back working
    mostly in blueprints and the editor in this section. One quick aside: when moving
    assets in the editor, it will leave behind a redirector `.uasset` file of the
    one you moved. All this does is point anything that looks for the old one to the
    new one. There''s a Fix-Up Redirectors commandlet you can run, which searches
    your content folder for all of these and any objects referencing them, points
    them properly to the new location, and deletes the redirector. This can also be
    done manually in the content browser by finding the Other Filters | Show Redirectors filter
    setting, and you can right-click on them in the content browser and select Fix
    Up to get rid of them. I did that at this point to keep things tidy.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的大量代码之后，我们将回到本节主要在蓝图和编辑器中工作。一个快速的旁白：当在编辑器中移动资产时，它会在你移动的资产后面留下一个重定向器`.uasset`文件。这仅仅是指向任何寻找旧文件的东西都指向新文件。你可以运行一个Fix-Up
    Redirectors命令行工具，它会搜索你的内容文件夹中所有这些以及任何引用它们的对象，将它们正确地指向新位置，并删除重定向器。这也可以通过在内容浏览器中手动完成，通过找到Other
    Filters | Show Redirectors过滤器设置，你可以在内容浏览器中右键单击它们并选择Fix Up来删除它们。我在这个点上做了这件事，以保持事情整洁。
- en: 'So now under FirstPersonCPP I next make a Textures folder and click the Import
    button in the content browser: browsing to where the screenshots were added (`/Saved/Screenshots/Windows`).
    Select the generated `.png` files here (five in my case) and let them all import
    as textures. It''s good to have a naming convention for searching blueprints as
    projects get larger, so for all of these textures I simply name them `T_`(weapon
    name). Of course, with some effort in UE4''s C++ using the `FileManager` we could
    cleverly automate renaming the `.png` files rather easily, but importing them
    into game content as textures is a bit more involved—bulk selecting them here
    and manually renaming is sufficient for us as we get on to the task of drawing
    them in an inventory UI.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在FirstPersonCPP下，我接下来创建一个Textures文件夹，并在内容浏览器中点击导入按钮：浏览到截图被添加的位置（`/Saved/Screenshots/Windows`）。在这里选择生成的`.png`文件（我的情况下是五个）并将它们全部导入为纹理。当项目变得更大时，有一个命名约定来搜索蓝图是很有用的，所以对于所有这些纹理，我简单地命名为`T_`(武器名称)。当然，在UE4的C++中使用`FileManager`进行一些努力，我们可以巧妙地自动重命名`.png`文件，但将它们导入游戏内容作为纹理则要复杂一些——在这里批量选择它们并手动重命名对我们来说就足够了，因为我们接下来要做的任务是绘制它们在库存UI中。
- en: Synchronizing your inventory and HUD
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步您的库存和HUD
- en: 'Moving to actually draw our icons and cycle them is the first portion of this
    book where not all steps of implementation will be fully shown. All of the work
    as always is available on GitHub, and it is recommended to go look at each change
    in this `Chapter 4` branch submission, but for discussion purposes, the focus
    will be on new concepts going forward and decision making. This is, after all,
    a Mastering book, so expect the pace and complexity of work to pick up. First,
    a bit of housekeeping, as this complexity does ramp up: as a project moves into
    a more mature state, the sheer number of source files tends to increase and it''s
    best early on to start managing these into logical directories. There are really
    two main schemes for how you group things in your project hierarchy: by function
    or by system. Functionally grouping source files is along the lines of (in our
    current reorganization) things such as all UI widget classes, with maybe subfolders
    for complex specialized types. Grouping by system would be (as I''ve done here)
    more like all things related to inventory. While these may seem like trivial decisions,
    or it may feel OK with modern IDEs to simply leave every class in one flat hierarchy,
    project size and developer team size should drive your decisions here. The important
    part is to make architectural decisions like this early and then stick to them
    throughout a project for the team''s consistency.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制图标并循环它们是本书的这一部分，其中不会完全展示所有实现步骤。所有的工作始终可在 GitHub 上找到，并建议查看这个 `Chapter 4`
    分支提交中的每个更改，但出于讨论的目的，重点将放在后续的新概念和决策上。毕竟，这是一本精通书籍，所以期待工作节奏和复杂性的提升。首先，做一些基本的整理，因为这种复杂性确实在增加：随着项目进入更成熟的状态，源文件的数量往往会增加，因此最好尽早开始将这些文件管理到逻辑目录中。实际上，在项目层次结构中组织项目的方式有两种：按功能或按系统。按功能分组源文件类似于（在我们的当前重组中）所有
    UI 小部件类，可能还有为复杂专用类型设置的子文件夹。按系统分组将类似于（如我所做的那样）所有与库存相关的事物。虽然这些可能看起来像是微不足道的决定，或者使用现代
    IDE 时可能感觉将每个类留在单一的扁平层次结构中是可行的，但项目规模和开发团队规模应该驱动你的决策。重要的是要尽早做出这样的架构决策，并在整个项目中坚持这些决策，以保持团队的连贯性。
- en: 'OK, on to the fun stuff! The main new class we need to create in C++ is `UUserWidget`,
    like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来是更有趣的部分！我们需要在 C++ 中创建的主要新类是 `UUserWidget`，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, as they''re new to this book, note the keyword for `BlueprintImplementableEvent`:
    these functions are actually not implemented in C++, only declared in the header.
    Their actual functionality comes in the blueprint events they generate. We''ll
    get to those in a bit, but let''s now look at how they are used and then we''ll
    trace that to how they are triggered:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于他们是这本书的新手，请注意 `BlueprintImplementableEvent` 的关键字：这些函数实际上不是在 C++ 中实现的，而是在头文件中声明的。它们的功能实际上来自于它们生成的蓝图事件。我们稍后会谈到这些，但现在让我们看看它们是如何被使用的，然后我们将追踪到它们是如何被触发的：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What''s happening here is we are hooking into an event in the `Inventory` class
    that will broadcast to all its listeners (our bindings) when events happen, passing
    weapon properties into our blueprint implementation. So, how do we do this? First
    we add these events to our inventory class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我们正在挂钩到 `Inventory` 类中的一个事件，该事件将在事件发生时向所有监听器（我们的绑定）广播，并将武器属性传递到我们的蓝图实现中。那么，我们是如何做到这一点的呢？首先，我们将这些事件添加到我们的库存类中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And in the `.cpp`, after a good amount of refactoring (and a couple of bug
    fixes I''m not too ashamed to admit), we have lines like these:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中，经过大量的重构（以及一些我不太愿意承认的几个错误修复）后，我们会有这样的行：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly added for, well, adding a weapon, and the newly implemented removal
    of weapons as well (this is done when ammo runs out).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为了添加武器以及新实施的武器移除功能（这是在弹药耗尽时进行的）。
- en: For a game like this, it's important to have a design in mind for how to show
    the player their inventory and know whether things such as ammo pickups without
    being a weapon pickup are possible, of course. In this case, if you're out of
    ammo, you might as well not have the weapon at all, so we remove it from the display.
    You could, of course, gray it out or the like, but again, make sure at all times
    your design drives your implementation decisions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的游戏，有一个设计思路来展示玩家的库存以及知道是否可能实现诸如弹药拾取而不是武器拾取这样的功能是很重要的。当然，如果你没有弹药，你甚至可以没有武器，所以我们将其从显示中移除。当然，你也可以将其变灰或类似操作，但再次强调，在所有时候，你的设计应该驱动你的实现决策。
- en: 'So we''re now communicating to our inventory display object key events when
    the inventory is changed in C++. Let''s take a moment than to see what that looks
    like on the blueprint side of this concept:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在正在通过C++将库存更改时的事件传递给我们的库存显示对象。让我们花点时间看看这个概念在蓝图方面的样子：
- en: '![](img/b12ef8d5-0d03-4aa8-98c7-5f393b3cda46.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b12ef8d5-0d03-4aa8-98c7-5f393b3cda46.png)'
- en: 'There are several things to note here, but it will be kept brief: notice the
    functions and variables on the left. These are blueprint-only things added with
    the + button to make all of this work. This is where a bit of mystery will remain
    unless you go to GitHub and look at all of the implementations. Hopefully, the
    functionality of these functions and variables is clear from the naming. As inventory
    items are added, widgets are added to a ScrollBox widget. The layout will follow,
    but the important concepts are that we''ll track weapon classes and icon widgets
    in parallel arrays so we can map them for selection and removal. That function
    is demonstrative of why all the functions won''t be shown here directly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事项，但将会简要说明：注意左侧的函数和变量。这些是仅通过+按钮添加的蓝图专用内容，以使所有这些工作。这就是为什么一些神秘的东西会保留下来，除非你前往GitHub查看所有实现。希望这些函数和变量的功能从命名中可以清楚地看出。随着库存物品的增加，小部件将被添加到ScrollBox小部件中。布局将随之而来，但重要概念是我们将跟踪武器类和图标小部件的并行数组，以便我们可以为选择和删除进行映射。这个函数展示了为什么不会直接在这里显示所有函数：
- en: '![](img/048979b9-3e71-4dc7-a0f9-b4e9aba2911c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/048979b9-3e71-4dc7-a0f9-b4e9aba2911c.png)'
- en: 'This is not even a particularly complex function, but it''s already a bit tight
    to get into one shot. Notice at the print-string node there''s a redirector node.
    They can be added by dragging from an execution pin (white ones) at any time,
    and then dragged around to help sometimes with the spaghetti that visual scripting
    can create. Hopefully, also you''re familiar with input and output variables (seen
    in the bottom left), blueprint functions can be extremely useful for quick implementation,
    and are all but required when working with UMG widgets. Some UI/UX designers may
    be comfortable implementing their own functionality, but mostly those roles will
    be more involved with the Designer tab, in the top-right. Let''s quickly look
    at that for this scrolling inventory widget that we''ll draw, currently, at the
    top of the screen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至不是一个特别复杂的函数，但已经有点紧凑，无法一次性完成。注意在打印字符串节点处有一个重定向节点。它们可以通过从任何执行引脚（白色引脚）拖动来添加，然后拖动以帮助有时解决视觉脚本可能创建的意大利面式代码。希望你也熟悉输入和输出变量（在左下角可见），蓝图函数对于快速实现非常有用，并且在与UMG小部件一起工作时几乎是必需的。一些UI/UX设计师可能对实现自己的功能感到舒适，但大多数情况下，这些角色将与右上角的“设计器”标签更相关。让我们快速看一下我们将绘制的这个滚动库存小部件，目前位于屏幕顶部：
- en: '![](img/0d86defb-fe30-4e5a-8456-336718fbe902.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d86defb-fe30-4e5a-8456-336718fbe902.png)'
- en: Of note in the top-right is that the ScrollBox widget, in this case, is checked
    to be a variable (you can see it referenced in blueprint scripting) and the slightly
    odd arrangement of HorizontalBox widgets on the left, which basically sandwich
    our ScrollBox into a Canvas widget in the middle that is the size we want. There
    are a **lot** of widget settings to get all this correct, including an Image-based
    widget named InventoryItem that can be reviewed in the GitHub project. Looking
    for what was modified to make things work as they do is always just a search for
    those little yellow looping arrows (which, as you know if clicked, revert a value
    to its default) indicating what has been modified.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角值得注意的是，ScrollBox小部件在此情况下被标记为变量（你可以在蓝图脚本中看到它的引用），以及左侧HorizontalBox小部件的略微奇怪的排列，这基本上将ScrollBox夹在中间的Canvas小部件中，该Canvas小部件的大小是我们想要的。要正确设置所有这些，需要很多小部件设置，包括一个基于图像的小部件名为InventoryItem，可以在GitHub项目中查看。寻找修改了什么以使事情按预期工作，始终只是搜索那些黄色循环箭头（如果你知道，点击会恢复值）以指示已修改的内容。
- en: 'Now, to make all of this work also requires adding a blueprint for our MasteringGameMode
    and MasteringHUD so that the former can set the latter as the HUD to use, and
    World Settings in the main level editing window can be set to use that mode:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使所有这些工作，还需要为MasteringGameMode和MasteringHUD添加蓝图，以便前者可以将后者设置为要使用的HUD，并且主级别编辑窗口中的世界设置可以设置为使用该模式：
- en: '![](img/3ea8f568-dd31-4371-ade8-afac646e4081.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ea8f568-dd31-4371-ade8-afac646e4081.png)'
- en: Notice that I un-hardcoded the crosshair texture, but exposing things like this
    to blueprint means adding extra code to handle if they are not set up properly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有将十字准星纹理硬编码，但将此类事物暴露给蓝图意味着需要添加额外的代码来处理它们是否设置正确。
- en: So the net result of this is that we can now scroll through our weapons, see
    which is selected (as it is the only full-alpha object in our list), and as we
    cycle what's in-hand, it cycles our ScrollBox full of icons, removing any that
    run out of ammo!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终结果是我们可以现在滚动浏览我们的武器，看到哪个被选中（因为它是我们列表中唯一的全alpha对象），当我们循环手中的物品时，我们的ScrollBox中的图标也会循环，移除任何耗尽弹药的图标！
- en: '![](img/a54a386a-82cb-4a67-8230-a00dbbb95735.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a54a386a-82cb-4a67-8230-a00dbbb95735.png)'
- en: 'If you find yourself getting errors trying to compile your widgets, be sure
    to note the change to `Mastering.Build.cs`. This is where you can include source
    modules your game may find itself needing (and to this point, we did not need
    UMG):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在编译小部件时遇到错误，请确保注意`Mastering.Build.cs`中的更改。这是你可以包含游戏可能需要的源模块的地方（到目前为止，我们不需要UMG）：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One last note (which will be well known to experienced GitHub users): I submitted
    my changes, *then* moved my files to reorganize them. GitHub sees moves as a deletion
    of the old file and addition of a new file, so you would lose the change history,
    but that can be seen in the two submissions that go along with this effort.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点（对于经验丰富的GitHub用户来说可能很熟悉）：我提交了我的更改，然后移动我的文件来重新组织它们。GitHub将移动视为旧文件的删除和新文件的添加，因此你会丢失更改历史，但可以在与这项工作相关的两个提交中看到。
- en: So now our inventory is synced up and good to go!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库存已经同步并准备就绪！
- en: Using UMG and game save slots
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UMG和游戏保存槽位
- en: UE 4.19+ gives us a nice class to actually save and load a chunk of data for
    objects we want to save. In our case, this will be every actor that can change
    its state or position, which right now is not a lot. But as a game grows, if in-scene
    saves are desired, it is incredibly important to start this process as early as
    possible too. Our biggest challenge will be the one class we implemented in [Chapter
    3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review and When to
    Use BP Scripting*, where almost its entire functionality was implemented on the
    blueprint side. Creating a solution that works with both native C++ classes and
    blueprints will be our all-inclusive goal for this section. The UMG UI will be
    a bit lighter than the last section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UE 4.19+为我们提供了一个很好的类，可以实际保存和加载数据块，用于我们想要保存的对象。在我们的案例中，这将是我们现在可以改变其状态或位置的每个演员，目前并不多。但随着游戏的发展，如果希望在场景内保存，尽早开始这个过程也非常重要。我们最大的挑战将是我们在[第3章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)中实现的那个类，*蓝图审查和何时使用BP脚本*，其中几乎全部功能都是在蓝图端实现的。创建一个同时适用于原生C++类和蓝图解决方案将是本节的全局目标。UMG
    UI将比本章上一节更轻量。
- en: Creating a widget for save slots
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建保存槽位的控件
- en: 'While the bulk of the work in this section will be actually implementing the
    loading and saving of various actor classes, we do of course need an interface
    to display this to players, and that is what we will do first. Our next step then
    is a UMG widget that we can bring up with buttons to facilitate this. So, back
    in the editor, we need a widget that has some touch-points back to C++ code so
    we can do the bulk of the work. To simplify this, we''ll make a new C++ class
    based on `UUserWidget`, call it MainMenuWidget, and add the class to the UI folder.
    Then, like before, we make a new blueprint asset and we will add 4 buttons to
    that in its design, like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节的大部分工作将是实际实现各种演员类的加载和保存，但我们当然需要一个界面来向玩家展示这些信息，这正是我们将要做的。接下来的步骤是一个UMG小部件，我们可以通过按钮来激活它。因此，回到编辑器中，我们需要一个具有一些与C++代码交互点的控件，这样我们就可以完成大部分工作。为了简化这个过程，我们将基于`UUserWidget`创建一个新的C++类，命名为MainMenuWidget，并将其添加到UI文件夹中。然后，就像之前一样，我们创建一个新的蓝图资产，并在其设计中添加4个按钮，如下所示：
- en: '![](img/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png)'
- en: Notice we set its initial visibility to Hidden, and at the ButtonBox level,
    the anchor is set to center screen with X and Y alignments of 0.5\. As always,
    feel free to reference the version in GitHub for all UMG/blueprint issues not
    specifically discussed here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将它的初始可见性设置为隐藏，并在ButtonBox级别，锚点设置为屏幕中心，X和Y对齐为0.5。就像往常一样，请随时参考GitHub上的版本，以解决这里未具体讨论的所有UMG/蓝图问题。
- en: 'Next, we bind the click events for each of those buttons. Click each button,
    and at the bottom of its Details tab are the events for input with a big green
    + button. Click that for each button''s OnClicked event and you''ll be taken to
    the blueprint graph at that event where it''s added. We add these functions to
    the widget class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个按钮绑定点击事件。点击每个按钮，在其详情标签页底部会有输入事件，旁边有一个大绿色的+按钮。点击该按钮为每个按钮的`OnClicked`事件添加，你将被带到该事件处的蓝图图中，我们将添加这些函数到`Widget`类中：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wire the save event to the `SaveGame` function, and wire the load event to
    the `LoadGame` function as well, of course. `Open` is called by an input: we need
    to bind one in player settings as we have done in the past. I set mine to *F10*
    as this is common in several games, but of course it can be any key, touch, or
    gesture desired. In `MasteringCharacter`, I bind this input to a simple pass-through
    function that gets the HUD like so and calls a function with the same name on
    that HUD:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将保存事件连接到`SaveGame`函数，并将加载事件连接到`LoadGame`函数，当然。`Open`是通过输入调用的：我们需要在玩家设置中绑定一个，就像我们过去做的那样。我将它设置为*F10*，因为在许多游戏中这是常见的，但当然可以是任何键、触摸或手势。在`MasteringCharacter`中，我将这个输入绑定到一个简单的透传函数，如下所示，并调用该HUD上具有相同名称的函数：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Back in the widget class, the `Open` and `Close` functions are worth looking
    at, but only open is listed here as close is essentially the same thing in reverse,
    setting the input mode to `FInputModeGameOnly`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Widget`类中，`Open`和`Close`函数值得一看，但这里只列出了`Open`，因为`Close`本质上是在`Open`的基础上反向操作，将输入模式设置为`FInputModeGameOnly`：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now with *F10*, while playing, our main menu comes up, and when the Return to
    Game button is clicked, its event just calls close now on the widget, which unpauses
    the game and returns mouse control to our normal player input. The last special
    event, the button labeled Exit Game, has a simple blueprint node call to quit
    playing (and exit standalone), utilizing the Execute Console Command node, with
    the command `exit`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用*F10*，在游戏中，我们的主菜单出现，当点击返回游戏按钮时，其事件只是现在在widget上调用关闭，这将暂停游戏并返回鼠标控制到我们的正常玩家输入。最后一个特殊事件，标记为退出游戏的按钮，有一个简单的蓝图节点调用，用于退出游戏（并退出独立模式），使用`Execute
    Console Command`节点，命令为`exit`。
- en: Later in the project, this is changed to a Quit Game node as this works when
    console commands may be unavailable (release builds, certain platforms, and so
    on). The Quit Game node is also nice because on mobile platforms it can simply
    send your app to the background instead of fully ending its execution. Keep in
    mind that iOS and Android can effectively end the execution of an app that is
    in the background if the OS decides it needs its resources; but again, at least
    the Quit Game node works across platforms and allows you the choice to try just
    going to the background.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目后期，这被更改为退出游戏节点，因为当控制台命令可能不可用（发布版本、某些平台等）时，这会起作用。退出游戏节点也很不错，因为在移动平台上，它可以将您的应用程序发送到后台而不是完全结束其执行。请记住，iOS和Android可以在操作系统决定需要其资源时有效地结束后台应用程序的执行；但再次强调，至少退出游戏节点在所有平台上都有效，并允许您选择尝试仅将其发送到后台。
- en: That's it for the menu side at the moment. Now we need to actually save our
    game, finally!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前菜单部分就到这里。现在我们需要实际保存我们的游戏，最终！
- en: Creating a save game file
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个保存游戏文件
- en: 'As noted at the top of this section, our actual game and the state of all our
    dynamic actors is done in three major steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节顶部所述，我们的实际游戏和所有动态演员的状态是通过三个主要步骤完成的：
- en: Add an interface to all actors that need to save. This involves a few changes
    to our moving platform, which we'll try to keep straightforward.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有需要保存的演员添加一个接口。这涉及到对我们移动平台的几个修改，我们将尽量保持其简单性。
- en: Serialize all our actors' desired variables to an `FArchive` by tagging our
    `UPROPERTIES`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有演员希望序列化的变量序列化到`FArchive`中，通过标记我们的`UPROPERTIES`。
- en: Write this to a file we can then serialize everything back out from.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此写入一个文件，然后我们可以从该文件反序列化所有内容。
- en: For very simple saving (such as player stats and the current level), be sure
    to check out the `USaveGame` document link in the *Further reading* section at
    the end of the chapter. Now, on to our relatively complex version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的保存操作（例如玩家统计数据和当前关卡），请务必查看章节末尾的*进一步阅读*部分中的`USaveGame`文档链接。现在，让我们继续探讨相对复杂的版本。
- en: First we need an interface that we'll add to all of our actors that we care
    about saving, this is the first time we need to make a C++ class outside the editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个接口，我们将将其添加到所有我们关心的需要保存的演员中，这是我们第一次在编辑器外创建C++类。
- en: When making new C++ from files, it's often just easiest to right-click the tabs
    at the top of Visual Studio, open Containing Folder, copy paste a `.h` and `.cpp`
    file up one folder, rename them as needed, copy them back down to the proper folder,
    then generate project files by right-clicking the `.uproject` or using the batch
    file style mentioned in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter.* Of course, the body of the files needs
    to be replaced.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当从文件创建新的 C++ 项目时，通常最简单的方法是右键点击 Visual Studio 顶部的选项卡，打开包含文件夹，复制粘贴一个 `.h` 和 `.cpp`
    文件到上一级文件夹，根据需要重命名它们，然后将它们复制回正确的文件夹，然后通过右键点击 `.uproject` 或使用 [第 1 章](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml)
    中提到的批处理文件样式生成项目文件，*为第一人称射击游戏创建 C++ 项目*。当然，文件的内容需要替换。
- en: 'The header of the `.h` should look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`.h` 文件的头部应该看起来像这样：'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And what is nice about BlueprintNativeEvent is that we can fire these from C++,
    but have them executed in blueprint. The class we have some new work to do for
    is our moving platform, which again, exists and is defined solely in blueprint.
    Making the interface `BlueprintType` means we can add this easily to our platform
    blueprint-only class. So, heading to that class, here are the steps we need to
    get it saving properly to the archive. Open the moving platform class, click Class
    Settings at the top main menu bar, and on the right, you'll see Implemented Interfaces,
    and we can click Add and select Saved Actor Interface to add this functionality
    on the blueprint side. Once we compile the blueprint, we can add an event then
    for when the actor is loaded. To properly set it in the right state, we need to
    click on its two variables in the My Blueprint tab on the left, and in their Details
    tab, click the down arrow to expose the rest of its options and check the box
    for SaveGame for both the GoingHome and StartPosition blueprint variables. Now,
    when we serialize a platform to an archive, these will be saved and loaded and
    while ideally we would "lasso" select a set of nodes and right-click and select
    Collapse to Function, we can't do this here because asynchronous nodes such as MoveComponentTo
    have to stay in the Event Graph layer. But let's add an event for the interface's
    Actor Loaded and then just copy paste some of the movement nodes, making sure
    that if the platform needs to be moving it goes the right way (based on the Going
    Home variable). There's no harm telling a platform to go where it already is,
    so we'll set it on the case it has Going Home set to move to its Start Position.
    Also fixed slightly is the on-actor-overlap event from before. It will go to Start
    Position + 300 in Z, rather than its current position. So that fixes arguably
    our hardest case, the blueprint-only class of the group. Let's add the interface
    to our other classes, and give them a general save functionality as well as a
    couple of specific ones (such as our `MasteringCharacter`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: BlueprintNativeEvent 的优点在于我们可以从 C++ 中触发这些事件，但它们在蓝图中被执行。我们需要做一些新工作的类是我们的移动平台，它再次，仅存在于蓝图定义中。将接口
    `BlueprintType` 化意味着我们可以轻松地将它添加到我们的平台蓝图类中。因此，前往该类，以下是我们需要执行以正确保存到存档的步骤。打开移动平台类，点击顶部主菜单栏中的“类设置”，在右侧，你会看到“实现接口”，我们可以点击“添加”并选择“保存演员接口”以在蓝图侧添加此功能。一旦我们编译了蓝图，我们就可以添加一个事件，当演员被加载时。为了正确设置它到正确的状态，我们需要在左侧的“我的蓝图”选项卡上点击其两个变量，并在它们的“详细信息”选项卡中，点击向下箭头以显示其余选项，并勾选“保存游戏”选项，对于“回家”和“起始位置”蓝图变量。现在，当我们将平台序列化到存档时，这些将被保存和加载。理想情况下，我们会“套索”选择一组节点，右键点击并选择“折叠到函数”，但我们不能在这里这样做，因为像
    MoveComponentTo 这样的异步节点必须保持在事件图层。但让我们为接口的“演员加载”添加一个事件，然后复制粘贴一些移动节点，确保如果平台需要移动，它移动的方向是正确的（基于“回家”变量）。告诉平台去它已经所在的地方没有害处，所以我们将设置在“回家”设置为移动到起始位置的情况下。之前修复的
    on-actor-overlap 事件也略有改进。它将移动到 Z 轴上的起始位置 + 300，而不是当前位置。这样，我们就解决了有争议的最难案例，即该组的蓝图仅类。让我们将接口添加到我们的其他类中，并给他们一个通用的保存功能以及一些特定的功能（例如我们的
    `MasteringCharacter`）。
- en: MyData will consist of all the `UPROPERTY` items we tag with `SaveGame`. Right
    now, the only one of these we would really need to add is the player's inventory;
    but because that has class references and an array of structs that also directly
    reference a texture and class, we'll custom handle inventory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MyData 将由所有我们用 `SaveGame` 标记的 `UPROPERTY` 项组成。目前，我们真正需要添加的这些之一是玩家的库存；但由于它有类引用和直接引用纹理和类的结构体数组，我们将自定义处理库存。
- en: Saving class and asset references directly does *not* work if you tag those
    `UPROPERTIES`. If an object references another object that will be created when
    the level is loaded, this may work, or to be safe you can look up placed-in-world
    actors by name in a fix-up pass. Most times, you save the class as a string, then
    respawn whatever object that is, as we will do extensively here as well as with
    our inventory special case saving.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 直接保存类和资产引用不适用于标记了`UPROPERTIES`的情况。如果一个对象引用了在关卡加载时将被创建的另一个对象，这可能有效，或者为了安全起见，你可以在修复过程中通过名称查找放置在世界的演员。大多数时候，你将类保存为字符串，然后重新生成该对象，正如我们在这里以及我们的存货特殊情况保存中将要广泛做的那样。
- en: If we had other basic types (such as the blueprint variables on our moving platform),
    simply add `UPROPERTY(SaveGame)` to their definition and they automatically serialize
    in and out with the actor data. To make inventory load and save properly, we need
    a couple of new structs and its own serialization to and from them, which we will
    demonstrate in the next section. Since it is not an actor class, it is a little
    annoying to put its structs in the same place as those actor saving ones, but
    this still seems at this level of complexity to be the best place. So now, how
    do we use this menu, some new UI, and a lot of saving and loading code to save
    everything that can change in our levels at any moment and load right back? Let's
    dive into that now!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有其他基本类型（例如移动平台上的蓝图变量），只需在它们的定义中添加`UPROPERTY(SaveGame)`，它们就会自动与演员数据一起序列化和反序列化。为了使存货加载和保存正常工作，我们需要一些新的结构体以及它们之间的序列化和反序列化，我们将在下一节中演示。由于它不是一个演员类，将其结构体放在与演员保存那些结构体相同的位置有点令人烦恼，但在这个复杂性的级别上，这似乎是最好的地方。所以现在，我们如何使用这个菜单、一些新的UI以及大量的保存和加载代码来保存我们关卡中任何时刻可能改变的所有内容，并正确加载回来？让我们现在就深入研究这个问题！
- en: Save and load from our menu
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的菜单保存和加载
- en: 'Saving our data is relatively straightforward, but as with all load/save systems,
    is mirrored with a little more difficulty on the load side. This functionality
    is almost exclusively implemented in the `MainMenuWidget` class, though I can
    see that the class might grow, moving it to the `SavedActorInterface` or the like;
    but let''s now go forward with what is done:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们的数据相对直接，但与所有加载/保存系统一样，在加载方面会稍微困难一些。这个功能几乎完全实现在`MainMenuWidget`类中，尽管我看到这个类可能会增长，可以将其移动到`SavedActorInterface`或类似的位置；但现在让我们继续进行已经完成的工作：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For saving there is a fair bit going on here, some of which is just basic file
    I/O, but other parts may be unintuitive and are discussed here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存方面，这里有很多事情在进行，其中一些只是基本的文件I/O，但其他部分可能不太直观，这里将进行讨论：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We save the timestamp and then split the map name with the `_` character. This
    is a bit of a risk because you'd, of course, want to make it very clear to level
    designers not to add this character to their map names. In this case, when we're
    playing and testing in PIE, it appends a couple of things to the left of the map
    name that end with `_` and so splitting from the end gets us, for example, `FirstPersonExampleMap`
    without the PIE prefixes that wind up there when playing in the editor. We then
    get a list of all actors that implement our save interface and iterate them. We
    then always save out the relevant actor transient data, but also look to see whether
    we've found our mastering character to do a bit of inventory work. As noted earlier,
    our inventory saving (and loading) needs to be done with the `FInventoryItemData`
    struct and not the `FWeaponProperties` struct inventory uses directly, because
    the latter references a class and texture directly (we need them saved by their
    path/name to properly serialize and then be reloaded from them).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存时间戳，然后使用`_`字符分割地图名称。这有点风险，因为你当然希望向关卡设计师明确指出不要将此字符添加到他们的地图名称中。在这种情况下，当我们正在玩并在PIE中进行测试时，它会在地图名称左侧附加一些以`_`结尾的东西，这样从末尾分割就可以得到例如`FirstPersonExampleMap`，而不包含在编辑器中玩游戏时最终出现在那里的PIE前缀。然后我们获取实现我们保存接口的所有演员的列表并迭代它们。然后我们总是保存相关演员的瞬态数据，同时也查看是否找到了我们的主角色以进行一些存货工作。如前所述，我们的存货保存（和加载）需要使用`FInventoryItemData`结构体，而不是直接使用`FWeaponProperties`结构体存货，因为后者直接引用了一个类和纹理（我们需要通过它们的路径/名称保存它们，以便正确序列化和然后从它们重新加载）。
- en: We set all the relevant information, then serialize to a binary for output and
    save the file, giving it the name of the timestamp we used. You could of course
    let the user pick the name, or save it otherwise, but this at least shows clearly
    when loading what time this save was from.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置所有相关信息，然后将其序列化为二进制输出并保存文件，文件名使用我们使用的时戳。当然，你也可以让用户选择名称，或者以其他方式保存，但至少在加载时可以清楚地显示这个存档是在什么时间保存的。
- en: After we have saved, we set the mouse cursor back to hidden, unpause the game,
    and close the main menu.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们保存后，我们将鼠标光标设置回隐藏，暂停游戏，并关闭主菜单。
- en: 'When loading, we first have to add some more UI to allow the player to pick
    the save that they want to load (or cancel):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时，我们首先需要添加一些 UI 以允许玩家选择他们想要加载的存档（或取消）：
- en: '![](img/e333d904-ecd1-451e-b0fc-97d700fc8e9f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e333d904-ecd1-451e-b0fc-97d700fc8e9f.png)'
- en: 'Notice the switcher UMG item. This lets us basically switch (of course) what
    is shown by the widget from that hierarchy down. We set this from nodes in the
    main menu blueprint, like when we open the loading portion here in a new function
    from the load-button''s on clicked event:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意切换器 UMG 项目。这使我们基本上可以从该层次结构向下切换（当然）小部件显示的内容。我们通过主菜单蓝图中的节点设置此选项，例如当我们在这里从加载按钮的点击事件打开新的加载部分时：
- en: '![](img/0366ca45-5235-4ed9-a1e1-871f5162da28.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0366ca45-5235-4ed9-a1e1-871f5162da28.png)'
- en: 'We then call the native function to get all the save files:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用本地函数以获取所有存档文件：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And then we create and add a button for each of them (with the main menu as
    a member) to the load game list. We make a quick UserWidget blueprint that has
    a simple button and text layout like so, that has one job to do when clicked:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为每个项目（以主菜单作为成员）创建并添加一个按钮到加载游戏列表中。我们快速创建一个具有简单按钮和文本布局的用户界面蓝图，如下所示，它有一个任务要在点击时执行：
- en: '![](img/b9bae0fb-3fe2-4a61-bdd4-891e057a56ec.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9bae0fb-3fe2-4a61-bdd4-891e057a56ec.png)'
- en: 'For those looking closely, there are a couple of points that could be handled
    differently. We will be addressing them later in the book. I would call out that
    we load (or restart) the map for the save, loading its data, and then, storing
    it in a static member variable that survives the map re-loading and is then triggered
    by the HUD''s `BeginPlay`. We''ll be exploring ways to switch from level to level
    and pass data between them in [Chapter 6](978665f4-5638-4a71-9f86-c0349e090ae7.xhtml),
    *Changing Levels, Streaming, and Retaining Your Data*, so fear not if you still
    have questions there. Also, at the moment, the only way to delete save files is
    to go to your content folder, but with all the work we''ve done here, adding a
    delete to your menus should not be an issue. And one last note: it''s also possible
    in a number of ways to hook one widget to another. In this case, I simply pass
    the menu to the button when the menu makes it. There''s nothing wrong with using
    clever techniques, just keep in mind that going with the simplest solution sometimes
    saves time, which every game ends up needing as it gets closer to being ready
    for the public.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些仔细观察的人来说，有几个点可以以不同的方式处理。我们将在本书的后面部分讨论它们。我想指出的是，我们加载（或重启）存档的地图，加载其数据，然后将其存储在静态成员变量中，该变量在地图重新加载后仍然存在，并由
    HUD 的 `BeginPlay` 触发。我们将在第 6 章 [Chapter 6](978665f4-5638-4a71-9f86-c0349e090ae7.xhtml)，*改变关卡，流式传输和保留你的数据*中探讨如何在关卡之间切换并传递数据，所以如果你还有疑问，不要担心。此外，目前删除存档文件的唯一方法是转到你的内容文件夹，但鉴于我们在这里所做的所有工作，将删除功能添加到你的菜单中应该不会是问题。最后一点：以多种方式将一个小部件连接到另一个小部件也是可能的。在这种情况下，我只是当菜单创建时将菜单传递给按钮。使用巧妙的技术没有问题，但请记住，有时候选择最简单的解决方案可以节省时间，这对于每个游戏来说，在接近准备向公众发布时都是必需的。
- en: So that's it, we made it! Checking GitHub, there's a new level with some changes
    in it, but that's really just there for now to prove out load-save from level
    to level and back again. Have fun testing that out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就完成了！检查 GitHub，有一个带有一些更改的新关卡，但现在它只是用来证明从关卡到关卡以及再次返回的加载-保存功能。祝你在测试中玩得开心。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter really ramps up the complexity level of work closer to the mastering
    level. After some warm-up work, it''s definitely time to dig into this level of
    detail and start to really learn the tips and tricks that can make or break a
    game in development. The work here should give a solid base to a number of levels
    of UI work: we made a bunch of new weapons, used our pick-ups to generate screenshot
    icons of them, added these back to the pick-ups and our inventory, utilized that
    inventory to build and sync up a scroll bar of weapons, and made menus and an
    entire save-anywhere system for all of our objects, whew! The project is finally
    starting to look more like a real game compared to the bare-bones template we
    began with, but one thing is missing: enemies to fight. But fear not, we''ll have
    those by the end of the next chapter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将工作复杂性提升到接近精通水平的程度。经过一些热身工作后，确实到了深入研究这一层次细节并开始真正学习那些可以使游戏开发成功或失败的小技巧的时候了。这里的工作应该为多个层次的UI工作提供一个坚实的基础：我们制作了许多新武器，使用拾取物生成它们的截图图标，将这些图标添加回拾取物和我们的库存中，利用这个库存构建并同步武器滚动条，并为所有对象制作了菜单和整个任意保存系统，哇！与最初我们开始时的裸骨模板相比，项目终于开始更像一个真正的游戏了，但有一件事还缺失：敌人。但不用担心，我们将在下一章的结尾拥有它们。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to commit any changes to files to GitHub before moving them
    to a new folder location?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在将文件移动到新文件夹位置之前，将任何更改提交到GitHub很重要？
- en: What are the steps needed to make a pawn that won't move or fall upon starting
    an empty level?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在启动空关卡时不会移动或掉落的NPC需要哪些步骤？
- en: What are the two ways of cleaning up redirectors in UE4, and why is it important
    to do so from time to time?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4中清理重定向器的两种方法是什么，为什么有时这样做很重要？
- en: What UMG child widgets can be used for placing and spacing other widgets within
    a parent?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父窗口中放置和间距其他小部件时，可以使用哪些UMG子部件？
- en: What is the advantage of using `BlueprintImplementableEvents` in communicating
    from C++ to UMG?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BlueprintImplementableEvents`在C++与UMG之间通信的优势是什么？
- en: Which types of `UPROPERTIES` must absolutely not be attempted to serialize when
    saving class variables?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存类变量时，哪些类型的`UPROPERTIES`绝对不能尝试序列化？
- en: What alternative to saving those properties was used here to save and restore
    those special types?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，为了保存和恢复这些特殊类型，使用了哪种保存属性的替代方法？
- en: Which system was used to implement in only a few lines the building of a list
    of files matching an extension?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用几行代码实现匹配扩展名的文件列表构建的系统是哪个？
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Simple saves with `USaveGame`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`USaveGame`的简单保存：
- en: '[https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code](https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code](https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code)'
