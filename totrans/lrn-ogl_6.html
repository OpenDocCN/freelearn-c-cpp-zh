<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing a Skybox Using a Cubemap</h1>
                </header>
            
            <article>
                
<p>In this chapter, we’ll create a skybox using a cubemap. So, let’s first understand what a cubemap is. It is a combination of multiple textures combined into a single texture, which is a cube. It is basically a series of six individual 2D textures that are mapped to a cube. They usually would have some sort of pattern to them, in a way that they actually flow from one side to the other. A skybox is essentially a cubemap, but a massive one. The player and the game world is essentially within that big cube. It encompasses the entire scene with six images of the game environment; if you, as a player, are inside a skybox and you try to look around, it would feel like you have a high-resolution world around you. And, if you try to reach for the edges of the cube you wouldn't be able to do that, because it's just infinitely far away from you. In this chapter, we’ll learn how to implement a skybox using a cubemap to create amazing worlds within your game</p>
<p>We’ll start by creating shaders for our Skybox.</p>
<div class="packt_infobox">You can refer to all the code files for this chapter in the <kbd>Chapter06</kbd> folder on GitHub. The GitHub link can be found in the preface of the book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating shaders for the skybox</h1>
                </header>
            
            <article>
                
<p>As usual, we'll begin with creating our shaders. We'll initiate by duplicating our shader files, <kbd><span class="CodeInTextPACKT">core.vs</span></kbd>, and <span class="CodeInTextPACKT"><kbd>core.frag</kbd>,</span> and name those copied files as <kbd><span class="CodeInTextPACKT">skybox.vs</span></kbd> and <kbd><span class="CodeInTextPACKT">skybox.frag</span></kbd>. We'll now carry out some modification on these shader files; take a look at the following steps to understand the changes that will be made:</p>
<ol>
<li>We'll begin with making modifications to our <kbd><span class="CodeInTextPACKT">skybox.vs</span></kbd> shader. Take a look at the following code and implement the following modification in your shader file:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core 

layout (location = 0) in vec3 position; 

out vec3 TexCoords; 
uniform mat4 projection; 
uniform mat4 view; 
void main() 

{ 
    vec4 pos = projection * view * vec4(position, 1.0); 
    gl_Position = pos.xyww; 
    TexCoords = position; 
} </pre>
<p style="padding-left: 60px">Once you have made the changes, save the file.</p>
<ol start="2">
<li>Next, we'll move on to <kbd><span class="CodeInTextPACKT">Skybox.frag</span></kbd> and carry out the following highlighted changes to the code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core 
in vec3 TexCoords; 
out vec4 color; 
uniform samplerCube skybox; 
void main() 
{ 
    color = texture(skybox, TexCoords); 
} </pre>
<p>Save these changes to your shaders.</p>
<p>Now we have modified our shader files to implement the skybox, we'll move on to make modifications to our <kbd>main.cpp</kbd> file and create our skybox.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifications to the main.cpp file</h1>
                </header>
            
            <article>
                
<p>In the <kbd>main.cpp</kbd> file, there are a few changes we need to make. Follow the steps shown here:</p>
<ol>
<li>First of all, we need to create a new shader object, so before we define <span class="CodeInTextPACKT"><kbd>GLfloat cubeVertices[]</kbd>,</span> we need to add <kbd><span class="CodeInTextPACKT">Shader</span> <span class="CodeInTextPACKT">skyboxShader()</span></kbd>. And, to that we'll pass the locations of our shader files: <kbd><span class="CodeInTextPACKT">"res/shaders/skybox.vs"</span></kbd> and <span class="CodeInTextPACKT"><kbd>"res/shaders/skybox.frag"</kbd>.</span></li>
<li>Next, we're going to need some more vertices for the skybox. Luckily, you can refer those to the <kbd><span class="CodeInTextPACKT">main.cpp</span></kbd> file present inside the <kbd><span class="CodeInTextPACKT">advanced_opengl</span></kbd> folder. Add these vertices to our code.</li>
<li>Once you've got the skybox vertices all set up, you will need to create a vertex array object and vertex buffer object for the skybox. So, let's do that right now.</li>
<li>After we have defined <span class="CodeInTextPACKT"><kbd>glBindVertexArray(0)</kbd>, w</span>e'll add <span class="CodeInTextPACKT"><kbd>GLuint skyboxVAO</kbd> and <kbd>skyboxVBO;</kbd></span>.</li>
<li>Then, we'll add <kbd><span class="CodeInTextPACKT">glGenVertexArrays();</span></kbd> the vertex array is going to take the parameter <kbd>1</kbd> and then a skybox vertex array object, <kbd><span class="CodeInTextPACKT">skyboxVAO</span></kbd>. Next, we're going to generate the buffers into the skybox vertex buffer object.</li>
<li>So, we'll add <kbd><span class="CodeInTextPACKT">glGenBuffers();</span></kbd> and to that we'll pass the parameter as <kbd><span class="CodeInTextPACKT">1</span></kbd> and <kbd><span class="CodeInTextPACKT">&amp;skyboxVBO</span></kbd>.</li>
<li>Then add <kbd><span class="CodeInTextPACKT">glBindVertexArray()</span></kbd>, and to that we'll pass <kbd><span class="CodeInTextPACKT">skyboxVAO</span></kbd>.</li>
<li>Next, we add <span class="CodeInTextPACKT"><kbd>glBindBuffer()</kbd>,</span> and for this we'll pass <kbd><span class="CodeInTextPACKT">GL_ARRAY_BUFFER</span></kbd> and <kbd><span class="CodeInTextPACKT">skyboxVBO</span></kbd>. It's very similar to what we've already done before in the previous chapters, so all of this should be very familiar.</li>
<li>Add <span class="CodeInTextPACKT"><kbd>glBufferData()</kbd>,</span> and the first parameter it will take here is <span class="CodeInTextPACKT"><kbd>GL_ARRAY_BUFFER</kbd>,</span> and the size of the skybox vertices array. Next, we need to actually pass in <span class="CodeInTextPACKT"><kbd>skyboxVertices</kbd>,</span> and finally, we're just going to set it to <kbd><span class="CodeInTextPACKT">GL_STATIC_DRAW</span></kbd>.</li>
</ol>
<ol start="10">
<li>Then we'll add <kbd><span class="CodeInTextPACKT">GLEnableVertexAttribArray()</span></kbd>. We're going to set this to <kbd>0</kbd>. Next, we're going to add <kbd><span class="CodeInTextPACKT">glVertexAttribPointer()</span></kbd>. This is going to take <span class="CodeInTextPACKT"><kbd>0</kbd>, <kbd>3</kbd>, <kbd>GL_FLOAT</kbd>, <kbd>GL_FALSE</kbd>, <kbd>3 * sizeof( GLfloat)</kbd>, <kbd>( GLvoid * ) 0</kbd></span>. Take a look at the following code to understand the description:</li>
</ol>
<pre style="padding-left: 60px">// Setup skybox VAO 

    GLuint skyboxVAO, skyboxVBO; 
    glGenVertexArrays( 1, &amp;skyboxVAO ); <br/>    glGenBuffers( 1, &amp;skyboxVBO ); 
    glBindVertexArray( skyboxVAO ); 
    glBindBuffer( GL_ARRAY_BUFFER, skyboxVBO ); 
    glBufferData( GL_ARRAY_BUFFER, sizeof( skyboxVertices ),<br/>    &amp;skyboxVertices, GL_STATIC_DRAW ); 
    glEnableVertexAttribArray( 0 ); 
    glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(<br/>    GLfloat ), ( GLvoid * ) 0 ); 
    glBindVertexArray(0);  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Texture.h file</h1>
                </header>
            
            <article>
                
<p>Next, we will actually load the textures, so what we're going to do is create a separate texture file, and we'll just have a method for loading the textures, and also a separate method for loading cube textures. The reason for doing this is we're going to be using this code regularly, and it's just that we have to rewrite these every single time. If we want to do multiple objects, especially, we don't want to rewrite this every single time. Let's take a look at the following steps to create the <kbd>Texture.h</kbd> file:</p>
<ol>
<li>First of all, we'll create an empty header file and name that as <span class="CodeInTextPACKT"><kbd>Texture.h</kbd>,</span> and add that to our project.</li>
<li>Then, in <kbd><span class="CodeInTextPACKT">Texture.h</span></kbd>, we'll add the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once </pre>
<ol start="3">
<li>Then, we'll add some header files, such as <kbd><span class="CodeInTextPACKT">#define GLEW_STATIC</span></kbd> (if you didn't statically link GLEW, then you don't need to put this line here), <kbd><span class="CodeInTextPACKT">#include &lt;GL/glew.h&gt;</span></kbd>, and <kbd><span class="CodeInTextPACKT">#include &lt;vector&gt;</span></kbd>.</li>
<li>Next, we'll create a class called <kbd><span class="CodeInTextPACKT">TextureLoading</span></kbd> and begin adding all our code to it.</li>
<li>We'll type <kbd><span class="CodeInTextPACKT">public</span></kbd>, and the first method we're going to have is a <kbd>static GLuint LoadTexture()</kbd> and to that we'll pass <kbd><span class="CodeInTextPACKT">GLchar *path</span></kbd>.</li>
</ol>
<ol start="6">
<li>Now, we'll go to our <kbd>main.cpp</kbd> file, and we'll cut and paste all the load and create textures and texture loading-related code, and paste it into the <kbd><span class="CodeInTextPACKT">LoadTextureMethod</span></kbd> that we created in the previous step.</li>
<li>Now, let's have a look at what we need to change in here; check out the following highlighted code to understand the changes:</li>
</ol>
<pre style="padding-left: 60px">static GLuint LoadTexture( GLchar *path ) 
    { 
        //Generate texture ID and load texture data 
        GLuint textureID; 
        glGenTextures( 1, &amp;textureID );   
        int imageWidth, imageHeight; 
        unsigned char *image = SOIL_load_image( path, &amp;imageWidth, <br/>        &amp;imageHeight, 0, SOIL_LOAD_RGB ); 
        
        // Assign texture to ID 
        glBindTexture( GL_TEXTURE_2D, textureID ); 
        glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, imageWidth,<br/>        imageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image ); 
        glGenerateMipmap( GL_TEXTURE_2D );  

        // Parameters 
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, <br/>        GL_REPEAT ); 
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,<br/>        GL_REPEAT ); 
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,<br/>        GL_LINEAR_MIPMAP_LINEAR ); 
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,<br/>        GL_LINEAR ); 
        glBindTexture( GL_TEXTURE_2D,  0); <br/>        SOIL_free_image_data( image );          
        return textureID; 
    } 

    static GLuint LoadCubemap( vector&lt;const GLchar * &gt; faces) 
    { 
        GLuint textureID; 
        glGenTextures( 1, &amp;textureID );  
        int imageWidth, imageHeight; 
        unsigned char *image; 
            glBindTexture( GL_TEXTURE_CUBE_MAP, textureID ); 
   
      for ( GLuint i = 0; i &lt; faces.size( ); i++ ) 
        { 
            image = SOIL_load_image( faces[i], &amp;imageWidth,<br/>            &amp;imageHeight, 0, SOIL_LOAD_RGB ); 
            glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0,<br/>            GL_RGB, imageWidth, imageHeight, 0, GL_RGB,<br/>            GL_UNSIGNED_BYTE, image ); <br/>            SOIL_free_image_data( image ); 
        } 
        <br/>glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); 
glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); 
glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE ); 
glBindTexture( GL_TEXTURE_CUBE_MAP, 0); 
return textureID; 

} </pre>
<ol start="8">
<li>Now, we go back to <kbd><span class="CodeInTextPACKT">main.cpp</span></kbd>, and add <kbd><span class="CodeInTextPACKT">#include Texture.h</span></kbd>, then come to the location in the code where we want to load textures, and there we'll add the following to load our texture code: <kbd><span class="CodeInTextPACKT">GLuint cubeTexture = TextureLoading::LoadTexture( "res/images/container2.png" )</span></kbd> and also update the bind texture code, as highlighted here:</li>
</ol>
<pre style="padding-left: 60px">glBindTexture( GL_TEXTURE_2D, cubeTexture );   </pre>
<p>Now, let's run it and check if our <kbd><span class="CodeInTextPACKT">Texture.h</span></kbd> code builds successfully, and that it compiles without any errors. You should get the following output on your screen:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span><img class="aligncenter size-full wp-image-299 image-border" src="assets/3bae1e53-cba6-4a9d-9190-ca6f79006b2c.png" style="width:18.42em;height:18.08em;"/><br/></span></div>
<p>This isn't the cubemap at the moment, as we were just sorting out the texturing, but making a separate texture will allow us to easily reuse texture loading.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding cube mapping code to Texture.h</h1>
                </header>
            
            <article>
                
<p>So now, what we actually want to do is essentially the similar process as we did with the texture file, but for cube mapping. The code will be very similar, so to begin with what we are going to do is duplicate the texture loading code and paste below it. Then, we'll make the following highlighted changes to the code:</p>
<pre>static GLuint LoadCubemap( vector&lt;const GLchar * &gt; faces) 
    { 
        GLuint textureID; 
        glGenTextures( 1, &amp;textureID );      
        int imageWidth, imageHeight; 
        unsigned char *image;
        glBindTexture( GL_TEXTURE_CUBE_MAP, textureID ); 
        for ( GLuint i = 0; i &lt; faces.size( ); i++ ) 
        { 
            image = SOIL_load_image( faces[i], &amp;imageWidth, &amp;imageHeight,<br/>            0, SOIL_LOAD_RGB );  
            glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB,<br/>            imageWidth, imageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image ); 
            SOIL_free_image_data( image ); 
        } 
<br/>        glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER,<br/>        GL_LINEAR ); 

        glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER,<br/>        GL_LINEAR ); 

        glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S,<br/>        GL_CLAMP_TO_EDGE ); 

        glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T,<br/>        GL_CLAMP_TO_EDGE ); 

        glTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R,<br/>        GL_CLAMP_TO_EDGE ); 

        glBindTexture( GL_TEXTURE_CUBE_MAP, 0); 
        return textureID; 
    }</pre>
<p>In the preceding code, we added <kbd><span class="CodeInTextPACKT">GLchars</span></kbd> because we don't have one path; remember, we're going to have six different paths. Then, we created the <kbd>for</kbd> loop because we wanted to go over our six different images with ease, and also we didn't want to repeat the code, which was the whole point of doing what we're doing.</p>
<p>So, if we go back to our main file that is in our <kbd>main.cpp</kbd>, we can actually finish off what we were doing. Go to the section where we are loading our texture file, and after that code, add the following highlighted code:</p>
<pre>// Cubemap (Skybox) 

    vector&lt;const GLchar*&gt; faces; 
    faces.push_back( "res/images/skybox/right.tga" ); 
    faces.push_back( "res/images/skybox/left.tga" ); 
    faces.push_back( "res/images/skybox/top.tga" ); 
    faces.push_back( "res/images/skybox/bottom.tga" ); 
    faces.push_back( "res/images/skybox/back.tga" ); 
    faces.push_back( "res/images/skybox/front.tga" ); 
    GLuint cubemapTexture = TextureLoading::LoadCubemap( faces ) </pre>
<p>In the preceding code, we added the cubemap texture. The order here does matter, so you can't just willy-nilly put it in. If you downloaded other images from a website, you might need to rearrange it properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing the skybox</h1>
                </header>
            
            <article>
                
<p>Now, what we need to actually do is, well, draw the skybox, so let's begin by following the steps shown here:</p>
<ol>
<li>Go to the location in our code where we're done with all the model matrix stuff, and we're going to add <span class="CodeInTextPACKT"><kbd>glDepthFunc()</kbd>;</span> and in there, we need to pass <span class="CodeInTextPACKT"><kbd>GL_LEQUAL</kbd>.</span> This changes the depth function, so the depth test passes when values are equal to the depth buffer's content.</li>
<li>Next, we're going to add <kbd><span class="CodeInTextPACKT">skyboxShader.Use()</span></kbd>.</li>
<li>Then, add <kbd><span class="CodeInTextPACKT">view = glmm::mat4()</span></kbd>. And in here, we are going to pass <kbd><span class="CodeInTextPACKT">glm::mat3()</span></kbd>, and to that we'll pass <kbd><span class="CodeInTextPACKT">camera.GetViewMatrix()</span></kbd>.</li>
<li>Next, add <kbd><span class="CodeInTextPACKT">glUniformMatrix4fv()</span></kbd>. For this, we will pass the following:<br/>
<kbd>glGetUniformLocation( skyboxShader.Program, "view" ), 1, GL_FALSE, glm::value_ptr( view )</kbd>.</li>
</ol>
<ol start="5">
<li>We need to do something very similar for the projection matrix as well. So, we will add the following code: <kbd>glUniformMatrix4fv( glGetUniformLocation( skyboxShader.Program, "projection" ), 1, GL_FALSE, glm::value_ptr( projection ) );</kbd>.</li>
<li>Now what we need to do is just add the skybox cube. So, add <kbd><span class="CodeInTextPACKT">glBindVertexArray();</span></kbd> function and to that we'll pass <kbd><span class="CodeInTextPACKT">skyboxVAO</span></kbd>, and then add <kbd><span class="CodeInTextPACKT">glBindTexture()</span></kbd>. And for the bind texture function, it's going to be <kbd><span class="CodeInTextPACKT">GL_TEXTURE_CUBE_MAP</span></kbd>. Then, add the <kbd><span class="CodeInTextPACKT">cubemapTexture</span></kbd> that we call the <kbd>LoadCubemap</kbd> method.</li>
<li>Then, add <kbd><span class="CodeInTextPACKT">glDrawArrays();</span></kbd>. And, the parameters we'll pass are as follows: <kbd><span class="CodeInTextPACKT">GL_TRIANGLES</span></kbd>, <kbd><span class="CodeInTextPACKT">0</span></kbd>, <span class="CodeInTextPACKT"><kbd>36</kbd>.</span> Again, this is just a cube, so it's very simple stuff.</li>
<li>Next, add <kbd><span class="CodeInTextPACKT">glBindVertexArray()</span></kbd>. For that, pass <kbd>0</kbd>, as we normally would.</li>
<li>Now, we just need to set the <kbd><span class="CodeInTextPACKT">glDepthFunc()</span></kbd> back, and to that we're going to pass <span class="CodeInTextPACKT"><kbd>GL_LESS</kbd>;</span> this just sets it back to default.</li>
</ol>
<p>And now, we should be ready to run, so let's run this and check what output we get on the screen. We should get the following scene:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span><img src="assets/2fb9e2cb-ad73-4ba2-9020-70d1ea3aa7e7.png" style="width:33.67em;height:24.75em;"/></span></div>
<p>It literally does look like we've created a 3D world. If you try moving away, you can see the cube getting smaller and smaller. But, everything else is staying the same because we're going to be infinitely far away from all of the sides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we generated a Skybox using a cubemap, and learned to apply various textures to it. We also learned how to create the separate texture file to load our textures in the code. Also, we learned how to draw the skybox and created our game world using it.</p>
<p>There's a bonus chapter for you on Model Loading on the following link: <a href="https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf">https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf</a><br/>
In this chapter,  you'll learn how to setup Assimp (Open Asset Import Library) on Windows using CMake for all our Model Loading needs. You'll also get to learn how to create mesh class and Model class to handle loading of our model.  </p>


            </article>

            
        </section>
    </body></html>