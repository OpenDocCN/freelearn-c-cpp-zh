["```cpp\nif ((p.x > .15 * GetSystemMetrics(SM_CXSCREEN)) && \n    (p.x < .42 * GetSystemMetrics(SM_CXSCREEN)) && \n    (p.y > .58 * GetSystemMetrics(SM_CYSCREEN)) && \n    (p.y < .70 * GetSystemMetrics(SM_CYSCREEN))) \n{ \n  if (mousedown) \n  { \n    mGameState = TCodeRex::LOAD; \n    mGameLevel = L0; \n  } \n} \n\n```", "```cpp\nint Square(int x) \n\n```", "```cpp\nint (*)(int); \n\n```", "```cpp\nint (*pFunc)(int); \n\n```", "```cpp\nint (*pFunc)(int); \npFunc = Square; \nstd::cout << \"2 Squared is \"<< pFunc(2) << std::endl; \n\n```", "```cpp\n//Fills array with random values from 0 to maxVal - 1 \nvoid RandomFill(int* array, int size, int maxVal) \n{ \n  for (int i = 0; i < size; ++i) \n    array[i] = std::rand() % maxVal; \n} \n\n//Fills array with value \nvoid ValueFill(int* array, int size, int value) \n{ \n  for (int i = 0; i < size; ++i) \n    array[i] = value; \n} \n\n//Fills array with ordered values from 0 - maxVal - 1 repeatedly \nvoid ModFill(int* array, int size, int maxVal) \n{ \n  for (int i = 0; i < size; ++i) \n    array[i] = i % maxVal; \n} \n\n//Helper to print array \nvoid PrintArray(const int* array, int size) \n{ \n  for (int i = 0; i < size; ++i) \n    std::cout << array[i] << \" \"; \n  std::cout << std::endl; \n} \n\n```", "```cpp\nvoid FillAndPrint(void (*fillFunc)(int*, int, int), int* array, int size, int param); \n\n```", "```cpp\n//Defines a function pointer type named FillFUnc \ntypedef void(*FillFunc)(int*, int, int); \n\nvoid FillAndPrint(FillFunc pFunc, int* array, int size, int param) \n{ \n  pFunc(array, size, param); \n  PrintArray(array, size); \n} \n\n```", "```cpp\nint main(void) \n{ \n  const int SIZE = 20; \n  int array[SIZE]; \n  //See the Random number generator \n  std::srand(static_cast<unsigned>(time(0))); \n  FillAndPrint(ValueFill, array, 20, 3); \n  FillAndPrint(RandomFill, array, 10, 5); \n\n  return 0; \n} \n\n```", "```cpp\nFillFunc PickFill(int index) \n{   \n  switch (index) \n  { \n  case 0: \n    return RandomFill; \n  case 1: \n    return ValueFill; \n  default: \n    //We could report an error if the value is outside of the \n    //range, but instead we just use a default \n    return ModFill; \n  } \n} \n\n//Our Second main example \nint main(void) \n{ \n  const int SIZE = 20; \n  int array[SIZE]; \n  int fillChoice; \n  int param; \n\n  //This doesn't properly explain to the user, \n  //but it is just an example \n  std::cout << \"Enter a Fill Mode and parameter to use\" \n            << std::endl; \n  std::cin  >> fillChoice; \n  std::cin  >> param; \n  //See the Random number generator \n  std::srand(static_cast<unsigned>(time(0))); \n  FillAndPrint(PickFill(fillChoice), array, 20, param); \n\n  return 0; \n} \n\n```", "```cpp\n//MainMenuComponent.h \nclass MainMenuComponent : public M5Component \n{ \npublic: \n  MainMenuComponent(void); \n  ~MainMenuComponent(void); \n  virtual void Update(float dt); \n  virtual void FromFile(M5IniFile&); \n  virtual MainMenuComponent* Clone(void) const; \nprivate: \n}; \n\n//MainMenuComponent.cpp \nvoid MainMenuComponent::Update(float /*dt*/) \n{ \n  M5Vec2 mouseClick; \n  M5Input::GetMouse(mouseClick); \n\n  if(M5Input::IsTriggered(M5_MOUSE_LEFT) && \n     M5Intersect::PointRect(clickPoint, \n       m_pObj->pos, m_pObj->scale.x, m_pObj->scale.y)) \n  { \n    M5StageManager::SetNextStage(ST_MainMenu); \n  } \n} \n\n```", "```cpp\n// SwapTextureComponent.cpp \nvoid SwapTextureComponent::Update(float /*dt*/) \n{ \n  M5Vec2 mouseClick; \n  M5Input::GetMouse(mouseClick); \n\n  if(M5Input::IsTriggered(M5_MOUSE_LEFT) && \n     M5Intersect::PointRect(clickPoint, \n     m_pObj->pos, m_pObj->scale.x, m_pObj->scale.y)) \n{ \n  //Get the Graphics Component \n  M5GfxComponent* pGfx = 0; \n    m_savedObj->GetComponent(CT_GfxComponent, pGfx); \n\n    //Do something to swap the texture...  \n  } \n} \n\n```", "```cpp\nint Square(int x) \n{ \n  return x * x; \n} \n\nint Cube(int x) \n{ \n  return x*x*x; \n} \n\n```", "```cpp\n//Base Command Class \nclass Command \n{ \npublic: \n  virtual ~Command(void) {} \n  virtual void Execute(void) = 0; \n}; \n\n```", "```cpp\n//Derived command classes \nclass Square5Command: public Command \n{ \npublic: \n  virtual void Execute(void) \n  { \n    std::cout << \"5 squared is \" << Square(5) << std::endl; \n  } \n}; \n\n```", "```cpp\n//The function signature of both Square and Cube \ntypedef int (*OneArgFunc)(int); \n\n//Command that can use any function of type OneArgFunc \nclass OneArgCommand: public Command \n{ \npublic: \n  OneArgCommand(OneArgFunc action, int* pValue): \n    m_action(action), m_pValue(pValue) \n  { \n  } \n  virtual void Execute(void) \n  { \n    *m_pValue = m_action(*m_pValue); \n  } \nprivate: \n  OneArgFunc m_action; \n  int*       m_pValue; \n}; \n\n```", "```cpp\nint main(void) \n{ \n  const int SIZE = 3; \n  int value = 2; \n   //This commands could be loaded via another function \n  Command* commands[SIZE] = { \n    new Square5Command, \n    new OneArgCommand(Square, &value), \n    new OneArgCommand(Cube, &value), \n  }; \n\n  //The Client Code \n  commands[0]->Execute();//Square5 \n  std::cout << \"value is \" << value << std::endl; \n  commands[1]->Execute();//OneArg Square \n  std::cout << \"value is \" << value << std::endl; \n  commands[2]->Execute();//OneArg Cube \n  std::cout << \"value is \" << value << std::endl; \n\n   for (int i = 0; i < SIZE; ++i) \n    delete commands[i]; \n\n  return 0; \n} \n\n```", "```cpp\n5 squared is 25 \nvalue is 2 \nvalue is 4 \nvalue is 64 \n\n```", "```cpp\nint Add(int x, int y) \n{ \n  return x + y; \n} \n\n```", "```cpp\ntypedef int (*TwoArgsFunc)(int, int); \n\n```", "```cpp\nclass TwoArgCommand: public Command \n{ \npublic: \n  TwoArgCommand(TwoArgsFunc action, int x, int y) : \n    m_action(action), m_first(x), m_second(y) \n  { \n  } \n\n  virtual void Execute(void) \n  { \n    std::cout << \"The Result is \" \n                << m_action(m_first, m_second) \n                << std::endl; \n  } \nprivate: \n  TwoArgsFunc m_action; \n  int         m_first; \n  int         m_second; \n}; \n\n```", "```cpp\nCommand* commands[SIZE] = { \n    new Square5Command, \n    new OneArgCommand(Square, &value), \n    new OneArgCommand(Cube, &value), \n    new TwoArgCommand(Add, 5, 6) \n  }; \n\n//The Client Code \n  commands[0]->Execute();//Square5 \n  std::cout << \"value is \" << value << std::endl; \n  commands[1]->Execute();//OneArg Square \n  std::cout << \"value is \" << value << std::endl; \n  commands[2]->Execute();//OneArg Cube \n  std::cout << \"value is \" << value << std::endl; \n  commands[3]->Execute();//TwoArg \n\n```", "```cpp\n5 squared is 25 \nvalue is 2 \nvalue is 4 \nvalue is 64 \nThe Result is 11 \n\n```", "```cpp\n//Example of hard-coding a class method \nvirtual void Execute(void) \n{ \n  m_gameObject->Draw(); \n} \n\n```", "```cpp\nclass SomeClass \n{ \npublic: \n  //Example of what the compiler adds to every \n  //Non-static class method. THIS IS NOT REAL CODE \nvoid SomeFunc(SomeClass* const this); \nprivate: \n  int m_x; \n}; \n\n```", "```cpp\nSomeClass someClass; \n//when we type this \nsomeClass.SomeFunc(); \n\n//The compiler does something like this \nSomeClass::SomeFunc(&someClass); \n\n```", "```cpp\nvoid SomeClass::SomeFunc(/* SomeClass* const this */) \n{ \n//We can still use the this pointer even though it isn't \n//in the parameter list \nthis->m_x += 2; \n\n//But we don't have to use it. \nm_x += 2; \n} \n\n```", "```cpp\nSomeClass someClass; \n//This doesn't work because they are not the same type \nvoid (*BadFunc)(void) = &SomeClass::SomeFunc; \n\n//We must include the class type \nvoid (SomeClass::*GoodFunc)(void) = &SomeClass::SomeFunc; \n\n```", "```cpp\nSomeClass someClass; \nvoid (SomeClass::*GoodFunc)(void) = &SomeClass::SomeFunc; \n\n//this doesn't work. GoodFunc isn't part of the class \nsomeClass.GoodFunc(); \n//Extra parenthesis is required for .* and ->* \n(someClass.*GoodFunc)(); \n\n```", "```cpp\nclass SomeObject \n{ \npublic: \n  SomeObject(int x):m_x(x){} \n\n  void Display(void) \n  { \n    std::cout << \"x is \" << m_x << std::endl; \n  } \n  void Change(void) \n  { \n    m_x += m_x; \n  } \nprivate: \n  int m_x; \n}; \n\n```", "```cpp\ntypedef void (SomeObject::*SomeObjectMember)(void); \n\n```", "```cpp\nclass SomeObjectCommand: public Command \n{ \npublic: \n  SomeObjectCommand(SomeObject* pObj, SomeObjectMember member) : \n    m_pObj(pObj), m_member(member) \n  { \n  } \n  virtual void Execute(void) \n  { \n    (m_pObj->*m_member)(); \n  } \nprivate: \n  SomeObject*      m_pObj; \n  SomeObjectMember m_member; \n}; \n\n```", "```cpp\n#define CALL_MEMBER_FUNC(pObj, member) ((pObj)->*(member)) \n\n```", "```cpp\nvirtual void Execute(void) \n{ \n  CALL_MEMBER_FUNC(m_pObj, m_member)(); \n} \n\n```", "```cpp\nint main(void) \n{ \n  const int SIZE = 6; \n  int value = 2; \n  SomeObject object(10); \n  Command* commands[SIZE] = { \n    new Square5Command, \n    new OneArgCommand(Square, &value), \n    new OneArgCommand(Cube, &value), \n    new TwoArgCommand(Add, 5, 6), \n    new SomeObjectCommand(&object, &SomeObject::Display), \n    new SomeObjectCommand(&object, &SomeObject::Change) \n  }; \n\n  //The Client Code \n  commands[0]->Execute();//Square5 \n  std::cout << \"value is \" << value << std::endl; \n  commands[1]->Execute();//OneArg Square \n  std::cout << \"value is \" << value << std::endl; \n  commands[2]->Execute();//OneArg Cube \n  std::cout << \"value is \" << value << std::endl; \n  commands[3]->Execute();//TwoArg \n\n  //Member function pointers \n  commands[4]->Execute();//Display \n  commands[5]->Execute();//Change \n  commands[4]->Execute();//Display \n\n  for (int i = 0; i < SIZE; ++i) \n    delete commands[i]; \n\n  return 0; \n} \n\n```", "```cpp\ntemplate<typename Type, typename Method> \nclass TMethodCommand: public Command \n{ \npublic: \n  TMethodCommand(Type* pObj, Method method) : \n     m_pObj(pObj), m_method(method) \n  { \n  } \n\n  virtual void Execute(void) \n  { \n    (m_pObj->*m_method)(); \n  } \nprivate: \n  Type*  m_pObj; \n  Method m_method; \n}; \n\n```", "```cpp\n//Examples of setting up function calls \n//Immediate execution \nAdd(5, 6); \n//Delayed execution \nCommand* p1 = new TwoArgCommand(Add, 5, 6); \n\n//Immediate execution \nsomeObject.Display(); \n//Delayed execution \nCommand* p2 = new SomeObjectCommand(&object,&SomeObject::Display); \n\n```", "```cpp\nclass MoveCommand: public Command \n{ \npublic: \nMoveCommand (Object* pObj, const Vec2D& moveTo) : \n  m_pObj(pObj), m_method(method), m_oldPos(pObj->pos) \n{ \n} \nvirtual void Execute(void) \n{ \n  m_pObj->pos = m_moveTo; \n} \n\n//Add this method to the Command Interface \nvirtual void Undo(void) \n{ \n  m_pObj->pos = m_oldPos; \n} \nprivate: \nObject* m_pObj; \nVec2D   m_moveTo; \nVec2D   m_oldPos;//Save the old position so we can redo \n}; \n\n```", "```cpp\nclass M5Command \n{ \npublic: \n  virtual ~M5Command(void) {}//Empty Virtual Destructor \n  virtual void Execute(void) = 0; \n  virtual M5Command* Clone(void) const = 0; \n}; \n\n```", "```cpp\nclass UIButtonComponent: public M5Component \n{ \npublic: \n  UIButtonComponent(void); \n  ~UIButtonComponent(void); \n  virtual void Update(float dt); \n  virtual UIButtonComponent* Clone(void) const; \n  void SetOnClick(M5Command* pCommand); \nprivate: \n  M5Command* m_pOnClick; \n}; \n\n```", "```cpp\nUI Button Component::UI Button Component(void) : \n  M5Component(CT_UIButtonComponent), m_pOnClick(nullptr) \n{ \n} \n\n```", "```cpp\nUIButtonComponent::~UIButtonComponent(void) \n{ \n  delete m_pOnClick; \n  m_pOnClick = 0; \n} \n\n```", "```cpp\nvoid UIButtonComponent::Update(float) \n{ \n  if (M5Input::IsTriggered(M5_MOUSE_LEFT)) \n  { \n    M5Vec2 clickPoint; \n    M5Input::GetMouse(clickPoint); \n    if (M5Intersect::PointRect(clickPoint, m_pObj->pos, \n       m_pObj->scale.x, m_pObj->scale.y)) \n    { \n      M5DEBUG_ASSERT(m_pOnClick != 0,\n         \"The UIButton command is null\"): \n      m_pOnClick->Execute(); \n    } \n  } \n} \n\n```", "```cpp\nUIButtonComponent* UIButtonComponent::Clone(void) const \n{ \nUIButtonComponent* pClone = new UIButtonComponent(); \npClone->m_pObj = m_pObj; \n\nif(pClone->m_pOnClick != nullptr) \n  pClone->m_pOnClick = m_pOnClick->Clone(); \n\nreturn pClone; \n} \n\n```", "```cpp\nvoid UIButtonComponent::SetOnClick(M5Command* pCommand) \n{ \n//Make sure to delete the old one \ndelete m_pOnClick; \nm_pOnClick = pCommand; \n} \n\n```", "```cpp\nvoid UIButtonComponent::Update(float) \n{ \n  M5Vec2 clickPoint; \n  M5Input::GetMouse(clickPoint); \n  if (M5Intersect::PointRect(clickPoint, m_pObj->pos, \n     m_pObj->scale.x, m_pObj->scale.y)) \n  { \n    if (M5Input::IsTriggered(M5_MOUSE_LEFT)) \n    { \n      //Do onClick Command \n    } \n    else \n    { \n      //Do onMouseOver Command\n     } \n  } \n} \n\n```", "```cpp\nclass ChangeStageCommand: public M5Command \n{ \npublic: \nChangeStageCommand(M5StageTypes nextStage); \nChangeStageCommand(void); \nvirtual void Execute(void); \nvoid SetNextStage(M5StageTypes nextStage); \nvirtual ChangeStageCommand* Clone(void) const; \nprivate: \n  M5StageTypes m_stage; \n}; \n\n```", "```cpp\nvoid ChangeStageCommand::Execute(void) \n{ \n  M5StageManager::SetNextStage(m_stage); \n} \n\n```"]