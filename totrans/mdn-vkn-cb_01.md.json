["```cpp\n    VkDevice device;\n    const VkSamplerCreateInfo samplerInfo = {\n          .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,\n          .magFilter = VK_FILTER_LINEAR,\n          .minFilter = VK_FILTER_LINEAR,\n          .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n          .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n          .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n          .mipLodBias = 0,\n          .anisotropyEnable = VK_FALSE,\n          .minLod = 0,\n          .maxLod = maxLod,\n      };\n    VkSampler sampler = VK_NULL_HANDLE;\n    const VkResult result = vkCreateSampler(device, &samplerInfo, nullptr, &sampler);\n    assert(result == VK_SUCCESS);\n    VkStructureType declared by the Vulkan SDK. If you use the wrong value for sType, you won’t get a compilation error, and maybe not even a runtime error. Maybe not even an error at all! Well, at least not while running it on your development machine. As soon as someone else tries your code on their device, then it could crash. Luckily, there is a mechanism that helps us detect this kind of mistake at runtime. It’s called the Validation Layer, and we’re going to talk more about it in this chapter.\n    ```", "```cpp\n    #define VK_CHECK(func)                                \\\n      {                                                   \\\n        const VkResult result = func;                     \\\n        if (result != VK_SUCCESS) {                       \\\n          std::cerr << \"Error calling function \" << #func \\\n                    << \" at \" << __FILE__ << \":\"          \\\n                    << __LINE__ << \". Result is \"         \\\n                    << string_VkResult(result)            \\\n                    << std::endl;                         \\\n          assert(false);                                  \\\n        }                                                 \\\n      }\n    ```", "```cpp\n    bool isEnabledForDevice(VkDevice device,\n                            const std::string &extName) {\n      // std::unordered_map<std::string> deviceExtensions;\n      return deviceExtensions.contains(extName);\n    }\n      VkDevice device;  // Valid Vulkan Device\n    #if defined(VK_KHR_win32_surface)\n      // VK_KHR_WIN32_SURFACE_EXTENSION_NAME is defined as the string\n      // \"VK_KHR_win32_surface\"\n      if (isEnabledForDevice(device, VK_KHR_WIN32_SURFACE_EXTENSION_NAME)) {\n        // VkWin32SurfaceCreateInfoKHR struct is available, as well as the\n        // vkCreateWin32SurfaceKHR() function\n        VkWin32SurfaceCreateInfoKHR surfaceInfo;\n      }\n    #endif\n    ```", "```cpp\n    VUID-VkSamplerCreateInfo-sType-sType(ERROR / SPEC): msgNum: -129708450 - Validation Error: [ VUID-VkSamplerCreateInfo-sType-sType ] Object 0: handle = 0x1fbd501b6e0, name = Device, type = VK_OBJECT_TYPE_DEVICE; | MessageID = 0xf844ce5e | vkCreateSampler: parameter pCreateInfo->sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO. The Vulkan spec states: sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO (https://vulkan.lunarg.com/doc/view/1.3.236.0/windows/1.3-extensions/vkspec.html#VUID-VkSamplerCreateInfo-sType-sType)\n        Objects: 1\n            [0] 0x1fbd501b6e0, type: 3, name: Device\n    ```", "```cpp\n    uint32_t instanceLayerCount{0};\n    VK_CHECK(vkEnumerateInstanceLayerProperties(\n        &instanceLayerCount, nullptr));\n    std::vector<VkLayerProperties> layers(\n        instanceLayerCount);\n    VK_CHECK(vkEnumerateInstanceLayerProperties(\n        &instanceLayerCount, layers.data()));\n    ```", "```cpp\n    std::vector<std::string> availableLayers;\n    std::transform(\n        layers.begin(), layers.end(),\n        std::back_inserter(availableLayers),\n        [](const VkLayerProperties& properties) {\n          return properties.layerName;\n        });\n    ```", "```cpp\n    std::unordered_set<std::string> filterExtensions(\n        std::vector<std::string> availableExtensions,\n        std::vector<std::string> requestedExtensions) {\n      std::sort(availableExtensions.begin(),\n                availableExtensions.end());\n      std::sort(requestedExtensions.begin(),\n                requestedExtensions.end());\n      std::vector<std::string> result;\n      std::set_intersection(\n          availableExtensions.begin(),\n          availableExtensions.end(),\n          requestedExtensions.begin(),\n          requestedExtensions.end(),\n          std::back_inserter(result));\n      return std::unordered_set<std::string>(\n          result.begin(), result.end());\n    }\n    ```", "```cpp\n    uint32_t extensionsCount{0};\n    vkEnumerateInstanceExtensionProperties(\n        nullptr, &extensionsCount, nullptr);\n    std::vector<VkExtensionProperties>\n        extensionProperties(extensionsCount);\n    vkEnumerateInstanceExtensionProperties(\n        nullptr, &extensionsCount,\n        extensionProperties.data());\n    std::vector<std::string> availableExtensions;\n    std::transform(\n        extensionProperties.begin(),\n        extensionProperties.end(),\n        std::back_inserter(availableExtensions),\n        [](const VkExtensionProperties& properties) {\n          return properties.extensionName;\n        });\n    ```", "```cpp\n    const std::vector<std::string>\n        requestedInstanceLayers = {\n            \"VK_LAYER_KHRONOS_validation\"};\n    const std::vector<std::string>\n        requestedInstanceExtensions = {\n    #if defined(VK_KHR_win32_surface)\n          VK_KHR_WIN32_SURFACE_EXTENSION_NAME,\n    #endif\n    #if defined(VK_EXT_debug_utils),\n          VK_EXT_DEBUG_UTILS_EXTENSION_NAME,\n    #endif\n    #if defined(VK_KHR_surface)\n          VK_KHR_SURFACE_EXTENSION_NAME,\n    #endif\n        };\n    const auto enabledInstanceLayers =\n        filterExtensions(availableLayers,\n                          requestedInstanceLayers);\n    const auto enabledInstanceExtensions =\n        filterExtensions(availableExtensions,\n                          requestedInstanceExtensions);\n    ```", "```cpp\n    std::vector<const char*> instanceExtensions(\n        enabledInstanceExtensions.size());\n    std::transform(enabledInstanceExtensions.begin(),\n                    enabledInstanceExtensions.end(),\n                    instanceExtensions.begin(),\n                    std::mem_fn(&std::string::c_str));\n    ```", "```cpp\n    const VkApplicationInfo applicationInfo_ = {\n        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n        .pApplicationName = \"Essential Graphics With Vulkan\",\n        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),\n        .apiVersion = VK_API_VERSION_1_3,\n    };\n    ```", "```cpp\n    const VkInstanceCreateInfo instanceInfo = {\n        .sType =\n            VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n        .pApplicationInfo = &applicationInfo_,\n        .enabledLayerCount = static_cast<uint32_t>(\n            requestedLayers.size()),\n        .ppEnabledLayerNames = requestedLayers.data(),\n        .enabledExtensionCount = static_cast<uint32_t>(\n            instanceExtensions.size()),\n        .ppEnabledExtensionNames =  instanceExtensions.data(),\n    };\n    VkInstance instance_{VK_NULL_HANDLE};\n    VK_CHECK(vkCreateInstance(&instanceInfo, nullptr,\n                              &instance_));\n    ```", "```cpp\n    const auto window = glfwGetWin32Window(glfwWindow);\n    #if defined(VK_USE_PLATFORM_WIN32_KHR) && \\\n        defined(VK_KHR_win32_surface)\n        if (enabledInstanceExtensions_.contains(\n                VK_KHR_WIN32_SURFACE_EXTENSION_NAME)) {\n          if (window != nullptr) {\n            const VkWin32SurfaceCreateInfoKHR ci = {\n                .sType =\n                    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,\n                .hinstance = GetModuleHandle(NULL),\n                .hwnd = (HWND)window,\n            };\n            VK_CHECK(vkCreateWin32SurfaceKHR(\n                instance_, &ci, nullptr, &surface_));\n          }\n        }\n    #endif\n    ```", "```cpp\n    std::vector<PhysicalDevice>\n    Context::enumeratePhysicalDevices(\n        const std::vector<std::string>&\n            requestedExtensions) const {\n      uint32_t deviceCount{0};\n      VK_CHECK(vkEnumeratePhysicalDevices(\n          instance_, &deviceCount, nullptr));\n      ASSERT(deviceCount > 0,\n              \"No Vulkan devices found\");\n      std::vector<VkPhysicalDevice> devices(\n          deviceCount);\n      VK_CHECK(vkEnumeratePhysicalDevices(\n          instance_, &deviceCount, devices.data()));\n      std::vector<PhysicalDevice> physicalDevices;\n      for (const auto device : devices) {\n        physicalDevices.emplace_back(PhysicalDevice(\n            device, surface_, requestedExtensions,\n            printEnumerations_));\n      }\n      return physicalDevices;\n    }\n    ```", "```cpp\n    uint32_t queueFamilyCount{0};\n    vkGetPhysicalDeviceQueueFamilyProperties(\n        physicalDevice_, &queueFamilyCount, nullptr);\n    queueFamilyProperties_.resize(queueFamilyCount);\n    vkGetPhysicalDeviceQueueFamilyProperties(\n        physicalDevice_, &queueFamilyCount,\n        queueFamilyProperties_.data());\n    ```", "```cpp\n    uint32_t propertyCount{0};\n    VK_CHECK(vkEnumerateDeviceExtensionProperties(\n        physicalDevice_, nullptr, &propertyCount,\n        nullptr));\n    std::vector<VkExtensionProperties> properties(\n        propertyCount);\n    VK_CHECK(vkEnumerateDeviceExtensionProperties(\n        physicalDevice_, nullptr, &propertyCount,\n        properties.data()));\n    ```", "```cpp\n    std::transform(\n        properties.begin(), properties.end(),\n        std::back_inserter(extensions_),\n        [](const VkExtensionProperties& property) {\n          return std::string(property.extensionName);\n        });\n    ```", "```cpp\n    enabledExtensions_ = util::filterExtensions(\n        extensions_, requestedExtensions);\n    ```", "```cpp\n    uint32_t graphicsFamilyIndex{UINT32_MAX};\n    uint32_t presentationFamilyIndex{UINT32_MAX};\n    for (uint32_t queueFamilyIndex = 0;\n          queueFamilyIndex <\n              queueFamilyProperties_.size() &&\n          requestedQueueTypes != 0;\n          ++queueFamilyIndex) {\n      if (graphicsFamilyIndex == UINT32_MAX &&\n          (queueFamilyProperties_[queueFamilyIndex]\n                .queueFlags &\n            VK_QUEUE_GRAPHICS_BIT)) {\n        graphicsFamilyIndex = queueFamilyIndex;\n      }\n    ```", "```cpp\n    #if defined(VK_KHR_surface)\n      if (enabledInstanceExtensions_.contains(\n              VK_KHR_SURFACE_EXTENSION_NAME)) {\n        if (presentationFamilyIndex == UINT32_MAX &&\n            surface != VK_NULL_HANDLE) {\n          VkBool32 supportsPresent{VK_FALSE};\n          vkGetPhysicalDeviceSurfaceSupportKHR(\n              physicalDevice_, queueFamilyIndex,\n              surface, &supportsPresent);\n          if (supportsPresent == VK_TRUE) {\n            presentationFamilyIndex = queueFamilyIndex;\n          }\n        }\n      }\n    #endif\n    }\n    ```", "```cpp\n    auto physicalDevice_ = enumeratePhysicalDevices(\n        requestedExtensions)[0];\n    // Retrieves a vector of (queue family indices and\n    // their number)\n    const vector<uint32_t> familyIndices =\n        physicalDevice_.reservedFamilies();\n    std::vector<VkDeviceQueueCreateInfo>\n        queueCreateInfos;\n    float priority{1.0f};\n    for (const auto& queueFamilyIndex :\n          familyIndices) {\n      queueCreateInfos.emplace_back(\n          VkDeviceQueueCreateInfo{\n              .sType =\n                  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n              .queueFamilyIndex = queueFamilyIndex,\n              .queueCount = 1,\n              .pQueuePriorities = &priority,\n          });\n      ++index;\n    }\n    ```", "```cpp\n    std::vector<const char*> deviceExtensions(\n        physicalDevice_.enabledExtensions().size());\n    std::transform(\n        physicalDevice_.enabledExtensions().begin(),\n        physicalDevice_.enabledExtensions().end(),\n        deviceExtensions.begin(),\n        std::mem_fn(&std::string::c_str));\n    const VkDeviceCreateInfo dci = {\n        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,\n        .queueCreateInfoCount = static_cast<uint32_t>(\n            queueCreateInfos.size()),\n        .pQueueCreateInfos = queueCreateInfos.data(),\n        .enabledLayerCount = static_cast<uint32_t>(\n            requestedLayers.size()),\n        .ppEnabledLayerNames = requestedLayers.data(),\n        .enabledExtensionCount = static_cast<uint32_t>(\n            deviceExtensions.size()),\n        .ppEnabledExtensionNames =\n            deviceExtensions.data(),\n    };\n    VK_CHECK(vkCreateDevice(\n        physicalDevice_.vkPhysicalDevice(), &dci,\n        nullptr, &device_));\n    ```", "```cpp\nVkQueue queue{VK_NULL_HANDLE};\nuint32_t queueFamilyIndex; // valid queue family\nvkGetDeviceQueue(device, queueFamilyIndex, 0, &queue);\n```", "```cpp\nuint32_t queueFamilyIndex; // Valid queue family index\nconst VkCommandPoolCreateInfo commandPoolInfo = {\n    .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,\n    .flags =\n      VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,\n    .queueFamilyIndex = queueFamilyIndex,\n};\nVkCommandPool commandPool{VK_NULL_HANDLE};\nVK_CHECK(\n    vkCreateCommandPool(device, &commandPoolInfo,\n                        nullptr, &commandPool));\n```", "```cpp\n    const VkCommandBufferAllocateInfo commandBufferInfo = {\n            .sType =\n                VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,\n            .commandPool = commandPool_,\n            .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,\n            .commandBufferCount = 1,\n        };\n        VkCommandBuffer cmdBuffer{VK_NULL_HANDLE};\n        VK_CHECK(vkAllocateCommandBuffers(\n            device, &commandBufferInfo, &cmdBuffer));\n    ```", "```cpp\n    const VkCommandBufferBeginInfo info = {\n          .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n          .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n    };\n    VK_CHECK(vkBeginCommandBuffer(cmdBuffer, &info));\n    ```", "```cpp\n    VK_CHECK(vkEndCommandBuffer(cmdBuffer));\n    ```", "```cpp\n    VkDevice device;  // Valid Vulkan Device\n    VkQueue queue;  // Valid Vulkan Queue\n    VkFence fence{VK_NULL_HANDLE};\n    const VkFenceCreateInfo fenceInfo = {\n        .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,\n        .flags = VK_FENCE_CREATE_SIGNALED_BIT,\n    };\n    VK_CHECK(vkCreateFence(device, &fenceInfo, nullptr,\n                            &fence));\n    const VkSubmitInfo submitInfo = {\n        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n        .commandBufferCount = 1,\n        .pCommandBuffers = cmdBuffer,\n    };\n    VK_CHECK(\n        vkQueueSubmit(queue, 1, submitInfo, fence));\n    ```", "```cpp\n    VkDevice device; // Valid Vulkan Device\n    VK_CHECK(vkWaitForFences(device, 1, &fences, true,\n                             UINT32_MAX));\n    VK_CHECK(vkResetFences(device, 1, &fences));\n    ```", "```cpp\n    RenderPass::RenderPass(\n        const Context& context,\n        const std::vector<std::shared_ptr<Texture>>\n            attachments,\n        const std::vector<VkAttachmentLoadOp>& loadOp,\n        const std::vector<VkAttachmentStoreOp>& storeOp,\n        const std::vector<VkImageLayout>& layout,\n        VkPipelineBindPoint bindPoint,\n        const std::string& name)\n        : device_{context.device()} {\n      ASSERT(attachments.size() == loadOp.size() &&\n                 attachments.size() == storeOp.size() &&\n                 attachments.size() == layout.size(),\n             \"The sizes of the attachments and their load \"\n             \"and store operations and final layouts \"\n             \"must match\");\n      std::vector<VkAttachmentDescription>\n          attachmentDescriptors;\n      std::vector<VkAttachmentReference>\n          colorAttachmentReferences;\n      std::optional<VkAttachmentReference>\n          depthStencilAttachmentReference;\n    ```", "```cpp\n      for (uint32_t index = 0; index < attachments.size();\n           ++index) {\n        attachmentDescriptors.emplace_back(\n            VkAttachmentDescription{\n                .format = attachments[index]->vkFormat(),\n                .samples = VK_SAMPLE_COUNT_1_BIT,\n                .loadOp =\n                    attachments[index]->isStencil()\n                        ? VK_ATTACHMENT_LOAD_OP_DONT_CARE\n                        : loadOp[index],\n                .storeOp =\n                    attachments[index]->isStencil()\n                        ? VK_ATTACHMENT_STORE_OP_DONT_CARE\n                        : storeOp[index],\n                .stencilLoadOp =\n                    attachments[index]->isStencil()\n                        ? loadOp[index]\n                        : VK_ATTACHMENT_LOAD_OP_DONT_CARE,\n                .stencilStoreOp =\n                    attachments[index]->isStencil()\n                        ? storeOp[index]\n                        : VK_ATTACHMENT_STORE_OP_DONT_CARE,\n                .initialLayout =\n                    attachments[index]->vkLayout(),\n                .finalLayout = layout[index],\n            });\n    ```", "```cpp\n        if (attachments[index]->isStencil() ||\n            attachments[index]->isDepth()) {\n          depthStencilAttachmentReference =\n              VkAttachmentReference{\n                  .attachment = index,\n                  .layout =\n                      VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,\n              };\n        } else {\n          colorAttachmentReferences.emplace_back(\n              VkAttachmentReference{\n                  .attachment = index,\n                  .layout =\n                      VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n              });\n        }\n      }\n    ```", "```cpp\n      const VkSubpassDescription spd = {\n          .pipelineBindPoint =\n              VK_PIPELINE_BIND_POINT_GRAPHICS,\n          .colorAttachmentCount = static_cast<uint32_t>(\n              colorAttachmentReferences.size()),\n          .pColorAttachments =\n              colorAttachmentReferences.data(),\n          .pDepthStencilAttachment =\n              depthStencilAttachmentReference.has_value()\n                  ? &depthStencilAttachmentReference\n                         .value()\n                  : nullptr,\n      };\n    ```", "```cpp\n      const VkSubpassDependency subpassDependency = {\n          .srcSubpass = VK_SUBPASS_EXTERNAL,\n          .srcStageMask =\n              VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |\n              VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,\n          .dstStageMask =\n              VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |\n              VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,\n          .dstAccessMask =\n              VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |\n              VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,\n      };\n    ```", "```cpp\n      const VkRenderPassCreateInfo rpci = {\n          .sType =\n              VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,\n          .attachmentCount = static_cast<uint32_t>(\n              attachmentDescriptors.size()),\n          .pAttachments = attachmentDescriptors.data(),\n          .subpassCount = 1,\n          .pSubpasses = &spd,\n          .dependencyCount = 1,\n          .pDependencies = &subpassDependency,\n      };\n      VK_CHECK(vkCreateRenderPass(device_, &rpci, nullptr,\n                                  &renderPass_));\n      context.setVkObjectname(renderPass_,\n                              VK_OBJECT_TYPE_RENDER_PASS,\n                              \"Render pass: \" + name);\n    }\n    ```", "```cpp\n    RenderPass::~RenderPass() {\n      vkDestroyRenderPass(device_, renderPass_, nullptr);\n    }\n    ```", "```cpp\n    uint32_t width, height; // Width and height of attachments\n    VkDevice device; // Valid Vulkan Device\n    std::vector<VkImageView> imageViews; // Valid Image Views\n    const VkFramebufferCreateInfo framebufferInfo = {\n        .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,\n        .renderPass = renderPass,\n        .attachmentCount =\n            static_cast<uint32_t>(attachments.size()),\n        .pAttachments = imageViews.data(),\n        .width = attachments[0]->vkExtents().width,\n        .height = attachments[0]->vkExtents().height,\n        .layers = 1,\n    };\n    VK_CHECK(\n        vkCreateFramebuffer(device_, &framebufferInfo,\n                            nullptr, &framebuffer_));\n    ```", "```cpp\n    VkImage image; // Valid VkImage\n    const VkImageAspectFlags aspectMask =\n        isDepth() ? VK_IMAGE_ASPECT_DEPTH_BIT\n                  : VK_IMAGE_ASPECT_COLOR_BIT;\n    const VkImageViewCreateInfo imageViewInfo = {\n        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n        .image = image_,\n        .viewType = viewType,\n        .format = format,\n        .components =\n            {\n                .r = VK_COMPONENT_SWIZZLE_IDENTITY,\n                .g = VK_COMPONENT_SWIZZLE_IDENTITY,\n                .b = VK_COMPONENT_SWIZZLE_IDENTITY,\n                .a = VK_COMPONENT_SWIZZLE_IDENTITY,\n            },\n        .subresourceRange = {\n            .aspectMask = aspectMask,\n            .baseMipLevel = 0,\n            .levelCount = numMipLevels,\n            .baseArrayLayer = 0,\n            .layerCount = layers,\n        }};\n    VK_CHECK(vkCreateImageView(context_.device(),\n                                &imageViewInfo, nullptr,\n                                &imageView_));\n    ```", "```cpp\n    std::vector<char> ShaderModule::glslToSpirv(\n        const std::vector<char>& data,\n        EShLanguage shaderStage,\n        const std::string& shaderDir,\n        const char* entryPoint) {\n      static bool glslangInitialized = false;\n      if (!glslangInitialized) {\n        glslang::InitializeProcess();\n        glslangInitialized = true;\n      }\n    ```", "```cpp\n      glslang::TShader tshader(shaderStage);\n      const char* glslCStr = data.data();\n      tshader.setStrings(&glslCStr, 1);\n      glslang::EshTargetClientVersion clientVersion =\n          glslang::EShTargetVulkan_1_3;\n      glslang::EShTargetLanguageVersion langVersion =\n          glslang::EShTargetSpv_1_3;\n      tshader.setEnvInput(glslang::EShSourceGlsl,\n                          shaderStage,\n                          glslang::EShClientVulkan, 460);\n      tshader.setEnvClient(glslang::EShClientVulkan,\n                           clientVersion);\n      tshader.setEnvTarget(glslang::EShTargetSpv,\n                           langVersion);\n      tshader.setEntryPoint(entryPoint);\n      tshader.setSourceEntryPoint(entryPoint);\n    ```", "```cpp\n      const TBuiltInResource* resources =\n          GetDefaultResources();\n      const EShMessages messages =\n          static_cast<EShMessages>(\n              EShMsgDefault | EShMsgSpvRules |\n              EShMsgVulkanRules | EShMsgDebugInfo |\n              EShMsgReadHlsl);\n      CustomIncluder includer(shaderDir);\n      std::string preprocessedGLSL;\n      if (!tshader.preprocess(\n              resources, 460, ENoProfile, false, false,\n              messages, &preprocessedGLSL, includer)) {\n        std::cout << \"Preprocessing failed for shader: \"\n                  << std::endl;\n        printShader(data);\n        std::cout << std::endl;\n        std::cout << tshader.getInfoLog() << std::endl;\n        std::cout << tshader.getInfoDebugLog()\n                  << std::endl;\n        ASSERT(false, \"includes are forbidden\");\n        return std::vector<char>();\n      }\n    ```", "```cpp\n      glslang::SpvOptions options;\n    #ifdef _DEBUG\n      tshader.setDebugInfo(true);\n      options.generateDebugInfo = true;\n      options.disableOptimizer = true;\n      options.optimizeSize = false;\n      options.stripDebugInfo = false;\n      options.emitNonSemanticShaderDebugSource = true;\n    #else\n      options.disableOptimizer = true;  // Special care!\n      options.optimizeSize = true;\n      options.stripDebugInfo = true;\n    #endif\n      glslang::TProgram program;\n      program.addShader(&tshader);\n      if (!program.link(messages)) {\n        std::cout << \"Parsing failed for shader \"\n                  << std::endl;\n        std::cout << program.getInfoLog() << std::endl;\n        std::cout << program.getInfoDebugLog()\n                  << std::endl;\n        ASSERT(false, \"link failed\");\n      }\n      std::vector<uint32_t> spirvData;\n      spv::SpvBuildLogger spvLogger;\n      glslang::GlslangToSpv(\n           program.getIntermediate(shaderStage), spirvData,\n          &spvLogger, &options);\n      std::vector<char> byteCode;\n      byteCode.resize(spirvData.size() *\n                      (sizeof(uint32_t) / sizeof(char)));\n      std::memcpy(byteCode.data(), spirvData.data(),\n                  byteCode.size());\n      return byteCode;\n    }\n    ```", "```cpp\n    const std::array<VkDynamicState, 1> dynamicStates = {\n        VK_DYNAMIC_STATE_VIEWPORT,\n    };\n    const VkPipelineDynamicStateCreateInfo dynamicState = {\n        .sType =\n          VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,\n        .dynamicStateCount =\n            static_cast<uint32_t>(dynamicStates.size()),\n        .pDynamicStates = dynamicStates.data(),\n    };\n    dynamicStates array contains only the VK_DYNAMIC_STATE_VIEWPORT value, but it may contain a much larger set of values from VkDynamicState.\n    ```", "```cpp\n    const VkGraphicsPipelineCreateInfo pipelineInfo = {\n        .sType=VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n        .stageCount = uint32_t(shaderStages.size()),\n        .pStages = shaderStages.data(),\n        .pVertexInputState = &vinfo,\n        .pInputAssemblyState = &inputAssembly,\n        .pViewportState = &viewportState,\n        .pRasterizationState = &rasterizer,\n        .pMultisampleState = &multisampling,\n        .pDepthStencilState = &depthStencilState, // Optional\n        .pColorBlendState = &colorBlending,\n        .pDynamicState = &dynamicState,\n        .layout = layout,\n        .renderPass = renderPass,\n        .basePipelineHandle = VK_NULL_HANDLE, // Optional\n        .basePipelineIndex = -1,  // Optional\n    };\n    VkPipeline gfxPipeline = VK_NULL_HANDLE;\n    VK_CHECK(vkCreateGraphicsPipelines(\n        device_, VK_NULL_HANDLE, 1, &pipelineInfo,\n        nullptr, &gfxPipeline));\n    ```", "```cpp\n    const VkSubmitInfo submitInfo = {\n        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n        .waitSemaphoreCount = 1,\n        .pWaitSemaphores = &imageAvailable,\n        .pWaitDstStageMask = submitStageMask,\n        .commandBufferCount = 1,\n        .pCommandBuffers = buffer,\n        .signalSemaphoreCount = 1,\n        .pSignalSemaphores = &imagePresented,\n    };\n    VK_CHECK(vkQueueSubmit(queue_, 1, &submitInfo, fence));\n    ```", "```cpp\nconst VkPresentInfoKHR presentInfo{\n    .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n    .waitSemaphoreCount = 1,\n    .pWaitSemaphores = &imageRendered_,\n    .swapchainCount = 1,\n    .pSwapchains = &swapchain_,\n    .pImageIndices = &imageIndex_,\n};\nVK_CHECK(vkQueuePresentKHR(presentQueue_, &presentInfo));\n```", "```cpp\n    #version 460\n    layout(location = 0) out vec4 outColor;\n    vec2 positions[3] = vec2[](\n        vec2(0.0, -0.5),\n        vec2(0.5, 0.5),\n        vec2(-0.5, 0.5)\n    );\n    vec3 colors[3] = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    void main() {\n       gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);\n       outColor = vec4(colors[gl_VertexIndex], 1.0);\n    }\n    ```", "```cpp\n    #version 460\n    layout(location = 0) in vec4 inColor;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n        outColor = inColor;\n    }\n    ```", "```cpp\n    int main(int argc, char** argv) {\n      initWindow(&window_);\n      // Create Context\n      VulkanCore::VulkanFeatureChain featureChain;\n      VulkanCore::Context::createDefaultFeatureChain(\n          featureChain);\n      VulkanCore::Context context(\n          (void*)glfwGetWin32Window(window_),\n          {},  // layers\n          {\n              VK_KHR_WIN32_SURFACE_EXTENSION_NAME,\n              VK_KHR_SURFACE_EXTENSION_NAME,\n              VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,\n          },  // instance extensions\n          {VK_KHR_SWAPCHAIN_EXTENSION_NAME},  // device\n                                              // extensions\n          VK_QUEUE_GRAPHICS_BIT,  // request a graphics\n                                  // queue only\n          featureChain, true);\n    ```", "```cpp\n      // Create Swapchain\n      const VkExtent2D extents = context.physicalDevice()\n                                     .surfaceCapabilities()\n                                     .minImageExtent;\n      context.createSwapchain(\n          VK_FORMAT_B8G8R8A8_UNORM,\n          VK_COLORSPACE_SRGB_NONLINEAR_KHR,\n          VK_PRESENT_MODE_FIFO_KHR, extents);\n      const VkRect2D renderArea = {\n          .offset = {.x = 0, .y = 0}, .extent = extents};\n    ```", "```cpp\n      // Create Shader Modules\n      const auto shadersPath =\n          std::filesystem::current_path() /\n          \"resources/shaders\";\n      const auto vertexShaderPath =\n          shadersPath / \"triangle.vert\";\n      const auto fragShaderPath =\n          shadersPath / \"triangle.frag\";\n      const auto vertexShader = context.createShaderModule(\n          vertexShaderPath.string(),\n          VK_SHADER_STAGE_VERTEX_BIT);\n      const auto fragShader = context.createShaderModule(\n          fragShaderPath.string(),\n          VK_SHADER_STAGE_FRAGMENT_BIT);\n      // Create Framebuffers\n      std::vector<std::shared_ptr<VulkanCore::Framebuffer>>\n          swapchain_framebuffers(\n              context.swapchain()->numberImages());\n    ```", "```cpp\n      // Create Render Pass\n      std::shared_ptr<VulkanCore::RenderPass> renderPass =\n          context.createRenderPass(\n              {context.swapchain()->texture(0)},\n              {VK_ATTACHMENT_LOAD_OP_CLEAR},\n              {VK_ATTACHMENT_STORE_OP_STORE},\n              {VK_IMAGE_LAYOUT_PRESENT_SRC_KHR},\n              VK_PIPELINE_BIND_POINT_GRAPHICS);\n    ```", "```cpp\n      // Create Graphics Pipeline\n      auto pipeline = context.createGraphicsPipeline(\n          VulkanCore::Pipeline::GraphicsPipelineDescriptor{\n              .vertexShader_ = vertexShader,\n              .fragmentShader_ = fragShader,\n              .viewport = context.swapchain()->extent(),\n              .depthTestEnable = false,\n          },\n          renderPass->vkRenderPass());\n      // Create Command Queue Manager\n      auto commandMgr = context.createGraphicsCommandQueue(\n          context.swapchain()->numberImages(),\n          context.swapchain()->numberImages());\n      // FPS Counter\n      EngineCore::FPSCounter fps(glfwGetTime());\n    ```", "```cpp\n      // Main Render Loop\n      while (!glfwWindowShouldClose(window_)) {\n        fps.update(glfwGetTime());\n        const auto texture =\n            context.swapchain()->acquireImage();\n        const auto swapchainImageIndex =\n            context.swapchain()->currentImageIndex();\n        // Create the framebuffer the first time we get\n        // here, once for each swapchain image\n        if (swapchain_framebuffers[swapchainImageIndex] ==\n            nullptr) {\n          swapchain_framebuffers[swapchainImageIndex] =\n              context.createFramebuffer(\n                  renderPass->vkRenderPass(), {texture},\n                  nullptr, nullptr);\n        }\n        auto commandBuffer =\n            commandMgr.getCmdBufferToBegin();\n    ```", "```cpp\n        // Begin Render Pass\n        constexpr VkClearValue clearColor{0.0f, 0.0f, 0.0f,\n                                          0.0f};\n        const VkRenderPassBeginInfo renderpassInfo = {\n            .sType =\n                VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n            .renderPass = renderPass->vkRenderPass(),\n            .framebuffer =\n                swapchain_framebuffers[swapchainImageIndex]\n                    ->vkFramebuffer(),\n            .renderArea = renderArea,\n            .clearValueCount = 1,\n            .pClearValues = &clearColor,\n        };\n        vkCmdBeginRenderPass(commandBuffer,\n                             &renderpassInfo,\n                             VK_SUBPASS_CONTENTS_INLINE);\n        pipeline->bind(commandBuffer);\n    ```", "```cpp\n        vkCmdDraw(commandBuffer, 3, 1, 0, 0);\n        vkCmdEndRenderPass(commandBuffer);\n        commandMgr.endCmdBuffer(commandBuffer);\n        constexpr VkPipelineStageFlags flags =\n            VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n        const auto submitInfo =\n            context.swapchain()->createSubmitInfo(\n                &commandBuffer, &flags);\n        commandMgr.submit(&submitInfo);\n        commandMgr.goToNextCmdBuffer();\n        // Present render output to the screen\n        context.swapchain()->present();\n        glfwPollEvents();\n        // Increment frame number\n        fps.incFrame();\n      }\n    ```", "```cpp\n      commandMgr.waitUntilAllSubmitsAreComplete();\n      glfwDestroyWindow(window_);\n      glfwTerminate();\n      return 0;\n    }\n    ```"]