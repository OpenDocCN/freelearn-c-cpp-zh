<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing Events, Custom Signals, and Slots</h1>
                </header>
            
            <article>
                
<p>This chapter introduces the concept of events. To maintain a working state, messages are passed around from the windowing system to the application, and within the application itself. These messages may contain data that could be useful when delivered at some destination. The messages being talked about here are referred to as events in Qt.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Events</li>
<li>Event handlers</li>
<li>Drag and drop</li>
<li>Custom signals</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Events</h1>
                </header>
            
            <article>
                
<p>In Qt, all events that occur are encapsulated in objects that inherit from the <kbd>QEvent</kbd> abstract class. An example of an event that has occurred is when a window has been resized or moved. The change in the state of the application will be noticed, and an appropriate <kbd>QEvent</kbd> object will be created to represent it.</p>
<p>The application event loop delivers this object to certain objects that inherit from <kbd>QObject</kbd>. This <kbd>QEvent</kbd> object is handled by means of a method call that will be invoked.</p>
<p>There are different types of events. When a mouse is clicked, a <kbd>QMouseEvent</kbd> object is created to represent this. The object will contain additional information, such as the specific mouse button that was clicked, together with the location where that event occurred.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event handlers</h1>
                </header>
            
            <article>
                
<p>All <kbd>QObjects</kbd> have an <kbd>event()</kbd> method that receives events. For <kbd>QWidgets</kbd>, this method will relay the event object to more specific event handlers. It is possible to redefine what an event handler should do by sub-classing the widget of interest and re-implementing that event handler.</p>
<p>Let's create an application where we shall re-implement an event handler.</p>
<p>Create a folder containing the <kbd>main.cpp</kbd>, <kbd>mainwindow.cpp</kbd>, and <kbd>mainwindow.h</kbd> files. The <kbd>mainwindow.h</kbd> file should contain the following code:</p>
<pre>#include &lt;QMainWindow&gt;<br/>#include &lt;QMoveEvent&gt;<br/>#include &lt;QMainWindow&gt;<br/><strong>class </strong>MainWindow: <strong>public </strong>QMainWindow {<br/>   Q_OBJECT<br/>   <strong>public</strong>:<br/>       MainWindow(QWidget *parent = 0);<br/>   <strong>protected</strong>:<br/>       <strong>void </strong>moveEvent(QMoveEvent *event);<br/>};</pre>
<p>In the preceding code, we have only sub-classed <kbd>QMainWindow</kbd>. A default constructor is declared and the event handler that we want to override, or re-implement, is the <kbd>moveEvent(QMoveEvent *event)</kbd> handler.</p>
<p>When a window is moved, the <kbd>event()</kbd> method of the <kbd>QMainWindow</kbd> object will be called. The event will be further encapsulated in a <kbd>QMoveEvent</kbd> object and forwarded to the <kbd>moveEvent()</kbd> event handler. Since we are interested in changing the behavior of the window when it is moved, we define our own <kbd>moveEvent()</kbd>.</p>
<p>Add the following lines of code to <kbd>mainwindow.cpp</kbd>:</p>
<pre>#include "mainwindow.h"<br/>MainWindow::MainWindow(QWidget *parent) : QMainWindow (parent){<br/>   setWindowTitle("Locate Window with timer");<br/>}<br/><strong>void </strong>MainWindow::moveEvent(QMoveEvent *event) {<br/>   <strong>int </strong>xCord = event-&gt;pos().x();<br/>   <strong>int </strong>yCord = event-&gt;pos().y();<br/>   QString text = QString::number(xCord) + ", " + QString::number(yCord);<br/>   statusBar()-&gt;showMessage(text);<br/>}</pre>
<p class="mce-root"><span>In the default constructor, the title of the window is set. The</span> event <span>object carries the coordinates of where the window currently is. Then </span><kbd>event-&gt;pos().x()</kbd> <span>is called to obtain the</span> <em>x </em>coordinate, likewise the <em>y</em> coordinate <span>is obtained by calling</span> <kbd>event-&gt;pos().y()</kbd><span>.</span></p>
<p>We convert <kbd>yCord</kbd> and <kbd>xCord</kbd> to text and store them in <kbd>text</kbd>. To access the status bar of the window, <kbd>statusBar()</kbd> is called and <kbd>text</kbd> is passed to the <kbd>showMessage()</kbd> method of the status bar object returned from the call to <kbd>statusBar()</kbd>.</p>
<p>The <kbd>main.cpp</kbd> file will contain, as usual, the following code:</p>
<pre>#include &lt;QApplication&gt;<br/>#include "mainwindow.h"<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]){<br/>   QApplication app(argc, argv);<br/>   MainWindow window;<br/>   window.resize(300, 300);<br/>   window.show();<br/>   <strong>return </strong>app.exec();<br/>}</pre>
<p>Compile and run the application. Note how the status bar changes when you move the application window.</p>
<p>Here are two screenshots showing how the status bar, located at the bottom of the window, changed when the window was moved.</p>
<p>The first state of the window is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-338 image-border" src="Images/dcc84278-9975-45c0-ae38-1367731496d0.png" style="width:25.50em;height:8.00em;" width="586" height="184"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When the window was moved, it later showed the output as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-339 image-border" src="Images/94e24190-451d-4f1a-8523-1fd3787c6caf.png" style="width:25.50em;height:8.17em;" width="582" height="186"/></p>
<p>Note the very bottom of the window and how it has changed. Continuously move the window around and observe how the status bar changes.</p>
<p>Let's write another example to improve our understanding of Qt events.</p>
<p>Apart from the events generated by the windowing system, other events are generated by Qt. The example here will illustrate how to tell Qt to send our application timer-based events at certain intervals.</p>
<p>As usual, we shall start with the three main files we usually create, that is, <kbd>main.cpp</kbd>, <kbd>mainwindow.cpp</kbd>, and <kbd>mainwindow.h</kbd>. The project builds upon the previous example.</p>
<p>In the <kbd>mainwindow.h</kbd> file, insert the following lines of codes:</p>
<pre>#ifndef MAINWINDOW_H<br/>#define MAINWINDOW_H<br/>#include &lt;QMainWindow&gt;<br/>#include &lt;QMoveEvent&gt;<br/>#include &lt;QMainWindow&gt;<br/>#include &lt;QStatusBar&gt;<br/>#include &lt;QLabel&gt;<br/><strong>class </strong>MainWindow: <strong>public </strong>QMainWindow {<br/>   Q_OBJECT<br/>   <strong>public</strong>:<br/>       MainWindow(QWidget *parent = 0);<br/>   <strong>protected</strong>:<br/>       <strong>void </strong>moveEvent(QMoveEvent *event);<br/>       <strong>void </strong>timerEvent(QTimerEvent *event);<br/>   <strong>private</strong>:<br/>       QLabel *currentDateTimeLabel;<br/>};<br/>#endif</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To receive the timer events, we shall implement our own <kbd>timerEvent</kbd> method, which will be the destination of the event that is given off when a timer expires. That is the essence of adding the void <kbd>timerEvent(QTimerEvent *event)</kbd> signature. The <kbd>QLabel</kbd> <kbd>currentDateTimeLabel</kbd> instance will be used to display the date and time.</p>
<p>In the <kbd>mainwindow.cpp</kbd> file, the default constructor is defined by the following code:</p>
<pre>#include &lt;QDateTime&gt;<br/>#include "mainwindow.h"<br/>MainWindow::MainWindow(QWidget *parent) : QMainWindow (parent){<br/> setWindowTitle("Locate Window");<br/> currentDateTimeLabel = <strong>new </strong>QLabel("Current Date and Time");<br/> currentDateTimeLabel-&gt;setAlignment(Qt::AlignCenter);<br/> setCentralWidget(currentDateTimeLabel);<br/> startTimer(1000);<br/>}</pre>
<p>The title for the window is set. An instance of <kbd>QLabel</kbd> is created and the call to <kbd>setAlignment</kbd> ensures that its content says centered. Then <kbd>currentDateTimeLabel</kbd> is passed to the <kbd>setCentralWidget()</kbd> method. The <kbd>startTimer(1000)</kbd> <span>method </span>starts a timer and will trigger a <kbd>QTimerEvent</kbd> object every second, represented by <kbd>1000</kbd>.</p>
<p>For each second, we now need to define what should happen by re-implementing the <kbd>timerEvent()</kbd> method.</p>
<p>Add the following code to <kbd>mainwindow.cpp</kbd>:</p>
<pre><strong>void </strong>MainWindow::timerEvent(QTimerEvent *event){<br/>   Q_UNUSED(event);<br/>   QString dateTime = QDateTime::currentDateTime().toString();<br/>   currentDateTimeLabel-&gt;setText(dateTime);<br/>}</pre>
<p>Every second, the <kbd>timerEvent()</kbd> will be called and passed an instance of <kbd>QTimerEvent</kbd>. The <kbd>Q_UNUSED (event)</kbd> is used to keep the compiler from complaining that <kbd>event()</kbd> is not being used in any way. A string representation of the current date and time is passed to <kbd>dateTime</kbd> and set as the text for the <kbd>currentDateTimeLabel</kbd> instance variable.</p>
<p>The <kbd>main.cpp</kbd> file remains the same as before. As a reference it is presented once more, as shown in the following code:</p>
<pre>#include &lt;QApplication&gt;<br/>#include "mainwindow.h"<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]){<br/>   QApplication app(argc, argv);<br/>   MainWindow window;<br/>   window.resize(300, 300);<br/>   window.show();<br/>   <strong>return </strong>app.exec();<br/>}</pre>
<p>Compile and run the application, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-340 image-border" src="Images/7c283a6a-eaf6-4f51-9148-708fddfb35ab.png" style="width:22.83em;height:9.08em;" width="588" height="234"/></p>
<p>The application will initially show the text, current date, and time, but after a second it should change <span>and display the updated time</span>. Every second that passes will cause text to be updated too.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drag and drop</h1>
                </header>
            
            <article>
                
<p>In this section, we shall put together a simple application that can handle drag and drop operations from an external source into an application.</p>
<p>The application is a small text editor. When a text file is dropped into the text area, it will open and insert the contents of that text file into the text area. The status of the window will show the number of characters in the text area, which is an instance of a <kbd>QTextEdit</kbd>.</p>
<p>This example application also illustrates a very important point about events. To customize a widget, one has to change the existing behavior of that widget by overriding its event handlers. Signals and slots are not considered when trying to customize widgets (except events).</p>
<p>To begin this project, perform the following steps:</p>
<ol>
<li>Create a new folder with a name of your choice</li>
<li>Create the <kbd>main.cpp</kbd>, <kbd>mainwindow.cpp</kbd>, <kbd>mainwindow.h</kbd>, <kbd>dragTextEdit.h</kbd>, and <kbd>dragTextEdit.cpp</kbd> files</li>
</ol>
<p>The <kbd>dragTextEdit.h</kbd> and <kbd>dragTextEdit.cpp</kbd> files will contain the definition of our custom widget. The <kbd>mainwindow.cpp</kbd> and <kbd>mainwindow.h</kbd> files will be used to construct the application.</p>
<p>Let's start with the custom <kbd>QTextEdit</kbd> widget. Insert the following lines of code into <kbd>dragTextEdit.h</kbd>:</p>
<pre>#ifndef TEXTEDIT_H<br/>#define TEXTEDIT_H<br/>#include &lt;QMoveEvent&gt;<br/>#include &lt;QMouseEvent&gt;<br/>#include &lt;QDebug&gt;<br/>#include &lt;QDateTime&gt;<br/>#include &lt;QTextEdit&gt;<br/>#include &lt;QMimeData&gt;<br/>#include &lt;QMimeDatabase&gt;<br/>#include &lt;QMimeType&gt;<br/><strong>class </strong>DragTextEdit: <strong>public </strong>QTextEdit<br/>{<br/>   Q_OBJECT<br/>   <strong>public</strong>:<br/>       <strong>explicit </strong>DragTextEdit(QWidget *parent = <strong>nullptr</strong>);<br/>   <strong>protected</strong>:<br/>       <strong>void </strong>dragEnterEvent(QDragEnterEvent *event) override;<br/>       <strong>void </strong>dragMoveEvent(QDragMoveEvent *event) override;<br/>       <strong>void </strong>dragLeaveEvent(QDragLeaveEvent *event) override;<br/>       <strong>void </strong>dropEvent(QDropEvent *event) override;<br/>};<br/>#endif</pre>
<p>The <kbd>DragTextEdit</kbd><span> custom widget</span>, inherits from <kbd>QTextEdit</kbd>. The default constructor is declared. In order to accept a drop event, we need to override the following methods to ensure proper behavior, as shown in the following code:</p>
<pre><strong>protected</strong>:<br/>   <strong>void </strong>dragEnterEvent(QDragEnterEvent *event) override;<br/>   <strong>void </strong>dragMoveEvent(QDragMoveEvent *event) override;<br/>   <strong>void </strong>dragLeaveEvent(QDragLeaveEvent *event) override;<br/>   <strong>void </strong>dropEvent(QDropEvent *event) override</pre>
<p>Now that the header file has been created, open the <kbd>dragTextEdit.cpp</kbd> file and add the definition of the default constructor, as shown in the following code:</p>
<pre>#include "dragTextEdit.h"<br/>DragTextEdit::DragTextEdit(QWidget *parent) : QTextEdit(parent)<br/>{<br/>   setAcceptDrops(<strong>true</strong>);<br/>}</pre>
<p>The <kbd>#include</kbd> directive imports the header file, after which the default constructor is defined. In order for our widget to accept a drop event, we need to say so by calling the <kbd>setAcceptDrops(true)</kbd> method.</p>
<p>We now have to add the definition of the methods we want to override. Add the following lines to <kbd>dragTextEdit.cpp</kbd>:</p>
<pre><strong>void </strong>DragTextEdit::dragMoveEvent(QDragMoveEvent *event)<br/>{<br/>   event-&gt;acceptProposedAction();<br/>}<br/><strong>void </strong>DragTextEdit::dragLeaveEvent(QDragLeaveEvent *event)<br/>{<br/>   event-&gt;accept();<br/>}<br/><strong>void </strong>DragTextEdit::dragEnterEvent(QDragEnterEvent *event)<br/>{   event-&gt;acceptProposedAction();<br/>}</pre>
<p>These event handlers deal with the major steps involved when there is going to be a drop action. The  <kbd>acceptProposedAction()</kbd> method is called on the event object in the <kbd>dragEnterEvent()</kbd> and <kbd>dragMoveEvent()</kbd> methods. These events are called when the cursor in drag mode is on the boundary of the widget that calls the <kbd>setAcceptDrops()</kbd> method. If you refuse to call the <kbd>acceptProposedAction()</kbd> method, the drop behavior may misbehave.</p>
<p>The <kbd>dragMoveEvent()</kbd> event handler is called when the cursor is within the widget of interest. But to define what happens when the drop event happens we need to define the <kbd>dropEvent()</kbd> handler.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Add the following code to <kbd>dragTextEdit.cpp</kbd>:</p>
<pre><strong>void </strong>DragTextEdit::dropEvent(QDropEvent *event)<br/>{<br/>   <strong>const </strong>QMimeData *mimeData = event-&gt;mimeData();<br/>   <strong>if </strong>(mimeData-&gt;hasText()) {<br/>       QTextStream out(stdout);<br/>       QFile file(mimeData-&gt;urls().at(0).path());<br/>       file.open(QFile::ReadOnly | QFile::Text);<br/>       QString contents = file.readAll();<br/>       setText(contents);<br/>       event-&gt;acceptProposedAction();<br/>   }<br/>   <strong>else</strong>{<br/>       event-&gt;ignore();<br/>   }<br/>}</pre>
<p>The mime data of the file, encapsulated within the event object, is obtained by calling <kbd>event-&gt;mimeData()</kbd>. If it contains text data, we extract the contents of the file and call the <kbd>setText()</kbd> method belonging to <kbd>QTextEdit</kbd>. This will populate the <kbd>DragTextEdit</kbd> instance with that text. Note the fact that we continue to call <kbd>event-&gt;acceptProposedAction()</kbd> to tell Qt that we have handled this event. If, on the other hand, <kbd>event-&gt;ignore()</kbd> is called, it is taken as an unwanted event or action and is, as such, propagated to a parent widget.</p>
<p>This completes the implementation of custom <kbd>QTextEdit</kbd>. Now we need to create <kbd>mainwindow.h</kbd> and <kbd>mainwindow.cpp</kbd> that will construct the main application window and make use of <kbd>DragTextEdit</kbd>.</p>
<p>Create the <kbd>mainwindow.h</kbd> file and insert the following code:</p>
<pre>#ifndef MAINWINDOW_H<br/>#define MAINWINDOW_H<br/>#include &lt;QMainWindow&gt;<br/>#include &lt;QLabel&gt;<br/>#include &lt;QMoveEvent&gt;<br/>#include &lt;QMouseEvent&gt;<br/>#include &lt;QVBoxLayout&gt;<br/>#include &lt;QDebug&gt;<br/>#include &lt;QDateTime&gt;<br/>#include &lt;QMainWindow&gt;<br/>#include &lt;QStatusBar&gt;<br/>#include "dragTextEdit.h"<br/><strong>class </strong>MainWindow: <strong>public </strong>QMainWindow<br/>{<br/>   Q_OBJECT<br/>   <strong>public</strong>:<br/>       MainWindow(QWidget *parent = 0);<br/>   <strong>private </strong>slots:<br/>       <strong>void </strong>updateStatusBar();<br/><strong>private</strong>:<br/>       DragTextEdit *slateDragTextEdit;<br/>};<br/>#endif</pre>
<p>The <kbd>QMainWindow</kbd>, <kbd>QLabel</kbd> class with the other usual classes are imported along with the <kbd>dragTextEdit.h</kbd> header file, which allows the inclusion of our custom class. A slot that will be called <strong>anytime text</strong> is added or removed from the <kbd>DragTextEdit</kbd> widget and is declared. Lastly, an instance of <kbd>DragTextEdit</kbd> is created.</p>
<p>Create and open the <kbd>mainwindow.cpp</kbd> file and insert the following code:</p>
<pre>#include "mainwindow.h"<br/>MainWindow::MainWindow(QWidget *parent) : QMainWindow (parent)<br/>{<br/>   QWidget *mainWidget = <strong>new </strong>QWidget;<br/>   QVBoxLayout *layout = <strong>new </strong>QVBoxLayout;<br/>   slateDragTextEdit = <strong>new </strong>DragTextEdit();<br/>   layout-&gt;addWidget(slateDragTextEdit);<br/>   mainWidget-&gt;setLayout(layout);<br/>   setCentralWidget(mainWidget);<br/>   statusBar()-&gt;showMessage(QString::number(0));<br/>   connect(slateDragTextEdit, SIGNAL(textChanged()), <strong>this</strong>, SLOT(updateStatusBar()));<br/>}<br/><strong>void </strong>MainWindow::updateStatusBar()<br/>{   <strong>int </strong>charCount = slateDragTextEdit-&gt;toPlainText().count();<br/>  statusBar()-&gt;showMessage(QString::number(charCount));<br/>}</pre>
<p>In the constructor,  <kbd>QWidget</kbd> and the <kbd>QVBoxLayout</kbd> objects are created to hold the main widget and layout. This widget will then be inserted with the call to <kbd>setCentralWdiget()</kbd>, as shown in the following code:</p>
<pre>slateDragTextEdit = <strong>new </strong>DragTextEdit();<br/>layout-&gt;addWidget(slateDragTextEdit);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>An instance of the  <kbd>DragTextEdit</kbd> custom class is created and passed to <kbd>slateDragTextEdit</kbd>. This widget is added to our main layout, as shown in the following code:</p>
<pre>statusBar()-&gt;showMessage(QString::number(0));</pre>
<p>The status bar of the window is set to <kbd>0</kbd>.</p>
<p>Anytime the <kbd>slateDragTextEdit</kbd> emits the <kbd>textChanged()</kbd> signal, a call to the <kbd>updateStatusBar()</kbd> slot will be called. In this slot, the characters within <kbd>slateDragTextEdit</kbd> will be extracted and counted. The status bar will thus be updated when a character is added to or removed from <kbd>slateDragTextEdit</kbd>.</p>
<p>The <kbd>main.cpp</kbd> file will contain only the following few lines of code to instantiate the window and display it:</p>
<pre>#include &lt;QApplication&gt;<br/>#include &lt;Qt&gt;<br/>#include "mainwindow.h"<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]){<br/>   QApplication app(argc, argv);<br/>   MainWindow window;<br/>   window.setWindowTitle("Drag Text Edit");<br/>   window.show();<br/>   <strong>return </strong>app.exec();<br/>}</pre>
<p>At the end of the project, you should have five (5) files in your folder. To compile the project, issue the following commands within the folder on the command line:</p>
<pre><strong>% qmake -project</strong></pre>
<p>Don't forget to add <kbd>QT += widgets</kbd> to the generated <kbd>.pro</kbd> file. The <kbd>.pro</kbd> file should contain the header files and program files. It should look like the following code:</p>
<pre># Input<br/>HEADERS += dragTextEdit.h mainwindow.h<br/>SOURCES += dragTextEdit.cpp main.cpp mainwindow.cpp</pre>
<p>Continue to issue the following commands:</p>
<pre><strong>% qmake</strong><br/><strong>% make</strong><br/><strong>% ./program_executable</strong></pre>
<p class="mce-root">A running program will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-341 image-border" src="Images/fff52ff4-47db-48f9-a15a-5483b1fbb4f3.png" style="width:20.17em;height:8.50em;" width="547" height="231"/></p>
<p>Since there are no characters when the program is executed, the status bar will read <span class="packt_screen">0</span>, as in the preceding screenshot.</p>
<p>Type some input into the text area and find out how, with every keystroke, the status bar is updated, as we have in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-343 image-border" src="Images/9eed95ff-fa3c-443f-8852-bd80c08131f6.png" style="width:19.08em;height:8.33em;" width="537" height="235"/></p>
<p>The example in this section illustrates how the text area can accept items external to the application. Drag and drop any  text (<kbd>.txt</kbd>) file, or any file containing text, onto the text area and see how its content is used to populate the textbox, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-344 image-border" src="Images/0d887219-00d7-4797-aab9-a5177730da6d.png" style="width:18.58em;height:11.08em;" width="551" height="328"/></p>
<p>From the preceding screenshot, the content of the <kbd>sometext.txt</kbd> file, which contains text, will be pasted into the text area as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-345 image-border" src="Images/2767e320-a8e6-4759-a354-a33fcb5ab6c3.png" style="width:21.67em;height:9.08em;" width="545" height="229"/></p>
<p>Experiment by removing the call to <kbd>acceptProposedAction()</kbd> and <kbd>accept()</kbd> and see how the drag and drop changes.</p>
<p>The last section of this chapter will touch on the creation of a custom signal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom signals</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we saw how to use slots and create custom slots to implement some functionality in response to a signal being emitted. Now, in this section, we will look at how to create custom signals that can be emitted and connected to other slots.</p>
<p>To create a custom signal, one needs to declare a method signature and mark it as a signal with the aid of the <kbd>Q_OBJECT</kbd> macro. When declared, signals don't have a return type, but they can accept parameters.</p>
<p>Let's get our feet wet with a project. As usual, a new folder should be created with the three (3) files, namely, <kbd>main.cpp</kbd>, <kbd>mainwindow.cpp</kbd>, and <kbd>mainwindow.h</kbd>.</p>
<p>In this example, we shall override <kbd>mousePressEvent</kbd> and emit a custom signal that will be connected to a slot to perform a number of updates on a window.</p>
<p>In the <kbd>mainwindow.h</kbd> file, insert the following lines of code:</p>
<pre>#ifndef MAINWINDOW_H<br/>#define MAINWINDOW_H<br/>#include &lt;QMainWindow&gt;<br/>#include &lt;QMoveEvent&gt;<br/>#include &lt;QMouseEvent&gt;<br/>#include &lt;QVBoxLayout&gt;<br/>#include &lt;QDebug&gt;<br/>#include &lt;QDateTime&gt;<br/>#include &lt;QStatusBar&gt;<br/>#include &lt;QLabel&gt;<br/><strong>class </strong>MainWindow: <strong>public </strong>QMainWindow<br/>{<br/>   Q_OBJECT<br/>   <strong>public </strong>slots:<br/>       <strong>void </strong>updateMousePosition(QPoint pos);<br/>   signals:<br/>       <strong>void </strong>mouseMoved(QPoint pos);<br/>   <strong>public</strong>:<br/>       MainWindow(QWidget *parent = 0);<br/>   <strong>protected</strong>:<br/>       <strong>void </strong>mousePressEvent(QMouseEvent *event);<br/>   <strong>private</strong>:<br/>       QLabel *mousePosition;<br/>       QWidget *windowCentralWidget;<br/>};<br/>#endif</pre>
<p>The custom signal here is declared with the following lines:</p>
<pre>signals:<br/>   <strong>void </strong>mouseMoved(QPoint pos);</pre>
<p>When this signal is emitted, it will pass an instance of <kbd>QPoint</kbd> as an argument. If we didn't want our signal to pass any argument, it would have been written with as <kbd>void</kbd> <kbd>mouseMoved()</kbd>.</p>
<div class="packt_tip packt_infobox">Custom signals should return nothing. The signal will be emitted when we re-implement the <kbd>mousePressEvent()</kbd> handler. </div>
<p>The <kbd>void updateMousePosition(QPoint pos)</kbd>, slot will be connected to the custom signal. Its definition is found in <kbd>mainwindow.cpp</kbd>.</p>
<p>The member pointer, <kbd>mousePosition</kbd>, will display the coordinates of the mouse when it is clicked.</p>
<p>In the <kbd>mainwindow.cpp</kbd> file, we shall define three (3) methods. These are the default constructor, the slot <kbd>updateMousePosition()</kbd>, and the <kbd>mousePressEvent() override</kbd> methods, as shown in the following code:</p>
<pre>#include "mainwindow.h"<br/><strong>void </strong>MainWindow::mousePressEvent(QMouseEvent *event){<br/>   emit mouseMoved(event-&gt;pos());<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>include</kbd> statement has to be at the very top of the file. In this <kbd>override</kbd> method, we obtain the coordinate where the mouse press event was generated by calling <kbd>event-&gt;pos()</kbd>.</p>
<p>The points <kbd>x</kbd> and <kbd>y</kbd> coordinates are obtained by calling <kbd>x()</kbd> and <kbd>y()</kbd>, respectively.</p>
<p>The <kbd>emit mouseMoved(event-&gt;pos())</kbd> line is used to emit the signal we declared in the header file. Furthermore, <kbd>event-&gt;pos()</kbd> will return a <kbd>QPoint</kbd> object, which conforms with the signature of the signal.</p>
<p>The following screenshot shows how the slot is defined in the <kbd>mainwindow.cpp</kbd> file:</p>
<pre><strong>void </strong>MainWindow::updateMousePosition(QPoint point){<br/>   <strong>int </strong>xCord = point.x();<br/>   <strong>int </strong>yCord = point.y();<br/>   QString text = QString::number(xCord) + ", " + QString::number(yCord);<br/>   mousePosition-&gt;setText(text);<br/>   statusBar()-&gt;showMessage(text);<br/>}</pre>
<p>The <kbd>QPoint</kbd> instance is received by the slot as a parameter. It's <kbd>x</kbd> and <kbd>y</kbd> coordinates are obtained by calling <kbd>point.x()</kbd> and <kbd>point.y()</kbd>, respectively. A <kbd>QString</kbd> instance <kbd>text</kbd> is used to concatenate the two values, <kbd>xCord</kbd> and <kbd>yCord</kbd>, into a longer string.</p>
<p>The <kbd>QLabel</kbd> instance, <kbd>mousePosition</kbd>, will be used to display this coordinate by calling its <kbd>setText()</kbd> method. Similarly, the status bar of the window will be set by calling <kbd>statusBar()-&gt;showMessage(text)</kbd>.</p>
<p>To do the plumbing of connecting the custom signal to our slot, we need to define the default constructor. Add the following lines to <kbd>mainwindow.cpp</kbd>:</p>
<pre class="mce-root">MainWindow::MainWindow(QWidget *parent) : QMainWindow (parent){<br/>   windowCentralWidget = new QWidget();<br/>   mousePosition = new QLabel("Mouse Position");<br/>   QVBoxLayout *innerLayout = new QVBoxLayout();<br/>   innerLayout-&gt;addWidget(mousePosition);<br/>   windowCentralWidget-&gt;setLayout(innerLayout);<br/>   setCentralWidget(windowCentralWidget);<br/>   statusBar()-&gt;showMessage("Ready");<br/>   connect(this, SIGNAL(mouseMoved(QPoint)), this, SLOT(updateMousePosition(QPoint)));<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Like we have been doing, the <kbd>windowCentralWidget</kbd> is used as the main widget in our application. <kbd>QLabel</kbd> is added to its layout, <kbd>innerLayout</kbd>. The status bar is given an initial value of <kbd>"Ready"</kbd>.</p>
<p>The <kbd>mouseMoved(QPoint)</kbd> signal is connected to the <kbd>updateMousePosition(QPoint)</kbd> slot.</p>
<p>In the <kbd>main.cpp</kbd> file, we shall instantiate our window and start the main event loop, as shown in the following code:</p>
<pre>#include &lt;QApplication&gt;<br/>#include &lt;Qt&gt;<br/>#include "mainwindow.h"<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]){<br/>   QApplication app(argc, argv);<br/>   MainWindow window;<br/>   window.resize(300, 300);<br/>   window.setWindowTitle("Hover Events");<br/>   window.show();<br/>   <strong>return </strong>app.exec();<br/>}</pre>
<p>Compile and run the executable, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-346 image-border" src="Images/d1da79e9-cc58-4aff-b720-ea53646bf223.png" style="width:21.83em;height:9.50em;" width="586" height="255"/></p>
<p>The status bar reads <span class="packt_screen">Ready</span>, while the <kbd>QLabel</kbd> making up the main widget in the window reads <span class="packt_screen">Mouse Position</span>. Now, click on any part within the window, and see the status bar and label change to display the coordinates of the mouse where the click was generated.</p>
<p>See the following screenshot as an example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-417 image-border" src="Images/51548fa3-126b-4072-8339-236bb3314c50.png" style="width:18.92em;height:20.33em;" width="589" height="634"/></p>
<p>The location of the cursor is <span class="packt_screen">145, 157</span>, where <span class="packt_screen">145</span> is on the <em>x</em> axi<em>s</em> and <span class="packt_screen">157</span> is on the <em>y</em> axis. When the cursor is moved, this value will not change. However, when the mouse is clicked, the <kbd>mouseMoved()</kbd> signal will be emitted along with the coordinates to update the screen. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter shed more light on how to use events in Qt. We understood the different situations that call for the use of events instead of the signal-slot mechanism. The first examples touched on how to override and implement custom event handlers. The events we implemented captured the position of a window and also redefined what should happen every second in an example application.</p>
<p>With the aid of events, we also implemented a simple drop event in the drag and drop action, where a simple text editor was created to accept files that are dropped in the text area. Lastly, the chapter illustrated how to create a custom signal that is emitted when an event occurs.</p>
<p>In <a href="bfdfd852-205f-4c4b-bb41-d798fdc865f7.xhtml">Chapter 6</a>, <em>Connecting Qt with Databases</em>, we will focus on the various ways to store data and retrieve it when building Qt applications.</p>


            </article>

            
        </section>
    </div>



  </body></html>