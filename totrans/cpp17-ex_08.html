<html><head></head><body>
        

                            
                    <h1 class="header-title">The Computer Plays</h1>
                
            
            
                
<p>In this chapter, we continue to work on the Othello and Noughts and Crosses games. The new part of this chapter is the computer playing against the human; instead of two human players, the computer plays against a human.</p>
<p>Topics we will cover in this chapter include:</p>
<ul>
<li class="mce-root">Game-theory reasoning. In both games, the human or the computer can make the first move, and we add code for the computer to play against the human.</li>
<li class="mce-root">In Othello, for each move, we scan the game grid and try to find the move that causes the highest number of the human's marks to be swapped.</li>
<li class="mce-root">In Noughts and Crosses, we try to find the position in the game grid that gives us the highest number of marks in a row, or, if the human is about to get five in row, we have to place the computer’s mark in a position that prevents that.</li>
<li class="mce-root">An introduction to random number generation. If the computer can choose between several equivalent moves, it shall randomly select one of the moves.</li>
<li class="mce-root">We continue to use C++ features such as classes, fields, and methods. We also continue to use Qt features such as windows and widgets.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Othello</h1>
                
            
            
                
<p>In the Othello application of this chapter, we reuse the <kbd>MainWindow</kbd> and <kbd>GameWidget</kbd> classes of the previous chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The OthelloWindow class</h1>
                
            
            
                
<p>The <kbd>OthelloWindow</kbd> class is rather similar to its counterpart in the previous chapter. However, in addition to the menus and items, the window of this version also holds submenus. The submenus will be added by calling the <kbd>addAction</kbd> method in the <kbd>OthelloWindow.cpp</kbd> file.</p>
<p><strong>OthelloWindow.h</strong></p>
<pre style="padding-left: 60px">#ifndef OTHELLOWINDOW_H 
#define OTHELLOWINDOW_H 
 
#include "..\MainWindow\MainWindow.h" 
#include "OthelloWidget.h" 
 
class OthelloWindow : public MainWindow { 
  Q_OBJECT 
 
  public: 
    OthelloWindow(QWidget *parentWidget = nullptr); 
    ~OthelloWindow(); 
 
    void closeEvent(QCloseEvent *eventPtr)
                   {m_othelloWidgetPtr-&gt;closeEvent(eventPtr);} 
 
  private: 
    OthelloWidget* m_othelloWidgetPtr; 
}; 
 
#endif // OTHELLOWINDOW_H </pre>
<p>The <kbd>OthelloWindow.cpp</kbd> file holds the definitions of the methods of the <kbd>OthelloWindow</kbd> class.</p>
<p><strong>OthelloWindow.cpp</strong></p>
<pre style="padding-left: 60px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
#include &lt;QtWidgets&gt; </pre>
<p>The title of the window has been changed to <kbd>Othello Advanced</kbd>:</p>
<pre style="padding-left: 60px">OthelloWindow::OthelloWindow(QWidget *parentWidget /*= nullptr*/) 
 :MainWindow(parentWidget) { 
  setWindowTitle(tr("Othello Advanced")); 
  resize(1000, 500); 
 
  m_othelloWidgetPtr = new OthelloWidget(this); 
  setCentralWidget(m_othelloWidgetPtr); 
 
  { QMenu* gameMenuPtr = menuBar()-&gt;addMenu(tr("&amp;Game")); 
    connect(gameMenuPtr, SIGNAL(aboutToShow()), 
            this, SLOT(onMenuShow())); </pre>
<p>There are two submenus of the Game menu, <kbd>Computer Starts</kbd> and <kbd>Human Starts</kbd>:</p>
<pre style="padding-left: 60px">    { QMenu* computerStartsMenuPtr = 
        gameMenuPtr-&gt;addMenu(tr("&amp;Computer Starts")); 
      connect(computerStartsMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); </pre>
<p>The <kbd>Computer Starts</kbd> submenu holds the two items <kbd>Computer Black</kbd> and <kbd>Computer White</kbd>:</p>
<pre>      addAction(computerStartsMenuPtr, tr("Computer &amp;Black"), 
                SLOT(onComputerStartsBlack()), 0, 
                tr("Computer Black"), nullptr, 
                tr("Computer Black"), 
                LISTENER(isComputerStartsBlackEnabled)); 
 
      addAction(computerStartsMenuPtr, tr("Computer &amp;White"), 
                SLOT(onComputerStartsWhite()), 0, 
                tr("Computer White"), nullptr, 
                tr("Computer White"), 
                LISTENER(isComputerStartsWhiteEnabled)); 
    } </pre>
<p>The <kbd>Human Starts</kbd> submenu holds two items, <kbd>Human Black</kbd> and <kbd>Human White</kbd>:</p>
<pre style="padding-left: 30px">    { QMenu* humanStartsMenuPtr = 
        gameMenuPtr-&gt;addMenu(tr("&amp;Human Starts")); 
      connect(humanStartsMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); 
 
      addAction(humanStartsMenuPtr, tr("Human &amp;Black"), 
                SLOT(onHumanStartsBlack()), 0, tr("Human Black"), 
                nullptr, tr("Human Black"), 
                LISTENER(isHumanStartsBlackEnabled)); 
 
      addAction(humanStartsMenuPtr, tr("Human &amp;White"), 
                SLOT(onHumanStartsWhite()), 0, tr("Human White"), 
                nullptr, tr("Human White"), 
                LISTENER(isHumanStartsWhiteEnabled)); 
    } 
 
    gameMenuPtr-&gt;addSeparator(); 
 
    addAction(gameMenuPtr, tr("&amp;Quit the Game"), 
              SLOT(onQuit()), 
              QKeySequence(Qt::CTRL + Qt::Key_Q), tr("Quit Game"), 
              nullptr, tr("Quit the Game"), 
              LISTENER(isQuitEnabled)); 
 
    addAction(gameMenuPtr, tr("E&amp;xit"),i 
              SLOT(onExit()), QKeySequence::Quit); 
  } 
} 
 
OthelloWindow::~OthelloWindow() { 
  delete m_othelloWidgetPtr; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The OthelloWidget Class</h1>
                
            
            
                
<p>The <kbd>OthelloWidget</kbd> class holds the functionality of Othello. It allows the computer to play against a human:</p>
<p><strong>OthelloWidget.h</strong></p>
<pre style="padding-left: 60px">#ifndef OTHELLOWIDGET_H 
#define OTHELLOWIDGET_H 
 
#include "..\MainWindow\GameWidget.h" 
 
#define ROWS    8 
#define COLUMNS 8 
 
enum Mark {Empty = 0, Black, White}; 
 
class OthelloWidget : public GameWidget { 
  Q_OBJECT 
 
  public: 
    OthelloWidget(QWidget* parentWidget); 
 
    void mouseMark(int row, int column); 
    void drawMark(QPainter&amp; painter, 
                  const QRect&amp; markRect, int mark); 
 
  public slots: 
    DEFINE_LISTENER(OthelloWidget, isComputerStartsBlackEnabled); 
    DEFINE_LISTENER(OthelloWidget, isComputerStartsWhiteEnabled); 
    DEFINE_LISTENER(OthelloWidget, isHumanStartsBlackEnabled); 
    DEFINE_LISTENER(OthelloWidget, isHumanStartsWhiteEnabled); 
 
    void onComputerStartsBlack(); 
    void onComputerStartsWhite(); 
    void onHumanStartsBlack(); 
    void onHumanStartsWhite(); 
 
  private: 
    bool checkWinner(); 
    void turn(int row, int column, Mark mark); 
    void calculateComputerMove(); 
    void calculateTurns(int row, int column, Mark mark, 
                        QSet&lt;QPair&lt;int,int&gt;&gt;&amp; totalSet, 
                        int&amp; neighbours); 
    Mark m_humanMark, m_computerMark; 
}; 
 
#endif // OTHELLOWIDGET_H </pre>
<p>The <kbd>OthelloWidget.cpp</kbd> file holds the definitions of the methods of the <kbd>OthelloWidget</kbd> class:</p>
<p><strong>OthelloWidget.cpp</strong></p>
<pre style="padding-left: 60px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
 
#include &lt;QTime&gt; 
#include &lt;CTime&gt; 
#include &lt;CAssert&gt; 
using namespace std; 
 
OthelloWidget::OthelloWidget(QWidget* parentWidget) 
 :GameWidget(ROWS, COLUMNS, parentWidget) { 
  // Empty. 
} </pre>
<p>The <kbd>isComputerStartsBlackEnabled</kbd>, <kbd>isComputerStartsWhiteEnabled</kbd>, <kbd>isHumanStartsBlackEnabled</kbd>, and <kbd>isHumanStartsWhiteEnabled</kbd> methods are called before the <kbd>Computer Starts</kbd> and <kbd>Human Starts</kbd> submenus. They become enabled if there is no game in progress:</p>
<pre style="padding-left: 60px">bool OthelloWidget::isComputerStartsBlackEnabled() { 
  return !isGameInProgress(); 
} 
 
bool OthelloWidget::isComputerStartsWhiteEnabled() { 
  return !isGameInProgress(); 
} 
 
bool OthelloWidget::isHumanStartsBlackEnabled() { 
  return !isGameInProgress(); 
} 
 
bool OthelloWidget::isHumanStartsWhiteEnabled() { 
  return !isGameInProgress(); 
} </pre>
<p>The <kbd>onComputerStartsBlack</kbd> and <kbd>onComputerStartsWhite</kbd> methods are called when the user selects one of the items of the <kbd>Computer Starts</kbd> submenu. They set the computer mark to black or white, start the game by setting the mark in the middle of the game grid, and update the window:</p>
<pre style="padding-left: 60px">void OthelloWidget::onComputerStartsBlack() { 
  setGameInProgress(true); 
  set(ROWS / 2, COLUMNS / 2, m_computerMark = Black); 
  m_humanMark = White; 
  update(); 
} 
 
void OthelloWidget::onComputerStartsWhite() { 
  setGameInProgress(true); 
  set(ROWS / 2, COLUMNS / 2, m_computerMark = White); 
  m_humanMark = Black; 
  update(); 
} </pre>
<p>The <kbd>onHumanStartsBlack</kbd> and <kbd>onHumanStartsWhite</kbd> methods are called when the user selects one of the items of the <kbd>Human Starts</kbd> submenu. They set the computer mark to black or white and update the window. They do not set any mark in the game grid. Instead, the human is to make the first move:</p>
<pre style="padding-left: 60px">void OthelloWidget::onHumanStartsBlack() { 
  setGameInProgress(true); 
  m_humanMark = Black; 
  m_computerMark = White; 
  update(); 
} 
 
void OthelloWidget::onHumanStartsWhite() { 
  setGameInProgress(true); 
  m_humanMark = White; 
  m_computerMark = Black; 
  update(); 
} </pre>
<p>The <kbd>mouseMark</kbd> method is called when the user clicks one empty position in the game grid. We start by setting the next mark at the position, and turn the marks as a result of the move:</p>
<pre style="padding-left: 60px">void OthelloWidget::mouseMark(int row, int column) { 
  set(row, column, m_humanMark); 
  turn(row, column, m_humanMark); 
  update(); </pre>
<p>If the human's move did not cause the game grid to become full, we call to <kbd>calculateComputerMove</kbd> to set the computer mark to the position, causing the maximum number of opposite marks to be turned. We then update the window and call <kbd>checkWinner</kbd> again to decide if the computer move caused the game grid to become full:</p>
<pre style="padding-left: 60px">  if (!checkWinner()) { 
    calculateComputerMove(); 
    update(); 
    checkWinner(); 
  } 
} </pre>
<p>The <kbd>drawMark</kbd> method is called when a position in the game grid needs to be repainted. It draws the mark in the same way as in the previous chapter:</p>
<pre style="padding-left: 60px">void OthelloWidget::drawMark(QPainter&amp; painter, 
                             const QRect&amp; markRect, int mark) { 
  painter.setPen(Qt::black); 
  painter.drawRect(markRect); 
  painter.fillRect(markRect, Qt::lightGray); 
 
  switch (mark) { 
    case Black: 
      painter.setPen(Qt::black); 
      painter.setBrush(Qt::black); 
      painter.drawEllipse(markRect); 
      break; 
 
    case White: 
      painter.setPen(Qt::white); 
      painter.setBrush(Qt::white); 
      painter.drawEllipse(markRect); 
      break; 
 
    case Empty: 
      break; 
  } 
} </pre>
<p>The <kbd>checkWinner</kbd> method of this chapter is also similar to its counterpart in the previous chapter. It checks whether the game grid is full. If it is full, the winner is announced, or else it is a draw:</p>
<pre style="padding-left: 60px">bool OthelloWidget::checkWinner() { 
  int blacks = 0, whites = 0, empties = 0; 
 
  for (int row = 0; row &lt; ROWS; ++row) { 
    for (int column = 0; column &lt; COLUMNS; ++column) { 
      switch (get(row, column)) { 
        case Black: 
          ++blacks; 
          break; 
 
        case White: 
          ++whites; 
          break; 
 
        case Empty: 
          ++empties; 
          break; 
      } 
    } 
  } 
 
  if (empties == 0) { 
    QMessageBox messageBox(QMessageBox::Information, 
                           tr("Victory"), QString()); 
    QString text; 
 
    if (blacks &gt; whites) { 
      text.sprintf("The Winner: %s.", (m_computerMark == Black) 
                                      ? "Computer" : "Human"); 
    } 
    else if (whites &gt; blacks) { 
      text.sprintf("The Winner: %s.", (m_computerMark == White) 
                                      ? "Computer" : "Human"); 
    } 
    else { 
      text.sprintf("A Draw."); 
    } 
 
    messageBox.setText(text); 
    messageBox.setStandardButtons(QMessageBox::Ok); 
    messageBox.exec(); 
    setGameInProgress(false); 
    clearGrid(); 
    update(); 
 
    return true; 
  } 
 
  return false; 
} </pre>
<p>The <kbd>calculateComputerMove</kbd> method calculates the move of the computer that generates the highest number of turned opposite marks. We iterate through the computer marks and, for each mark, call <kbd>calculateTurns</kbd> to obtain the maximum number of opposite marks that would be turned if we placed the marks at that position. For each mark, we also obtain the number of neighbours, which is valuable if we do not find any marks to turn.</p>
<p>The <kbd>maxTurnSetSize</kbd> and <kbd>maxNeighbours</kbd> fields hold the maximum number of turnable marks and neighbours; <kbd>maxTurnSetList</kbd> holds a list of the maximum sets of positions of turnable marks, and <kbd>maxNeighboursList</kbd> holds a list of the maximum number of neighbours:</p>
<pre style="padding-left: 60px">void OthelloWidget::calculateComputerMove() { 
  int maxTurnSetSize = 0, maxNeighbours = 0; 
  QList&lt;QSet&lt;QPair&lt;int,int&gt;&gt;&gt; maxTurnSetList; 
  QList&lt;QPair&lt;int,int&gt;&gt; maxNeighboursList; </pre>
<p>We iterate through all the positions in the game grid. For each empty position, we obtain the number of opposite marks to be turned if we were to place our mark in that position. We also obtain the number of opposite neighbours:</p>
<pre style="padding-left: 60px">  for (int row = 0; row &lt; ROWS; ++row) { 
    for (int column = 0; column &lt; COLUMNS; ++column) { 
      if (get(row, column) == Empty) { 
        QSet&lt;QPair&lt;int,int&gt;&gt; turnSet; 
        int neighbours = 0; 
        calculateTurns(row, column, m_computerMark, 
                       turnSet, neighbours); 
        int turnSetSize = turnSet.size(); </pre>
<p>If we find a set of turnable marks that is larger than the current maximum set, we set the <kbd>maxTurnSetSize</kbd> field to the size of the new turnable set, insert the current position in the set, clear <kbd>maxTurnSetList</kbd> (since we do not want its previous smaller sets), and add the new set.</p>
<p>We add the current set for the sake of simplicity; it is easier to add it to the set than to store it in any other way:</p>
<pre>        if (turnSetSize &gt; maxTurnSetSize) { 
          maxTurnSetSize = turnSetSize; 
          turnSet.insert(QPair&lt;int,int&gt;(row, column)); 
          maxTurnSetList.clear(); 
          maxTurnSetList.append(turnSet); 
        } </pre>
<p>If the new set is not empty and of equal size to the maximum set, then we simply add it to <kbd>maxTurnSetList</kbd>:</p>
<pre>        else if ((turnSetSize &gt; 0) &amp;&amp; 
                 (turnSetSize == maxTurnSetSize)) { 
          turnSet.insert(QPair&lt;int,int&gt;(row, column)); 
          maxTurnSetList.append(turnSet); 
        } </pre>
<p>We also check the number of neighbours of the current position. We work in the same way as in the <kbd>turnable</kbd> set case. If the neighbours are more than the maximum number of neighbours, we clear <kbd>maxNeighboursList</kbd> and add the new position:</p>
<pre>        if (neighbours &gt; maxNeighbours) { 
          maxNeighbours = neighbours; 
          maxNeighboursList.clear(); 
          maxNeighboursList.append(QPair&lt;int,int&gt;(row, column)); 
        } </pre>
<p>If there is at least one neighbour, and the neighbours is equal to the maximum number of neighbours, we add it to the <kbd>maxNeighboursList</kbd> list:</p>
<pre style="padding-left: 60px">        else if ((neighbours &gt; 0) &amp;&amp; 
                 (neighbours == maxNeighbours)) { 
          maxNeighboursList.append(QPair&lt;int,int&gt;(row, column)); 
        } 
      } 
    } 
  } </pre>
<p>If there is at least one position where we will turn at least one opposite mark, we choose it. If there are several positions that will turn the same amount of opposite marks, we randomly select one of them. We use the C standard functions <kbd>srand</kbd>, <kbd>rand</kbd>, and <kbd>time</kbd> to obtain a random integer number. </p>
<p class="mce-root">The random number generator algorithm takes a start value and then generates a sequence of random numbers. The <kbd>srand</kbd> function initializes the generator with a start value, and then <kbd>rand</kbd> is called repeatedly in order to obtain new random numbers. In order to not call <kbd>srand</kbd> with the same start value every time (which would result in the same random number sequence), we call <kbd>srand</kbd> with the result of a call to the <kbd>time</kbd> standard C function, which returns the number of seconds since January 1, 1970. In this way, the random number generator is initialized with a new value for each game, and we obtain a new sequence of random numbers by repeatedly calling <kbd>rand</kbd>:</p>
<pre style="padding-left: 60px">  if (maxTurnSetSize &gt; 0) { 
    srand(time(NULL)); 
    int index = rand() % maxTurnSetList.size(); 
    QSet&lt;QPair&lt;int,int&gt;&gt; maxTurnSet = maxTurnSetList[index]; </pre>
<p>When we have obtained the set of positions to be turned, we iterate through the set and set the computer mark to all its positions:</p>
<pre style="padding-left: 60px">    for (QPair&lt;int,int&gt; position : maxTurnSet) { 
      int row = position.first, column = position.second; 
      set(row, column, m_computerMark); 
    } 
  } </pre>
<p>If there is no position that would cause opposite marks to be turned, we look at the neighbours instead. In the same way, we randomly select one of the positions with the maximum number of neighbours. Note that we do not need to iterate through any set; in this case, we only set one mark:</p>
<pre style="padding-left: 60px">  else { 
    assert(!maxNeighboursList.empty()); 
    srand(time(NULL)); 
    int index = rand() % maxNeighboursList.size(); 
    QPair&lt;int,int&gt; position = maxNeighboursList[index]; 
    int row = position.first, column = position.second; 
    set(row, column, m_computerMark); 
  } 
} </pre>
<p>The <kbd>turn</kbd> method is called when the human has made a move. It calls <kbd>calculateMark</kbd> to obtain a set of turnable opposite marks, and then iterates through the set and sets each position in the game grid:</p>
<pre style="padding-left: 60px">void OthelloWidget::turn(int row, int column, Mark mark) { 
  QSet&lt;QPair&lt;int,int&gt;&gt; turnSet; 
  calculateMark(row, column, mark, turnSet); 
 
  for (QPair&lt;int,int&gt; pair : turnSet) { 
    int row = pair.first, column = pair.second; 
    set(row, column, mark); 
  } 
} </pre>
<p>The <kbd>calculateTurns</kbd> method calculates the set of turnable opposite marks and number of neighbours of the given position:</p>
<pre style="padding-left: 60px">void OthelloWidget::calculateTurns(int row, int column, 
                  Mark playerMark,QSet&lt;QPair&lt;int,int&gt;&gt;&amp; totalSet, 
                  int&amp; neighbours) { </pre>
<p>Each integer pair in <kbd>directionArray</kbd> refers to a direction in accordance with the compass rising:</p>
<pre style="padding-left: 60px">  QPair&lt;int,int&gt; directionArray[] = 
    {QPair&lt;int,int&gt;(-1, 0),   // North 
     QPair&lt;int,int&gt;(-1, 1),   // Northeast 
     QPair&lt;int,int&gt;(0, 1),    // East 
     QPair&lt;int,int&gt;(1, 1),    // Southeast 
     QPair&lt;int,int&gt;(1, 0),    // South 
     QPair&lt;int,int&gt;(1, -1),   // Southwest 
     QPair&lt;int,int&gt;(0, -1),   // West 
     QPair&lt;int,int&gt;(-1, -1)}; // Northwest </pre>
<p>The size of an array can be decided by dividing its total size (in bytes) by the size of its first value:</p>
<pre style="padding-left: 60px">  int arraySize = 
    (sizeof directionArray) / (sizeof directionArray[0]); 
 
  neighbours = 0; 
  int opponentMark = (playerMark == Black) ? White : Black; </pre>
<p>We iterate through the directions and, for each direction, keep moving as long as we find the mark of the opponent:</p>
<pre style="padding-left: 60px">  for (int index = 0; index &lt; arraySize; ++index) { 
    QPair&lt;int,int&gt; pair = directionArray[index]; </pre>
<p>The <kbd>row</kbd> and <kbd>column</kbd> fields hold the current row and column as long as we iterate through a direction:</p>
<pre style="padding-left: 30px">    int rowStep = pair.first, columnStep = pair.second, 
        currRow = row, currColumn = column; </pre>
<p>First, we check if we have a neighbor of the opponent mark in the closest position. If we have not reached one of the borders of the game grid, and if there is an opponent mark in the position, we increase <kbd>neighbours</kbd>:</p>
<pre style="padding-left: 60px">    if (((row + rowStep) &gt;= 0) &amp;&amp; ((row + rowStep) &lt; ROWS) &amp;&amp; 
        ((column + rowStep) &gt;= 0) &amp;&amp; 
        ((column + columnStep) &lt; COLUMNS) &amp;&amp; 
        (get(row + rowStep, column + rowStep) == opponentMark)) { 
      ++neighbours; 
    } 
 </pre>
<p>We gather the marks we find during the iteration in <kbd>directionSet</kbd>:</p>
<pre style="padding-left: 30px">    QSet&lt;QPair&lt;int,int&gt;&gt; directionSet; 
 
    while (true) { 
      currRow += rowStep; 
      currColumn += columnStep; </pre>
<p>If we reach one of the borders of the game grid, or if we find an empty position, we break the iteration:</p>
<pre style="padding-left: 30px">      if ((currRow &lt; 0) || (currRow == ROWS) || 
          (currColumn &lt; 0) || (currColumn == COLUMNS) || 
          (get(currRow, currColumn) == Empty)) { 
        break; 
      } </pre>
<p>If we find the player's mark, we add the <kbd>directionSet</kbd> to the total set and break the iterations:</p>
<pre style="padding-left: 30px">      else if (get(currRow, currColumn) == playerMark) { 
        totalSet += directionSet; 
        break; 
      } </pre>
<p>If we do find the player's mark or an empty position, we have found the opponent's mark, and we add its position to the direction set:</p>
<pre style="padding-left: 60px">      else { 
        directionSet.insert(QPair&lt;int,int&gt;(row, column)); 
      } 
    } 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>As always, the <kbd>main</kbd> function creates an application, shows the window, and executes the application until the user closes the window or selects the Exit menu item.</p>
<p><strong>Main.cpp</strong></p>
<pre style="padding-left: 60px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  OthelloWindow othelloWindow; 
  othelloWindow.show(); 
  return application.exec(); 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Noughts and Crosses</h1>
                
            
            
                
<p>The Noughts and Crosses application of this chapter is based on the version in the previous chapter. The difference is that in this version the computer plays against a human.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The NaCWindow class</h1>
                
            
            
                
<p>The <kbd>NaCWindow</kbd> class is similar to the <kbd>OthelloWindow</kbd> class in the previous section (NaC is an abbreviation for Noughts and Crosses). It adds two submenus to the game menu, where the computer or human makes the first move and selects a nought or cross:</p>
<p><strong>NaCWindow.h</strong></p>
<pre style="padding-left: 60px">#ifndef NACWINDOW_H 
#define NACWINDOW_H 
 
#include "..\MainWindow\MainWindow.h" 
#include "NaCWidget.h" 
 
class NaCWindow : public MainWindow { 
  Q_OBJECT 
 
  public: 
    NaCWindow(QWidget *parentWidget = nullptr); 
    ~NaCWindow(); 
 
  public: 
    void closeEvent(QCloseEvent *eventPtr)
                   {m_nacWidgetPtr-&gt;closeEvent(eventPtr);} 
 
  private: 
    NaCWidget* m_nacWidgetPtr; 
}; 
 
#endif // NACWINDOW_H </pre>
<p>The <kbd>NaCWindow.cpp</kbd> file holds the definitions of the methods of the <kbd>NaCWindow</kbd> class:</p>
<p><strong>NaCWindow.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWindow.h" 
#include &lt;QtWidgets&gt; </pre>
<p>The title has been changed to <kbd>Noughts and Crosses Advanced</kbd>:</p>
<pre style="padding-left: 60px">NaCWindow::NaCWindow(QWidget *parentWidget /*= nullptr*/) 
 :MainWindow(parentWidget) { 
  setWindowTitle(tr("Noughts and Crosses Advanced")); 
  resize(1000, 500); 
 
  m_nacWidgetPtr = new NaCWidget(this); 
  setCentralWidget(m_nacWidgetPtr); 
 
  { QMenu* gameMenuPtr = menuBar()-&gt;addMenu(tr("&amp;Game")); 
    connect(gameMenuPtr, SIGNAL(aboutToShow()), 
            this, SLOT(onMenuShow())); 
 
    { QMenu* computerStartsMenuPtr = 
        gameMenuPtr-&gt;addMenu(tr("&amp;Computer Starts")); 
      connect(computerStartsMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); 
 
      addAction(computerStartsMenuPtr, tr("Computer &amp;Nought"), 
                SLOT(onComputerStartsNought()), 0, 
                tr("Computer Nought"), nullptr, 
                tr("Computer Nought"), 
                LISTENER(isComputerStartsNoughtEnabled)); 
 
        addAction(computerStartsMenuPtr, tr("Computer &amp;Cross"), 
                  SLOT(onComputerStartsCross()), 0, 
                  tr("Computer Cross"), nullptr, 
                  tr("Computer Cross"), 
                  LISTENER(isComputerStartsCrossEnabled)); 
    } 
 
    { QMenu* humanStartsMenuPtr = 
        gameMenuPtr-&gt;addMenu(tr("&amp;Human Starts")); 
      connect(humanStartsMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); 
 
      addAction(humanStartsMenuPtr, tr("Human &amp;Nought"), 
                SLOT(onHumanNought()), 0, tr("Human Nought"), 
                nullptr, tr("Human Nought"), 
                LISTENER(isHumanNoughtEnabled)); 
 
      addAction(humanStartsMenuPtr, tr("Human &amp;Cross"), 
                SLOT(onHumanCross()), 0, tr("Human Cross"), 
                nullptr, tr("Human Cross"), 
                LISTENER(isHumanCrossEnabled)); 
    } 
 
    gameMenuPtr-&gt;addSeparator(); 
 
    addAction(gameMenuPtr, tr("&amp;Quit the Game"), 
              SLOT(onQuit()), 
              QKeySequence(Qt::CTRL + Qt::Key_Q), tr("Quit Game"), 
              nullptr, tr("Quit the Game"), 
              LISTENER(isQuitEnabled)); 
 
    addAction(gameMenuPtr, tr("E&amp;xit"), 
              SLOT(onExit()), QKeySequence::Quit); 
  } 
} 
 
NaCWindow::~NaCWindow() { 
  delete m_nacWidgetPtr; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The NaCWidget class</h1>
                
            
            
                
<p>The <kbd>NaCWidget</kbd> class has been improved compared to the version in the previous chapter. It holds the <kbd>calculateComputerMove</kbd> and <kbd>calculateMarkValue</kbd> methods for the computer to play against the human:</p>
<p><strong>NaCWidget.h</strong></p>
<pre style="padding-left: 60px">#ifndef NACWIDGET_H 
#define NACWIDGET_H 
 
#include "..\MainWindow\GameWidget.h" 
 
#define ROWS    26 
#define COLUMNS 26 
 
enum Mark {Empty = 0, Nought, Cross}; 
 
class NaCWidget : public GameWidget { 
  Q_OBJECT 
 
  public: 
    NaCWidget(QWidget* parentWidget); 
 
    void mouseMark(int row, int column); 
    void drawMark(QPainter&amp; painter, 
                  const QRect&amp; markRect, int mark); 
 
  public slots: 
    DEFINE_LISTENER(NaCWidget, isComputerStartsNoughtEnabled); 
    DEFINE_LISTENER(NaCWidget, isComputerStartsCrossEnabled); 
    DEFINE_LISTENER(NaCWidget, isHumanStartsNoughtEnabled); 
    DEFINE_LISTENER(NaCWidget, isHumanStartsCrossEnabled); 
 
    void onComputerStartsNought(); 
    void onComputerStartsCross(); 
    void onHumanStartsNought(); 
    void onHumanStartsCross(); 
 
  private: 
    bool checkWinner(int row, int column, Mark mark); 
    int countMarks(int row, int column, int rowStep, 
                   int columnStep, Mark mark); 
    void calculateComputerMove(int&amp; row, int &amp;column); 
    double calculateMarkValue(int row, int column, Mark mark); 
 
    Mark m_humanMark, m_computerMark; 
}; 
 
#endif // NACWIDGET_H </pre>
<p>The <kbd>NaCWidget.cpp</kbd> file holds the definitions of the methods of the <kbd>NaCWidget</kbd> class:</p>
<p><strong>NaCWidget.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWidget.h" 
#include &lt;CTime&gt; 
#include &lt;CAssert&gt; 
 
NaCWidget::NaCWidget(QWidget* parentWidget) 
 :GameWidget(ROWS, COLUMNS, parentWidget) { 
  // Empty. 
} </pre>
<p>The <kbd>isComputerStartsNoughtEnabled</kbd>, <kbd>isComputerStartsCrossEnabled</kbd>, <kbd>isHumanStartsNoughtEnabled</kbd>, and <kbd>isHumanStartsCrossEnabled</kbd> methods decide whether to enable the <kbd>Computer Nought</kbd>, <kbd>Computer Cross</kbd>, <kbd>Human Nought</kbd>, and <kbd>Human cross</kbd> menu items. They are all enabled when there is no game in progress:</p>
<pre style="padding-left: 60px">bool NaCWidget::isComputerStartsNoughtEnabled() { 
  return !isGameInProgress(); 
} 
 
bool NaCWidget::isComputerStartsCrossEnabled() { 
  return !isGameInProgress(); 
} 
 
bool NaCWidget::isHumanStartsNoughtEnabled() { 
  return !isGameInProgress(); 
} 
 
bool NaCWidget::isHumanStartsCrossEnabled() { 
  return !isGameInProgress(); 
} </pre>
<p>The <kbd>onComputerStartsNought</kbd>, <kbd>onComputerStartsCross</kbd>, <kbd>onHumanStartsNought</kbd>, and <kbd>onHumanStartsCross</kbd> are called when the user selects the <kbd>Computer Noughts</kbd>, <kbd>Computer Cross</kbd>, <kbd>Human Noughts</kbd>, and <kbd>Human Cross</kbd> menu items. They set the game in progress, set the computer and human marks to nought and cross, and update the window. In cases where the computer makes the first move, it is placed in the middle of the game grid in order to use the game grid as effectively as possible:</p>
<pre style="padding-left: 60px">void NaCWidget::onComputerStartsNought() { 
  setGameInProgress(true); 
  set(ROWS /2, COLUMNS / 2, m_computerMark = Nought); 
  m_humanMark = Cross; 
  update(); 
} 
 
void NaCWidget::onComputerStartsCross() { 
  setGameInProgress(true); 
  set(ROWS /2, COLUMNS / 2, m_computerMark = Cross); 
  m_humanMark = Nought; 
  update(); 
} 
 
void NaCWidget::onHumanStartsNought() { 
  setGameInProgress(true); 
  m_computerMark = Cross; 
  m_humanMark = Nought; 
  update(); 
} 
 
void NaCWidget::onHumanStartsCross() { 
  setGameInProgress(true); 
  m_computerMark = Nought; 
  m_humanMark = Cross; 
  update(); 
} </pre>
<p>The <kbd>mouseMark</kbd> method is called when the human player clicks an empty position in the game grid. We start by setting the mark to the position and updating the window:</p>
<pre style="padding-left: 60px">void NaCWidget::mouseMark(int row, int column) { 
  set(row, column, m_humanMark); 
  update(); </pre>
<p>If the human's move did not cause them to win the game, we calculate the next move of the computer, set the position, check if the move has caused the computer to win the game, and update the window:</p>
<pre style="padding-left: 60px">  if (!checkWinner(row, column, m_humanMark)) { 
    calculateComputerMove(row, column); 
    set(row, column, m_computerMark); 
    checkWinner(row, column, m_computerMark); 
    update(); 
  } 
} </pre>
<p>The <kbd>drawMark</kbd> method is called when a position needs to be repainted. It is similar to its counterpart in the previous chapter. It draws a nought or a cross:</p>
<pre style="padding-left: 60px">void NaCWidget::drawMark(QPainter&amp; painter, 
                         const QRect&amp; markRect, int mark) { 
  painter.setPen(Qt::black); 
 
  switch (mark) { 
    case Nought: 
      painter.drawEllipse(markRect); 
      break; 
 
    case Cross: 
      painter.drawLine(markRect.topLeft(), 
                       markRect.bottomRight()); 
      painter.drawLine(markRect.topRight(), 
                       markRect.bottomLeft()); 
      break; 
 
    case Empty: 
      break; 
  } 
} </pre>
<p>The <kbd>checkWinner</kbd> method is also similar to its counterpart in the previous chapter. It decides if the latest move has caused five marks in a row. If it has, the winner is announced:</p>
<pre style="padding-left: 60px">bool NaCWidget::checkWinner(int row, int column, Mark mark) { 
  if ((countMarks(row, column, -1, 0, mark) &gt;= 5) || 
      (countMarks(row, column, 0, -1, mark) &gt;= 5) || 
      (countMarks(row, column, -1, 1, mark) &gt;= 5) || 
      (countMarks(row, column, 1, 1, mark) &gt;= 5)) { 
    QMessageBox messageBox(QMessageBox::Information, 
                           tr("Victory"), QString()); 
    QString text; 
    text.sprintf("The Winner: %s.", 
                 (mark == m_computerMark) ? "Computer" : "Human"); 
 
    messageBox.setText(text); 
    messageBox.setStandardButtons(QMessageBox::Ok); 
    messageBox.exec(); 
    setGameInProgress(false); 
    clearGrid(); 
    update(); 
    return true; 
  } 
 
  return false; 
} </pre>
<p>The <kbd>countMarks</kbd> method counts the number of marks in a row. It has been improved compared to its counterpart in the previous chapter. In this version, we also count the highest possible number of marks in a row that the move can lead to. Since <kbd>countMarks</kbd> is called by <kbd>calculateComputerMove</kbd>, we need to know how many marks in a row the move may lead to:</p>
<pre style="padding-left: 60px">double NaCWidget::countMarks(int row, int column, int rowStep, 
                        int columnStep, Mark mark) { </pre>
<p>The <kbd>markCount</kbd> field holds the number of marks in a row that we would get if we placed our mark at the given position; <kbd>freeCount</kbd> holds the number of marks in a row we possibly can get if we continue to add marks in that row. The reason is that the computer will not add marks to a row that cannot become five in a row:</p>
<pre style="padding-left: 60px">  double markCount = 0; 
  int freeCount = 0; </pre>
<p>We iterate through the game grid in the given direction:</p>
<pre style="padding-left: 60px">  { bool marked = true; 
    int currentRow = row, currentColumn = column; 
 
    while ((currentRow &gt;= 0) &amp;&amp; (currentRow &lt; ROWS) &amp;&amp; 
           (currentColumn &gt;= 0) &amp;&amp; (currentColumn &lt; COLUMNS)) { </pre>
<p>As long as we find the mark, we increase both <kbd>markCount</kbd> and <kbd>freeCount</kbd>:</p>
<pre style="padding-left: 60px">      if (get(currentRow, currentColumn) == mark) { 
        if (marked) { 
          ++markCount; 
        } 
 
        ++freeCount; 
      } </pre>
<p>If we find an empty position, we add <kbd>0.4</kbd> (since a free row is better than a closed row) to the <kbd>markCount</kbd>, and continue to increase the <kbd>freeCount</kbd>:</p>
<pre style="padding-left: 60px">      else if (get(currentRow, currentColumn) == Empty) { 
        if (marked) { 
          markCount += 0.4; 
        } 
 
        marked = false; 
        ++freeCount; 
      } </pre>
<p>If we find neither the computer mark nor an empty position, we must have found the human's mark, and we break the iteration:</p>
<pre style="padding-left: 60px">      else { 
        break; 
      } </pre>
<p>At the end of each iteration, we add the row and columns steps to the current row and column:</p>
<pre style="padding-left: 60px">      currentRow += rowStep; 
      currentColumn += columnStep; 
    } 
  } </pre>
<p>We perform a similar iteration in the opposite direction. The only difference is that we subtract the row and columns steps at the end of each iteration, instead of adding to them:</p>
<pre style="padding-left: 60px">  { bool marked = true; 
    int currentRow = row + rowStep, 
        currentColumn = column + columnStep; 
 
    while ((currentRow &gt;= 0) &amp;&amp; (currentRow &lt; ROWS) &amp;&amp; 
           (currentColumn &gt;= 0) &amp;&amp; (currentColumn &lt; COLUMNS)) { 
      if (get(currentRow, currentColumn) == mark) { 
        if (marked) { 
          ++markCount; 
        } 
      } 
      else if (get(currentRow, currentColumn) == Empty) { 
        if (marked) { 
          markCount += 0.4; 
        } 
 
        marked = false; 
        ++freeCount; 
      } 
      else { 
        break; 
      } 
 
      currentRow -= rowStep; 
      currentColumn -= columnStep; 
    } 
  } </pre>
<p>If the free count is at least five, we return the mark count. If it is less than five, we return zero, since we cannot obtain five in a row in this direction:</p>
<pre style="padding-left: 90px">  return (freeCount &gt;= 5) ? markCount : 0; 
} </pre>
<p>The <kbd>calculateComputerMove</kbd> method calculates the computer move that causes the maximum numbers of marks in a row. We count both the computer and human's rows, since we may be facing a situation where we need to stop the human from winning instead of maximizing the computer's chance to win.</p>
<p>The <kbd>maxComputerValue</kbd> and <kbd>maxHumanValue</kbd> fields hold the maximum number of marks in a row that we have found so far. The <kbd>maxComputerList</kbd> and <kbd>maxHumanList</kbd> hold the position that causes the maximum number of marks in a row for the computer and the human:</p>
<pre style="padding-left: 60px">void NaCWidget::calculateComputerMove(int&amp; maxRow,int &amp;maxColumn){ 
  double maxComputerValue = 0, maxHumanValue = 0; 
  QList&lt;QPair&lt;int,int&gt;&gt; maxComputerList, maxHumanList; </pre>
<p>We iterate through the game grid. For each empty position, we try to set the computer and human mark and see how many marks in a row that would cause:</p>
<pre style="padding-left: 60px">  for (int row = 0; row &lt; ROWS; ++row) { 
    for (int column = 0; column &lt; COLUMNS; ++column)  { 
      if (get(row, column) == Empty) { 
        set(row, column, m_computerMark); </pre>
<p>We obtain the maximum number of marks in a row for the computer and human mark. If it is larger than the previous maximum number, we clear the list and add the position to the list:</p>
<pre>        { double computerValue = 
            calculateMarkValue(row, column, m_computerMark); 
 
          if (computerValue &gt; maxComputerValue) { 
            maxComputerValue = computerValue; 
            maxComputerList.clear(); 
            maxComputerList.append(QPair&lt;int,int&gt;(row, column)); 
          } </pre>
<p>If the new number of marks in a row is greater than zero or equals the maximum number, we just add the position:</p>
<pre>          else if ((computerValue &gt; 0) &amp;&amp; 
                   (computerValue == maxComputerValue)) { 
            maxComputerList.append(QPair&lt;int,int&gt;(row, column)); 
          } 
        } </pre>
<p>We do the same for the human mark as the computer mark:</p>
<pre>        set(row, column, m_humanMark); 
 
        { double humanValue = 
            calculateMarkValue(row, column, m_humanMark); 
 
          if (humanValue &gt; maxHumanValue) { 
            maxHumanValue = humanValue; 
            maxHumanList.clear(); 
            maxHumanList.append(QPair&lt;int,int&gt;(row, column)); 
          } 
          else if ((humanValue &gt; 0) &amp;&amp; 
                   (humanValue == maxHumanValue)) { 
            maxHumanList.append(QPair&lt;int,int&gt;(row, column)); 
          } 
        } </pre>
<p>Finally, we reset the position to the empty value:</p>
<pre style="padding-left: 60px">        set(row, column, Empty); 
      } 
    } 
  } </pre>
<p>The computer or human must have at least one in a row for a position:</p>
<pre style="padding-left: 60px">  assert(!maxComputerList.empty() &amp;&amp; !maxHumanList.empty()); </pre>
<p>If the computer's value is at least two and larger the human value, or if the human value is less the four, we randomly select one of the computer's maximum moves:</p>
<pre style="padding-left: 60px">  if ((maxComputerValue &gt;= 2) &amp;&amp; 
      ((maxComputerValue &gt;= maxHumanValue) || 
       (maxHumanValue &lt; 3.8))) { 
    srand(time(NULL)); 
    QPair&lt;int,int&gt; pair = 
      maxComputerList[rand() % maxComputerList.size()]; 
    maxRow = pair.first; 
    maxColumn = pair.second; 
  } </pre>
<p>However, if the computer cannot make at least two in a row, or if the human is about to get five in a row, we randomly select one of the human's maximum moves:</p>
<pre style="padding-left: 60px">  else { 
    srand(time(NULL)); 
    QPair&lt;int,int&gt; pair = 
      maxHumanList[rand() % maxHumanList.size()]; 
    maxRow = pair.first; 
    maxColumn = pair.second; 
  } 
} </pre>
<p>The <kbd>calculateMarkValue</kbd> method calculates the maximum number of marks in a row that the given position may cause by calculating the larger value of its four directions:</p>
<pre style="padding-left: 60px">double NaCWidget::calculateMarkValue(int row, int column, 
                                     Mark mark) { 
  return qMax(qMax(countMarks(row, column, -1, 0, mark), 
                   countMarks(row, column, 0, -1, mark)), 
              qMax(countMarks(row, column, -1, 1, mark), 
                   countMarks(row, column, 1, 1, mark))); 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>Finally, the <kbd>main</kbd> function works at it always does in the Qt applications:</p>
<p><strong>Main.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWidget.h" 
#include "NaCWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  NaCWindow mainWindow; 
  mainWindow.show(); 
  return application.exec(); 
} 
 </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have developed more advanced versions of the games of the previous chapter. In both Othello and Noughts and Crosses, we have added code that lets the computer play against the human. In Othello, we looked for the position in the game grid that would cause the highest number of the opponent’s marks to be changed. In Noughts and Crosses, we searched for the move that gave the computer the highest possible number of marks in a row, preferably five in a row. However, we also had to search for the potential number of marks in a row for the opponent, and prevent their next move if it led to victory. Now, I suggest that you sit back and enjoy a couple of rounds with the computer before moving on to the next chapter.</p>
<p>In the next chapter, we will start developing a <strong>Domain-Specific Language</strong> (<strong>DSL</strong>), which is a language intended for a specific domain. We will develop a DSL for specifying the drawings of graphical objects, such as lines, rectangles, ellipses, and text, as well as the settings for color, font, pen and brush style, and alignment. We will also write a viewer that displays the graphical objects.</p>


            

            
        
    </body></html>